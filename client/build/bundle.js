(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/dave/lh2/angular2/study-tracker/client/app/main.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
require("bootstrap");
var angular2_1 = require('angular2/angular2');
var router_1 = require('angular2/router');
var router_2 = require('angular2/router');
var router_3 = require('angular2/router');
var users_1 = require('./users');
var signin_1 = require('./signin');
var plan_1 = require('./plan');
var Firebase = require('firebase/lib/firebase-web.js');
var StudyTracker = (function () {
    function StudyTracker(router) {
        this.router = router;
        this.fbRef = new Firebase('https://study-tracker.firebaseio.com');
        console.log("main.ts: in StudyTracker constructor");
    }
    StudyTracker.prototype.registerUserBlock = function (userComp) {
        this.userBlock = userComp;
        userComp.registerParent(this, this.fbRef);
        // NOTE: here we use the router *name* not the actual route URL!
        this.router.navigate(['./Plan']); // SignIn
    };
    StudyTracker = __decorate([
        angular2_1.Component({
            selector: 'app'
        }),
        angular2_1.View({
            directives: [router_3.RouterLink, router_3.RouterOutlet, users_1.UserBlock],
            template: "\n        <user-block (initevent)=\"registerUserBlock($event)\"> </user-block>\n\n        <div class=\"container\">\n          <router-outlet></router-outlet>\n        </div>\n        "
        }),
        router_1.RouteConfig([
            { path: '/plan', as: 'Plan', component: plan_1.Plan },
            { path: '/signin', as: 'SignIn', component: signin_1.SignIn }
        ]), 
        __metadata('design:paramtypes', [router_1.Router])
    ], StudyTracker);
    return StudyTracker;
})();
// similar to jQuery(document).ready(), but doesn't work in old IE browsers
document.addEventListener('DOMContentLoaded', function () {
    angular2_1.bootstrap(StudyTracker, 
    // List of universally injectable providers
    [
        router_1.ROUTER_PROVIDERS,
        angular2_1.provide(router_2.LocationStrategy, { useClass: router_2.HashLocationStrategy })
    ]);
}, false);

},{"./plan":"/Users/dave/lh2/angular2/study-tracker/client/app/plan.ts","./signin":"/Users/dave/lh2/angular2/study-tracker/client/app/signin.ts","./users":"/Users/dave/lh2/angular2/study-tracker/client/app/users.ts","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js","bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/dist/js/npm.js","firebase/lib/firebase-web.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/plan.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
var Plan = (function () {
    function Plan() {
        console.log("plan.ts: in constructor");
        var data = [{ id: 1, color: 'blue', name: 'Science' },
            { id: 2, color: 'red', name: 'Math' },
            { id: 3, color: '#AA22BB', name: 'English' },
            { id: 4, color: '#222', name: 'Art' }];
        jQuery("#category-select").typeahead({
            source: data,
            minLength: 0,
            showHintOnFocus: true,
            addItem: { id: -1, name: '(Add class)' },
            formatter: function (item) {
                var html = this.highlighter(this.displayText(item));
                if (item.color) {
                    html = '<div class="dropdown-color-box" style="background-color:' + item.color + '"> </div>' + html;
                }
                else {
                    html = '<div class="dropdown-color-box"> </div>' + html;
                }
                return html;
            },
            afterSelect: function (item) {
                console.log("Selected", item);
                if (item.id === -2) {
                    jQuery("#category-add-name").text(item.name);
                    jQuery("#category-add").show();
                }
            },
            updater: function (item) {
                if (item.id === -1) {
                    return { id: -2, name: this.$element.val() };
                }
                else {
                    return item;
                }
            }
        });
        // Fix for bug in IOS as reported:
        // http://stackoverflow.com/questions/12190783/why-doesnt-bootstrap-button-dropdown-work-on-ios
        jQuery('body').on('touchstart.dropdown', '.dropdown-menu', function (e) {
            e.stopPropagation();
        });
    }
    Plan = __decorate([
        angular2_1.Component({
            selector: 'plan'
        }),
        angular2_1.View({
            template: "\n          <input type=\"text\" data-provide=\"typeahead\" id=\"category-select\" placeholder=\"Enter a class\">\n\n          <div class=\"collapse\" id=\"category-add\">\n  \t    Select a color for new class <b id=\"category-add-name\"></b>\n          </div>\n        "
        }), 
        __metadata('design:paramtypes', [])
    ], Plan);
    return Plan;
})();
exports.Plan = Plan;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/signin.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
var router_1 = require('angular2/router');
var SignIn = (function () {
    function SignIn() {
    }
    SignIn = __decorate([
        angular2_1.Component({
            selector: 'signin'
        }),
        angular2_1.View({
            directives: [router_1.RouterLink],
            template: "\n        <h1> Please sign in </h1>\n        "
        }), 
        __metadata('design:paramtypes', [])
    ], SignIn);
    return SignIn;
})();
exports.SignIn = SignIn;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/users.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
exports.User = {};
var UserBlock = (function () {
    function UserBlock() {
        console.log("users.ts: in UserBlock constructor");
        // Only initialize locally instatiated data here 
        // (angular2-dependent data has not yet been fully initialized)
        this.initevent = new angular2_1.EventEmitter();
        this.parent = null; // will be set by the parent
        this.fbRef = null;
        this.user = exports.User;
        // Initialize
        this.updateUserData(null);
        console.log("users.ts: finished UserBlock constructor");
    }
    UserBlock.prototype.onInit = function () {
        // onInit() is a angular2 lifecycle method called 
        // automatically after angular2 has completed initialization
        console.log("onInit: for Users Component", this);
        this.initevent.next(this); // send initevent to parent component
    };
    UserBlock.prototype.registerParent = function (parent, fbRef) {
        var self = this;
        this.fbRef = fbRef;
        this.parent = parent;
        // Register the authentication callback
        this.fbRef.onAuth(function (authData) {
            self.updateUserData(authData);
        });
    };
    UserBlock.prototype.login = function (provider) {
        var self = this;
        if (provider === 'facebook') {
            alert("Sorry, Facebook signin not yet supported");
            return;
        }
        this.fbRef.authWithOAuthPopup(provider, function (error, authData) {
            if (error) {
                if (error.code === "TRANSPORT_UNAVAILABLE") {
                    // Could be due to not allowing pop-ups in this env
                    self.fbRef.authWithOAuthRedirect("google", function (error) {
                        if (error) {
                            console.log("Login Failed!", error);
                        }
                    });
                }
                else {
                    console.log("Login Failed!", error);
                }
            }
            else if (authData) {
                self.updateUserData(authData); // accelerate the process a little
                console.log("Authenticated successfully with payload:", authData);
            }
            else {
                console.log("Login apparently failed, but without error info");
            }
        });
    };
    UserBlock.prototype.logout = function () {
        this.fbRef.unauth();
        this.updateUserData(null);
    };
    UserBlock.prototype.updateUserData = function (authData) {
        this.user._authData = authData;
        var provider;
        if (authData) {
            provider = authData.provider;
        }
        else {
            provider = null;
        }
        switch (provider) {
            case 'google':
                this.user.isLoggedIn = true;
                this.user.firstName = this.user._authData.google.cachedUserProfile.given_name;
                this.user.lastName = this.user._authData.google.cachedUserProfile.family_name;
                this.user.profileImageURL = this.user._authData.google.profileImageURL;
                break;
            default:
                this.user.isLoggedIn = false;
                this.user.firstName = null;
                this.user.lastName = null;
                this.user.profileImageURL = null;
                break;
        }
    };
    UserBlock = __decorate([
        angular2_1.Component({
            selector: 'user-block',
            events: ['initevent'] // NOTE that event names must be all lower case
        }),
        angular2_1.View({
            template: "\n      <div class=\"container\">\n        <div class=\"signin-form\">\n          <div [hidden]=\"user.isLoggedIn\">\n            <h3 class=\"form-signin-heading\">Please sign in using:</h3>\n            <button class=\"btn btn-lg btn-primary btn-block\" (click)=\"login('google')\">  Google  </button>\n            <button class=\"btn btn-lg btn-primary btn-block\" (click)=\"login('facebook')\">Facebook</button>\n          </div>\n\n          <div [hidden]=\"!user.isLoggedIn\">\n            Hello {{user.firstName}} <img src=\"{{user.profileImageURL}}\"/> \n            <a class=\"btn\" (click)=\"logout()\">\n              Sign out\n            </a>\n          </div>\n        </div>\n      </div>\n      "
        }), 
        __metadata('design:paramtypes', [])
    ], UserBlock);
    return UserBlock;
})();
exports.UserBlock = UserBlock;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./core'));
__export(require('./profile'));
__export(require('./lifecycle_hooks'));
__export(require('./bootstrap'));

},{"./bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/bootstrap.js","./core":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/core.js","./lifecycle_hooks":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/lifecycle_hooks.js","./profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/profile.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/bootstrap.js":[function(require,module,exports){
'use strict';/**
 * This file is only used for dart applications and for internal examples
 * that compile with both JavaScript and Dart.
 */
var bootstrap_1 = require('angular2/src/core/bootstrap');
exports.bootstrap = bootstrap_1.bootstrap;

},{"angular2/src/core/bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/core.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
 * @module
 * @description
 * Starting point to import all public core APIs.
 */
__export(require('./src/core/metadata'));
__export(require('./src/core/util'));
__export(require('./src/core/di'));
__export(require('./src/core/pipes'));
__export(require('./src/core/facade'));
__export(require('./src/core/application'));
__export(require('./src/core/bootstrap'));
__export(require('./src/core/services'));
__export(require('./src/core/linker'));
__export(require('./src/core/lifecycle'));
__export(require('./src/core/zone'));
__export(require('./src/core/render'));
__export(require('./src/core/directives'));
__export(require('./src/core/forms'));
__export(require('./src/core/debug'));
__export(require('./src/core/change_detection'));

},{"./src/core/application":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js","./src/core/bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js","./src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","./src/core/debug":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug.js","./src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","./src/core/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives.js","./src/core/facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade.js","./src/core/forms":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js","./src/core/lifecycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/lifecycle.js","./src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","./src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js","./src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js","./src/core/services":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services.js","./src/core/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util.js","./src/core/zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/lifecycle_hooks.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Defines interfaces to be implemented by directives when they need to hook into the change
 * detection mechanism.
 */

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Observable.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _utilSymbol_observable = require('./util/Symbol_observable');

var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */

var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is
     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
     * of a succesful completion.
     */

    function Observable(subscribe) {
        _classCallCheck(this, Observable);

        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }

    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature.
    /**
     * @static
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @returns {Observable} a new cold observable
     * @description creates a new cold Observable by calling the Observable constructor
     */

    /**
     * @method lift
     * @param {Operator} the operator defining the operation to take on the observable
     * @returns {Observable} a new observable with the Operator applied
     * @description creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     */

    Observable.prototype.lift = function lift(operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };

    /**
     * @method Symbol.observable
     * @returns {Observable} this instance of the observable
     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     */

    Observable.prototype[_utilSymbol_observable2['default']] = function () {
        return this;
    };

    /**
     * @method subscribe
     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @returns {Subscription} a subscription reference to the registered handlers
     * @description registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     */

    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
        var subscriber = undefined;
        if (observerOrNext && typeof observerOrNext === "object") {
            if (observerOrNext instanceof _Subscriber2['default']) {
                subscriber = observerOrNext;
            } else {
                subscriber = new _Subscriber2['default'](observerOrNext);
            }
        } else {
            var next = observerOrNext;
            subscriber = _Subscriber2['default'].create(next, error, complete);
        }
        subscriber.add(this._subscribe(subscriber));
        return subscriber;
    };

    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @returns {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */

    Observable.prototype.forEach = function forEach(next) {
        var _this = this;

        return new Promise(function (resolve, reject) {
            _this.subscribe(next, reject, resolve);
        });
    };

    Observable.prototype._subscribe = function _subscribe(subscriber) {
        return this.source._subscribe(this.operator.call(subscriber));
    };

    return Observable;
})();

exports['default'] = Observable;
Observable.create = function (subscribe) {
    return new Observable(subscribe);
};
module.exports = exports['default'];
},{"./Subscriber":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js","./util/Symbol_observable":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/Symbol_observable.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subject.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('./Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _Subscription = require('./Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _subjectsSubjectSubscription = require('./subjects/SubjectSubscription');

var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);

var subscriptionAdd = _Subscription2['default'].prototype.add;
var subscriptionRemove = _Subscription2['default'].prototype.remove;
var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
var subscriberNext = _Subscriber2['default'].prototype.next;
var subscriberError = _Subscriber2['default'].prototype.error;
var subscriberComplete = _Subscriber2['default'].prototype.complete;
var _subscriberNext = _Subscriber2['default'].prototype._next;
var _subscriberError = _Subscriber2['default'].prototype._error;
var _subscriberComplete = _Subscriber2['default'].prototype._complete;
var _observableSubscribe = _Observable3['default'].prototype._subscribe;

var Subject = (function (_Observable) {
    _inherits(Subject, _Observable);

    function Subject() {
        _classCallCheck(this, Subject);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        _Observable.call.apply(_Observable, [this].concat(args));
        this.observers = [];
        this.isUnsubscribed = false;
        this.dispatching = false;
        this.errorSignal = false;
        this.completeSignal = false;
    }

    Subject.create = function create(source, destination) {
        return new BidirectionalSubject(source, destination);
    };

    Subject.prototype.lift = function lift(operator) {
        var subject = new BidirectionalSubject(this, this.destination || this);
        subject.operator = operator;
        return subject;
    };

    Subject.prototype._subscribe = function _subscribe(subscriber) {
        if (subscriber.isUnsubscribed) {
            return;
        } else if (this.errorSignal) {
            subscriber.error(this.errorInstance);
            return;
        } else if (this.completeSignal) {
            subscriber.complete();
            return;
        } else if (this.isUnsubscribed) {
            throw new Error("Cannot subscribe to a disposed Subject.");
        }
        this.observers.push(subscriber);
        return new _subjectsSubjectSubscription2['default'](this, subscriber);
    };

    Subject.prototype.add = function add(subscription) {
        subscriptionAdd.call(this, subscription);
    };

    Subject.prototype.remove = function remove(subscription) {
        subscriptionRemove.call(this, subscription);
    };

    Subject.prototype.unsubscribe = function unsubscribe() {
        this.observers = void 0;
        subscriptionUnsubscribe.call(this);
    };

    Subject.prototype.next = function next(value) {
        if (this.isUnsubscribed) {
            return;
        }
        this.dispatching = true;
        this._next(value);
        this.dispatching = false;
        if (this.errorSignal) {
            this.error(this.errorInstance);
        } else if (this.completeSignal) {
            this.complete();
        }
    };

    Subject.prototype.error = function error(_error) {
        if (this.isUnsubscribed || this.completeSignal) {
            return;
        }
        this.errorSignal = true;
        this.errorInstance = _error;
        if (this.dispatching) {
            return;
        }
        this._error(_error);
        this.unsubscribe();
    };

    Subject.prototype.complete = function complete() {
        if (this.isUnsubscribed || this.errorSignal) {
            return;
        }
        this.completeSignal = true;
        if (this.dispatching) {
            return;
        }
        this._complete();
        this.unsubscribe();
    };

    Subject.prototype._next = function _next(value) {
        var index = -1;
        var observers = this.observers.slice(0);
        var len = observers.length;
        while (++index < len) {
            observers[index].next(value);
        }
    };

    Subject.prototype._error = function _error(error) {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0;
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].error(error);
        }
        this.isUnsubscribed = false;
    };

    Subject.prototype._complete = function _complete() {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0; // optimization
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].complete();
        }
        this.isUnsubscribed = false;
    };

    return Subject;
})(_Observable3['default']);

exports['default'] = Subject;

var BidirectionalSubject = (function (_Subject) {
    _inherits(BidirectionalSubject, _Subject);

    function BidirectionalSubject(source, destination) {
        _classCallCheck(this, BidirectionalSubject);

        _Subject.call(this);
        this.source = source;
        this.destination = destination;
    }

    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
        return _observableSubscribe.call(this, subscriber);
    };

    BidirectionalSubject.prototype.next = function next(x) {
        subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype.error = function error(e) {
        subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype.complete = function complete() {
        subscriberComplete.call(this);
    };

    BidirectionalSubject.prototype._next = function _next(x) {
        _subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype._error = function _error(e) {
        _subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype._complete = function _complete() {
        _subscriberComplete.call(this);
    };

    return BidirectionalSubject;
})(Subject);

module.exports = exports['default'];
},{"./Observable":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Observable.js","./Subscriber":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js","./Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js","./subjects/SubjectSubscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/subjects/SubjectSubscription.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilNoop = require('./util/noop');

var _utilNoop2 = _interopRequireDefault(_utilNoop);

var _utilThrowError = require('./util/throwError');

var _utilThrowError2 = _interopRequireDefault(_utilThrowError);

var _utilTryOrOnError = require('./util/tryOrOnError');

var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);

var _Subscription2 = require('./Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var Subscriber = (function (_Subscription) {
    _inherits(Subscriber, _Subscription);

    function Subscriber(destination) {
        _classCallCheck(this, Subscriber);

        _Subscription.call(this);
        this._isUnsubscribed = false;
        this.destination = destination;
        if (!destination) {
            return;
        }
        var subscription = destination._subscription;
        if (subscription) {
            this._subscription = subscription;
        } else if (destination instanceof Subscriber) {
            this._subscription = destination;
        }
    }

    Subscriber.create = function create(next, error, complete) {
        var subscriber = new Subscriber();
        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
        return subscriber;
    };

    Subscriber.prototype._next = function _next(value) {
        this.destination.next(value);
    };

    Subscriber.prototype._error = function _error(err) {
        this.destination.error(err);
    };

    Subscriber.prototype._complete = function _complete() {
        this.destination.complete();
    };

    Subscriber.prototype.add = function add(sub) {
        // route add to the shared Subscription if it exists
        var _subscription = this._subscription;
        if (_subscription) {
            _subscription.add(sub);
        } else {
            _Subscription.prototype.add.call(this, sub);
        }
    };

    Subscriber.prototype.remove = function remove(sub) {
        // route remove to the shared Subscription if it exists
        if (this._subscription) {
            this._subscription.remove(sub);
        } else {
            _Subscription.prototype.remove.call(this, sub);
        }
    };

    Subscriber.prototype.unsubscribe = function unsubscribe() {
        if (this._isUnsubscribed) {
            return;
        } else if (this._subscription) {
            this._isUnsubscribed = true;
        } else {
            _Subscription.prototype.unsubscribe.call(this);
        }
    };

    Subscriber.prototype.next = function next(value) {
        if (!this.isUnsubscribed) {
            this._next(value);
        }
    };

    Subscriber.prototype.error = function error(_error2) {
        if (!this.isUnsubscribed) {
            this._error(_error2);
            this.unsubscribe();
        }
    };

    Subscriber.prototype.complete = function complete() {
        if (!this.isUnsubscribed) {
            this._complete();
            this.unsubscribe();
        }
    };

    _createClass(Subscriber, [{
        key: 'isUnsubscribed',
        get: function get() {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                return this._isUnsubscribed || subscription.isUnsubscribed;
            } else {
                return this._isUnsubscribed;
            }
        },
        set: function set(value) {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                subscription.isUnsubscribed = Boolean(value);
            } else {
                this._isUnsubscribed = Boolean(value);
            }
        }
    }]);

    return Subscriber;
})(_Subscription3['default']);

exports['default'] = Subscriber;
module.exports = exports['default'];
},{"./Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js","./util/noop":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/noop.js","./util/throwError":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/throwError.js","./util/tryOrOnError":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/tryOrOnError.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Subscription = (function () {
    function Subscription(_unsubscribe) {
        _classCallCheck(this, Subscription);

        this.isUnsubscribed = false;
        if (_unsubscribe) {
            this._unsubscribe = _unsubscribe;
        }
    }

    Subscription.prototype._unsubscribe = function _unsubscribe() {};

    Subscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var unsubscribe = this._unsubscribe;
        var subscriptions = this._subscriptions;
        this._subscriptions = void 0;
        if (unsubscribe) {
            unsubscribe.call(this);
        }
        if (subscriptions != null) {
            var index = -1;
            var len = subscriptions.length;
            while (++index < len) {
                subscriptions[index].unsubscribe();
            }
        }
    };

    Subscription.prototype.add = function add(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to add our this
        //  3. we're attempting to add the static `empty` Subscription
        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var sub = subscription;
        switch (typeof subscription) {
            case "function":
                sub = new Subscription(subscription);
            case "object":
                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
                    break;
                } else if (this.isUnsubscribed) {
                    sub.unsubscribe();
                } else {
                    var subscriptions = this._subscriptions || (this._subscriptions = []);
                    subscriptions.push(sub);
                }
                break;
            default:
                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
        }
    };

    Subscription.prototype.remove = function remove(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to remove ourthis
        //  3. we're attempting to remove the static `empty` Subscription
        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };

    return Subscription;
})();

exports["default"] = Subscription;

Subscription.EMPTY = (function (empty) {
    empty.isUnsubscribed = true;
    return empty;
})(new Subscription());
module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/subjects/SubjectSubscription.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscription2 = require('../Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var SubjectSubscription = (function (_Subscription) {
    _inherits(SubjectSubscription, _Subscription);

    function SubjectSubscription(subject, observer) {
        _classCallCheck(this, SubjectSubscription);

        _Subscription.call(this);
        this.subject = subject;
        this.observer = observer;
        this.isUnsubscribed = false;
    }

    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = void 0;
        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.observer);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };

    return SubjectSubscription;
})(_Subscription3['default']);

exports['default'] = SubjectSubscription;
module.exports = exports['default'];
},{"../Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/Symbol_observable.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _root = require('./root');

if (!_root.root.Symbol) {
    _root.root.Symbol = {};
}
if (!_root.root.Symbol.observable) {
    if (typeof _root.root.Symbol['for'] === 'function') {
        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
    } else {
        _root.root.Symbol.observable = '@@observable';
    }
}
exports['default'] = _root.root.Symbol.observable;
module.exports = exports['default'];
},{"./root":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/root.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/noop.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = noop;

function noop() {}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/root.js":[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
exports.root = root;
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = root = freeGlobal;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/throwError.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = throwError;

function throwError(e) {
  throw e;
}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/tryOrOnError.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = tryOrOnError;

function tryOrOnError(target) {
    function tryCatcher() {
        try {
            tryCatcher.target.apply(this, arguments);
        } catch (e) {
            this.error(e);
        }
    }
    tryCatcher.target = target;
    return tryCatcher;
}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/profile.js":[function(require,module,exports){
'use strict';var profile_1 = require('./src/core/profile/profile');
exports.wtfCreateScope = profile_1.wtfCreateScope;
exports.wtfLeave = profile_1.wtfLeave;
exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;

},{"./src/core/profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/render.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
 * This file is only used for dart applications and for internal examples
 * that compile with both JavaScript and Dart.
 *
 * JavaScript users should import from angular2/core.
 */
__export(require('./src/core/render'));

},{"./src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Maps application URLs into application states, to support deep-linking and navigation.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var router_1 = require('./src/router/router');
exports.Router = router_1.Router;
var router_outlet_1 = require('./src/router/router_outlet');
exports.RouterOutlet = router_outlet_1.RouterOutlet;
var router_link_1 = require('./src/router/router_link');
exports.RouterLink = router_link_1.RouterLink;
var instruction_1 = require('./src/router/instruction');
exports.RouteParams = instruction_1.RouteParams;
var route_registry_1 = require('./src/router/route_registry');
exports.RouteRegistry = route_registry_1.RouteRegistry;
var location_strategy_1 = require('./src/router/location_strategy');
exports.LocationStrategy = location_strategy_1.LocationStrategy;
var hash_location_strategy_1 = require('./src/router/hash_location_strategy');
exports.HashLocationStrategy = hash_location_strategy_1.HashLocationStrategy;
var path_location_strategy_1 = require('./src/router/path_location_strategy');
exports.PathLocationStrategy = path_location_strategy_1.PathLocationStrategy;
var location_1 = require('./src/router/location');
exports.Location = location_1.Location;
exports.APP_BASE_HREF = location_1.APP_BASE_HREF;
__export(require('./src/router/route_config_decorator'));
__export(require('./src/router/route_definition'));
var lifecycle_annotations_1 = require('./src/router/lifecycle_annotations');
exports.CanActivate = lifecycle_annotations_1.CanActivate;
var instruction_2 = require('./src/router/instruction');
exports.Instruction = instruction_2.Instruction;
exports.ComponentInstruction = instruction_2.ComponentInstruction;
var angular2_1 = require('angular2/angular2');
exports.OpaqueToken = angular2_1.OpaqueToken;
var route_data_1 = require('./src/router/route_data');
exports.ROUTE_DATA = route_data_1.ROUTE_DATA;
var location_strategy_2 = require('./src/router/location_strategy');
var path_location_strategy_2 = require('./src/router/path_location_strategy');
var router_2 = require('./src/router/router');
var router_outlet_2 = require('./src/router/router_outlet');
var router_link_2 = require('./src/router/router_link');
var route_registry_2 = require('./src/router/route_registry');
var location_2 = require('./src/router/location');
var angular2_2 = require('angular2/angular2');
var lang_1 = require('./src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Token used to bind the component with the top-level {@link RouteConfig}s for the
 * application.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_PRIMARY_COMPONENT = lang_1.CONST_EXPR(new angular2_2.OpaqueToken('RouterPrimaryComponent'));
/**
 * A list of directives. To use the router directives like {@link RouterOutlet} and
 * {@link RouterLink}, add this to your `directives` array in the {@link View} decorator of your
 * component.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *    // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_DIRECTIVES = lang_1.CONST_EXPR([router_outlet_2.RouterOutlet, router_link_2.RouterLink]);
/**
 * A list of {@link Provider}s. To use the router, you must add this to your application.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_PROVIDERS = lang_1.CONST_EXPR([
    route_registry_2.RouteRegistry,
    lang_1.CONST_EXPR(new angular2_2.Provider(location_strategy_2.LocationStrategy, { useClass: path_location_strategy_2.PathLocationStrategy })),
    location_2.Location,
    lang_1.CONST_EXPR(new angular2_2.Provider(router_2.Router, {
        useFactory: routerFactory,
        deps: lang_1.CONST_EXPR([route_registry_2.RouteRegistry, location_2.Location, exports.ROUTER_PRIMARY_COMPONENT])
    })),
    lang_1.CONST_EXPR(new angular2_2.Provider(exports.ROUTER_PRIMARY_COMPONENT, { useFactory: routerPrimaryComponentFactory, deps: lang_1.CONST_EXPR([angular2_2.ApplicationRef]) }))
]);
/**
 * @deprecated
 */
exports.ROUTER_BINDINGS = exports.ROUTER_PROVIDERS;
function routerFactory(registry, location, primaryComponent) {
    return new router_2.RootRouter(registry, location, primaryComponent);
}
function routerPrimaryComponentFactory(app) {
    if (app.componentTypes.length == 0) {
        throw new exceptions_1.BaseException("Bootstrap at least one component before injecting Router.");
    }
    return app.componentTypes[0];
}

},{"./src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","./src/router/hash_location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/hash_location_strategy.js","./src/router/instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./src/router/lifecycle_annotations":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js","./src/router/location":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js","./src/router/location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","./src/router/path_location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_location_strategy.js","./src/router/route_config_decorator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js","./src/router/route_data":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js","./src/router/route_definition":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_definition.js","./src/router/route_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_registry.js","./src/router/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js","./src/router/router_link":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_link.js","./src/router/router_outlet":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_outlet.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var math_1 = require('angular2/src/core/facade/math');
var util_1 = require('angular2/src/core/render/dom/util');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var Animation = (function () {
    /**
     * Stores the start time and starts the animation
     * @param element
     * @param data
     * @param browserDetails
     */
    function Animation(element, data, browserDetails) {
        var _this = this;
        this.element = element;
        this.data = data;
        this.browserDetails = browserDetails;
        /** functions to be called upon completion */
        this.callbacks = [];
        /** functions for removing event listeners */
        this.eventClearFunctions = [];
        /** flag used to track whether or not the animation has finished */
        this.completed = false;
        this._stringPrefix = '';
        this.startTime = lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        this._stringPrefix = dom_adapter_1.DOM.getAnimationPrefix();
        this.setup();
        this.wait(function (timestamp) { return _this.start(); });
    }
    Object.defineProperty(Animation.prototype, "totalTime", {
        /** total amount of time that the animation should take including delay */
        get: function () {
            var delay = this.computedDelay != null ? this.computedDelay : 0;
            var duration = this.computedDuration != null ? this.computedDuration : 0;
            return delay + duration;
        },
        enumerable: true,
        configurable: true
    });
    Animation.prototype.wait = function (callback) {
        // Firefox requires 2 frames for some reason
        this.browserDetails.raf(callback, 2);
    };
    /**
     * Sets up the initial styles before the animation is started
     */
    Animation.prototype.setup = function () {
        if (this.data.fromStyles != null)
            this.applyStyles(this.data.fromStyles);
        if (this.data.duration != null)
            this.applyStyles({ 'transitionDuration': this.data.duration.toString() + 'ms' });
        if (this.data.delay != null)
            this.applyStyles({ 'transitionDelay': this.data.delay.toString() + 'ms' });
    };
    /**
     * After the initial setup has occurred, this method adds the animation styles
     */
    Animation.prototype.start = function () {
        this.addClasses(this.data.classesToAdd);
        this.addClasses(this.data.animationClasses);
        this.removeClasses(this.data.classesToRemove);
        if (this.data.toStyles != null)
            this.applyStyles(this.data.toStyles);
        var computedStyles = dom_adapter_1.DOM.getComputedStyle(this.element);
        this.computedDelay =
            math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-delay')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-delay')));
        this.computedDuration = math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-duration')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-duration')));
        this.addEvents();
    };
    /**
     * Applies the provided styles to the element
     * @param styles
     */
    Animation.prototype.applyStyles = function (styles) {
        var _this = this;
        collection_1.StringMapWrapper.forEach(styles, function (value, key) {
            var dashCaseKey = util_1.camelCaseToDashCase(key);
            if (lang_1.isPresent(dom_adapter_1.DOM.getStyle(_this.element, dashCaseKey))) {
                dom_adapter_1.DOM.setStyle(_this.element, dashCaseKey, value.toString());
            }
            else {
                dom_adapter_1.DOM.setStyle(_this.element, _this._stringPrefix + dashCaseKey, value.toString());
            }
        });
    };
    /**
     * Adds the provided classes to the element
     * @param classes
     */
    Animation.prototype.addClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.DOM.addClass(this.element, classes[i]);
    };
    /**
     * Removes the provided classes from the element
     * @param classes
     */
    Animation.prototype.removeClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.DOM.removeClass(this.element, classes[i]);
    };
    /**
     * Adds events to track when animations have finished
     */
    Animation.prototype.addEvents = function () {
        var _this = this;
        if (this.totalTime > 0) {
            this.eventClearFunctions.push(dom_adapter_1.DOM.onAndCancel(this.element, dom_adapter_1.DOM.getTransitionEnd(), function (event) { return _this.handleAnimationEvent(event); }));
        }
        else {
            this.handleAnimationCompleted();
        }
    };
    Animation.prototype.handleAnimationEvent = function (event) {
        var elapsedTime = math_1.Math.round(event.elapsedTime * 1000);
        if (!this.browserDetails.elapsedTimeIncludesDelay)
            elapsedTime += this.computedDelay;
        event.stopPropagation();
        if (elapsedTime >= this.totalTime)
            this.handleAnimationCompleted();
    };
    /**
     * Runs all animation callbacks and removes temporary classes
     */
    Animation.prototype.handleAnimationCompleted = function () {
        this.removeClasses(this.data.animationClasses);
        this.callbacks.forEach(function (callback) { return callback(); });
        this.callbacks = [];
        this.eventClearFunctions.forEach(function (fn) { return fn(); });
        this.eventClearFunctions = [];
        this.completed = true;
    };
    /**
     * Adds animation callbacks to be called upon completion
     * @param callback
     * @returns {Animation}
     */
    Animation.prototype.onComplete = function (callback) {
        if (this.completed) {
            callback();
        }
        else {
            this.callbacks.push(callback);
        }
        return this;
    };
    /**
     * Converts the duration string to the number of milliseconds
     * @param duration
     * @returns {number}
     */
    Animation.prototype.parseDurationString = function (duration) {
        var maxValue = 0;
        // duration must have at least 2 characters to be valid. (number + type)
        if (duration == null || duration.length < 2) {
            return maxValue;
        }
        else if (duration.substring(duration.length - 2) == 'ms') {
            var value = lang_1.NumberWrapper.parseInt(this.stripLetters(duration), 10);
            if (value > maxValue)
                maxValue = value;
        }
        else if (duration.substring(duration.length - 1) == 's') {
            var ms = lang_1.NumberWrapper.parseFloat(this.stripLetters(duration)) * 1000;
            var value = math_1.Math.floor(ms);
            if (value > maxValue)
                maxValue = value;
        }
        return maxValue;
    };
    /**
     * Strips the letters from the duration string
     * @param str
     * @returns {string}
     */
    Animation.prototype.stripLetters = function (str) {
        return lang_1.StringWrapper.replaceAll(str, lang_1.RegExpWrapper.create('[^0-9]+$', ''), '');
    };
    return Animation;
})();
exports.Animation = Animation;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/facade/math":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js","angular2/src/core/render/dom/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var css_animation_builder_1 = require('./css_animation_builder');
var browser_details_1 = require('./browser_details');
var AnimationBuilder = (function () {
    /**
     * Used for DI
     * @param browserDetails
     */
    function AnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
    }
    /**
     * Creates a new CSS Animation
     * @returns {CssAnimationBuilder}
     */
    AnimationBuilder.prototype.css = function () { return new css_animation_builder_1.CssAnimationBuilder(this.browserDetails); };
    AnimationBuilder = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [browser_details_1.BrowserDetails])
    ], AnimationBuilder);
    return AnimationBuilder;
})();
exports.AnimationBuilder = AnimationBuilder;

},{"./browser_details":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js","./css_animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_builder.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var math_1 = require('angular2/src/core/facade/math');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var BrowserDetails = (function () {
    function BrowserDetails() {
        this.elapsedTimeIncludesDelay = false;
        this.doesElapsedTimeIncludesDelay();
    }
    /**
     * Determines if `event.elapsedTime` includes transition delay in the current browser.  At this
     * time, Chrome and Opera seem to be the only browsers that include this.
     */
    BrowserDetails.prototype.doesElapsedTimeIncludesDelay = function () {
        var _this = this;
        var div = dom_adapter_1.DOM.createElement('div');
        dom_adapter_1.DOM.setAttribute(div, 'style', "position: absolute; top: -9999px; left: -9999px; width: 1px;\n      height: 1px; transition: all 1ms linear 1ms;");
        // Firefox requires that we wait for 2 frames for some reason
        this.raf(function (timestamp) {
            dom_adapter_1.DOM.on(div, 'transitionend', function (event) {
                var elapsed = math_1.Math.round(event.elapsedTime * 1000);
                _this.elapsedTimeIncludesDelay = elapsed == 2;
                dom_adapter_1.DOM.remove(div);
            });
            dom_adapter_1.DOM.setStyle(div, 'width', '2px');
        }, 2);
    };
    BrowserDetails.prototype.raf = function (callback, frames) {
        if (frames === void 0) { frames = 1; }
        var queue = new RafQueue(callback, frames);
        return function () { return queue.cancel(); };
    };
    BrowserDetails = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], BrowserDetails);
    return BrowserDetails;
})();
exports.BrowserDetails = BrowserDetails;
var RafQueue = (function () {
    function RafQueue(callback, frames) {
        this.callback = callback;
        this.frames = frames;
        this._raf();
    }
    RafQueue.prototype._raf = function () {
        var _this = this;
        this.currentFrameId = dom_adapter_1.DOM.requestAnimationFrame(function (timestamp) { return _this._nextFrame(timestamp); });
    };
    RafQueue.prototype._nextFrame = function (timestamp) {
        this.frames--;
        if (this.frames > 0) {
            this._raf();
        }
        else {
            this.callback(timestamp);
        }
    };
    RafQueue.prototype.cancel = function () {
        dom_adapter_1.DOM.cancelAnimationFrame(this.currentFrameId);
        this.currentFrameId = null;
    };
    return RafQueue;
})();

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/math":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_builder.js":[function(require,module,exports){
'use strict';var css_animation_options_1 = require('./css_animation_options');
var animation_1 = require('./animation');
var CssAnimationBuilder = (function () {
    /**
     * Accepts public properties for CssAnimationBuilder
     */
    function CssAnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
        /** @type {CssAnimationOptions} */
        this.data = new css_animation_options_1.CssAnimationOptions();
    }
    /**
     * Adds a temporary class that will be removed at the end of the animation
     * @param className
     */
    CssAnimationBuilder.prototype.addAnimationClass = function (className) {
        this.data.animationClasses.push(className);
        return this;
    };
    /**
     * Adds a class that will remain on the element after the animation has finished
     * @param className
     */
    CssAnimationBuilder.prototype.addClass = function (className) {
        this.data.classesToAdd.push(className);
        return this;
    };
    /**
     * Removes a class from the element
     * @param className
     */
    CssAnimationBuilder.prototype.removeClass = function (className) {
        this.data.classesToRemove.push(className);
        return this;
    };
    /**
     * Sets the animation duration (and overrides any defined through CSS)
     * @param duration
     */
    CssAnimationBuilder.prototype.setDuration = function (duration) {
        this.data.duration = duration;
        return this;
    };
    /**
     * Sets the animation delay (and overrides any defined through CSS)
     * @param delay
     */
    CssAnimationBuilder.prototype.setDelay = function (delay) {
        this.data.delay = delay;
        return this;
    };
    /**
     * Sets styles for both the initial state and the destination state
     * @param from
     * @param to
     */
    CssAnimationBuilder.prototype.setStyles = function (from, to) {
        return this.setFromStyles(from).setToStyles(to);
    };
    /**
     * Sets the initial styles for the animation
     * @param from
     */
    CssAnimationBuilder.prototype.setFromStyles = function (from) {
        this.data.fromStyles = from;
        return this;
    };
    /**
     * Sets the destination styles for the animation
     * @param to
     */
    CssAnimationBuilder.prototype.setToStyles = function (to) {
        this.data.toStyles = to;
        return this;
    };
    /**
     * Starts the animation and returns a promise
     * @param element
     */
    CssAnimationBuilder.prototype.start = function (element) {
        return new animation_1.Animation(element, this.data, this.browserDetails);
    };
    return CssAnimationBuilder;
})();
exports.CssAnimationBuilder = CssAnimationBuilder;

},{"./animation":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation.js","./css_animation_options":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_options.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_options.js":[function(require,module,exports){
'use strict';var CssAnimationOptions = (function () {
    function CssAnimationOptions() {
        /** classes to be added to the element */
        this.classesToAdd = [];
        /** classes to be removed from the element */
        this.classesToRemove = [];
        /** classes to be added for the duration of the animation */
        this.animationClasses = [];
    }
    return CssAnimationOptions;
})();
exports.CssAnimationOptions = CssAnimationOptions;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var compiler_1 = require('angular2/src/core/compiler/compiler');
var application_common_1 = require('./application_common');
var application_tokens_1 = require('./application_tokens');
exports.APP_COMPONENT = application_tokens_1.APP_COMPONENT;
exports.APP_ID = application_tokens_1.APP_ID;
var application_common_2 = require('./application_common');
exports.platform = application_common_2.platform;
var application_ref_1 = require('./application_ref');
exports.PlatformRef = application_ref_1.PlatformRef;
exports.ApplicationRef = application_ref_1.ApplicationRef;
exports.applicationCommonBindings = application_ref_1.applicationCommonBindings;
exports.createNgZone = application_ref_1.createNgZone;
exports.platformCommon = application_ref_1.platformCommon;
exports.platformBindings = application_ref_1.platformBindings;
/// See [commonBootstrap] for detailed documentation.
function bootstrap(appComponentType, appBindings) {
    if (appBindings === void 0) { appBindings = null; }
    var bindings = [compiler_1.compilerProviders()];
    if (lang_1.isPresent(appBindings)) {
        bindings.push(appBindings);
    }
    return application_common_1.commonBootstrap(appComponentType, bindings);
}
exports.bootstrap = bootstrap;

},{"./application_common":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_common.js","./application_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js","./application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/compiler/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/compiler.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_common.js":[function(require,module,exports){
'use strict';var forms_1 = require('angular2/src/core/forms');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var browser_adapter_1 = require('angular2/src/core/dom/browser_adapter');
var browser_testability_1 = require('angular2/src/core/testability/browser_testability');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var xhr_impl_1 = require('angular2/src/core/compiler/xhr_impl');
var event_manager_1 = require('angular2/src/core/render/dom/events/event_manager');
var key_events_1 = require('angular2/src/core/render/dom/events/key_events');
var hammer_gestures_1 = require('angular2/src/core/render/dom/events/hammer_gestures');
var testability_1 = require('angular2/src/core/testability/testability');
var api_1 = require('angular2/src/core/render/api');
var render_1 = require('angular2/src/core/render/render');
var shared_styles_host_1 = require('angular2/src/core/render/dom/shared_styles_host');
var platform_bindings_1 = require('./platform_bindings');
var animation_builder_1 = require('angular2/src/animate/animation_builder');
var browser_details_1 = require('angular2/src/animate/browser_details');
var wtf_init_1 = require('./profile/wtf_init');
var application_ref_1 = require('./application_ref');
/**
 * A default set of providers which apply only to an Angular application running on
 * the UI thread.
 */
function applicationDomBindings() {
    if (lang_1.isBlank(dom_adapter_1.DOM)) {
        throw "Must set a root DOM adapter first.";
    }
    return [
        di_1.provide(render_1.DOCUMENT, { useValue: dom_adapter_1.DOM.defaultDoc() }),
        event_manager_1.EventManager,
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: event_manager_1.DomEventsPlugin, multi: true }),
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: key_events_1.KeyEventsPlugin, multi: true }),
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true }),
        di_1.provide(render_1.DomRenderer, { useClass: render_1.DomRenderer_ }),
        di_1.provide(api_1.Renderer, { useExisting: render_1.DomRenderer }),
        shared_styles_host_1.DomSharedStylesHost,
        di_1.provide(shared_styles_host_1.SharedStylesHost, { useExisting: shared_styles_host_1.DomSharedStylesHost }),
        platform_bindings_1.EXCEPTION_PROVIDER,
        di_1.provide(xhr_1.XHR, { useValue: new xhr_impl_1.XHRImpl() }),
        testability_1.Testability,
        browser_details_1.BrowserDetails,
        animation_builder_1.AnimationBuilder,
        forms_1.FORM_PROVIDERS
    ];
}
exports.applicationDomBindings = applicationDomBindings;
/**
 * Initialize the Angular 'platform' on the page.
 *
 * See {@link PlatformRef} for details on the Angular platform.
 *
 * # Without specified providers
 *
 * If no providers are specified, `platform`'s behavior depends on whether an existing
 * platform exists:
 *
 * If no platform exists, a new one will be created with the default {@link platformBindings}.
 *
 * If a platform already exists, it will be returned (regardless of what providers it
 * was created with). This is a convenience feature, allowing for multiple applications
 * to be loaded into the same platform without awareness of each other.
 *
 * # With specified providers
 *
 * It is also possible to specify providers to be made in the new platform. These providers
 * will be shared between all applications on the page. For example, an abstraction for
 * the browser cookie jar should be bound at the platform level, because there is only one
 * cookie jar regardless of how many applications on the age will be accessing it.
 *
 * If providers are specified directly, `platform` will create the Angular platform with
 * them if a platform did not exist already. If it did exist, however, an error will be
 * thrown.
 *
 * # DOM Applications
 *
 * This version of `platform` initializes Angular to run in the UI thread, with direct
 * DOM access. Web-worker applications should call `platform` from
 * `src/web_workers/worker/application_common` instead.
 */
function platform(bindings) {
    return application_ref_1.platformCommon(bindings, function () {
        browser_adapter_1.BrowserDomAdapter.makeCurrent();
        wtf_init_1.wtfInit();
        browser_testability_1.BrowserGetTestability.init();
    });
}
exports.platform = platform;
/**
 * Bootstrapping for Angular applications.
 *
 * You instantiate an Angular application by explicitly specifying a component to use
 * as the root component for your application via the `bootstrap()` method.
 *
 * ## Simple Example
 *
 * Assuming this `index.html`:
 *
 * ```html
 * <html>
 *   <!-- load Angular script tags here. -->
 *   <body>
 *     <my-app>loading...</my-app>
 *   </body>
 * </html>
 * ```
 *
 * An application is bootstrapped inside an existing browser DOM, typically `index.html`.
 * Unlike Angular 1, Angular 2 does not compile/process providers in `index.html`. This is
 * mainly for security reasons, as well as architectural changes in Angular 2. This means
 * that `index.html` can safely be processed using server-side technologies such as
 * providers. Bindings can thus use double-curly `{{ syntax }}` without collision from
 * Angular 2 component double-curly `{{ syntax }}`.
 *
 * We can use this script code:
 *
 * ```
 * @Component({
 *    selector: 'my-app',
 *    template: 'Hello {{ name }}!'
 * })
 * class MyApp {
 *   name:string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 *
 * main() {
 *   return bootstrap(MyApp);
 * }
 * ```
 *
 * When the app developer invokes `bootstrap()` with the root component `MyApp` as its
 * argument, Angular performs the following tasks:
 *
 *  1. It uses the component's `selector` property to locate the DOM element which needs
 *     to be upgraded into the angular component.
 *  2. It creates a new child injector (from the platform injector). Optionally, you can
 *     also override the injector configuration for an app by invoking `bootstrap` with the
 *     `componentInjectableBindings` argument.
 *  3. It creates a new `Zone` and connects it to the angular application's change detection
 *     domain instance.
 *  4. It creates a shadow DOM on the selected component's host element and loads the
 *     template into it.
 *  5. It instantiates the specified component.
 *  6. Finally, Angular performs change detection to apply the initial data providers for the
 *     application.
 *
 *
 * ## Instantiating Multiple Applications on a Single Page
 *
 * There are two ways to do this.
 *
 * ### Isolated Applications
 *
 * Angular creates a new application each time that the `bootstrap()` method is invoked.
 * When multiple applications are created for a page, Angular treats each application as
 * independent within an isolated change detection and `Zone` domain. If you need to share
 * data between applications, use the strategy described in the next section, "Applications
 * That Share Change Detection."
 *
 *
 * ### Applications That Share Change Detection
 *
 * If you need to bootstrap multiple applications that share common data, the applications
 * must share a common change detection and zone. To do that, create a meta-component that
 * lists the application components in its template.
 *
 * By only invoking the `bootstrap()` method once, with the meta-component as its argument,
 * you ensure that only a single change detection zone is created and therefore data can be
 * shared across the applications.
 *
 *
 * ## Platform Injector
 *
 * When working within a browser window, there are many singleton resources: cookies, title,
 * location, and others. Angular services that represent these resources must likewise be
 * shared across all Angular applications that occupy the same browser window. For this
 * reason, Angular creates exactly one global platform injector which stores all shared
 * services, and each angular application injector has the platform injector as its parent.
 *
 * Each application has its own private injector as well. When there are multiple
 * applications on a page, Angular treats each application injector's services as private
 * to that application.
 *
 *
 * # API
 * - `appComponentType`: The root component which should act as the application. This is
 *   a reference to a `Type` which is annotated with `@Component(...)`.
 * - `componentInjectableBindings`: An additional set of providers that can be added to the
 *   app injector to override default injection behavior.
 * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter
 *   for unhandled exceptions.
 *
 * Returns a `Promise` of {@link ComponentRef}.
 */
function commonBootstrap(appComponentType, appBindings) {
    if (appBindings === void 0) { appBindings = null; }
    var p = platform();
    var bindings = [application_ref_1.applicationCommonBindings(), applicationDomBindings()];
    if (lang_1.isPresent(appBindings)) {
        bindings.push(appBindings);
    }
    return p.application(bindings).bootstrap(appComponentType);
}
exports.commonBootstrap = commonBootstrap;

},{"./application_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js","./platform_bindings":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/platform_bindings.js","./profile/wtf_init":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_init.js","angular2/src/animate/animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js","angular2/src/animate/browser_details":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/compiler/xhr_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr_impl.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/browser_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/browser_adapter.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/forms":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","angular2/src/core/render/dom/events/event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/render/dom/events/hammer_gestures":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_gestures.js","angular2/src/core/render/dom/events/key_events":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/key_events.js","angular2/src/core/render/dom/shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js","angular2/src/core/render/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js","angular2/src/core/testability/browser_testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/browser_testability.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ng_zone_1 = require('angular2/src/core/zone/ng_zone');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var application_tokens_1 = require('./application_tokens');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var testability_1 = require('angular2/src/core/testability/testability');
var dynamic_component_loader_1 = require('angular2/src/core/linker/dynamic_component_loader');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var view_ref_1 = require('angular2/src/core/linker/view_ref');
var life_cycle_1 = require('angular2/src/core/life_cycle/life_cycle');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var view_pool_1 = require('angular2/src/core/linker/view_pool');
var view_manager_1 = require('angular2/src/core/linker/view_manager');
var view_manager_utils_1 = require('angular2/src/core/linker/view_manager_utils');
var view_listener_1 = require('angular2/src/core/linker/view_listener');
var proto_view_factory_1 = require('./linker/proto_view_factory');
var pipes_1 = require('angular2/src/core/pipes');
var view_resolver_1 = require('./linker/view_resolver');
var directive_resolver_1 = require('./linker/directive_resolver');
var pipe_resolver_1 = require('./linker/pipe_resolver');
var compiler_1 = require('angular2/src/core/linker/compiler');
var dynamic_component_loader_2 = require("./linker/dynamic_component_loader");
var view_manager_2 = require("./linker/view_manager");
var compiler_2 = require("./linker/compiler");
/**
 * Constructs the set of providers meant for use at the platform level.
 *
 * These are providers that should be singletons shared among all Angular applications
 * running on the page.
 */
function platformBindings() {
    return [di_1.provide(reflection_1.Reflector, { useValue: reflection_1.reflector }), testability_1.TestabilityRegistry];
}
exports.platformBindings = platformBindings;
/**
 * Construct providers specific to an individual root component.
 */
function _componentProviders(appComponentType) {
    return [
        di_1.provide(application_tokens_1.APP_COMPONENT, { useValue: appComponentType }),
        di_1.provide(application_tokens_1.APP_COMPONENT_REF_PROMISE, {
            useFactory: function (dynamicComponentLoader, injector) {
                // TODO(rado): investigate whether to support bindings on root component.
                return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector)
                    .then(function (componentRef) {
                    if (lang_1.isPresent(componentRef.location.nativeElement)) {
                        injector.get(testability_1.TestabilityRegistry)
                            .registerApplication(componentRef.location.nativeElement, injector.get(testability_1.Testability));
                    }
                    return componentRef;
                });
            },
            deps: [dynamic_component_loader_1.DynamicComponentLoader, di_1.Injector]
        }),
        di_1.provide(appComponentType, {
            useFactory: function (p) { return p.then(function (ref) { return ref.instance; }); },
            deps: [application_tokens_1.APP_COMPONENT_REF_PROMISE]
        }),
    ];
}
/**
 * Construct a default set of providers which should be included in any Angular
 * application, regardless of whether it runs on the UI thread or in a web worker.
 */
function applicationCommonBindings() {
    return [
        di_1.provide(compiler_1.Compiler, { useClass: compiler_2.Compiler_ }),
        application_tokens_1.APP_ID_RANDOM_PROVIDER,
        view_pool_1.AppViewPool,
        di_1.provide(view_pool_1.APP_VIEW_POOL_CAPACITY, { useValue: 10000 }),
        di_1.provide(view_manager_1.AppViewManager, { useClass: view_manager_2.AppViewManager_ }),
        view_manager_utils_1.AppViewManagerUtils,
        view_listener_1.AppViewListener,
        proto_view_factory_1.ProtoViewFactory,
        view_resolver_1.ViewResolver,
        pipes_1.DEFAULT_PIPES,
        di_1.provide(change_detection_1.IterableDiffers, { useValue: change_detection_1.defaultIterableDiffers }),
        di_1.provide(change_detection_1.KeyValueDiffers, { useValue: change_detection_1.defaultKeyValueDiffers }),
        directive_resolver_1.DirectiveResolver,
        pipe_resolver_1.PipeResolver,
        di_1.provide(dynamic_component_loader_1.DynamicComponentLoader, { useClass: dynamic_component_loader_2.DynamicComponentLoader_ }),
        di_1.provide(life_cycle_1.LifeCycle, {
            useFactory: function (exceptionHandler) { return new life_cycle_1.LifeCycle_(null, lang_1.assertionsEnabled()); },
            deps: [exceptions_1.ExceptionHandler]
        })
    ];
}
exports.applicationCommonBindings = applicationCommonBindings;
/**
 * Create an Angular zone.
 */
function createNgZone() {
    return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });
}
exports.createNgZone = createNgZone;
var _platform;
function platformCommon(bindings, initializer) {
    if (lang_1.isPresent(_platform)) {
        if (lang_1.isBlank(bindings)) {
            return _platform;
        }
        throw "platform() can only be called once per page";
    }
    if (lang_1.isPresent(initializer)) {
        initializer();
    }
    if (lang_1.isBlank(bindings)) {
        bindings = platformBindings();
    }
    _platform = new PlatformRef_(di_1.Injector.resolveAndCreate(bindings), function () { _platform = null; });
    return _platform;
}
exports.platformCommon = platformCommon;
/**
 * The Angular platform is the entry point for Angular on a web page. Each page
 * has exactly one platform, and services (such as reflection) which are common
 * to every Angular application running on the page are bound in its scope.
 *
 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
 * explicitly by calling {@link platform}().
 */
var PlatformRef = (function () {
    function PlatformRef() {
    }
    Object.defineProperty(PlatformRef.prototype, "injector", {
        /**
         * Retrieve the platform {@link Injector}, which is the parent injector for
         * every Angular application on the page and provides singleton providers.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return PlatformRef;
})();
exports.PlatformRef = PlatformRef;
var PlatformRef_ = (function (_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector, _dispose) {
        _super.call(this);
        this._injector = _injector;
        this._dispose = _dispose;
        /** @internal */
        this._applications = [];
    }
    Object.defineProperty(PlatformRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    PlatformRef_.prototype.application = function (bindings) {
        var app = this._initApp(createNgZone(), bindings);
        return app;
    };
    PlatformRef_.prototype.asyncApplication = function (bindingFn) {
        var _this = this;
        var zone = createNgZone();
        var completer = async_1.PromiseWrapper.completer();
        zone.run(function () {
            async_1.PromiseWrapper.then(bindingFn(zone), function (bindings) {
                completer.resolve(_this._initApp(zone, bindings));
            });
        });
        return completer.promise;
    };
    PlatformRef_.prototype._initApp = function (zone, providers) {
        var _this = this;
        var injector;
        var app;
        zone.run(function () {
            providers.push(di_1.provide(ng_zone_1.NgZone, { useValue: zone }));
            providers.push(di_1.provide(ApplicationRef, { useFactory: function () { return app; }, deps: [] }));
            var exceptionHandler;
            try {
                injector = _this.injector.resolveAndCreateChild(providers);
                exceptionHandler = injector.get(exceptions_1.ExceptionHandler);
                zone.overrideOnErrorHandler(function (e, s) { return exceptionHandler.call(e, s); });
            }
            catch (e) {
                if (lang_1.isPresent(exceptionHandler)) {
                    exceptionHandler.call(e, e.stack);
                }
                else {
                    dom_adapter_1.DOM.logError(e);
                }
            }
        });
        app = new ApplicationRef_(this, zone, injector);
        this._applications.push(app);
        return app;
    };
    PlatformRef_.prototype.dispose = function () {
        this._applications.forEach(function (app) { return app.dispose(); });
        this._dispose();
    };
    /** @internal */
    PlatformRef_.prototype._applicationDisposed = function (app) { collection_1.ListWrapper.remove(this._applications, app); };
    return PlatformRef_;
})(PlatformRef);
exports.PlatformRef_ = PlatformRef_;
/**
 * A reference to an Angular application running on a page.
 *
 * For more about Angular applications, see the documentation for {@link bootstrap}.
 */
var ApplicationRef = (function () {
    function ApplicationRef() {
    }
    Object.defineProperty(ApplicationRef.prototype, "injector", {
        /**
         * Retrieve the application {@link Injector}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "zone", {
        /**
         * Retrieve the application {@link NgZone}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
        /**
         * Get a list of component types registered to this application.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ApplicationRef;
})();
exports.ApplicationRef = ApplicationRef;
var ApplicationRef_ = (function (_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_platform, _zone, _injector) {
        _super.call(this);
        this._platform = _platform;
        this._zone = _zone;
        this._injector = _injector;
        this._bootstrapListeners = [];
        this._rootComponents = [];
        this._rootComponentTypes = [];
    }
    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {
        this._bootstrapListeners.push(listener);
    };
    ApplicationRef_.prototype.bootstrap = function (componentType, providers) {
        var _this = this;
        var completer = async_1.PromiseWrapper.completer();
        this._zone.run(function () {
            var componentProviders = _componentProviders(componentType);
            if (lang_1.isPresent(providers)) {
                componentProviders.push(providers);
            }
            var exceptionHandler = _this._injector.get(exceptions_1.ExceptionHandler);
            _this._rootComponentTypes.push(componentType);
            try {
                var injector = _this._injector.resolveAndCreateChild(componentProviders);
                var compRefToken = injector.get(application_tokens_1.APP_COMPONENT_REF_PROMISE);
                var tick = function (componentRef) {
                    var appChangeDetector = view_ref_1.internalView(componentRef.hostView).changeDetector;
                    var lc = injector.get(life_cycle_1.LifeCycle);
                    lc.registerWith(_this._zone, appChangeDetector);
                    lc.tick();
                    completer.resolve(componentRef);
                    _this._rootComponents.push(componentRef);
                    _this._bootstrapListeners.forEach(function (listener) { return listener(componentRef); });
                };
                var tickResult = async_1.PromiseWrapper.then(compRefToken, tick);
                async_1.PromiseWrapper.then(tickResult, function (_) { });
                async_1.PromiseWrapper.then(tickResult, null, function (err, stackTrace) { return completer.reject(err, stackTrace); });
            }
            catch (e) {
                exceptionHandler.call(e, e.stack);
                completer.reject(e, e.stack);
            }
        });
        return completer.promise;
    };
    Object.defineProperty(ApplicationRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "zone", {
        get: function () { return this._zone; },
        enumerable: true,
        configurable: true
    });
    ApplicationRef_.prototype.dispose = function () {
        // TODO(alxhub): Dispose of the NgZone.
        this._rootComponents.forEach(function (ref) { return ref.dispose(); });
        this._platform._applicationDisposed(this);
    };
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
        get: function () { return this._rootComponentTypes; },
        enumerable: true,
        configurable: true
    });
    return ApplicationRef_;
})(ApplicationRef);
exports.ApplicationRef_ = ApplicationRef_;

},{"./application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","./linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","./linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","./linker/pipe_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js","./linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","./linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","./linker/view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/life_cycle/life_cycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","angular2/src/core/linker/view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","angular2/src/core/linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","angular2/src/core/linker/view_manager_utils":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js","angular2/src/core/linker/view_pool":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js","angular2/src/core/linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js","angular2/src/core/zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 *  @internal
 */
exports.APP_COMPONENT_REF_PROMISE = lang_1.CONST_EXPR(new di_1.OpaqueToken('Promise<ComponentRef>'));
/**
 * An {@link angular2/di/OpaqueToken} representing the application root type in the {@link
 * Injector}.
 *
 * ```
 * @Component(...)
 * class MyApp {
 *   ...
 * }
 *
 * bootstrap(MyApp).then((appRef:ApplicationRef) {
 *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);
 * });
 *
 * ```
 */
exports.APP_COMPONENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppComponent'));
/**
 * A DI Token representing a unique string id assigned to the application by Angular and used
 * primarily for prefixing application attributes and CSS styles when
 * {@link ViewEncapsulation#Emulated} is being used.
 *
 * If you need to avoid randomly generated value to be used as an application id, you can provide
 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
 * using this token.
 */
exports.APP_ID = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppId'));
function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
}
/**
 * Bindings that will generate a random APP_ID_TOKEN.
 */
exports.APP_ID_RANDOM_PROVIDER = lang_1.CONST_EXPR(new di_1.Provider(exports.APP_ID, { useFactory: _appIdRandomProviderFactory, deps: [] }));
function _randomChar() {
    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
}

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js":[function(require,module,exports){
'use strict';// Note: This file only exists so that Dart users can import
// bootstrap from angular2/bootstrap. JS users should import
// from angular2/core.
var application_1 = require('./application');
exports.bootstrap = application_1.bootstrap;

},{"./application":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Change detection enables data binding in Angular.
 */
var change_detection_1 = require('./change_detection/change_detection');
exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
exports.ExpressionChangedAfterItHasBeenCheckedException = change_detection_1.ExpressionChangedAfterItHasBeenCheckedException;
exports.ChangeDetectionError = change_detection_1.ChangeDetectionError;
exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
exports.WrappedValue = change_detection_1.WrappedValue;
exports.SimpleChange = change_detection_1.SimpleChange;
exports.IterableDiffers = change_detection_1.IterableDiffers;
exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;

},{"./change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_util_1 = require('./change_detection_util');
var change_detector_ref_1 = require('./change_detector_ref');
var exceptions_2 = require('./exceptions');
var constants_1 = require('./constants');
var profile_1 = require('../profile/profile');
var observable_facade_1 = require('./observable_facade');
var _scope_check = profile_1.wtfCreateScope("ChangeDetector#check(ascii id, bool throwOnChange)");
var _Context = (function () {
    function _Context(element, componentElement, context, locals, injector, expression) {
        this.element = element;
        this.componentElement = componentElement;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
        this.expression = expression;
    }
    return _Context;
})();
var AbstractChangeDetector = (function () {
    function AbstractChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, bindingTargets, directiveIndices, strategy) {
        this.id = id;
        this.dispatcher = dispatcher;
        this.numberOfPropertyProtoRecords = numberOfPropertyProtoRecords;
        this.bindingTargets = bindingTargets;
        this.directiveIndices = directiveIndices;
        this.strategy = strategy;
        this.lightDomChildren = [];
        this.shadowDomChildren = [];
        // The names of the below fields must be kept in sync with codegen_name_util.ts or
        // change detection will fail.
        this.alreadyChecked = false;
        this.locals = null;
        this.mode = null;
        this.pipes = null;
        this.ref = new change_detector_ref_1.ChangeDetectorRef_(this);
    }
    AbstractChangeDetector.prototype.addChild = function (cd) {
        this.lightDomChildren.push(cd);
        cd.parent = this;
    };
    AbstractChangeDetector.prototype.removeChild = function (cd) { collection_1.ListWrapper.remove(this.lightDomChildren, cd); };
    AbstractChangeDetector.prototype.addShadowDomChild = function (cd) {
        this.shadowDomChildren.push(cd);
        cd.parent = this;
    };
    AbstractChangeDetector.prototype.removeShadowDomChild = function (cd) { collection_1.ListWrapper.remove(this.shadowDomChildren, cd); };
    AbstractChangeDetector.prototype.remove = function () { this.parent.removeChild(this); };
    AbstractChangeDetector.prototype.handleEvent = function (eventName, elIndex, locals) {
        var res = this.handleEventInternal(eventName, elIndex, locals);
        this.markPathToRootAsCheckOnce();
        return res;
    };
    AbstractChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) { return false; };
    AbstractChangeDetector.prototype.detectChanges = function () { this.runDetectChanges(false); };
    AbstractChangeDetector.prototype.checkNoChanges = function () { throw new exceptions_1.BaseException("Not implemented"); };
    AbstractChangeDetector.prototype.runDetectChanges = function (throwOnChange) {
        if (this.mode === constants_1.ChangeDetectionStrategy.Detached ||
            this.mode === constants_1.ChangeDetectionStrategy.Checked)
            return;
        var s = _scope_check(this.id, throwOnChange);
        this.detectChangesInRecords(throwOnChange);
        this._detectChangesInLightDomChildren(throwOnChange);
        if (!throwOnChange)
            this.afterContentLifecycleCallbacks();
        this._detectChangesInShadowDomChildren(throwOnChange);
        if (!throwOnChange)
            this.afterViewLifecycleCallbacks();
        if (this.mode === constants_1.ChangeDetectionStrategy.CheckOnce)
            this.mode = constants_1.ChangeDetectionStrategy.Checked;
        this.alreadyChecked = true;
        profile_1.wtfLeave(s);
    };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `detectChangesInRecordsInternal` which does the work of detecting changes
    // and which this method will call.
    // This method expects that `detectChangesInRecordsInternal` will set the property
    // `this.propertyBindingIndex` to the propertyBindingIndex of the first proto record. This is to
    // facilitate error reporting.
    AbstractChangeDetector.prototype.detectChangesInRecords = function (throwOnChange) {
        if (!this.hydrated()) {
            this.throwDehydratedError();
        }
        try {
            this.detectChangesInRecordsInternal(throwOnChange);
        }
        catch (e) {
            this._throwError(e, e.stack);
        }
    };
    // Subclasses should override this method to perform any work necessary to detect and report
    // changes. For example, changes should be reported via `ChangeDetectionUtil.addChange`, lifecycle
    // methods should be called, etc.
    // This implementation should also set `this.propertyBindingIndex` to the propertyBindingIndex of
    // the
    // first proto record to facilitate error reporting. See {@link #detectChangesInRecords}.
    AbstractChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) { };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `hydrateDirectives`.
    AbstractChangeDetector.prototype.hydrate = function (context, locals, directives, pipes) {
        this.mode = change_detection_util_1.ChangeDetectionUtil.changeDetectionMode(this.strategy);
        this.context = context;
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            this.observeComponent(context);
        }
        this.locals = locals;
        this.pipes = pipes;
        this.hydrateDirectives(directives);
        this.alreadyChecked = false;
    };
    // Subclasses should override this method to hydrate any directives.
    AbstractChangeDetector.prototype.hydrateDirectives = function (directives) { };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `dehydrateDirectives`.
    AbstractChangeDetector.prototype.dehydrate = function () {
        this.dehydrateDirectives(true);
        // This is an experimental feature. Works only in Dart.
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            this._unsubsribeFromObservables();
        }
        this.context = null;
        this.locals = null;
        this.pipes = null;
    };
    // Subclasses should override this method to dehydrate any directives. This method should reverse
    // any work done in `hydrateDirectives`.
    AbstractChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) { };
    AbstractChangeDetector.prototype.hydrated = function () { return this.context !== null; };
    AbstractChangeDetector.prototype.afterContentLifecycleCallbacks = function () {
        this.dispatcher.notifyAfterContentChecked();
        this.afterContentLifecycleCallbacksInternal();
    };
    AbstractChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () { };
    AbstractChangeDetector.prototype.afterViewLifecycleCallbacks = function () {
        this.dispatcher.notifyAfterViewChecked();
        this.afterViewLifecycleCallbacksInternal();
    };
    AbstractChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () { };
    /** @internal */
    AbstractChangeDetector.prototype._detectChangesInLightDomChildren = function (throwOnChange) {
        var c = this.lightDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    };
    /** @internal */
    AbstractChangeDetector.prototype._detectChangesInShadowDomChildren = function (throwOnChange) {
        var c = this.shadowDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    };
    AbstractChangeDetector.prototype.markAsCheckOnce = function () { this.mode = constants_1.ChangeDetectionStrategy.CheckOnce; };
    AbstractChangeDetector.prototype.markPathToRootAsCheckOnce = function () {
        var c = this;
        while (lang_1.isPresent(c) && c.mode !== constants_1.ChangeDetectionStrategy.Detached) {
            if (c.mode === constants_1.ChangeDetectionStrategy.Checked)
                c.mode = constants_1.ChangeDetectionStrategy.CheckOnce;
            c = c.parent;
        }
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype._unsubsribeFromObservables = function () {
        if (lang_1.isPresent(this.subscriptions)) {
            for (var i = 0; i < this.subscriptions.length; ++i) {
                var s = this.subscriptions[i];
                if (lang_1.isPresent(this.subscriptions[i])) {
                    s.cancel();
                    this.subscriptions[i] = null;
                }
            }
        }
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeValue = function (value, index) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            if (lang_1.isBlank(this.subscriptions[index])) {
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
            }
            else if (this.streams[index] !== value.changes) {
                this.subscriptions[index].cancel();
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
            }
        }
        return value;
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeDirective = function (value, index) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            var arrayIndex = this.numberOfPropertyProtoRecords + index + 2; // +1 is component
            this.streams[arrayIndex] = value.changes;
            this.subscriptions[arrayIndex] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
        }
        return value;
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeComponent = function (value) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            var index = this.numberOfPropertyProtoRecords + 1;
            this.streams[index] = value.changes;
            this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
        }
        return value;
    };
    AbstractChangeDetector.prototype._createArrayToStoreObservables = function () {
        if (lang_1.isBlank(this.subscriptions)) {
            this.subscriptions = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
                this.directiveIndices.length + 2);
            this.streams = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
                this.directiveIndices.length + 2);
        }
    };
    AbstractChangeDetector.prototype.getDirectiveFor = function (directives, index) {
        return directives.getDirectiveFor(this.directiveIndices[index]);
    };
    AbstractChangeDetector.prototype.getDetectorFor = function (directives, index) {
        return directives.getDetectorFor(this.directiveIndices[index]);
    };
    AbstractChangeDetector.prototype.notifyDispatcher = function (value) {
        this.dispatcher.notifyOnBinding(this._currentBinding(), value);
    };
    AbstractChangeDetector.prototype.logBindingUpdate = function (value) {
        this.dispatcher.logBindingUpdate(this._currentBinding(), value);
    };
    AbstractChangeDetector.prototype.addChange = function (changes, oldValue, newValue) {
        if (lang_1.isBlank(changes)) {
            changes = {};
        }
        changes[this._currentBinding().name] = change_detection_util_1.ChangeDetectionUtil.simpleChange(oldValue, newValue);
        return changes;
    };
    AbstractChangeDetector.prototype._throwError = function (exception, stack) {
        var error;
        try {
            var c = this.dispatcher.getDebugContext(this._currentBinding().elementIndex, null);
            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector, this._currentBinding().debug) :
                null;
            error = new exceptions_2.ChangeDetectionError(this._currentBinding().debug, exception, stack, context);
        }
        catch (e) {
            // if an error happens during getting the debug context, we throw a ChangeDetectionError
            // without the extra information.
            error = new exceptions_2.ChangeDetectionError(null, exception, stack, null);
        }
        throw error;
    };
    AbstractChangeDetector.prototype.throwOnChangeError = function (oldValue, newValue) {
        throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(this._currentBinding().debug, oldValue, newValue, null);
    };
    AbstractChangeDetector.prototype.throwDehydratedError = function () { throw new exceptions_2.DehydratedException(); };
    AbstractChangeDetector.prototype._currentBinding = function () {
        return this.bindingTargets[this.propertyBindingIndex];
    };
    return AbstractChangeDetector;
})();
exports.AbstractChangeDetector = AbstractChangeDetector;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./change_detector_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js","./observable_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/observable_facade.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var DIRECTIVE_LIFECYCLE = "directiveLifecycle";
var BINDING = "native";
var DIRECTIVE = "directive";
var ELEMENT_PROPERTY = "elementProperty";
var ELEMENT_ATTRIBUTE = "elementAttribute";
var ELEMENT_CLASS = "elementClass";
var ELEMENT_STYLE = "elementStyle";
var TEXT_NODE = "textNode";
var EVENT = "event";
var HOST_EVENT = "hostEvent";
var BindingTarget = (function () {
    function BindingTarget(mode, elementIndex, name, unit, debug) {
        this.mode = mode;
        this.elementIndex = elementIndex;
        this.name = name;
        this.unit = unit;
        this.debug = debug;
    }
    BindingTarget.prototype.isDirective = function () { return this.mode === DIRECTIVE; };
    BindingTarget.prototype.isElementProperty = function () { return this.mode === ELEMENT_PROPERTY; };
    BindingTarget.prototype.isElementAttribute = function () { return this.mode === ELEMENT_ATTRIBUTE; };
    BindingTarget.prototype.isElementClass = function () { return this.mode === ELEMENT_CLASS; };
    BindingTarget.prototype.isElementStyle = function () { return this.mode === ELEMENT_STYLE; };
    BindingTarget.prototype.isTextNode = function () { return this.mode === TEXT_NODE; };
    return BindingTarget;
})();
exports.BindingTarget = BindingTarget;
var BindingRecord = (function () {
    function BindingRecord(mode, target, implicitReceiver, ast, setter, lifecycleEvent, directiveRecord) {
        this.mode = mode;
        this.target = target;
        this.implicitReceiver = implicitReceiver;
        this.ast = ast;
        this.setter = setter;
        this.lifecycleEvent = lifecycleEvent;
        this.directiveRecord = directiveRecord;
    }
    BindingRecord.prototype.isDirectiveLifecycle = function () { return this.mode === DIRECTIVE_LIFECYCLE; };
    BindingRecord.prototype.callOnChanges = function () {
        return lang_1.isPresent(this.directiveRecord) && this.directiveRecord.callOnChanges;
    };
    BindingRecord.prototype.isDefaultChangeDetection = function () {
        return lang_1.isBlank(this.directiveRecord) || this.directiveRecord.isDefaultChangeDetection();
    };
    BindingRecord.createDirectiveDoCheck = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "DoCheck", directiveRecord);
    };
    BindingRecord.createDirectiveOnInit = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnInit", directiveRecord);
    };
    BindingRecord.createDirectiveOnChanges = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnChanges", directiveRecord);
    };
    BindingRecord.createForDirective = function (ast, propertyName, setter, directiveRecord) {
        var elementIndex = directiveRecord.directiveIndex.elementIndex;
        var t = new BindingTarget(DIRECTIVE, elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(DIRECTIVE, t, 0, ast, setter, null, directiveRecord);
    };
    BindingRecord.createForElementProperty = function (ast, elementIndex, propertyName) {
        var t = new BindingTarget(ELEMENT_PROPERTY, elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementAttribute = function (ast, elementIndex, attributeName) {
        var t = new BindingTarget(ELEMENT_ATTRIBUTE, elementIndex, attributeName, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementClass = function (ast, elementIndex, className) {
        var t = new BindingTarget(ELEMENT_CLASS, elementIndex, className, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementStyle = function (ast, elementIndex, styleName, unit) {
        var t = new BindingTarget(ELEMENT_STYLE, elementIndex, styleName, unit, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForHostProperty = function (directiveIndex, ast, propertyName) {
        var t = new BindingTarget(ELEMENT_PROPERTY, directiveIndex.elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostAttribute = function (directiveIndex, ast, attributeName) {
        var t = new BindingTarget(ELEMENT_ATTRIBUTE, directiveIndex.elementIndex, attributeName, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostClass = function (directiveIndex, ast, className) {
        var t = new BindingTarget(ELEMENT_CLASS, directiveIndex.elementIndex, className, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostStyle = function (directiveIndex, ast, styleName, unit) {
        var t = new BindingTarget(ELEMENT_STYLE, directiveIndex.elementIndex, styleName, unit, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForTextNode = function (ast, elementIndex) {
        var t = new BindingTarget(TEXT_NODE, elementIndex, null, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForEvent = function (ast, eventName, elementIndex) {
        var t = new BindingTarget(EVENT, elementIndex, eventName, null, ast.toString());
        return new BindingRecord(EVENT, t, 0, ast, null, null, null);
    };
    BindingRecord.createForHostEvent = function (ast, eventName, directiveRecord) {
        var directiveIndex = directiveRecord.directiveIndex;
        var t = new BindingTarget(HOST_EVENT, directiveIndex.elementIndex, eventName, null, ast.toString());
        return new BindingRecord(HOST_EVENT, t, directiveIndex, ast, null, null, directiveRecord);
    };
    return BindingRecord;
})();
exports.BindingRecord = BindingRecord;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js":[function(require,module,exports){
'use strict';var iterable_differs_1 = require('./differs/iterable_differs');
var default_iterable_differ_1 = require('./differs/default_iterable_differ');
var keyvalue_differs_1 = require('./differs/keyvalue_differs');
var default_keyvalue_differ_1 = require('./differs/default_keyvalue_differ');
var lang_1 = require('angular2/src/core/facade/lang');
var ast_1 = require('./parser/ast');
exports.ASTWithSource = ast_1.ASTWithSource;
exports.AST = ast_1.AST;
exports.AstTransformer = ast_1.AstTransformer;
exports.PropertyRead = ast_1.PropertyRead;
exports.LiteralArray = ast_1.LiteralArray;
exports.ImplicitReceiver = ast_1.ImplicitReceiver;
var lexer_1 = require('./parser/lexer');
exports.Lexer = lexer_1.Lexer;
var parser_1 = require('./parser/parser');
exports.Parser = parser_1.Parser;
var locals_1 = require('./parser/locals');
exports.Locals = locals_1.Locals;
var exceptions_1 = require('./exceptions');
exports.DehydratedException = exceptions_1.DehydratedException;
exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
exports.ChangeDetectionError = exceptions_1.ChangeDetectionError;
var interfaces_1 = require('./interfaces');
exports.ChangeDetectorDefinition = interfaces_1.ChangeDetectorDefinition;
exports.DebugContext = interfaces_1.DebugContext;
exports.ChangeDetectorGenConfig = interfaces_1.ChangeDetectorGenConfig;
var constants_1 = require('./constants');
exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
exports.CHANGE_DECTION_STRATEGY_VALUES = constants_1.CHANGE_DECTION_STRATEGY_VALUES;
var proto_change_detector_1 = require('./proto_change_detector');
exports.DynamicProtoChangeDetector = proto_change_detector_1.DynamicProtoChangeDetector;
var jit_proto_change_detector_1 = require('./jit_proto_change_detector');
exports.JitProtoChangeDetector = jit_proto_change_detector_1.JitProtoChangeDetector;
var binding_record_1 = require('./binding_record');
exports.BindingRecord = binding_record_1.BindingRecord;
exports.BindingTarget = binding_record_1.BindingTarget;
var directive_record_1 = require('./directive_record');
exports.DirectiveIndex = directive_record_1.DirectiveIndex;
exports.DirectiveRecord = directive_record_1.DirectiveRecord;
var dynamic_change_detector_1 = require('./dynamic_change_detector');
exports.DynamicChangeDetector = dynamic_change_detector_1.DynamicChangeDetector;
var change_detector_ref_1 = require('./change_detector_ref');
exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
var iterable_differs_2 = require('./differs/iterable_differs');
exports.IterableDiffers = iterable_differs_2.IterableDiffers;
var keyvalue_differs_2 = require('./differs/keyvalue_differs');
exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
var change_detection_util_1 = require('./change_detection_util');
exports.WrappedValue = change_detection_util_1.WrappedValue;
exports.SimpleChange = change_detection_util_1.SimpleChange;
/**
 * Structural diffing for `Object`s and `Map`s.
 */
exports.keyValDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_keyvalue_differ_1.DefaultKeyValueDifferFactory())]);
/**
 * Structural diffing for `Iterable` types such as `Array`s.
 */
exports.iterableDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_iterable_differ_1.DefaultIterableDifferFactory())]);
exports.defaultIterableDiffers = lang_1.CONST_EXPR(new iterable_differs_1.IterableDiffers(exports.iterableDiff));
exports.defaultKeyValueDiffers = lang_1.CONST_EXPR(new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff));

},{"./binding_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./change_detector_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./differs/default_iterable_differ":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_iterable_differ.js","./differs/default_keyvalue_differ":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_keyvalue_differ.js","./differs/iterable_differs":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/iterable_differs.js","./differs/keyvalue_differs":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/keyvalue_differs.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./dynamic_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js","./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js","./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js","./jit_proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/jit_proto_change_detector.js","./parser/ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./parser/lexer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js","./parser/locals":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/locals.js","./parser/parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/parser.js","./proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var abstract_change_detector_1 = require('./abstract_change_detector');
var change_detection_util_1 = require('./change_detection_util');
var codegen_name_util_1 = require('./codegen_name_util');
var codegen_logic_util_1 = require('./codegen_logic_util');
var codegen_facade_1 = require('./codegen_facade');
var proto_change_detector_1 = require('./proto_change_detector');
/**
 * The code generator takes a list of proto records and creates a function/class
 * that "emulates" what the developer would write by hand to implement the same
 * kind of behaviour.
 *
 * This code should be kept in sync with the Dart transformer's
 * `angular2.transform.template_compiler.change_detector_codegen` library. If you make updates
 * here, please make equivalent changes there.
*/
var IS_CHANGED_LOCAL = "isChanged";
var CHANGES_LOCAL = "changes";
var ChangeDetectorJITGenerator = (function () {
    function ChangeDetectorJITGenerator(definition, changeDetectionUtilVarName, abstractChangeDetectorVarName) {
        this.changeDetectionUtilVarName = changeDetectionUtilVarName;
        this.abstractChangeDetectorVarName = abstractChangeDetectorVarName;
        var propertyBindingRecords = proto_change_detector_1.createPropertyRecords(definition);
        var eventBindingRecords = proto_change_detector_1.createEventRecords(definition);
        var propertyBindingTargets = definition.bindingRecords.map(function (b) { return b.target; });
        this.id = definition.id;
        this.changeDetectionStrategy = definition.strategy;
        this.genConfig = definition.genConfig;
        this.records = propertyBindingRecords;
        this.propertyBindingTargets = propertyBindingTargets;
        this.eventBindings = eventBindingRecords;
        this.directiveRecords = definition.directiveRecords;
        this._names = new codegen_name_util_1.CodegenNameUtil(this.records, this.eventBindings, this.directiveRecords, this.changeDetectionUtilVarName);
        this._logic = new codegen_logic_util_1.CodegenLogicUtil(this._names, this.changeDetectionUtilVarName, this.changeDetectionStrategy);
        this.typeName = codegen_name_util_1.sanitizeName("ChangeDetector_" + this.id);
    }
    ChangeDetectorJITGenerator.prototype.generate = function () {
        var factorySource = "\n      " + this.generateSource() + "\n      return function(dispatcher) {\n        return new " + this.typeName + "(dispatcher);\n      }\n    ";
        return new Function(this.abstractChangeDetectorVarName, this.changeDetectionUtilVarName, factorySource)(abstract_change_detector_1.AbstractChangeDetector, change_detection_util_1.ChangeDetectionUtil);
    };
    ChangeDetectorJITGenerator.prototype.generateSource = function () {
        var _this = this;
        return "\n      var " + this.typeName + " = function " + this.typeName + "(dispatcher) {\n        " + this.abstractChangeDetectorVarName + ".call(\n            this, " + JSON.stringify(this.id) + ", dispatcher, " + this.records.length + ",\n            " + this.typeName + ".gen_propertyBindingTargets, " + this.typeName + ".gen_directiveIndices,\n            " + codegen_facade_1.codify(this.changeDetectionStrategy) + ");\n        this.dehydrateDirectives(false);\n      }\n\n      " + this.typeName + ".prototype = Object.create(" + this.abstractChangeDetectorVarName + ".prototype);\n\n      " + this.typeName + ".prototype.detectChangesInRecordsInternal = function(throwOnChange) {\n        " + this._names.genInitLocals() + "\n        var " + IS_CHANGED_LOCAL + " = false;\n        var " + CHANGES_LOCAL + " = null;\n\n        " + this.records.map(function (r) { return _this._genRecord(r); }).join("\n") + "\n      }\n\n      " + this._maybeGenHandleEventInternal() + "\n\n      " + this._genCheckNoChanges() + "\n\n      " + this._maybeGenAfterContentLifecycleCallbacks() + "\n\n      " + this._maybeGenAfterViewLifecycleCallbacks() + "\n\n      " + this._maybeGenHydrateDirectives() + "\n\n      " + this._maybeGenDehydrateDirectives() + "\n\n      " + this._genPropertyBindingTargets() + "\n\n      " + this._genDirectiveIndices() + "\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genPropertyBindingTargets = function () {
        var targets = this._logic.genPropertyBindingTargets(this.propertyBindingTargets, this.genConfig.genDebugInfo);
        return this.typeName + ".gen_propertyBindingTargets = " + targets + ";";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genDirectiveIndices = function () {
        var indices = this._logic.genDirectiveIndices(this.directiveRecords);
        return this.typeName + ".gen_directiveIndices = " + indices + ";";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenHandleEventInternal = function () {
        var _this = this;
        if (this.eventBindings.length > 0) {
            var handlers = this.eventBindings.map(function (eb) { return _this._genEventBinding(eb); }).join("\n");
            return "\n        " + this.typeName + ".prototype.handleEventInternal = function(eventName, elIndex, locals) {\n          var " + this._names.getPreventDefaultAccesor() + " = false;\n          " + this._names.genInitEventLocals() + "\n          " + handlers + "\n          return " + this._names.getPreventDefaultAccesor() + ";\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genEventBinding = function (eb) {
        var _this = this;
        var recs = eb.records.map(function (r) { return _this._genEventBindingEval(eb, r); }).join("\n");
        return "\n    if (eventName === \"" + eb.eventName + "\" && elIndex === " + eb.elIndex + ") {\n      " + recs + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genEventBindingEval = function (eb, r) {
        if (r.lastInBinding) {
            var evalRecord = this._logic.genEventBindingEvalValue(eb, r);
            var markPath = this._genMarkPathToRootAsCheckOnce(r);
            var prevDefault = this._genUpdatePreventDefault(eb, r);
            return evalRecord + "\n" + markPath + "\n" + prevDefault;
        }
        else {
            return this._logic.genEventBindingEvalValue(eb, r);
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genMarkPathToRootAsCheckOnce = function (r) {
        var br = r.bindingRecord;
        if (br.isDefaultChangeDetection()) {
            return "";
        }
        else {
            return this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markPathToRootAsCheckOnce();";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genUpdatePreventDefault = function (eb, r) {
        var local = this._names.getEventLocalName(eb, r.selfIndex);
        return "if (" + local + " === false) { " + this._names.getPreventDefaultAccesor() + " = true};";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenDehydrateDirectives = function () {
        var destroyPipesCode = this._names.genPipeOnDestroy();
        if (destroyPipesCode) {
            destroyPipesCode = "if (destroyPipes) { " + destroyPipesCode + " }";
        }
        var dehydrateFieldsCode = this._names.genDehydrateFields();
        if (!destroyPipesCode && !dehydrateFieldsCode)
            return '';
        return this.typeName + ".prototype.dehydrateDirectives = function(destroyPipes) {\n        " + destroyPipesCode + "\n        " + dehydrateFieldsCode + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenHydrateDirectives = function () {
        var hydrateDirectivesCode = this._logic.genHydrateDirectives(this.directiveRecords);
        var hydrateDetectorsCode = this._logic.genHydrateDetectors(this.directiveRecords);
        if (!hydrateDirectivesCode && !hydrateDetectorsCode)
            return '';
        return this.typeName + ".prototype.hydrateDirectives = function(directives) {\n      " + hydrateDirectivesCode + "\n      " + hydrateDetectorsCode + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenAfterContentLifecycleCallbacks = function () {
        var notifications = this._logic.genContentLifecycleCallbacks(this.directiveRecords);
        if (notifications.length > 0) {
            var directiveNotifications = notifications.join("\n");
            return "\n        " + this.typeName + ".prototype.afterContentLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenAfterViewLifecycleCallbacks = function () {
        var notifications = this._logic.genViewLifecycleCallbacks(this.directiveRecords);
        if (notifications.length > 0) {
            var directiveNotifications = notifications.join("\n");
            return "\n        " + this.typeName + ".prototype.afterViewLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genRecord = function (r) {
        var rec;
        if (r.isLifeCycleRecord()) {
            rec = this._genDirectiveLifecycle(r);
        }
        else if (r.isPipeRecord()) {
            rec = this._genPipeCheck(r);
        }
        else {
            rec = this._genReferenceCheck(r);
        }
        return "\n      " + this._maybeFirstInBinding(r) + "\n      " + rec + "\n      " + this._maybeGenLastInDirective(r) + "\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genDirectiveLifecycle = function (r) {
        if (r.name === "DoCheck") {
            return this._genOnCheck(r);
        }
        else if (r.name === "OnInit") {
            return this._genOnInit(r);
        }
        else if (r.name === "OnChanges") {
            return this._genOnChange(r);
        }
        else {
            throw new exceptions_1.BaseException("Unknown lifecycle event '" + r.name + "'");
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genPipeCheck = function (r) {
        var _this = this;
        var context = this._names.getLocalName(r.contextIndex);
        var argString = r.args.map(function (arg) { return _this._names.getLocalName(arg); }).join(", ");
        var oldValue = this._names.getFieldName(r.selfIndex);
        var newValue = this._names.getLocalName(r.selfIndex);
        var pipe = this._names.getPipeName(r.selfIndex);
        var pipeName = r.name;
        var init = "\n      if (" + pipe + " === " + this.changeDetectionUtilVarName + ".uninitialized) {\n        " + pipe + " = " + this._names.getPipesAccessorName() + ".get('" + pipeName + "');\n      }\n    ";
        var read = newValue + " = " + pipe + ".pipe.transform(" + context + ", [" + argString + "]);";
        var contexOrArgCheck = r.args.map(function (a) { return _this._names.getChangeName(a); });
        contexOrArgCheck.push(this._names.getChangeName(r.contextIndex));
        var condition = "!" + pipe + ".pure || (" + contexOrArgCheck.join(" || ") + ")";
        var check = "\n      if (" + oldValue + " !== " + newValue + ") {\n        " + newValue + " = " + this.changeDetectionUtilVarName + ".unwrapValue(" + newValue + ")\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
        var genCode = r.shouldBeChecked() ? "" + read + check : read;
        if (r.isUsedByOtherRecord()) {
            return init + " if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
        }
        else {
            return init + " if (" + condition + ") { " + genCode + " }";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genReferenceCheck = function (r) {
        var _this = this;
        var oldValue = this._names.getFieldName(r.selfIndex);
        var newValue = this._names.getLocalName(r.selfIndex);
        var read = "\n      " + this._logic.genPropertyBindingEvalValue(r) + "\n    ";
        var check = "\n      if (" + newValue + " !== " + oldValue + ") {\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
        var genCode = r.shouldBeChecked() ? "" + read + check : read;
        if (r.isPureFunction()) {
            var condition = r.args.map(function (a) { return _this._names.getChangeName(a); }).join(" || ");
            if (r.isUsedByOtherRecord()) {
                return "if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
            }
            else {
                return "if (" + condition + ") { " + genCode + " }";
            }
        }
        else {
            return genCode;
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genChangeMarker = function (r) {
        return r.argumentToPureFunction ? this._names.getChangeName(r.selfIndex) + " = true" : "";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genUpdateDirectiveOrElement = function (r) {
        if (!r.lastInBinding)
            return "";
        var newValue = this._names.getLocalName(r.selfIndex);
        var oldValue = this._names.getFieldName(r.selfIndex);
        var notifyDebug = this.genConfig.logBindingUpdate ? "this.logBindingUpdate(" + newValue + ");" : "";
        var br = r.bindingRecord;
        if (br.target.isDirective()) {
            var directiveProperty = this._names.getDirectiveName(br.directiveRecord.directiveIndex) + "." + br.target.name;
            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + directiveProperty + " = " + newValue + ";\n        " + notifyDebug + "\n        " + IS_CHANGED_LOCAL + " = true;\n      ";
        }
        else {
            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        this.notifyDispatcher(" + newValue + ");\n        " + notifyDebug + "\n      ";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genThrowOnChangeCheck = function (oldValue, newValue) {
        if (this.genConfig.genCheckNoChanges) {
            return "\n        if(throwOnChange) {\n          this.throwOnChangeError(" + oldValue + ", " + newValue + ");\n        }\n        ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genCheckNoChanges = function () {
        if (this.genConfig.genCheckNoChanges) {
            return this.typeName + ".prototype.checkNoChanges = function() { this.runDetectChanges(true); }";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genAddToChanges = function (r) {
        var newValue = this._names.getLocalName(r.selfIndex);
        var oldValue = this._names.getFieldName(r.selfIndex);
        if (!r.bindingRecord.callOnChanges())
            return "";
        return CHANGES_LOCAL + " = this.addChange(" + CHANGES_LOCAL + ", " + oldValue + ", " + newValue + ");";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeFirstInBinding = function (r) {
        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);
        var firstInBindng = lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
        return firstInBindng && !r.bindingRecord.isDirectiveLifecycle() ?
            this._names.getPropertyBindingIndex() + " = " + r.propertyBindingIndex + ";" :
            '';
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenLastInDirective = function (r) {
        if (!r.lastInDirective)
            return "";
        return "\n      " + CHANGES_LOCAL + " = null;\n      " + this._genNotifyOnPushDetectors(r) + "\n      " + IS_CHANGED_LOCAL + " = false;\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnCheck = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange) " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".doCheck();";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnInit = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange && !" + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onInit();";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnChange = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange && " + CHANGES_LOCAL + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onChanges(" + CHANGES_LOCAL + ");";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genNotifyOnPushDetectors = function (r) {
        var br = r.bindingRecord;
        if (!r.lastInDirective || br.isDefaultChangeDetection())
            return "";
        var retVal = "\n      if(" + IS_CHANGED_LOCAL + ") {\n        " + this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markAsCheckOnce();\n      }\n    ";
        return retVal;
    };
    return ChangeDetectorJITGenerator;
})();
exports.ChangeDetectorJITGenerator = ChangeDetectorJITGenerator;

},{"./abstract_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./codegen_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js","./codegen_logic_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_logic_util.js","./codegen_name_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_name_util.js","./proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var constants_1 = require('./constants');
var pipe_lifecycle_reflector_1 = require('./pipe_lifecycle_reflector');
var binding_record_1 = require('./binding_record');
var directive_record_1 = require('./directive_record');
/**
 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
 * reference
 * has not changed.
 *
 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
 *
 * Example:
 *
 * ```
 * if (this._latestValue === this._latestReturnedValue) {
 *    return this._latestReturnedValue;
 *  } else {
 *    this._latestReturnedValue = this._latestValue;
 *    return WrappedValue.wrap(this._latestValue); // this will force update
 *  }
 * ```
 */
var WrappedValue = (function () {
    function WrappedValue(wrapped) {
        this.wrapped = wrapped;
    }
    WrappedValue.wrap = function (value) {
        var w = _wrappedValues[_wrappedIndex++ % 5];
        w.wrapped = value;
        return w;
    };
    return WrappedValue;
})();
exports.WrappedValue = WrappedValue;
var _wrappedValues = [
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null)
];
var _wrappedIndex = 0;
var SimpleChange = (function () {
    function SimpleChange(previousValue, currentValue) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
    }
    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === ChangeDetectionUtil.uninitialized; };
    return SimpleChange;
})();
exports.SimpleChange = SimpleChange;
var _simpleChangesIndex = 0;
var _simpleChanges = [
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null)
];
function _simpleChange(previousValue, currentValue) {
    var index = _simpleChangesIndex++ % 20;
    var s = _simpleChanges[index];
    s.previousValue = previousValue;
    s.currentValue = currentValue;
    return s;
}
/* tslint:disable:requireParameterType */
var ChangeDetectionUtil = (function () {
    function ChangeDetectionUtil() {
    }
    ChangeDetectionUtil.arrayFn0 = function () { return []; };
    ChangeDetectionUtil.arrayFn1 = function (a1) { return [a1]; };
    ChangeDetectionUtil.arrayFn2 = function (a1, a2) { return [a1, a2]; };
    ChangeDetectionUtil.arrayFn3 = function (a1, a2, a3) { return [a1, a2, a3]; };
    ChangeDetectionUtil.arrayFn4 = function (a1, a2, a3, a4) { return [a1, a2, a3, a4]; };
    ChangeDetectionUtil.arrayFn5 = function (a1, a2, a3, a4, a5) { return [a1, a2, a3, a4, a5]; };
    ChangeDetectionUtil.arrayFn6 = function (a1, a2, a3, a4, a5, a6) { return [a1, a2, a3, a4, a5, a6]; };
    ChangeDetectionUtil.arrayFn7 = function (a1, a2, a3, a4, a5, a6, a7) { return [a1, a2, a3, a4, a5, a6, a7]; };
    ChangeDetectionUtil.arrayFn8 = function (a1, a2, a3, a4, a5, a6, a7, a8) {
        return [a1, a2, a3, a4, a5, a6, a7, a8];
    };
    ChangeDetectionUtil.arrayFn9 = function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
    };
    ChangeDetectionUtil.operation_negate = function (value) { return !value; };
    ChangeDetectionUtil.operation_add = function (left, right) { return left + right; };
    ChangeDetectionUtil.operation_subtract = function (left, right) { return left - right; };
    ChangeDetectionUtil.operation_multiply = function (left, right) { return left * right; };
    ChangeDetectionUtil.operation_divide = function (left, right) { return left / right; };
    ChangeDetectionUtil.operation_remainder = function (left, right) { return left % right; };
    ChangeDetectionUtil.operation_equals = function (left, right) { return left == right; };
    ChangeDetectionUtil.operation_not_equals = function (left, right) { return left != right; };
    ChangeDetectionUtil.operation_identical = function (left, right) { return left === right; };
    ChangeDetectionUtil.operation_not_identical = function (left, right) { return left !== right; };
    ChangeDetectionUtil.operation_less_then = function (left, right) { return left < right; };
    ChangeDetectionUtil.operation_greater_then = function (left, right) { return left > right; };
    ChangeDetectionUtil.operation_less_or_equals_then = function (left, right) { return left <= right; };
    ChangeDetectionUtil.operation_greater_or_equals_then = function (left, right) { return left >= right; };
    ChangeDetectionUtil.operation_logical_and = function (left, right) { return left && right; };
    ChangeDetectionUtil.operation_logical_or = function (left, right) { return left || right; };
    ChangeDetectionUtil.cond = function (cond, trueVal, falseVal) { return cond ? trueVal : falseVal; };
    ChangeDetectionUtil.mapFn = function (keys) {
        function buildMap(values) {
            var res = collection_1.StringMapWrapper.create();
            for (var i = 0; i < keys.length; ++i) {
                collection_1.StringMapWrapper.set(res, keys[i], values[i]);
            }
            return res;
        }
        switch (keys.length) {
            case 0:
                return function () { return []; };
            case 1:
                return function (a1) { return buildMap([a1]); };
            case 2:
                return function (a1, a2) { return buildMap([a1, a2]); };
            case 3:
                return function (a1, a2, a3) { return buildMap([a1, a2, a3]); };
            case 4:
                return function (a1, a2, a3, a4) { return buildMap([a1, a2, a3, a4]); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return buildMap([a1, a2, a3, a4, a5]); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) { return buildMap([a1, a2, a3, a4, a5, a6]); };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) { return buildMap([a1, a2, a3, a4, a5, a6, a7]); };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]); };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                };
            default:
                throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
        }
    };
    ChangeDetectionUtil.keyedAccess = function (obj, args) { return obj[args[0]]; };
    ChangeDetectionUtil.unwrapValue = function (value) {
        if (value instanceof WrappedValue) {
            return value.wrapped;
        }
        else {
            return value;
        }
    };
    ChangeDetectionUtil.changeDetectionMode = function (strategy) {
        return constants_1.isDefaultChangeDetectionStrategy(strategy) ? constants_1.ChangeDetectionStrategy.CheckAlways :
            constants_1.ChangeDetectionStrategy.CheckOnce;
    };
    ChangeDetectionUtil.simpleChange = function (previousValue, currentValue) {
        return _simpleChange(previousValue, currentValue);
    };
    ChangeDetectionUtil.isValueBlank = function (value) { return lang_1.isBlank(value); };
    ChangeDetectionUtil.s = function (value) { return lang_1.isPresent(value) ? "" + value : ''; };
    ChangeDetectionUtil.protoByIndex = function (protos, selfIndex) {
        return selfIndex < 1 ?
            null :
            protos[selfIndex - 1]; // self index is shifted by one because of context
    };
    ChangeDetectionUtil.callPipeOnDestroy = function (selectedPipe) {
        if (pipe_lifecycle_reflector_1.implementsOnDestroy(selectedPipe.pipe)) {
            selectedPipe.pipe.onDestroy();
        }
    };
    ChangeDetectionUtil.bindingTarget = function (mode, elementIndex, name, unit, debug) {
        return new binding_record_1.BindingTarget(mode, elementIndex, name, unit, debug);
    };
    ChangeDetectionUtil.directiveIndex = function (elementIndex, directiveIndex) {
        return new directive_record_1.DirectiveIndex(elementIndex, directiveIndex);
    };
    ChangeDetectionUtil.uninitialized = lang_1.CONST_EXPR(new Object());
    return ChangeDetectionUtil;
})();
exports.ChangeDetectionUtil = ChangeDetectionUtil;

},{"./binding_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./pipe_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipe_lifecycle_reflector.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var constants_1 = require('./constants');
var ChangeDetectorRef = (function () {
    function ChangeDetectorRef() {
    }
    return ChangeDetectorRef;
})();
exports.ChangeDetectorRef = ChangeDetectorRef;
var ChangeDetectorRef_ = (function (_super) {
    __extends(ChangeDetectorRef_, _super);
    function ChangeDetectorRef_(_cd) {
        _super.call(this);
        this._cd = _cd;
    }
    ChangeDetectorRef_.prototype.markForCheck = function () { this._cd.markPathToRootAsCheckOnce(); };
    ChangeDetectorRef_.prototype.detach = function () { this._cd.mode = constants_1.ChangeDetectionStrategy.Detached; };
    ChangeDetectorRef_.prototype.detectChanges = function () { this._cd.detectChanges(); };
    ChangeDetectorRef_.prototype.reattach = function () {
        this._cd.mode = constants_1.ChangeDetectionStrategy.CheckAlways;
        this.markForCheck();
    };
    return ChangeDetectorRef_;
})(ChangeDetectorRef);
exports.ChangeDetectorRef_ = ChangeDetectorRef_;

},{"./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/coalesce.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var proto_record_1 = require('./proto_record');
/**
 * Removes "duplicate" records. It assuming that record evaluation does not
 * have side-effects.
 *
 * Records that are not last in bindings are removed and all the indices
 * of the records that depend on them are updated.
 *
 * Records that are last in bindings CANNOT be removed, and instead are
 * replaced with very cheap SELF records.
 */
function coalesce(records) {
    var res = [];
    var indexMap = new collection_1.Map();
    for (var i = 0; i < records.length; ++i) {
        var r = records[i];
        var record = _replaceIndices(r, res.length + 1, indexMap);
        var matchingRecord = _findMatching(record, res);
        if (lang_1.isPresent(matchingRecord) && record.lastInBinding) {
            res.push(_selfRecord(record, matchingRecord.selfIndex, res.length + 1));
            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
            matchingRecord.referencedBySelf = true;
        }
        else if (lang_1.isPresent(matchingRecord) && !record.lastInBinding) {
            if (record.argumentToPureFunction) {
                matchingRecord.argumentToPureFunction = true;
            }
            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
        }
        else {
            res.push(record);
            indexMap.set(r.selfIndex, record.selfIndex);
        }
    }
    return res;
}
exports.coalesce = coalesce;
function _selfRecord(r, contextIndex, selfIndex) {
    return new proto_record_1.ProtoRecord(proto_record_1.RecordType.Self, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, false, false, r.propertyBindingIndex);
}
function _findMatching(r, rs) {
    return collection_1.ListWrapper.find(rs, function (rr) { return rr.mode !== proto_record_1.RecordType.DirectiveLifecycle && _sameDirIndex(rr, r) &&
        rr.mode === r.mode && lang_1.looseIdentical(rr.funcOrValue, r.funcOrValue) &&
        rr.contextIndex === r.contextIndex && lang_1.looseIdentical(rr.name, r.name) &&
        collection_1.ListWrapper.equals(rr.args, r.args); });
}
function _sameDirIndex(a, b) {
    var di1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;
    var ei1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;
    var di2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;
    var ei2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;
    return di1 === di2 && ei1 === ei2;
}
function _replaceIndices(r, selfIndex, indexMap) {
    var args = r.args.map(function (a) { return _map(indexMap, a); });
    var contextIndex = _map(indexMap, r.contextIndex);
    return new proto_record_1.ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, r.argumentToPureFunction, r.referencedBySelf, r.propertyBindingIndex);
}
function _map(indexMap, value) {
    var r = indexMap.get(value);
    return lang_1.isPresent(r) ? r : value;
}

},{"./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js":[function(require,module,exports){
'use strict';/**
 * Converts `funcOrValue` to a string which can be used in generated code.
 */
function codify(obj) {
    return JSON.stringify(obj);
}
exports.codify = codify;
function rawString(str) {
    return "'" + str + "'";
}
exports.rawString = rawString;
/**
 * Combine the strings of generated code into a single interpolated string.
 * Each element of `vals` is expected to be a string literal or a codegen'd
 * call to a method returning a string.
 */
function combineGeneratedStrings(vals) {
    return vals.join(' + ');
}
exports.combineGeneratedStrings = combineGeneratedStrings;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_logic_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var codegen_facade_1 = require('./codegen_facade');
var proto_record_1 = require('./proto_record');
var constants_1 = require('./constants');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Class responsible for providing change detection logic for change detector classes.
 */
var CodegenLogicUtil = (function () {
    function CodegenLogicUtil(_names, _utilName, _changeDetection) {
        this._names = _names;
        this._utilName = _utilName;
        this._changeDetection = _changeDetection;
    }
    /**
     * Generates a statement which updates the local variable representing `protoRec` with the current
     * value of the record. Used by property bindings.
     */
    CodegenLogicUtil.prototype.genPropertyBindingEvalValue = function (protoRec) {
        var _this = this;
        return this._genEvalValue(protoRec, function (idx) { return _this._names.getLocalName(idx); }, this._names.getLocalsAccessorName());
    };
    /**
     * Generates a statement which updates the local variable representing `protoRec` with the current
     * value of the record. Used by event bindings.
     */
    CodegenLogicUtil.prototype.genEventBindingEvalValue = function (eventRecord, protoRec) {
        var _this = this;
        return this._genEvalValue(protoRec, function (idx) { return _this._names.getEventLocalName(eventRecord, idx); }, "locals");
    };
    CodegenLogicUtil.prototype._genEvalValue = function (protoRec, getLocalName, localsAccessor) {
        var context = (protoRec.contextIndex == -1) ?
            this._names.getDirectiveName(protoRec.directiveIndex) :
            getLocalName(protoRec.contextIndex);
        var argString = protoRec.args.map(function (arg) { return getLocalName(arg); }).join(", ");
        var rhs;
        switch (protoRec.mode) {
            case proto_record_1.RecordType.Self:
                rhs = context;
                break;
            case proto_record_1.RecordType.Const:
                rhs = codegen_facade_1.codify(protoRec.funcOrValue);
                break;
            case proto_record_1.RecordType.PropertyRead:
                rhs = this._observe(context + "." + protoRec.name, protoRec);
                break;
            case proto_record_1.RecordType.SafeProperty:
                var read = this._observe(context + "." + protoRec.name, protoRec);
                rhs =
                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(read, protoRec);
                break;
            case proto_record_1.RecordType.PropertyWrite:
                rhs = context + "." + protoRec.name + " = " + getLocalName(protoRec.args[0]);
                break;
            case proto_record_1.RecordType.Local:
                rhs = this._observe(localsAccessor + ".get(" + codegen_facade_1.rawString(protoRec.name) + ")", protoRec);
                break;
            case proto_record_1.RecordType.InvokeMethod:
                rhs = this._observe(context + "." + protoRec.name + "(" + argString + ")", protoRec);
                break;
            case proto_record_1.RecordType.SafeMethodInvoke:
                var invoke = context + "." + protoRec.name + "(" + argString + ")";
                rhs =
                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(invoke, protoRec);
                break;
            case proto_record_1.RecordType.InvokeClosure:
                rhs = context + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.PrimitiveOp:
                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.CollectionLiteral:
                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.Interpolate:
                rhs = this._genInterpolation(protoRec);
                break;
            case proto_record_1.RecordType.KeyedRead:
                rhs = this._observe(context + "[" + getLocalName(protoRec.args[0]) + "]", protoRec);
                break;
            case proto_record_1.RecordType.KeyedWrite:
                rhs = context + "[" + getLocalName(protoRec.args[0]) + "] = " + getLocalName(protoRec.args[1]);
                break;
            case proto_record_1.RecordType.Chain:
                rhs = 'null';
                break;
            default:
                throw new exceptions_1.BaseException("Unknown operation " + protoRec.mode);
        }
        return getLocalName(protoRec.selfIndex) + " = " + rhs + ";";
    };
    /** @internal */
    CodegenLogicUtil.prototype._observe = function (exp, rec) {
        // This is an experimental feature. Works only in Dart.
        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            return "this.observeValue(" + exp + ", " + rec.selfIndex + ")";
        }
        else {
            return exp;
        }
    };
    CodegenLogicUtil.prototype.genPropertyBindingTargets = function (propertyBindingTargets, genDebugInfo) {
        var _this = this;
        var bs = propertyBindingTargets.map(function (b) {
            if (lang_1.isBlank(b))
                return "null";
            var debug = genDebugInfo ? codegen_facade_1.codify(b.debug) : "null";
            return _this._utilName + ".bindingTarget(" + codegen_facade_1.codify(b.mode) + ", " + b.elementIndex + ", " + codegen_facade_1.codify(b.name) + ", " + codegen_facade_1.codify(b.unit) + ", " + debug + ")";
        });
        return "[" + bs.join(", ") + "]";
    };
    CodegenLogicUtil.prototype.genDirectiveIndices = function (directiveRecords) {
        var _this = this;
        var bs = directiveRecords.map(function (b) {
            return (_this._utilName + ".directiveIndex(" + b.directiveIndex.elementIndex + ", " + b.directiveIndex.directiveIndex + ")");
        });
        return "[" + bs.join(", ") + "]";
    };
    /** @internal */
    CodegenLogicUtil.prototype._genInterpolation = function (protoRec) {
        var iVals = [];
        for (var i = 0; i < protoRec.args.length; ++i) {
            iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[i]));
            iVals.push(this._utilName + ".s(" + this._names.getLocalName(protoRec.args[i]) + ")");
        }
        iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[protoRec.args.length]));
        return codegen_facade_1.combineGeneratedStrings(iVals);
    };
    CodegenLogicUtil.prototype.genHydrateDirectives = function (directiveRecords) {
        var res = [];
        for (var i = 0; i < directiveRecords.length; ++i) {
            var r = directiveRecords[i];
            res.push(this._names.getDirectiveName(r.directiveIndex) + " = " + this._genReadDirective(i) + ";");
        }
        return res.join("\n");
    };
    CodegenLogicUtil.prototype._genReadDirective = function (index) {
        // This is an experimental feature. Works only in Dart.
        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            return "this.observeDirective(this.getDirectiveFor(directives, " + index + "), " + index + ")";
        }
        else {
            return "this.getDirectiveFor(directives, " + index + ")";
        }
    };
    CodegenLogicUtil.prototype.genHydrateDetectors = function (directiveRecords) {
        var res = [];
        for (var i = 0; i < directiveRecords.length; ++i) {
            var r = directiveRecords[i];
            if (!r.isDefaultChangeDetection()) {
                res.push(this._names.getDetectorName(r.directiveIndex) + " = this.getDetectorFor(directives, " + i + ");");
            }
        }
        return res.join("\n");
    };
    CodegenLogicUtil.prototype.genContentLifecycleCallbacks = function (directiveRecords) {
        var res = [];
        // NOTE(kegluneq): Order is important!
        for (var i = directiveRecords.length - 1; i >= 0; --i) {
            var dir = directiveRecords[i];
            if (dir.callAfterContentInit) {
                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterContentInit();");
            }
            if (dir.callAfterContentChecked) {
                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterContentChecked();");
            }
        }
        return res;
    };
    CodegenLogicUtil.prototype.genViewLifecycleCallbacks = function (directiveRecords) {
        var res = [];
        // NOTE(kegluneq): Order is important!
        for (var i = directiveRecords.length - 1; i >= 0; --i) {
            var dir = directiveRecords[i];
            if (dir.callAfterViewInit) {
                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterViewInit();");
            }
            if (dir.callAfterViewChecked) {
                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterViewChecked();");
            }
        }
        return res;
    };
    return CodegenLogicUtil;
})();
exports.CodegenLogicUtil = CodegenLogicUtil;

},{"./codegen_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_name_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
// The names of these fields must be kept in sync with abstract_change_detector.ts or change
// detection will fail.
var _ALREADY_CHECKED_ACCESSOR = "alreadyChecked";
var _CONTEXT_ACCESSOR = "context";
var _PROP_BINDING_INDEX = "propertyBindingIndex";
var _DIRECTIVES_ACCESSOR = "directiveIndices";
var _DISPATCHER_ACCESSOR = "dispatcher";
var _LOCALS_ACCESSOR = "locals";
var _MODE_ACCESSOR = "mode";
var _PIPES_ACCESSOR = "pipes";
var _PROTOS_ACCESSOR = "protos";
// `context` is always first.
exports.CONTEXT_INDEX = 0;
var _FIELD_PREFIX = 'this.';
var _whiteSpaceRegExp = lang_1.RegExpWrapper.create("\\W", "g");
/**
 * Returns `s` with all non-identifier characters removed.
 */
function sanitizeName(s) {
    return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
}
exports.sanitizeName = sanitizeName;
/**
 * Class responsible for providing field and local variable names for change detector classes.
 * Also provides some convenience functions, for example, declaring variables, destroying pipes,
 * and dehydrating the detector.
 */
var CodegenNameUtil = (function () {
    function CodegenNameUtil(_records, _eventBindings, _directiveRecords, _utilName) {
        this._records = _records;
        this._eventBindings = _eventBindings;
        this._directiveRecords = _directiveRecords;
        this._utilName = _utilName;
        /** @internal */
        this._sanitizedEventNames = new collection_1.Map();
        this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this._records.length + 1);
        this._sanitizedNames[exports.CONTEXT_INDEX] = _CONTEXT_ACCESSOR;
        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
            this._sanitizedNames[i + 1] = sanitizeName("" + this._records[i].name + i);
        }
        for (var ebIndex = 0; ebIndex < _eventBindings.length; ++ebIndex) {
            var eb = _eventBindings[ebIndex];
            var names = [_CONTEXT_ACCESSOR];
            for (var i = 0, iLen = eb.records.length; i < iLen; ++i) {
                names.push(sanitizeName("" + eb.records[i].name + i + "_" + ebIndex));
            }
            this._sanitizedEventNames.set(eb, names);
        }
    }
    /** @internal */
    CodegenNameUtil.prototype._addFieldPrefix = function (name) { return "" + _FIELD_PREFIX + name; };
    CodegenNameUtil.prototype.getDispatcherName = function () { return this._addFieldPrefix(_DISPATCHER_ACCESSOR); };
    CodegenNameUtil.prototype.getPipesAccessorName = function () { return this._addFieldPrefix(_PIPES_ACCESSOR); };
    CodegenNameUtil.prototype.getProtosName = function () { return this._addFieldPrefix(_PROTOS_ACCESSOR); };
    CodegenNameUtil.prototype.getDirectivesAccessorName = function () { return this._addFieldPrefix(_DIRECTIVES_ACCESSOR); };
    CodegenNameUtil.prototype.getLocalsAccessorName = function () { return this._addFieldPrefix(_LOCALS_ACCESSOR); };
    CodegenNameUtil.prototype.getAlreadyCheckedName = function () { return this._addFieldPrefix(_ALREADY_CHECKED_ACCESSOR); };
    CodegenNameUtil.prototype.getModeName = function () { return this._addFieldPrefix(_MODE_ACCESSOR); };
    CodegenNameUtil.prototype.getPropertyBindingIndex = function () { return this._addFieldPrefix(_PROP_BINDING_INDEX); };
    CodegenNameUtil.prototype.getLocalName = function (idx) { return "l_" + this._sanitizedNames[idx]; };
    CodegenNameUtil.prototype.getEventLocalName = function (eb, idx) {
        return "l_" + this._sanitizedEventNames.get(eb)[idx];
    };
    CodegenNameUtil.prototype.getChangeName = function (idx) { return "c_" + this._sanitizedNames[idx]; };
    /**
     * Generate a statement initializing local variables used when detecting changes.
     */
    CodegenNameUtil.prototype.genInitLocals = function () {
        var declarations = [];
        var assignments = [];
        for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {
            if (i == exports.CONTEXT_INDEX) {
                declarations.push(this.getLocalName(i) + " = " + this.getFieldName(i));
            }
            else {
                var rec = this._records[i - 1];
                if (rec.argumentToPureFunction) {
                    var changeName = this.getChangeName(i);
                    declarations.push(this.getLocalName(i) + "," + changeName);
                    assignments.push(changeName);
                }
                else {
                    declarations.push("" + this.getLocalName(i));
                }
            }
        }
        var assignmentsCode = collection_1.ListWrapper.isEmpty(assignments) ? '' : assignments.join('=') + " = false;";
        return "var " + declarations.join(',') + ";" + assignmentsCode;
    };
    /**
     * Generate a statement initializing local variables for event handlers.
     */
    CodegenNameUtil.prototype.genInitEventLocals = function () {
        var _this = this;
        var res = [(this.getLocalName(exports.CONTEXT_INDEX) + " = " + this.getFieldName(exports.CONTEXT_INDEX))];
        this._sanitizedEventNames.forEach(function (names, eb) {
            for (var i = 0; i < names.length; ++i) {
                if (i !== exports.CONTEXT_INDEX) {
                    res.push("" + _this.getEventLocalName(eb, i));
                }
            }
        });
        return res.length > 1 ? "var " + res.join(',') + ";" : '';
    };
    CodegenNameUtil.prototype.getPreventDefaultAccesor = function () { return "preventDefault"; };
    CodegenNameUtil.prototype.getFieldCount = function () { return this._sanitizedNames.length; };
    CodegenNameUtil.prototype.getFieldName = function (idx) { return this._addFieldPrefix(this._sanitizedNames[idx]); };
    CodegenNameUtil.prototype.getAllFieldNames = function () {
        var fieldList = [];
        for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {
            if (k === 0 || this._records[k - 1].shouldBeChecked()) {
                fieldList.push(this.getFieldName(k));
            }
        }
        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
            var rec = this._records[i];
            if (rec.isPipeRecord()) {
                fieldList.push(this.getPipeName(rec.selfIndex));
            }
        }
        for (var j = 0, jLen = this._directiveRecords.length; j < jLen; ++j) {
            var dRec = this._directiveRecords[j];
            fieldList.push(this.getDirectiveName(dRec.directiveIndex));
            if (!dRec.isDefaultChangeDetection()) {
                fieldList.push(this.getDetectorName(dRec.directiveIndex));
            }
        }
        return fieldList;
    };
    /**
     * Generates statements which clear all fields so that the change detector is dehydrated.
     */
    CodegenNameUtil.prototype.genDehydrateFields = function () {
        var fields = this.getAllFieldNames();
        collection_1.ListWrapper.removeAt(fields, exports.CONTEXT_INDEX);
        if (collection_1.ListWrapper.isEmpty(fields))
            return '';
        // At least one assignment.
        fields.push(this._utilName + ".uninitialized;");
        return fields.join(' = ');
    };
    /**
     * Generates statements destroying all pipe variables.
     */
    CodegenNameUtil.prototype.genPipeOnDestroy = function () {
        var _this = this;
        return collection_1.ListWrapper.filter(this._records, function (r) { return r.isPipeRecord(); })
            .map(function (r) { return (_this._utilName + ".callPipeOnDestroy(" + _this.getPipeName(r.selfIndex) + ");"); })
            .join('\n');
    };
    CodegenNameUtil.prototype.getPipeName = function (idx) {
        return this._addFieldPrefix(this._sanitizedNames[idx] + "_pipe");
    };
    CodegenNameUtil.prototype.getDirectiveName = function (d) {
        return this._addFieldPrefix("directive_" + d.name);
    };
    CodegenNameUtil.prototype.getDetectorName = function (d) { return this._addFieldPrefix("detector_" + d.name); };
    return CodegenNameUtil;
})();
exports.CodegenNameUtil = CodegenNameUtil;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
(function (ChangeDetectionStrategy) {
    /**
     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckOnce"] = 0] = "CheckOnce";
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Checked"] = 1] = "Checked";
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckAlways"] = 2] = "CheckAlways";
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Detached"] = 3] = "Detached";
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 4] = "OnPush";
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 5] = "Default";
    /**
     * This is an experimental feature. Works only in Dart.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPushObserve"] = 6] = "OnPushObserve";
})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
exports.CHANGE_DECTION_STRATEGY_VALUES = [
    ChangeDetectionStrategy.CheckOnce,
    ChangeDetectionStrategy.Checked,
    ChangeDetectionStrategy.CheckAlways,
    ChangeDetectionStrategy.Detached,
    ChangeDetectionStrategy.OnPush,
    ChangeDetectionStrategy.Default,
    ChangeDetectionStrategy.OnPushObserve
];
function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return lang_1.isBlank(changeDetectionStrategy) ||
        changeDetectionStrategy === ChangeDetectionStrategy.Default;
}
exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_iterable_differ.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_2 = require('angular2/src/core/facade/lang');
var DefaultIterableDifferFactory = (function () {
    function DefaultIterableDifferFactory() {
    }
    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
    DefaultIterableDifferFactory.prototype.create = function (cdRef) { return new DefaultIterableDiffer(); };
    DefaultIterableDifferFactory = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DefaultIterableDifferFactory);
    return DefaultIterableDifferFactory;
})();
exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
var DefaultIterableDiffer = (function () {
    function DefaultIterableDiffer() {
        this._collection = null;
        this._length = null;
        // Keeps track of the used records at any point in time (during & across `_check()` calls)
        this._linkedRecords = null;
        // Keeps track of the removed records at any point in time during `_check()` calls.
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
        get: function () { return this._collection; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
        get: function () { return this._length; },
        enumerable: true,
        configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._itHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
        var record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.diff = function (collection) {
        if (lang_2.isBlank(collection))
            collection = [];
        if (!collection_1.isListLikeIterable(collection)) {
            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
        }
        if (this.check(collection)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultIterableDiffer.prototype.onDestroy = function () { };
    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
    DefaultIterableDiffer.prototype.check = function (collection) {
        var _this = this;
        this._reset();
        var record = this._itHead;
        var mayBeDirty = false;
        var index;
        var item;
        if (lang_2.isArray(collection)) {
            var list = collection;
            this._length = collection.length;
            for (index = 0; index < this._length; index++) {
                item = list[index];
                if (record === null || !lang_2.looseIdentical(record.item, item)) {
                    record = this._mismatch(record, item, index);
                    mayBeDirty = true;
                }
                else if (mayBeDirty) {
                    // TODO(misko): can we limit this to duplicates only?
                    record = this._verifyReinsertion(record, item, index);
                }
                record = record._next;
            }
        }
        else {
            index = 0;
            collection_1.iterateListLike(collection, function (item) {
                if (record === null || !lang_2.looseIdentical(record.item, item)) {
                    record = _this._mismatch(record, item, index);
                    mayBeDirty = true;
                }
                else if (mayBeDirty) {
                    // TODO(misko): can we limit this to duplicates only?
                    record = _this._verifyReinsertion(record, item, index);
                }
                record = record._next;
                index++;
            });
            this._length = index;
        }
        this._truncate(record);
        this._collection = collection;
        return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
        // CollectionChanges is considered dirty if it has any additions, moves or removals.
        get: function () {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reset the state of the change objects to show no changes. This means set previousKey to
     * currentKey, and clear all of the queues (additions, moves, removals).
     * Set the previousIndexes of moved and added items to their currentIndexes
     * Reset the list of additions, moves and removals
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            var nextRecord;
            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
            }
            this._additionsHead = this._additionsTail = null;
            for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
            }
            this._movesHead = this._movesTail = null;
            this._removalsHead = this._removalsTail = null;
        }
    };
    /**
     * This is the core function which handles differences between collections.
     *
     * - `record` is the record which we saw at this position last time. If null then it is a new
     *   item.
     * - `item` is the current item in the collection
     * - `index` is the position of the item in the collection
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._mismatch = function (record, item, index) {
        // The previous record after which we will append the current one.
        var previousRecord;
        if (record === null) {
            previousRecord = this._itTail;
        }
        else {
            previousRecord = record._prev;
            // Remove the record from the collection since we know it does not match the item.
            this._remove(record);
        }
        // Attempt to see if we have seen the item before.
        record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
        if (record !== null) {
            // We have seen this before, we need to move it forward in the collection.
            this._moveAfter(record, previousRecord, index);
        }
        else {
            // Never seen it, check evicted list.
            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
            if (record !== null) {
                // It is an item which we have evicted earlier: reinsert it back into the list.
                this._reinsertAfter(record, previousRecord, index);
            }
            else {
                // It is a new item: add it.
                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
            }
        }
        return record;
    };
    /**
     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
     *
     * Use case: `[a, a]` => `[b, a, a]`
     *
     * If we did not have this check then the insertion of `b` would:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) leave `a` at index `1` as is. <-- this is wrong!
     *   3) reinsert `a` at index 2. <-- this is wrong!
     *
     * The correct behavior is:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) reinsert `a` at index 1.
     *   3) move `a` at from `1` to `2`.
     *
     *
     * Double check that we have not evicted a duplicate item. We need to check if the item type may
     * have already been removed:
     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
     * at the end.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, index) {
        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
        if (reinsertRecord !== null) {
            record = this._reinsertAfter(reinsertRecord, record._prev, index);
        }
        else if (record.currentIndex != index) {
            record.currentIndex = index;
            this._addToMoves(record, index);
        }
        return record;
    };
    /**
     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
     *
     * - `record` The first excess {@link CollectionChangeRecord}.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._truncate = function (record) {
        // Anything after that needs to be removed;
        while (record !== null) {
            var nextRecord = record._next;
            this._addToRemovals(this._unlink(record));
            record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
            this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
            this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
            this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
            this._removalsTail._nextRemoved = null;
        }
    };
    /** @internal */
    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.remove(record);
        }
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
            // todo(vicb)
            // assert(this._additionsHead === null);
            this._additionsTail = this._additionsHead = record;
        }
        else {
            // todo(vicb)
            // assert(_additionsTail._nextAdded === null);
            // assert(record._nextAdded === null);
            this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
        // todo(vicb)
        // assert(record != prevRecord);
        // assert(record._next === null);
        // assert(record._prev === null);
        var next = prevRecord === null ? this._itHead : prevRecord._next;
        // todo(vicb)
        // assert(next != record);
        // assert(prevRecord != record);
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
            this._itTail = record;
        }
        else {
            next._prev = record;
        }
        if (prevRecord === null) {
            this._itHead = record;
        }
        else {
            prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
            this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._remove = function (record) {
        return this._addToRemovals(this._unlink(record));
    };
    /** @internal */
    DefaultIterableDiffer.prototype._unlink = function (record) {
        if (this._linkedRecords !== null) {
            this._linkedRecords.remove(record);
        }
        var prev = record._prev;
        var next = record._next;
        // todo(vicb)
        // assert((record._prev = null) === null);
        // assert((record._next = null) === null);
        if (prev === null) {
            this._itHead = next;
        }
        else {
            prev._next = next;
        }
        if (next === null) {
            this._itTail = prev;
        }
        else {
            next._prev = prev;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
        // todo(vicb)
        // assert(record._nextMoved === null);
        if (record.previousIndex === toIndex) {
            return record;
        }
        if (this._movesTail === null) {
            // todo(vicb)
            // assert(_movesHead === null);
            this._movesTail = this._movesHead = record;
        }
        else {
            // todo(vicb)
            // assert(_movesTail._nextMoved === null);
            this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
        if (this._unlinkedRecords === null) {
            this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
            // todo(vicb)
            // assert(_removalsHead === null);
            this._removalsTail = this._removalsHead = record;
            record._prevRemoved = null;
        }
        else {
            // todo(vicb)
            // assert(_removalsTail._nextRemoved === null);
            // assert(record._nextRemoved === null);
            record._prevRemoved = this._removalsTail;
            this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
    };
    DefaultIterableDiffer.prototype.toString = function () {
        var record;
        var list = [];
        for (record = this._itHead; record !== null; record = record._next) {
            list.push(record);
        }
        var previous = [];
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            previous.push(record);
        }
        var additions = [];
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            additions.push(record);
        }
        var moves = [];
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            moves.push(record);
        }
        var removals = [];
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            removals.push(record);
        }
        return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n";
    };
    return DefaultIterableDiffer;
})();
exports.DefaultIterableDiffer = DefaultIterableDiffer;
var CollectionChangeRecord = (function () {
    function CollectionChangeRecord(item) {
        this.item = item;
        this.currentIndex = null;
        this.previousIndex = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._prev = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._prevDup = null;
        /** @internal */
        this._nextDup = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextMoved = null;
    }
    CollectionChangeRecord.prototype.toString = function () {
        return this.previousIndex === this.currentIndex ?
            lang_2.stringify(this.item) :
            lang_2.stringify(this.item) + '[' + lang_2.stringify(this.previousIndex) + '->' +
                lang_2.stringify(this.currentIndex) + ']';
    };
    return CollectionChangeRecord;
})();
exports.CollectionChangeRecord = CollectionChangeRecord;
// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
var _DuplicateItemRecordList = (function () {
    function _DuplicateItemRecordList() {
        /** @internal */
        this._head = null;
        /** @internal */
        this._tail = null;
    }
    /**
     * Append the record to the list of duplicates.
     *
     * Note: by design all records in the list of duplicates hold the same value in record.item.
     */
    _DuplicateItemRecordList.prototype.add = function (record) {
        if (this._head === null) {
            this._head = this._tail = record;
            record._nextDup = null;
            record._prevDup = null;
        }
        else {
            // todo(vicb)
            // assert(record.item ==  _head.item ||
            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
            this._tail._nextDup = record;
            record._prevDup = this._tail;
            record._nextDup = null;
            this._tail = record;
        }
    };
    // Returns a CollectionChangeRecord having CollectionChangeRecord.item == item and
    // CollectionChangeRecord.currentIndex >= afterIndex
    _DuplicateItemRecordList.prototype.get = function (item, afterIndex) {
        var record;
        for (record = this._head; record !== null; record = record._nextDup) {
            if ((afterIndex === null || afterIndex < record.currentIndex) &&
                lang_2.looseIdentical(record.item, item)) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
     *
     * Returns whether the list of duplicates is empty.
     */
    _DuplicateItemRecordList.prototype.remove = function (record) {
        // todo(vicb)
        // assert(() {
        //  // verify that the record being removed is in the list.
        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
        //    if (identical(cursor, record)) return true;
        //  }
        //  return false;
        //});
        var prev = record._prevDup;
        var next = record._nextDup;
        if (prev === null) {
            this._head = next;
        }
        else {
            prev._nextDup = next;
        }
        if (next === null) {
            this._tail = prev;
        }
        else {
            next._prevDup = prev;
        }
        return this._head === null;
    };
    return _DuplicateItemRecordList;
})();
var _DuplicateMap = (function () {
    function _DuplicateMap() {
        this.map = new Map();
    }
    _DuplicateMap.prototype.put = function (record) {
        // todo(vicb) handle corner cases
        var key = lang_2.getMapKey(record.item);
        var duplicates = this.map.get(key);
        if (!lang_2.isPresent(duplicates)) {
            duplicates = new _DuplicateItemRecordList();
            this.map.set(key, duplicates);
        }
        duplicates.add(record);
    };
    /**
     * Retrieve the `value` using key. Because the CollectionChangeRecord value maybe one which we
     * have already iterated over, we use the afterIndex to pretend it is not there.
     *
     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
     * have any more `a`s needs to return the last `a` not the first or second.
     */
    _DuplicateMap.prototype.get = function (value, afterIndex) {
        if (afterIndex === void 0) { afterIndex = null; }
        var key = lang_2.getMapKey(value);
        var recordList = this.map.get(key);
        return lang_2.isBlank(recordList) ? null : recordList.get(value, afterIndex);
    };
    /**
     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
     *
     * The list of duplicates also is removed from the map if it gets empty.
     */
    _DuplicateMap.prototype.remove = function (record) {
        var key = lang_2.getMapKey(record.item);
        // todo(vicb)
        // assert(this.map.containsKey(key));
        var recordList = this.map.get(key);
        // Remove the list of duplicates when it gets empty
        if (recordList.remove(record)) {
            this.map.delete(key);
        }
        return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
        get: function () { return this.map.size === 0; },
        enumerable: true,
        configurable: true
    });
    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_2.stringify(this.map) + ')'; };
    return _DuplicateMap;
})();

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_keyvalue_differ.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var DefaultKeyValueDifferFactory = (function () {
    function DefaultKeyValueDifferFactory() {
    }
    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
    DefaultKeyValueDifferFactory = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DefaultKeyValueDifferFactory);
    return DefaultKeyValueDifferFactory;
})();
exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
var DefaultKeyValueDiffer = (function () {
    function DefaultKeyValueDiffer() {
        this._records = new Map();
        this._mapHead = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
        get: function () {
            return this._additionsHead !== null || this._changesHead !== null ||
                this._removalsHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
        var record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.diff = function (map) {
        if (lang_1.isBlank(map))
            map = collection_1.MapWrapper.createFromPairs([]);
        if (!(map instanceof Map || lang_1.isJsObject(map))) {
            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
        }
        if (this.check(map)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
    DefaultKeyValueDiffer.prototype.check = function (map) {
        var _this = this;
        this._reset();
        var records = this._records;
        var oldSeqRecord = this._mapHead;
        var lastOldSeqRecord = null;
        var lastNewSeqRecord = null;
        var seqChanged = false;
        this._forEach(map, function (value, key) {
            var newSeqRecord;
            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {
                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                    oldSeqRecord.currentValue = value;
                    _this._addToChanges(oldSeqRecord);
                }
            }
            else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                    oldSeqRecord._next = null;
                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                    _this._addToRemovals(oldSeqRecord);
                }
                if (records.has(key)) {
                    newSeqRecord = records.get(key);
                }
                else {
                    newSeqRecord = new KVChangeRecord(key);
                    records.set(key, newSeqRecord);
                    newSeqRecord.currentValue = value;
                    _this._addToAdditions(newSeqRecord);
                }
            }
            if (seqChanged) {
                if (_this._isInRemovals(newSeqRecord)) {
                    _this._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                    _this._mapHead = newSeqRecord;
                }
                else {
                    lastNewSeqRecord._next = newSeqRecord;
                }
            }
            lastOldSeqRecord = oldSeqRecord;
            lastNewSeqRecord = newSeqRecord;
            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
        });
        this._truncate(lastOldSeqRecord, oldSeqRecord);
        return this.isDirty;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            // Record the state of the mapping
            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
            }
            for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
            }
            // todo(vicb) once assert is supported
            // assert(() {
            //  var r = _changesHead;
            //  while (r != null) {
            //    var nextRecord = r._nextChanged;
            //    r._nextChanged = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _additionsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextAdded;
            //    r._nextAdded = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _removalsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextRemoved;
            //    r._nextRemoved = null;
            //    r = nextRecord;
            //  }
            //
            //  return true;
            //});
            this._changesHead = this._changesTail = null;
            this._additionsHead = this._additionsTail = null;
            this._removalsHead = this._removalsTail = null;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
        while (record !== null) {
            if (lastRecord === null) {
                this._mapHead = null;
            }
            else {
                lastRecord._next = null;
            }
            var nextRecord = record._next;
            // todo(vicb) assert
            // assert((() {
            //  record._next = null;
            //  return true;
            //}));
            this._addToRemovals(record);
            lastRecord = record;
            record = nextRecord;
        }
        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
            rec.previousValue = rec.currentValue;
            rec.currentValue = null;
            this._records.delete(rec.key);
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
        return record === this._removalsHead || record._nextRemoved !== null ||
            record._prevRemoved !== null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._removalsHead === null) {
            this._removalsHead = this._removalsTail = record;
        }
        else {
            this._removalsTail._nextRemoved = record;
            record._prevRemoved = this._removalsTail;
            this._removalsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
        var next = record._next;
        if (prev === null) {
            this._mapHead = next;
        }
        else {
            prev._next = next;
        }
        // todo(vicb) assert
        // assert((() {
        //  record._next = null;
        //  return true;
        //})());
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        record._prevRemoved = record._nextRemoved = null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
        // todo(vicb): assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._additionsHead === null) {
            this._additionsHead = this._additionsTail = record;
        }
        else {
            this._additionsTail._nextAdded = record;
            this._additionsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
        // todo(vicb) assert
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._changesHead === null) {
            this._changesHead = this._changesTail = record;
        }
        else {
            this._changesTail._nextChanged = record;
            this._changesTail = record;
        }
    };
    DefaultKeyValueDiffer.prototype.toString = function () {
        var items = [];
        var previous = [];
        var changes = [];
        var additions = [];
        var removals = [];
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            items.push(lang_1.stringify(record));
        }
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            previous.push(lang_1.stringify(record));
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            changes.push(lang_1.stringify(record));
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            additions.push(lang_1.stringify(record));
        }
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            removals.push(lang_1.stringify(record));
        }
        return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n";
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
        if (obj instanceof Map) {
            obj.forEach(fn);
        }
        else {
            collection_1.StringMapWrapper.forEach(obj, fn);
        }
    };
    return DefaultKeyValueDiffer;
})();
exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
var KVChangeRecord = (function () {
    function KVChangeRecord(key) {
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextChanged = null;
    }
    KVChangeRecord.prototype.toString = function () {
        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
            lang_1.stringify(this.key) :
            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
                lang_1.stringify(this.currentValue) + ']');
    };
    return KVChangeRecord;
})();
exports.KVChangeRecord = KVChangeRecord;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/iterable_differs.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
/**
 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
 */
var IterableDiffers = (function () {
    function IterableDiffers(factories) {
        this.factories = factories;
    }
    IterableDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new IterableDiffers(factories);
        }
        else {
            return new IterableDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
     * inherited {@link IterableDiffers} instance with the provided factories and return a new
     * {@link IterableDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link IterableDiffer} available.
     *
     * # Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     IterableDiffers.extend([new ImmutableListDiffer()])
     *   ]
     * })
     * ```
     */
    IterableDiffers.extend = function (factories) {
        return new di_1.Provider(IterableDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
                }
                return IterableDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    IterableDiffers.prototype.find = function (iterable) {
        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(iterable); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "'");
        }
    };
    IterableDiffers = __decorate([
        di_1.Injectable(),
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], IterableDiffers);
    return IterableDiffers;
})();
exports.IterableDiffers = IterableDiffers;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/keyvalue_differs.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
/**
 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
 */
var KeyValueDiffers = (function () {
    function KeyValueDiffers(factories) {
        this.factories = factories;
    }
    KeyValueDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new KeyValueDiffers(factories);
        }
        else {
            return new KeyValueDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
     * {@link KeyValueDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link KeyValueDiffer} available.
     *
     * # Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
     *   ]
     * })
     * ```
     */
    KeyValueDiffers.extend = function (factories) {
        return new di_1.Provider(KeyValueDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
                }
                return KeyValueDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    KeyValueDiffers.prototype.find = function (kv) {
        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(kv); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
        }
    };
    KeyValueDiffers = __decorate([
        di_1.Injectable(),
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], KeyValueDiffers);
    return KeyValueDiffers;
})();
exports.KeyValueDiffers = KeyValueDiffers;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var constants_1 = require('./constants');
var DirectiveIndex = (function () {
    function DirectiveIndex(elementIndex, directiveIndex) {
        this.elementIndex = elementIndex;
        this.directiveIndex = directiveIndex;
    }
    Object.defineProperty(DirectiveIndex.prototype, "name", {
        get: function () { return this.elementIndex + "_" + this.directiveIndex; },
        enumerable: true,
        configurable: true
    });
    return DirectiveIndex;
})();
exports.DirectiveIndex = DirectiveIndex;
var DirectiveRecord = (function () {
    function DirectiveRecord(_a) {
        var _b = _a === void 0 ? {} : _a, directiveIndex = _b.directiveIndex, callAfterContentInit = _b.callAfterContentInit, callAfterContentChecked = _b.callAfterContentChecked, callAfterViewInit = _b.callAfterViewInit, callAfterViewChecked = _b.callAfterViewChecked, callOnChanges = _b.callOnChanges, callDoCheck = _b.callDoCheck, callOnInit = _b.callOnInit, changeDetection = _b.changeDetection;
        this.directiveIndex = directiveIndex;
        this.callAfterContentInit = lang_1.normalizeBool(callAfterContentInit);
        this.callAfterContentChecked = lang_1.normalizeBool(callAfterContentChecked);
        this.callOnChanges = lang_1.normalizeBool(callOnChanges);
        this.callAfterViewInit = lang_1.normalizeBool(callAfterViewInit);
        this.callAfterViewChecked = lang_1.normalizeBool(callAfterViewChecked);
        this.callDoCheck = lang_1.normalizeBool(callDoCheck);
        this.callOnInit = lang_1.normalizeBool(callOnInit);
        this.changeDetection = changeDetection;
    }
    DirectiveRecord.prototype.isDefaultChangeDetection = function () {
        return constants_1.isDefaultChangeDetectionStrategy(this.changeDetection);
    };
    return DirectiveRecord;
})();
exports.DirectiveRecord = DirectiveRecord;

},{"./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var abstract_change_detector_1 = require('./abstract_change_detector');
var change_detection_util_1 = require('./change_detection_util');
var constants_1 = require('./constants');
var proto_record_1 = require('./proto_record');
var DynamicChangeDetector = (function (_super) {
    __extends(DynamicChangeDetector, _super);
    function DynamicChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy, _records, _eventBindings, _directiveRecords, _genConfig) {
        _super.call(this, id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);
        this._records = _records;
        this._eventBindings = _eventBindings;
        this._directiveRecords = _directiveRecords;
        this._genConfig = _genConfig;
        this.directives = null;
        var len = _records.length + 1;
        this.values = collection_1.ListWrapper.createFixedSize(len);
        this.localPipes = collection_1.ListWrapper.createFixedSize(len);
        this.prevContexts = collection_1.ListWrapper.createFixedSize(len);
        this.changes = collection_1.ListWrapper.createFixedSize(len);
        this.dehydrateDirectives(false);
    }
    DynamicChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) {
        var _this = this;
        var preventDefault = false;
        this._matchingEventBindings(eventName, elIndex)
            .forEach(function (rec) {
            var res = _this._processEventBinding(rec, locals);
            if (res === false) {
                preventDefault = true;
            }
        });
        return preventDefault;
    };
    /** @internal */
    DynamicChangeDetector.prototype._processEventBinding = function (eb, locals) {
        var values = collection_1.ListWrapper.createFixedSize(eb.records.length);
        values[0] = this.values[0];
        for (var i = 0; i < eb.records.length; ++i) {
            var proto = eb.records[i];
            var res = this._calculateCurrValue(proto, values, locals);
            if (proto.lastInBinding) {
                this._markPathAsCheckOnce(proto);
                return res;
            }
            else {
                this._writeSelf(proto, res, values);
            }
        }
        throw new exceptions_1.BaseException("Cannot be reached");
    };
    /** @internal */
    DynamicChangeDetector.prototype._markPathAsCheckOnce = function (proto) {
        if (!proto.bindingRecord.isDefaultChangeDetection()) {
            var dir = proto.bindingRecord.directiveRecord;
            this._getDetectorFor(dir.directiveIndex).markPathToRootAsCheckOnce();
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._matchingEventBindings = function (eventName, elIndex) {
        return collection_1.ListWrapper.filter(this._eventBindings, function (eb) { return eb.eventName == eventName && eb.elIndex === elIndex; });
    };
    DynamicChangeDetector.prototype.hydrateDirectives = function (directives) {
        this.values[0] = this.context;
        this.directives = directives;
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            for (var i = 0; i < this.directiveIndices.length; ++i) {
                var index = this.directiveIndices[i];
                _super.prototype.observeDirective.call(this, directives.getDirectiveFor(index), i);
            }
        }
    };
    DynamicChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) {
        if (destroyPipes) {
            this._destroyPipes();
        }
        this.values[0] = null;
        this.directives = null;
        collection_1.ListWrapper.fill(this.values, change_detection_util_1.ChangeDetectionUtil.uninitialized, 1);
        collection_1.ListWrapper.fill(this.changes, false);
        collection_1.ListWrapper.fill(this.localPipes, null);
        collection_1.ListWrapper.fill(this.prevContexts, change_detection_util_1.ChangeDetectionUtil.uninitialized);
    };
    /** @internal */
    DynamicChangeDetector.prototype._destroyPipes = function () {
        for (var i = 0; i < this.localPipes.length; ++i) {
            if (lang_1.isPresent(this.localPipes[i])) {
                change_detection_util_1.ChangeDetectionUtil.callPipeOnDestroy(this.localPipes[i]);
            }
        }
    };
    DynamicChangeDetector.prototype.checkNoChanges = function () { this.runDetectChanges(true); };
    DynamicChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) {
        var protos = this._records;
        var changes = null;
        var isChanged = false;
        for (var i = 0; i < protos.length; ++i) {
            var proto = protos[i];
            var bindingRecord = proto.bindingRecord;
            var directiveRecord = bindingRecord.directiveRecord;
            if (this._firstInBinding(proto)) {
                this.propertyBindingIndex = proto.propertyBindingIndex;
            }
            if (proto.isLifeCycleRecord()) {
                if (proto.name === "DoCheck" && !throwOnChange) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).doCheck();
                }
                else if (proto.name === "OnInit" && !throwOnChange && !this.alreadyChecked) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
                }
                else if (proto.name === "OnChanges" && lang_1.isPresent(changes) && !throwOnChange) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).onChanges(changes);
                }
            }
            else {
                var change = this._check(proto, throwOnChange, this.values, this.locals);
                if (lang_1.isPresent(change)) {
                    this._updateDirectiveOrElement(change, bindingRecord);
                    isChanged = true;
                    changes = this._addChange(bindingRecord, change, changes);
                }
            }
            if (proto.lastInDirective) {
                changes = null;
                if (isChanged && !bindingRecord.isDefaultChangeDetection()) {
                    this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                }
                isChanged = false;
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._firstInBinding = function (r) {
        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this._records, r.selfIndex - 1);
        return lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
    };
    DynamicChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () {
        var dirs = this._directiveRecords;
        for (var i = dirs.length - 1; i >= 0; --i) {
            var dir = dirs[i];
            if (dir.callAfterContentInit && !this.alreadyChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterContentInit();
            }
            if (dir.callAfterContentChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterContentChecked();
            }
        }
    };
    DynamicChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () {
        var dirs = this._directiveRecords;
        for (var i = dirs.length - 1; i >= 0; --i) {
            var dir = dirs[i];
            if (dir.callAfterViewInit && !this.alreadyChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterViewInit();
            }
            if (dir.callAfterViewChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterViewChecked();
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._updateDirectiveOrElement = function (change, bindingRecord) {
        if (lang_1.isBlank(bindingRecord.directiveRecord)) {
            _super.prototype.notifyDispatcher.call(this, change.currentValue);
        }
        else {
            var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
            bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
        }
        if (this._genConfig.logBindingUpdate) {
            _super.prototype.logBindingUpdate.call(this, change.currentValue);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._addChange = function (bindingRecord, change, changes) {
        if (bindingRecord.callOnChanges()) {
            return _super.prototype.addChange.call(this, changes, change.previousValue, change.currentValue);
        }
        else {
            return changes;
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._getDirectiveFor = function (directiveIndex) { return this.directives.getDirectiveFor(directiveIndex); };
    /** @internal */
    DynamicChangeDetector.prototype._getDetectorFor = function (directiveIndex) { return this.directives.getDetectorFor(directiveIndex); };
    /** @internal */
    DynamicChangeDetector.prototype._check = function (proto, throwOnChange, values, locals) {
        if (proto.isPipeRecord()) {
            return this._pipeCheck(proto, throwOnChange, values);
        }
        else {
            return this._referenceCheck(proto, throwOnChange, values, locals);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._referenceCheck = function (proto, throwOnChange, values, locals) {
        if (this._pureFuncAndArgsDidNotChange(proto)) {
            this._setChanged(proto, false);
            return null;
        }
        var currValue = this._calculateCurrValue(proto, values, locals);
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            _super.prototype.observeValue.call(this, currValue, proto.selfIndex);
        }
        if (proto.shouldBeChecked()) {
            var prevValue = this._readSelf(proto, values);
            if (!isSame(prevValue, currValue)) {
                if (proto.lastInBinding) {
                    var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
                    if (throwOnChange)
                        this.throwOnChangeError(prevValue, currValue);
                    this._writeSelf(proto, currValue, values);
                    this._setChanged(proto, true);
                    return change;
                }
                else {
                    this._writeSelf(proto, currValue, values);
                    this._setChanged(proto, true);
                    return null;
                }
            }
            else {
                this._setChanged(proto, false);
                return null;
            }
        }
        else {
            this._writeSelf(proto, currValue, values);
            this._setChanged(proto, true);
            return null;
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._calculateCurrValue = function (proto, values, locals) {
        switch (proto.mode) {
            case proto_record_1.RecordType.Self:
                return this._readContext(proto, values);
            case proto_record_1.RecordType.Const:
                return proto.funcOrValue;
            case proto_record_1.RecordType.PropertyRead:
                var context = this._readContext(proto, values);
                return proto.funcOrValue(context);
            case proto_record_1.RecordType.SafeProperty:
                var context = this._readContext(proto, values);
                return lang_1.isBlank(context) ? null : proto.funcOrValue(context);
            case proto_record_1.RecordType.PropertyWrite:
                var context = this._readContext(proto, values);
                var value = this._readArgs(proto, values)[0];
                proto.funcOrValue(context, value);
                return value;
            case proto_record_1.RecordType.KeyedWrite:
                var context = this._readContext(proto, values);
                var key = this._readArgs(proto, values)[0];
                var value = this._readArgs(proto, values)[1];
                context[key] = value;
                return value;
            case proto_record_1.RecordType.Local:
                return locals.get(proto.name);
            case proto_record_1.RecordType.InvokeMethod:
                var context = this._readContext(proto, values);
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
            case proto_record_1.RecordType.SafeMethodInvoke:
                var context = this._readContext(proto, values);
                if (lang_1.isBlank(context)) {
                    return null;
                }
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
            case proto_record_1.RecordType.KeyedRead:
                var arg = this._readArgs(proto, values)[0];
                return this._readContext(proto, values)[arg];
            case proto_record_1.RecordType.Chain:
                var args = this._readArgs(proto, values);
                return args[args.length - 1];
            case proto_record_1.RecordType.InvokeClosure:
                return lang_1.FunctionWrapper.apply(this._readContext(proto, values), this._readArgs(proto, values));
            case proto_record_1.RecordType.Interpolate:
            case proto_record_1.RecordType.PrimitiveOp:
            case proto_record_1.RecordType.CollectionLiteral:
                return lang_1.FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto, values));
            default:
                throw new exceptions_1.BaseException("Unknown operation " + proto.mode);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._pipeCheck = function (proto, throwOnChange, values) {
        var context = this._readContext(proto, values);
        var selectedPipe = this._pipeFor(proto, context);
        if (!selectedPipe.pure || this._argsOrContextChanged(proto)) {
            var args = this._readArgs(proto, values);
            var currValue = selectedPipe.pipe.transform(context, args);
            if (proto.shouldBeChecked()) {
                var prevValue = this._readSelf(proto, values);
                if (!isSame(prevValue, currValue)) {
                    currValue = change_detection_util_1.ChangeDetectionUtil.unwrapValue(currValue);
                    if (proto.lastInBinding) {
                        var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
                        if (throwOnChange)
                            this.throwOnChangeError(prevValue, currValue);
                        this._writeSelf(proto, currValue, values);
                        this._setChanged(proto, true);
                        return change;
                    }
                    else {
                        this._writeSelf(proto, currValue, values);
                        this._setChanged(proto, true);
                        return null;
                    }
                }
                else {
                    this._setChanged(proto, false);
                    return null;
                }
            }
            else {
                this._writeSelf(proto, currValue, values);
                this._setChanged(proto, true);
                return null;
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._pipeFor = function (proto, context) {
        var storedPipe = this._readPipe(proto);
        if (lang_1.isPresent(storedPipe))
            return storedPipe;
        var pipe = this.pipes.get(proto.name);
        this._writePipe(proto, pipe);
        return pipe;
    };
    /** @internal */
    DynamicChangeDetector.prototype._readContext = function (proto, values) {
        if (proto.contextIndex == -1) {
            return this._getDirectiveFor(proto.directiveIndex);
        }
        else {
            return values[proto.contextIndex];
        }
        return values[proto.contextIndex];
    };
    /** @internal */
    DynamicChangeDetector.prototype._readSelf = function (proto, values) { return values[proto.selfIndex]; };
    /** @internal */
    DynamicChangeDetector.prototype._writeSelf = function (proto, value, values) { values[proto.selfIndex] = value; };
    /** @internal */
    DynamicChangeDetector.prototype._readPipe = function (proto) { return this.localPipes[proto.selfIndex]; };
    /** @internal */
    DynamicChangeDetector.prototype._writePipe = function (proto, value) { this.localPipes[proto.selfIndex] = value; };
    /** @internal */
    DynamicChangeDetector.prototype._setChanged = function (proto, value) {
        if (proto.argumentToPureFunction)
            this.changes[proto.selfIndex] = value;
    };
    /** @internal */
    DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange = function (proto) {
        return proto.isPureFunction() && !this._argsChanged(proto);
    };
    /** @internal */
    DynamicChangeDetector.prototype._argsChanged = function (proto) {
        var args = proto.args;
        for (var i = 0; i < args.length; ++i) {
            if (this.changes[args[i]]) {
                return true;
            }
        }
        return false;
    };
    /** @internal */
    DynamicChangeDetector.prototype._argsOrContextChanged = function (proto) {
        return this._argsChanged(proto) || this.changes[proto.contextIndex];
    };
    /** @internal */
    DynamicChangeDetector.prototype._readArgs = function (proto, values) {
        var res = collection_1.ListWrapper.createFixedSize(proto.args.length);
        var args = proto.args;
        for (var i = 0; i < args.length; ++i) {
            res[i] = values[args[i]];
        }
        return res;
    };
    return DynamicChangeDetector;
})(abstract_change_detector_1.AbstractChangeDetector);
exports.DynamicChangeDetector = DynamicChangeDetector;
function isSame(a, b) {
    if (a === b)
        return true;
    if (a instanceof String && b instanceof String && a == b)
        return true;
    if ((a !== a) && (b !== b))
        return true;
    return false;
}

},{"./abstract_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/event_binding.js":[function(require,module,exports){
'use strict';var EventBinding = (function () {
    function EventBinding(eventName, elIndex, dirIndex, records) {
        this.eventName = eventName;
        this.elIndex = elIndex;
        this.dirIndex = dirIndex;
        this.records = records;
    }
    return EventBinding;
})();
exports.EventBinding = EventBinding;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require("angular2/src/core/facade/exceptions");
/**
 * An error thrown if application changes model breaking the top-down data flow.
 *
 * This exception is only thrown in dev mode.
 *
 * <!-- TODO: Add a link once the dev mode option is configurable -->
 *
 * ### Example
 *
 * ```typescript
 * @Component({
 *   selector: 'parent',
 *   template: `
 *     <child [prop]="parentProp"></child>
 *   `,
 *   directives: [forwardRef(() => Child)]
 * })
 * class Parent {
 *   parentProp = "init";
 * }
 *
 * @Directive({selector: 'child', inputs: ['prop']})
 * class Child {
 *   constructor(public parent: Parent) {}
 *
 *   set prop(v) {
 *     // this updates the parent property, which is disallowed during change detection
 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
 *     this.parent.parentProp = "updated";
 *   }
 * }
 * ```
 */
var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
    function ExpressionChangedAfterItHasBeenCheckedException(exp, oldValue, currValue, context) {
        _super.call(this, ("Expression '" + exp + "' has changed after it was checked. ") +
            ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
    }
    return ExpressionChangedAfterItHasBeenCheckedException;
})(exceptions_1.BaseException);
exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
/**
 * Thrown when an expression evaluation raises an exception.
 *
 * This error wraps the original exception to attach additional contextual information that can
 * be useful for debugging.
 *
 * ### Example ([live demo](http://plnkr.co/edit/2Kywoz?p=preview))
 *
 * ```typescript
 * @Directive({selector: 'child', inputs: ['prop']})
 * class Child {
 *   prop;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <child [prop]="field.first"></child>
 *   `,
 *   directives: [Child]
 * })
 * class App {
 *   field = null;
 * }
 *
 * bootstrap(App);
 * ```
 *
 * You can access the original exception and stack through the `originalException` and
 * `originalStack` properties.
 */
var ChangeDetectionError = (function (_super) {
    __extends(ChangeDetectionError, _super);
    function ChangeDetectionError(exp, originalException, originalStack, context) {
        _super.call(this, originalException + " in [" + exp + "]", originalException, originalStack, context);
        this.location = exp;
    }
    return ChangeDetectionError;
})(exceptions_1.WrappedException);
exports.ChangeDetectionError = ChangeDetectionError;
/**
 * Thrown when change detector executes on dehydrated view.
 *
 * This error indicates a bug in the framework.
 *
 * This is an internal Angular error.
 */
var DehydratedException = (function (_super) {
    __extends(DehydratedException, _super);
    function DehydratedException() {
        _super.call(this, 'Attempt to detect changes on a dehydrated detector.');
    }
    return DehydratedException;
})(exceptions_1.BaseException);
exports.DehydratedException = DehydratedException;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js":[function(require,module,exports){
'use strict';var DebugContext = (function () {
    function DebugContext(element, componentElement, directive, context, locals, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.directive = directive;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
    }
    return DebugContext;
})();
exports.DebugContext = DebugContext;
var ChangeDetectorGenConfig = (function () {
    function ChangeDetectorGenConfig(genCheckNoChanges, genDebugInfo, logBindingUpdate, useJit) {
        this.genCheckNoChanges = genCheckNoChanges;
        this.genDebugInfo = genDebugInfo;
        this.logBindingUpdate = logBindingUpdate;
        this.useJit = useJit;
    }
    return ChangeDetectorGenConfig;
})();
exports.ChangeDetectorGenConfig = ChangeDetectorGenConfig;
var ChangeDetectorDefinition = (function () {
    function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, eventRecords, directiveRecords, genConfig) {
        this.id = id;
        this.strategy = strategy;
        this.variableNames = variableNames;
        this.bindingRecords = bindingRecords;
        this.eventRecords = eventRecords;
        this.directiveRecords = directiveRecords;
        this.genConfig = genConfig;
    }
    return ChangeDetectorDefinition;
})();
exports.ChangeDetectorDefinition = ChangeDetectorDefinition;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/jit_proto_change_detector.js":[function(require,module,exports){
'use strict';var change_detection_jit_generator_1 = require('./change_detection_jit_generator');
var JitProtoChangeDetector = (function () {
    function JitProtoChangeDetector(definition) {
        this.definition = definition;
        this._factory = this._createFactory(definition);
    }
    JitProtoChangeDetector.isSupported = function () { return true; };
    JitProtoChangeDetector.prototype.instantiate = function (dispatcher) { return this._factory(dispatcher); };
    /** @internal */
    JitProtoChangeDetector.prototype._createFactory = function (definition) {
        return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, 'util', 'AbstractChangeDetector').generate();
    };
    return JitProtoChangeDetector;
})();
exports.JitProtoChangeDetector = JitProtoChangeDetector;

},{"./change_detection_jit_generator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/observable_facade.js":[function(require,module,exports){
'use strict';function isObservable(value) {
    return false;
}
exports.isObservable = isObservable;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require("angular2/src/core/facade/lang");
var collection_1 = require("angular2/src/core/facade/collection");
var AST = (function () {
    function AST() {
    }
    AST.prototype.visit = function (visitor) { return null; };
    AST.prototype.toString = function () { return "AST"; };
    return AST;
})();
exports.AST = AST;
var EmptyExpr = (function (_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
        _super.apply(this, arguments);
    }
    EmptyExpr.prototype.visit = function (visitor) {
        // do nothing
    };
    return EmptyExpr;
})(AST);
exports.EmptyExpr = EmptyExpr;
var ImplicitReceiver = (function (_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
        _super.apply(this, arguments);
    }
    ImplicitReceiver.prototype.visit = function (visitor) { return visitor.visitImplicitReceiver(this); };
    return ImplicitReceiver;
})(AST);
exports.ImplicitReceiver = ImplicitReceiver;
/**
 * Multiple expressions separated by a semicolon.
 */
var Chain = (function (_super) {
    __extends(Chain, _super);
    function Chain(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    Chain.prototype.visit = function (visitor) { return visitor.visitChain(this); };
    return Chain;
})(AST);
exports.Chain = Chain;
var Conditional = (function (_super) {
    __extends(Conditional, _super);
    function Conditional(condition, trueExp, falseExp) {
        _super.call(this);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
    }
    Conditional.prototype.visit = function (visitor) { return visitor.visitConditional(this); };
    return Conditional;
})(AST);
exports.Conditional = Conditional;
var If = (function (_super) {
    __extends(If, _super);
    function If(condition, trueExp, falseExp) {
        _super.call(this);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
    }
    If.prototype.visit = function (visitor) { return visitor.visitIf(this); };
    return If;
})(AST);
exports.If = If;
var PropertyRead = (function (_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(receiver, name, getter) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.getter = getter;
    }
    PropertyRead.prototype.visit = function (visitor) { return visitor.visitPropertyRead(this); };
    return PropertyRead;
})(AST);
exports.PropertyRead = PropertyRead;
var PropertyWrite = (function (_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(receiver, name, setter, value) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.setter = setter;
        this.value = value;
    }
    PropertyWrite.prototype.visit = function (visitor) { return visitor.visitPropertyWrite(this); };
    return PropertyWrite;
})(AST);
exports.PropertyWrite = PropertyWrite;
var SafePropertyRead = (function (_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(receiver, name, getter) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.getter = getter;
    }
    SafePropertyRead.prototype.visit = function (visitor) { return visitor.visitSafePropertyRead(this); };
    return SafePropertyRead;
})(AST);
exports.SafePropertyRead = SafePropertyRead;
var KeyedRead = (function (_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(obj, key) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
    }
    KeyedRead.prototype.visit = function (visitor) { return visitor.visitKeyedRead(this); };
    return KeyedRead;
})(AST);
exports.KeyedRead = KeyedRead;
var KeyedWrite = (function (_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(obj, key, value) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
        this.value = value;
    }
    KeyedWrite.prototype.visit = function (visitor) { return visitor.visitKeyedWrite(this); };
    return KeyedWrite;
})(AST);
exports.KeyedWrite = KeyedWrite;
var BindingPipe = (function (_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(exp, name, args) {
        _super.call(this);
        this.exp = exp;
        this.name = name;
        this.args = args;
    }
    BindingPipe.prototype.visit = function (visitor) { return visitor.visitPipe(this); };
    return BindingPipe;
})(AST);
exports.BindingPipe = BindingPipe;
var LiteralPrimitive = (function (_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(value) {
        _super.call(this);
        this.value = value;
    }
    LiteralPrimitive.prototype.visit = function (visitor) { return visitor.visitLiteralPrimitive(this); };
    return LiteralPrimitive;
})(AST);
exports.LiteralPrimitive = LiteralPrimitive;
var LiteralArray = (function (_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    LiteralArray.prototype.visit = function (visitor) { return visitor.visitLiteralArray(this); };
    return LiteralArray;
})(AST);
exports.LiteralArray = LiteralArray;
var LiteralMap = (function (_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(keys, values) {
        _super.call(this);
        this.keys = keys;
        this.values = values;
    }
    LiteralMap.prototype.visit = function (visitor) { return visitor.visitLiteralMap(this); };
    return LiteralMap;
})(AST);
exports.LiteralMap = LiteralMap;
var Interpolation = (function (_super) {
    __extends(Interpolation, _super);
    function Interpolation(strings, expressions) {
        _super.call(this);
        this.strings = strings;
        this.expressions = expressions;
    }
    Interpolation.prototype.visit = function (visitor) { visitor.visitInterpolation(this); };
    return Interpolation;
})(AST);
exports.Interpolation = Interpolation;
var Binary = (function (_super) {
    __extends(Binary, _super);
    function Binary(operation, left, right) {
        _super.call(this);
        this.operation = operation;
        this.left = left;
        this.right = right;
    }
    Binary.prototype.visit = function (visitor) { return visitor.visitBinary(this); };
    return Binary;
})(AST);
exports.Binary = Binary;
var PrefixNot = (function (_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(expression) {
        _super.call(this);
        this.expression = expression;
    }
    PrefixNot.prototype.visit = function (visitor) { return visitor.visitPrefixNot(this); };
    return PrefixNot;
})(AST);
exports.PrefixNot = PrefixNot;
var MethodCall = (function (_super) {
    __extends(MethodCall, _super);
    function MethodCall(receiver, name, fn, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.fn = fn;
        this.args = args;
    }
    MethodCall.prototype.visit = function (visitor) { return visitor.visitMethodCall(this); };
    return MethodCall;
})(AST);
exports.MethodCall = MethodCall;
var SafeMethodCall = (function (_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(receiver, name, fn, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.fn = fn;
        this.args = args;
    }
    SafeMethodCall.prototype.visit = function (visitor) { return visitor.visitSafeMethodCall(this); };
    return SafeMethodCall;
})(AST);
exports.SafeMethodCall = SafeMethodCall;
var FunctionCall = (function (_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(target, args) {
        _super.call(this);
        this.target = target;
        this.args = args;
    }
    FunctionCall.prototype.visit = function (visitor) { return visitor.visitFunctionCall(this); };
    return FunctionCall;
})(AST);
exports.FunctionCall = FunctionCall;
var ASTWithSource = (function (_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location) {
        _super.call(this);
        this.ast = ast;
        this.source = source;
        this.location = location;
    }
    ASTWithSource.prototype.visit = function (visitor) { return this.ast.visit(visitor); };
    ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
    return ASTWithSource;
})(AST);
exports.ASTWithSource = ASTWithSource;
var TemplateBinding = (function () {
    function TemplateBinding(key, keyIsVar, name, expression) {
        this.key = key;
        this.keyIsVar = keyIsVar;
        this.name = name;
        this.expression = expression;
    }
    return TemplateBinding;
})();
exports.TemplateBinding = TemplateBinding;
var RecursiveAstVisitor = (function () {
    function RecursiveAstVisitor() {
    }
    RecursiveAstVisitor.prototype.visitBinary = function (ast) {
        ast.left.visit(this);
        ast.right.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitConditional = function (ast) {
        ast.condition.visit(this);
        ast.trueExp.visit(this);
        ast.falseExp.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitIf = function (ast) {
        ast.condition.visit(this);
        ast.trueExp.visit(this);
        ast.falseExp.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function (ast) {
        ast.exp.visit(this);
        this.visitAll(ast.args);
        return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast) {
        ast.target.visit(this);
        this.visitAll(ast.args);
        return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast) { return null; };
    RecursiveAstVisitor.prototype.visitInterpolation = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast) {
        ast.obj.visit(this);
        ast.key.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast) {
        ast.obj.visit(this);
        ast.key.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast) { return this.visitAll(ast.values); };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast) { return null; };
    RecursiveAstVisitor.prototype.visitMethodCall = function (ast) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast) {
        ast.expression.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast) {
        ast.receiver.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args);
    };
    RecursiveAstVisitor.prototype.visitAll = function (asts) {
        var _this = this;
        asts.forEach(function (ast) { return ast.visit(_this); });
        return null;
    };
    return RecursiveAstVisitor;
})();
exports.RecursiveAstVisitor = RecursiveAstVisitor;
var AstTransformer = (function () {
    function AstTransformer() {
    }
    AstTransformer.prototype.visitImplicitReceiver = function (ast) { return ast; };
    AstTransformer.prototype.visitInterpolation = function (ast) {
        return new Interpolation(ast.strings, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralPrimitive = function (ast) {
        return new LiteralPrimitive(ast.value);
    };
    AstTransformer.prototype.visitPropertyRead = function (ast) {
        return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
    };
    AstTransformer.prototype.visitPropertyWrite = function (ast) {
        return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);
    };
    AstTransformer.prototype.visitSafePropertyRead = function (ast) {
        return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
    };
    AstTransformer.prototype.visitMethodCall = function (ast) {
        return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitSafeMethodCall = function (ast) {
        return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitFunctionCall = function (ast) {
        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitLiteralArray = function (ast) {
        return new LiteralArray(this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralMap = function (ast) {
        return new LiteralMap(ast.keys, this.visitAll(ast.values));
    };
    AstTransformer.prototype.visitBinary = function (ast) {
        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
    };
    AstTransformer.prototype.visitPrefixNot = function (ast) { return new PrefixNot(ast.expression.visit(this)); };
    AstTransformer.prototype.visitConditional = function (ast) {
        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    };
    AstTransformer.prototype.visitPipe = function (ast) {
        return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitKeyedRead = function (ast) {
        return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
    };
    AstTransformer.prototype.visitKeyedWrite = function (ast) {
        return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
    };
    AstTransformer.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    AstTransformer.prototype.visitChain = function (ast) { return new Chain(this.visitAll(ast.expressions)); };
    AstTransformer.prototype.visitIf = function (ast) {
        var falseExp = lang_1.isPresent(ast.falseExp) ? ast.falseExp.visit(this) : null;
        return new If(ast.condition.visit(this), ast.trueExp.visit(this), falseExp);
    };
    return AstTransformer;
})();
exports.AstTransformer = AstTransformer;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var decorators_1 = require('angular2/src/core/di/decorators');
var collection_1 = require("angular2/src/core/facade/collection");
var lang_1 = require("angular2/src/core/facade/lang");
var exceptions_1 = require('angular2/src/core/facade/exceptions');
(function (TokenType) {
    TokenType[TokenType["Character"] = 0] = "Character";
    TokenType[TokenType["Identifier"] = 1] = "Identifier";
    TokenType[TokenType["Keyword"] = 2] = "Keyword";
    TokenType[TokenType["String"] = 3] = "String";
    TokenType[TokenType["Operator"] = 4] = "Operator";
    TokenType[TokenType["Number"] = 5] = "Number";
})(exports.TokenType || (exports.TokenType = {}));
var TokenType = exports.TokenType;
var Lexer = (function () {
    function Lexer() {
    }
    Lexer.prototype.tokenize = function (text) {
        var scanner = new _Scanner(text);
        var tokens = [];
        var token = scanner.scanToken();
        while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
        }
        return tokens;
    };
    Lexer = __decorate([
        decorators_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], Lexer);
    return Lexer;
})();
exports.Lexer = Lexer;
var Token = (function () {
    function Token(index, type, numValue, strValue) {
        this.index = index;
        this.type = type;
        this.numValue = numValue;
        this.strValue = strValue;
    }
    Token.prototype.isCharacter = function (code) {
        return (this.type == TokenType.Character && this.numValue == code);
    };
    Token.prototype.isNumber = function () { return (this.type == TokenType.Number); };
    Token.prototype.isString = function () { return (this.type == TokenType.String); };
    Token.prototype.isOperator = function (operater) {
        return (this.type == TokenType.Operator && this.strValue == operater);
    };
    Token.prototype.isIdentifier = function () { return (this.type == TokenType.Identifier); };
    Token.prototype.isKeyword = function () { return (this.type == TokenType.Keyword); };
    Token.prototype.isKeywordVar = function () { return (this.type == TokenType.Keyword && this.strValue == "var"); };
    Token.prototype.isKeywordNull = function () { return (this.type == TokenType.Keyword && this.strValue == "null"); };
    Token.prototype.isKeywordUndefined = function () {
        return (this.type == TokenType.Keyword && this.strValue == "undefined");
    };
    Token.prototype.isKeywordTrue = function () { return (this.type == TokenType.Keyword && this.strValue == "true"); };
    Token.prototype.isKeywordIf = function () { return (this.type == TokenType.Keyword && this.strValue == "if"); };
    Token.prototype.isKeywordElse = function () { return (this.type == TokenType.Keyword && this.strValue == "else"); };
    Token.prototype.isKeywordFalse = function () { return (this.type == TokenType.Keyword && this.strValue == "false"); };
    Token.prototype.toNumber = function () {
        // -1 instead of NULL ok?
        return (this.type == TokenType.Number) ? this.numValue : -1;
    };
    Token.prototype.toString = function () {
        switch (this.type) {
            case TokenType.Character:
            case TokenType.Identifier:
            case TokenType.Keyword:
            case TokenType.Operator:
            case TokenType.String:
                return this.strValue;
            case TokenType.Number:
                return this.numValue.toString();
            default:
                return null;
        }
    };
    return Token;
})();
exports.Token = Token;
function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));
}
function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
}
function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
}
function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
}
function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
}
function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, "");
}
exports.EOF = new Token(-1, TokenType.Character, 0, "");
exports.$EOF = 0;
exports.$TAB = 9;
exports.$LF = 10;
exports.$VTAB = 11;
exports.$FF = 12;
exports.$CR = 13;
exports.$SPACE = 32;
exports.$BANG = 33;
exports.$DQ = 34;
exports.$HASH = 35;
exports.$$ = 36;
exports.$PERCENT = 37;
exports.$AMPERSAND = 38;
exports.$SQ = 39;
exports.$LPAREN = 40;
exports.$RPAREN = 41;
exports.$STAR = 42;
exports.$PLUS = 43;
exports.$COMMA = 44;
exports.$MINUS = 45;
exports.$PERIOD = 46;
exports.$SLASH = 47;
exports.$COLON = 58;
exports.$SEMICOLON = 59;
exports.$LT = 60;
exports.$EQ = 61;
exports.$GT = 62;
exports.$QUESTION = 63;
var $0 = 48;
var $9 = 57;
var $A = 65, $E = 69, $Z = 90;
exports.$LBRACKET = 91;
exports.$BACKSLASH = 92;
exports.$RBRACKET = 93;
var $CARET = 94;
var $_ = 95;
var $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
exports.$LBRACE = 123;
exports.$BAR = 124;
exports.$RBRACE = 125;
var $NBSP = 160;
var ScannerError = (function (_super) {
    __extends(ScannerError, _super);
    function ScannerError(message) {
        _super.call(this);
        this.message = message;
    }
    ScannerError.prototype.toString = function () { return this.message; };
    return ScannerError;
})(exceptions_1.BaseException);
exports.ScannerError = ScannerError;
var _Scanner = (function () {
    function _Scanner(input) {
        this.input = input;
        this.peek = 0;
        this.index = -1;
        this.length = input.length;
        this.advance();
    }
    _Scanner.prototype.advance = function () {
        this.peek =
            ++this.index >= this.length ? exports.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
    };
    _Scanner.prototype.scanToken = function () {
        var input = this.input, length = this.length, peek = this.peek, index = this.index;
        // Skip whitespace.
        while (peek <= exports.$SPACE) {
            if (++index >= length) {
                peek = exports.$EOF;
                break;
            }
            else {
                peek = lang_1.StringWrapper.charCodeAt(input, index);
            }
        }
        this.peek = peek;
        this.index = index;
        if (index >= length) {
            return null;
        }
        // Handle identifiers and numbers.
        if (isIdentifierStart(peek))
            return this.scanIdentifier();
        if (isDigit(peek))
            return this.scanNumber(index);
        var start = index;
        switch (peek) {
            case exports.$PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, exports.$PERIOD);
            case exports.$LPAREN:
            case exports.$RPAREN:
            case exports.$LBRACE:
            case exports.$RBRACE:
            case exports.$LBRACKET:
            case exports.$RBRACKET:
            case exports.$COMMA:
            case exports.$COLON:
            case exports.$SEMICOLON:
                return this.scanCharacter(start, peek);
            case exports.$SQ:
            case exports.$DQ:
                return this.scanString();
            case exports.$HASH:
            case exports.$PLUS:
            case exports.$MINUS:
            case exports.$STAR:
            case exports.$SLASH:
            case exports.$PERCENT:
            case $CARET:
                return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));
            case exports.$QUESTION:
                return this.scanComplexOperator(start, '?', exports.$PERIOD, '.');
            case exports.$LT:
            case exports.$GT:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=');
            case exports.$BANG:
            case exports.$EQ:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=', exports.$EQ, '=');
            case exports.$AMPERSAND:
                return this.scanComplexOperator(start, '&', exports.$AMPERSAND, '&');
            case exports.$BAR:
                return this.scanComplexOperator(start, '|', exports.$BAR, '|');
            case $NBSP:
                while (isWhitespace(this.peek))
                    this.advance();
                return this.scanToken();
        }
        this.error("Unexpected character [" + lang_1.StringWrapper.fromCharCode(peek) + "]", 0);
        return null;
    };
    _Scanner.prototype.scanCharacter = function (start, code) {
        assert(this.peek == code);
        this.advance();
        return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function (start, str) {
        assert(this.peek == lang_1.StringWrapper.charCodeAt(str, 0));
        assert(collection_1.SetWrapper.has(OPERATORS, str));
        this.advance();
        return newOperatorToken(start, str);
    };
    /**
     * Tokenize a 2/3 char long operator
     *
     * @param start start index in the expression
     * @param one first symbol (always part of the operator)
     * @param twoCode code point for the second symbol
     * @param two second symbol (part of the operator when the second code point matches)
     * @param threeCode code point for the third symbol
     * @param three third symbol (part of the operator when provided and matches source expression)
     * @returns {Token}
     */
    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
        assert(this.peek == lang_1.StringWrapper.charCodeAt(one, 0));
        this.advance();
        var str = one;
        if (this.peek == twoCode) {
            this.advance();
            str += two;
        }
        if (lang_1.isPresent(threeCode) && this.peek == threeCode) {
            this.advance();
            str += three;
        }
        assert(collection_1.SetWrapper.has(OPERATORS, str));
        return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function () {
        assert(isIdentifierStart(this.peek));
        var start = this.index;
        this.advance();
        while (isIdentifierPart(this.peek))
            this.advance();
        var str = this.input.substring(start, this.index);
        if (collection_1.SetWrapper.has(KEYWORDS, str)) {
            return newKeywordToken(start, str);
        }
        else {
            return newIdentifierToken(start, str);
        }
    };
    _Scanner.prototype.scanNumber = function (start) {
        assert(isDigit(this.peek));
        var simple = (this.index === start);
        this.advance(); // Skip initial digit.
        while (true) {
            if (isDigit(this.peek)) {
            }
            else if (this.peek == exports.$PERIOD) {
                simple = false;
            }
            else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                    this.advance();
                if (!isDigit(this.peek))
                    this.error('Invalid exponent', -1);
                simple = false;
            }
            else {
                break;
            }
            this.advance();
        }
        var str = this.input.substring(start, this.index);
        // TODO
        var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);
        return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function () {
        assert(this.peek == exports.$SQ || this.peek == exports.$DQ);
        var start = this.index;
        var quote = this.peek;
        this.advance(); // Skip initial quote.
        var buffer;
        var marker = this.index;
        var input = this.input;
        while (this.peek != quote) {
            if (this.peek == exports.$BACKSLASH) {
                if (buffer == null)
                    buffer = new lang_1.StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode;
                if (this.peek == $u) {
                    // 4 character hex code for unicode character.
                    var hex = input.substring(this.index + 1, this.index + 5);
                    try {
                        unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);
                    }
                    catch (e) {
                        this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                    }
                    for (var i = 0; i < 5; i++) {
                        this.advance();
                    }
                }
                else {
                    unescapedCode = unescape(this.peek);
                    this.advance();
                }
                buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
            }
            else if (this.peek == exports.$EOF) {
                this.error('Unterminated quote', 0);
            }
            else {
                this.advance();
            }
        }
        var last = input.substring(marker, this.index);
        this.advance(); // Skip terminating quote.
        // Compute the unescaped string value.
        var unescaped = last;
        if (buffer != null) {
            buffer.add(last);
            unescaped = buffer.toString();
        }
        return newStringToken(start, unescaped);
    };
    _Scanner.prototype.error = function (message, offset) {
        var position = this.index + offset;
        throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
})();
function isWhitespace(code) {
    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == $NBSP);
}
function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == exports.$$);
}
function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) ||
        (code == $_) || (code == exports.$$);
}
function isDigit(code) {
    return $0 <= code && code <= $9;
}
function isExponentStart(code) {
    return code == $e || code == $E;
}
function isExponentSign(code) {
    return code == exports.$MINUS || code == exports.$PLUS;
}
function unescape(code) {
    switch (code) {
        case $n:
            return exports.$LF;
        case $f:
            return exports.$FF;
        case $r:
            return exports.$CR;
        case $t:
            return exports.$TAB;
        case $v:
            return exports.$VTAB;
        default:
            return code;
    }
}
var OPERATORS = collection_1.SetWrapper.createFromList([
    '+',
    '-',
    '*',
    '/',
    '%',
    '^',
    '=',
    '==',
    '!=',
    '===',
    '!==',
    '<',
    '>',
    '<=',
    '>=',
    '&&',
    '||',
    '&',
    '|',
    '!',
    '?',
    '#',
    '?.'
]);
var KEYWORDS = collection_1.SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);

},{"angular2/src/core/di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/locals.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var Locals = (function () {
    function Locals(parent, current) {
        this.parent = parent;
        this.current = current;
    }
    Locals.prototype.contains = function (name) {
        if (this.current.has(name)) {
            return true;
        }
        if (lang_1.isPresent(this.parent)) {
            return this.parent.contains(name);
        }
        return false;
    };
    Locals.prototype.get = function (name) {
        if (this.current.has(name)) {
            return this.current.get(name);
        }
        if (lang_1.isPresent(this.parent)) {
            return this.parent.get(name);
        }
        throw new exceptions_1.BaseException("Cannot find '" + name + "'");
    };
    Locals.prototype.set = function (name, value) {
        // TODO(rado): consider removing this check if we can guarantee this is not
        // exposed to the public API.
        // TODO: vsavkin maybe it should check only the local map
        if (this.current.has(name)) {
            this.current.set(name, value);
        }
        else {
            throw new exceptions_1.BaseException("Setting of new keys post-construction is not supported. Key: " + name + ".");
        }
    };
    Locals.prototype.clearValues = function () { collection_1.MapWrapper.clearValues(this.current); };
    return Locals;
})();
exports.Locals = Locals;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/parser.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var decorators_1 = require('angular2/src/core/di/decorators');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lexer_1 = require('./lexer');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var ast_1 = require('./ast');
var _implicitReceiver = new ast_1.ImplicitReceiver();
// TODO(tbosch): Cannot make this const/final right now because of the transpiler...
var INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
var ParseException = (function (_super) {
    __extends(ParseException, _super);
    function ParseException(message, input, errLocation, ctxLocation) {
        _super.call(this, "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation);
    }
    return ParseException;
})(exceptions_1.BaseException);
var Parser = (function () {
    function Parser(/** @internal */ _lexer, providedReflector) {
        if (providedReflector === void 0) { providedReflector = null; }
        this._lexer = _lexer;
        this._reflector = lang_1.isPresent(providedReflector) ? providedReflector : reflection_1.reflector;
    }
    Parser.prototype.parseAction = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseBinding = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseSimpleBinding = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseTemplateBindings = function (input, location) {
        var tokens = this._lexer.tokenize(input);
        return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length <= 1) {
            return null;
        }
        var strings = [];
        var expressions = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i % 2 === 0) {
                // fixed string
                strings.push(part);
            }
            else if (part.trim().length > 0) {
                var tokens = this._lexer.tokenize(part);
                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                expressions.push(ast);
            }
            else {
                throw new ParseException('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i) + " in", location);
            }
        }
        return new ast_1.ASTWithSource(new ast_1.Interpolation(strings, expressions), input, location);
    };
    Parser.prototype.wrapLiteralPrimitive = function (input, location) {
        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);
    };
    Parser.prototype._checkNoInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length > 1) {
            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, "at column " + this._findInterpolationErrorColumn(parts, 1) + " in", location);
        }
    };
    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx) {
        var errLocation = '';
        for (var j = 0; j < partInErrIdx; j++) {
            errLocation += j % 2 === 0 ? parts[j] : "{{" + parts[j] + "}}";
        }
        return errLocation.length;
    };
    Parser = __decorate([
        decorators_1.Injectable(), 
        __metadata('design:paramtypes', [lexer_1.Lexer, reflection_1.Reflector])
    ], Parser);
    return Parser;
})();
exports.Parser = Parser;
var _ParseAST = (function () {
    function _ParseAST(input, location, tokens, reflector, parseAction) {
        this.input = input;
        this.location = location;
        this.tokens = tokens;
        this.reflector = reflector;
        this.parseAction = parseAction;
        this.index = 0;
    }
    _ParseAST.prototype.peek = function (offset) {
        var i = this.index + offset;
        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
        get: function () { return this.peek(0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
        get: function () {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
        },
        enumerable: true,
        configurable: true
    });
    _ParseAST.prototype.advance = function () { this.index++; };
    _ParseAST.prototype.optionalCharacter = function (code) {
        if (this.next.isCharacter(code)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.optionalKeywordVar = function () {
        if (this.peekKeywordVar()) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.peekKeywordVar = function () { return this.next.isKeywordVar() || this.next.isOperator('#'); };
    _ParseAST.prototype.expectCharacter = function (code) {
        if (this.optionalCharacter(code))
            return;
        this.error("Missing expected " + lang_1.StringWrapper.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function (op) {
        if (this.next.isOperator(op)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.expectOperator = function (operator) {
        if (this.optionalOperator(operator))
            return;
        this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword()) {
            this.error("Unexpected token " + n + ", expected identifier or keyword");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
            this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.parseChain = function () {
        var exprs = [];
        while (this.index < this.tokens.length) {
            var expr = this.parsePipe();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                if (!this.parseAction) {
                    this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
            else if (this.index < this.tokens.length) {
                this.error("Unexpected token '" + this.next + "'");
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    _ParseAST.prototype.parseSimpleBinding = function () {
        var ast = this.parseChain();
        if (!SimpleExpressionChecker.check(ast)) {
            this.error("Simple binding expression can only contain field access and constants'");
        }
        return ast;
    };
    _ParseAST.prototype.parsePipe = function () {
        var result = this.parseExpression();
        if (this.optionalOperator("|")) {
            if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
            }
            do {
                var name = this.expectIdentifierOrKeyword();
                var args = [];
                while (this.optionalCharacter(lexer_1.$COLON)) {
                    args.push(this.parsePipe());
                }
                result = new ast_1.BindingPipe(result, name, args);
            } while (this.optionalOperator("|"));
        }
        return result;
    };
    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
    _ParseAST.prototype.parseConditional = function () {
        var start = this.inputIndex;
        var result = this.parseLogicalOr();
        if (this.optionalOperator('?')) {
            var yes = this.parsePipe();
            if (!this.optionalCharacter(lexer_1.$COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error("Conditional expression " + expression + " requires all 3 expressions");
            }
            var no = this.parsePipe();
            return new ast_1.Conditional(result, yes, no);
        }
        else {
            return result;
        }
    };
    _ParseAST.prototype.parseLogicalOr = function () {
        // '||'
        var result = this.parseLogicalAnd();
        while (this.optionalOperator('||')) {
            result = new ast_1.Binary('||', result, this.parseLogicalAnd());
        }
        return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function () {
        // '&&'
        var result = this.parseEquality();
        while (this.optionalOperator('&&')) {
            result = new ast_1.Binary('&&', result, this.parseEquality());
        }
        return result;
    };
    _ParseAST.prototype.parseEquality = function () {
        // '==','!=','===','!=='
        var result = this.parseRelational();
        while (true) {
            if (this.optionalOperator('==')) {
                result = new ast_1.Binary('==', result, this.parseRelational());
            }
            else if (this.optionalOperator('===')) {
                result = new ast_1.Binary('===', result, this.parseRelational());
            }
            else if (this.optionalOperator('!=')) {
                result = new ast_1.Binary('!=', result, this.parseRelational());
            }
            else if (this.optionalOperator('!==')) {
                result = new ast_1.Binary('!==', result, this.parseRelational());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseRelational = function () {
        // '<', '>', '<=', '>='
        var result = this.parseAdditive();
        while (true) {
            if (this.optionalOperator('<')) {
                result = new ast_1.Binary('<', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>')) {
                result = new ast_1.Binary('>', result, this.parseAdditive());
            }
            else if (this.optionalOperator('<=')) {
                result = new ast_1.Binary('<=', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>=')) {
                result = new ast_1.Binary('>=', result, this.parseAdditive());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseAdditive = function () {
        // '+', '-'
        var result = this.parseMultiplicative();
        while (true) {
            if (this.optionalOperator('+')) {
                result = new ast_1.Binary('+', result, this.parseMultiplicative());
            }
            else if (this.optionalOperator('-')) {
                result = new ast_1.Binary('-', result, this.parseMultiplicative());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseMultiplicative = function () {
        // '*', '%', '/'
        var result = this.parsePrefix();
        while (true) {
            if (this.optionalOperator('*')) {
                result = new ast_1.Binary('*', result, this.parsePrefix());
            }
            else if (this.optionalOperator('%')) {
                result = new ast_1.Binary('%', result, this.parsePrefix());
            }
            else if (this.optionalOperator('/')) {
                result = new ast_1.Binary('/', result, this.parsePrefix());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrefix = function () {
        if (this.optionalOperator('+')) {
            return this.parsePrefix();
        }
        else if (this.optionalOperator('-')) {
            return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());
        }
        else if (this.optionalOperator('!')) {
            return new ast_1.PrefixNot(this.parsePrefix());
        }
        else {
            return this.parseCallChain();
        }
    };
    _ParseAST.prototype.parseCallChain = function () {
        var result = this.parsePrimary();
        while (true) {
            if (this.optionalCharacter(lexer_1.$PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result, false);
            }
            else if (this.optionalOperator('?.')) {
                result = this.parseAccessMemberOrMethodCall(result, true);
            }
            else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
                var key = this.parsePipe();
                this.expectCharacter(lexer_1.$RBRACKET);
                if (this.optionalOperator("=")) {
                    var value = this.parseConditional();
                    result = new ast_1.KeyedWrite(result, key, value);
                }
                else {
                    result = new ast_1.KeyedRead(result, key);
                }
            }
            else if (this.optionalCharacter(lexer_1.$LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter(lexer_1.$RPAREN);
                result = new ast_1.FunctionCall(result, args);
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrimary = function () {
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var result = this.parsePipe();
            this.expectCharacter(lexer_1.$RPAREN);
            return result;
        }
        else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
            this.advance();
            return new ast_1.LiteralPrimitive(null);
        }
        else if (this.next.isKeywordTrue()) {
            this.advance();
            return new ast_1.LiteralPrimitive(true);
        }
        else if (this.next.isKeywordFalse()) {
            this.advance();
            return new ast_1.LiteralPrimitive(false);
        }
        else if (this.parseAction && this.next.isKeywordIf()) {
            this.advance();
            this.expectCharacter(lexer_1.$LPAREN);
            var condition = this.parseExpression();
            this.expectCharacter(lexer_1.$RPAREN);
            var ifExp = this.parseExpressionOrBlock();
            var elseExp;
            if (this.next.isKeywordElse()) {
                this.advance();
                elseExp = this.parseExpressionOrBlock();
            }
            return new ast_1.If(condition, ifExp, elseExp);
        }
        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
            var elements = this.parseExpressionList(lexer_1.$RBRACKET);
            this.expectCharacter(lexer_1.$RBRACKET);
            return new ast_1.LiteralArray(elements);
        }
        else if (this.next.isCharacter(lexer_1.$LBRACE)) {
            return this.parseLiteralMap();
        }
        else if (this.next.isIdentifier()) {
            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
        }
        else if (this.next.isNumber()) {
            var value = this.next.toNumber();
            this.advance();
            return new ast_1.LiteralPrimitive(value);
        }
        else if (this.next.isString()) {
            var literalValue = this.next.toString();
            this.advance();
            return new ast_1.LiteralPrimitive(literalValue);
        }
        else if (this.index >= this.tokens.length) {
            this.error("Unexpected end of expression: " + this.input);
        }
        else {
            this.error("Unexpected token " + this.next);
        }
        // error() throws, so we don't reach here.
        throw new exceptions_1.BaseException("Fell through all cases in parsePrimary");
    };
    _ParseAST.prototype.parseExpressionList = function (terminator) {
        var result = [];
        if (!this.next.isCharacter(terminator)) {
            do {
                result.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
        }
        return result;
    };
    _ParseAST.prototype.parseLiteralMap = function () {
        var keys = [];
        var values = [];
        this.expectCharacter(lexer_1.$LBRACE);
        if (!this.optionalCharacter(lexer_1.$RBRACE)) {
            do {
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push(key);
                this.expectCharacter(lexer_1.$COLON);
                values.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
            this.expectCharacter(lexer_1.$RBRACE);
        }
        return new ast_1.LiteralMap(keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
        if (isSafe === void 0) { isSafe = false; }
        var id = this.expectIdentifierOrKeyword();
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var args = this.parseCallArguments();
            this.expectCharacter(lexer_1.$RPAREN);
            var fn = this.reflector.method(id);
            return isSafe ? new ast_1.SafeMethodCall(receiver, id, fn, args) :
                new ast_1.MethodCall(receiver, id, fn, args);
        }
        else {
            if (isSafe) {
                if (this.optionalOperator("=")) {
                    this.error("The '?.' operator cannot be used in the assignment");
                }
                else {
                    return new ast_1.SafePropertyRead(receiver, id, this.reflector.getter(id));
                }
            }
            else {
                if (this.optionalOperator("=")) {
                    if (!this.parseAction) {
                        this.error("Bindings cannot contain assignments");
                    }
                    var value = this.parseConditional();
                    return new ast_1.PropertyWrite(receiver, id, this.reflector.setter(id), value);
                }
                else {
                    return new ast_1.PropertyRead(receiver, id, this.reflector.getter(id));
                }
            }
        }
        return null;
    };
    _ParseAST.prototype.parseCallArguments = function () {
        if (this.next.isCharacter(lexer_1.$RPAREN))
            return [];
        var positionals = [];
        do {
            positionals.push(this.parsePipe());
        } while (this.optionalCharacter(lexer_1.$COMMA));
        return positionals;
    };
    _ParseAST.prototype.parseExpressionOrBlock = function () {
        if (this.optionalCharacter(lexer_1.$LBRACE)) {
            var block = this.parseBlockContent();
            this.expectCharacter(lexer_1.$RBRACE);
            return block;
        }
        return this.parseExpression();
    };
    _ParseAST.prototype.parseBlockContent = function () {
        if (!this.parseAction) {
            this.error("Binding expression cannot contain chained expression");
        }
        var exprs = [];
        while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {
            var expr = this.parseExpression();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    _ParseAST.prototype.expectTemplateBindingKey = function () {
        var result = '';
        var operatorFound = false;
        do {
            result += this.expectIdentifierOrKeywordOrString();
            operatorFound = this.optionalOperator('-');
            if (operatorFound) {
                result += '-';
            }
        } while (operatorFound);
        return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function () {
        var bindings = [];
        var prefix = null;
        while (this.index < this.tokens.length) {
            var keyIsVar = this.optionalKeywordVar();
            var key = this.expectTemplateBindingKey();
            if (!keyIsVar) {
                if (prefix == null) {
                    prefix = key;
                }
                else {
                    key = prefix + '-' + key;
                }
            }
            this.optionalCharacter(lexer_1.$COLON);
            var name = null;
            var expression = null;
            if (keyIsVar) {
                if (this.optionalOperator("=")) {
                    name = this.expectTemplateBindingKey();
                }
                else {
                    name = '\$implicit';
                }
            }
            else if (this.next !== lexer_1.EOF && !this.peekKeywordVar()) {
                var start = this.inputIndex;
                var ast = this.parsePipe();
                var source = this.input.substring(start, this.inputIndex);
                expression = new ast_1.ASTWithSource(ast, source, this.location);
            }
            bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
            if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {
                this.optionalCharacter(lexer_1.$COMMA);
            }
        }
        return bindings;
    };
    _ParseAST.prototype.error = function (message, index) {
        if (index === void 0) { index = null; }
        if (lang_1.isBlank(index))
            index = this.index;
        var location = (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
            "at the end of the expression";
        throw new ParseException(message, this.input, location, this.location);
    };
    return _ParseAST;
})();
exports._ParseAST = _ParseAST;
var SimpleExpressionChecker = (function () {
    function SimpleExpressionChecker() {
        this.simple = true;
    }
    SimpleExpressionChecker.check = function (ast) {
        var s = new SimpleExpressionChecker();
        ast.visit(s);
        return s.simple;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast) { };
    SimpleExpressionChecker.prototype.visitInterpolation = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast) { };
    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast) { };
    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitMethodCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast) { this.visitAll(ast.expressions); };
    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast) { this.visitAll(ast.values); };
    SimpleExpressionChecker.prototype.visitBinary = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitConditional = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPipe = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    SimpleExpressionChecker.prototype.visitChain = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitIf = function (ast) { this.simple = false; };
    return SimpleExpressionChecker;
})();

},{"./ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./lexer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js","angular2/src/core/di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipe_lifecycle_reflector.js":[function(require,module,exports){
'use strict';function implementsOnDestroy(pipe) {
    return pipe.constructor.prototype.onDestroy;
}
exports.implementsOnDestroy = implementsOnDestroy;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipes.js":[function(require,module,exports){
'use strict';var SelectedPipe = (function () {
    function SelectedPipe(pipe, pure) {
        this.pipe = pipe;
        this.pure = pure;
    }
    return SelectedPipe;
})();
exports.SelectedPipe = SelectedPipe;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ast_1 = require('./parser/ast');
var change_detection_util_1 = require('./change_detection_util');
var dynamic_change_detector_1 = require('./dynamic_change_detector');
var directive_record_1 = require('./directive_record');
var event_binding_1 = require('./event_binding');
var coalesce_1 = require('./coalesce');
var proto_record_1 = require('./proto_record');
var DynamicProtoChangeDetector = (function () {
    function DynamicProtoChangeDetector(_definition) {
        this._definition = _definition;
        this._propertyBindingRecords = createPropertyRecords(_definition);
        this._eventBindingRecords = createEventRecords(_definition);
        this._propertyBindingTargets = this._definition.bindingRecords.map(function (b) { return b.target; });
        this._directiveIndices = this._definition.directiveRecords.map(function (d) { return d.directiveIndex; });
    }
    DynamicProtoChangeDetector.prototype.instantiate = function (dispatcher) {
        return new dynamic_change_detector_1.DynamicChangeDetector(this._definition.id, dispatcher, this._propertyBindingRecords.length, this._propertyBindingTargets, this._directiveIndices, this._definition.strategy, this._propertyBindingRecords, this._eventBindingRecords, this._definition.directiveRecords, this._definition.genConfig);
    };
    return DynamicProtoChangeDetector;
})();
exports.DynamicProtoChangeDetector = DynamicProtoChangeDetector;
function createPropertyRecords(definition) {
    var recordBuilder = new ProtoRecordBuilder();
    collection_1.ListWrapper.forEachWithIndex(definition.bindingRecords, function (b, index) { return recordBuilder.add(b, definition.variableNames, index); });
    return coalesce_1.coalesce(recordBuilder.records);
}
exports.createPropertyRecords = createPropertyRecords;
function createEventRecords(definition) {
    // TODO: vsavkin: remove $event when the compiler handles render-side variables properly
    var varNames = collection_1.ListWrapper.concat(['$event'], definition.variableNames);
    return definition.eventRecords.map(function (er) {
        var records = _ConvertAstIntoProtoRecords.create(er, varNames);
        var dirIndex = er.implicitReceiver instanceof directive_record_1.DirectiveIndex ? er.implicitReceiver : null;
        return new event_binding_1.EventBinding(er.target.name, er.target.elementIndex, dirIndex, records);
    });
}
exports.createEventRecords = createEventRecords;
var ProtoRecordBuilder = (function () {
    function ProtoRecordBuilder() {
        this.records = [];
    }
    ProtoRecordBuilder.prototype.add = function (b, variableNames, bindingIndex) {
        var oldLast = collection_1.ListWrapper.last(this.records);
        if (lang_1.isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
            oldLast.lastInDirective = false;
        }
        var numberOfRecordsBefore = this.records.length;
        this._appendRecords(b, variableNames, bindingIndex);
        var newLast = collection_1.ListWrapper.last(this.records);
        if (lang_1.isPresent(newLast) && newLast !== oldLast) {
            newLast.lastInBinding = true;
            newLast.lastInDirective = true;
            this._setArgumentToPureFunction(numberOfRecordsBefore);
        }
    };
    /** @internal */
    ProtoRecordBuilder.prototype._setArgumentToPureFunction = function (startIndex) {
        var _this = this;
        for (var i = startIndex; i < this.records.length; ++i) {
            var rec = this.records[i];
            if (rec.isPureFunction()) {
                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
                    true; });
            }
            if (rec.mode === proto_record_1.RecordType.Pipe) {
                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
                    true; });
                this.records[rec.contextIndex - 1].argumentToPureFunction = true;
            }
        }
    };
    /** @internal */
    ProtoRecordBuilder.prototype._appendRecords = function (b, variableNames, bindingIndex) {
        if (b.isDirectiveLifecycle()) {
            this.records.push(new proto_record_1.ProtoRecord(proto_record_1.RecordType.DirectiveLifecycle, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, false, false, false, false, null));
        }
        else {
            _ConvertAstIntoProtoRecords.append(this.records, b, variableNames, bindingIndex);
        }
    };
    return ProtoRecordBuilder;
})();
exports.ProtoRecordBuilder = ProtoRecordBuilder;
var _ConvertAstIntoProtoRecords = (function () {
    function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _variableNames, _bindingIndex) {
        this._records = _records;
        this._bindingRecord = _bindingRecord;
        this._variableNames = _variableNames;
        this._bindingIndex = _bindingIndex;
    }
    _ConvertAstIntoProtoRecords.append = function (records, b, variableNames, bindingIndex) {
        var c = new _ConvertAstIntoProtoRecords(records, b, variableNames, bindingIndex);
        b.ast.visit(c);
    };
    _ConvertAstIntoProtoRecords.create = function (b, variableNames) {
        var rec = [];
        _ConvertAstIntoProtoRecords.append(rec, b, variableNames, null);
        rec[rec.length - 1].lastInBinding = true;
        return rec;
    };
    _ConvertAstIntoProtoRecords.prototype.visitImplicitReceiver = function (ast) { return this._bindingRecord.implicitReceiver; };
    _ConvertAstIntoProtoRecords.prototype.visitInterpolation = function (ast) {
        var args = this._visitAll(ast.expressions);
        return this._addRecord(proto_record_1.RecordType.Interpolate, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralPrimitive = function (ast) {
        return this._addRecord(proto_record_1.RecordType.Const, "literal", ast.value, [], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPropertyRead = function (ast) {
        var receiver = ast.receiver.visit(this);
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
            ast.receiver instanceof ast_1.ImplicitReceiver) {
            return this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
        }
        else {
            return this._addRecord(proto_record_1.RecordType.PropertyRead, ast.name, ast.getter, [], null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitPropertyWrite = function (ast) {
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
            ast.receiver instanceof ast_1.ImplicitReceiver) {
            throw new exceptions_1.BaseException("Cannot reassign a variable binding " + ast.name);
        }
        else {
            var receiver = ast.receiver.visit(this);
            var value = ast.value.visit(this);
            return this._addRecord(proto_record_1.RecordType.PropertyWrite, ast.name, ast.setter, [value], null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitKeyedWrite = function (ast) {
        var obj = ast.obj.visit(this);
        var key = ast.key.visit(this);
        var value = ast.value.visit(this);
        return this._addRecord(proto_record_1.RecordType.KeyedWrite, null, null, [key, value], null, obj);
    };
    _ConvertAstIntoProtoRecords.prototype.visitSafePropertyRead = function (ast) {
        var receiver = ast.receiver.visit(this);
        return this._addRecord(proto_record_1.RecordType.SafeProperty, ast.name, ast.getter, [], null, receiver);
    };
    _ConvertAstIntoProtoRecords.prototype.visitMethodCall = function (ast) {
        var receiver = ast.receiver.visit(this);
        var args = this._visitAll(ast.args);
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name)) {
            var target = this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
            return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
        }
        else {
            return this._addRecord(proto_record_1.RecordType.InvokeMethod, ast.name, ast.fn, args, null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitSafeMethodCall = function (ast) {
        var receiver = ast.receiver.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.SafeMethodInvoke, ast.name, ast.fn, args, null, receiver);
    };
    _ConvertAstIntoProtoRecords.prototype.visitFunctionCall = function (ast) {
        var target = ast.target.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralArray = function (ast) {
        var primitiveName = "arrayFn" + ast.expressions.length;
        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralMap = function (ast) {
        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, _mapPrimitiveName(ast.keys), change_detection_util_1.ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitBinary = function (ast) {
        var left = ast.left.visit(this);
        var right = ast.right.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPrefixNot = function (ast) {
        var exp = ast.expression.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "operation_negate", change_detection_util_1.ChangeDetectionUtil.operation_negate, [exp], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitConditional = function (ast) {
        var c = ast.condition.visit(this);
        var t = ast.trueExp.visit(this);
        var f = ast.falseExp.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "cond", change_detection_util_1.ChangeDetectionUtil.cond, [c, t, f], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPipe = function (ast) {
        var value = ast.exp.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.Pipe, ast.name, ast.name, args, null, value);
    };
    _ConvertAstIntoProtoRecords.prototype.visitKeyedRead = function (ast) {
        var obj = ast.obj.visit(this);
        var key = ast.key.visit(this);
        return this._addRecord(proto_record_1.RecordType.KeyedRead, "keyedAccess", change_detection_util_1.ChangeDetectionUtil.keyedAccess, [key], null, obj);
    };
    _ConvertAstIntoProtoRecords.prototype.visitChain = function (ast) {
        var _this = this;
        var args = ast.expressions.map(function (e) { return e.visit(_this); });
        return this._addRecord(proto_record_1.RecordType.Chain, "chain", null, args, null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitIf = function (ast) { throw new exceptions_1.BaseException('Not supported'); };
    _ConvertAstIntoProtoRecords.prototype._visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    _ConvertAstIntoProtoRecords.prototype._addRecord = function (type, name, funcOrValue, args, fixedArgs, context) {
        var selfIndex = this._records.length + 1;
        if (context instanceof directive_record_1.DirectiveIndex) {
            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
        }
        else {
            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
        }
        return selfIndex;
    };
    return _ConvertAstIntoProtoRecords;
})();
function _arrayFn(length) {
    switch (length) {
        case 0:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn0;
        case 1:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn1;
        case 2:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn2;
        case 3:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn3;
        case 4:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn4;
        case 5:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn5;
        case 6:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn6;
        case 7:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn7;
        case 8:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn8;
        case 9:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn9;
        default:
            throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
    }
}
function _mapPrimitiveName(keys) {
    var stringifiedKeys = keys.map(function (k) { return lang_1.isString(k) ? "\"" + k + "\"" : "" + k; }).join(', ');
    return "mapFn([" + stringifiedKeys + "])";
}
function _operationToPrimitiveName(operation) {
    switch (operation) {
        case '+':
            return "operation_add";
        case '-':
            return "operation_subtract";
        case '*':
            return "operation_multiply";
        case '/':
            return "operation_divide";
        case '%':
            return "operation_remainder";
        case '==':
            return "operation_equals";
        case '!=':
            return "operation_not_equals";
        case '===':
            return "operation_identical";
        case '!==':
            return "operation_not_identical";
        case '<':
            return "operation_less_then";
        case '>':
            return "operation_greater_then";
        case '<=':
            return "operation_less_or_equals_then";
        case '>=':
            return "operation_greater_or_equals_then";
        case '&&':
            return "operation_logical_and";
        case '||':
            return "operation_logical_or";
        default:
            throw new exceptions_1.BaseException("Unsupported operation " + operation);
    }
}
function _operationToFunction(operation) {
    switch (operation) {
        case '+':
            return change_detection_util_1.ChangeDetectionUtil.operation_add;
        case '-':
            return change_detection_util_1.ChangeDetectionUtil.operation_subtract;
        case '*':
            return change_detection_util_1.ChangeDetectionUtil.operation_multiply;
        case '/':
            return change_detection_util_1.ChangeDetectionUtil.operation_divide;
        case '%':
            return change_detection_util_1.ChangeDetectionUtil.operation_remainder;
        case '==':
            return change_detection_util_1.ChangeDetectionUtil.operation_equals;
        case '!=':
            return change_detection_util_1.ChangeDetectionUtil.operation_not_equals;
        case '===':
            return change_detection_util_1.ChangeDetectionUtil.operation_identical;
        case '!==':
            return change_detection_util_1.ChangeDetectionUtil.operation_not_identical;
        case '<':
            return change_detection_util_1.ChangeDetectionUtil.operation_less_then;
        case '>':
            return change_detection_util_1.ChangeDetectionUtil.operation_greater_then;
        case '<=':
            return change_detection_util_1.ChangeDetectionUtil.operation_less_or_equals_then;
        case '>=':
            return change_detection_util_1.ChangeDetectionUtil.operation_greater_or_equals_then;
        case '&&':
            return change_detection_util_1.ChangeDetectionUtil.operation_logical_and;
        case '||':
            return change_detection_util_1.ChangeDetectionUtil.operation_logical_or;
        default:
            throw new exceptions_1.BaseException("Unsupported operation " + operation);
    }
}
function s(v) {
    return lang_1.isPresent(v) ? "" + v : '';
}
function _interpolationFn(strings) {
    var length = strings.length;
    var c0 = length > 0 ? strings[0] : null;
    var c1 = length > 1 ? strings[1] : null;
    var c2 = length > 2 ? strings[2] : null;
    var c3 = length > 3 ? strings[3] : null;
    var c4 = length > 4 ? strings[4] : null;
    var c5 = length > 5 ? strings[5] : null;
    var c6 = length > 6 ? strings[6] : null;
    var c7 = length > 7 ? strings[7] : null;
    var c8 = length > 8 ? strings[8] : null;
    var c9 = length > 9 ? strings[9] : null;
    switch (length - 1) {
        case 1:
            return function (a1) { return c0 + s(a1) + c1; };
        case 2:
            return function (a1, a2) { return c0 + s(a1) + c1 + s(a2) + c2; };
        case 3:
            return function (a1, a2, a3) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3; };
        case 4:
            return function (a1, a2, a3, a4) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4; };
        case 5:
            return function (a1, a2, a3, a4, a5) {
                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
            };
        case 6:
            return function (a1, a2, a3, a4, a5, a6) {
                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
            };
        case 7:
            return function (a1, a2, a3, a4, a5, a6, a7) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7; };
        case 8:
            return function (a1, a2, a3, a4, a5, a6, a7, a8) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) +
                c8; };
        case 9:
            return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 +
                s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) +
                c7 + s(a8) + c8 + s(a9) + c9; };
        default:
            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
    }
}

},{"./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./coalesce":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/coalesce.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./dynamic_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js","./event_binding":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/event_binding.js","./parser/ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js":[function(require,module,exports){
'use strict';(function (RecordType) {
    RecordType[RecordType["Self"] = 0] = "Self";
    RecordType[RecordType["Const"] = 1] = "Const";
    RecordType[RecordType["PrimitiveOp"] = 2] = "PrimitiveOp";
    RecordType[RecordType["PropertyRead"] = 3] = "PropertyRead";
    RecordType[RecordType["PropertyWrite"] = 4] = "PropertyWrite";
    RecordType[RecordType["Local"] = 5] = "Local";
    RecordType[RecordType["InvokeMethod"] = 6] = "InvokeMethod";
    RecordType[RecordType["InvokeClosure"] = 7] = "InvokeClosure";
    RecordType[RecordType["KeyedRead"] = 8] = "KeyedRead";
    RecordType[RecordType["KeyedWrite"] = 9] = "KeyedWrite";
    RecordType[RecordType["Pipe"] = 10] = "Pipe";
    RecordType[RecordType["Interpolate"] = 11] = "Interpolate";
    RecordType[RecordType["SafeProperty"] = 12] = "SafeProperty";
    RecordType[RecordType["CollectionLiteral"] = 13] = "CollectionLiteral";
    RecordType[RecordType["SafeMethodInvoke"] = 14] = "SafeMethodInvoke";
    RecordType[RecordType["DirectiveLifecycle"] = 15] = "DirectiveLifecycle";
    RecordType[RecordType["Chain"] = 16] = "Chain";
})(exports.RecordType || (exports.RecordType = {}));
var RecordType = exports.RecordType;
var ProtoRecord = (function () {
    function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, lastInBinding, lastInDirective, argumentToPureFunction, referencedBySelf, propertyBindingIndex) {
        this.mode = mode;
        this.name = name;
        this.funcOrValue = funcOrValue;
        this.args = args;
        this.fixedArgs = fixedArgs;
        this.contextIndex = contextIndex;
        this.directiveIndex = directiveIndex;
        this.selfIndex = selfIndex;
        this.bindingRecord = bindingRecord;
        this.lastInBinding = lastInBinding;
        this.lastInDirective = lastInDirective;
        this.argumentToPureFunction = argumentToPureFunction;
        this.referencedBySelf = referencedBySelf;
        this.propertyBindingIndex = propertyBindingIndex;
    }
    ProtoRecord.prototype.isPureFunction = function () {
        return this.mode === RecordType.Interpolate || this.mode === RecordType.CollectionLiteral;
    };
    ProtoRecord.prototype.isUsedByOtherRecord = function () { return !this.lastInBinding || this.referencedBySelf; };
    ProtoRecord.prototype.shouldBeChecked = function () {
        return this.argumentToPureFunction || this.lastInBinding || this.isPureFunction() ||
            this.isPipeRecord();
    };
    ProtoRecord.prototype.isPipeRecord = function () { return this.mode === RecordType.Pipe; };
    ProtoRecord.prototype.isLifeCycleRecord = function () { return this.mode === RecordType.DirectiveLifecycle; };
    return ProtoRecord;
})();
exports.ProtoRecord = ProtoRecord;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/anchor_based_app_root_url.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var app_root_url_1 = require("angular2/src/core/compiler/app_root_url");
var dom_adapter_1 = require("angular2/src/core/dom/dom_adapter");
var di_1 = require("angular2/src/core/di");
/**
 * Extension of {@link AppRootUrl} that uses a DOM anchor tag to set the root url to
 * the current page's url.
 */
var AnchorBasedAppRootUrl = (function (_super) {
    __extends(AnchorBasedAppRootUrl, _super);
    function AnchorBasedAppRootUrl() {
        _super.call(this, "");
        // compute the root url to pass to AppRootUrl
        var a = dom_adapter_1.DOM.createElement('a');
        dom_adapter_1.DOM.resolveAndSetHref(a, './', null);
        this.value = dom_adapter_1.DOM.getHref(a);
    }
    AnchorBasedAppRootUrl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AnchorBasedAppRootUrl);
    return AnchorBasedAppRootUrl;
})(app_root_url_1.AppRootUrl);
exports.AnchorBasedAppRootUrl = AnchorBasedAppRootUrl;

},{"angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
/**
 * Specifies app root url for the application.
 *
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var AppRootUrl = (function () {
    function AppRootUrl(value) {
        this.value = value;
    }
    AppRootUrl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [String])
    ], AppRootUrl);
    return AppRootUrl;
})();
exports.AppRootUrl = AppRootUrl;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_definition_factory.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var template_ast_1 = require('./template_ast');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
function createChangeDetectorDefinitions(componentType, componentStrategy, genConfig, parsedTemplate) {
    var pvVisitors = [];
    var visitor = new ProtoViewVisitor(null, pvVisitors, componentStrategy);
    template_ast_1.templateVisitAll(visitor, parsedTemplate);
    return createChangeDefinitions(pvVisitors, componentType, genConfig);
}
exports.createChangeDetectorDefinitions = createChangeDetectorDefinitions;
var ProtoViewVisitor = (function () {
    function ProtoViewVisitor(parent, allVisitors, strategy) {
        this.parent = parent;
        this.allVisitors = allVisitors;
        this.strategy = strategy;
        this.boundTextCount = 0;
        this.boundElementCount = 0;
        this.variableNames = [];
        this.bindingRecords = [];
        this.eventRecords = [];
        this.directiveRecords = [];
        this.viewIndex = allVisitors.length;
        allVisitors.push(this);
    }
    ProtoViewVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        this.boundElementCount++;
        for (var i = 0; i < ast.directives.length; i++) {
            ast.directives[i].visit(this, i);
        }
        var childVisitor = new ProtoViewVisitor(this, this.allVisitors, change_detection_1.ChangeDetectionStrategy.Default);
        // Attention: variables present on an embedded template count towards
        // the embedded template and not the template anchor!
        template_ast_1.templateVisitAll(childVisitor, ast.vars);
        template_ast_1.templateVisitAll(childVisitor, ast.children);
        return null;
    };
    ProtoViewVisitor.prototype.visitElement = function (ast, context) {
        if (ast.isBound()) {
            this.boundElementCount++;
        }
        template_ast_1.templateVisitAll(this, ast.inputs, null);
        template_ast_1.templateVisitAll(this, ast.outputs);
        template_ast_1.templateVisitAll(this, ast.exportAsVars);
        for (var i = 0; i < ast.directives.length; i++) {
            ast.directives[i].visit(this, i);
        }
        template_ast_1.templateVisitAll(this, ast.children);
        return null;
    };
    ProtoViewVisitor.prototype.visitNgContent = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitVariable = function (ast, context) {
        this.variableNames.push(ast.name);
        return null;
    };
    ProtoViewVisitor.prototype.visitEvent = function (ast, directiveRecord) {
        var bindingRecord = lang_1.isPresent(directiveRecord) ?
            change_detection_1.BindingRecord.createForHostEvent(ast.handler, ast.fullName, directiveRecord) :
            change_detection_1.BindingRecord.createForEvent(ast.handler, ast.fullName, this.boundElementCount - 1);
        this.eventRecords.push(bindingRecord);
        return null;
    };
    ProtoViewVisitor.prototype.visitElementProperty = function (ast, directiveRecord) {
        var boundElementIndex = this.boundElementCount - 1;
        var dirIndex = lang_1.isPresent(directiveRecord) ? directiveRecord.directiveIndex : null;
        var bindingRecord;
        if (ast.type === template_ast_1.PropertyBindingType.Property) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostProperty(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementProperty(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Attribute) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostAttribute(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementAttribute(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Class) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostClass(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementClass(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Style) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostStyle(dirIndex, ast.value, ast.name, ast.unit) :
                    change_detection_1.BindingRecord.createForElementStyle(ast.value, boundElementIndex, ast.name, ast.unit);
        }
        this.bindingRecords.push(bindingRecord);
        return null;
    };
    ProtoViewVisitor.prototype.visitAttr = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitBoundText = function (ast, context) {
        var boundTextIndex = this.boundTextCount++;
        this.bindingRecords.push(change_detection_1.BindingRecord.createForTextNode(ast.value, boundTextIndex));
        return null;
    };
    ProtoViewVisitor.prototype.visitText = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitDirective = function (ast, directiveIndexAsNumber) {
        var directiveIndex = new change_detection_1.DirectiveIndex(this.boundElementCount - 1, directiveIndexAsNumber);
        var directiveMetadata = ast.directive;
        var directiveRecord = new change_detection_1.DirectiveRecord({
            directiveIndex: directiveIndex,
            callAfterContentInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentInit) !== -1,
            callAfterContentChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentChecked) !== -1,
            callAfterViewInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewInit) !== -1,
            callAfterViewChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewChecked) !== -1,
            callOnChanges: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnChanges) !== -1,
            callDoCheck: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.DoCheck) !== -1,
            callOnInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnInit) !== -1,
            changeDetection: directiveMetadata.changeDetection
        });
        this.directiveRecords.push(directiveRecord);
        template_ast_1.templateVisitAll(this, ast.inputs, directiveRecord);
        var bindingRecords = this.bindingRecords;
        if (directiveRecord.callOnChanges) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnChanges(directiveRecord));
        }
        if (directiveRecord.callOnInit) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnInit(directiveRecord));
        }
        if (directiveRecord.callDoCheck) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveDoCheck(directiveRecord));
        }
        template_ast_1.templateVisitAll(this, ast.hostProperties, directiveRecord);
        template_ast_1.templateVisitAll(this, ast.hostEvents, directiveRecord);
        template_ast_1.templateVisitAll(this, ast.exportAsVars);
        return null;
    };
    ProtoViewVisitor.prototype.visitDirectiveProperty = function (ast, directiveRecord) {
        // TODO: these setters should eventually be created by change detection, to make
        // it monomorphic!
        var setter = reflection_1.reflector.setter(ast.directiveName);
        this.bindingRecords.push(change_detection_1.BindingRecord.createForDirective(ast.value, ast.directiveName, setter, directiveRecord));
        return null;
    };
    return ProtoViewVisitor;
})();
function createChangeDefinitions(pvVisitors, componentType, genConfig) {
    var pvVariableNames = _collectNestedProtoViewsVariableNames(pvVisitors);
    return pvVisitors.map(function (pvVisitor) {
        var id = componentType.name + "_" + pvVisitor.viewIndex;
        return new change_detection_1.ChangeDetectorDefinition(id, pvVisitor.strategy, pvVariableNames[pvVisitor.viewIndex], pvVisitor.bindingRecords, pvVisitor.eventRecords, pvVisitor.directiveRecords, genConfig);
    });
}
function _collectNestedProtoViewsVariableNames(pvVisitors) {
    var nestedPvVariableNames = collection_1.ListWrapper.createFixedSize(pvVisitors.length);
    pvVisitors.forEach(function (pv) {
        var parentVariableNames = lang_1.isPresent(pv.parent) ? nestedPvVariableNames[pv.parent.viewIndex] : [];
        nestedPvVariableNames[pv.viewIndex] = parentVariableNames.concat(pv.variableNames);
    });
    return nestedPvVariableNames;
}

},{"./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var source_module_1 = require('./source_module');
var change_detection_jit_generator_1 = require('angular2/src/core/change_detection/change_detection_jit_generator');
var change_definition_factory_1 = require('./change_definition_factory');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var change_detector_codegen_1 = require('angular2/src/transform/template_compiler/change_detector_codegen');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
var UTIL = "ChangeDetectionUtil";
var ABSTRACT_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/abstract_change_detector" + util_1.MODULE_SUFFIX);
var UTIL_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/change_detection_util" + util_1.MODULE_SUFFIX);
var PREGEN_PROTO_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/pregen_proto_change_detector" + util_1.MODULE_SUFFIX);
var ChangeDetectionCompiler = (function () {
    function ChangeDetectionCompiler(_genConfig) {
        this._genConfig = _genConfig;
    }
    ChangeDetectionCompiler.prototype.compileComponentRuntime = function (componentType, strategy, parsedTemplate) {
        var _this = this;
        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        return changeDetectorDefinitions.map(function (definition) {
            return _this._createChangeDetectorFactory(definition);
        });
    };
    ChangeDetectionCompiler.prototype._createChangeDetectorFactory = function (definition) {
        if (util_1.IS_DART || !this._genConfig.useJit) {
            var proto = new change_detection_1.DynamicProtoChangeDetector(definition);
            return function (dispatcher) { return proto.instantiate(dispatcher); };
        }
        else {
            return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, UTIL, ABSTRACT_CHANGE_DETECTOR).generate();
        }
    };
    ChangeDetectionCompiler.prototype.compileComponentCodeGen = function (componentType, strategy, parsedTemplate) {
        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        var factories = [];
        var index = 0;
        var sourceParts = changeDetectorDefinitions.map(function (definition) {
            var codegen;
            var sourcePart;
            // TODO(tbosch): move the 2 code generators to the same place, one with .dart and one with .ts
            // suffix
            // and have the same API for calling them!
            if (util_1.IS_DART) {
                codegen = new change_detector_codegen_1.Codegen(PREGEN_PROTO_CHANGE_DETECTOR_MODULE);
                var className = definition.id;
                var typeRef = (index === 0 && componentType.isHost) ?
                    'dynamic' :
                    "" + source_module_1.moduleRef(componentType.moduleUrl) + componentType.name;
                codegen.generate(typeRef, className, definition);
                factories.push("(dispatcher) => new " + className + "(dispatcher)");
                sourcePart = codegen.toString();
            }
            else {
                codegen = new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, "" + UTIL_MODULE + UTIL, "" + ABSTRACT_CHANGE_DETECTOR_MODULE + ABSTRACT_CHANGE_DETECTOR);
                factories.push("function(dispatcher) { return new " + codegen.typeName + "(dispatcher); }");
                sourcePart = codegen.generateSource();
            }
            index++;
            return sourcePart;
        });
        return new source_module_1.SourceExpressions(sourceParts, factories);
    };
    ChangeDetectionCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorGenConfig])
    ], ChangeDetectionCompiler);
    return ChangeDetectionCompiler;
})();
exports.ChangeDetectionCompiler = ChangeDetectionCompiler;

},{"./change_definition_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_definition_factory.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/change_detection/change_detection_jit_generator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/transform/template_compiler/change_detector_codegen":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/transform/template_compiler/change_detector_codegen.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
var template_ast_1 = require('./template_ast');
var source_module_1 = require('./source_module');
var view_1 = require('angular2/src/core/metadata/view');
var style_compiler_1 = require('./style_compiler');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
exports.TEMPLATE_COMMANDS_MODULE_REF = source_module_1.moduleRef("package:angular2/src/core/linker/template_commands" + util_1.MODULE_SUFFIX);
var IMPLICIT_TEMPLATE_VAR = '\$implicit';
var CLASS_ATTR = 'class';
var STYLE_ATTR = 'style';
var CommandCompiler = (function () {
    function CommandCompiler() {
    }
    CommandCompiler.prototype.compileComponentRuntime = function (component, appId, templateId, template, changeDetectorFactories, componentTemplateFactory) {
        var visitor = new CommandBuilderVisitor(new RuntimeCommandFactory(component, appId, templateId, componentTemplateFactory, changeDetectorFactories), 0);
        template_ast_1.templateVisitAll(visitor, template);
        return visitor.result;
    };
    CommandCompiler.prototype.compileComponentCodeGen = function (component, appIdExpr, templateIdExpr, template, changeDetectorFactoryExpressions, componentTemplateFactory) {
        var visitor = new CommandBuilderVisitor(new CodegenCommandFactory(component, appIdExpr, templateIdExpr, componentTemplateFactory, changeDetectorFactoryExpressions), 0);
        template_ast_1.templateVisitAll(visitor, template);
        var source = "[" + visitor.result.join(',') + "]";
        return new source_module_1.SourceExpression([], source);
    };
    CommandCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], CommandCompiler);
    return CommandCompiler;
})();
exports.CommandCompiler = CommandCompiler;
var RuntimeCommandFactory = (function () {
    function RuntimeCommandFactory(component, appId, templateId, componentTemplateFactory, changeDetectorFactories) {
        this.component = component;
        this.appId = appId;
        this.templateId = templateId;
        this.componentTemplateFactory = componentTemplateFactory;
        this.changeDetectorFactories = changeDetectorFactories;
    }
    RuntimeCommandFactory.prototype._mapDirectives = function (directives) {
        return directives.map(function (directive) { return directive.type.runtime; });
    };
    RuntimeCommandFactory.prototype._addStyleShimAttributes = function (attrNameAndValues, localComponent, localTemplateId) {
        var additionalStyles = [];
        if (lang_1.isPresent(localComponent) &&
            localComponent.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStyles.push(style_compiler_1.shimHostAttribute(this.appId, localTemplateId));
            additionalStyles.push('');
        }
        if (this.component.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStyles.push(style_compiler_1.shimContentAttribute(this.appId, this.templateId));
            additionalStyles.push('');
        }
        return additionalStyles.concat(attrNameAndValues);
    };
    RuntimeCommandFactory.prototype.createText = function (value, isBound, ngContentIndex) {
        return template_commands_1.text(value, isBound, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createNgContent = function (index, ngContentIndex) {
        return template_commands_1.ngContent(index, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createBeginElement = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        return template_commands_1.beginElement(name, this._addStyleShimAttributes(attrNameAndValues, null, null), eventTargetAndNames, variableNameAndValues, this._mapDirectives(directives), isBound, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createEndElement = function () { return template_commands_1.endElement(); };
    RuntimeCommandFactory.prototype.createBeginComponent = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex) {
        var nestedTemplate = this.componentTemplateFactory(directives[0]);
        return template_commands_1.beginComponent(name, this._addStyleShimAttributes(attrNameAndValues, directives[0], nestedTemplate.id), eventTargetAndNames, variableNameAndValues, this._mapDirectives(directives), nativeShadow, ngContentIndex, nestedTemplate);
    };
    RuntimeCommandFactory.prototype.createEndComponent = function () { return template_commands_1.endComponent(); };
    RuntimeCommandFactory.prototype.createEmbeddedTemplate = function (embeddedTemplateIndex, attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, children) {
        return template_commands_1.embeddedTemplate(attrNameAndValues, variableNameAndValues, this._mapDirectives(directives), isMerged, ngContentIndex, this.changeDetectorFactories[embeddedTemplateIndex], children);
    };
    return RuntimeCommandFactory;
})();
var CodegenCommandFactory = (function () {
    function CodegenCommandFactory(component, appIdExpr, templateIdExpr, componentTemplateFactory, changeDetectorFactoryExpressions) {
        this.component = component;
        this.appIdExpr = appIdExpr;
        this.templateIdExpr = templateIdExpr;
        this.componentTemplateFactory = componentTemplateFactory;
        this.changeDetectorFactoryExpressions = changeDetectorFactoryExpressions;
    }
    CodegenCommandFactory.prototype._addStyleShimAttributes = function (attrNameAndValues, localComponent, localTemplateIdExpr) {
        var additionalStlyes = [];
        if (lang_1.isPresent(localComponent) &&
            localComponent.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStlyes.push(new Expression(style_compiler_1.shimHostAttributeExpr(this.appIdExpr, localTemplateIdExpr)));
            additionalStlyes.push('');
        }
        if (this.component.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStlyes.push(new Expression(style_compiler_1.shimContentAttributeExpr(this.appIdExpr, this.templateIdExpr)));
            additionalStlyes.push('');
        }
        return additionalStlyes.concat(attrNameAndValues);
    };
    CodegenCommandFactory.prototype.createText = function (value, isBound, ngContentIndex) {
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "text(" + util_1.escapeSingleQuoteString(value) + ", " + isBound + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createNgContent = function (index, ngContentIndex) {
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "ngContent(" + index + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createBeginElement = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        var attrsExpression = codeGenArray(this._addStyleShimAttributes(attrNameAndValues, null, null));
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "beginElement(" + util_1.escapeSingleQuoteString(name) + ", " + attrsExpression + ", " + codeGenArray(eventTargetAndNames) + ", " + codeGenArray(variableNameAndValues) + ", " + codeGenDirectivesArray(directives) + ", " + isBound + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createEndElement = function () { return exports.TEMPLATE_COMMANDS_MODULE_REF + "endElement()"; };
    CodegenCommandFactory.prototype.createBeginComponent = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex) {
        var nestedCompExpr = this.componentTemplateFactory(directives[0]);
        var attrsExpression = codeGenArray(this._addStyleShimAttributes(attrNameAndValues, directives[0], nestedCompExpr + ".id"));
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "beginComponent(" + util_1.escapeSingleQuoteString(name) + ", " + attrsExpression + ", " + codeGenArray(eventTargetAndNames) + ", " + codeGenArray(variableNameAndValues) + ", " + codeGenDirectivesArray(directives) + ", " + nativeShadow + ", " + ngContentIndex + ", " + nestedCompExpr + ")";
    };
    CodegenCommandFactory.prototype.createEndComponent = function () { return exports.TEMPLATE_COMMANDS_MODULE_REF + "endComponent()"; };
    CodegenCommandFactory.prototype.createEmbeddedTemplate = function (embeddedTemplateIndex, attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, children) {
        return (exports.TEMPLATE_COMMANDS_MODULE_REF + "embeddedTemplate(" + codeGenArray(attrNameAndValues) + ", " + codeGenArray(variableNameAndValues) + ", ") +
            (codeGenDirectivesArray(directives) + ", " + isMerged + ", " + ngContentIndex + ", " + this.changeDetectorFactoryExpressions[embeddedTemplateIndex] + ", [" + children.join(',') + "])");
    };
    return CodegenCommandFactory;
})();
function visitAndReturnContext(visitor, asts, context) {
    template_ast_1.templateVisitAll(visitor, asts, context);
    return context;
}
var CommandBuilderVisitor = (function () {
    function CommandBuilderVisitor(commandFactory, embeddedTemplateIndex) {
        this.commandFactory = commandFactory;
        this.embeddedTemplateIndex = embeddedTemplateIndex;
        this.result = [];
        this.transitiveNgContentCount = 0;
    }
    CommandBuilderVisitor.prototype._readAttrNameAndValues = function (directives, attrAsts) {
        var attrs = keyValueArrayToMap(visitAndReturnContext(this, attrAsts, []));
        directives.forEach(function (directiveMeta) {
            collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, function (value, name) {
                var prevValue = attrs[name];
                attrs[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
            });
        });
        return mapToKeyValueArray(attrs);
    };
    CommandBuilderVisitor.prototype.visitNgContent = function (ast, context) {
        this.transitiveNgContentCount++;
        this.result.push(this.commandFactory.createNgContent(ast.index, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        var _this = this;
        this.embeddedTemplateIndex++;
        var childVisitor = new CommandBuilderVisitor(this.commandFactory, this.embeddedTemplateIndex);
        template_ast_1.templateVisitAll(childVisitor, ast.children);
        var isMerged = childVisitor.transitiveNgContentCount > 0;
        var variableNameAndValues = [];
        ast.vars.forEach(function (varAst) {
            variableNameAndValues.push(varAst.name);
            variableNameAndValues.push(varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR);
        });
        var directives = [];
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            directiveAst.visit(_this, new DirectiveContext(index, [], [], directives));
        });
        this.result.push(this.commandFactory.createEmbeddedTemplate(this.embeddedTemplateIndex, this._readAttrNameAndValues(directives, ast.attrs), variableNameAndValues, directives, isMerged, ast.ngContentIndex, childVisitor.result));
        this.transitiveNgContentCount += childVisitor.transitiveNgContentCount;
        this.embeddedTemplateIndex = childVisitor.embeddedTemplateIndex;
        return null;
    };
    CommandBuilderVisitor.prototype.visitElement = function (ast, context) {
        var _this = this;
        var component = ast.getComponent();
        var eventTargetAndNames = visitAndReturnContext(this, ast.outputs, []);
        var variableNameAndValues = [];
        if (lang_1.isBlank(component)) {
            ast.exportAsVars.forEach(function (varAst) {
                variableNameAndValues.push(varAst.name);
                variableNameAndValues.push(null);
            });
        }
        var directives = [];
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            directiveAst.visit(_this, new DirectiveContext(index, eventTargetAndNames, variableNameAndValues, directives));
        });
        eventTargetAndNames = removeKeyValueArrayDuplicates(eventTargetAndNames);
        var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
        if (lang_1.isPresent(component)) {
            this.result.push(this.commandFactory.createBeginComponent(ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, component.template.encapsulation === view_1.ViewEncapsulation.Native, ast.ngContentIndex));
            template_ast_1.templateVisitAll(this, ast.children);
            this.result.push(this.commandFactory.createEndComponent());
        }
        else {
            this.result.push(this.commandFactory.createBeginElement(ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, ast.isBound(), ast.ngContentIndex));
            template_ast_1.templateVisitAll(this, ast.children);
            this.result.push(this.commandFactory.createEndElement());
        }
        return null;
    };
    CommandBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
    CommandBuilderVisitor.prototype.visitAttr = function (ast, attrNameAndValues) {
        attrNameAndValues.push(ast.name);
        attrNameAndValues.push(ast.value);
        return null;
    };
    CommandBuilderVisitor.prototype.visitBoundText = function (ast, context) {
        this.result.push(this.commandFactory.createText(null, true, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitText = function (ast, context) {
        this.result.push(this.commandFactory.createText(ast.value, false, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitDirective = function (ast, ctx) {
        ctx.targetDirectives.push(ast.directive);
        template_ast_1.templateVisitAll(this, ast.hostEvents, ctx.eventTargetAndNames);
        ast.exportAsVars.forEach(function (varAst) {
            ctx.targetVariableNameAndValues.push(varAst.name);
            ctx.targetVariableNameAndValues.push(ctx.index);
        });
        return null;
    };
    CommandBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
        eventTargetAndNames.push(ast.target);
        eventTargetAndNames.push(ast.name);
        return null;
    };
    CommandBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
    CommandBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
    return CommandBuilderVisitor;
})();
function removeKeyValueArrayDuplicates(keyValueArray) {
    var knownPairs = new Set();
    var resultKeyValueArray = [];
    for (var i = 0; i < keyValueArray.length; i += 2) {
        var key = keyValueArray[i];
        var value = keyValueArray[i + 1];
        var pairId = key + ":" + value;
        if (!collection_1.SetWrapper.has(knownPairs, pairId)) {
            resultKeyValueArray.push(key);
            resultKeyValueArray.push(value);
            knownPairs.add(pairId);
        }
    }
    return resultKeyValueArray;
}
function keyValueArrayToMap(keyValueArr) {
    var data = {};
    for (var i = 0; i < keyValueArr.length; i += 2) {
        data[keyValueArr[i]] = keyValueArr[i + 1];
    }
    return data;
}
function mapToKeyValueArray(data) {
    var entryArray = [];
    collection_1.StringMapWrapper.forEach(data, function (value, name) { entryArray.push([name, value]); });
    // We need to sort to get a defined output order
    // for tests and for caching generated artifacts...
    collection_1.ListWrapper.sort(entryArray, function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });
    var keyValueArray = [];
    entryArray.forEach(function (entry) {
        keyValueArray.push(entry[0]);
        keyValueArray.push(entry[1]);
    });
    return keyValueArray;
}
function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
        return attrValue1 + " " + attrValue2;
    }
    else {
        return attrValue2;
    }
}
var DirectiveContext = (function () {
    function DirectiveContext(index, eventTargetAndNames, targetVariableNameAndValues, targetDirectives) {
        this.index = index;
        this.eventTargetAndNames = eventTargetAndNames;
        this.targetVariableNameAndValues = targetVariableNameAndValues;
        this.targetDirectives = targetDirectives;
    }
    return DirectiveContext;
})();
var Expression = (function () {
    function Expression(value) {
        this.value = value;
    }
    return Expression;
})();
function escapeValue(value) {
    if (value instanceof Expression) {
        return value.value;
    }
    else if (lang_1.isString(value)) {
        return util_1.escapeSingleQuoteString(value);
    }
    else if (lang_1.isBlank(value)) {
        return 'null';
    }
    else {
        return "" + value;
    }
}
function codeGenArray(data) {
    return "[" + data.map(escapeValue).join(',') + "]";
}
function codeGenDirectivesArray(directives) {
    var expressions = directives.map(function (directiveType) { return ("" + source_module_1.moduleRef(directiveType.type.moduleUrl) + directiveType.type.name); });
    return "[" + expressions.join(',') + "]";
}

},{"./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/compiler.js":[function(require,module,exports){
'use strict';var runtime_compiler_1 = require("./runtime_compiler");
var template_compiler_1 = require('./template_compiler');
exports.TemplateCompiler = template_compiler_1.TemplateCompiler;
var directive_metadata_1 = require('./directive_metadata');
exports.CompileDirectiveMetadata = directive_metadata_1.CompileDirectiveMetadata;
exports.CompileTypeMetadata = directive_metadata_1.CompileTypeMetadata;
exports.CompileTemplateMetadata = directive_metadata_1.CompileTemplateMetadata;
var source_module_1 = require('./source_module');
exports.SourceModule = source_module_1.SourceModule;
exports.SourceWithImports = source_module_1.SourceWithImports;
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var template_parser_1 = require('angular2/src/core/compiler/template_parser');
var html_parser_1 = require('angular2/src/core/compiler/html_parser');
var template_normalizer_1 = require('angular2/src/core/compiler/template_normalizer');
var runtime_metadata_1 = require('angular2/src/core/compiler/runtime_metadata');
var change_detector_compiler_1 = require('angular2/src/core/compiler/change_detector_compiler');
var style_compiler_1 = require('angular2/src/core/compiler/style_compiler');
var command_compiler_1 = require('angular2/src/core/compiler/command_compiler');
var template_compiler_2 = require('angular2/src/core/compiler/template_compiler');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var compiler_1 = require('angular2/src/core/linker/compiler');
var runtime_compiler_2 = require('angular2/src/core/compiler/runtime_compiler');
var element_schema_registry_1 = require('angular2/src/core/compiler/schema/element_schema_registry');
var dom_element_schema_registry_1 = require('angular2/src/core/compiler/schema/dom_element_schema_registry');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var app_root_url_1 = require('angular2/src/core/compiler/app_root_url');
var anchor_based_app_root_url_1 = require('angular2/src/core/compiler/anchor_based_app_root_url');
var change_detection_2 = require('angular2/src/core/change_detection/change_detection');
function compilerProviders() {
    return [
        change_detection_2.Lexer,
        change_detection_2.Parser,
        html_parser_1.HtmlParser,
        template_parser_1.TemplateParser,
        template_normalizer_1.TemplateNormalizer,
        runtime_metadata_1.RuntimeMetadataResolver,
        style_compiler_1.StyleCompiler,
        command_compiler_1.CommandCompiler,
        change_detector_compiler_1.ChangeDetectionCompiler,
        di_1.provide(change_detection_1.ChangeDetectorGenConfig, {
            useValue: new change_detection_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), lang_1.assertionsEnabled(), false, true)
        }),
        template_compiler_2.TemplateCompiler,
        di_1.provide(runtime_compiler_2.RuntimeCompiler, { useClass: runtime_compiler_1.RuntimeCompiler_ }),
        di_1.provide(compiler_1.Compiler, { useExisting: runtime_compiler_2.RuntimeCompiler }),
        dom_element_schema_registry_1.DomElementSchemaRegistry,
        di_1.provide(element_schema_registry_1.ElementSchemaRegistry, { useExisting: dom_element_schema_registry_1.DomElementSchemaRegistry }),
        anchor_based_app_root_url_1.AnchorBasedAppRootUrl,
        di_1.provide(app_root_url_1.AppRootUrl, { useExisting: anchor_based_app_root_url_1.AnchorBasedAppRootUrl }),
        url_resolver_1.UrlResolver
    ];
}
exports.compilerProviders = compilerProviders;

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./runtime_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/anchor_based_app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/anchor_based_app_root_url.js","angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/compiler/change_detector_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js","angular2/src/core/compiler/command_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js","angular2/src/core/compiler/html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","angular2/src/core/compiler/runtime_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js","angular2/src/core/compiler/runtime_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js","angular2/src/core/compiler/schema/dom_element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/dom_element_schema_registry.js","angular2/src/core/compiler/schema/element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/compiler/style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","angular2/src/core/compiler/template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/compiler/template_normalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js","angular2/src/core/compiler/template_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var view_1 = require('angular2/src/core/metadata/view');
var selector_1 = require('angular2/src/core/compiler/selector');
var util_1 = require('./util');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
// group 1: "property" from "[property]"
// group 2: "event" from "(event)"
var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
var CompileTypeMetadata = (function () {
    function CompileTypeMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, runtime = _b.runtime, name = _b.name, moduleUrl = _b.moduleUrl, isHost = _b.isHost;
        this.runtime = runtime;
        this.name = name;
        this.moduleUrl = moduleUrl;
        this.isHost = lang_1.normalizeBool(isHost);
    }
    CompileTypeMetadata.fromJson = function (data) {
        return new CompileTypeMetadata({ name: data['name'], moduleUrl: data['moduleUrl'], isHost: data['isHost'] });
    };
    CompileTypeMetadata.prototype.toJson = function () {
        return {
            // Note: Runtime type can't be serialized...
            'name': this.name,
            'moduleUrl': this.moduleUrl,
            'isHost': this.isHost
        };
    };
    return CompileTypeMetadata;
})();
exports.CompileTypeMetadata = CompileTypeMetadata;
var CompileTemplateMetadata = (function () {
    function CompileTemplateMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, ngContentSelectors = _b.ngContentSelectors;
        this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : view_1.ViewEncapsulation.Emulated;
        this.template = template;
        this.templateUrl = templateUrl;
        this.styles = lang_1.isPresent(styles) ? styles : [];
        this.styleUrls = lang_1.isPresent(styleUrls) ? styleUrls : [];
        this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];
    }
    CompileTemplateMetadata.fromJson = function (data) {
        return new CompileTemplateMetadata({
            encapsulation: lang_1.isPresent(data['encapsulation']) ?
                view_1.VIEW_ENCAPSULATION_VALUES[data['encapsulation']] :
                data['encapsulation'],
            template: data['template'],
            templateUrl: data['templateUrl'],
            styles: data['styles'],
            styleUrls: data['styleUrls'],
            ngContentSelectors: data['ngContentSelectors']
        });
    };
    CompileTemplateMetadata.prototype.toJson = function () {
        return {
            'encapsulation': lang_1.isPresent(this.encapsulation) ? lang_1.serializeEnum(this.encapsulation) : this.encapsulation,
            'template': this.template,
            'templateUrl': this.templateUrl,
            'styles': this.styles,
            'styleUrls': this.styleUrls,
            'ngContentSelectors': this.ngContentSelectors
        };
    };
    return CompileTemplateMetadata;
})();
exports.CompileTemplateMetadata = CompileTemplateMetadata;
var CompileDirectiveMetadata = (function () {
    function CompileDirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, lifecycleHooks = _b.lifecycleHooks, template = _b.template;
        this.type = type;
        this.isComponent = isComponent;
        this.dynamicLoadable = dynamicLoadable;
        this.selector = selector;
        this.exportAs = exportAs;
        this.changeDetection = changeDetection;
        this.inputs = inputs;
        this.outputs = outputs;
        this.hostListeners = hostListeners;
        this.hostProperties = hostProperties;
        this.hostAttributes = hostAttributes;
        this.lifecycleHooks = lifecycleHooks;
        this.template = template;
    }
    CompileDirectiveMetadata.create = function (_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, lifecycleHooks = _b.lifecycleHooks, template = _b.template;
        var hostListeners = {};
        var hostProperties = {};
        var hostAttributes = {};
        if (lang_1.isPresent(host)) {
            collection_1.StringMapWrapper.forEach(host, function (value, key) {
                var matches = lang_1.RegExpWrapper.firstMatch(HOST_REG_EXP, key);
                if (lang_1.isBlank(matches)) {
                    hostAttributes[key] = value;
                }
                else if (lang_1.isPresent(matches[1])) {
                    hostProperties[matches[1]] = value;
                }
                else if (lang_1.isPresent(matches[2])) {
                    hostListeners[matches[2]] = value;
                }
            });
        }
        var inputsMap = {};
        if (lang_1.isPresent(inputs)) {
            inputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                inputsMap[parts[0]] = parts[1];
            });
        }
        var outputsMap = {};
        if (lang_1.isPresent(outputs)) {
            outputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                outputsMap[parts[0]] = parts[1];
            });
        }
        return new CompileDirectiveMetadata({
            type: type,
            isComponent: lang_1.normalizeBool(isComponent),
            dynamicLoadable: lang_1.normalizeBool(dynamicLoadable),
            selector: selector,
            exportAs: exportAs,
            changeDetection: changeDetection,
            inputs: inputsMap,
            outputs: outputsMap,
            hostListeners: hostListeners,
            hostProperties: hostProperties,
            hostAttributes: hostAttributes,
            lifecycleHooks: lang_1.isPresent(lifecycleHooks) ? lifecycleHooks : [], template: template
        });
    };
    CompileDirectiveMetadata.fromJson = function (data) {
        return new CompileDirectiveMetadata({
            isComponent: data['isComponent'],
            dynamicLoadable: data['dynamicLoadable'],
            selector: data['selector'],
            exportAs: data['exportAs'],
            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
            changeDetection: lang_1.isPresent(data['changeDetection']) ?
                change_detection_1.CHANGE_DECTION_STRATEGY_VALUES[data['changeDetection']] :
                data['changeDetection'],
            inputs: data['inputs'],
            outputs: data['outputs'],
            hostListeners: data['hostListeners'],
            hostProperties: data['hostProperties'],
            hostAttributes: data['hostAttributes'],
            lifecycleHooks: data['lifecycleHooks'].map(function (hookValue) { return interfaces_1.LIFECYCLE_HOOKS_VALUES[hookValue]; }),
            template: lang_1.isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) :
                data['template']
        });
    };
    CompileDirectiveMetadata.prototype.toJson = function () {
        return {
            'isComponent': this.isComponent,
            'dynamicLoadable': this.dynamicLoadable,
            'selector': this.selector,
            'exportAs': this.exportAs,
            'type': lang_1.isPresent(this.type) ? this.type.toJson() : this.type,
            'changeDetection': lang_1.isPresent(this.changeDetection) ? lang_1.serializeEnum(this.changeDetection) :
                this.changeDetection,
            'inputs': this.inputs,
            'outputs': this.outputs,
            'hostListeners': this.hostListeners,
            'hostProperties': this.hostProperties,
            'hostAttributes': this.hostAttributes,
            'lifecycleHooks': this.lifecycleHooks.map(function (hook) { return lang_1.serializeEnum(hook); }),
            'template': lang_1.isPresent(this.template) ? this.template.toJson() : this.template
        };
    };
    return CompileDirectiveMetadata;
})();
exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
function createHostComponentMeta(componentType, componentSelector) {
    var template = selector_1.CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
        type: new CompileTypeMetadata({
            runtime: Object,
            name: "Host" + componentType.name,
            moduleUrl: componentType.moduleUrl,
            isHost: true
        }),
        template: new CompileTemplateMetadata({ template: template, templateUrl: '', styles: [], styleUrls: [], ngContentSelectors: [] }),
        changeDetection: change_detection_1.ChangeDetectionStrategy.Default,
        inputs: [],
        outputs: [],
        host: {},
        lifecycleHooks: [],
        isComponent: true,
        dynamicLoadable: false,
        selector: '*'
    });
}
exports.createHostComponentMeta = createHostComponentMeta;

},{"./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/selector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var HtmlTextAst = (function () {
    function HtmlTextAst(value, sourceInfo) {
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    HtmlTextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return HtmlTextAst;
})();
exports.HtmlTextAst = HtmlTextAst;
var HtmlAttrAst = (function () {
    function HtmlAttrAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    HtmlAttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return HtmlAttrAst;
})();
exports.HtmlAttrAst = HtmlAttrAst;
var HtmlElementAst = (function () {
    function HtmlElementAst(name, attrs, children, sourceInfo) {
        this.name = name;
        this.attrs = attrs;
        this.children = children;
        this.sourceInfo = sourceInfo;
    }
    HtmlElementAst.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
    return HtmlElementAst;
})();
exports.HtmlElementAst = HtmlElementAst;
function htmlVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.htmlVisitAll = htmlVisitAll;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var html_ast_1 = require('./html_ast');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var NG_NON_BINDABLE = 'ng-non-bindable';
var HtmlParser = (function () {
    function HtmlParser() {
    }
    HtmlParser.prototype.parse = function (template, sourceInfo) {
        var root = dom_adapter_1.DOM.createTemplate(template);
        return parseChildNodes(root, sourceInfo);
    };
    HtmlParser.prototype.unparse = function (nodes) {
        var visitor = new UnparseVisitor();
        var parts = [];
        html_ast_1.htmlVisitAll(visitor, nodes, parts);
        return parts.join('');
    };
    HtmlParser = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HtmlParser);
    return HtmlParser;
})();
exports.HtmlParser = HtmlParser;
function parseText(text, indexInParent, parentSourceInfo) {
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    var value = dom_adapter_1.DOM.getText(text);
    return new html_ast_1.HtmlTextAst(value, parentSourceInfo + " > #text(" + value + "):nth-child(" + indexInParent + ")");
}
function parseAttr(element, parentSourceInfo, attrName, attrValue) {
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    return new html_ast_1.HtmlAttrAst(attrName, attrValue, parentSourceInfo + "[" + attrName + "=" + attrValue + "]");
}
function parseElement(element, indexInParent, parentSourceInfo) {
    // normalize nodename always as lower case so that following build steps
    // can rely on this
    var nodeName = dom_adapter_1.DOM.nodeName(element).toLowerCase();
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    var sourceInfo = parentSourceInfo + " > " + nodeName + ":nth-child(" + indexInParent + ")";
    var attrs = parseAttrs(element, sourceInfo);
    var childNodes = parseChildNodes(element, sourceInfo);
    return new html_ast_1.HtmlElementAst(nodeName, attrs, childNodes, sourceInfo);
}
function parseAttrs(element, elementSourceInfo) {
    // Note: sort the attributes early in the pipeline to get
    // consistent results throughout the pipeline, as attribute order is not defined
    // in DOM parsers!
    var attrMap = dom_adapter_1.DOM.attributeMap(element);
    var attrList = [];
    attrMap.forEach(function (value, name) { return attrList.push([name, value]); });
    attrList.sort(function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });
    return attrList.map(function (entry) { return parseAttr(element, elementSourceInfo, entry[0], entry[1]); });
}
function parseChildNodes(element, parentSourceInfo) {
    var root = dom_adapter_1.DOM.templateAwareRoot(element);
    var childNodes = dom_adapter_1.DOM.childNodesAsList(root);
    var result = [];
    var index = 0;
    childNodes.forEach(function (childNode) {
        var childResult = null;
        if (dom_adapter_1.DOM.isTextNode(childNode)) {
            var text = childNode;
            childResult = parseText(text, index, parentSourceInfo);
        }
        else if (dom_adapter_1.DOM.isElementNode(childNode)) {
            var el = childNode;
            childResult = parseElement(el, index, parentSourceInfo);
        }
        if (lang_1.isPresent(childResult)) {
            // Won't have a childResult for e.g. comment nodes
            result.push(childResult);
        }
        index++;
    });
    return result;
}
var UnparseVisitor = (function () {
    function UnparseVisitor() {
    }
    UnparseVisitor.prototype.visitElement = function (ast, parts) {
        parts.push("<" + ast.name);
        var attrs = [];
        html_ast_1.htmlVisitAll(this, ast.attrs, attrs);
        if (ast.attrs.length > 0) {
            parts.push(' ');
            parts.push(attrs.join(' '));
        }
        parts.push(">");
        html_ast_1.htmlVisitAll(this, ast.children, parts);
        parts.push("</" + ast.name + ">");
        return null;
    };
    UnparseVisitor.prototype.visitAttr = function (ast, parts) {
        parts.push(ast.name + "=" + util_1.escapeDoubleQuoteString(ast.value));
        return null;
    };
    UnparseVisitor.prototype.visitText = function (ast, parts) {
        parts.push(ast.value);
        return null;
    };
    return UnparseVisitor;
})();

},{"./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var compiler_1 = require('angular2/src/core/linker/compiler');
var proto_view_factory_1 = require('angular2/src/core/linker/proto_view_factory');
var template_compiler_1 = require('./template_compiler');
var di_1 = require('angular2/src/core/di');
var RuntimeCompiler = (function (_super) {
    __extends(RuntimeCompiler, _super);
    function RuntimeCompiler() {
        _super.apply(this, arguments);
    }
    return RuntimeCompiler;
})(compiler_1.Compiler);
exports.RuntimeCompiler = RuntimeCompiler;
var RuntimeCompiler_ = (function (_super) {
    __extends(RuntimeCompiler_, _super);
    function RuntimeCompiler_(_protoViewFactory, _templateCompiler) {
        _super.call(this, _protoViewFactory);
        this._templateCompiler = _templateCompiler;
    }
    RuntimeCompiler_.prototype.compileInHost = function (componentType) {
        var _this = this;
        return this._templateCompiler.compileHostComponentRuntime(componentType)
            .then(function (compiledHostTemplate) { return compiler_1.internalCreateProtoView(_this, compiledHostTemplate); });
    };
    RuntimeCompiler_.prototype.clearCache = function () {
        _super.prototype.clearCache.call(this);
        this._templateCompiler.clearCache();
    };
    RuntimeCompiler_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [proto_view_factory_1.ProtoViewFactory, template_compiler_1.TemplateCompiler])
    ], RuntimeCompiler_);
    return RuntimeCompiler_;
})(compiler_1.Compiler_);
exports.RuntimeCompiler_ = RuntimeCompiler_;

},{"./template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var cpl = require('./directive_metadata');
var dirAnn = require('angular2/src/core/metadata/directives');
var directive_resolver_1 = require('angular2/src/core/linker/directive_resolver');
var view_resolver_1 = require('angular2/src/core/linker/view_resolver');
var directive_lifecycle_reflector_1 = require('angular2/src/core/linker/directive_lifecycle_reflector');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var di_2 = require('angular2/src/core/di');
var util_1 = require('./util');
// group 1: "property" from "[property]"
// group 2: "event" from "(event)"
var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
var RuntimeMetadataResolver = (function () {
    function RuntimeMetadataResolver(_directiveResolver, _viewResolver) {
        this._directiveResolver = _directiveResolver;
        this._viewResolver = _viewResolver;
        this._cache = new Map();
    }
    RuntimeMetadataResolver.prototype.getMetadata = function (directiveType) {
        var meta = this._cache.get(directiveType);
        if (lang_1.isBlank(meta)) {
            var directiveAnnotation = this._directiveResolver.resolve(directiveType);
            var moduleUrl = calcModuleUrl(directiveType, directiveAnnotation);
            var templateMeta = null;
            var changeDetectionStrategy = null;
            if (directiveAnnotation instanceof dirAnn.ComponentMetadata) {
                var compAnnotation = directiveAnnotation;
                var viewAnnotation = this._viewResolver.resolve(directiveType);
                templateMeta = new cpl.CompileTemplateMetadata({
                    encapsulation: viewAnnotation.encapsulation,
                    template: viewAnnotation.template,
                    templateUrl: viewAnnotation.templateUrl,
                    styles: viewAnnotation.styles,
                    styleUrls: viewAnnotation.styleUrls
                });
                changeDetectionStrategy = compAnnotation.changeDetection;
            }
            meta = cpl.CompileDirectiveMetadata.create({
                selector: directiveAnnotation.selector,
                exportAs: directiveAnnotation.exportAs,
                isComponent: lang_1.isPresent(templateMeta),
                dynamicLoadable: true,
                type: new cpl.CompileTypeMetadata({ name: lang_1.stringify(directiveType), moduleUrl: moduleUrl, runtime: directiveType }),
                template: templateMeta,
                changeDetection: changeDetectionStrategy,
                inputs: directiveAnnotation.inputs,
                outputs: directiveAnnotation.outputs,
                host: directiveAnnotation.host,
                lifecycleHooks: collection_1.ListWrapper.filter(interfaces_1.LIFECYCLE_HOOKS_VALUES, function (hook) { return directive_lifecycle_reflector_1.hasLifecycleHook(hook, directiveType); })
            });
            this._cache.set(directiveType, meta);
        }
        return meta;
    };
    RuntimeMetadataResolver.prototype.getViewDirectivesMetadata = function (component) {
        var _this = this;
        var view = this._viewResolver.resolve(component);
        var directives = flattenDirectives(view);
        for (var i = 0; i < directives.length; i++) {
            if (!isValidDirective(directives[i])) {
                throw new exceptions_1.BaseException("Unexpected directive value '" + lang_1.stringify(directives[i]) + "' on the View of component '" + lang_1.stringify(component) + "'");
            }
        }
        return removeDuplicatedDirectives(directives.map(function (type) { return _this.getMetadata(type); }));
    };
    RuntimeMetadataResolver = __decorate([
        di_2.Injectable(), 
        __metadata('design:paramtypes', [directive_resolver_1.DirectiveResolver, view_resolver_1.ViewResolver])
    ], RuntimeMetadataResolver);
    return RuntimeMetadataResolver;
})();
exports.RuntimeMetadataResolver = RuntimeMetadataResolver;
function removeDuplicatedDirectives(directives) {
    var directivesMap = new Map();
    directives.forEach(function (dirMeta) { directivesMap.set(dirMeta.type.runtime, dirMeta); });
    return collection_1.MapWrapper.values(directivesMap);
}
function flattenDirectives(view) {
    if (lang_1.isBlank(view.directives))
        return [];
    var directives = [];
    flattenList(view.directives, directives);
    return directives;
}
function flattenList(tree, out) {
    for (var i = 0; i < tree.length; i++) {
        var item = di_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
            flattenList(item, out);
        }
        else {
            out.push(item);
        }
    }
}
function isValidDirective(value) {
    return lang_1.isPresent(value) && (value instanceof lang_1.Type);
}
function calcModuleUrl(type, directiveAnnotation) {
    if (lang_1.isPresent(directiveAnnotation.moduleId)) {
        return "package:" + directiveAnnotation.moduleId + util_1.MODULE_SUFFIX;
    }
    else {
        return reflection_1.reflector.importUri(type);
    }
}

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/directive_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js","angular2/src/core/linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/linker/view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/src/core/metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/dom_element_schema_registry.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var element_schema_registry_1 = require('./element_schema_registry');
var DomElementSchemaRegistry = (function (_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
        _super.apply(this, arguments);
        this._protoElements = new Map();
    }
    DomElementSchemaRegistry.prototype._getProtoElement = function (tagName) {
        var element = this._protoElements.get(tagName);
        if (lang_1.isBlank(element)) {
            element = dom_adapter_1.DOM.createElement(tagName);
            this._protoElements.set(tagName, element);
        }
        return element;
    };
    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) {
        if (tagName.indexOf('-') !== -1) {
            // can't tell now as we don't know which properties a custom element will get
            // once it is instantiated
            return true;
        }
        else {
            var elm = this._getProtoElement(tagName);
            return dom_adapter_1.DOM.hasProperty(elm, propName);
        }
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {
        var mappedPropName = collection_1.StringMapWrapper.get(dom_adapter_1.DOM.attrToPropMap, propName);
        return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;
    };
    DomElementSchemaRegistry = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DomElementSchemaRegistry);
    return DomElementSchemaRegistry;
})(element_schema_registry_1.ElementSchemaRegistry);
exports.DomElementSchemaRegistry = DomElementSchemaRegistry;

},{"./element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js":[function(require,module,exports){
'use strict';var ElementSchemaRegistry = (function () {
    function ElementSchemaRegistry() {
    }
    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) { return true; };
    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return propName; };
    return ElementSchemaRegistry;
})();
exports.ElementSchemaRegistry = ElementSchemaRegistry;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var _EMPTY_ATTR_VALUE = '';
// TODO: Can't use `const` here as
// in Dart this is not transpiled into `final` yet...
var _SELECTOR_REGEXP = lang_1.RegExpWrapper.create('(\\:not\\()|' +
    '([-\\w]+)|' +
    '(?:\\.([-\\w]+))|' +
    '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
    '(\\))|' +
    '(\\s*,\\s*)'); // ","
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
var CssSelector = (function () {
    function CssSelector() {
        this.element = null;
        this.classNames = [];
        this.attrs = [];
        this.notSelectors = [];
    }
    CssSelector.parse = function (selector) {
        var results = [];
        var _addResult = function (res, cssSel) {
            if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) &&
                collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
            }
            res.push(cssSel);
        };
        var cssSelector = new CssSelector();
        var matcher = lang_1.RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
        var match;
        var current = cssSelector;
        var inNot = false;
        while (lang_1.isPresent(match = lang_1.RegExpMatcherWrapper.next(matcher))) {
            if (lang_1.isPresent(match[1])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');
                }
                inNot = true;
                current = new CssSelector();
                cssSelector.notSelectors.push(current);
            }
            if (lang_1.isPresent(match[2])) {
                current.setElement(match[2]);
            }
            if (lang_1.isPresent(match[3])) {
                current.addClassName(match[3]);
            }
            if (lang_1.isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
            }
            if (lang_1.isPresent(match[6])) {
                inNot = false;
                current = cssSelector;
            }
            if (lang_1.isPresent(match[7])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');
                }
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
            }
        }
        _addResult(results, cssSelector);
        return results;
    };
    CssSelector.prototype.isElementSelector = function () {
        return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) &&
            collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
    };
    CssSelector.prototype.setElement = function (element) {
        if (element === void 0) { element = null; }
        if (lang_1.isPresent(element)) {
            element = element.toLowerCase();
        }
        this.element = element;
    };
    /** Gets a template string for an element that matches the selector. */
    CssSelector.prototype.getMatchingElementTemplate = function () {
        var tagName = lang_1.isPresent(this.element) ? this.element : 'div';
        var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
        var attrs = '';
        for (var i = 0; i < this.attrs.length; i += 2) {
            var attrName = this.attrs[i];
            var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
            attrs += " " + attrName + attrValue;
        }
        return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function (name, value) {
        if (value === void 0) { value = _EMPTY_ATTR_VALUE; }
        this.attrs.push(name.toLowerCase());
        if (lang_1.isPresent(value)) {
            value = value.toLowerCase();
        }
        else {
            value = _EMPTY_ATTR_VALUE;
        }
        this.attrs.push(value);
    };
    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
    CssSelector.prototype.toString = function () {
        var res = '';
        if (lang_1.isPresent(this.element)) {
            res += this.element;
        }
        if (lang_1.isPresent(this.classNames)) {
            for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
            }
        }
        if (lang_1.isPresent(this.attrs)) {
            for (var i = 0; i < this.attrs.length;) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                    res += '=' + attrValue;
                }
                res += ']';
            }
        }
        this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
        return res;
    };
    return CssSelector;
})();
exports.CssSelector = CssSelector;
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
var SelectorMatcher = (function () {
    function SelectorMatcher() {
        this._elementMap = new collection_1.Map();
        this._elementPartialMap = new collection_1.Map();
        this._classMap = new collection_1.Map();
        this._classPartialMap = new collection_1.Map();
        this._attrValueMap = new collection_1.Map();
        this._attrValuePartialMap = new collection_1.Map();
        this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function (notSelectors) {
        var notMatcher = new SelectorMatcher();
        notMatcher.addSelectables(notSelectors, null);
        return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
        var listContext = null;
        if (cssSelectors.length > 1) {
            listContext = new SelectorListContext(cssSelectors);
            this._listContexts.push(listContext);
        }
        for (var i = 0; i < cssSelectors.length; i++) {
            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
        }
    };
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
        var matcher = this;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
        if (lang_1.isPresent(element)) {
            var isTerminal = attrs.length === 0 && classNames.length === 0;
            if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
            }
            else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
            }
        }
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                    this._addTerminal(matcher._classMap, className, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._classPartialMap, className);
                }
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                if (isTerminal) {
                    var terminalMap = matcher._attrValueMap;
                    var terminalValuesMap = terminalMap.get(attrName);
                    if (lang_1.isBlank(terminalValuesMap)) {
                        terminalValuesMap = new collection_1.Map();
                        terminalMap.set(attrName, terminalValuesMap);
                    }
                    this._addTerminal(terminalValuesMap, attrValue, selectable);
                }
                else {
                    var parttialMap = matcher._attrValuePartialMap;
                    var partialValuesMap = parttialMap.get(attrName);
                    if (lang_1.isBlank(partialValuesMap)) {
                        partialValuesMap = new collection_1.Map();
                        parttialMap.set(attrName, partialValuesMap);
                    }
                    matcher = this._addPartial(partialValuesMap, attrValue);
                }
            }
        }
    };
    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
        var terminalList = map.get(name);
        if (lang_1.isBlank(terminalList)) {
            terminalList = [];
            map.set(name, terminalList);
        }
        terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function (map, name) {
        var matcher = map.get(name);
        if (lang_1.isBlank(matcher)) {
            matcher = new SelectorMatcher();
            map.set(name, matcher);
        }
        return matcher;
    };
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
        var result = false;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        for (var i = 0; i < this._listContexts.length; i++) {
            this._listContexts[i].alreadyMatched = false;
        }
        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
            result;
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result =
                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result =
                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                        result;
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var terminalValuesMap = this._attrValueMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) ||
                    result;
                var partialValuesMap = this._attrValuePartialMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result =
                    this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
            }
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var selectables = map.get(name);
        var starSelectables = map.get("*");
        if (lang_1.isPresent(starSelectables)) {
            selectables = selectables.concat(starSelectables);
        }
        if (lang_1.isBlank(selectables)) {
            return false;
        }
        var selectable;
        var result = false;
        for (var index = 0; index < selectables.length; index++) {
            selectable = selectables[index];
            result = selectable.finalize(cssSelector, matchedCallback) || result;
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback /*: (c: CssSelector, a: any) => void*/) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var nestedSelector = map.get(name);
        if (lang_1.isBlank(nestedSelector)) {
            return false;
        }
        // TODO(perf): get rid of recursion and measure again
        // TODO(perf): don't pass the whole selector into the recursion,
        // but only the not processed parts
        return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
})();
exports.SelectorMatcher = SelectorMatcher;
var SelectorListContext = (function () {
    function SelectorListContext(selectors) {
        this.selectors = selectors;
        this.alreadyMatched = false;
    }
    return SelectorListContext;
})();
exports.SelectorListContext = SelectorListContext;
// Store context to pass back selector and context when a selector is matched
var SelectorContext = (function () {
    function SelectorContext(selector, cbContext, listContext) {
        this.selector = selector;
        this.cbContext = cbContext;
        this.listContext = listContext;
        this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function (cssSelector, callback) {
        var result = true;
        if (this.notSelectors.length > 0 &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
            result = !notMatcher.match(cssSelector, null);
        }
        if (result && lang_1.isPresent(callback) &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            if (lang_1.isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
            }
            callback(this.selector, this.cbContext);
        }
        return result;
    };
    return SelectorContext;
})();
exports.SelectorContext = SelectorContext;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/shadow_css.js":[function(require,module,exports){
'use strict';var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */
/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsultion: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to imlement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/
var ShadowCss = (function () {
    function ShadowCss() {
        this.strictStyling = true;
    }
    /*
    * Shim a style element with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    */
    ShadowCss.prototype.shimStyle = function (style, selector, hostSelector) {
        if (hostSelector === void 0) { hostSelector = ''; }
        var cssText = dom_adapter_1.DOM.getText(style);
        return this.shimCssText(cssText, selector, hostSelector);
    };
    /*
    * Shim some cssText with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    *
    * When strictStyling is true:
    * - selector is the attribute added to all elements inside the host,
    * - hostSelector is the attribute added to the host itself.
    */
    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
        if (hostSelector === void 0) { hostSelector = ''; }
        cssText = this._insertDirectives(cssText);
        return this._scopeCssText(cssText, selector, hostSelector);
    };
    /** @internal */
    ShadowCss.prototype._insertDirectives = function (cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
    };
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
    **/
    /** @internal */
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) { return m[1] + '{'; });
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
    **/
    /** @internal */
    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[1], '');
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            return m[3] + rule;
        });
    };
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
    */
    /** @internal */
    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
        var _this = this;
        var unscoped = this._extractUnscopedRulesFromCssText(cssText);
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (lang_1.isPresent(scopeSelector)) {
            _withCssRules(cssText, function (rules) { cssText = _this._scopeRules(rules, scopeSelector, hostSelector); });
        }
        cssText = cssText + '\n' + unscoped;
        return cssText.trim();
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
    **/
    /** @internal */
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        var r = '', m;
        var matcher = lang_1.RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
        while (lang_1.isPresent(m = lang_1.RegExpMatcherWrapper.next(matcher))) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);
            r += rule + '\n\n';
        }
        return r;
    };
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar
    */
    /** @internal */
    ShadowCss.prototype._convertColonHost = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar, .foo scopeName > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * scopeName.foo .bar { ... }
    */
    /** @internal */
    ShadowCss.prototype._convertColonHostContext = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    /** @internal */
    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
        // p1 = :host, p2 = contents of (), p3 rest of rule
        return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function (m) {
            if (lang_1.isPresent(m[2])) {
                var parts = m[2].split(','), r = [];
                for (var i = 0; i < parts.length; i++) {
                    var p = parts[i];
                    if (lang_1.isBlank(p))
                        break;
                    p = p.trim();
                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    };
    /** @internal */
    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
        if (lang_1.StringWrapper.contains(part, _polyfillHost)) {
            return this._colonHostPartReplacer(host, part, suffix);
        }
        else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
        }
    };
    /** @internal */
    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
        return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;
    };
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
    */
    /** @internal */
    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
            cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
        }
        return cssText;
    };
    // change a selector like 'div' to 'name div'
    /** @internal */
    ShadowCss.prototype._scopeRules = function (cssRules, scopeSelector, hostSelector) {
        var cssText = '';
        if (lang_1.isPresent(cssRules)) {
            for (var i = 0; i < cssRules.length; i++) {
                var rule = cssRules[i];
                if (dom_adapter_1.DOM.isStyleRule(rule) || dom_adapter_1.DOM.isPageRule(rule)) {
                    cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) +
                        ' {\n';
                    cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                }
                else if (dom_adapter_1.DOM.isMediaRule(rule)) {
                    cssText += '@media ' + rule.media.mediaText + ' {\n';
                    cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                    cssText += '\n}\n\n';
                }
                else {
                    // KEYFRAMES_RULE in IE throws when we query cssText
                    // when it contains a -webkit- property.
                    // if this happens, we fallback to constructing the rule
                    // from the CSSRuleSet
                    // https://connect.microsoft.com/IE/feedbackdetail/view/955703/accessing-csstext-of-a-keyframe-rule-that-contains-a-webkit-property-via-cssom-generates-exception
                    try {
                        if (lang_1.isPresent(rule.cssText)) {
                            cssText += rule.cssText + '\n\n';
                        }
                    }
                    catch (x) {
                        if (dom_adapter_1.DOM.isKeyframesRule(rule) && lang_1.isPresent(rule.cssRules)) {
                            cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                        }
                    }
                }
            }
        }
        return cssText;
    };
    /** @internal */
    ShadowCss.prototype._ieSafeCssTextFromKeyFrameRule = function (rule) {
        var cssText = '@keyframes ' + rule.name + ' {';
        for (var i = 0; i < rule.cssRules.length; i++) {
            var r = rule.cssRules[i];
            cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
        }
        cssText += ' }';
        return cssText;
    };
    /** @internal */
    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
        var r = [], parts = selector.split(',');
        for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            p = p.trim();
            if (this._selectorNeedsScoping(p, scopeSelector)) {
                p = strict && !lang_1.StringWrapper.contains(p, _polyfillHostNoCombinator) ?
                    this._applyStrictSelectorScope(p, scopeSelector) :
                    this._applySelectorScope(p, scopeSelector, hostSelector);
            }
            r.push(p);
        }
        return r.join(', ');
    };
    /** @internal */
    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
        var re = this._makeScopeMatcher(scopeSelector);
        return !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(re, selector));
    };
    /** @internal */
    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
        var lre = /\[/g;
        var rre = /\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\[');
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\]');
        return lang_1.RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    /** @internal */
    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
        // Difference from webcomponentsjs: scopeSelector could not be an array
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    // scope via name and [is=name]
    /** @internal */
    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
        if (lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
            var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
            selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
            return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
        }
        else {
            return scopeSelector + ' ' + selector;
        }
    };
    // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]
    /** @internal */
    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector) {
        var isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) { return m[1]; });
        var splits = [' ', '>', '+', '~'], scoped = selector, attrName = '[' + scopeSelector + ']';
        for (var i = 0; i < splits.length; i++) {
            var sep = splits[i];
            var parts = scoped.split(sep);
            scoped = parts.map(function (p) {
                // remove :host since it should be unnecessary
                var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) &&
                    !lang_1.StringWrapper.contains(t, attrName)) {
                    var re = /([^:]*)(:*)(.*)/g;
                    var m = lang_1.RegExpWrapper.firstMatch(re, t);
                    if (lang_1.isPresent(m)) {
                        p = m[1] + attrName + m[2] + m[3];
                    }
                }
                return p;
            })
                .join(sep);
        }
        return scoped;
    };
    /** @internal */
    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
        return selector;
    };
    /** @internal */
    ShadowCss.prototype._propertiesFromRule = function (rule) {
        var cssText = rule.style.cssText;
        // TODO(sorvell): Safari cssom incorrectly removes quotes from the content
        // property. (https://bugs.webkit.org/show_bug.cgi?id=118045)
        // don't replace attr rules
        var attrRe = /['"]+|attr/g;
        if (rule.style.content.length > 0 &&
            !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
            var contentRe = /content:[^;]*;/g;
            cssText =
                lang_1.StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
        }
        // TODO(sorvell): we can workaround this issue here, but we need a list
        // of troublesome properties to fix https://github.com/Polymer/platform/issues/53
        //
        // inherit rules can be omitted from cssText
        // TODO(sorvell): remove when Blink bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=358273
        // var style = rule.style;
        // for (var i = 0; i < style.length; i++) {
        //  var name = style.item(i);
        //  var value = style.getPropertyValue(name);
        //  if (value == 'initial') {
        //    cssText += name + ': initial; ';
        //  }
        //}
        return cssText;
    };
    return ShadowCss;
})();
exports.ShadowCss = ShadowCss;
var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _polyfillHost = '-shadowcsshost';
// note: :host-context pre-processed to -shadowcsshostcontext.
var _polyfillHostContext = '-shadowcsscontext';
var _parenSuffix = ')(?:\\((' +
    '(?:\\([^)(]*\\)|[^)(]*)+?' +
    ')\\))?([^,{]*)';
var _cssColonHostRe = lang_1.RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
var _cssColonHostContextRe = lang_1.RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
var _shadowDOMSelectorsRe = [
    />>>/g,
    /::shadow/g,
    /::content/g,
    // Deprecated selectors
    // TODO(vicb): see https://github.com/angular/clang-format/issues/16
    // clang-format off
    /\/deep\//g,
    /\/shadow-deep\//g,
    /\/shadow\//g,
];
var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
var _polyfillHostRe = lang_1.RegExpWrapper.create(_polyfillHost, 'im');
var _colonHostRe = /:host/gim;
var _colonHostContextRe = /:host-context/gim;
function _cssToRules(cssText) {
    return dom_adapter_1.DOM.cssToRules(cssText);
}
function _withCssRules(cssText, callback) {
    // Difference from webcomponentjs: remove the workaround for an old bug in Chrome
    if (lang_1.isBlank(callback))
        return;
    var rules = _cssToRules(cssText);
    callback(rules);
}

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var MODULE_REGEXP = /#MODULE\[([^\]]*)\]/g;
function moduleRef(moduleUrl) {
    return "#MODULE[" + moduleUrl + "]";
}
exports.moduleRef = moduleRef;
var SourceModule = (function () {
    function SourceModule(moduleUrl, sourceWithModuleRefs) {
        this.moduleUrl = moduleUrl;
        this.sourceWithModuleRefs = sourceWithModuleRefs;
    }
    SourceModule.prototype.getSourceWithImports = function () {
        var _this = this;
        var moduleAliases = {};
        var imports = [];
        var newSource = lang_1.StringWrapper.replaceAllMapped(this.sourceWithModuleRefs, MODULE_REGEXP, function (match) {
            var moduleUrl = match[1];
            var alias = moduleAliases[moduleUrl];
            if (lang_1.isBlank(alias)) {
                if (moduleUrl == _this.moduleUrl) {
                    alias = '';
                }
                else {
                    alias = "import" + imports.length;
                    imports.push([moduleUrl, alias]);
                }
                moduleAliases[moduleUrl] = alias;
            }
            return alias.length > 0 ? alias + "." : '';
        });
        return new SourceWithImports(newSource, imports);
    };
    return SourceModule;
})();
exports.SourceModule = SourceModule;
var SourceExpression = (function () {
    function SourceExpression(declarations, expression) {
        this.declarations = declarations;
        this.expression = expression;
    }
    return SourceExpression;
})();
exports.SourceExpression = SourceExpression;
var SourceExpressions = (function () {
    function SourceExpressions(declarations, expressions) {
        this.declarations = declarations;
        this.expressions = expressions;
    }
    return SourceExpressions;
})();
exports.SourceExpressions = SourceExpressions;
var SourceWithImports = (function () {
    function SourceWithImports(source, imports) {
        this.source = source;
        this.imports = imports;
    }
    return SourceWithImports;
})();
exports.SourceWithImports = SourceWithImports;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var source_module_1 = require('./source_module');
var view_1 = require('angular2/src/core/metadata/view');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var shadow_css_1 = require('angular2/src/core/compiler/shadow_css');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var COMPONENT_VARIABLE = '%COMP%';
var COMPONENT_REGEX = /%COMP%/g;
var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
var HOST_ATTR_EXPR = "'_nghost-'+" + COMPONENT_VARIABLE;
var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
var CONTENT_ATTR_EXPR = "'_ngcontent-'+" + COMPONENT_VARIABLE;
var StyleCompiler = (function () {
    function StyleCompiler(_xhr, _urlResolver) {
        this._xhr = _xhr;
        this._urlResolver = _urlResolver;
        this._styleCache = new Map();
        this._shadowCss = new shadow_css_1.ShadowCss();
    }
    StyleCompiler.prototype.compileComponentRuntime = function (appId, templateId, template) {
        var styles = template.styles;
        var styleAbsUrls = template.styleUrls;
        return this._loadStyles(styles, styleAbsUrls, template.encapsulation === view_1.ViewEncapsulation.Emulated)
            .then(function (styles) { return styles.map(function (style) { return lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, componentId(appId, templateId)); }); });
    };
    StyleCompiler.prototype.compileComponentCodeGen = function (appIdExpression, templateIdExpression, template) {
        var shim = template.encapsulation === view_1.ViewEncapsulation.Emulated;
        var suffix;
        if (shim) {
            suffix = util_1.codeGenMapArray(['style'], "style" + util_1.codeGenReplaceAll(COMPONENT_VARIABLE, componentIdExpression(appIdExpression, templateIdExpression)));
        }
        else {
            suffix = '';
        }
        return this._styleCodeGen(template.styles, template.styleUrls, shim, suffix);
    };
    StyleCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {
        var styleWithImports = style_url_resolver_1.resolveStyleUrls(this._urlResolver, stylesheetUrl, cssText);
        return [
            this._styleModule(stylesheetUrl, false, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, false, '')),
            this._styleModule(stylesheetUrl, true, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, true, ''))
        ];
    };
    StyleCompiler.prototype.clearCache = function () { this._styleCache.clear(); };
    StyleCompiler.prototype._loadStyles = function (plainStyles, absUrls, encapsulate) {
        var _this = this;
        var promises = absUrls.map(function (absUrl) {
            var cacheKey = "" + absUrl + (encapsulate ? '.shim' : '');
            var result = _this._styleCache.get(cacheKey);
            if (lang_1.isBlank(result)) {
                result = _this._xhr.get(absUrl).then(function (style) {
                    var styleWithImports = style_url_resolver_1.resolveStyleUrls(_this._urlResolver, absUrl, style);
                    return _this._loadStyles([styleWithImports.style], styleWithImports.styleUrls, encapsulate);
                });
                _this._styleCache.set(cacheKey, result);
            }
            return result;
        });
        return async_1.PromiseWrapper.all(promises).then(function (nestedStyles) {
            var result = plainStyles.map(function (plainStyle) { return _this._shimIfNeeded(plainStyle, encapsulate); });
            nestedStyles.forEach(function (styles) { return styles.forEach(function (style) { return result.push(style); }); });
            return result;
        });
    };
    StyleCompiler.prototype._styleCodeGen = function (plainStyles, absUrls, shim, suffix) {
        var _this = this;
        var expressionSource = "(";
        expressionSource +=
            "[" + plainStyles.map(function (plainStyle) { return util_1.escapeSingleQuoteString(_this._shimIfNeeded(plainStyle, shim)); }).join(',') + "]";
        for (var i = 0; i < absUrls.length; i++) {
            var moduleUrl = this._createModuleUrl(absUrls[i], shim);
            expressionSource += util_1.codeGenConcatArray(source_module_1.moduleRef(moduleUrl) + "STYLES");
        }
        expressionSource += ")" + suffix;
        return new source_module_1.SourceExpression([], expressionSource);
    };
    StyleCompiler.prototype._styleModule = function (stylesheetUrl, shim, expression) {
        var moduleSource = "\n      " + expression.declarations.join('\n') + "\n      " + util_1.codeGenExportVariable('STYLES') + expression.expression + ";\n    ";
        return new source_module_1.SourceModule(this._createModuleUrl(stylesheetUrl, shim), moduleSource);
    };
    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
    };
    StyleCompiler.prototype._createModuleUrl = function (stylesheetUrl, shim) {
        return shim ? stylesheetUrl + ".shim" + util_1.MODULE_SUFFIX : "" + stylesheetUrl + util_1.MODULE_SUFFIX;
    };
    StyleCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver])
    ], StyleCompiler);
    return StyleCompiler;
})();
exports.StyleCompiler = StyleCompiler;
function shimContentAttribute(appId, templateId) {
    return lang_1.StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentId(appId, templateId));
}
exports.shimContentAttribute = shimContentAttribute;
function shimContentAttributeExpr(appIdExpr, templateIdExpr) {
    return lang_1.StringWrapper.replaceAll(CONTENT_ATTR_EXPR, COMPONENT_REGEX, componentIdExpression(appIdExpr, templateIdExpr));
}
exports.shimContentAttributeExpr = shimContentAttributeExpr;
function shimHostAttribute(appId, templateId) {
    return lang_1.StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentId(appId, templateId));
}
exports.shimHostAttribute = shimHostAttribute;
function shimHostAttributeExpr(appIdExpr, templateIdExpr) {
    return lang_1.StringWrapper.replaceAll(HOST_ATTR_EXPR, COMPONENT_REGEX, componentIdExpression(appIdExpr, templateIdExpr));
}
exports.shimHostAttributeExpr = shimHostAttributeExpr;
function componentId(appId, templateId) {
    return appId + "-" + templateId;
}
function componentIdExpression(appIdExpression, templateIdExpression) {
    return appIdExpression + "+'-'+" + util_1.codeGenToString(templateIdExpression);
}

},{"./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/compiler/shadow_css":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/shadow_css.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js":[function(require,module,exports){
'use strict';// Some of the code comes from WebComponents.JS
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Rewrites URLs by resolving '@import' and 'url()' URLs from the given base URL,
 * removes and returns the @import urls
 */
function resolveStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    cssText = extractUrls(resolver, baseUrl, cssText, foundUrls);
    cssText = replaceUrls(resolver, baseUrl, cssText);
    return new StyleWithImports(cssText, foundUrls);
}
exports.resolveStyleUrls = resolveStyleUrls;
var StyleWithImports = (function () {
    function StyleWithImports(style, styleUrls) {
        this.style = style;
        this.styleUrls = styleUrls;
    }
    return StyleWithImports;
})();
exports.StyleWithImports = StyleWithImports;
function extractUrls(resolver, baseUrl, cssText, foundUrls) {
    return lang_1.StringWrapper.replaceAllMapped(cssText, _cssImportRe, function (m) {
        var url = lang_1.isPresent(m[1]) ? m[1] : m[2];
        var schemeMatch = lang_1.RegExpWrapper.firstMatch(_urlWithSchemaRe, url);
        if (lang_1.isPresent(schemeMatch) && schemeMatch[1] != 'package') {
            // Do not attempt to resolve non-package absolute URLs with URI scheme
            return m[0];
        }
        foundUrls.push(resolver.resolve(baseUrl, url));
        return '';
    });
}
function replaceUrls(resolver, baseUrl, cssText) {
    return lang_1.StringWrapper.replaceAllMapped(cssText, _cssUrlRe, function (m) {
        var pre = m[1];
        var originalUrl = m[2];
        if (lang_1.RegExpWrapper.test(_dataUrlRe, originalUrl)) {
            // Do not attempt to resolve data: URLs
            return m[0];
        }
        var url = lang_1.StringWrapper.replaceAll(originalUrl, _quoteRe, '');
        var post = m[3];
        var resolvedUrl = resolver.resolve(baseUrl, url);
        return pre + "'" + resolvedUrl + "'" + post;
    });
}
var _cssUrlRe = /(url\()([^)]*)(\))/g;
var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
var _quoteRe = /['"]/g;
var _dataUrlRe = /^['"]?data:/g;
// TODO: can't use /^[^:/?#.]+:/g due to clang-format bug:
//       https://github.com/angular/angular/issues/4596
var _urlWithSchemaRe = /^['"]?([a-zA-Z\-\+\.]+):/g;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var TextAst = (function () {
    function TextAst(value, ngContentIndex, sourceInfo) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return TextAst;
})();
exports.TextAst = TextAst;
var BoundTextAst = (function () {
    function BoundTextAst(value, ngContentIndex, sourceInfo) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    BoundTextAst.prototype.visit = function (visitor, context) {
        return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
})();
exports.BoundTextAst = BoundTextAst;
var AttrAst = (function () {
    function AttrAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return AttrAst;
})();
exports.AttrAst = AttrAst;
var BoundElementPropertyAst = (function () {
    function BoundElementPropertyAst(name, type, value, unit, sourceInfo) {
        this.name = name;
        this.type = type;
        this.value = value;
        this.unit = unit;
        this.sourceInfo = sourceInfo;
    }
    BoundElementPropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitElementProperty(this, context);
    };
    return BoundElementPropertyAst;
})();
exports.BoundElementPropertyAst = BoundElementPropertyAst;
var BoundEventAst = (function () {
    function BoundEventAst(name, target, handler, sourceInfo) {
        this.name = name;
        this.target = target;
        this.handler = handler;
        this.sourceInfo = sourceInfo;
    }
    BoundEventAst.prototype.visit = function (visitor, context) {
        return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
        get: function () {
            if (lang_1.isPresent(this.target)) {
                return this.target + ":" + this.name;
            }
            else {
                return this.name;
            }
        },
        enumerable: true,
        configurable: true
    });
    return BoundEventAst;
})();
exports.BoundEventAst = BoundEventAst;
var VariableAst = (function () {
    function VariableAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    VariableAst.prototype.visit = function (visitor, context) {
        return visitor.visitVariable(this, context);
    };
    return VariableAst;
})();
exports.VariableAst = VariableAst;
var ElementAst = (function () {
    function ElementAst(name, attrs, inputs, outputs, exportAsVars, directives, children, ngContentIndex, sourceInfo) {
        this.name = name;
        this.attrs = attrs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.exportAsVars = exportAsVars;
        this.directives = directives;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    ElementAst.prototype.visit = function (visitor, context) {
        return visitor.visitElement(this, context);
    };
    ElementAst.prototype.isBound = function () {
        return (this.inputs.length > 0 || this.outputs.length > 0 || this.exportAsVars.length > 0 ||
            this.directives.length > 0);
    };
    ElementAst.prototype.getComponent = function () {
        return this.directives.length > 0 && this.directives[0].directive.isComponent ?
            this.directives[0].directive :
            null;
    };
    return ElementAst;
})();
exports.ElementAst = ElementAst;
var EmbeddedTemplateAst = (function () {
    function EmbeddedTemplateAst(attrs, vars, directives, children, ngContentIndex, sourceInfo) {
        this.attrs = attrs;
        this.vars = vars;
        this.directives = directives;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
        return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
})();
exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
var BoundDirectivePropertyAst = (function () {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceInfo) {
        this.directiveName = directiveName;
        this.templateName = templateName;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
})();
exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
var DirectiveAst = (function () {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, exportAsVars, sourceInfo) {
        this.directive = directive;
        this.inputs = inputs;
        this.hostProperties = hostProperties;
        this.hostEvents = hostEvents;
        this.exportAsVars = exportAsVars;
        this.sourceInfo = sourceInfo;
    }
    DirectiveAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
})();
exports.DirectiveAst = DirectiveAst;
var NgContentAst = (function () {
    function NgContentAst(index, ngContentIndex, sourceInfo) {
        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    NgContentAst.prototype.visit = function (visitor, context) {
        return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
})();
exports.NgContentAst = NgContentAst;
(function (PropertyBindingType) {
    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
})(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
var PropertyBindingType = exports.PropertyBindingType;
function templateVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.templateVisitAll = templateVisitAll;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
var directive_metadata_1 = require('./directive_metadata');
var di_1 = require('angular2/src/core/di');
var source_module_1 = require('./source_module');
var change_detector_compiler_1 = require('./change_detector_compiler');
var style_compiler_1 = require('./style_compiler');
var command_compiler_1 = require('./command_compiler');
var template_parser_1 = require('./template_parser');
var template_normalizer_1 = require('./template_normalizer');
var runtime_metadata_1 = require('./runtime_metadata');
var application_tokens_1 = require('angular2/src/core/application_tokens');
var command_compiler_2 = require('./command_compiler');
var util_1 = require('./util');
var di_2 = require('angular2/src/core/di');
var TemplateCompiler = (function () {
    function TemplateCompiler(_runtimeMetadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _commandCompiler, _cdCompiler, appId) {
        this._runtimeMetadataResolver = _runtimeMetadataResolver;
        this._templateNormalizer = _templateNormalizer;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._commandCompiler = _commandCompiler;
        this._cdCompiler = _cdCompiler;
        this._hostCacheKeys = new Map();
        this._compiledTemplateCache = new Map();
        this._compiledTemplateDone = new Map();
        this._appId = appId;
    }
    TemplateCompiler.prototype.normalizeDirectiveMetadata = function (directive) {
        if (!directive.isComponent) {
            // For non components there is nothing to be normalized yet.
            return async_1.PromiseWrapper.resolve(directive);
        }
        var normalizedTemplatePromise;
        if (directive.isComponent) {
            normalizedTemplatePromise =
                this._templateNormalizer.normalizeTemplate(directive.type, directive.template);
        }
        else {
            normalizedTemplatePromise = async_1.PromiseWrapper.resolve(null);
        }
        return normalizedTemplatePromise.then(function (normalizedTemplate) { return new directive_metadata_1.CompileDirectiveMetadata({
            type: directive.type,
            isComponent: directive.isComponent,
            dynamicLoadable: directive.dynamicLoadable,
            selector: directive.selector,
            exportAs: directive.exportAs,
            changeDetection: directive.changeDetection,
            inputs: directive.inputs,
            outputs: directive.outputs,
            hostListeners: directive.hostListeners,
            hostProperties: directive.hostProperties,
            hostAttributes: directive.hostAttributes,
            lifecycleHooks: directive.lifecycleHooks, template: normalizedTemplate
        }); });
    };
    TemplateCompiler.prototype.compileHostComponentRuntime = function (type) {
        var hostCacheKey = this._hostCacheKeys.get(type);
        if (lang_1.isBlank(hostCacheKey)) {
            hostCacheKey = new Object();
            this._hostCacheKeys.set(type, hostCacheKey);
            var compMeta = this._runtimeMetadataResolver.getMetadata(type);
            assertComponent(compMeta);
            var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
            this._compileComponentRuntime(hostCacheKey, hostMeta, [compMeta], new Set());
        }
        return this._compiledTemplateDone.get(hostCacheKey)
            .then(function (compiledTemplate) { return new template_commands_1.CompiledHostTemplate(function () { return compiledTemplate; }); });
    };
    TemplateCompiler.prototype.clearCache = function () {
        this._hostCacheKeys.clear();
        this._styleCompiler.clearCache();
        this._compiledTemplateCache.clear();
        this._compiledTemplateDone.clear();
    };
    TemplateCompiler.prototype._compileComponentRuntime = function (cacheKey, compMeta, viewDirectives, compilingComponentCacheKeys) {
        var _this = this;
        var compiledTemplate = this._compiledTemplateCache.get(cacheKey);
        var done = this._compiledTemplateDone.get(cacheKey);
        if (lang_1.isBlank(compiledTemplate)) {
            var styles;
            var changeDetectorFactory;
            var commands;
            var templateId = template_commands_1.nextTemplateId();
            compiledTemplate =
                new template_commands_1.CompiledTemplate(templateId, function (_a, _b) { return [changeDetectorFactory, commands, styles]; });
            this._compiledTemplateCache.set(cacheKey, compiledTemplate);
            compilingComponentCacheKeys.add(cacheKey);
            done =
                async_1.PromiseWrapper.all([
                    this._styleCompiler.compileComponentRuntime(this._appId, templateId, compMeta.template)
                ].concat(viewDirectives.map(function (dirMeta) {
                    return _this.normalizeDirectiveMetadata(dirMeta);
                })))
                    .then(function (stylesAndNormalizedViewDirMetas) {
                    var childPromises = [];
                    var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);
                    var parsedTemplate = _this._templateParser.parse(compMeta.template.template, normalizedViewDirMetas, compMeta.type.name);
                    var changeDetectorFactories = _this._cdCompiler.compileComponentRuntime(compMeta.type, compMeta.changeDetection, parsedTemplate);
                    changeDetectorFactory = changeDetectorFactories[0];
                    styles = stylesAndNormalizedViewDirMetas[0];
                    commands = _this._compileCommandsRuntime(compMeta, templateId, parsedTemplate, changeDetectorFactories, compilingComponentCacheKeys, childPromises);
                    return async_1.PromiseWrapper.all(childPromises);
                })
                    .then(function (_) {
                    collection_1.SetWrapper.delete(compilingComponentCacheKeys, cacheKey);
                    return compiledTemplate;
                });
            this._compiledTemplateDone.set(cacheKey, done);
        }
        return compiledTemplate;
    };
    TemplateCompiler.prototype._compileCommandsRuntime = function (compMeta, templateId, parsedTemplate, changeDetectorFactories, compilingComponentCacheKeys, childPromises) {
        var _this = this;
        return this._commandCompiler.compileComponentRuntime(compMeta, this._appId, templateId, parsedTemplate, changeDetectorFactories, function (childComponentDir) {
            var childCacheKey = childComponentDir.type.runtime;
            var childViewDirectives = _this._runtimeMetadataResolver.getViewDirectivesMetadata(childComponentDir.type.runtime);
            var childIsRecursive = collection_1.SetWrapper.has(compilingComponentCacheKeys, childCacheKey);
            var childTemplate = _this._compileComponentRuntime(childCacheKey, childComponentDir, childViewDirectives, compilingComponentCacheKeys);
            if (!childIsRecursive) {
                // Only wait for a child if it is not a cycle
                childPromises.push(_this._compiledTemplateDone.get(childCacheKey));
            }
            return childTemplate;
        });
    };
    TemplateCompiler.prototype.compileTemplatesCodeGen = function (components) {
        var _this = this;
        if (components.length === 0) {
            throw new exceptions_1.BaseException('No components given');
        }
        var declarations = [];
        var templateArguments = [];
        var componentMetas = [];
        var templateIdVariable = 'templateId';
        var appIdVariable = 'appId';
        components.forEach(function (componentWithDirs) {
            var compMeta = componentWithDirs.component;
            assertComponent(compMeta);
            componentMetas.push(compMeta);
            _this._processTemplateCodeGen(compMeta, appIdVariable, templateIdVariable, componentWithDirs.directives, declarations, templateArguments);
            if (compMeta.dynamicLoadable) {
                var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
                componentMetas.push(hostMeta);
                _this._processTemplateCodeGen(hostMeta, appIdVariable, templateIdVariable, [compMeta], declarations, templateArguments);
            }
        });
        collection_1.ListWrapper.forEachWithIndex(componentMetas, function (compMeta, index) {
            var templateDataFn = util_1.codeGenValueFn([appIdVariable, templateIdVariable], "[" + templateArguments[index].join(',') + "]");
            var compiledTemplateExpr = "new " + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "CompiledTemplate(" + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "nextTemplateId()," + templateDataFn + ")";
            var variableValueExpr;
            if (compMeta.type.isHost) {
                var factoryName = "_hostTemplateFactory" + index;
                declarations.push(util_1.codeGenValueFn([], compiledTemplateExpr, factoryName) + ";");
                var constructionKeyword = util_1.IS_DART ? 'const' : 'new';
                variableValueExpr =
                    constructionKeyword + " " + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "CompiledHostTemplate(" + factoryName + ")";
            }
            else {
                variableValueExpr = compiledTemplateExpr;
            }
            declarations.push("" + util_1.codeGenExportVariable(templateVariableName(compMeta.type), compMeta.type.isHost) + variableValueExpr + ";");
        });
        var moduleUrl = components[0].component.type.moduleUrl;
        return new source_module_1.SourceModule("" + templateModuleUrl(moduleUrl), declarations.join('\n'));
    };
    TemplateCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {
        return this._styleCompiler.compileStylesheetCodeGen(stylesheetUrl, cssText);
    };
    TemplateCompiler.prototype._processTemplateCodeGen = function (compMeta, appIdExpr, templateIdExpr, directives, targetDeclarations, targetTemplateArguments) {
        var styleExpr = this._styleCompiler.compileComponentCodeGen(appIdExpr, templateIdExpr, compMeta.template);
        var parsedTemplate = this._templateParser.parse(compMeta.template.template, directives, compMeta.type.name);
        var changeDetectorsExprs = this._cdCompiler.compileComponentCodeGen(compMeta.type, compMeta.changeDetection, parsedTemplate);
        var commandsExpr = this._commandCompiler.compileComponentCodeGen(compMeta, appIdExpr, templateIdExpr, parsedTemplate, changeDetectorsExprs.expressions, codeGenComponentTemplateFactory);
        addAll(styleExpr.declarations, targetDeclarations);
        addAll(changeDetectorsExprs.declarations, targetDeclarations);
        addAll(commandsExpr.declarations, targetDeclarations);
        targetTemplateArguments.push([changeDetectorsExprs.expressions[0], commandsExpr.expression, styleExpr.expression]);
    };
    TemplateCompiler = __decorate([
        di_1.Injectable(),
        __param(6, di_2.Inject(application_tokens_1.APP_ID)), 
        __metadata('design:paramtypes', [runtime_metadata_1.RuntimeMetadataResolver, template_normalizer_1.TemplateNormalizer, template_parser_1.TemplateParser, style_compiler_1.StyleCompiler, command_compiler_1.CommandCompiler, change_detector_compiler_1.ChangeDetectionCompiler, String])
    ], TemplateCompiler);
    return TemplateCompiler;
})();
exports.TemplateCompiler = TemplateCompiler;
var NormalizedComponentWithViewDirectives = (function () {
    function NormalizedComponentWithViewDirectives(component, directives) {
        this.component = component;
        this.directives = directives;
    }
    return NormalizedComponentWithViewDirectives;
})();
exports.NormalizedComponentWithViewDirectives = NormalizedComponentWithViewDirectives;
function assertComponent(meta) {
    if (!meta.isComponent) {
        throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
}
function templateVariableName(type) {
    return type.name + "Template";
}
function templateModuleUrl(moduleUrl) {
    var urlWithoutSuffix = moduleUrl.substring(0, moduleUrl.length - util_1.MODULE_SUFFIX.length);
    return urlWithoutSuffix + ".template" + util_1.MODULE_SUFFIX;
}
function addAll(source, target) {
    for (var i = 0; i < source.length; i++) {
        target.push(source[i]);
    }
}
function codeGenComponentTemplateFactory(nestedCompType) {
    return "" + source_module_1.moduleRef(templateModuleUrl(nestedCompType.type.moduleUrl)) + templateVariableName(nestedCompType.type);
}

},{"./change_detector_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js","./command_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js","./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./runtime_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","./template_normalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js","./template_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var directive_metadata_1 = require('./directive_metadata');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var di_1 = require('angular2/src/core/di');
var view_1 = require('angular2/src/core/metadata/view');
var html_ast_1 = require('./html_ast');
var html_parser_1 = require('./html_parser');
var template_preparser_1 = require('./template_preparser');
var TemplateNormalizer = (function () {
    function TemplateNormalizer(_xhr, _urlResolver, _domParser) {
        this._xhr = _xhr;
        this._urlResolver = _urlResolver;
        this._domParser = _domParser;
    }
    TemplateNormalizer.prototype.normalizeTemplate = function (directiveType, template) {
        var _this = this;
        if (lang_1.isPresent(template.template)) {
            return async_1.PromiseWrapper.resolve(this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl));
        }
        else if (lang_1.isPresent(template.templateUrl)) {
            var sourceAbsUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
            return this._xhr.get(sourceAbsUrl)
                .then(function (templateContent) { return _this.normalizeLoadedTemplate(directiveType, template, templateContent, sourceAbsUrl); });
        }
        else {
            throw new exceptions_1.BaseException("No template specified for component " + directiveType.name);
        }
    };
    TemplateNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
        var _this = this;
        var domNodes = this._domParser.parse(template, directiveType.name);
        var visitor = new TemplatePreparseVisitor();
        html_ast_1.htmlVisitAll(visitor, domNodes);
        var allStyles = templateMeta.styles.concat(visitor.styles);
        var allStyleAbsUrls = visitor.styleUrls.map(function (url) { return _this._urlResolver.resolve(templateAbsUrl, url); })
            .concat(templateMeta.styleUrls.map(function (url) { return _this._urlResolver.resolve(directiveType.moduleUrl, url); }));
        var allResolvedStyles = allStyles.map(function (style) {
            var styleWithImports = style_url_resolver_1.resolveStyleUrls(_this._urlResolver, templateAbsUrl, style);
            styleWithImports.styleUrls.forEach(function (styleUrl) { return allStyleAbsUrls.push(styleUrl); });
            return styleWithImports.style;
        });
        var encapsulation = templateMeta.encapsulation;
        if (encapsulation === view_1.ViewEncapsulation.Emulated && allResolvedStyles.length === 0 &&
            allStyleAbsUrls.length === 0) {
            encapsulation = view_1.ViewEncapsulation.None;
        }
        return new directive_metadata_1.CompileTemplateMetadata({
            encapsulation: encapsulation,
            template: template,
            templateUrl: templateAbsUrl,
            styles: allResolvedStyles,
            styleUrls: allStyleAbsUrls,
            ngContentSelectors: visitor.ngContentSelectors
        });
    };
    TemplateNormalizer = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver, html_parser_1.HtmlParser])
    ], TemplateNormalizer);
    return TemplateNormalizer;
})();
exports.TemplateNormalizer = TemplateNormalizer;
var TemplatePreparseVisitor = (function () {
    function TemplatePreparseVisitor() {
        this.ngContentSelectors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        switch (preparsedElement.type) {
            case template_preparser_1.PreparsedElementType.NG_CONTENT:
                if (this.ngNonBindableStackCount === 0) {
                    this.ngContentSelectors.push(preparsedElement.selectAttr);
                }
                break;
            case template_preparser_1.PreparsedElementType.STYLE:
                var textContent = '';
                ast.children.forEach(function (child) {
                    if (child instanceof html_ast_1.HtmlTextAst) {
                        textContent += child.value;
                    }
                });
                this.styles.push(textContent);
                break;
            case template_preparser_1.PreparsedElementType.STYLESHEET:
                this.styleUrls.push(preparsedElement.hrefAttr);
                break;
        }
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount++;
        }
        html_ast_1.htmlVisitAll(this, ast.children);
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount--;
        }
        return null;
    };
    TemplatePreparseVisitor.prototype.visitAttr = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
    return TemplatePreparseVisitor;
})();

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","./style_url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js","./template_preparser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var html_parser_1 = require('./html_parser');
var template_ast_1 = require('./template_ast');
var selector_1 = require('angular2/src/core/compiler/selector');
var element_schema_registry_1 = require('angular2/src/core/compiler/schema/element_schema_registry');
var template_preparser_1 = require('./template_preparser');
var html_ast_1 = require('./html_ast');
var util_1 = require('./util');
// Group 1 = "bind-"
// Group 2 = "var-" or "#"
// Group 3 = "on-"
// Group 4 = "bindon-"
// Group 5 = the identifier after "bind-", "var-/#", or "on-"
// Group 6 = idenitifer inside [()]
// Group 7 = idenitifer inside []
// Group 8 = identifier inside ()
var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
var TEMPLATE_ELEMENT = 'template';
var TEMPLATE_ATTR = 'template';
var TEMPLATE_ATTR_PREFIX = '*';
var CLASS_ATTR = 'class';
var PROPERTY_PARTS_SEPARATOR = new RegExp('\\.');
var ATTRIBUTE_PREFIX = 'attr';
var CLASS_PREFIX = 'class';
var STYLE_PREFIX = 'style';
var TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];
var TemplateParser = (function () {
    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser) {
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this._htmlParser = _htmlParser;
    }
    TemplateParser.prototype.parse = function (template, directives, sourceInfo) {
        var parseVisitor = new TemplateParseVisitor(directives, this._exprParser, this._schemaRegistry);
        var result = html_ast_1.htmlVisitAll(parseVisitor, this._htmlParser.parse(template, sourceInfo), EMPTY_COMPONENT);
        if (parseVisitor.errors.length > 0) {
            var errorString = parseVisitor.errors.join('\n');
            throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
        }
        return result;
    };
    TemplateParser = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.Parser, element_schema_registry_1.ElementSchemaRegistry, html_parser_1.HtmlParser])
    ], TemplateParser);
    return TemplateParser;
})();
exports.TemplateParser = TemplateParser;
var TemplateParseVisitor = (function () {
    function TemplateParseVisitor(directives, _exprParser, _schemaRegistry) {
        var _this = this;
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this.errors = [];
        this.directivesIndex = new Map();
        this.ngContentCount = 0;
        this.selectorMatcher = new selector_1.SelectorMatcher();
        collection_1.ListWrapper.forEachWithIndex(directives, function (directive, index) {
            var selector = selector_1.CssSelector.parse(directive.selector);
            _this.selectorMatcher.addSelectables(selector, directive);
            _this.directivesIndex.set(directive, index);
        });
    }
    TemplateParseVisitor.prototype._reportError = function (message) { this.errors.push(message); };
    TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceInfo) {
        try {
            return this._exprParser.parseInterpolation(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseAction = function (value, sourceInfo) {
        try {
            return this._exprParser.parseAction(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseBinding = function (value, sourceInfo) {
        try {
            return this._exprParser.parseBinding(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceInfo) {
        try {
            return this._exprParser.parseTemplateBindings(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return [];
        }
    };
    TemplateParseVisitor.prototype.visitText = function (ast, component) {
        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);
        var expr = this._parseInterpolation(ast.value, ast.sourceInfo);
        if (lang_1.isPresent(expr)) {
            return new template_ast_1.BoundTextAst(expr, ngContentIndex, ast.sourceInfo);
        }
        else {
            return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceInfo);
        }
    };
    TemplateParseVisitor.prototype.visitAttr = function (ast, contex) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceInfo);
    };
    TemplateParseVisitor.prototype.visitElement = function (element, component) {
        var _this = this;
        var nodeName = element.name;
        var preparsedElement = template_preparser_1.preparseElement(element);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
        }
        var matchableAttrs = [];
        var elementOrDirectiveProps = [];
        var vars = [];
        var events = [];
        var templateElementOrDirectiveProps = [];
        var templateVars = [];
        var templateMatchableAttrs = [];
        var hasInlineTemplates = false;
        var attrs = [];
        element.attrs.forEach(function (attr) {
            matchableAttrs.push([attr.name, attr.value]);
            var hasBinding = _this._parseAttr(attr, matchableAttrs, elementOrDirectiveProps, events, vars);
            var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateVars);
            if (!hasBinding && !hasTemplateBinding) {
                // don't include the bindings as attributes as well in the AST
                attrs.push(_this.visitAttr(attr, null));
            }
            if (hasTemplateBinding) {
                hasInlineTemplates = true;
            }
        });
        var isTemplateElement = nodeName == TEMPLATE_ELEMENT;
        var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
        var directives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, elementCssSelector), elementOrDirectiveProps, isTemplateElement ? [] : vars, element.sourceInfo);
        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directives);
        var children = html_ast_1.htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, Component.create(directives));
        var elementNgContentIndex = hasInlineTemplates ? null : component.findNgContentIndex(elementCssSelector);
        var parsedElement;
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {
            parsedElement =
                new template_ast_1.NgContentAst(this.ngContentCount++, elementNgContentIndex, element.sourceInfo);
        }
        else if (isTemplateElement) {
            this._assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, events, element.sourceInfo);
            parsedElement = new template_ast_1.EmbeddedTemplateAst(attrs, vars, directives, children, elementNgContentIndex, element.sourceInfo);
        }
        else {
            this._assertOnlyOneComponent(directives, element.sourceInfo);
            var elementExportAsVars = collection_1.ListWrapper.filter(vars, function (varAst) { return varAst.value.length === 0; });
            parsedElement =
                new template_ast_1.ElementAst(nodeName, attrs, elementProps, events, elementExportAsVars, directives, children, elementNgContentIndex, element.sourceInfo);
        }
        if (hasInlineTemplates) {
            var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
            var templateDirectives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, templateCssSelector), templateElementOrDirectiveProps, [], element.sourceInfo);
            var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectives);
            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectives, templateElementProps, [], element.sourceInfo);
            parsedElement = new template_ast_1.EmbeddedTemplateAst([], templateVars, templateDirectives, [parsedElement], component.findNgContentIndex(templateCssSelector), element.sourceInfo);
        }
        return parsedElement;
    };
    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {
        var templateBindingsSource = null;
        if (attr.name == TEMPLATE_ATTR) {
            templateBindingsSource = attr.value;
        }
        else if (lang_1.StringWrapper.startsWith(attr.name, TEMPLATE_ATTR_PREFIX)) {
            var key = lang_1.StringWrapper.substring(attr.name, TEMPLATE_ATTR_PREFIX.length); // remove the star
            templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
        }
        if (lang_1.isPresent(templateBindingsSource)) {
            var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceInfo);
            for (var i = 0; i < bindings.length; i++) {
                var binding = bindings[i];
                var dashCaseKey = util_1.camelCaseToDashCase(binding.key);
                if (binding.keyIsVar) {
                    targetVars.push(new template_ast_1.VariableAst(util_1.dashCaseToCamelCase(binding.key), binding.name, attr.sourceInfo));
                    targetMatchableAttrs.push([dashCaseKey, binding.name]);
                }
                else if (lang_1.isPresent(binding.expression)) {
                    this._parsePropertyAst(dashCaseKey, binding.expression, attr.sourceInfo, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([dashCaseKey, '']);
                }
            }
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parseAttr = function (attr, targetMatchableAttrs, targetProps, targetEvents, targetVars) {
        var attrName = this._normalizeAttributeName(attr.name);
        var attrValue = attr.value;
        var bindParts = lang_1.RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
        var hasBinding = false;
        if (lang_1.isPresent(bindParts)) {
            hasBinding = true;
            if (lang_1.isPresent(bindParts[1])) {
                this._parseProperty(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[2])) {
                var identifier = bindParts[5];
                this._parseVariable(identifier, attrValue, attr.sourceInfo, targetMatchableAttrs, targetVars);
            }
            else if (lang_1.isPresent(bindParts[3])) {
                this._parseEvent(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[4])) {
                this._parseProperty(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[6])) {
                this._parseProperty(bindParts[6], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[6], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[7])) {
                this._parseProperty(bindParts[7], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[8])) {
                this._parseEvent(bindParts[8], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
        }
        else {
            hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
        }
        if (!hasBinding) {
            this._parseLiteralAttr(attrName, attrValue, attr.sourceInfo, targetProps);
        }
        return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
        return lang_1.StringWrapper.startsWith(attrName, 'data-') ? lang_1.StringWrapper.substring(attrName, 5) :
            attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceInfo, targetMatchableAttrs, targetVars) {
        targetVars.push(new template_ast_1.VariableAst(util_1.dashCaseToCamelCase(identifier), value, sourceInfo));
        targetMatchableAttrs.push([identifier, value]);
    };
    TemplateParseVisitor.prototype._parseProperty = function (name, expression, sourceInfo, targetMatchableAttrs, targetProps) {
        this._parsePropertyAst(name, this._parseBinding(expression, sourceInfo), sourceInfo, targetMatchableAttrs, targetProps);
    };
    TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceInfo, targetMatchableAttrs, targetProps) {
        var expr = this._parseInterpolation(value, sourceInfo);
        if (lang_1.isPresent(expr)) {
            this._parsePropertyAst(name, expr, sourceInfo, targetMatchableAttrs, targetProps);
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceInfo, targetMatchableAttrs, targetProps) {
        targetMatchableAttrs.push([name, ast.source]);
        targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceInfo));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceInfo, targetMatchableAttrs, targetEvents) {
        this._parseEvent(name + "-change", expression + "=$event", sourceInfo, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceInfo, targetMatchableAttrs, targetEvents) {
        // long format: 'target: eventName'
        var parts = util_1.splitAtColon(name, [null, name]);
        var target = parts[0];
        var eventName = parts[1];
        targetEvents.push(new template_ast_1.BoundEventAst(util_1.dashCaseToCamelCase(eventName), target, this._parseAction(expression, sourceInfo), sourceInfo));
        // Don't detect directives for event names for now,
        // so don't add the event name to the matchableAttrs
    };
    TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceInfo, targetProps) {
        targetProps.push(new BoundElementOrDirectiveProperty(util_1.dashCaseToCamelCase(name), this._exprParser.wrapLiteralPrimitive(value, sourceInfo), true, sourceInfo));
    };
    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
        var _this = this;
        var directives = [];
        selectorMatcher.match(elementCssSelector, function (selector, directive) { directives.push(directive); });
        // Need to sort the directives so that we get consistent results throughout,
        // as selectorMatcher uses Maps inside.
        // Also need to make components the first directive in the array
        collection_1.ListWrapper.sort(directives, function (dir1, dir2) {
            var dir1Comp = dir1.isComponent;
            var dir2Comp = dir2.isComponent;
            if (dir1Comp && !dir2Comp) {
                return -1;
            }
            else if (!dir1Comp && dir2Comp) {
                return 1;
            }
            else {
                return _this.directivesIndex.get(dir1) - _this.directivesIndex.get(dir2);
            }
        });
        return directives;
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function (elementName, directives, props, possibleExportAsVars, sourceInfo) {
        var _this = this;
        var matchedVariables = new Set();
        var directiveAsts = directives.map(function (directive) {
            var hostProperties = [];
            var hostEvents = [];
            var directiveProperties = [];
            _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceInfo, hostProperties);
            _this._createDirectiveHostEventAsts(directive.hostListeners, sourceInfo, hostEvents);
            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
            var exportAsVars = [];
            possibleExportAsVars.forEach(function (varAst) {
                if ((varAst.value.length === 0 && directive.isComponent) ||
                    (directive.exportAs == varAst.value)) {
                    exportAsVars.push(varAst);
                    matchedVariables.add(varAst.name);
                }
            });
            return new template_ast_1.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, exportAsVars, sourceInfo);
        });
        possibleExportAsVars.forEach(function (varAst) {
            if (varAst.value.length > 0 && !collection_1.SetWrapper.has(matchedVariables, varAst.name)) {
                _this._reportError("There is no directive with \"exportAs\" set to \"" + varAst.value + "\" at " + varAst.sourceInfo);
            }
        });
        return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceInfo, targetPropertyAsts) {
        var _this = this;
        if (lang_1.isPresent(hostProps)) {
            collection_1.StringMapWrapper.forEach(hostProps, function (expression, propName) {
                var exprAst = _this._parseBinding(expression, sourceInfo);
                targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceInfo));
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceInfo, targetEventAsts) {
        var _this = this;
        if (lang_1.isPresent(hostListeners)) {
            collection_1.StringMapWrapper.forEach(hostListeners, function (expression, propName) {
                _this._parseEvent(propName, expression, sourceInfo, [], targetEventAsts);
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
        if (lang_1.isPresent(directiveProperties)) {
            var boundPropsByName = new Map();
            boundProps.forEach(function (boundProp) {
                var key = util_1.dashCaseToCamelCase(boundProp.name);
                var prevValue = boundPropsByName.get(boundProp.name);
                if (lang_1.isBlank(prevValue) || prevValue.isLiteral) {
                    // give [a]="b" a higher precedence thatn a="b" on the same element
                    boundPropsByName.set(key, boundProp);
                }
            });
            collection_1.StringMapWrapper.forEach(directiveProperties, function (elProp, dirProp) {
                elProp = util_1.dashCaseToCamelCase(elProp);
                var boundProp = boundPropsByName.get(elProp);
                // Bindings are optional, so this binding only needs to be set up if an expression is given.
                if (lang_1.isPresent(boundProp)) {
                    targetBoundDirectiveProps.push(new template_ast_1.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceInfo));
                }
            });
        }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
        var _this = this;
        var boundElementProps = [];
        var boundDirectivePropsIndex = new Map();
        directives.forEach(function (directive) {
            directive.inputs.forEach(function (prop) {
                boundDirectivePropsIndex.set(prop.templateName, prop);
            });
        });
        props.forEach(function (prop) {
            if (!prop.isLiteral && lang_1.isBlank(boundDirectivePropsIndex.get(prop.name))) {
                boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceInfo));
            }
        });
        return boundElementProps;
    };
    TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceInfo) {
        var unit = null;
        var bindingType;
        var boundPropertyName;
        var parts = lang_1.StringWrapper.split(name, PROPERTY_PARTS_SEPARATOR);
        if (parts.length === 1) {
            boundPropertyName = this._schemaRegistry.getMappedPropName(util_1.dashCaseToCamelCase(parts[0]));
            bindingType = template_ast_1.PropertyBindingType.Property;
            if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {
                this._reportError("Can't bind to '" + boundPropertyName + "' since it isn't a known native property in " + sourceInfo);
            }
        }
        else if (parts[0] == ATTRIBUTE_PREFIX) {
            boundPropertyName = util_1.dashCaseToCamelCase(parts[1]);
            bindingType = template_ast_1.PropertyBindingType.Attribute;
        }
        else if (parts[0] == CLASS_PREFIX) {
            // keep original case!
            boundPropertyName = parts[1];
            bindingType = template_ast_1.PropertyBindingType.Class;
        }
        else if (parts[0] == STYLE_PREFIX) {
            unit = parts.length > 2 ? parts[2] : null;
            boundPropertyName = util_1.dashCaseToCamelCase(parts[1]);
            bindingType = template_ast_1.PropertyBindingType.Style;
        }
        else {
            this._reportError("Invalid property name " + name + " in " + sourceInfo);
            bindingType = null;
        }
        return new template_ast_1.BoundElementPropertyAst(boundPropertyName, bindingType, ast, unit, sourceInfo);
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
        var componentTypeNames = [];
        directives.forEach(function (directive) {
            var typeName = directive.directive.type.name;
            if (directive.directive.isComponent) {
                componentTypeNames.push(typeName);
            }
        });
        return componentTypeNames;
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceInfo) {
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 1) {
            this._reportError("More than one component: " + componentTypeNames.join(',') + " in " + sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, events, sourceInfo) {
        var _this = this;
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 0) {
            this._reportError("Components on an embedded template: " + componentTypeNames.join(',') + " in " + sourceInfo);
        }
        elementProps.forEach(function (prop) {
            _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template in " + prop.sourceInfo);
        });
        events.forEach(function (event) {
            _this._reportError("Event binding " + event.name + " on an embedded template in " + event.sourceInfo);
        });
    };
    return TemplateParseVisitor;
})();
var NonBindableVisitor = (function () {
    function NonBindableVisitor() {
    }
    NonBindableVisitor.prototype.visitElement = function (ast, component) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
        }
        var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
        var selector = createElementCssSelector(ast.name, attrNameAndValues);
        var ngContentIndex = component.findNgContentIndex(selector);
        var children = html_ast_1.htmlVisitAll(this, ast.children, EMPTY_COMPONENT);
        return new template_ast_1.ElementAst(ast.name, html_ast_1.htmlVisitAll(this, ast.attrs), [], [], [], [], children, ngContentIndex, ast.sourceInfo);
    };
    NonBindableVisitor.prototype.visitAttr = function (ast, context) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceInfo);
    };
    NonBindableVisitor.prototype.visitText = function (ast, component) {
        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);
        return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceInfo);
    };
    return NonBindableVisitor;
})();
var BoundElementOrDirectiveProperty = (function () {
    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceInfo) {
        this.name = name;
        this.expression = expression;
        this.isLiteral = isLiteral;
        this.sourceInfo = sourceInfo;
    }
    return BoundElementOrDirectiveProperty;
})();
var ParseError = (function () {
    function ParseError(message, sourceInfo) {
        this.message = message;
        this.sourceInfo = sourceInfo;
    }
    return ParseError;
})();
function splitClasses(classAttrValue) {
    return lang_1.StringWrapper.split(classAttrValue.trim(), /\s+/g);
}
exports.splitClasses = splitClasses;
var Component = (function () {
    function Component(ngContentIndexMatcher, wildcardNgContentIndex) {
        this.ngContentIndexMatcher = ngContentIndexMatcher;
        this.wildcardNgContentIndex = wildcardNgContentIndex;
    }
    Component.create = function (directives) {
        if (directives.length === 0 || !directives[0].directive.isComponent) {
            return EMPTY_COMPONENT;
        }
        var matcher = new selector_1.SelectorMatcher();
        var ngContentSelectors = directives[0].directive.template.ngContentSelectors;
        var wildcardNgContentIndex = null;
        for (var i = 0; i < ngContentSelectors.length; i++) {
            var selector = ngContentSelectors[i];
            if (lang_1.StringWrapper.equals(selector, '*')) {
                wildcardNgContentIndex = i;
            }
            else {
                matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);
            }
        }
        return new Component(matcher, wildcardNgContentIndex);
    };
    Component.prototype.findNgContentIndex = function (selector) {
        var ngContentIndices = [];
        if (lang_1.isPresent(this.wildcardNgContentIndex)) {
            ngContentIndices.push(this.wildcardNgContentIndex);
        }
        this.ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
        collection_1.ListWrapper.sort(ngContentIndices);
        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return Component;
})();
function createElementCssSelector(elementName, matchableAttrs) {
    var cssSelector = new selector_1.CssSelector();
    cssSelector.setElement(elementName);
    for (var i = 0; i < matchableAttrs.length; i++) {
        var attrName = matchableAttrs[i][0].toLowerCase();
        var attrValue = matchableAttrs[i][1];
        cssSelector.addAttribute(attrName, attrValue);
        if (attrName == CLASS_ATTR) {
            var classes = splitClasses(attrValue);
            classes.forEach(function (className) { return cssSelector.addClassName(className); });
        }
    }
    return cssSelector;
}
var EMPTY_COMPONENT = new Component(new selector_1.SelectorMatcher(), null);
var NON_BINDABLE_VISITOR = new NonBindableVisitor();

},{"./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","./template_preparser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/schema/element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/compiler/selector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var NG_CONTENT_SELECT_ATTR = 'select';
var NG_CONTENT_ELEMENT = 'ng-content';
var LINK_ELEMENT = 'link';
var LINK_STYLE_REL_ATTR = 'rel';
var LINK_STYLE_HREF_ATTR = 'href';
var LINK_STYLE_REL_VALUE = 'stylesheet';
var STYLE_ELEMENT = 'style';
var SCRIPT_ELEMENT = 'script';
var NG_NON_BINDABLE_ATTR = 'ng-non-bindable';
function preparseElement(ast) {
    var selectAttr = null;
    var hrefAttr = null;
    var relAttr = null;
    var nonBindable = false;
    ast.attrs.forEach(function (attr) {
        if (attr.name == NG_CONTENT_SELECT_ATTR) {
            selectAttr = attr.value;
        }
        else if (attr.name == LINK_STYLE_HREF_ATTR) {
            hrefAttr = attr.value;
        }
        else if (attr.name == LINK_STYLE_REL_ATTR) {
            relAttr = attr.value;
        }
        else if (attr.name == NG_NON_BINDABLE_ATTR) {
            nonBindable = true;
        }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name;
    var type = PreparsedElementType.OTHER;
    if (nodeName == NG_CONTENT_ELEMENT) {
        type = PreparsedElementType.NG_CONTENT;
    }
    else if (nodeName == STYLE_ELEMENT) {
        type = PreparsedElementType.STYLE;
    }
    else if (nodeName == SCRIPT_ELEMENT) {
        type = PreparsedElementType.SCRIPT;
    }
    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
        type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable);
}
exports.preparseElement = preparseElement;
(function (PreparsedElementType) {
    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
})(exports.PreparsedElementType || (exports.PreparsedElementType = {}));
var PreparsedElementType = exports.PreparsedElementType;
var PreparsedElement = (function () {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable) {
        this.type = type;
        this.selectAttr = selectAttr;
        this.hrefAttr = hrefAttr;
        this.nonBindable = nonBindable;
    }
    return PreparsedElement;
})();
exports.PreparsedElement = PreparsedElement;
function normalizeNgContentSelect(selectAttr) {
    if (lang_1.isBlank(selectAttr) || selectAttr.length === 0) {
        return '*';
    }
    return selectAttr;
}

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var UrlResolver = (function () {
    function UrlResolver() {
    }
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     *
     * @param {string} baseUrl
     * @param {string} url
     * @returns {string} the resolved URL
     */
    UrlResolver.prototype.resolve = function (baseUrl, url) { return _resolveUrl(baseUrl, url); };
    UrlResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], UrlResolver);
    return UrlResolver;
})();
exports.UrlResolver = UrlResolver;
// The code below is adapted from Traceur:
// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (lang_1.isPresent(opt_scheme)) {
        out.push(opt_scheme + ':');
    }
    if (lang_1.isPresent(opt_domain)) {
        out.push('//');
        if (lang_1.isPresent(opt_userInfo)) {
            out.push(opt_userInfo + '@');
        }
        out.push(opt_domain);
        if (lang_1.isPresent(opt_port)) {
            out.push(':' + opt_port);
        }
    }
    if (lang_1.isPresent(opt_path)) {
        out.push(opt_path);
    }
    if (lang_1.isPresent(opt_queryData)) {
        out.push('?' + opt_queryData);
    }
    if (lang_1.isPresent(opt_fragment)) {
        out.push('#' + opt_fragment);
    }
    return out.join('');
}
/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @internal
 */
var _splitRe = lang_1.RegExpWrapper.create('^' +
    '(?:' +
    '([^:/?#.]+)' +
    // used by other URL parts such as :,
    // ?, /, #, and .
    ':)?' +
    '(?://' +
    '(?:([^/?#]*)@)?' +
    '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
    // digits, dashes, dots, percent
    // escapes, and unicode characters.
    '(?::([0-9]+))?' +
    ')?' +
    '([^?#]+)?' +
    '(?:\\?([^#]*))?' +
    '(?:#(.*))?' +
    '$');
/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
var _ComponentIndex;
(function (_ComponentIndex) {
    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
})(_ComponentIndex || (_ComponentIndex = {}));
/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
function _split(uri) {
    return lang_1.RegExpWrapper.firstMatch(_splitRe, uri);
}
/**
  * Removes dot segments in given path component, as described in
  * RFC 3986, section 5.2.4.
  *
  * @param {string} path A non-empty path component.
  * @return {string} Path component with removed dot segments.
  */
function _removeDotSegments(path) {
    if (path == '/')
        return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
        var segment = segments[pos];
        switch (segment) {
            case '':
            case '.':
                break;
            case '..':
                if (out.length > 0) {
                    out.pop();
                }
                else {
                    up++;
                }
                break;
            default:
                out.push(segment);
        }
    }
    if (leadingSlash == '') {
        while (up-- > 0) {
            out.unshift('..');
        }
        if (out.length === 0)
            out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
}
/**
 * Takes an array of the parts from split and canonicalizes the path part
 * and then joins all the parts.
 * @param {Array.<string?>} parts
 * @return {string}
 */
function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
}
/**
 * Resolves a URL.
 * @param {string} base The URL acting as the base URL.
 * @param {string} to The URL to resolve.
 * @return {string}
 */
function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {
        return _joinAndCanonicalizePath(parts);
    }
    else {
        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
        if (lang_1.isBlank(parts[i])) {
            parts[i] = baseParts[i];
        }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
        return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (lang_1.isBlank(path))
        path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
}

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
var SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\$/g;
var DOUBLE_QUOTE_ESCAPE_STRING_RE = /"|\\|\n|\$/g;
exports.IS_DART = !lang_1.isJsObject({});
exports.MODULE_SUFFIX = exports.IS_DART ? '.dart' : '.js';
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;
function escapeSingleQuoteString(input) {
    if (lang_1.isBlank(input)) {
        return null;
    }
    return "'" + escapeString(input, SINGLE_QUOTE_ESCAPE_STRING_RE) + "'";
}
exports.escapeSingleQuoteString = escapeSingleQuoteString;
function escapeDoubleQuoteString(input) {
    if (lang_1.isBlank(input)) {
        return null;
    }
    return "\"" + escapeString(input, DOUBLE_QUOTE_ESCAPE_STRING_RE) + "\"";
}
exports.escapeDoubleQuoteString = escapeDoubleQuoteString;
function escapeString(input, re) {
    return lang_1.StringWrapper.replaceAllMapped(input, re, function (match) {
        if (match[0] == '$') {
            return exports.IS_DART ? '\\$' : '$';
        }
        else if (match[0] == '\n') {
            return '\\n';
        }
        else {
            return "\\" + match[0];
        }
    });
}
function codeGenExportVariable(name, isConst) {
    if (isConst === void 0) { isConst = false; }
    var declaration = exports.IS_DART && isConst ? "const " + name : "var " + name;
    return exports.IS_DART ? declaration + " = " : declaration + " = exports['" + name + "'] = ";
}
exports.codeGenExportVariable = codeGenExportVariable;
function codeGenConcatArray(expression) {
    return (exports.IS_DART ? '..addAll' : '.concat') + "(" + expression + ")";
}
exports.codeGenConcatArray = codeGenConcatArray;
function codeGenMapArray(argNames, callback) {
    if (exports.IS_DART) {
        return ".map( (" + argNames.join(',') + ") => " + callback + " ).toList()";
    }
    else {
        return ".map(function(" + argNames.join(',') + ") { return " + callback + "; })";
    }
}
exports.codeGenMapArray = codeGenMapArray;
function codeGenReplaceAll(pattern, expression) {
    if (exports.IS_DART) {
        return ".replaceAll('" + pattern + "', " + expression + ")";
    }
    else {
        return ".replace(/" + pattern + "/g, " + expression + ")";
    }
}
exports.codeGenReplaceAll = codeGenReplaceAll;
function codeGenValueFn(params, value, fnName) {
    if (fnName === void 0) { fnName = ''; }
    if (exports.IS_DART) {
        return fnName + "(" + params.join(',') + ") => " + value;
    }
    else {
        return "function " + fnName + "(" + params.join(',') + ") { return " + value + "; }";
    }
}
exports.codeGenValueFn = codeGenValueFn;
function codeGenToString(expr) {
    if (exports.IS_DART) {
        return "'${" + expr + "}'";
    }
    else {
        // JS automatically convets to string...
        return expr;
    }
}
exports.codeGenToString = codeGenToString;
function splitAtColon(input, defaultValues) {
    var parts = lang_1.StringWrapper.split(input.trim(), /\s*:\s*/g);
    if (parts.length > 1) {
        return parts;
    }
    else {
        return defaultValues;
    }
}
exports.splitAtColon = splitAtColon;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js":[function(require,module,exports){
'use strict';var XHR = (function () {
    function XHR() {
    }
    XHR.prototype.get = function (url) { return null; };
    return XHR;
})();
exports.XHR = XHR;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr_impl.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var async_1 = require('angular2/src/core/facade/async');
var lang_1 = require('angular2/src/core/facade/lang');
var xhr_1 = require('./xhr');
var XHRImpl = (function (_super) {
    __extends(XHRImpl, _super);
    function XHRImpl() {
        _super.apply(this, arguments);
    }
    XHRImpl.prototype.get = function (url) {
        var completer = async_1.PromiseWrapper.completer();
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'text';
        xhr.onload = function () {
            // responseText is the old-school way of retrieving response (supported by IE8 & 9)
            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
            var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;
            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
            var status = xhr.status === 1223 ? 204 : xhr.status;
            // fix status code when it is 0 (0 status is undocumented).
            // Occurs when accessing file resources or on Android 4.1 stock browser
            // while retrieving files from application cache.
            if (status === 0) {
                status = response ? 200 : 0;
            }
            if (200 <= status && status <= 300) {
                completer.resolve(response);
            }
            else {
                completer.reject("Failed to load " + url, null);
            }
        };
        xhr.onerror = function () { completer.reject("Failed to load " + url, null); };
        xhr.send();
        return completer.promise;
    };
    XHRImpl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], XHRImpl);
    return XHRImpl;
})(xhr_1.XHR);
exports.XHRImpl = XHRImpl;

},{"./xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug.js":[function(require,module,exports){
'use strict';var debug_element_1 = require('./debug/debug_element');
exports.DebugElement = debug_element_1.DebugElement;
exports.asNativeElements = debug_element_1.asNativeElements;
exports.By = debug_element_1.By;
exports.Scope = debug_element_1.Scope;
exports.inspectElement = debug_element_1.inspectElement;
var debug_element_view_listener_1 = require('./debug/debug_element_view_listener');
exports.inspectNativeElement = debug_element_view_listener_1.inspectNativeElement;
exports.ELEMENT_PROBE_PROVIDERS = debug_element_view_listener_1.ELEMENT_PROBE_PROVIDERS;
exports.ELEMENT_PROBE_BINDINGS = debug_element_view_listener_1.ELEMENT_PROBE_BINDINGS;

},{"./debug/debug_element":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js","./debug/debug_element_view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element_view_listener.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var view_ref_1 = require('angular2/src/core/linker/view_ref');
/**
 * A DebugElement contains information from the Angular compiler about an
 * element and provides access to the corresponding ElementInjector and
 * underlying DOM Element, as well as a way to query for children.
 */
var DebugElement = (function () {
    function DebugElement() {
    }
    Object.defineProperty(DebugElement.prototype, "componentInstance", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "nativeElement", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "elementRef", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "children", {
        /**
         * Get child DebugElements from within the Light DOM.
         *
         * @return {DebugElement[]}
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "componentViewChildren", {
        /**
         * Get the root DebugElement children of a component. Returns an empty
         * list if the current DebugElement is not a component root.
         *
         * @return {DebugElement[]}
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * Return the first descendant TestElement matching the given predicate
     * and scope.
     *
     * @param {Function: boolean} predicate
     * @param {Scope} scope
     *
     * @return {DebugElement}
     */
    DebugElement.prototype.query = function (predicate, scope) {
        if (scope === void 0) { scope = Scope.all; }
        var results = this.queryAll(predicate, scope);
        return results.length > 0 ? results[0] : null;
    };
    /**
     * Return descendant TestElememts matching the given predicate
     * and scope.
     *
     * @param {Function: boolean} predicate
     * @param {Scope} scope
     *
     * @return {DebugElement[]}
     */
    DebugElement.prototype.queryAll = function (predicate, scope) {
        if (scope === void 0) { scope = Scope.all; }
        var elementsInScope = scope(this);
        return collection_1.ListWrapper.filter(elementsInScope, predicate);
    };
    return DebugElement;
})();
exports.DebugElement = DebugElement;
var DebugElement_ = (function (_super) {
    __extends(DebugElement_, _super);
    function DebugElement_(_parentView, _boundElementIndex) {
        _super.call(this);
        this._parentView = _parentView;
        this._boundElementIndex = _boundElementIndex;
        this._elementInjector = this._parentView.elementInjectors[this._boundElementIndex];
    }
    Object.defineProperty(DebugElement_.prototype, "componentInstance", {
        get: function () {
            if (!lang_1.isPresent(this._elementInjector)) {
                return null;
            }
            return this._elementInjector.getComponent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "nativeElement", {
        get: function () { return this.elementRef.nativeElement; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "elementRef", {
        get: function () { return this._parentView.elementRefs[this._boundElementIndex]; },
        enumerable: true,
        configurable: true
    });
    DebugElement_.prototype.getDirectiveInstance = function (directiveIndex) {
        return this._elementInjector.getDirectiveAtIndex(directiveIndex);
    };
    Object.defineProperty(DebugElement_.prototype, "children", {
        get: function () {
            return this._getChildElements(this._parentView, this._boundElementIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "componentViewChildren", {
        get: function () {
            var shadowView = this._parentView.getNestedView(this._boundElementIndex);
            if (!lang_1.isPresent(shadowView)) {
                // The current element is not a component.
                return [];
            }
            return this._getChildElements(shadowView, null);
        },
        enumerable: true,
        configurable: true
    });
    DebugElement_.prototype.triggerEventHandler = function (eventName, eventObj) {
        this._parentView.triggerEventHandlers(eventName, eventObj, this._boundElementIndex);
    };
    DebugElement_.prototype.hasDirective = function (type) {
        if (!lang_1.isPresent(this._elementInjector)) {
            return false;
        }
        return this._elementInjector.hasDirective(type);
    };
    DebugElement_.prototype.inject = function (type) {
        if (!lang_1.isPresent(this._elementInjector)) {
            return null;
        }
        return this._elementInjector.get(type);
    };
    DebugElement_.prototype.getLocal = function (name) { return this._parentView.locals.get(name); };
    /** @internal */
    DebugElement_.prototype._getChildElements = function (view, parentBoundElementIndex) {
        var _this = this;
        var els = [];
        var parentElementBinder = null;
        if (lang_1.isPresent(parentBoundElementIndex)) {
            parentElementBinder = view.proto.elementBinders[parentBoundElementIndex - view.elementOffset];
        }
        for (var i = 0; i < view.proto.elementBinders.length; ++i) {
            var binder = view.proto.elementBinders[i];
            if (binder.parent == parentElementBinder) {
                els.push(new DebugElement_(view, view.elementOffset + i));
                var views = view.viewContainers[view.elementOffset + i];
                if (lang_1.isPresent(views)) {
                    views.views.forEach(function (nextView) { els = els.concat(_this._getChildElements(nextView, null)); });
                }
            }
        }
        return els;
    };
    return DebugElement_;
})(DebugElement);
exports.DebugElement_ = DebugElement_;
/**
 * Returns a DebugElement for a ElementRef.
 *
 * @param {ElementRef}: elementRef
 * @return {DebugElement}
 */
function inspectElement(elementRef) {
    return new DebugElement_(view_ref_1.internalView(elementRef.parentView), elementRef.boundElementIndex);
}
exports.inspectElement = inspectElement;
function asNativeElements(arr) {
    return arr.map(function (debugEl) { return debugEl.nativeElement; });
}
exports.asNativeElements = asNativeElements;
var Scope = (function () {
    function Scope() {
    }
    Scope.all = function (debugElement) {
        var scope = [];
        scope.push(debugElement);
        debugElement.children.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });
        debugElement.componentViewChildren.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });
        return scope;
    };
    Scope.light = function (debugElement) {
        var scope = [];
        debugElement.children.forEach(function (child) {
            scope.push(child);
            scope = scope.concat(Scope.light(child));
        });
        return scope;
    };
    Scope.view = function (debugElement) {
        var scope = [];
        debugElement.componentViewChildren.forEach(function (child) {
            scope.push(child);
            scope = scope.concat(Scope.light(child));
        });
        return scope;
    };
    return Scope;
})();
exports.Scope = Scope;
var By = (function () {
    function By() {
    }
    By.all = function () { return function (debugElement) { return true; }; };
    By.css = function (selector) {
        return function (debugElement) {
            return lang_1.isPresent(debugElement.nativeElement) ?
                dom_adapter_1.DOM.elementMatches(debugElement.nativeElement, selector) :
                false;
        };
    };
    By.directive = function (type) {
        return function (debugElement) { return debugElement.hasDirective(type); };
    };
    return By;
})();
exports.By = By;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element_view_listener.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var view_listener_1 = require('angular2/src/core/linker/view_listener');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var api_1 = require('angular2/src/core/render/api');
var debug_element_1 = require('./debug_element');
var NG_ID_PROPERTY = 'ngid';
var INSPECT_GLOBAL_NAME = 'ng.probe';
var NG_ID_SEPARATOR = '#';
// Need to keep the views in a global Map so that multiple angular apps are supported
var _allIdsByView = new collection_1.Map();
var _allViewsById = new collection_1.Map();
var _nextId = 0;
function _setElementId(element, indices) {
    if (lang_1.isPresent(element)) {
        dom_adapter_1.DOM.setData(element, NG_ID_PROPERTY, indices.join(NG_ID_SEPARATOR));
    }
}
function _getElementId(element) {
    var elId = dom_adapter_1.DOM.getData(element, NG_ID_PROPERTY);
    if (lang_1.isPresent(elId)) {
        return elId.split(NG_ID_SEPARATOR).map(function (partStr) { return lang_1.NumberWrapper.parseInt(partStr, 10); });
    }
    else {
        return null;
    }
}
function inspectNativeElement(element) {
    var elId = _getElementId(element);
    if (lang_1.isPresent(elId)) {
        var view = _allViewsById.get(elId[0]);
        if (lang_1.isPresent(view)) {
            return new debug_element_1.DebugElement_(view, elId[1]);
        }
    }
    return null;
}
exports.inspectNativeElement = inspectNativeElement;
var DebugElementViewListener = (function () {
    function DebugElementViewListener(_renderer) {
        this._renderer = _renderer;
        dom_adapter_1.DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    }
    DebugElementViewListener.prototype.viewCreated = function (view) {
        var viewId = _nextId++;
        _allViewsById.set(viewId, view);
        _allIdsByView.set(view, viewId);
        for (var i = 0; i < view.elementRefs.length; i++) {
            var el = view.elementRefs[i];
            _setElementId(this._renderer.getNativeElementSync(el), [viewId, i]);
        }
    };
    DebugElementViewListener.prototype.viewDestroyed = function (view) {
        var viewId = _allIdsByView.get(view);
        _allIdsByView.delete(view);
        _allViewsById.delete(viewId);
    };
    DebugElementViewListener = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [api_1.Renderer])
    ], DebugElementViewListener);
    return DebugElementViewListener;
})();
exports.DebugElementViewListener = DebugElementViewListener;
exports.ELEMENT_PROBE_PROVIDERS = lang_1.CONST_EXPR([
    DebugElementViewListener,
    lang_1.CONST_EXPR(new di_1.Provider(view_listener_1.AppViewListener, { useExisting: DebugElementViewListener })),
]);
exports.ELEMENT_PROBE_BINDINGS = exports.ELEMENT_PROBE_PROVIDERS;

},{"./debug_element":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * The `di` module provides dependency injection container services.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var metadata_1 = require('./di/metadata');
exports.InjectMetadata = metadata_1.InjectMetadata;
exports.OptionalMetadata = metadata_1.OptionalMetadata;
exports.InjectableMetadata = metadata_1.InjectableMetadata;
exports.SelfMetadata = metadata_1.SelfMetadata;
exports.HostMetadata = metadata_1.HostMetadata;
exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
exports.DependencyMetadata = metadata_1.DependencyMetadata;
// we have to reexport * because Dart and TS export two different sets of types
__export(require('./di/decorators'));
var forward_ref_1 = require('./di/forward_ref');
exports.forwardRef = forward_ref_1.forwardRef;
exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
var injector_1 = require('./di/injector');
exports.Injector = injector_1.Injector;
var provider_1 = require('./di/provider');
exports.Binding = provider_1.Binding;
exports.ProviderBuilder = provider_1.ProviderBuilder;
exports.ResolvedFactory = provider_1.ResolvedFactory;
exports.Dependency = provider_1.Dependency;
exports.bind = provider_1.bind;
exports.Provider = provider_1.Provider;
exports.provide = provider_1.provide;
var key_1 = require('./di/key');
exports.Key = key_1.Key;
exports.TypeLiteral = key_1.TypeLiteral;
var exceptions_1 = require('./di/exceptions');
exports.NoProviderError = exceptions_1.NoProviderError;
exports.AbstractProviderError = exceptions_1.AbstractProviderError;
exports.CyclicDependencyError = exceptions_1.CyclicDependencyError;
exports.InstantiationError = exceptions_1.InstantiationError;
exports.InvalidProviderError = exceptions_1.InvalidProviderError;
exports.NoAnnotationError = exceptions_1.NoAnnotationError;
exports.OutOfBoundsError = exceptions_1.OutOfBoundsError;
var opaque_token_1 = require('./di/opaque_token');
exports.OpaqueToken = opaque_token_1.OpaqueToken;

},{"./di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","./di/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./di/forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./di/injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js","./di/key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","./di/opaque_token":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/opaque_token.js","./di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js":[function(require,module,exports){
'use strict';var metadata_1 = require('./metadata');
var decorators_1 = require('../util/decorators');
/**
 * Factory for creating {@link InjectMetadata}.
 */
exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
/**
 * Factory for creating {@link OptionalMetadata}.
 */
exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
/**
 * Factory for creating {@link InjectableMetadata}.
 */
exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
/**
 * Factory for creating {@link SelfMetadata}.
 */
exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
/**
 * Factory for creating {@link HostMetadata}.
 */
exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
/**
 * Factory for creating {@link SkipSelfMetadata}.
 */
exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);

},{"../util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
        if (collection_1.ListWrapper.contains(res, keys[i])) {
            res.push(keys[i]);
            return res;
        }
        else {
            res.push(keys[i]);
        }
    }
    return res;
}
function constructResolvingPath(keys) {
    if (keys.length > 1) {
        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });
        return " (" + tokenStrs.join(' -> ') + ")";
    }
    else {
        return "";
    }
}
/**
 * Base class for all errors arising from misconfigured providers.
 */
var AbstractProviderError = (function (_super) {
    __extends(AbstractProviderError, _super);
    function AbstractProviderError(injector, key, constructResolvingMessage) {
        _super.call(this, "DI Exception");
        this.keys = [key];
        this.injectors = [injector];
        this.constructResolvingMessage = constructResolvingMessage;
        this.message = this.constructResolvingMessage(this.keys);
    }
    AbstractProviderError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
        this.message = this.constructResolvingMessage(this.keys);
    };
    Object.defineProperty(AbstractProviderError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return AbstractProviderError;
})(exceptions_1.BaseException);
exports.AbstractProviderError = AbstractProviderError;
/**
 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
 * {@link Injector} does not have a {@link Provider} for {@link Key}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b:B) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 */
var NoProviderError = (function (_super) {
    __extends(NoProviderError, _super);
    function NoProviderError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
            return "No provider for " + first + "!" + constructResolvingPath(keys);
        });
    }
    return NoProviderError;
})(AbstractProviderError);
exports.NoProviderError = NoProviderError;
/**
 * Thrown when dependencies form a cycle.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
 *
 * ```typescript
 * var injector = Injector.resolveAndCreate([
 *   provide("one", {useFactory: (two) => "two", deps: [[new Inject("two")]]}),
 *   provide("two", {useFactory: (one) => "one", deps: [[new Inject("one")]]})
 * ]);
 *
 * expect(() => injector.get("one")).toThrowError();
 * ```
 *
 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
 */
var CyclicDependencyError = (function (_super) {
    __extends(CyclicDependencyError, _super);
    function CyclicDependencyError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
        });
    }
    return CyclicDependencyError;
})(AbstractProviderError);
exports.CyclicDependencyError = CyclicDependencyError;
/**
 * Thrown when a constructing type returns with an Error.
 *
 * The `InstantiationError` class contains the original error plus the dependency graph which caused
 * this object to be instantiated.
 *
 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor() {
 *     throw new Error('message');
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([A]);

 * try {
 *   injector.get(A);
 * } catch (e) {
 *   expect(e instanceof InstantiationError).toBe(true);
 *   expect(e.originalException.message).toEqual("message");
 *   expect(e.originalStack).toBeDefined();
 * }
 * ```
 */
var InstantiationError = (function (_super) {
    __extends(InstantiationError, _super);
    function InstantiationError(injector, originalException, originalStack, key) {
        _super.call(this, "DI Exception", originalException, originalStack, null);
        this.keys = [key];
        this.injectors = [injector];
    }
    InstantiationError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
    };
    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
        get: function () {
            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "causeKey", {
        get: function () { return this.keys[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return InstantiationError;
})(exceptions_1.WrappedException);
exports.InstantiationError = InstantiationError;
/**
 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
 * creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
 * ```
 */
var InvalidProviderError = (function (_super) {
    __extends(InvalidProviderError, _super);
    function InvalidProviderError(provider) {
        _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " +
            provider.toString());
    }
    return InvalidProviderError;
})(exceptions_1.BaseException);
exports.InvalidProviderError = InvalidProviderError;
/**
 * Thrown when the class has no annotation information.
 *
 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
 * need to be injected into the constructor.
 *
 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 *
 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
 *
 * ```typescript
 * class B {}
 *
 * class A {
 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
 * }
 *
 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
 * ```
 */
var NoAnnotationError = (function (_super) {
    __extends(NoAnnotationError, _super);
    function NoAnnotationError(typeOrFunc, params) {
        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
    }
    NoAnnotationError._genMessage = function (typeOrFunc, params) {
        var signature = [];
        for (var i = 0, ii = params.length; i < ii; i++) {
            var parameter = params[i];
            if (lang_1.isBlank(parameter) || parameter.length == 0) {
                signature.push('?');
            }
            else {
                signature.push(parameter.map(lang_1.stringify).join(' '));
            }
        }
        return "Cannot resolve all parameters for " + lang_1.stringify(typeOrFunc) + "(" +
            signature.join(', ') + "). " + 'Make sure they all have valid type or annotations.';
    };
    return NoAnnotationError;
})(exceptions_1.BaseException);
exports.NoAnnotationError = NoAnnotationError;
/**
 * Thrown when getting an object by index.
 *
 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
 *
 * ```typescript
 * class A {}
 *
 * var injector = Injector.resolveAndCreate([A]);
 *
 * expect(() => injector.getAt(100)).toThrowError();
 * ```
 */
var OutOfBoundsError = (function (_super) {
    __extends(OutOfBoundsError, _super);
    function OutOfBoundsError(index) {
        _super.call(this, "Index " + index + " is out-of-bounds.");
    }
    return OutOfBoundsError;
})(exceptions_1.BaseException);
exports.OutOfBoundsError = OutOfBoundsError;
// TODO: add a working example after alpha38 is released
/**
 * Thrown when a multi provider and a regular provider are bound to the same token.
 *
 * ### Example
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate([
 *   new Provider("Strings", {useValue: "string1", multi: true}),
 *   new Provider("Strings", {useValue: "string2", multi: false})
 * ])).toThrowError();
 * ```
 */
var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
        _super.call(this, "Cannot mix multi providers and regular providers, got: " + provider1.toString() + " " +
            provider2.toString());
    }
    return MixingMultiProvidersWithRegularProvidersError;
})(exceptions_1.BaseException);
exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
 *
 * ```typescript
 * class Door {
 *   lock: Lock;
 *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) {
 *     this.lock = lock;
 *   }
 * }
 *
 * // Only at this point Lock is defined.
 * class Lock {
 * }
 *
 * var injector = Injector.resolveAndCreate([Door, Lock]);
 * var door = injector.get(Door);
 * expect(door instanceof Door).toBe(true);
 * expect(door.lock instanceof Lock).toBe(true);
 * ```
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
    return forwardRefFn;
}
exports.forwardRef = forwardRef;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * ```typescript
 * var ref = forwardRef(() => "refValue");
 * expect(resolveForwardRef(ref)).toEqual("refValue");
 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
 * ```
 *
 * See: {@link forwardRef}
 */
function resolveForwardRef(type) {
    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
        type.__forward_ref__ === forwardRef) {
        return type();
    }
    else {
        return type;
    }
}
exports.resolveForwardRef = resolveForwardRef;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var provider_1 = require('./provider');
var exceptions_1 = require('./exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
var key_1 = require('./key');
var metadata_1 = require('./metadata');
// Threshold for the dynamic version
var _MAX_CONSTRUCTION_COUNTER = 10;
exports.UNDEFINED = lang_1.CONST_EXPR(new Object());
/**
 * Visibility of a {@link Provider}.
 */
(function (Visibility) {
    /**
     * A `Public` {@link Provider} is only visible to regular (as opposed to host) child injectors.
     */
    Visibility[Visibility["Public"] = 0] = "Public";
    /**
     * A `Private` {@link Provider} is only visible to host (as opposed to regular) child injectors.
     */
    Visibility[Visibility["Private"] = 1] = "Private";
    /**
     * A `PublicAndPrivate` {@link Provider} is visible to both host and regular child injectors.
     */
    Visibility[Visibility["PublicAndPrivate"] = 2] = "PublicAndPrivate";
})(exports.Visibility || (exports.Visibility = {}));
var Visibility = exports.Visibility;
function canSee(src, dst) {
    return (src === dst) ||
        (dst === Visibility.PublicAndPrivate || src === Visibility.PublicAndPrivate);
}
var ProtoInjectorInlineStrategy = (function () {
    function ProtoInjectorInlineStrategy(protoEI, bwv) {
        this.provider0 = null;
        this.provider1 = null;
        this.provider2 = null;
        this.provider3 = null;
        this.provider4 = null;
        this.provider5 = null;
        this.provider6 = null;
        this.provider7 = null;
        this.provider8 = null;
        this.provider9 = null;
        this.keyId0 = null;
        this.keyId1 = null;
        this.keyId2 = null;
        this.keyId3 = null;
        this.keyId4 = null;
        this.keyId5 = null;
        this.keyId6 = null;
        this.keyId7 = null;
        this.keyId8 = null;
        this.keyId9 = null;
        this.visibility0 = null;
        this.visibility1 = null;
        this.visibility2 = null;
        this.visibility3 = null;
        this.visibility4 = null;
        this.visibility5 = null;
        this.visibility6 = null;
        this.visibility7 = null;
        this.visibility8 = null;
        this.visibility9 = null;
        var length = bwv.length;
        if (length > 0) {
            this.provider0 = bwv[0].provider;
            this.keyId0 = bwv[0].getKeyId();
            this.visibility0 = bwv[0].visibility;
        }
        if (length > 1) {
            this.provider1 = bwv[1].provider;
            this.keyId1 = bwv[1].getKeyId();
            this.visibility1 = bwv[1].visibility;
        }
        if (length > 2) {
            this.provider2 = bwv[2].provider;
            this.keyId2 = bwv[2].getKeyId();
            this.visibility2 = bwv[2].visibility;
        }
        if (length > 3) {
            this.provider3 = bwv[3].provider;
            this.keyId3 = bwv[3].getKeyId();
            this.visibility3 = bwv[3].visibility;
        }
        if (length > 4) {
            this.provider4 = bwv[4].provider;
            this.keyId4 = bwv[4].getKeyId();
            this.visibility4 = bwv[4].visibility;
        }
        if (length > 5) {
            this.provider5 = bwv[5].provider;
            this.keyId5 = bwv[5].getKeyId();
            this.visibility5 = bwv[5].visibility;
        }
        if (length > 6) {
            this.provider6 = bwv[6].provider;
            this.keyId6 = bwv[6].getKeyId();
            this.visibility6 = bwv[6].visibility;
        }
        if (length > 7) {
            this.provider7 = bwv[7].provider;
            this.keyId7 = bwv[7].getKeyId();
            this.visibility7 = bwv[7].visibility;
        }
        if (length > 8) {
            this.provider8 = bwv[8].provider;
            this.keyId8 = bwv[8].getKeyId();
            this.visibility8 = bwv[8].visibility;
        }
        if (length > 9) {
            this.provider9 = bwv[9].provider;
            this.keyId9 = bwv[9].getKeyId();
            this.visibility9 = bwv[9].visibility;
        }
    }
    ProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
        if (index == 0)
            return this.provider0;
        if (index == 1)
            return this.provider1;
        if (index == 2)
            return this.provider2;
        if (index == 3)
            return this.provider3;
        if (index == 4)
            return this.provider4;
        if (index == 5)
            return this.provider5;
        if (index == 6)
            return this.provider6;
        if (index == 7)
            return this.provider7;
        if (index == 8)
            return this.provider8;
        if (index == 9)
            return this.provider9;
        throw new exceptions_1.OutOfBoundsError(index);
    };
    ProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
        return new InjectorInlineStrategy(injector, this);
    };
    return ProtoInjectorInlineStrategy;
})();
exports.ProtoInjectorInlineStrategy = ProtoInjectorInlineStrategy;
var ProtoInjectorDynamicStrategy = (function () {
    function ProtoInjectorDynamicStrategy(protoInj, bwv) {
        var len = bwv.length;
        this.providers = collection_1.ListWrapper.createFixedSize(len);
        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
        this.visibilities = collection_1.ListWrapper.createFixedSize(len);
        for (var i = 0; i < len; i++) {
            this.providers[i] = bwv[i].provider;
            this.keyIds[i] = bwv[i].getKeyId();
            this.visibilities[i] = bwv[i].visibility;
        }
    }
    ProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
        if (index < 0 || index >= this.providers.length) {
            throw new exceptions_1.OutOfBoundsError(index);
        }
        return this.providers[index];
    };
    ProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
        return new InjectorDynamicStrategy(this, ei);
    };
    return ProtoInjectorDynamicStrategy;
})();
exports.ProtoInjectorDynamicStrategy = ProtoInjectorDynamicStrategy;
var ProtoInjector = (function () {
    function ProtoInjector(bwv) {
        this.numberOfProviders = bwv.length;
        this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ?
            new ProtoInjectorDynamicStrategy(this, bwv) :
            new ProtoInjectorInlineStrategy(this, bwv);
    }
    ProtoInjector.prototype.getProviderAtIndex = function (index) { return this._strategy.getProviderAtIndex(index); };
    return ProtoInjector;
})();
exports.ProtoInjector = ProtoInjector;
var InjectorInlineStrategy = (function () {
    function InjectorInlineStrategy(injector, protoStrategy) {
        this.injector = injector;
        this.protoStrategy = protoStrategy;
        this.obj0 = exports.UNDEFINED;
        this.obj1 = exports.UNDEFINED;
        this.obj2 = exports.UNDEFINED;
        this.obj3 = exports.UNDEFINED;
        this.obj4 = exports.UNDEFINED;
        this.obj5 = exports.UNDEFINED;
        this.obj6 = exports.UNDEFINED;
        this.obj7 = exports.UNDEFINED;
        this.obj8 = exports.UNDEFINED;
        this.obj9 = exports.UNDEFINED;
    }
    InjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    InjectorInlineStrategy.prototype.instantiateProvider = function (provider, visibility) {
        return this.injector._new(provider, visibility);
    };
    InjectorInlineStrategy.prototype.attach = function (parent, isHost) {
        var inj = this.injector;
        inj._parent = parent;
        inj._isHost = isHost;
    };
    InjectorInlineStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
        var p = this.protoStrategy;
        var inj = this.injector;
        if (p.keyId0 === keyId && canSee(p.visibility0, visibility)) {
            if (this.obj0 === exports.UNDEFINED) {
                this.obj0 = inj._new(p.provider0, p.visibility0);
            }
            return this.obj0;
        }
        if (p.keyId1 === keyId && canSee(p.visibility1, visibility)) {
            if (this.obj1 === exports.UNDEFINED) {
                this.obj1 = inj._new(p.provider1, p.visibility1);
            }
            return this.obj1;
        }
        if (p.keyId2 === keyId && canSee(p.visibility2, visibility)) {
            if (this.obj2 === exports.UNDEFINED) {
                this.obj2 = inj._new(p.provider2, p.visibility2);
            }
            return this.obj2;
        }
        if (p.keyId3 === keyId && canSee(p.visibility3, visibility)) {
            if (this.obj3 === exports.UNDEFINED) {
                this.obj3 = inj._new(p.provider3, p.visibility3);
            }
            return this.obj3;
        }
        if (p.keyId4 === keyId && canSee(p.visibility4, visibility)) {
            if (this.obj4 === exports.UNDEFINED) {
                this.obj4 = inj._new(p.provider4, p.visibility4);
            }
            return this.obj4;
        }
        if (p.keyId5 === keyId && canSee(p.visibility5, visibility)) {
            if (this.obj5 === exports.UNDEFINED) {
                this.obj5 = inj._new(p.provider5, p.visibility5);
            }
            return this.obj5;
        }
        if (p.keyId6 === keyId && canSee(p.visibility6, visibility)) {
            if (this.obj6 === exports.UNDEFINED) {
                this.obj6 = inj._new(p.provider6, p.visibility6);
            }
            return this.obj6;
        }
        if (p.keyId7 === keyId && canSee(p.visibility7, visibility)) {
            if (this.obj7 === exports.UNDEFINED) {
                this.obj7 = inj._new(p.provider7, p.visibility7);
            }
            return this.obj7;
        }
        if (p.keyId8 === keyId && canSee(p.visibility8, visibility)) {
            if (this.obj8 === exports.UNDEFINED) {
                this.obj8 = inj._new(p.provider8, p.visibility8);
            }
            return this.obj8;
        }
        if (p.keyId9 === keyId && canSee(p.visibility9, visibility)) {
            if (this.obj9 === exports.UNDEFINED) {
                this.obj9 = inj._new(p.provider9, p.visibility9);
            }
            return this.obj9;
        }
        return exports.UNDEFINED;
    };
    InjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
        if (index == 0)
            return this.obj0;
        if (index == 1)
            return this.obj1;
        if (index == 2)
            return this.obj2;
        if (index == 3)
            return this.obj3;
        if (index == 4)
            return this.obj4;
        if (index == 5)
            return this.obj5;
        if (index == 6)
            return this.obj6;
        if (index == 7)
            return this.obj7;
        if (index == 8)
            return this.obj8;
        if (index == 9)
            return this.obj9;
        throw new exceptions_1.OutOfBoundsError(index);
    };
    InjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
    return InjectorInlineStrategy;
})();
exports.InjectorInlineStrategy = InjectorInlineStrategy;
var InjectorDynamicStrategy = (function () {
    function InjectorDynamicStrategy(protoStrategy, injector) {
        this.protoStrategy = protoStrategy;
        this.injector = injector;
        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
        collection_1.ListWrapper.fill(this.objs, exports.UNDEFINED);
    }
    InjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    InjectorDynamicStrategy.prototype.instantiateProvider = function (provider, visibility) {
        return this.injector._new(provider, visibility);
    };
    InjectorDynamicStrategy.prototype.attach = function (parent, isHost) {
        var inj = this.injector;
        inj._parent = parent;
        inj._isHost = isHost;
    };
    InjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
        var p = this.protoStrategy;
        for (var i = 0; i < p.keyIds.length; i++) {
            if (p.keyIds[i] === keyId && canSee(p.visibilities[i], visibility)) {
                if (this.objs[i] === exports.UNDEFINED) {
                    this.objs[i] = this.injector._new(p.providers[i], p.visibilities[i]);
                }
                return this.objs[i];
            }
        }
        return exports.UNDEFINED;
    };
    InjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
        if (index < 0 || index >= this.objs.length) {
            throw new exceptions_1.OutOfBoundsError(index);
        }
        return this.objs[index];
    };
    InjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
    return InjectorDynamicStrategy;
})();
exports.InjectorDynamicStrategy = InjectorDynamicStrategy;
var ProviderWithVisibility = (function () {
    function ProviderWithVisibility(provider, visibility) {
        this.provider = provider;
        this.visibility = visibility;
    }
    ;
    ProviderWithVisibility.prototype.getKeyId = function () { return this.provider.key.id; };
    return ProviderWithVisibility;
})();
exports.ProviderWithVisibility = ProviderWithVisibility;
/**
 * A dependency injection container used for instantiating objects and resolving dependencies.
 *
 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
 * constructor dependencies.
 *
 * In typical use, application code asks for the dependencies in the constructor and they are
 * resolved by the `Injector`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
 *
 * The following example creates an `Injector` configured to create `Engine` and `Car`.
 *
 * ```typescript
 * @Injectable()
 * class Engine {
 * }
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine:Engine) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([Car, Engine]);
 * var car = injector.get(Car);
 * expect(car instanceof Car).toBe(true);
 * expect(car.engine instanceof Engine).toBe(true);
 * ```
 *
 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
 * resolve all of the object's dependencies automatically.
 */
var Injector = (function () {
    /**
     * Private
     */
    function Injector(_proto /* ProtoInjector */, _parent, _depProvider, _debugContext) {
        if (_parent === void 0) { _parent = null; }
        if (_depProvider === void 0) { _depProvider = null; }
        if (_debugContext === void 0) { _debugContext = null; }
        this._depProvider = _depProvider;
        this._debugContext = _debugContext;
        /** @internal */
        this._isHost = false;
        /** @internal */
        this._constructionCounter = 0;
        this._proto = _proto;
        this._parent = _parent;
        this._strategy = _proto._strategy.createInjectorStrategy(this);
    }
    /**
     * Turns an array of provider definitions into an array of resolved providers.
     *
     * A resolution is a process of flattening multiple nested arrays and converting individual
     * providers into an array of {@link ResolvedProvider}s.
     *
     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = Injector.resolve([Car, [[Engine]]]);
     *
     * expect(providers.length).toEqual(2);
     *
     * expect(providers[0] instanceof ResolvedProvider).toBe(true);
     * expect(providers[0].key.displayName).toBe("Car");
     * expect(providers[0].dependencies.length).toEqual(1);
     * expect(providers[0].factory).toBeDefined();
     *
     * expect(providers[1].key.displayName).toBe("Engine");
     * });
     * ```
     *
     * See {@link Injector#fromResolvedProviders} for more info.
     */
    Injector.resolve = function (providers) {
        return provider_1.resolveProviders(providers);
    };
    /**
     * Resolves an array of providers and creates an injector from those providers.
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Car, Engine]);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     *
     * This function is slower than the corresponding `fromResolvedProviders`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
     */
    Injector.resolveAndCreate = function (providers) {
        var resolvedProviders = Injector.resolve(providers);
        return Injector.fromResolvedProviders(resolvedProviders);
    };
    /**
     * Creates an injector from previously resolved providers.
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = Injector.resolve([Car, Engine]);
     * var injector = Injector.fromResolvedProviders(providers);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     */
    Injector.fromResolvedProviders = function (providers) {
        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });
        var proto = new ProtoInjector(bd);
        return new Injector(proto, null, null);
    };
    /**
     * @deprecated
     */
    Injector.fromResolvedBindings = function (providers) {
        return Injector.fromResolvedProviders(providers);
    };
    /**
     * @internal
     */
    Injector.prototype.debugContext = function () { return this._debugContext(); };
    /**
     * Retrieves an instance from the injector based on the provided token.
     * Throws {@link NoProviderError} if not found.
     *
     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide("validToken", {useValue: "Value"})
     * ]);
     * expect(injector.get("validToken")).toEqual("Value");
     * expect(() => injector.get("invalidToken")).toThrowError();
     * ```
     *
     * `Injector` returns itself when given `Injector` as a token.
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([]);
     * expect(injector.get(Injector)).toBe(injector);
     * ```
     */
    Injector.prototype.get = function (token) {
        return this._getByKey(key_1.Key.get(token), null, null, false, Visibility.PublicAndPrivate);
    };
    /**
     * Retrieves an instance from the injector based on the provided token.
     * Returns null if not found.
     *
     * ### Example ([live demo](http://plnkr.co/edit/tpEbEy?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide("validToken", {useValue: "Value"})
     * ]);
     * expect(injector.getOptional("validToken")).toEqual("Value");
     * expect(injector.getOptional("invalidToken")).toBe(null);
     * ```
     *
     * `Injector` returns itself when given `Injector` as a token.
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([]);
     * expect(injector.getOptional(Injector)).toBe(injector);
     * ```
     */
    Injector.prototype.getOptional = function (token) {
        return this._getByKey(key_1.Key.get(token), null, null, true, Visibility.PublicAndPrivate);
    };
    /**
     * @internal
     */
    Injector.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
    Object.defineProperty(Injector.prototype, "parent", {
        /**
         * Parent of this injector.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
         *
         * ```typescript
         * var parent = Injector.resolveAndCreate([]);
         * var child = parent.resolveAndCreateChild([]);
         * expect(child.parent).toBe(parent);
         * ```
         */
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Injector.prototype, "internalStrategy", {
        /**
         * @internal
         * Internal. Do not use.
         * We return `any` not to export the InjectorStrategy type.
         */
        get: function () { return this._strategy; },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolves an array of providers and creates a child injector from those providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parent = Injector.resolveAndCreate([ParentProvider]);
     * var child = parent.resolveAndCreateChild([ChildProvider]);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     *
     * This function is slower than the corresponding `createChildFromResolved`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
     */
    Injector.prototype.resolveAndCreateChild = function (providers) {
        var resolvedProviders = Injector.resolve(providers);
        return this.createChildFromResolved(resolvedProviders);
    };
    /**
     * Creates a child injector from previously resolved providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parentProviders = Injector.resolve([ParentProvider]);
     * var childProviders = Injector.resolve([ChildProvider]);
     *
     * var parent = Injector.fromResolvedProviders(parentProviders);
     * var child = parent.createChildFromResolved(childProviders);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     */
    Injector.prototype.createChildFromResolved = function (providers) {
        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });
        var proto = new ProtoInjector(bd);
        var inj = new Injector(proto, null, null);
        inj._parent = this;
        return inj;
    };
    /**
     * Resolves a provider and instantiates an object in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Engine]);
     *
     * var car = injector.resolveAndInstantiate(Car);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
     * ```
     */
    Injector.prototype.resolveAndInstantiate = function (provider) {
        return this.instantiateResolved(Injector.resolve([provider])[0]);
    };
    /**
     * Instantiates an object using a resolved provider in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Engine]);
     * var carProvider = Injector.resolve([Car])[0];
     * var car = injector.instantiateResolved(carProvider);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
     * ```
     */
    Injector.prototype.instantiateResolved = function (provider) {
        return this._instantiateProvider(provider, Visibility.PublicAndPrivate);
    };
    /** @internal */
    Injector.prototype._new = function (provider, visibility) {
        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
            throw new exceptions_1.CyclicDependencyError(this, provider.key);
        }
        return this._instantiateProvider(provider, visibility);
    };
    Injector.prototype._instantiateProvider = function (provider, visibility) {
        if (provider.multiProvider) {
            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
            for (var i = 0; i < provider.resolvedFactories.length; ++i) {
                res[i] = this._instantiate(provider, provider.resolvedFactories[i], visibility);
            }
            return res;
        }
        else {
            return this._instantiate(provider, provider.resolvedFactories[0], visibility);
        }
    };
    Injector.prototype._instantiate = function (provider, resolvedFactory, visibility) {
        var factory = resolvedFactory.factory;
        var deps = resolvedFactory.dependencies;
        var length = deps.length;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19;
        try {
            d0 = length > 0 ? this._getByDependency(provider, deps[0], visibility) : null;
            d1 = length > 1 ? this._getByDependency(provider, deps[1], visibility) : null;
            d2 = length > 2 ? this._getByDependency(provider, deps[2], visibility) : null;
            d3 = length > 3 ? this._getByDependency(provider, deps[3], visibility) : null;
            d4 = length > 4 ? this._getByDependency(provider, deps[4], visibility) : null;
            d5 = length > 5 ? this._getByDependency(provider, deps[5], visibility) : null;
            d6 = length > 6 ? this._getByDependency(provider, deps[6], visibility) : null;
            d7 = length > 7 ? this._getByDependency(provider, deps[7], visibility) : null;
            d8 = length > 8 ? this._getByDependency(provider, deps[8], visibility) : null;
            d9 = length > 9 ? this._getByDependency(provider, deps[9], visibility) : null;
            d10 = length > 10 ? this._getByDependency(provider, deps[10], visibility) : null;
            d11 = length > 11 ? this._getByDependency(provider, deps[11], visibility) : null;
            d12 = length > 12 ? this._getByDependency(provider, deps[12], visibility) : null;
            d13 = length > 13 ? this._getByDependency(provider, deps[13], visibility) : null;
            d14 = length > 14 ? this._getByDependency(provider, deps[14], visibility) : null;
            d15 = length > 15 ? this._getByDependency(provider, deps[15], visibility) : null;
            d16 = length > 16 ? this._getByDependency(provider, deps[16], visibility) : null;
            d17 = length > 17 ? this._getByDependency(provider, deps[17], visibility) : null;
            d18 = length > 18 ? this._getByDependency(provider, deps[18], visibility) : null;
            d19 = length > 19 ? this._getByDependency(provider, deps[19], visibility) : null;
        }
        catch (e) {
            if (e instanceof exceptions_1.AbstractProviderError || e instanceof exceptions_1.InstantiationError) {
                e.addKey(this, provider.key);
            }
            throw e;
        }
        var obj;
        try {
            switch (length) {
                case 0:
                    obj = factory();
                    break;
                case 1:
                    obj = factory(d0);
                    break;
                case 2:
                    obj = factory(d0, d1);
                    break;
                case 3:
                    obj = factory(d0, d1, d2);
                    break;
                case 4:
                    obj = factory(d0, d1, d2, d3);
                    break;
                case 5:
                    obj = factory(d0, d1, d2, d3, d4);
                    break;
                case 6:
                    obj = factory(d0, d1, d2, d3, d4, d5);
                    break;
                case 7:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
                    break;
                case 8:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                    break;
                case 9:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                    break;
                case 10:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                    break;
                case 11:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                    break;
                case 12:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                    break;
                case 13:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                    break;
                case 14:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                    break;
                case 15:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                    break;
                case 16:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                    break;
                case 17:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                    break;
                case 18:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                    break;
                case 19:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                    break;
                case 20:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                    break;
            }
        }
        catch (e) {
            throw new exceptions_1.InstantiationError(this, e, e.stack, provider.key);
        }
        return obj;
    };
    Injector.prototype._getByDependency = function (provider, dep, providerVisibility) {
        var special = lang_1.isPresent(this._depProvider) ?
            this._depProvider.getDependency(this, provider, dep) :
            exports.UNDEFINED;
        if (special !== exports.UNDEFINED) {
            return special;
        }
        else {
            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional, providerVisibility);
        }
    };
    Injector.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, optional, providerVisibility) {
        if (key === INJECTOR_KEY) {
            return this;
        }
        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
            return this._getByKeySelf(key, optional, providerVisibility);
        }
        else if (upperBoundVisibility instanceof metadata_1.HostMetadata) {
            return this._getByKeyHost(key, optional, providerVisibility, lowerBoundVisibility);
        }
        else {
            return this._getByKeyDefault(key, optional, providerVisibility, lowerBoundVisibility);
        }
    };
    /** @internal */
    Injector.prototype._throwOrNull = function (key, optional) {
        if (optional) {
            return null;
        }
        else {
            throw new exceptions_1.NoProviderError(this, key);
        }
    };
    /** @internal */
    Injector.prototype._getByKeySelf = function (key, optional, providerVisibility) {
        var obj = this._strategy.getObjByKeyId(key.id, providerVisibility);
        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getByKeyHost = function (key, optional, providerVisibility, lowerBoundVisibility) {
        var inj = this;
        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
            if (inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
            }
            else {
                inj = inj._parent;
            }
        }
        while (inj != null) {
            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
            if (obj !== exports.UNDEFINED)
                return obj;
            if (lang_1.isPresent(inj._parent) && inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
            }
            else {
                inj = inj._parent;
            }
        }
        return this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getPrivateDependency = function (key, optional, inj) {
        var obj = inj._parent._strategy.getObjByKeyId(key.id, Visibility.Private);
        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getByKeyDefault = function (key, optional, providerVisibility, lowerBoundVisibility) {
        var inj = this;
        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
            providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
            inj = inj._parent;
        }
        while (inj != null) {
            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
            if (obj !== exports.UNDEFINED)
                return obj;
            providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
            inj = inj._parent;
        }
        return this._throwOrNull(key, optional);
    };
    Object.defineProperty(Injector.prototype, "displayName", {
        get: function () {
            return "Injector(providers: [" + _mapProviders(this, function (b) { return (" \"" + b.key.displayName + "\" "); }).join(", ") + "])";
        },
        enumerable: true,
        configurable: true
    });
    Injector.prototype.toString = function () { return this.displayName; };
    return Injector;
})();
exports.Injector = Injector;
var INJECTOR_KEY = key_1.Key.get(Injector);
function _mapProviders(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
        res.push(fn(injector._proto.getProviderAtIndex(i)));
    }
    return res;
}

},{"./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","./provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var type_literal_1 = require('./type_literal');
var forward_ref_1 = require('./forward_ref');
var type_literal_2 = require('./type_literal');
exports.TypeLiteral = type_literal_2.TypeLiteral;
/**
 * A unique object used for retrieving items from the {@link Injector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link Injector} because its system-wide unique `id` allows the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link Injector} creates keys automatically when resolving
 * providers.
 */
var Key = (function () {
    /**
     * Private
     */
    function Key(token, id) {
        this.token = token;
        this.id = id;
        if (lang_1.isBlank(token)) {
            throw new exceptions_1.BaseException('Token must be defined!');
        }
    }
    Object.defineProperty(Key.prototype, "displayName", {
        /**
         * Returns a stringified token.
         */
        get: function () { return lang_1.stringify(this.token); },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves a `Key` for a token.
     */
    Key.get = function (token) { return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token)); };
    Object.defineProperty(Key, "numberOfKeys", {
        /**
         * @returns the number of keys registered in the system.
         */
        get: function () { return _globalKeyRegistry.numberOfKeys; },
        enumerable: true,
        configurable: true
    });
    return Key;
})();
exports.Key = Key;
/**
 * @internal
 */
var KeyRegistry = (function () {
    function KeyRegistry() {
        this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function (token) {
        if (token instanceof Key)
            return token;
        // TODO: workaround for https://github.com/Microsoft/TypeScript/issues/3123
        var theToken = token;
        if (token instanceof type_literal_1.TypeLiteral) {
            theToken = token.type;
        }
        token = theToken;
        if (this._allKeys.has(token)) {
            return this._allKeys.get(token);
        }
        var newKey = new Key(token, Key.numberOfKeys);
        this._allKeys.set(token, newKey);
        return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
        get: function () { return this._allKeys.size; },
        enumerable: true,
        configurable: true
    });
    return KeyRegistry;
})();
exports.KeyRegistry = KeyRegistry;
var _globalKeyRegistry = new KeyRegistry();

},{"./forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./type_literal":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/type_literal.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require("angular2/src/core/facade/lang");
/**
 * A parameter metadata that specifies a dependency.
 *
 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Inject("MyEngine") engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([
 *  provide("MyEngine", {useClass: Engine}),
 *  Car
 * ]);
 *
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 *
 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
 *
 * ### Example
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
 * }
 *
 * var injector = Injector.resolveAndCreate([Engine, Car]);
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 */
var InjectMetadata = (function () {
    function InjectMetadata(token) {
        this.token = token;
    }
    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
    InjectMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], InjectMetadata);
    return InjectMetadata;
})();
exports.InjectMetadata = InjectMetadata;
/**
 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
 * the dependency is not found.
 *
 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Optional() engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([Car]);
 * expect(injector.get(Car).engine).toBeNull();
 * ```
 */
var OptionalMetadata = (function () {
    function OptionalMetadata() {
    }
    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
    OptionalMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], OptionalMetadata);
    return OptionalMetadata;
})();
exports.OptionalMetadata = OptionalMetadata;
/**
 * `DependencyMetadata` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
var DependencyMetadata = (function () {
    function DependencyMetadata() {
    }
    Object.defineProperty(DependencyMetadata.prototype, "token", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    DependencyMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DependencyMetadata);
    return DependencyMetadata;
})();
exports.DependencyMetadata = DependencyMetadata;
/**
 * A marker metadata that marks a class as available to {@link Injector} for creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
 *
 * ```typescript
 * @Injectable()
 * class UsefulService {}
 *
 * @Injectable()
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
 * ```
 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
 * does not have `@Injectable` marker, as shown in the example below.
 *
 * ```typescript
 * class UsefulService {}
 *
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(() => injector.get(NeedsService)).toThrowError();
 * ```
 */
var InjectableMetadata = (function () {
    function InjectableMetadata() {
    }
    InjectableMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], InjectableMetadata);
    return InjectableMetadata;
})();
exports.InjectableMetadata = InjectableMetadata;
/**
 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
 *
 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;

 *   dependency;
 *   constructor(@Self() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * var nd = inj.get(NeedsDependency);
 *
 * expect(nd.dependency instanceof Dependency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency]);
 * var child = inj.resolveAndCreateChild([NeedsDependency]);
 * expect(() => child.get(NeedsDependency)).toThrowError();
 * ```
 */
var SelfMetadata = (function () {
    function SelfMetadata() {
    }
    SelfMetadata.prototype.toString = function () { return "@Self()"; };
    SelfMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], SelfMetadata);
    return SelfMetadata;
})();
exports.SelfMetadata = SelfMetadata;
/**
 * Specifies that the dependency resolution should start from the parent injector.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@SkipSelf() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var parent = Injector.resolveAndCreate([Dependency]);
 * var child = parent.resolveAndCreateChild([NeedsDependency]);
 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * expect(() => inj.get(NeedsDependency)).toThrowError();
 * ```
 */
var SkipSelfMetadata = (function () {
    function SkipSelfMetadata() {
    }
    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
    SkipSelfMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], SkipSelfMetadata);
    return SkipSelfMetadata;
})();
exports.SkipSelfMetadata = SkipSelfMetadata;
/**
 * Specifies that an injector should retrieve a dependency from any injector until reaching the
 * closest host.
 *
 * In Angular, a component element is automatically declared as a host for all the injectors in
 * its view.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
 *
 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
 * So `ParentCmp` is the host of `ChildDirective`.
 *
 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
 *
 *```typescript
 * class OtherService {}
 * class HostService {}
 *
 * @Directive({
 *   selector: 'child-directive'
 * })
 * class ChildDirective {
 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
 *     console.log("os is null", os);
 *     console.log("hs is NOT null", hs);
 *   }
 * }
 *
 * @Component({
 *   selector: 'parent-cmp',
 *   providers: [HostService],
 *   template: `
 *     Dir: <child-directive></child-directive>
 *   `,
 *   directives: [ChildDirective]
 * })
 * class ParentCmp {
 * }
 *
 * @Component({
 *   selector: 'app',
 *   providers: [OtherService],
 *   template: `
 *     Parent: <parent-cmp></parent-cmp>
 *   `,
 *   directives: [ParentCmp]
 * })
 * class App {
 * }
 *
 * bootstrap(App);
 *```
 */
var HostMetadata = (function () {
    function HostMetadata() {
    }
    HostMetadata.prototype.toString = function () { return "@Host()"; };
    HostMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], HostMetadata);
    return HostMetadata;
})();
exports.HostMetadata = HostMetadata;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/opaque_token.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Creates a token that can be used in a DI Provider.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
 *
 * ```typescript
 * var t = new OpaqueToken("value");
 *
 * var injector = Injector.resolveAndCreate([
 *   provide(t, {useValue: "providedValue"})
 * ]);
 *
 * expect(injector.get(t)).toEqual("bindingValue");
 * ```
 *
 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
 * caused by multiple providers using the same string as two different tokens.
 *
 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
 * error messages.
 */
var OpaqueToken = (function () {
    function OpaqueToken(_desc) {
        this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
    OpaqueToken = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], OpaqueToken);
    return OpaqueToken;
})();
exports.OpaqueToken = OpaqueToken;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var key_1 = require('./key');
var metadata_1 = require('./metadata');
var exceptions_2 = require('./exceptions');
var forward_ref_1 = require('./forward_ref');
var Dependency = (function () {
    function Dependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
        this.key = key;
        this.optional = optional;
        this.lowerBoundVisibility = lowerBoundVisibility;
        this.upperBoundVisibility = upperBoundVisibility;
        this.properties = properties;
    }
    Dependency.fromKey = function (key) { return new Dependency(key, false, null, null, []); };
    return Dependency;
})();
exports.Dependency = Dependency;
var _EMPTY_LIST = lang_1.CONST_EXPR([]);
/**
 * Describes how the {@link Injector} should instantiate a given token.
 *
 * See {@link provide}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
 *
 * ```javascript
 * var injector = Injector.resolveAndCreate([
 *   new Provider("message", { useValue: 'Hello' })
 * ]);
 *
 * expect(injector.get("message")).toEqual('Hello');
 * ```
 */
var Provider = (function () {
    function Provider(token, _a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        this.token = token;
        this.useClass = useClass;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory;
        this.dependencies = deps;
        this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
        // TODO: Provide a full working example after alpha38 is released.
        /**
         * Creates multiple providers matching the same token (a multi-provider).
         *
         * Multi-providers are used for creating pluggable service, where the system comes
         * with some default providers, and the user can register additonal providers.
         * The combination of the default providers and the additional providers will be
         * used to drive the behavior of the system.
         *
         * ### Example
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true}),
         *   new Provider("Strings", { useValue: "String2", multi: true})
         * ]);
         *
         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
         * ```
         *
         * Multi-providers and regular providers cannot be mixed. The following
         * will throw an exception:
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true }),
         *   new Provider("Strings", { useValue: "String2"})
         * ]);
         * ```
         */
        get: function () { return lang_1.normalizeBool(this._multi); },
        enumerable: true,
        configurable: true
    });
    Provider = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], Provider);
    return Provider;
})();
exports.Provider = Provider;
/**
 * @deprecated
 */
var Binding = (function (_super) {
    __extends(Binding, _super);
    function Binding(token, _a) {
        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
        _super.call(this, token, {
            useClass: toClass,
            useValue: toValue,
            useExisting: toAlias,
            useFactory: toFactory,
            deps: deps,
            multi: multi
        });
    }
    Object.defineProperty(Binding.prototype, "toClass", {
        /**
         * @deprecated
         */
        get: function () { return this.useClass; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toAlias", {
        /**
         * @deprecated
         */
        get: function () { return this.useExisting; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toFactory", {
        /**
         * @deprecated
         */
        get: function () { return this.useFactory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toValue", {
        /**
         * @deprecated
         */
        get: function () { return this.useValue; },
        enumerable: true,
        configurable: true
    });
    Binding = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], Binding);
    return Binding;
})(Provider);
exports.Binding = Binding;
var ResolvedProvider_ = (function () {
    function ResolvedProvider_(key, resolvedFactories, multiProvider) {
        this.key = key;
        this.resolvedFactories = resolvedFactories;
        this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedProvider_.prototype, "resolvedFactory", {
        get: function () { return this.resolvedFactories[0]; },
        enumerable: true,
        configurable: true
    });
    return ResolvedProvider_;
})();
exports.ResolvedProvider_ = ResolvedProvider_;
/**
 * An internal resolved representation of a factory function created by resolving {@link Provider}.
 */
var ResolvedFactory = (function () {
    function ResolvedFactory(
        /**
         * Factory function which can return an instance of an object represented by a key.
         */
        factory, 
        /**
         * Arguments (dependencies) to the `factory` function.
         */
        dependencies) {
        this.factory = factory;
        this.dependencies = dependencies;
    }
    return ResolvedFactory;
})();
exports.ResolvedFactory = ResolvedFactory;
/**
 * @deprecated
 * Creates a {@link Provider}.
 *
 * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,
 * or
 * to an existing `token`.
 * See {@link ProviderBuilder} for more details.
 *
 * The `token` is most commonly a class or {@link angular2/di/OpaqueToken}.
 */
function bind(token) {
    return new ProviderBuilder(token);
}
exports.bind = bind;
/**
 * Creates a {@link Provider}.
 *
 * See {@link Provider} for more details.
 *
 * <!-- TODO: improve the docs -->
 */
function provide(token, _a) {
    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
    return new Provider(token, {
        useClass: useClass,
        useValue: useValue,
        useExisting: useExisting,
        useFactory: useFactory,
        deps: deps,
        multi: multi
    });
}
exports.provide = provide;
/**
 * Helper class for the {@link bind} function.
 */
var ProviderBuilder = (function () {
    function ProviderBuilder(token) {
        this.token = token;
    }
    /**
     * Binds a DI token to a class.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
     * easy comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toClass = function (type) {
        if (!lang_1.isType(type)) {
            throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
        }
        return new Provider(this.token, { useClass: type });
    };
    /**
     * Binds a DI token to a value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide('message', {useValue: 'Hello'})
     * ]);
     *
     * expect(injector.get('message')).toEqual('Hello');
     * ```
     */
    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };
    /**
     * Binds a DI token to an existing token.
     *
     * Angular will return the same instance as if the provided token was used. (This is
     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
     *
     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
     * easy
     * comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toAlias = function (aliasToken) {
        if (lang_1.isBlank(aliasToken)) {
            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
        }
        return new Provider(this.token, { useExisting: aliasToken });
    };
    /**
     * Binds a DI token to a function which computes the value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide(Number, {useFactory: () => { return 1+2; }}),
     *   provide(String, {useFactory: (v) => { return "Value: " + v; }, deps: [Number]})
     * ]);
     *
     * expect(injector.get(Number)).toEqual(3);
     * expect(injector.get(String)).toEqual('Value: 3');
     * ```
     */
    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {
        if (!lang_1.isFunction(factory)) {
            throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
        }
        return new Provider(this.token, { useFactory: factory, deps: dependencies });
    };
    return ProviderBuilder;
})();
exports.ProviderBuilder = ProviderBuilder;
/**
 * Resolve a single provider.
 */
function resolveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (lang_1.isPresent(provider.useClass)) {
        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
        factoryFn = reflection_1.reflector.factory(useClass);
        resolvedDeps = _dependenciesFor(useClass);
    }
    else if (lang_1.isPresent(provider.useExisting)) {
        factoryFn = function (aliasInstance) { return aliasInstance; };
        resolvedDeps = [Dependency.fromKey(key_1.Key.get(provider.useExisting))];
    }
    else if (lang_1.isPresent(provider.useFactory)) {
        factoryFn = provider.useFactory;
        resolvedDeps = _constructDependencies(provider.useFactory, provider.dependencies);
    }
    else {
        factoryFn = function () { return provider.useValue; };
        resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedFactory(factoryFn, resolvedDeps);
}
exports.resolveFactory = resolveFactory;
/**
 * Converts the {@link Provider} into {@link ResolvedProvider}.
 *
 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
 * convenience provider syntax.
 */
function resolveProvider(provider) {
    return new ResolvedProvider_(key_1.Key.get(provider.token), [resolveFactory(provider)], false);
}
exports.resolveProvider = resolveProvider;
/**
 * Resolve a list of Providers.
 */
function resolveProviders(providers) {
    var normalized = _createListOfProviders(_normalizeProviders(providers, new Map()));
    return normalized.map(function (b) {
        if (b instanceof _NormalizedProvider) {
            return new ResolvedProvider_(b.key, [b.resolvedFactory], false);
        }
        else {
            var arr = b;
            return new ResolvedProvider_(arr[0].key, arr.map(function (_) { return _.resolvedFactory; }), true);
        }
    });
}
exports.resolveProviders = resolveProviders;
/**
 * The algorithm works as follows:
 *
 * [Provider] -> [_NormalizedProvider|[_NormalizedProvider]] -> [ResolvedProvider]
 *
 * _NormalizedProvider is essentially a resolved provider before it was grouped by key.
 */
var _NormalizedProvider = (function () {
    function _NormalizedProvider(key, resolvedFactory) {
        this.key = key;
        this.resolvedFactory = resolvedFactory;
    }
    return _NormalizedProvider;
})();
function _createListOfProviders(flattenedProviders) {
    return collection_1.MapWrapper.values(flattenedProviders);
}
function _normalizeProviders(providers, res) {
    providers.forEach(function (b) {
        if (b instanceof lang_1.Type) {
            _normalizeProvider(provide(b, { useClass: b }), res);
        }
        else if (b instanceof Provider) {
            _normalizeProvider(b, res);
        }
        else if (b instanceof Array) {
            _normalizeProviders(b, res);
        }
        else if (b instanceof ProviderBuilder) {
            throw new exceptions_2.InvalidProviderError(b.token);
        }
        else {
            throw new exceptions_2.InvalidProviderError(b);
        }
    });
    return res;
}
function _normalizeProvider(b, res) {
    var key = key_1.Key.get(b.token);
    var factory = resolveFactory(b);
    var normalized = new _NormalizedProvider(key, factory);
    if (b.multi) {
        var existingProvider = res.get(key.id);
        if (existingProvider instanceof Array) {
            existingProvider.push(normalized);
        }
        else if (lang_1.isBlank(existingProvider)) {
            res.set(key.id, [normalized]);
        }
        else {
            throw new exceptions_2.MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
        }
    }
    else {
        var existingProvider = res.get(key.id);
        if (existingProvider instanceof Array) {
            throw new exceptions_2.MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
        }
        res.set(key.id, normalized);
    }
}
function _constructDependencies(factoryFunction, dependencies) {
    if (lang_1.isBlank(dependencies)) {
        return _dependenciesFor(factoryFunction);
    }
    else {
        var params = dependencies.map(function (t) { return [t]; });
        return dependencies.map(function (t) { return _extractToken(factoryFunction, t, params); });
    }
}
function _dependenciesFor(typeOrFunc) {
    var params = reflection_1.reflector.parameters(typeOrFunc);
    if (lang_1.isBlank(params))
        return [];
    if (collection_1.ListWrapper.any(params, function (p) { return lang_1.isBlank(p); })) {
        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
    }
    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
}
function _extractToken(typeOrFunc, metadata /*any[] | any*/, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!lang_1.isArray(metadata)) {
        return _createDependency(metadata, optional, null, null, depProps);
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
        var paramMetadata = metadata[i];
        if (paramMetadata instanceof lang_1.Type) {
            token = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
            token = paramMetadata.token;
        }
        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
            optional = true;
        }
        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.HostMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
            lowerBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
            if (lang_1.isPresent(paramMetadata.token)) {
                token = paramMetadata.token;
            }
            depProps.push(paramMetadata);
        }
    }
    token = forward_ref_1.resolveForwardRef(token);
    if (lang_1.isPresent(token)) {
        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }
    else {
        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
    }
}
function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new Dependency(key_1.Key.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
}

},{"./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/type_literal.js":[function(require,module,exports){
'use strict';/**
 * Type literals is a Dart-only feature. This is here only so we can x-compile
 * to multiple languages.
 */
var TypeLiteral = (function () {
    function TypeLiteral() {
    }
    Object.defineProperty(TypeLiteral.prototype, "type", {
        get: function () { throw new Error("Type literals are only supported in Dart"); },
        enumerable: true,
        configurable: true
    });
    return TypeLiteral;
})();
exports.TypeLiteral = TypeLiteral;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Common directives shipped with Angular.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var lang_1 = require('./facade/lang');
var ng_class_1 = require('./directives/ng_class');
var ng_for_1 = require('./directives/ng_for');
var ng_if_1 = require('./directives/ng_if');
var ng_style_1 = require('./directives/ng_style');
var ng_switch_1 = require('./directives/ng_switch');
var ng_class_2 = require('./directives/ng_class');
exports.NgClass = ng_class_2.NgClass;
var ng_for_2 = require('./directives/ng_for');
exports.NgFor = ng_for_2.NgFor;
var ng_if_2 = require('./directives/ng_if');
exports.NgIf = ng_if_2.NgIf;
var ng_style_2 = require('./directives/ng_style');
exports.NgStyle = ng_style_2.NgStyle;
var ng_switch_2 = require('./directives/ng_switch');
exports.NgSwitch = ng_switch_2.NgSwitch;
exports.NgSwitchWhen = ng_switch_2.NgSwitchWhen;
exports.NgSwitchDefault = ng_switch_2.NgSwitchDefault;
__export(require('./directives/observable_list_diff'));
/**
 * A collection of Angular core directives that are likely to be used in each and every Angular
 * application.
 *
 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
 * property of the `@View` annotation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
 *
 * Instead of writing:
 *
 * ```typescript
 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 * one could import all the core directives at once:
 *
 * ```typescript
 * import {CORE_DIRECTIVES} from 'angular2/angular2';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [CORE_DIRECTIVES, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 */
exports.CORE_DIRECTIVES = lang_1.CONST_EXPR([ng_class_1.NgClass, ng_for_1.NgFor, ng_if_1.NgIf, ng_style_1.NgStyle, ng_switch_1.NgSwitch, ng_switch_1.NgSwitchWhen, ng_switch_1.NgSwitchDefault]);

},{"./directives/ng_class":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_class.js","./directives/ng_for":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_for.js","./directives/ng_if":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_if.js","./directives/ng_style":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_style.js","./directives/ng_switch":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_switch.js","./directives/observable_list_diff":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/observable_list_diff.js","./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_class.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var change_detection_1 = require('angular2/src/core/change_detection');
var render_1 = require('angular2/src/core/render');
var collection_1 = require('angular2/src/core/facade/collection');
/**
 * The `NgClass` directive conditionally adds and removes CSS classes on an HTML element based on
 * an expression's evaluation result.
 *
 * The result of an expression evaluation is interpreted differently depending on type of
 * the expression evaluation result:
 * - `string` - all the CSS classes listed in a string (space delimited) are added
 * - `Array` - all the CSS classes (Array elements) are added
 * - `Object` - each key corresponds to a CSS class name while values are interpreted as expressions
 * evaluating to `Boolean`. If a given expression evaluates to `true` a corresponding CSS class
 * is added - otherwise it is removed.
 *
 * While the `NgClass` directive can interpret expressions evaluating to `string`, `Array`
 * or `Object`, the `Object`-based version is the most often used and has an advantage of keeping
 * all the CSS class names in a template.
 *
 * ### Example ([live demo](http://plnkr.co/edit/a4YdtmWywhJ33uqfpPPn?p=preview)):
 *
 * ```
 * import {Component, NgClass} from 'angular2/angular2';
 *
 * @Component({
 *   selector: 'toggle-button',
 *   inputs: ['isDisabled'],
 *   template: `
 *      <div class="button" [ng-class]="{active: isOn, disabled: isDisabled}"
 *          (click)="toggle(!isOn)">
 *          Click me!
 *      </div>`,
 *   styles: [`
 *     .button {
 *       width: 120px;
 *       border: medium solid black;
 *     }
 *
 *     .active {
 *       background-color: red;
 *    }
 *
 *     .disabled {
 *       color: gray;
 *       border: medium solid gray;
 *     }
 *   `]
 *   directives: [NgClass]
 * })
 * class ToggleButton {
 *   isOn = false;
 *   isDisabled = false;
 *
 *   toggle(newState) {
 *     if (!this.isDisabled) {
 *       this.isOn = newState;
 *     }
 *   }
 * }
 * ```
 */
var NgClass = (function () {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "initialClasses", {
        set: function (v) {
            this._applyInitialClasses(true);
            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
            this._applyInitialClasses(false);
            this._applyClasses(this._rawClass, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgClass.prototype, "rawClass", {
        set: function (v) {
            this._cleanupClasses(this._rawClass);
            if (lang_1.isString(v)) {
                v = v.split(' ');
            }
            this._rawClass = v;
            if (lang_1.isPresent(v)) {
                if (collection_1.isListLikeIterable(v)) {
                    this._differ = this._iterableDiffers.find(v).create(null);
                    this._mode = 'iterable';
                }
                else {
                    this._differ = this._keyValueDiffers.find(v).create(null);
                    this._mode = 'keyValue';
                }
            }
            else {
                this._differ = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    NgClass.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawClass);
            if (lang_1.isPresent(changes)) {
                if (this._mode == 'iterable') {
                    this._applyIterableChanges(changes);
                }
                else {
                    this._applyKeyValueChanges(changes);
                }
            }
        }
    };
    NgClass.prototype.onDestroy = function () { this._cleanupClasses(this._rawClass); };
    NgClass.prototype._cleanupClasses = function (rawClassVal) {
        this._applyClasses(rawClassVal, true);
        this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    NgClass.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });
        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });
    };
    NgClass.prototype._applyInitialClasses = function (isCleanup) {
        var _this = this;
        this._initialClasses.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
    };
    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
        var _this = this;
        if (lang_1.isPresent(rawClassVal)) {
            if (collection_1.isListLikeIterable(rawClassVal)) {
                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
            }
            else {
                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {
                    if (expVal)
                        _this._toggleClass(className, !isCleanup);
                });
            }
        }
    };
    NgClass.prototype._toggleClass = function (className, enabled) {
        className = className.trim();
        if (className.length > 0) {
            this._renderer.setElementClass(this._ngEl, className, enabled);
        }
    };
    NgClass = __decorate([
        metadata_1.Directive({ selector: '[ng-class]', inputs: ['rawClass: ng-class', 'initialClasses: class'] }), 
        __metadata('design:paramtypes', [change_detection_1.IterableDiffers, change_detection_1.KeyValueDiffers, linker_1.ElementRef, render_1.Renderer])
    ], NgClass);
    return NgClass;
})();
exports.NgClass = NgClass;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_for.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var change_detection_1 = require('angular2/src/core/change_detection');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `NgFor` directive instantiates a template once per item from an iterable. The context for
 * each instantiated template inherits from the outer context with the given loop variable set
 * to the current item from the iterable.
 *
 * It is possible to alias the `index` to a local variable that will be set to the current loop
 * iteration in the template context, and also to alias the 'last' to a local variable that will
 * be set to a boolean indicating if the item is the last one in the iteration
 *
 * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
 *
 * * When an item is added, a new instance of the template is added to the DOM.
 * * When an item is removed, its template instance is removed from the DOM.
 * * When items are reordered, their respective templates are reordered in the DOM.
 *
 * # Example
 *
 * ```
 * <ul>
 *   <li *ng-for="#error of errors; #i = index">
 *     Error {{i}} of {{errors.length}}: {{error.message}}
 *   </li>
 * </ul>
 * ```
 *
 * # Syntax
 *
 * - `<li *ng-for="#item of items; #i = index">...</li>`
 * - `<li template="ng-for #item of items; #i = index">...</li>`
 * - `<template ng-for #item [ng-for-of]="items" #i="index"><li>...</li></template>`
 */
var NgFor = (function () {
    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._iterableDiffers = _iterableDiffers;
        this._cdr = _cdr;
    }
    Object.defineProperty(NgFor.prototype, "ngForOf", {
        set: function (value) {
            this._ngForOf = value;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
                this._differ = this._iterableDiffers.find(value).create(this._cdr);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
        set: function (value) { this._templateRef = value; },
        enumerable: true,
        configurable: true
    });
    NgFor.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._ngForOf);
            if (lang_1.isPresent(changes))
                this._applyChanges(changes);
        }
    };
    NgFor.prototype._applyChanges = function (changes) {
        // TODO(rado): check if change detection can produce a change record that is
        // easier to consume than current.
        var recordViewTuples = [];
        changes.forEachRemovedItem(function (removedRecord) {
            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
        });
        changes.forEachMovedItem(function (movedRecord) {
            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
        });
        var insertTuples = this._bulkRemove(recordViewTuples);
        changes.forEachAddedItem(function (addedRecord) {
            return insertTuples.push(new RecordViewTuple(addedRecord, null));
        });
        this._bulkInsert(insertTuples);
        for (var i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
        }
        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
            this._viewContainer.get(i).setLocal('last', i === ilen - 1);
        }
    };
    NgFor.prototype._perViewChange = function (view, record) {
        view.setLocal('\$implicit', record.item);
        view.setLocal('index', record.currentIndex);
        view.setLocal('even', (record.currentIndex % 2 == 0));
        view.setLocal('odd', (record.currentIndex % 2 == 1));
    };
    NgFor.prototype._bulkRemove = function (tuples) {
        tuples.sort(function (a, b) { return a.record.previousIndex - b.record.previousIndex; });
        var movedTuples = [];
        for (var i = tuples.length - 1; i >= 0; i--) {
            var tuple = tuples[i];
            // separate moved views from removed views.
            if (lang_1.isPresent(tuple.record.currentIndex)) {
                tuple.view = this._viewContainer.detach(tuple.record.previousIndex);
                movedTuples.push(tuple);
            }
            else {
                this._viewContainer.remove(tuple.record.previousIndex);
            }
        }
        return movedTuples;
    };
    NgFor.prototype._bulkInsert = function (tuples) {
        tuples.sort(function (a, b) { return a.record.currentIndex - b.record.currentIndex; });
        for (var i = 0; i < tuples.length; i++) {
            var tuple = tuples[i];
            if (lang_1.isPresent(tuple.view)) {
                this._viewContainer.insert(tuple.view, tuple.record.currentIndex);
            }
            else {
                tuple.view =
                    this._viewContainer.createEmbeddedView(this._templateRef, tuple.record.currentIndex);
            }
        }
        return tuples;
    };
    NgFor = __decorate([
        metadata_1.Directive({ selector: '[ng-for][ng-for-of]', inputs: ['ngForOf', 'ngForTemplate'] }), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, change_detection_1.IterableDiffers, change_detection_1.ChangeDetectorRef])
    ], NgFor);
    return NgFor;
})();
exports.NgFor = NgFor;
var RecordViewTuple = (function () {
    function RecordViewTuple(record, view) {
        this.record = record;
        this.view = view;
    }
    return RecordViewTuple;
})();

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_if.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Removes or recreates a portion of the DOM tree based on an {expression}.
 *
 * If the expression assigned to `ng-if` evaluates to a false value then the element
 * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
 *
 * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
 *
 * ```
 * <div *ng-if="errorCount > 0" class="error">
 *   <!-- Error message displayed when the errorCount property on the current context is greater
 * than 0. -->
 *   {{errorCount}} errors detected
 * </div>
 * ```
 *
 * # Syntax
 *
 * - `<div *ng-if="condition">...</div>`
 * - `<div template="ng-if condition">...</div>`
 * - `<template [ng-if]="condition"><div>...</div></template>`
 */
var NgIf = (function () {
    function NgIf(_viewContainer, _templateRef) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._prevCondition = null;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
        set: function (newCondition /* boolean */) {
            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
                this._prevCondition = true;
                this._viewContainer.createEmbeddedView(this._templateRef);
            }
            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
                this._prevCondition = false;
                this._viewContainer.clear();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgIf = __decorate([
        metadata_1.Directive({ selector: '[ng-if]', inputs: ['ngIf'] }), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef])
    ], NgIf);
    return NgIf;
})();
exports.NgIf = NgIf;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_style.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var change_detection_1 = require('angular2/src/core/change_detection');
var linker_1 = require('angular2/src/core/linker');
var metadata_1 = require('angular2/src/core/metadata');
var render_1 = require('angular2/src/core/render');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `NgStyle` directive changes styles based on a result of expression evaluation.
 *
 * An expression assigned to the `ng-style` property must evaluate to an object and the
 * corresponding element styles are updated based on changes to this object. Style names to update
 * are taken from the object's keys, and values - from the corresponding object's values.
 *
 * # Syntax
 *
 * - `<div [ng-style]="{'font-style': style}"></div>`
 * - `<div [ng-style]="styleExp"></div>` - here the `styleExp` must evaluate to an object
 *
 * ### Example ([live demo](http://plnkr.co/edit/YamGS6GkUh9GqWNQhCyM?p=preview)):
 *
 * ```
 * import {Component, NgStyle} from 'angular2/angular2';
 *
 * @Component({
 *  selector: 'ng-style-example',
 *  template: `
 *    <h1 [ng-style]="{'font-style': style, 'font-size': size, 'font-weight': weight}">
 *      Change style of this text!
 *    </h1>
 *
 *    <hr>
 *
 *    <label>Italic: <input type="checkbox" (change)="changeStyle($event)"></label>
 *    <label>Bold: <input type="checkbox" (change)="changeWeight($event)"></label>
 *    <label>Size: <input type="text" [value]="size" (change)="size = $event.target.value"></label>
 *  `,
 *  directives: [NgStyle]
 * })
 * export class NgStyleExample {
 *    style = 'normal';
 *    weight = 'normal';
 *    size = '20px';
 *
 *    changeStyle($event: any) {
 *      this.style = $event.target.checked ? 'italic' : 'normal';
 *    }
 *
 *    changeWeight($event: any) {
 *      this.weight = $event.target.checked ? 'bold' : 'normal';
 *    }
 * }
 * ```
 *
 * In this example the `font-style`, `font-size` and `font-weight` styles will be updated
 * based on the `style` property's value changes.
 */
var NgStyle = (function () {
    function NgStyle(_differs, _ngEl, _renderer) {
        this._differs = _differs;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "rawStyle", {
        set: function (v) {
            this._rawStyle = v;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
                this._differ = this._differs.find(this._rawStyle).create(null);
            }
        },
        enumerable: true,
        configurable: true
    });
    NgStyle.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawStyle);
            if (lang_1.isPresent(changes)) {
                this._applyChanges(changes);
            }
        }
    };
    NgStyle.prototype._applyChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });
    };
    NgStyle.prototype._setStyle = function (name, val) {
        this._renderer.setElementStyle(this._ngEl, name, val);
    };
    NgStyle = __decorate([
        metadata_1.Directive({ selector: '[ng-style]', inputs: ['rawStyle: ng-style'] }), 
        __metadata('design:paramtypes', [change_detection_1.KeyValueDiffers, linker_1.ElementRef, render_1.Renderer])
    ], NgStyle);
    return NgStyle;
})();
exports.NgStyle = NgStyle;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_switch.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var _WHEN_DEFAULT = lang_1.CONST_EXPR(new Object());
var SwitchView = (function () {
    function SwitchView(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
    }
    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
    return SwitchView;
})();
exports.SwitchView = SwitchView;
/**
 * The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a
 * scope expression.
 * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
 * preserved at the location as specified in the template.
 *
 * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches
 * the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **`[ng-switch]="..."` attribute**),
 * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per
 * element.
 * The when attribute is used to inform NgSwitch which element to display when the expression is
 * evaluated. If a matching expression is not found via a when attribute then an element with the
 * default attribute is displayed.
 *
 * # Example:
 *
 * ```
 * <ANY [ng-switch]="expression">
 *   <template [ng-switch-when]="whenExpression1">...</template>
 *   <template [ng-switch-when]="whenExpression1">...</template>
 *   <template ng-switch-default>...</template>
 * </ANY>
 * ```
 */
var NgSwitch = (function () {
    function NgSwitch() {
        this._useDefault = false;
        this._valueViews = new collection_1.Map();
        this._activeViews = [];
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
        set: function (value) {
            // Empty the currently active ViewContainers
            this._emptyAllActiveViews();
            // Add the ViewContainers matching the value (with a fallback to default)
            this._useDefault = false;
            var views = this._valueViews.get(value);
            if (lang_1.isBlank(views)) {
                this._useDefault = true;
                views = lang_1.normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
            }
            this._activateViews(views);
            this._switchValue = value;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    NgSwitch.prototype._onWhenValueChanged = function (oldWhen, newWhen, view) {
        this._deregisterView(oldWhen, view);
        this._registerView(newWhen, view);
        if (oldWhen === this._switchValue) {
            view.destroy();
            collection_1.ListWrapper.remove(this._activeViews, view);
        }
        else if (newWhen === this._switchValue) {
            if (this._useDefault) {
                this._useDefault = false;
                this._emptyAllActiveViews();
            }
            view.create();
            this._activeViews.push(view);
        }
        // Switch to default when there is no more active ViewContainers
        if (this._activeViews.length === 0 && !this._useDefault) {
            this._useDefault = true;
            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
        }
    };
    /** @internal */
    NgSwitch.prototype._emptyAllActiveViews = function () {
        var activeContainers = this._activeViews;
        for (var i = 0; i < activeContainers.length; i++) {
            activeContainers[i].destroy();
        }
        this._activeViews = [];
    };
    /** @internal */
    NgSwitch.prototype._activateViews = function (views) {
        // TODO(vicb): assert(this._activeViews.length === 0);
        if (lang_1.isPresent(views)) {
            for (var i = 0; i < views.length; i++) {
                views[i].create();
            }
            this._activeViews = views;
        }
    };
    /** @internal */
    NgSwitch.prototype._registerView = function (value, view) {
        var views = this._valueViews.get(value);
        if (lang_1.isBlank(views)) {
            views = [];
            this._valueViews.set(value, views);
        }
        views.push(view);
    };
    /** @internal */
    NgSwitch.prototype._deregisterView = function (value, view) {
        // `_WHEN_DEFAULT` is used a marker for non-registered whens
        if (value === _WHEN_DEFAULT)
            return;
        var views = this._valueViews.get(value);
        if (views.length == 1) {
            this._valueViews.delete(value);
        }
        else {
            collection_1.ListWrapper.remove(views, view);
        }
    };
    NgSwitch = __decorate([
        metadata_1.Directive({ selector: '[ng-switch]', inputs: ['ngSwitch'] }), 
        __metadata('design:paramtypes', [])
    ], NgSwitch);
    return NgSwitch;
})();
exports.NgSwitch = NgSwitch;
/**
 * Defines a case statement as an expression.
 *
 * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.
 *
 * Example:
 *
 * ```
 * // match against a context variable
 * <template [ng-switch-when]="contextVariable">...</template>
 *
 * // match against a constant string
 * <template ng-switch-when="stringValue">...</template>
 * ```
 */
var NgSwitchWhen = (function () {
    function NgSwitchWhen(viewContainer, templateRef, _switch) {
        this._switch = _switch;
        // `_WHEN_DEFAULT` is used as a marker for a not yet initialized value
        /** @internal */
        this._value = _WHEN_DEFAULT;
        this._view = new SwitchView(viewContainer, templateRef);
    }
    Object.defineProperty(NgSwitchWhen.prototype, "ngSwitchWhen", {
        set: function (value) {
            this._switch._onWhenValueChanged(this._value, value, this._view);
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    NgSwitchWhen = __decorate([
        metadata_1.Directive({ selector: '[ng-switch-when]', inputs: ['ngSwitchWhen'] }),
        __param(2, di_1.Host()), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, NgSwitch])
    ], NgSwitchWhen);
    return NgSwitchWhen;
})();
exports.NgSwitchWhen = NgSwitchWhen;
/**
 * Defines a default case statement.
 *
 * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.
 *
 * Example:
 *
 * ```
 * <template ng-switch-default>...</template>
 * ```
 */
var NgSwitchDefault = (function () {
    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
    }
    NgSwitchDefault = __decorate([
        metadata_1.Directive({ selector: '[ng-switch-default]' }),
        __param(2, di_1.Host()), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, NgSwitch])
    ], NgSwitchDefault);
    return NgSwitchDefault;
})();
exports.NgSwitchDefault = NgSwitchDefault;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/observable_list_diff.js":[function(require,module,exports){
'use strict';// TS does not have Observables

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/browser_adapter.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('./dom_adapter');
var generic_browser_adapter_1 = require('./generic_browser_adapter');
var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
};
var DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
var _keyMap = {
    // The following values are here for cross-browser compatibility and to match the W3C standard
    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
};
/* tslint:disable:requireParameterType */
var BrowserDomAdapter = (function (_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
        _super.apply(this, arguments);
    }
    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error("parse not implemented"); };
    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };
    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {
        el[methodName].apply(el, args);
    };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.logError = function (error) {
        if (window.console.error) {
            window.console.error(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
    BrowserDomAdapter.prototype.logGroup = function (error) {
        if (window.console.group) {
            window.console.group(error);
            this.logError(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function () {
        if (window.console.groupEnd) {
            window.console.groupEnd();
        }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
        get: function () { return _attrToPropMap; },
        enumerable: true,
        configurable: true
    });
    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
        el.addEventListener(evt, listener, false);
        // Needed to follow Dart's subscription semantic, until fix of
        // https://code.google.com/p/dart/issues/detail?id=17406
        return function () { el.removeEventListener(evt, listener, false); };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
        var evt = document.createEvent('MouseEvent');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function (eventType) {
        var evt = document.createEvent('Event');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function (evt) {
        evt.preventDefault();
        evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function (evt) {
        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
    BrowserDomAdapter.prototype.content = function (node) {
        if (this.hasProperty(node, "content")) {
            return node.content;
        }
        else {
            return node;
        }
    };
    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
        var childNodes = el.childNodes;
        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
        for (var i = 0; i < childNodes.length; i++) {
            res[i] = childNodes[i];
        }
        return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function (el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
    };
    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
    BrowserDomAdapter.prototype.remove = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
    BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) { nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); }); };
    BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
    // TODO(vicb): removed Element type because it does not support StyleElement
    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
    BrowserDomAdapter.prototype.createTemplate = function (html) {
        var t = document.createElement('template');
        t.innerHTML = html;
        return t;
    };
    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
        if (doc === void 0) { doc = document; }
        var el = doc.createElement('SCRIPT');
        el.setAttribute(attrName, attrValue);
        return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
        if (doc === void 0) { doc = document; }
        var style = doc.createElement('style');
        this.appendChild(style, this.createTextNode(css));
        return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
        return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
        return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
    BrowserDomAdapter.prototype.addClass = function (element, classname) { element.classList.add(classname); };
    BrowserDomAdapter.prototype.removeClass = function (element, classname) { element.classList.remove(classname); };
    BrowserDomAdapter.prototype.hasClass = function (element, classname) { return element.classList.contains(classname); };
    BrowserDomAdapter.prototype.setStyle = function (element, stylename, stylevalue) {
        element.style[stylename] = stylevalue;
    };
    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) { element.style[stylename] = null; };
    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
    BrowserDomAdapter.prototype.attributeMap = function (element) {
        var res = new Map();
        var elAttrs = element.attributes;
        for (var i = 0; i < elAttrs.length; i++) {
            var attrib = elAttrs[i];
            res.set(attrib.name, attrib.value);
        }
        return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) { return element.hasAttribute(attribute); };
    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) { return element.getAttribute(attribute); };
    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
    BrowserDomAdapter.prototype.createHtmlDocument = function () {
        return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
        try {
            return el.getBoundingClientRect();
        }
        catch (e) {
            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
        }
    };
    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
        var matches = false;
        if (n instanceof HTMLElement) {
            if (n.matches) {
                matches = n.matches(selector);
            }
            else if (n.msMatchesSelector) {
                matches = n.msMatchesSelector(selector);
            }
            else if (n.webkitMatchesSelector) {
                matches = n.webkitMatchesSelector(selector);
            }
        }
        return matches;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
        return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
    };
    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
    BrowserDomAdapter.prototype.hasShadowRoot = function (node) { return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot); };
    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
    BrowserDomAdapter.prototype.importIntoDoc = function (node) {
        var toImport = node;
        if (this.isTemplateElement(node)) {
            toImport = this.content(node);
        }
        return document.importNode(toImport, true);
    };
    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
    BrowserDomAdapter.prototype.isPageRule = function (rule) { return rule.type === CSSRule.PAGE_RULE; };
    BrowserDomAdapter.prototype.isStyleRule = function (rule) { return rule.type === CSSRule.STYLE_RULE; };
    BrowserDomAdapter.prototype.isMediaRule = function (rule) { return rule.type === CSSRule.MEDIA_RULE; };
    BrowserDomAdapter.prototype.isKeyframesRule = function (rule) { return rule.type === CSSRule.KEYFRAMES_RULE; };
    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
    BrowserDomAdapter.prototype.getEventKey = function (event) {
        var key = event.key;
        if (lang_1.isBlank(key)) {
            key = event.keyIdentifier;
            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
            // Safari
            // cf
            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
            if (lang_1.isBlank(key)) {
                return 'Unidentified';
            }
            if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                    // There is a bug in Chrome for numeric keypad keys:
                    // https://code.google.com/p/chromium/issues/detail?id=155654
                    // 1, 2, 3 ... are reported as A, B, C ...
                    key = _chromeNumKeyPadMap[key];
                }
            }
        }
        if (_keyMap.hasOwnProperty(key)) {
            key = _keyMap[key];
        }
        return key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
        if (target == "window") {
            return window;
        }
        else if (target == "document") {
            return document;
        }
        else if (target == "body") {
            return document.body;
        }
    };
    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
    BrowserDomAdapter.prototype.getBaseHref = function () {
        var href = getBaseElementHref();
        if (lang_1.isBlank(href)) {
            return null;
        }
        return relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
    BrowserDomAdapter.prototype.setData = function (element, name, value) {
        this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function (element, name) { return this.getAttribute(element, 'data-' + name); };
    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };
    BrowserDomAdapter.prototype.requestAnimationFrame = function (callback) { return window.requestAnimationFrame(callback); };
    BrowserDomAdapter.prototype.cancelAnimationFrame = function (id) { window.cancelAnimationFrame(id); };
    BrowserDomAdapter.prototype.performanceNow = function () {
        // performance.now() is not available in all browsers, see
        // http://caniuse.com/#search=performance.now
        if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {
            return window.performance.now();
        }
        else {
            return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        }
    };
    return BrowserDomAdapter;
})(generic_browser_adapter_1.GenericBrowserDomAdapter);
exports.BrowserDomAdapter = BrowserDomAdapter;
var baseElement = null;
function getBaseElementHref() {
    if (lang_1.isBlank(baseElement)) {
        baseElement = document.querySelector('base');
        if (lang_1.isBlank(baseElement)) {
            return null;
        }
    }
    return baseElement.getAttribute('href');
}
// based on urlUtils.js in AngularJS 1
var urlParsingNode = null;
function relativePath(url) {
    if (lang_1.isBlank(urlParsingNode)) {
        urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
        '/' + urlParsingNode.pathname;
}

},{"./dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","./generic_browser_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/generic_browser_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
function setRootDomAdapter(adapter) {
    if (lang_1.isBlank(exports.DOM)) {
        exports.DOM = adapter;
    }
}
exports.setRootDomAdapter = setRootDomAdapter;
/* tslint:disable:requireParameterType */
/**
 * Provides DOM operations in an environment-agnostic way.
 */
var DomAdapter = (function () {
    function DomAdapter() {
    }
    return DomAdapter;
})();
exports.DomAdapter = DomAdapter;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/generic_browser_adapter.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('./dom_adapter');
/**
 * Provides DOM operations in any browser environment.
 */
var GenericBrowserDomAdapter = (function (_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
        var _this = this;
        _super.call(this);
        this._animationPrefix = null;
        this._transitionEnd = null;
        try {
            var element = this.createElement('div', this.defaultDoc());
            if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {
                this._animationPrefix = '';
            }
            else {
                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                for (var i = 0; i < domPrefixes.length; i++) {
                    if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
                        this._animationPrefix = '-' + lang_1.StringWrapper.toLowerCase(domPrefixes[i]) + '-';
                        break;
                    }
                }
            }
            var transEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend',
                transition: 'transitionend'
            };
            collection_1.StringMapWrapper.forEach(transEndEventNames, function (value, key) {
                if (lang_1.isPresent(_this.getStyle(element, key))) {
                    _this._transitionEnd = value;
                }
            });
        }
        catch (e) {
            this._animationPrefix = null;
            this._transitionEnd = null;
        }
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.cssToRules = function (css) {
        var style = this.createStyleElement(css);
        this.appendChild(this.defaultDoc().head, style);
        var rules = [];
        if (lang_1.isPresent(style.sheet)) {
            // TODO(sorvell): Firefox throws when accessing the rules of a stylesheet
            // with an @import
            // https://bugzilla.mozilla.org/show_bug.cgi?id=625013
            try {
                var rawRules = style.sheet.cssRules;
                rules = collection_1.ListWrapper.createFixedSize(rawRules.length);
                for (var i = 0; i < rawRules.length; i++) {
                    rules[i] = rawRules[i];
                }
            }
            catch (e) {
            }
        }
        else {
        }
        this.remove(style);
        return rules;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
    };
    GenericBrowserDomAdapter.prototype.supportsUnprefixedCssAnimation = function () {
        return lang_1.isPresent(this.defaultDoc().body.style) &&
            lang_1.isPresent(this.defaultDoc().body.style.animationName);
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {
        return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : "";
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : ""; };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
        return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);
    };
    return GenericBrowserDomAdapter;
})(dom_adapter_1.DomAdapter);
exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;

},{"./dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade.js":[function(require,module,exports){
'use strict';// Public API for Facade
var lang_1 = require('./facade/lang');
exports.Type = lang_1.Type;
var async_1 = require('./facade/async');
exports.Observable = async_1.Observable;
exports.EventEmitter = async_1.EventEmitter;
var exceptions_1 = require('./facade/exceptions');
exports.WrappedException = exceptions_1.WrappedException;

},{"./facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","./facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
// TODO(jeffbcross): use ES6 import once typings are available
var Subject = require('@reactivex/rxjs/dist/cjs/Subject');
var PromiseWrapper = (function () {
    function PromiseWrapper() {
    }
    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };
    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };
    // Note: We can't rename this method into `catch`, as this is not a valid
    // method name in Dart.
    PromiseWrapper.catchError = function (promise, onError) {
        return promise.catch(onError);
    };
    PromiseWrapper.all = function (promises) {
        if (promises.length == 0)
            return Promise.resolve([]);
        return Promise.all(promises);
    };
    PromiseWrapper.then = function (promise, success, rejection) {
        return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function (computation) {
        return new Promise(function (res, rej) {
            try {
                res(computation());
            }
            catch (e) {
                rej(e);
            }
        });
    };
    PromiseWrapper.completer = function () {
        var resolve;
        var reject;
        var p = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        return { promise: p, resolve: resolve, reject: reject };
    };
    return PromiseWrapper;
})();
exports.PromiseWrapper = PromiseWrapper;
var TimerWrapper = (function () {
    function TimerWrapper() {
    }
    TimerWrapper.setTimeout = function (fn, millis) {
        return lang_1.global.setTimeout(fn, millis);
    };
    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };
    TimerWrapper.setInterval = function (fn, millis) {
        return lang_1.global.setInterval(fn, millis);
    };
    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };
    return TimerWrapper;
})();
exports.TimerWrapper = TimerWrapper;
var ObservableWrapper = (function () {
    function ObservableWrapper() {
    }
    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
    ObservableWrapper.subscribe = function (emitter, onNext, onThrow, onReturn) {
        if (onThrow === void 0) { onThrow = null; }
        if (onReturn === void 0) { onReturn = null; }
        return emitter.observer({ next: onNext, throw: onThrow, return: onReturn });
    };
    ObservableWrapper.isObservable = function (obs) { return obs instanceof Observable; };
    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };
    ObservableWrapper.callNext = function (emitter, value) { emitter.next(value); };
    ObservableWrapper.callThrow = function (emitter, error) { emitter.throw(error); };
    ObservableWrapper.callReturn = function (emitter) { emitter.return(null); };
    return ObservableWrapper;
})();
exports.ObservableWrapper = ObservableWrapper;
// TODO: vsavkin change to interface
var Observable = (function () {
    function Observable() {
    }
    Observable.prototype.observer = function (generator) { return null; };
    return Observable;
})();
exports.Observable = Observable;
/**
 * Use by directives and components to emit custom Events.
 *
 * ## Examples
 *
 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter = new EventEmitter();
 *   @Output() close: EventEmitter = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.next(null);
 *     } else {
 *       this.close.next(null);
 *     }
 *   }
 * }
 * ```
 *
 * Use Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 */
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    function EventEmitter() {
        _super.apply(this, arguments);
        /** @internal */
        this._subject = new Subject();
    }
    EventEmitter.prototype.observer = function (generator) {
        return this._subject.subscribe(function (value) { setTimeout(function () { return generator.next(value); }); }, function (error) { return generator.throw ? generator.throw(error) : null; }, function () { return generator.return ? generator.return() : null; });
    };
    EventEmitter.prototype.toRx = function () { return this._subject; };
    EventEmitter.prototype.next = function (value) { this._subject.next(value); };
    EventEmitter.prototype.throw = function (error) { this._subject.error(error); };
    EventEmitter.prototype.return = function (value) { this._subject.complete(); };
    return EventEmitter;
})(Observable);
exports.EventEmitter = EventEmitter;

},{"@reactivex/rxjs/dist/cjs/Subject":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subject.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.Map = lang_1.global.Map;
exports.Set = lang_1.global.Set;
// Safari and Internet Explorer do not support the iterable parameter to the
// Map constructor.  We work around that by manually adding the items.
var createMapFromPairs = (function () {
    try {
        if (new exports.Map([[1, 2]]).size === 1) {
            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromPairs(pairs) {
        var map = new exports.Map();
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            map.set(pair[0], pair[1]);
        }
        return map;
    };
})();
var createMapFromMap = (function () {
    try {
        if (new exports.Map(new exports.Map())) {
            return function createMapFromMap(m) { return new exports.Map(m); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromMap(m) {
        var map = new exports.Map();
        m.forEach(function (v, k) { map.set(k, v); });
        return map;
    };
})();
var _clearValues = (function () {
    if ((new exports.Map()).keys().next) {
        return function _clearValues(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
                m.set(k.value, null);
            }
        };
    }
    else {
        return function _clearValuesWithForeEach(m) {
            m.forEach(function (v, k) { m.set(k, null); });
        };
    }
})();
// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
var _arrayFromMap = (function () {
    try {
        if ((new exports.Map()).values().next) {
            return function createArrayFromMap(m, getValues) { return getValues ? Array.from(m.values()) : Array.from(m.keys()); };
        }
    }
    catch (e) {
    }
    return function createArrayFromMapWithForeach(m, getValues) {
        var res = ListWrapper.createFixedSize(m.size), i = 0;
        m.forEach(function (v, k) {
            res[i] = getValues ? v : k;
            i++;
        });
        return res;
    };
})();
var MapWrapper = (function () {
    function MapWrapper() {
    }
    MapWrapper.clone = function (m) { return createMapFromMap(m); };
    MapWrapper.createFromStringMap = function (stringMap) {
        var result = new exports.Map();
        for (var prop in stringMap) {
            result.set(prop, stringMap[prop]);
        }
        return result;
    };
    MapWrapper.toStringMap = function (m) {
        var r = {};
        m.forEach(function (v, k) { return r[k] = v; });
        return r;
    };
    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
    MapWrapper.clearValues = function (m) { _clearValues(m); };
    MapWrapper.iterable = function (m) { return m; };
    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
    return MapWrapper;
})();
exports.MapWrapper = MapWrapper;
/**
 * Wraps Javascript Objects
 */
var StringMapWrapper = (function () {
    function StringMapWrapper() {
    }
    StringMapWrapper.create = function () {
        // Note: We are not using Object.create(null) here due to
        // performance!
        // http://jsperf.com/ng2-object-create-null
        return {};
    };
    StringMapWrapper.contains = function (map, key) {
        return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function (map, key) {
        return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
    StringMapWrapper.keys = function (map) { return Object.keys(map); };
    StringMapWrapper.isEmpty = function (map) {
        for (var prop in map) {
            return false;
        }
        return true;
    };
    StringMapWrapper.delete = function (map, key) { delete map[key]; };
    StringMapWrapper.forEach = function (map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    };
    StringMapWrapper.merge = function (m1, m2) {
        var m = {};
        for (var attr in m1) {
            if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
            }
        }
        for (var attr in m2) {
            if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
            }
        }
        return m;
    };
    StringMapWrapper.equals = function (m1, m2) {
        var k1 = Object.keys(m1);
        var k2 = Object.keys(m2);
        if (k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (m1[key] !== m2[key]) {
                return false;
            }
        }
        return true;
    };
    return StringMapWrapper;
})();
exports.StringMapWrapper = StringMapWrapper;
var ListWrapper = (function () {
    function ListWrapper() {
    }
    // JS has no way to express a statically fixed size list, but dart does so we
    // keep both methods.
    ListWrapper.createFixedSize = function (size) { return new Array(size); };
    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
    ListWrapper.clone = function (array) { return array.slice(0); };
    ListWrapper.forEachWithIndex = function (array, fn) {
        for (var i = 0; i < array.length; i++) {
            fn(array[i], i);
        }
    };
    ListWrapper.first = function (array) {
        if (!array)
            return null;
        return array[0];
    };
    ListWrapper.last = function (array) {
        if (!array || array.length == 0)
            return null;
        return array[array.length - 1];
    };
    ListWrapper.find = function (list, pred) {
        for (var i = 0; i < list.length; ++i) {
            if (pred(list[i]))
                return list[i];
        }
        return null;
    };
    ListWrapper.indexOf = function (array, value, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        return array.indexOf(value, startIndex);
    };
    ListWrapper.reduce = function (list, fn, init) {
        return list.reduce(fn, init);
    };
    ListWrapper.filter = function (array, pred) { return array.filter(pred); };
    ListWrapper.any = function (list, pred) {
        for (var i = 0; i < list.length; ++i) {
            if (pred(list[i]))
                return true;
        }
        return false;
    };
    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
    ListWrapper.reversed = function (array) {
        var a = ListWrapper.clone(array);
        return a.reverse();
    };
    ListWrapper.concat = function (a, b) { return a.concat(b); };
    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
    ListWrapper.removeAt = function (list, index) {
        var res = list[index];
        list.splice(index, 1);
        return res;
    };
    ListWrapper.removeAll = function (list, items) {
        for (var i = 0; i < items.length; ++i) {
            var index = list.indexOf(items[i]);
            list.splice(index, 1);
        }
    };
    ListWrapper.remove = function (list, el) {
        var index = list.indexOf(el);
        if (index > -1) {
            list.splice(index, 1);
            return true;
        }
        return false;
    };
    ListWrapper.clear = function (list) { list.length = 0; };
    ListWrapper.isEmpty = function (list) { return list.length == 0; };
    ListWrapper.fill = function (list, value, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = null; }
        list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function (a, b) {
        if (a.length != b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    };
    ListWrapper.slice = function (l, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
    ListWrapper.sort = function (l, compareFn) {
        if (lang_1.isPresent(compareFn)) {
            l.sort(compareFn);
        }
        else {
            l.sort();
        }
    };
    ListWrapper.toString = function (l) { return l.toString(); };
    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
    ListWrapper.maximum = function (list, predicate) {
        if (list.length == 0) {
            return null;
        }
        var solution = null;
        var maxValue = -Infinity;
        for (var index = 0; index < list.length; index++) {
            var candidate = list[index];
            if (lang_1.isBlank(candidate)) {
                continue;
            }
            var candidateValue = predicate(candidate);
            if (candidateValue > maxValue) {
                solution = candidate;
                maxValue = candidateValue;
            }
        }
        return solution;
    };
    return ListWrapper;
})();
exports.ListWrapper = ListWrapper;
function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
        return false;
    return lang_1.isArray(obj) ||
        (!(obj instanceof exports.Map) &&
            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
}
exports.isListLikeIterable = isListLikeIterable;
function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
            fn(obj[i]);
        }
    }
    else {
        var iterator = obj[lang_1.getSymbolIterator()]();
        var item;
        while (!((item = iterator.next()).done)) {
            fn(item.value);
        }
    }
}
exports.iterateListLike = iterateListLike;
// Safari and Internet Explorer do not support the iterable parameter to the
// Set constructor.  We work around that by manually adding the items.
var createSetFromList = (function () {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
        return function createSetFromList(lst) { return new exports.Set(lst); };
    }
    else {
        return function createSetAndPopulateFromList(lst) {
            var res = new exports.Set(lst);
            if (res.size !== lst.length) {
                for (var i = 0; i < lst.length; i++) {
                    res.add(lst[i]);
                }
            }
            return res;
        };
    }
})();
var SetWrapper = (function () {
    function SetWrapper() {
    }
    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
    SetWrapper.has = function (s, key) { return s.has(key); };
    SetWrapper.delete = function (m, k) { m.delete(k); };
    return SetWrapper;
})();
exports.SetWrapper = SetWrapper;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exception_handler.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var _ArrayLogger = (function () {
    function _ArrayLogger() {
        this.res = [];
    }
    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroupEnd = function () { };
    ;
    return _ArrayLogger;
})();
/**
 * Provides a hook for centralized exception handling.
 *
 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
 * intercept error handling,
 * write a custom exception handler that replaces this default as appropriate for your app.
 *
 * # Example
 *
 * ```javascript
 *
 * class MyExceptionHandler implements ExceptionHandler {
 *   call(error, stackTrace = null, reason = null) {
 *     // do something with the exception
 *   }
 * }
 *
 * bootstrap(MyApp, [provide(ExceptionHandler, {useClass: MyExceptionHandler})])
 *
 * ```
 */
var ExceptionHandler = (function () {
    function ExceptionHandler(_logger, _rethrowException) {
        if (_rethrowException === void 0) { _rethrowException = true; }
        this._logger = _logger;
        this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var l = new _ArrayLogger();
        var e = new ExceptionHandler(l, false);
        e.call(exception, stackTrace, reason);
        return l.res.join("\n");
    };
    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var originalException = this._findOriginalException(exception);
        var originalStack = this._findOriginalStack(exception);
        var context = this._findContext(exception);
        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
            this._logger.logError("STACKTRACE:");
            this._logger.logError(this._longStackTrace(stackTrace));
        }
        if (lang_1.isPresent(reason)) {
            this._logger.logError("REASON: " + reason);
        }
        if (lang_1.isPresent(originalException)) {
            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
        }
        if (lang_1.isPresent(originalStack)) {
            this._logger.logError("ORIGINAL STACKTRACE:");
            this._logger.logError(this._longStackTrace(originalStack));
        }
        if (lang_1.isPresent(context)) {
            this._logger.logError("ERROR CONTEXT:");
            this._logger.logError(context);
        }
        this._logger.logGroupEnd();
        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
        if (this._rethrowException)
            throw exception;
    };
    /** @internal */
    ExceptionHandler.prototype._extractMessage = function (exception) {
        return exception instanceof exceptions_1.WrappedException ? exception.wrapperMessage : exception.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") :
            stackTrace.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._findContext = function (exception) {
        try {
            if (!(exception instanceof exceptions_1.WrappedException))
                return null;
            return lang_1.isPresent(exception.context) ? exception.context :
                this._findContext(exception.originalException);
        }
        catch (e) {
            // exception.context can throw an exception. if it happens, we ignore the context.
            return null;
        }
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalException = function (exception) {
        if (!(exception instanceof exceptions_1.WrappedException))
            return null;
        var e = exception.originalException;
        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
        }
        return e;
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalStack = function (exception) {
        if (!(exception instanceof exceptions_1.WrappedException))
            return null;
        var e = exception;
        var stack = exception.originalStack;
        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
            if (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
                stack = e.originalStack;
            }
        }
        return stack;
    };
    return ExceptionHandler;
})();
exports.ExceptionHandler = ExceptionHandler;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exception_handler_1 = require('./exception_handler');
var exception_handler_2 = require('./exception_handler');
exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
var BaseException = (function (_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
        if (message === void 0) { message = "--"; }
        _super.call(this, message);
        this.message = message;
        this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function () { return this.message; };
    return BaseException;
})(Error);
exports.BaseException = BaseException;
var WrappedException = (function (_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
        _super.call(this, _wrapperMessage);
        this._wrapperMessage = _wrapperMessage;
        this._originalException = _originalException;
        this._originalStack = _originalStack;
        this._context = _context;
        this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
        get: function () { return this._wrapperMessage; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
        get: function () { return this._wrapperStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
        get: function () { return this._originalException; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
        get: function () { return this._originalStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
        get: function () { return this._context; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
        enumerable: true,
        configurable: true
    });
    WrappedException.prototype.toString = function () { return this.message; };
    return WrappedException;
})(Error);
exports.WrappedException = WrappedException;
function makeTypeError(message) {
    return new TypeError(message);
}
exports.makeTypeError = makeTypeError;
function unimplemented() {
    throw new BaseException('unimplemented');
}
exports.unimplemented = unimplemented;

},{"./exception_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exception_handler.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js":[function(require,module,exports){
'use strict';(function (NumberFormatStyle) {
    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
var NumberFormatStyle = exports.NumberFormatStyle;
var NumberFormatter = (function () {
    function NumberFormatter() {
    }
    NumberFormatter.format = function (number, locale, style, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;
        var intlOptions = {
            minimumIntegerDigits: minimumIntegerDigits,
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits
        };
        intlOptions.style = NumberFormatStyle[style].toLowerCase();
        if (style == NumberFormatStyle.Currency) {
            intlOptions.currency = currency;
            intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
        }
        return new Intl.NumberFormat(locale, intlOptions).format(number);
    };
    return NumberFormatter;
})();
exports.NumberFormatter = NumberFormatter;
function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
}
function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
}
function extractComponents(pattern) {
    var ret = {};
    var i = 0, j;
    while (i < pattern.length) {
        j = i;
        while (j < pattern.length && pattern[j] == pattern[i])
            j++;
        var len = j - i;
        switch (pattern[i]) {
            case 'G':
                ret.era = nameCondition(len);
                break;
            case 'y':
                ret.year = digitCondition(len);
                break;
            case 'M':
                if (len >= 3)
                    ret.month = nameCondition(len);
                else
                    ret.month = digitCondition(len);
                break;
            case 'd':
                ret.day = digitCondition(len);
                break;
            case 'E':
                ret.weekday = nameCondition(len);
                break;
            case 'j':
                ret.hour = digitCondition(len);
                break;
            case 'h':
                ret.hour = digitCondition(len);
                ret.hour12 = true;
                break;
            case 'H':
                ret.hour = digitCondition(len);
                ret.hour12 = false;
                break;
            case 'm':
                ret.minute = digitCondition(len);
                break;
            case 's':
                ret.second = digitCondition(len);
                break;
            case 'z':
                ret.timeZoneName = 'long';
                break;
            case 'Z':
                ret.timeZoneName = 'short';
                break;
        }
        i = j;
    }
    return ret;
}
var dateFormatterCache = new Map();
var DateFormatter = (function () {
    function DateFormatter() {
    }
    DateFormatter.format = function (date, locale, pattern) {
        var key = locale + pattern;
        if (dateFormatterCache.has(key)) {
            return dateFormatterCache.get(key).format(date);
        }
        var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
        dateFormatterCache.set(key, formatter);
        return formatter.format(date);
    };
    return DateFormatter;
})();
exports.DateFormatter = DateFormatter;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js":[function(require,module,exports){
(function (global){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    return type['name'];
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var assertionsEnabled_ = typeof _global['assert'] !== 'undefined';
function assertionsEnabled() {
    return assertionsEnabled_;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    if (assertionsEnabled_) {
        _global['assert'].call(condition);
    }
};
// This function is needed only to properly support Dart's const expressions
// see https://github.com/angular/ts2dart/pull/151 for more info
function CONST_EXPR(expr) {
    return expr;
}
exports.CONST_EXPR = CONST_EXPR;
function CONST() {
    return function (target) { return target; };
}
exports.CONST = CONST;
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isNumber(obj) {
    return typeof obj === 'number';
}
exports.isNumber = isNumber;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.toUpperCase = function (s) { return s.toUpperCase(); };
    StringWrapper.toLowerCase = function (s) { return s.toLowerCase(); };
    StringWrapper.startsWith = function (s, start) { return s.startsWith(start); };
    StringWrapper.substring = function (s, start, end) {
        if (end === void 0) { end = null; }
        return s.substring(start, end === null ? undefined : end);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
})();
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
})();
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
})(Error);
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
})();
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    return RegExpWrapper;
})();
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
})();
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
})();
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
})();
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
})();
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name)) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.Math = lang_1.global.Math;
exports.NaN = typeof exports.NaN;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module is used for handling user input, by defining and building a {@link ControlGroup} that
 * consists of
 * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
 * to read information
 * from the form DOM elements.
 *
 * This module is not included in the `angular2` module; you must import the forms module
 * explicitly.
 *
 */
var model_1 = require('./forms/model');
exports.AbstractControl = model_1.AbstractControl;
exports.Control = model_1.Control;
exports.ControlGroup = model_1.ControlGroup;
exports.ControlArray = model_1.ControlArray;
var abstract_control_directive_1 = require('./forms/directives/abstract_control_directive');
exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
var control_container_1 = require('./forms/directives/control_container');
exports.ControlContainer = control_container_1.ControlContainer;
var ng_control_name_1 = require('./forms/directives/ng_control_name');
exports.NgControlName = ng_control_name_1.NgControlName;
var ng_form_control_1 = require('./forms/directives/ng_form_control');
exports.NgFormControl = ng_form_control_1.NgFormControl;
var ng_model_1 = require('./forms/directives/ng_model');
exports.NgModel = ng_model_1.NgModel;
var ng_control_1 = require('./forms/directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
var ng_control_group_1 = require('./forms/directives/ng_control_group');
exports.NgControlGroup = ng_control_group_1.NgControlGroup;
var ng_form_model_1 = require('./forms/directives/ng_form_model');
exports.NgFormModel = ng_form_model_1.NgFormModel;
var ng_form_1 = require('./forms/directives/ng_form');
exports.NgForm = ng_form_1.NgForm;
var default_value_accessor_1 = require('./forms/directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
var ng_control_status_1 = require('./forms/directives/ng_control_status');
exports.NgControlStatus = ng_control_status_1.NgControlStatus;
var checkbox_value_accessor_1 = require('./forms/directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
var select_control_value_accessor_1 = require('./forms/directives/select_control_value_accessor');
exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
var directives_1 = require('./forms/directives');
exports.FORM_DIRECTIVES = directives_1.FORM_DIRECTIVES;
var validators_1 = require('./forms/validators');
exports.NG_VALIDATORS = validators_1.NG_VALIDATORS;
exports.Validators = validators_1.Validators;
var validators_2 = require('./forms/directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
var form_builder_1 = require('./forms/form_builder');
exports.FormBuilder = form_builder_1.FormBuilder;
var form_builder_2 = require('./forms/form_builder');
var lang_1 = require('./facade/lang');
/**
 * Shorthand set of providers used for building Angular forms.
 *
 * ### Example:
 *
 * ```typescript
 * bootstrap(MyApp, [FORM_PROVIDERS]);
 * ```
 */
exports.FORM_PROVIDERS = lang_1.CONST_EXPR([form_builder_2.FormBuilder]);
/**
 * @deprecated
 */
exports.FORM_BINDINGS = exports.FORM_PROVIDERS;

},{"./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","./forms/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives.js","./forms/directives/abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js","./forms/directives/checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./forms/directives/control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./forms/directives/default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./forms/directives/ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./forms/directives/ng_control_group":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js","./forms/directives/ng_control_name":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js","./forms/directives/ng_control_status":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js","./forms/directives/ng_form":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js","./forms/directives/ng_form_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js","./forms/directives/ng_form_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js","./forms/directives/ng_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js","./forms/directives/select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","./forms/directives/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js","./forms/form_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/form_builder.js","./forms/model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","./forms/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var ng_control_name_1 = require('./directives/ng_control_name');
var ng_form_control_1 = require('./directives/ng_form_control');
var ng_model_1 = require('./directives/ng_model');
var ng_control_group_1 = require('./directives/ng_control_group');
var ng_form_model_1 = require('./directives/ng_form_model');
var ng_form_1 = require('./directives/ng_form');
var default_value_accessor_1 = require('./directives/default_value_accessor');
var checkbox_value_accessor_1 = require('./directives/checkbox_value_accessor');
var ng_control_status_1 = require('./directives/ng_control_status');
var select_control_value_accessor_1 = require('./directives/select_control_value_accessor');
var validators_1 = require('./directives/validators');
var ng_control_name_2 = require('./directives/ng_control_name');
exports.NgControlName = ng_control_name_2.NgControlName;
var ng_form_control_2 = require('./directives/ng_form_control');
exports.NgFormControl = ng_form_control_2.NgFormControl;
var ng_model_2 = require('./directives/ng_model');
exports.NgModel = ng_model_2.NgModel;
var ng_control_1 = require('./directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
var ng_control_group_2 = require('./directives/ng_control_group');
exports.NgControlGroup = ng_control_group_2.NgControlGroup;
var ng_form_model_2 = require('./directives/ng_form_model');
exports.NgFormModel = ng_form_model_2.NgFormModel;
var ng_form_2 = require('./directives/ng_form');
exports.NgForm = ng_form_2.NgForm;
var default_value_accessor_2 = require('./directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
var checkbox_value_accessor_2 = require('./directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
var select_control_value_accessor_2 = require('./directives/select_control_value_accessor');
exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
var validators_2 = require('./directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
var ng_control_status_2 = require('./directives/ng_control_status');
exports.NgControlStatus = ng_control_status_2.NgControlStatus;
/**
 *
 * A list of all the form directives used as part of a `@View` annotation.
 *
 *  This is a shorthand for importing them each individually.
 *
 * ### Example:
 *
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   directives: [FORM_DIRECTIVES]
 * })
 * class MyApp {}
 * ```
 */
exports.FORM_DIRECTIVES = lang_1.CONST_EXPR([
    ng_control_name_1.NgControlName,
    ng_control_group_1.NgControlGroup,
    ng_form_control_1.NgFormControl,
    ng_model_1.NgModel,
    ng_form_model_1.NgFormModel,
    ng_form_1.NgForm,
    select_control_value_accessor_1.NgSelectOption,
    default_value_accessor_1.DefaultValueAccessor,
    checkbox_value_accessor_1.CheckboxControlValueAccessor,
    select_control_value_accessor_1.SelectControlValueAccessor,
    ng_control_status_1.NgControlStatus,
    validators_1.RequiredValidator,
    validators_1.MinLengthValidator,
    validators_1.MaxLengthValidator
]);

},{"./directives/checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./directives/default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./directives/ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./directives/ng_control_group":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js","./directives/ng_control_name":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js","./directives/ng_control_status":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js","./directives/ng_form":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js","./directives/ng_form_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js","./directives/ng_form_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js","./directives/ng_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js","./directives/select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","./directives/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var AbstractControlDirective = (function () {
    function AbstractControlDirective() {
    }
    Object.defineProperty(AbstractControlDirective.prototype, "control", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "value", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.value : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.valid : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
        get: function () {
            return lang_1.isPresent(this.control) ? this.control.errors : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.pristine : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.dirty : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.touched : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.untouched : null; },
        enumerable: true,
        configurable: true
    });
    return AbstractControlDirective;
})();
exports.AbstractControlDirective = AbstractControlDirective;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var render_1 = require('angular2/src/core/render');
var linker_1 = require('angular2/src/core/linker');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var CHECKBOX_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return CheckboxControlValueAccessor; }), multi: true }));
/**
 * The accessor for writing a value and listening to changes on a checkbox input element.
 *
 *  # Example
 *  ```
 *  <input type="checkbox" [ng-control]="rememberLogin">
 *  ```
 */
var CheckboxControlValueAccessor = (function () {
    function CheckboxControlValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    CheckboxControlValueAccessor.prototype.writeValue = function (value) { shared_1.setProperty(this._renderer, this._elementRef, "checked", value); };
    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    CheckboxControlValueAccessor = __decorate([
        metadata_1.Directive({
            selector: 'input[type=checkbox][ng-control],input[type=checkbox][ng-form-control],input[type=checkbox][ng-model]',
            host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
            bindings: [CHECKBOX_VALUE_ACCESSOR]
        }), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef])
    ], CheckboxControlValueAccessor);
    return CheckboxControlValueAccessor;
})();
exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A directive that contains multiple {@link NgControl}.
 *
 * Only used by the forms module.
 */
var ControlContainer = (function (_super) {
    __extends(ControlContainer, _super);
    function ControlContainer() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(ControlContainer.prototype, "formDirective", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlContainer.prototype, "path", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return ControlContainer;
})(abstract_control_directive_1.AbstractControlDirective);
exports.ControlContainer = ControlContainer;

},{"./abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
exports.NG_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.OpaqueToken("NgValueAccessor"));

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var render_1 = require('angular2/src/core/render');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var DEFAULT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return DefaultValueAccessor; }), multi: true }));
/**
 * The default accessor for writing a value and listening to changes that is used by the
 * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
 *
 *  # Example
 *  ```
 *  <input type="text" [(ng-model)]="searchQuery">
 *  ```
 */
var DefaultValueAccessor = (function () {
    function DefaultValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    DefaultValueAccessor.prototype.writeValue = function (value) {
        var normalizedValue = lang_1.isBlank(value) ? '' : value;
        shared_1.setProperty(this._renderer, this._elementRef, 'value', normalizedValue);
    };
    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    DefaultValueAccessor = __decorate([
        metadata_1.Directive({
            selector: '[ng-control],[ng-model],[ng-form-control]',
            host: {
                '(change)': 'onChange($event.target.value)',
                '(input)': 'onChange($event.target.value)',
                '(blur)': 'onTouched()'
            },
            bindings: [DEFAULT_VALUE_ACCESSOR]
        }), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef])
    ], DefaultValueAccessor);
    return DefaultValueAccessor;
})();
exports.DefaultValueAccessor = DefaultValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A base class that all control directive extend.
 * It binds a {@link Control} object to a DOM element.
 */
// Cannot currently be abstract because it would contain
// an abstract method in the public API, and we cannot reflect
// on that in Dart due to https://github.com/dart-lang/sdk/issues/18721
// Also we don't have abstract setters, see https://github.com/Microsoft/TypeScript/issues/4669
var NgControl = (function (_super) {
    __extends(NgControl, _super);
    function NgControl() {
        _super.apply(this, arguments);
        this.name = null;
        this.valueAccessor = null;
    }
    Object.defineProperty(NgControl.prototype, "validator", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControl.prototype, "path", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    NgControl.prototype.viewToModelUpdate = function (newValue) { };
    return NgControl;
})(abstract_control_directive_1.AbstractControlDirective);
exports.NgControl = NgControl;

},{"./abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var controlGroupBinding = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgControlGroup; }) }));
/**
 * Creates and binds a control group to a DOM element.
 *
 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
 *
 * # Example
 *
 * In this example, we create the credentials and personal control groups.
 * We can work with each group separately: check its validity, get its value, listen to its changes.
 *
 *  ```
 * @Component({
 *      selector: "signup-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *              <form #f="form" (submit)='onSignUp(f.value)'>
 *                <div ng-control-group='credentials' #credentials="form">
 *                  Login <input type='text' ng-control='login'>
 *                  Password <input type='password' ng-control='password'>
 *                </div>
 *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
 *
 *                <div ng-control-group='personal'>
 *                  Name <input type='text' ng-control='name'>
 *                </div>
 *                <button type='submit'>Sign Up!</button>
 *              </form>
 *      `})
 * class SignupComp {
 *  onSignUp(value) {
 *    // value === {
 *    //  personal: {name: 'some name'},
 *    //  credentials: {login: 'some login', password: 'some password'}}
 *  }
 * }
 *
 *  ```
 */
var NgControlGroup = (function (_super) {
    __extends(NgControlGroup, _super);
    function NgControlGroup(_parent) {
        _super.call(this);
        this._parent = _parent;
    }
    NgControlGroup.prototype.onInit = function () { this.formDirective.addControlGroup(this); };
    NgControlGroup.prototype.onDestroy = function () { this.formDirective.removeControlGroup(this); };
    Object.defineProperty(NgControlGroup.prototype, "control", {
        get: function () { return this.formDirective.getControlGroup(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "path", {
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    NgControlGroup = __decorate([
        metadata_1.Directive({
            selector: '[ng-control-group]',
            bindings: [controlGroupBinding],
            inputs: ['name: ng-control-group'],
            exportAs: 'form'
        }),
        __param(0, di_1.Host()),
        __param(0, di_1.SkipSelf()), 
        __metadata('design:paramtypes', [control_container_1.ControlContainer])
    ], NgControlGroup);
    return NgControlGroup;
})(control_container_1.ControlContainer);
exports.NgControlGroup = NgControlGroup;

},{"./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var ng_control_1 = require('./ng_control');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
var controlNameBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgControlName; }) }));
/**
 * Creates and binds a control with a specified name to a DOM element.
 *
 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.

 * # Example
 *
 * In this example, we create the login and password controls.
 * We can work with each control separately: check its validity, get its value, listen to its
 * changes.
 *
 *  ```
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form #f="form" (submit)='onLogIn(f.value)'>
 *          Login <input type='text' ng-control='login' #l="form">
 *          <div *ng-if="!l.valid">Login is invalid</div>
 *
 *          Password <input type='password' ng-control='password'>
 *          <button type='submit'>Log in!</button>
 *        </form>
 *      `})
 * class LoginComp {
 *  onLogIn(value): void {
 *    // value === {login: 'some login', password: 'some password'}
 *  }
 * }
 *  ```
 *
 * We can also use ng-model to bind a domain model to the form.
 *
 *  ```
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form (submit)='onLogIn()'>
 *          Login <input type='text' ng-control='login' [(ng-model)]="credentials.login">
 *          Password <input type='password' ng-control='password'
 *                          [(ng-model)]="credentials.password">
 *          <button type='submit'>Log in!</button>
 *        </form>
 *      `})
 * class LoginComp {
 *  credentials: {login:string, password:string};
 *
 *  onLogIn(): void {
 *    // this.credentials.login === "some login"
 *    // this.credentials.password === "some password"
 *  }
 * }
 *  ```
 */
var NgControlName = (function (_super) {
    __extends(NgControlName, _super);
    function NgControlName(parent, validators, valueAccessors) {
        _super.call(this);
        this.update = new async_1.EventEmitter();
        /** @internal */
        this._added = false;
        this._parent = parent;
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgControlName.prototype.onChanges = function (changes) {
        if (!this._added) {
            this.formDirective.addControl(this);
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    };
    NgControlName.prototype.onDestroy = function () { this.formDirective.removeControl(this); };
    NgControlName.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    Object.defineProperty(NgControlName.prototype, "path", {
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "formDirective", {
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "control", {
        get: function () { return this.formDirective.getControl(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgControlName = __decorate([
        metadata_1.Directive({
            selector: '[ng-control]',
            bindings: [controlNameBinding],
            inputs: ['name: ngControl', 'model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Host()),
        __param(0, di_1.SkipSelf()),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(2, di_1.Optional()),
        __param(2, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [control_container_1.ControlContainer, Array, Array])
    ], NgControlName);
    return NgControlName;
})(ng_control_1.NgControl);
exports.NgControlName = NgControlName;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var ng_control_1 = require('./ng_control');
var lang_1 = require('angular2/src/core/facade/lang');
var NgControlStatus = (function () {
    function NgControlStatus(cd) {
        this._cd = cd;
    }
    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    NgControlStatus = __decorate([
        metadata_1.Directive({
            selector: '[ng-control],[ng-model],[ng-form-control]',
            host: {
                '[class.ng-untouched]': 'ngClassUntouched',
                '[class.ng-touched]': 'ngClassTouched',
                '[class.ng-pristine]': 'ngClassPristine',
                '[class.ng-dirty]': 'ngClassDirty',
                '[class.ng-valid]': 'ngClassValid',
                '[class.ng-invalid]': 'ngClassInvalid'
            }
        }),
        __param(0, di_1.Self()), 
        __metadata('design:paramtypes', [ng_control_1.NgControl])
    ], NgControlStatus);
    return NgControlStatus;
})();
exports.NgControlStatus = NgControlStatus;

},{"./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var model_1 = require('../model');
var shared_1 = require('./shared');
var formDirectiveProvider = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgForm; }) }));
/**
 * If `NgForm` is bound in a component, `<form>` elements in that component will be
 * upgraded to use the Angular form system.
 *
 * # Typical Use
 *
 * Include `FORM_DIRECTIVES` in the `directives` section of a {@link View} annotation
 * to use `NgForm` and its associated controls.
 *
 * # Structure
 *
 * An Angular form is a collection of `Control`s in some hierarchy.
 * `Control`s can be at the top level or can be organized in `ControlGroup`s
 * or `ControlArray`s. This hierarchy is reflected in the form's `value`, a
 * JSON object that mirrors the form structure.
 *
 * # Submission
 *
 * The `ng-submit` event signals when the user triggers a form submission.
 *
 * ### Example ([live demo](http://plnkr.co/edit/ltdgYj4P0iY64AR71EpL?p=preview))
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <p>Submit the form to see the data object Angular builds</p>
 *       <h2>NgForm demo</h2>
 *       <form #f="form" (ng-submit)="onSubmit(f.value)">
 *         <h3>Control group: credentials</h3>
 *         <div ng-control-group="credentials">
 *           <p>Login: <input type="text" ng-control="login"></p>
 *           <p>Password: <input type="password" ng-control="password"></p>
 *         </div>
 *         <h3>Control group: person</h3>
 *         <div ng-control-group="person">
 *           <p>First name: <input type="text" ng-control="firstName"></p>
 *           <p>Last name: <input type="text" ng-control="lastName"></p>
 *         </div>
 *         <button type="submit">Submit Form</button>
 *       <p>Form data submitted:</p>
 *       </form>
 *       <pre>{{data}}</pre>
 *     </div>
 * `,
 *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
 * })
 * export class App {
 *   constructor() {}
 *
 *   data: string;
 *
 *   onSubmit(data) {
 *     this.data = JSON.stringify(data, null, 2);
 *   }
 * }
 *  ```
 */
var NgForm = (function (_super) {
    __extends(NgForm, _super);
    function NgForm() {
        _super.apply(this, arguments);
        this.form = new model_1.ControlGroup({});
        this.ngSubmit = new async_1.EventEmitter();
    }
    Object.defineProperty(NgForm.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
        get: function () { return this.form.controls; },
        enumerable: true,
        configurable: true
    });
    NgForm.prototype.addControl = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            var ctrl = new model_1.Control();
            shared_1.setUpControl(ctrl, dir);
            container.addControl(dir.name, ctrl);
            ctrl.updateValidity();
        });
    };
    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgForm.prototype.removeControl = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
            }
        });
    };
    NgForm.prototype.addControlGroup = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            var group = new model_1.ControlGroup({});
            container.addControl(dir.name, group);
            group.updateValidity();
        });
    };
    NgForm.prototype.removeControlGroup = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
            }
        });
    };
    NgForm.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgForm.prototype.updateModel = function (dir, value) {
        var _this = this;
        this._later(function (_) {
            var ctrl = _this.form.find(dir.path);
            ctrl.updateValue(value);
        });
    };
    NgForm.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgForm.prototype._findContainer = function (path) {
        path.pop();
        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
    };
    /** @internal */
    NgForm.prototype._later = function (fn) { async_1.PromiseWrapper.then(async_1.PromiseWrapper.resolve(null), fn, function (_) { }); };
    NgForm = __decorate([
        metadata_1.Directive({
            selector: 'form:not([ng-no-form]):not([ng-form-model]),ng-form,[ng-form]',
            bindings: [formDirectiveProvider],
            host: {
                '(submit)': 'onSubmit()',
            },
            outputs: ['ngSubmit'],
            exportAs: 'form'
        }), 
        __metadata('design:paramtypes', [])
    ], NgForm);
    return NgForm;
})(control_container_1.ControlContainer);
exports.NgForm = NgForm;

},{"../model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var ng_control_1 = require('./ng_control');
var validators_1 = require('../validators');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
var formControlBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgFormControl; }) }));
/**
 * Binds an existing {@link Control} to a DOM element.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jcQlZ2tTh22BZZ2ucNAT?p=preview))
 *
 * In this example, we bind the control to an input element. When the value of the input element
 * changes, the value of the control will reflect that change. Likewise, if the value of the
 * control changes, the input element reflects that change.
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <h2>NgFormControl Example</h2>
 *       <form>
 *         <p>Element with existing control: <input type="text"
 * [ng-form-control]="loginControl"></p>
 *         <p>Value of existing control: {{loginControl.value}}</p>
 *       </form>
 *     </div>
 *   `,
 *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
 * })
 * export class App {
 *   loginControl: Control = new Control('');
 * }
 *  ```
 *
 * # ng-model
 *
 * We can also use `ng-model` to bind a domain model to the form.
 *
 * ### Example ([live demo](http://plnkr.co/edit/yHMLuHO7DNgT8XvtjTDH?p=preview))
 *
 *  ```typescript
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: "<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>"
 *      })
 * class LoginComp {
 *  loginControl: Control = new Control('');
 *  login:string;
 * }
 *  ```
 */
var NgFormControl = (function (_super) {
    __extends(NgFormControl, _super);
    function NgFormControl(validators, valueAccessors) {
        _super.call(this);
        this.update = new async_1.EventEmitter();
        /** @internal */
        this._added = false;
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgFormControl.prototype.onChanges = function (changes) {
        if (!this._added) {
            shared_1.setUpControl(this.form, this);
            this.form.updateValidity();
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.form.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgFormControl.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgFormControl.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    NgFormControl = __decorate([
        metadata_1.Directive({
            selector: '[ng-form-control]',
            bindings: [formControlBinding],
            inputs: ['form: ngFormControl', 'model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Optional()),
        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [Array, Array])
    ], NgFormControl);
    return NgFormControl;
})(ng_control_1.NgControl);
exports.NgFormControl = NgFormControl;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var formDirectiveProvider = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgFormModel; }) }));
/**
 * Binds an existing control group to a DOM element.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jqrVirudY8anJxTMUjTP?p=preview))
 *
 * In this example, we bind the control group to the form element, and we bind the login and
 * password controls to the login and password elements.
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <h2>NgFormModel Example</h2>
 *       <form [ng-form-model]="loginForm">
 *         <p>Login: <input type="text" ng-control="login"></p>
 *         <p>Password: <input type="password" ng-control="password"></p>
 *       </form>
 *       <p>Value:</p>
 *       <pre>{{value}}</pre>
 *     </div>
 *   `,
 *   directives: [FORM_DIRECTIVES]
 * })
 * export class App {
 *   loginForm: ControlGroup;
 *
 *   constructor() {
 *     this.loginForm = new ControlGroup({
 *       login: new Control(""),
 *       password: new Control("")
 *     });
 *   }
 *
 *   get value(): string {
 *     return JSON.stringify(this.loginForm.value, null, 2);
 *   }
 * }
 *  ```
 *
 * We can also use ng-model to bind a domain model to the form.
 *
 *  ```typescript
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form [ng-form-model]='loginForm'>
 *          Login <input type='text' ng-control='login' [(ng-model)]='credentials.login'>
 *          Password <input type='password' ng-control='password'
 *                          [(ng-model)]='credentials.password'>
 *          <button (click)="onLogin()">Login</button>
 *        </form>`
 *      })
 * class LoginComp {
 *  credentials: {login: string, password: string};
 *  loginForm: ControlGroup;
 *
 *  constructor() {
 *    this.loginForm = new ControlGroup({
 *      login: new Control(""),
 *      password: new Control("")
 *    });
 *  }
 *
 *  onLogin(): void {
 *    // this.credentials.login === 'some login'
 *    // this.credentials.password === 'some password'
 *  }
 * }
 *  ```
 */
var NgFormModel = (function (_super) {
    __extends(NgFormModel, _super);
    function NgFormModel() {
        _super.apply(this, arguments);
        this.form = null;
        this.directives = [];
        this.ngSubmit = new async_1.EventEmitter();
    }
    NgFormModel.prototype.onChanges = function (_) { this._updateDomValue(); };
    Object.defineProperty(NgFormModel.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    NgFormModel.prototype.addControl = function (dir) {
        var ctrl = this.form.find(dir.path);
        shared_1.setUpControl(ctrl, dir);
        ctrl.updateValidity();
        this.directives.push(dir);
    };
    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };
    NgFormModel.prototype.addControlGroup = function (dir) { };
    NgFormModel.prototype.removeControlGroup = function (dir) { };
    NgFormModel.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgFormModel.prototype.updateModel = function (dir, value) {
        var ctrl = this.form.find(dir.path);
        ctrl.updateValue(value);
    };
    NgFormModel.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgFormModel.prototype._updateDomValue = function () {
        var _this = this;
        this.directives.forEach(function (dir) {
            var ctrl = _this.form.find(dir.path);
            dir.valueAccessor.writeValue(ctrl.value);
        });
    };
    NgFormModel = __decorate([
        metadata_1.Directive({
            selector: '[ng-form-model]',
            bindings: [formDirectiveProvider],
            inputs: ['form: ng-form-model'],
            host: { '(submit)': 'onSubmit()' },
            outputs: ['ngSubmit'],
            exportAs: 'form'
        }), 
        __metadata('design:paramtypes', [])
    ], NgFormModel);
    return NgFormModel;
})(control_container_1.ControlContainer);
exports.NgFormModel = NgFormModel;

},{"./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var ng_control_1 = require('./ng_control');
var model_1 = require('../model');
var validators_1 = require('../validators');
var shared_1 = require('./shared');
var formControlBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgModel; }) }));
/**
 * Binds a domain model to a form control.
 *
 * # Usage
 *
 * `ng-model` binds an existing domain model to a form control. For a
 * two-way binding, use `[(ng-model)]` to ensure the model updates in
 * both directions.
 *
 * ### Example ([live demo](http://plnkr.co/edit/R3UX5qDaUqFO2VYR0UzH?p=preview))
 *  ```typescript
 * @Component({
 *      selector: "search-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `<input type='text' [(ng-model)]="searchQuery">`
 *      })
 * class SearchComp {
 *  searchQuery: string;
 * }
 *  ```
 */
var NgModel = (function (_super) {
    __extends(NgModel, _super);
    function NgModel(validators, valueAccessors) {
        _super.call(this);
        /** @internal */
        this._control = new model_1.Control();
        /** @internal */
        this._added = false;
        this.update = new async_1.EventEmitter();
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgModel.prototype.onChanges = function (changes) {
        if (!this._added) {
            shared_1.setUpControl(this._control, this);
            this._control.updateValidity();
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this._control.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgModel.prototype, "control", {
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgModel.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    NgModel = __decorate([
        metadata_1.Directive({
            selector: '[ng-model]:not([ng-control]):not([ng-form-control])',
            bindings: [formControlBinding],
            inputs: ['model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Optional()),
        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [Array, Array])
    ], NgModel);
    return NgModel;
})(ng_control_1.NgControl);
exports.NgModel = NgModel;

},{"../model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var render_1 = require('angular2/src/core/render');
var linker_1 = require('angular2/src/core/linker');
var metadata_1 = require('angular2/src/core/metadata');
var async_1 = require('angular2/src/core/facade/async');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var SELECT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return SelectControlValueAccessor; }), multi: true }));
/**
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * #Example:
 *
 * ```
 * <select ng-control="city">
 *   <option *ng-for="#c of cities" [value]="c"></option>
 * </select>
 * ```
 */
var NgSelectOption = (function () {
    function NgSelectOption() {
    }
    NgSelectOption = __decorate([
        metadata_1.Directive({ selector: 'option' }), 
        __metadata('design:paramtypes', [])
    ], NgSelectOption);
    return NgSelectOption;
})();
exports.NgSelectOption = NgSelectOption;
/**
 * The accessor for writing a value and listening to changes on a select element.
 */
var SelectControlValueAccessor = (function () {
    function SelectControlValueAccessor(_renderer, _elementRef, query) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
        this._updateValueWhenListOfOptionsChanges(query);
    }
    SelectControlValueAccessor.prototype.writeValue = function (value) {
        this.value = value;
        shared_1.setProperty(this._renderer, this._elementRef, "value", value);
    };
    SelectControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    SelectControlValueAccessor.prototype._updateValueWhenListOfOptionsChanges = function (query) {
        var _this = this;
        async_1.ObservableWrapper.subscribe(query.changes, function (_) { return _this.writeValue(_this.value); });
    };
    SelectControlValueAccessor = __decorate([
        metadata_1.Directive({
            selector: 'select[ng-control],select[ng-form-control],select[ng-model]',
            host: {
                '(change)': 'onChange($event.target.value)',
                '(input)': 'onChange($event.target.value)',
                '(blur)': 'onTouched()'
            },
            bindings: [SELECT_VALUE_ACCESSOR]
        }),
        __param(2, metadata_1.Query(NgSelectOption, { descendants: true })), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef, linker_1.QueryList])
    ], SelectControlValueAccessor);
    return SelectControlValueAccessor;
})();
exports.SelectControlValueAccessor = SelectControlValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var validators_1 = require('../validators');
var default_value_accessor_1 = require('./default_value_accessor');
var checkbox_value_accessor_1 = require('./checkbox_value_accessor');
var select_control_value_accessor_1 = require('./select_control_value_accessor');
function controlPath(name, parent) {
    var p = collection_1.ListWrapper.clone(parent.path);
    p.push(name);
    return p;
}
exports.controlPath = controlPath;
function setUpControl(control, dir) {
    if (lang_1.isBlank(control))
        _throwError(dir, "Cannot find control");
    if (lang_1.isBlank(dir.valueAccessor))
        _throwError(dir, "No value accessor for");
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    dir.valueAccessor.writeValue(control.value);
    // view -> model
    dir.valueAccessor.registerOnChange(function (newValue) {
        dir.viewToModelUpdate(newValue);
        control.updateValue(newValue, { emitModelToViewChange: false });
        control.markAsDirty();
    });
    // model -> view
    control.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });
    // touched
    dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
}
exports.setUpControl = setUpControl;
function _throwError(dir, message) {
    var path = dir.path.join(" -> ");
    throw new exceptions_1.BaseException(message + " '" + path + "'");
}
function setProperty(renderer, elementRef, propName, propValue) {
    renderer.setElementProperty(elementRef, propName, propValue);
}
exports.setProperty = setProperty;
function isPropertyUpdated(changes, viewModel) {
    if (!collection_1.StringMapWrapper.contains(changes, "model"))
        return false;
    var change = changes["model"];
    if (change.isFirstChange())
        return true;
    return !lang_1.looseIdentical(viewModel, change.currentValue);
}
exports.isPropertyUpdated = isPropertyUpdated;
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
    if (lang_1.isBlank(valueAccessors))
        return null;
    var defaultAccessor;
    var builtinAccessor;
    var customAccessor;
    valueAccessors.forEach(function (v) {
        if (v instanceof default_value_accessor_1.DefaultValueAccessor) {
            defaultAccessor = v;
        }
        else if (v instanceof checkbox_value_accessor_1.CheckboxControlValueAccessor ||
            v instanceof select_control_value_accessor_1.SelectControlValueAccessor) {
            if (lang_1.isPresent(builtinAccessor))
                _throwError(dir, "More than one built-in value accessor matches");
            builtinAccessor = v;
        }
        else {
            if (lang_1.isPresent(customAccessor))
                _throwError(dir, "More than one custom value accessor matches");
            customAccessor = v;
        }
    });
    if (lang_1.isPresent(customAccessor))
        return customAccessor;
    if (lang_1.isPresent(builtinAccessor))
        return builtinAccessor;
    if (lang_1.isPresent(defaultAccessor))
        return defaultAccessor;
    _throwError(dir, "No valid value accessor for");
    return null;
}
exports.selectValueAccessor = selectValueAccessor;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var validators_1 = require('../validators');
var lang_2 = require("angular2/src/core/facade/lang");
var REQUIRED_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, { useValue: validators_1.Validators.required, multi: true }));
var RequiredValidator = (function () {
    function RequiredValidator() {
    }
    RequiredValidator = __decorate([
        metadata_1.Directive({
            selector: '[required][ng-control],[required][ng-form-control],[required][ng-model]',
            providers: [REQUIRED_VALIDATOR]
        }), 
        __metadata('design:paramtypes', [])
    ], RequiredValidator);
    return RequiredValidator;
})();
exports.RequiredValidator = RequiredValidator;
function createMinLengthValidator(dir) {
    return validators_1.Validators.minLength(dir.minLength);
}
var MIN_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, {
    useFactory: createMinLengthValidator,
    deps: [di_1.forwardRef(function () { return MinLengthValidator; })],
    multi: true
}));
var MinLengthValidator = (function () {
    function MinLengthValidator(minLength) {
        this.minLength = lang_2.NumberWrapper.parseInt(minLength, 10);
    }
    MinLengthValidator = __decorate([
        metadata_1.Directive({
            selector: '[minlength][ng-control],[minlength][ng-form-control],[minlength][ng-model]',
            providers: [MIN_LENGTH_VALIDATOR]
        }),
        __param(0, metadata_1.Attribute("minlength")), 
        __metadata('design:paramtypes', [String])
    ], MinLengthValidator);
    return MinLengthValidator;
})();
exports.MinLengthValidator = MinLengthValidator;
function createMaxLengthValidator(dir) {
    return validators_1.Validators.maxLength(dir.maxLength);
}
var MAX_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, {
    useFactory: createMaxLengthValidator,
    deps: [di_1.forwardRef(function () { return MaxLengthValidator; })],
    multi: true
}));
var MaxLengthValidator = (function () {
    function MaxLengthValidator(maxLength) {
        this.maxLength = lang_2.NumberWrapper.parseInt(maxLength, 10);
    }
    MaxLengthValidator = __decorate([
        metadata_1.Directive({
            selector: '[maxlength][ng-control],[maxlength][ng-form-control],[maxlength][ng-model]',
            providers: [MAX_LENGTH_VALIDATOR]
        }),
        __param(0, metadata_1.Attribute("maxlength")), 
        __metadata('design:paramtypes', [String])
    ], MaxLengthValidator);
    return MaxLengthValidator;
})();
exports.MaxLengthValidator = MaxLengthValidator;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/form_builder.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var modelModule = require('./model');
/**
 * Creates a form object from a user-specified configuration.
 *
 * # Example
 *
 * ```
 * import {Component, bootstrap} from 'angular2/angular2';
 * import {FormBuilder, Validators, FORM_DIRECTIVES, ControlGroup} from 'angular2/core';
 *
 * @Component({
 *   selector: 'login-comp',
 *   viewProviders: [FormBuilder],
 *   template: `
 *     <form [control-group]="loginForm">
 *       Login <input control="login">
 *
 *       <div control-group="passwordRetry">
 *         Password <input type="password" control="password">
 *         Confirm password <input type="password" control="passwordConfirmation">
 *       </div>
 *     </form>
 *   `,
 *   directives: [FORM_DIRECTIVES]
 * })
 * class LoginComp {
 *   loginForm: ControlGroup;
 *
 *   constructor(builder: FormBuilder) {
 *     this.loginForm = builder.group({
 *       login: ["", Validators.required],
 *
 *       passwordRetry: builder.group({
 *         password: ["", Validators.required],
 *         passwordConfirmation: ["", Validators.required]
 *       })
 *     });
 *   }
 * }
 *
 * bootstrap(LoginComp);
 * ```
 *
 * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a
 * nested {@link ControlGroup} that defines a `password` and a `passwordConfirmation`
 * {@link Control}:
 *
 * ```
 *  var loginForm = builder.group({
 *    login: ["", Validators.required],
 *
 *    passwordRetry: builder.group({
 *      password: ["", Validators.required],
 *      passwordConfirmation: ["", Validators.required]
 *    })
 *  });
 *
 *  ```
 */
var FormBuilder = (function () {
    function FormBuilder() {
    }
    FormBuilder.prototype.group = function (controlsConfig, extra) {
        if (extra === void 0) { extra = null; }
        var controls = this._reduceControls(controlsConfig);
        var optionals = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "optionals") : null;
        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "validator") : null;
        if (lang_1.isPresent(validator)) {
            return new modelModule.ControlGroup(controls, optionals, validator);
        }
        else {
            return new modelModule.ControlGroup(controls, optionals);
        }
    };
    FormBuilder.prototype.control = function (value, validator) {
        if (validator === void 0) { validator = null; }
        if (lang_1.isPresent(validator)) {
            return new modelModule.Control(value, validator);
        }
        else {
            return new modelModule.Control(value);
        }
    };
    FormBuilder.prototype.array = function (controlsConfig, validator) {
        var _this = this;
        if (validator === void 0) { validator = null; }
        var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
        if (lang_1.isPresent(validator)) {
            return new modelModule.ControlArray(controls, validator);
        }
        else {
            return new modelModule.ControlArray(controls);
        }
    };
    /** @internal */
    FormBuilder.prototype._reduceControls = function (controlsConfig) {
        var _this = this;
        var controls = {};
        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
            controls[controlName] = _this._createControl(controlConfig);
        });
        return controls;
    };
    /** @internal */
    FormBuilder.prototype._createControl = function (controlConfig) {
        if (controlConfig instanceof modelModule.Control ||
            controlConfig instanceof modelModule.ControlGroup ||
            controlConfig instanceof modelModule.ControlArray) {
            return controlConfig;
        }
        else if (lang_1.isArray(controlConfig)) {
            var value = controlConfig[0];
            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
            return this.control(value, validator);
        }
        else {
            return this.control(controlConfig);
        }
    };
    FormBuilder = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], FormBuilder);
    return FormBuilder;
})();
exports.FormBuilder = FormBuilder;

},{"./model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var validators_1 = require('./validators');
/**
 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
 */
exports.VALID = "VALID";
/**
 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
 */
exports.INVALID = "INVALID";
function isControl(control) {
    return control instanceof AbstractControl;
}
exports.isControl = isControl;
function _find(control, path) {
    if (lang_1.isBlank(path))
        return null;
    if (!(path instanceof Array)) {
        path = path.split("/");
    }
    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
        return null;
    return collection_1.ListWrapper.reduce(path, function (v, name) {
        if (v instanceof ControlGroup) {
            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
        }
        else if (v instanceof ControlArray) {
            var index = name;
            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
        }
        else {
            return null;
        }
    }, control);
}
/**
 * Omitting from external API doc as this is really an abstract internal concept.
 */
var AbstractControl = (function () {
    function AbstractControl(validator) {
        this.validator = validator;
        /** @internal */
        this._pristine = true;
        /** @internal */
        this._touched = false;
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
        get: function () { return this._value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
        get: function () { return this._status; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
        get: function () { return this._status === exports.VALID; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
        get: function () { return this._errors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
        get: function () { return this._pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
        get: function () { return !this.pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
        get: function () { return this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
        get: function () { return !this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
        get: function () { return this._valueChanges; },
        enumerable: true,
        configurable: true
    });
    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };
    AbstractControl.prototype.markAsDirty = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._pristine = false;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.markAsDirty({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
    AbstractControl.prototype.updateValidity = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._errors = this.validator(this);
        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.updateValidity({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.updateValueAndValidity = function (_a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
        onlySelf = lang_1.normalizeBool(onlySelf);
        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
        this._updateValue();
        if (emitEvent) {
            async_1.ObservableWrapper.callNext(this._valueChanges, this._value);
        }
        this._errors = this.validator(this);
        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
        }
    };
    AbstractControl.prototype.find = function (path) { return _find(this, path); };
    AbstractControl.prototype.getError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
        if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
            return collection_1.StringMapWrapper.get(control._errors, errorCode);
        }
        else {
            return null;
        }
    };
    AbstractControl.prototype.hasError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        return lang_1.isPresent(this.getError(errorCode, path));
    };
    /** @internal */
    AbstractControl.prototype._updateValue = function () { };
    return AbstractControl;
})();
exports.AbstractControl = AbstractControl;
/**
 * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
 * validation state, which is determined by an optional validation function.
 *
 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
 * with {@link ControlGroup} and {@link ControlArray}.
 *
 * # Usage
 *
 * By default, a `Control` is created for every `<input>` or other form component.
 * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
 * bound to a DOM element instead. This `Control` can be configured with a custom
 * validation function.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var Control = (function (_super) {
    __extends(Control, _super);
    function Control(value, validator) {
        if (value === void 0) { value = null; }
        if (validator === void 0) { validator = validators_1.Validators.nullValidator; }
        _super.call(this, validator);
        this._value = value;
        this.updateValidity({ onlySelf: true });
        this._valueChanges = new async_1.EventEmitter();
    }
    /**
     * Set the value of the control to `value`.
     *
     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
     * and not its parent component. If `emitEvent` is `true`, this change will cause a
     * `valueChanges` event on the `Control` to be emitted. Both of these options default to
     * `false`.
     *
     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
     * specified.
     */
    Control.prototype.updateValue = function (value, _a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;
        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
        this._value = value;
        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
            this._onChange(this._value);
        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
    };
    /**
     * Register a listener for change events.
     */
    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };
    return Control;
})(AbstractControl);
exports.Control = Control;
/**
 * Defines a part of a form, of fixed length, that can contain other controls.
 *
 * A `ControlGroup` aggregates the values and errors of each {@link Control} in the group. Thus, if
 * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
 * changes its value, the entire group changes as well.
 *
 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
 * controls, but is of variable length.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlGroup = (function (_super) {
    __extends(ControlGroup, _super);
    function ControlGroup(controls, optionals, validator) {
        if (optionals === void 0) { optionals = null; }
        if (validator === void 0) { validator = validators_1.Validators.group; }
        _super.call(this, validator);
        this.controls = controls;
        this._optionals = lang_1.isPresent(optionals) ? optionals : {};
        this._valueChanges = new async_1.EventEmitter();
        this._setParentForControls();
        this._value = this._reduceValue();
        this.updateValidity({ onlySelf: true });
    }
    ControlGroup.prototype.addControl = function (name, control) {
        this.controls[name] = control;
        control.setParent(this);
    };
    ControlGroup.prototype.removeControl = function (name) { collection_1.StringMapWrapper.delete(this.controls, name); };
    ControlGroup.prototype.include = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, true);
        this.updateValueAndValidity();
    };
    ControlGroup.prototype.exclude = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, false);
        this.updateValueAndValidity();
    };
    ControlGroup.prototype.contains = function (controlName) {
        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
        return c && this._included(controlName);
    };
    /** @internal */
    ControlGroup.prototype._setParentForControls = function () {
        var _this = this;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });
    };
    /** @internal */
    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
    /** @internal */
    ControlGroup.prototype._reduceValue = function () {
        return this._reduceChildren({}, function (acc, control, name) {
            acc[name] = control.value;
            return acc;
        });
    };
    /** @internal */
    ControlGroup.prototype._reduceChildren = function (initValue, fn) {
        var _this = this;
        var res = initValue;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
            if (_this._included(name)) {
                res = fn(res, control, name);
            }
        });
        return res;
    };
    /** @internal */
    ControlGroup.prototype._included = function (controlName) {
        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
    };
    return ControlGroup;
})(AbstractControl);
exports.ControlGroup = ControlGroup;
/**
 * Defines a part of a form, of variable length, that can contain other controls.
 *
 * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
 * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
 * changes its value, the entire group changes as well.
 *
 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
 * other controls, but is of fixed length.
 *
 * # Adding or removing controls
 *
 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
 * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `ControlArray` directly, as that will result in strange and unexpected behavior such
 * as broken change detection.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlArray = (function (_super) {
    __extends(ControlArray, _super);
    function ControlArray(controls, validator) {
        if (validator === void 0) { validator = validators_1.Validators.array; }
        _super.call(this, validator);
        this.controls = controls;
        this._valueChanges = new async_1.EventEmitter();
        this._setParentForControls();
        this._updateValue();
        this.updateValidity({ onlySelf: true });
    }
    /**
     * Get the {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.at = function (index) { return this.controls[index]; };
    /**
     * Insert a new {@link AbstractControl} at the end of the array.
     */
    ControlArray.prototype.push = function (control) {
        this.controls.push(control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Insert a new {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.insert = function (index, control) {
        collection_1.ListWrapper.insert(this.controls, index, control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Remove the control at the given `index` in the array.
     */
    ControlArray.prototype.removeAt = function (index) {
        collection_1.ListWrapper.removeAt(this.controls, index);
        this.updateValueAndValidity();
    };
    Object.defineProperty(ControlArray.prototype, "length", {
        /**
         * Get the length of the control array.
         */
        get: function () { return this.controls.length; },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ControlArray.prototype._updateValue = function () { this._value = this.controls.map(function (control) { return control.value; }); };
    /** @internal */
    ControlArray.prototype._setParentForControls = function () {
        var _this = this;
        this.controls.forEach(function (control) { control.setParent(_this); });
    };
    return ControlArray;
})(AbstractControl);
exports.ControlArray = ControlArray;

},{"./validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var lang_2 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
exports.NG_VALIDATORS = lang_2.CONST_EXPR(new di_1.OpaqueToken("NgValidators"));
/**
 * Provides a set of validators used by form controls.
 *
 * # Example
 *
 * ```
 * var loginControl = new Control("", Validators.required)
 * ```
 */
var Validators = (function () {
    function Validators() {
    }
    Validators.required = function (control) {
        return lang_1.isBlank(control.value) || control.value == "" ? { "required": true } : null;
    };
    Validators.minLength = function (minLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length < minLength ?
                { "minlength": { "requiredLength": minLength, "actualLength": v.length } } :
                null;
        };
    };
    Validators.maxLength = function (maxLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length > maxLength ?
                { "maxlength": { "requiredLength": maxLength, "actualLength": v.length } } :
                null;
        };
    };
    Validators.nullValidator = function (c) { return null; };
    Validators.compose = function (validators) {
        if (lang_1.isBlank(validators))
            return Validators.nullValidator;
        return function (control) {
            var res = collection_1.ListWrapper.reduce(validators, function (res, validator) {
                var errors = validator(control);
                return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
            }, {});
            return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
        };
    };
    Validators.group = function (group) {
        var res = {};
        collection_1.StringMapWrapper.forEach(group.controls, function (control, name) {
            if (group.contains(name) && lang_1.isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
            }
        });
        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
    };
    Validators.array = function (array) {
        var res = {};
        array.controls.forEach(function (control) {
            if (lang_1.isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
            }
        });
        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
    };
    Validators._mergeErrors = function (control, res) {
        collection_1.StringMapWrapper.forEach(control.errors, function (value, error) {
            if (!collection_1.StringMapWrapper.contains(res, error)) {
                res[error] = [];
            }
            var current = res[error];
            current.push(control);
        });
    };
    return Validators;
})();
exports.Validators = Validators;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var profile_1 = require('../profile/profile');
/**
 * Provides access to explicitly trigger change detection in an application.
 *
 * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When
 * testing, or in some
 * limited application use cases, a developer can also trigger change detection with the
 * `lifecycle.tick()` method.
 *
 * Each Angular application has a single `LifeCycle` instance.
 *
 * # Example
 *
 * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which
 * invokes
 * `lifecycle.tick()` on your behalf.
 *
 * ```javascript
 * bootstrap(MyApp).then((ref:ComponentRef) => {
 *   var lifeCycle = ref.injector.get(LifeCycle);
 *   var myApp = ref.instance;
 *
 *   ref.doSomething();
 *   lifecycle.tick();
 * });
 * ```
 */
var LifeCycle = (function () {
    function LifeCycle() {
    }
    return LifeCycle;
})();
exports.LifeCycle = LifeCycle;
var LifeCycle_ = (function (_super) {
    __extends(LifeCycle_, _super);
    function LifeCycle_(changeDetector, enforceNoNewChanges) {
        if (changeDetector === void 0) { changeDetector = null; }
        if (enforceNoNewChanges === void 0) { enforceNoNewChanges = false; }
        _super.call(this);
        /** @internal */
        this._runningTick = false;
        this._changeDetectors = [];
        if (lang_1.isPresent(changeDetector)) {
            this._changeDetectors.push(changeDetector);
        }
        this._enforceNoNewChanges = enforceNoNewChanges;
    }
    LifeCycle_.prototype.registerWith = function (zone, changeDetector) {
        var _this = this;
        if (changeDetector === void 0) { changeDetector = null; }
        if (lang_1.isPresent(changeDetector)) {
            this._changeDetectors.push(changeDetector);
        }
        zone.overrideOnTurnDone(function () { return _this.tick(); });
    };
    LifeCycle_.prototype.tick = function () {
        if (this._runningTick) {
            throw new exceptions_1.BaseException("LifeCycle.tick is called recursively");
        }
        var s = LifeCycle_._tickScope();
        try {
            this._runningTick = true;
            this._changeDetectors.forEach(function (detector) { return detector.detectChanges(); });
            if (this._enforceNoNewChanges) {
                this._changeDetectors.forEach(function (detector) { return detector.checkNoChanges(); });
            }
        }
        finally {
            this._runningTick = false;
            profile_1.wtfLeave(s);
        }
    };
    LifeCycle_._tickScope = profile_1.wtfCreateScope('LifeCycle#tick()');
    LifeCycle_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [Object, Boolean])
    ], LifeCycle_);
    return LifeCycle_;
})(LifeCycle);
exports.LifeCycle_ = LifeCycle_;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/lifecycle.js":[function(require,module,exports){
'use strict';// Public API for LifeCycle
var life_cycle_1 = require('./life_cycle/life_cycle');
exports.LifeCycle = life_cycle_1.LifeCycle;

},{"./life_cycle/life_cycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js":[function(require,module,exports){
'use strict';// Public API for compiler
var directive_resolver_1 = require('./linker/directive_resolver');
exports.DirectiveResolver = directive_resolver_1.DirectiveResolver;
var compiler_1 = require('./linker/compiler');
exports.Compiler = compiler_1.Compiler;
var view_manager_1 = require('./linker/view_manager');
exports.AppViewManager = view_manager_1.AppViewManager;
var query_list_1 = require('./linker/query_list');
exports.QueryList = query_list_1.QueryList;
var dynamic_component_loader_1 = require('./linker/dynamic_component_loader');
exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
var element_ref_1 = require('./linker/element_ref');
exports.ElementRef = element_ref_1.ElementRef;
var template_ref_1 = require('./linker/template_ref');
exports.TemplateRef = template_ref_1.TemplateRef;
var view_ref_1 = require('./linker/view_ref');
exports.ViewRef = view_ref_1.ViewRef;
exports.ProtoViewRef = view_ref_1.ProtoViewRef;
var view_container_ref_1 = require('./linker/view_container_ref');
exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
var dynamic_component_loader_2 = require('./linker/dynamic_component_loader');
exports.ComponentRef = dynamic_component_loader_2.ComponentRef;

},{"./linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","./linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","./linker/element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./linker/query_list":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js","./linker/template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./linker/view_container_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js","./linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","./linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var proto_view_factory_1 = require('angular2/src/core/linker/proto_view_factory');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
/**
 * Low-level service for compiling {@link Component}s into {@link ProtoViewRef ProtoViews}s, which
 * can later be used to create and render a Component instance.
 *
 * Most applications should instead use higher-level {@link DynamicComponentLoader} service, which
 * both compiles and instantiates a Component.
 */
var Compiler = (function () {
    function Compiler() {
    }
    return Compiler;
})();
exports.Compiler = Compiler;
var Compiler_ = (function (_super) {
    __extends(Compiler_, _super);
    function Compiler_(_protoViewFactory) {
        _super.call(this);
        this._protoViewFactory = _protoViewFactory;
    }
    Compiler_.prototype.compileInHost = function (componentType) {
        var metadatas = reflection_1.reflector.annotations(componentType);
        var compiledHostTemplate = null;
        for (var i = 0; i < metadatas.length; i++) {
            var metadata = metadatas[i];
            if (metadata instanceof template_commands_1.CompiledHostTemplate) {
                compiledHostTemplate = metadata;
                break;
            }
        }
        if (lang_1.isBlank(compiledHostTemplate)) {
            throw new exceptions_1.BaseException("No precompiled template for component " + lang_1.stringify(componentType) + " found");
        }
        return async_1.PromiseWrapper.resolve(this._createProtoView(compiledHostTemplate));
    };
    Compiler_.prototype._createProtoView = function (compiledHostTemplate) {
        return this._protoViewFactory.createHost(compiledHostTemplate).ref;
    };
    Compiler_.prototype.clearCache = function () { this._protoViewFactory.clearCache(); };
    Compiler_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [proto_view_factory_1.ProtoViewFactory])
    ], Compiler_);
    return Compiler_;
})(Compiler);
exports.Compiler_ = Compiler_;
function internalCreateProtoView(compiler, compiledHostTemplate) {
    return compiler._createProtoView(compiledHostTemplate);
}
exports.internalCreateProtoView = internalCreateProtoView;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var interfaces_1 = require('./interfaces');
function hasLifecycleHook(lcInterface, token) {
    if (!(token instanceof lang_1.Type))
        return false;
    var proto = token.prototype;
    switch (lcInterface) {
        case interfaces_1.LifecycleHooks.AfterContentInit:
            return !!proto.afterContentInit;
        case interfaces_1.LifecycleHooks.AfterContentChecked:
            return !!proto.afterContentChecked;
        case interfaces_1.LifecycleHooks.AfterViewInit:
            return !!proto.afterViewInit;
        case interfaces_1.LifecycleHooks.AfterViewChecked:
            return !!proto.afterViewChecked;
        case interfaces_1.LifecycleHooks.OnChanges:
            return !!proto.onChanges;
        case interfaces_1.LifecycleHooks.DoCheck:
            return !!proto.doCheck;
        case interfaces_1.LifecycleHooks.OnDestroy:
            return !!proto.onDestroy;
        case interfaces_1.LifecycleHooks.OnInit:
            return !!proto.onInit;
        default:
            return false;
    }
}
exports.hasLifecycleHook = hasLifecycleHook;

},{"./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var metadata_1 = require('angular2/src/core/metadata');
var reflection_1 = require('angular2/src/core/reflection/reflection');
/*
 * Resolve a `Type` for {@link DirectiveMetadata}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var DirectiveResolver = (function () {
    function DirectiveResolver() {
    }
    /**
     * Return {@link DirectiveMetadata} for a given `Type`.
     */
    DirectiveResolver.prototype.resolve = function (type) {
        var typeMetadata = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
        if (lang_1.isPresent(typeMetadata)) {
            for (var i = 0; i < typeMetadata.length; i++) {
                var metadata = typeMetadata[i];
                if (metadata instanceof metadata_1.DirectiveMetadata) {
                    var propertyMetadata = reflection_1.reflector.propMetadata(type);
                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata);
                }
            }
        }
        throw new exceptions_1.BaseException("No Directive annotation found on " + lang_1.stringify(type));
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata) {
        var inputs = [];
        var outputs = [];
        var host = {};
        var queries = {};
        collection_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {
            metadata.forEach(function (a) {
                if (a instanceof metadata_1.InputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        inputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        inputs.push(propName);
                    }
                }
                if (a instanceof metadata_1.OutputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        outputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        outputs.push(propName);
                    }
                }
                if (a instanceof metadata_1.HostBindingMetadata) {
                    if (lang_1.isPresent(a.hostPropertyName)) {
                        host[("[" + a.hostPropertyName + "]")] = propName;
                    }
                    else {
                        host[("[" + propName + "]")] = propName;
                    }
                }
                if (a instanceof metadata_1.HostListenerMetadata) {
                    var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';
                    host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
                }
                if (a instanceof metadata_1.ContentChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ViewChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ContentChildMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ViewChildMetadata) {
                    queries[propName] = a;
                }
            });
        });
        return this._merge(dm, inputs, outputs, host, queries);
    };
    DirectiveResolver.prototype._merge = function (dm, inputs, outputs, host, queries) {
        var mergedInputs = lang_1.isPresent(dm.inputs) ? collection_1.ListWrapper.concat(dm.inputs, inputs) : inputs;
        var mergedOutputs = lang_1.isPresent(dm.outputs) ? collection_1.ListWrapper.concat(dm.outputs, outputs) : outputs;
        var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;
        var mergedQueries = lang_1.isPresent(dm.queries) ? collection_1.StringMapWrapper.merge(dm.queries, queries) : queries;
        if (dm instanceof metadata_1.ComponentMetadata) {
            return new metadata_1.ComponentMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                moduleId: dm.moduleId,
                queries: mergedQueries,
                changeDetection: dm.changeDetection,
                providers: dm.providers,
                viewProviders: dm.viewProviders
            });
        }
        else {
            return new metadata_1.DirectiveMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                moduleId: dm.moduleId,
                queries: mergedQueries,
                providers: dm.providers
            });
        }
    };
    DirectiveResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DirectiveResolver);
    return DirectiveResolver;
})();
exports.DirectiveResolver = DirectiveResolver;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var compiler_1 = require('./compiler');
var lang_1 = require('angular2/src/core/facade/lang');
var view_manager_1 = require('angular2/src/core/linker/view_manager');
/**
 * Represents an instance of a Component created via {@link DynamicComponentLoader}.
 *
 * `ComponentRef` provides access to the Component Instance as well other objects related to this
 * Component Instance and allows you to destroy the Component Instance via the {@link #dispose}
 * method.
 */
var ComponentRef = (function () {
    function ComponentRef() {
    }
    Object.defineProperty(ComponentRef.prototype, "hostView", {
        /**
         * The {@link ViewRef} of the Host View of this Component instance.
         */
        get: function () { return this.location.parentView; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "hostComponent", {
        /**
         * @internal
         *
         * The instance of the component.
         *
         * TODO(i): this api should be removed
         */
        get: function () { return this.instance; },
        enumerable: true,
        configurable: true
    });
    return ComponentRef;
})();
exports.ComponentRef = ComponentRef;
var ComponentRef_ = (function (_super) {
    __extends(ComponentRef_, _super);
    /**
     * TODO(i): refactor into public/private fields
     */
    function ComponentRef_(location, instance, componentType, injector, _dispose) {
        _super.call(this);
        this._dispose = _dispose;
        this.location = location;
        this.instance = instance;
        this.componentType = componentType;
        this.injector = injector;
    }
    Object.defineProperty(ComponentRef_.prototype, "hostComponentType", {
        /**
         * @internal
         *
         * Returns the type of this Component instance.
         *
         * TODO(i): this api should be removed
         */
        get: function () { return this.componentType; },
        enumerable: true,
        configurable: true
    });
    ComponentRef_.prototype.dispose = function () { this._dispose(); };
    return ComponentRef_;
})(ComponentRef);
exports.ComponentRef_ = ComponentRef_;
/**
 * Service for instantiating a Component and attaching it to a View at a specified location.
 */
var DynamicComponentLoader = (function () {
    function DynamicComponentLoader() {
    }
    return DynamicComponentLoader;
})();
exports.DynamicComponentLoader = DynamicComponentLoader;
var DynamicComponentLoader_ = (function (_super) {
    __extends(DynamicComponentLoader_, _super);
    function DynamicComponentLoader_(_compiler, _viewManager) {
        _super.call(this);
        this._compiler = _compiler;
        this._viewManager = _viewManager;
    }
    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelector, injector, onDispose) {
        var _this = this;
        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {
            var hostViewRef = _this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
            var newLocation = _this._viewManager.getHostElement(hostViewRef);
            var component = _this._viewManager.getComponent(newLocation);
            var dispose = function () {
                _this._viewManager.destroyRootHostView(hostViewRef);
                if (lang_1.isPresent(onDispose)) {
                    onDispose();
                }
            };
            return new ComponentRef_(newLocation, component, type, injector, dispose);
        });
    };
    DynamicComponentLoader_.prototype.loadIntoLocation = function (type, hostLocation, anchorName, providers) {
        if (providers === void 0) { providers = null; }
        return this.loadNextToLocation(type, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), providers);
    };
    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers) {
        var _this = this;
        if (providers === void 0) { providers = null; }
        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {
            var viewContainer = _this._viewManager.getViewContainer(location);
            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, providers);
            var newLocation = _this._viewManager.getHostElement(hostViewRef);
            var component = _this._viewManager.getComponent(newLocation);
            var dispose = function () {
                var index = viewContainer.indexOf(hostViewRef);
                if (index !== -1) {
                    viewContainer.remove(index);
                }
            };
            return new ComponentRef_(newLocation, component, type, null, dispose);
        });
    };
    DynamicComponentLoader_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [compiler_1.Compiler, view_manager_1.AppViewManager])
    ], DynamicComponentLoader_);
    return DynamicComponentLoader_;
})(DynamicComponentLoader);
exports.DynamicComponentLoader_ = DynamicComponentLoader_;

},{"./compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_binder.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var ElementBinder = (function () {
    function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective, nestedProtoView) {
        this.index = index;
        this.parent = parent;
        this.distanceToParent = distanceToParent;
        this.protoElementInjector = protoElementInjector;
        this.componentDirective = componentDirective;
        this.nestedProtoView = nestedProtoView;
        if (lang_1.isBlank(index)) {
            throw new exceptions_1.BaseException('null index not allowed.');
        }
    }
    return ElementBinder;
})();
exports.ElementBinder = ElementBinder;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var injector_1 = require('angular2/src/core/di/injector');
var provider_1 = require('angular2/src/core/di/provider');
var di_2 = require('../metadata/di');
var avmModule = require('./view_manager');
var view_container_ref_1 = require('./view_container_ref');
var element_ref_1 = require('./element_ref');
var template_ref_1 = require('./template_ref');
var directives_1 = require('../metadata/directives');
var directive_lifecycle_reflector_1 = require('./directive_lifecycle_reflector');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var query_list_1 = require('./query_list');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var event_config_1 = require('angular2/src/core/linker/event_config');
var pipe_provider_1 = require('angular2/src/core/pipes/pipe_provider');
var interfaces_1 = require('./interfaces');
var view_container_ref_2 = require("./view_container_ref");
var _staticKeys;
var StaticKeys = (function () {
    function StaticKeys() {
        this.viewManagerId = di_1.Key.get(avmModule.AppViewManager).id;
        this.templateRefId = di_1.Key.get(template_ref_1.TemplateRef).id;
        this.viewContainerId = di_1.Key.get(view_container_ref_1.ViewContainerRef).id;
        this.changeDetectorRefId = di_1.Key.get(change_detection_1.ChangeDetectorRef).id;
        this.elementRefId = di_1.Key.get(element_ref_1.ElementRef).id;
    }
    StaticKeys.instance = function () {
        if (lang_1.isBlank(_staticKeys))
            _staticKeys = new StaticKeys();
        return _staticKeys;
    };
    return StaticKeys;
})();
exports.StaticKeys = StaticKeys;
var TreeNode = (function () {
    function TreeNode(parent) {
        if (lang_1.isPresent(parent)) {
            parent.addChild(this);
        }
        else {
            this._parent = null;
        }
    }
    TreeNode.prototype.addChild = function (child) { child._parent = this; };
    TreeNode.prototype.remove = function () { this._parent = null; };
    Object.defineProperty(TreeNode.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    return TreeNode;
})();
exports.TreeNode = TreeNode;
var DirectiveDependency = (function (_super) {
    __extends(DirectiveDependency, _super);
    function DirectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties, attributeName, queryDecorator) {
        _super.call(this, key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
        this.attributeName = attributeName;
        this.queryDecorator = queryDecorator;
        this._verify();
    }
    /** @internal */
    DirectiveDependency.prototype._verify = function () {
        var count = 0;
        if (lang_1.isPresent(this.queryDecorator))
            count++;
        if (lang_1.isPresent(this.attributeName))
            count++;
        if (count > 1)
            throw new exceptions_1.BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
    };
    DirectiveDependency.createFrom = function (d) {
        return new DirectiveDependency(d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
    };
    DirectiveDependency._attributeName = function (properties) {
        var p = collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.AttributeMetadata; });
        return lang_1.isPresent(p) ? p.attributeName : null;
    };
    DirectiveDependency._query = function (properties) {
        return collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.QueryMetadata; });
    };
    return DirectiveDependency;
})(di_1.Dependency);
exports.DirectiveDependency = DirectiveDependency;
var DirectiveProvider = (function (_super) {
    __extends(DirectiveProvider, _super);
    function DirectiveProvider(key, factory, deps, metadata, providers, viewProviders) {
        _super.call(this, key, [new provider_1.ResolvedFactory(factory, deps)], false);
        this.metadata = metadata;
        this.providers = providers;
        this.viewProviders = viewProviders;
        this.callOnDestroy = directive_lifecycle_reflector_1.hasLifecycleHook(interfaces_1.LifecycleHooks.OnDestroy, key.token);
    }
    Object.defineProperty(DirectiveProvider.prototype, "displayName", {
        get: function () { return this.key.displayName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveProvider.prototype, "queries", {
        get: function () {
            if (lang_1.isBlank(this.metadata.queries))
                return [];
            var res = [];
            collection_1.StringMapWrapper.forEach(this.metadata.queries, function (meta, fieldName) {
                var setter = reflection_1.reflector.setter(fieldName);
                res.push(new QueryMetadataWithSetter(setter, meta));
            });
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveProvider.prototype, "eventEmitters", {
        get: function () {
            return lang_1.isPresent(this.metadata) && lang_1.isPresent(this.metadata.outputs) ? this.metadata.outputs :
                [];
        },
        enumerable: true,
        configurable: true
    });
    DirectiveProvider.createFromProvider = function (provider, meta) {
        if (lang_1.isBlank(meta)) {
            meta = new directives_1.DirectiveMetadata();
        }
        var rb = provider_1.resolveProvider(provider);
        var rf = rb.resolvedFactories[0];
        var deps = rf.dependencies.map(DirectiveDependency.createFrom);
        var providers = lang_1.isPresent(meta.providers) ? meta.providers : [];
        var viewBindigs = meta instanceof directives_1.ComponentMetadata && lang_1.isPresent(meta.viewProviders) ?
            meta.viewProviders :
            [];
        return new DirectiveProvider(rb.key, rf.factory, deps, meta, providers, viewBindigs);
    };
    DirectiveProvider.createFromType = function (type, annotation) {
        var provider = new di_1.Provider(type, { useClass: type });
        return DirectiveProvider.createFromProvider(provider, annotation);
    };
    return DirectiveProvider;
})(provider_1.ResolvedProvider_);
exports.DirectiveProvider = DirectiveProvider;
// TODO(rado): benchmark and consider rolling in as ElementInjector fields.
var PreBuiltObjects = (function () {
    function PreBuiltObjects(viewManager, view, elementRef, templateRef) {
        this.viewManager = viewManager;
        this.view = view;
        this.elementRef = elementRef;
        this.templateRef = templateRef;
        this.nestedView = null;
    }
    return PreBuiltObjects;
})();
exports.PreBuiltObjects = PreBuiltObjects;
var QueryMetadataWithSetter = (function () {
    function QueryMetadataWithSetter(setter, metadata) {
        this.setter = setter;
        this.metadata = metadata;
    }
    return QueryMetadataWithSetter;
})();
exports.QueryMetadataWithSetter = QueryMetadataWithSetter;
var EventEmitterAccessor = (function () {
    function EventEmitterAccessor(eventName, getter) {
        this.eventName = eventName;
        this.getter = getter;
    }
    EventEmitterAccessor.prototype.subscribe = function (view, boundElementIndex, directive) {
        var _this = this;
        var eventEmitter = this.getter(directive);
        return async_1.ObservableWrapper.subscribe(eventEmitter, function (eventObj) { return view.triggerEventHandlers(_this.eventName, eventObj, boundElementIndex); });
    };
    return EventEmitterAccessor;
})();
exports.EventEmitterAccessor = EventEmitterAccessor;
function _createEventEmitterAccessors(bwv) {
    var provider = bwv.provider;
    if (!(provider instanceof DirectiveProvider))
        return [];
    var db = provider;
    return db.eventEmitters.map(function (eventConfig) {
        var parsedEvent = event_config_1.EventConfig.parse(eventConfig);
        return new EventEmitterAccessor(parsedEvent.eventName, reflection_1.reflector.getter(parsedEvent.fieldName));
    });
}
function _createProtoQueryRefs(providers) {
    var res = [];
    collection_1.ListWrapper.forEachWithIndex(providers, function (b, i) {
        if (b.provider instanceof DirectiveProvider) {
            var directiveProvider = b.provider;
            // field queries
            var queries = directiveProvider.queries;
            queries.forEach(function (q) { return res.push(new ProtoQueryRef(i, q.setter, q.metadata)); });
            // queries passed into the constructor.
            // TODO: remove this after constructor queries are no longer supported
            var deps = directiveProvider.resolvedFactory.dependencies;
            deps.forEach(function (d) {
                if (lang_1.isPresent(d.queryDecorator))
                    res.push(new ProtoQueryRef(i, null, d.queryDecorator));
            });
        }
    });
    return res;
}
var ProtoElementInjector = (function () {
    function ProtoElementInjector(parent, index, bwv, distanceToParent, _firstProviderIsComponent, directiveVariableBindings) {
        this.parent = parent;
        this.index = index;
        this.distanceToParent = distanceToParent;
        this.directiveVariableBindings = directiveVariableBindings;
        this._firstProviderIsComponent = _firstProviderIsComponent;
        var length = bwv.length;
        this.protoInjector = new injector_1.ProtoInjector(bwv);
        this.eventEmitterAccessors = collection_1.ListWrapper.createFixedSize(length);
        for (var i = 0; i < length; ++i) {
            this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
        }
        this.protoQueryRefs = _createProtoQueryRefs(bwv);
    }
    ProtoElementInjector.create = function (parent, index, providers, firstProviderIsComponent, distanceToParent, directiveVariableBindings) {
        var bd = [];
        ProtoElementInjector._createDirectiveProviderWithVisibility(providers, bd, firstProviderIsComponent);
        if (firstProviderIsComponent) {
            ProtoElementInjector._createViewProvidersWithVisibility(providers, bd);
        }
        ProtoElementInjector._createProvidersWithVisibility(providers, bd);
        return new ProtoElementInjector(parent, index, bd, distanceToParent, firstProviderIsComponent, directiveVariableBindings);
    };
    ProtoElementInjector._createDirectiveProviderWithVisibility = function (dirProviders, bd, firstProviderIsComponent) {
        dirProviders.forEach(function (dirProvider) {
            bd.push(ProtoElementInjector._createProviderWithVisibility(firstProviderIsComponent, dirProvider, dirProviders, dirProvider));
        });
    };
    ProtoElementInjector._createProvidersWithVisibility = function (dirProviders, bd) {
        var providersFromAllDirectives = [];
        dirProviders.forEach(function (dirProvider) {
            providersFromAllDirectives =
                collection_1.ListWrapper.concat(providersFromAllDirectives, dirProvider.providers);
        });
        var resolved = di_1.Injector.resolve(providersFromAllDirectives);
        resolved.forEach(function (b) { return bd.push(new injector_1.ProviderWithVisibility(b, injector_1.Visibility.Public)); });
    };
    ProtoElementInjector._createProviderWithVisibility = function (firstProviderIsComponent, dirProvider, dirProviders, provider) {
        var isComponent = firstProviderIsComponent && dirProviders[0] === dirProvider;
        return new injector_1.ProviderWithVisibility(provider, isComponent ? injector_1.Visibility.PublicAndPrivate : injector_1.Visibility.Public);
    };
    ProtoElementInjector._createViewProvidersWithVisibility = function (dirProviders, bd) {
        var resolvedViewProviders = di_1.Injector.resolve(dirProviders[0].viewProviders);
        resolvedViewProviders.forEach(function (b) { return bd.push(new injector_1.ProviderWithVisibility(b, injector_1.Visibility.Private)); });
    };
    ProtoElementInjector.prototype.instantiate = function (parent) {
        return new ElementInjector(this, parent);
    };
    ProtoElementInjector.prototype.directParent = function () { return this.distanceToParent < 2 ? this.parent : null; };
    Object.defineProperty(ProtoElementInjector.prototype, "hasBindings", {
        get: function () { return this.eventEmitterAccessors.length > 0; },
        enumerable: true,
        configurable: true
    });
    ProtoElementInjector.prototype.getProviderAtIndex = function (index) { return this.protoInjector.getProviderAtIndex(index); };
    return ProtoElementInjector;
})();
exports.ProtoElementInjector = ProtoElementInjector;
var _Context = (function () {
    function _Context(element, componentElement, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.injector = injector;
    }
    return _Context;
})();
var ElementInjector = (function (_super) {
    __extends(ElementInjector, _super);
    function ElementInjector(_proto, parent) {
        var _this = this;
        _super.call(this, parent);
        this._preBuiltObjects = null;
        this._proto = _proto;
        this._injector =
            new di_1.Injector(this._proto.protoInjector, null, this, function () { return _this._debugContext(); });
        // we couple ourselves to the injector strategy to avoid polymoprhic calls
        var injectorStrategy = this._injector.internalStrategy;
        this._strategy = injectorStrategy instanceof injector_1.InjectorInlineStrategy ?
            new ElementInjectorInlineStrategy(injectorStrategy, this) :
            new ElementInjectorDynamicStrategy(injectorStrategy, this);
        this.hydrated = false;
        this._queryStrategy = this._buildQueryStrategy();
    }
    ElementInjector.prototype.dehydrate = function () {
        this.hydrated = false;
        this._host = null;
        this._preBuiltObjects = null;
        this._strategy.callOnDestroy();
        this._strategy.dehydrate();
        this._queryStrategy.dehydrate();
    };
    ElementInjector.prototype.hydrate = function (imperativelyCreatedInjector, host, preBuiltObjects) {
        this._host = host;
        this._preBuiltObjects = preBuiltObjects;
        this._reattachInjectors(imperativelyCreatedInjector);
        this._queryStrategy.hydrate();
        this._strategy.hydrate();
        this.hydrated = true;
    };
    ElementInjector.prototype._debugContext = function () {
        var p = this._preBuiltObjects;
        var index = p.elementRef.boundElementIndex - p.view.elementOffset;
        var c = this._preBuiltObjects.view.getDebugContext(index, null);
        return lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
    };
    ElementInjector.prototype._reattachInjectors = function (imperativelyCreatedInjector) {
        // Dynamically-loaded component in the template. Not a root ElementInjector.
        if (lang_1.isPresent(this._parent)) {
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                // The imperative injector is similar to having an element between
                // the dynamic-loaded component and its parent => no boundaries.
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
            }
            else {
                this._reattachInjector(this._injector, this._parent._injector, false);
            }
        }
        else if (lang_1.isPresent(this._host)) {
            // The imperative injector is similar to having an element between
            // the dynamic-loaded component and its parent => no boundary between
            // the component and imperativelyCreatedInjector.
            // But since it is a root ElementInjector, we need to create a boundary
            // between imperativelyCreatedInjector and _host.
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
            }
            else {
                this._reattachInjector(this._injector, this._host._injector, true);
            }
        }
        else {
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
            }
        }
    };
    ElementInjector.prototype._reattachInjector = function (injector, parentInjector, isBoundary) {
        injector.internalStrategy.attach(parentInjector, isBoundary);
    };
    ElementInjector.prototype.hasVariableBinding = function (name) {
        var vb = this._proto.directiveVariableBindings;
        return lang_1.isPresent(vb) && vb.has(name);
    };
    ElementInjector.prototype.getVariableBinding = function (name) {
        var index = this._proto.directiveVariableBindings.get(name);
        return lang_1.isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();
    };
    ElementInjector.prototype.get = function (token) { return this._injector.get(token); };
    ElementInjector.prototype.hasDirective = function (type) { return lang_1.isPresent(this._injector.getOptional(type)); };
    ElementInjector.prototype.getEventEmitterAccessors = function () { return this._proto.eventEmitterAccessors; };
    ElementInjector.prototype.getDirectiveVariableBindings = function () {
        return this._proto.directiveVariableBindings;
    };
    ElementInjector.prototype.getComponent = function () { return this._strategy.getComponent(); };
    ElementInjector.prototype.getInjector = function () { return this._injector; };
    ElementInjector.prototype.getElementRef = function () { return this._preBuiltObjects.elementRef; };
    ElementInjector.prototype.getViewContainerRef = function () {
        return new view_container_ref_2.ViewContainerRef_(this._preBuiltObjects.viewManager, this.getElementRef());
    };
    ElementInjector.prototype.getNestedView = function () { return this._preBuiltObjects.nestedView; };
    ElementInjector.prototype.getView = function () { return this._preBuiltObjects.view; };
    ElementInjector.prototype.directParent = function () { return this._proto.distanceToParent < 2 ? this.parent : null; };
    ElementInjector.prototype.isComponentKey = function (key) { return this._strategy.isComponentKey(key); };
    ElementInjector.prototype.getDependency = function (injector, provider, dep) {
        var key = dep.key;
        if (provider instanceof DirectiveProvider) {
            var dirDep = dep;
            var dirProvider = provider;
            var staticKeys = StaticKeys.instance();
            if (key.id === staticKeys.viewManagerId)
                return this._preBuiltObjects.viewManager;
            if (lang_1.isPresent(dirDep.attributeName))
                return this._buildAttribute(dirDep);
            if (lang_1.isPresent(dirDep.queryDecorator))
                return this._queryStrategy.findQuery(dirDep.queryDecorator).list;
            if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
                // We provide the component's view change detector to components and
                // the surrounding component's change detector to directives.
                if (dirProvider.metadata instanceof directives_1.ComponentMetadata) {
                    var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                    return componentView.changeDetector.ref;
                }
                else {
                    return this._preBuiltObjects.view.changeDetector.ref;
                }
            }
            if (dirDep.key.id === StaticKeys.instance().elementRefId) {
                return this.getElementRef();
            }
            if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
                return this.getViewContainerRef();
            }
            if (dirDep.key.id === StaticKeys.instance().templateRefId) {
                if (lang_1.isBlank(this._preBuiltObjects.templateRef)) {
                    if (dirDep.optional) {
                        return null;
                    }
                    throw new di_1.NoProviderError(null, dirDep.key);
                }
                return this._preBuiltObjects.templateRef;
            }
        }
        else if (provider instanceof pipe_provider_1.PipeProvider) {
            if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
                var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                return componentView.changeDetector.ref;
            }
        }
        return injector_1.UNDEFINED;
    };
    ElementInjector.prototype._buildAttribute = function (dep) {
        var attributes = this._proto.attributes;
        if (lang_1.isPresent(attributes) && attributes.has(dep.attributeName)) {
            return attributes.get(dep.attributeName);
        }
        else {
            return null;
        }
    };
    ElementInjector.prototype.addDirectivesMatchingQuery = function (query, list) {
        var templateRef = lang_1.isBlank(this._preBuiltObjects) ? null : this._preBuiltObjects.templateRef;
        if (query.selector === template_ref_1.TemplateRef && lang_1.isPresent(templateRef)) {
            list.push(templateRef);
        }
        this._strategy.addDirectivesMatchingQuery(query, list);
    };
    ElementInjector.prototype._buildQueryStrategy = function () {
        if (this._proto.protoQueryRefs.length === 0) {
            return _emptyQueryStrategy;
        }
        else if (this._proto.protoQueryRefs.length <=
            InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES) {
            return new InlineQueryStrategy(this);
        }
        else {
            return new DynamicQueryStrategy(this);
        }
    };
    ElementInjector.prototype.link = function (parent) { parent.addChild(this); };
    ElementInjector.prototype.unlink = function () { this.remove(); };
    ElementInjector.prototype.getDirectiveAtIndex = function (index) { return this._injector.getAt(index); };
    ElementInjector.prototype.hasInstances = function () { return this._proto.hasBindings && this.hydrated; };
    ElementInjector.prototype.getHost = function () { return this._host; };
    ElementInjector.prototype.getBoundElementIndex = function () { return this._proto.index; };
    ElementInjector.prototype.getRootViewInjectors = function () {
        if (!this.hydrated)
            return [];
        var view = this._preBuiltObjects.view;
        var nestedView = view.getNestedView(view.elementOffset + this.getBoundElementIndex());
        return lang_1.isPresent(nestedView) ? nestedView.rootElementInjectors : [];
    };
    ElementInjector.prototype.afterViewChecked = function () { this._queryStrategy.updateViewQueries(); };
    ElementInjector.prototype.afterContentChecked = function () { this._queryStrategy.updateContentQueries(); };
    ElementInjector.prototype.traverseAndSetQueriesAsDirty = function () {
        var inj = this;
        while (lang_1.isPresent(inj)) {
            inj._setQueriesAsDirty();
            inj = inj.parent;
        }
    };
    ElementInjector.prototype._setQueriesAsDirty = function () {
        this._queryStrategy.setContentQueriesAsDirty();
        if (lang_1.isPresent(this._host))
            this._host._queryStrategy.setViewQueriesAsDirty();
    };
    return ElementInjector;
})(TreeNode);
exports.ElementInjector = ElementInjector;
var _EmptyQueryStrategy = (function () {
    function _EmptyQueryStrategy() {
    }
    _EmptyQueryStrategy.prototype.setContentQueriesAsDirty = function () { };
    _EmptyQueryStrategy.prototype.setViewQueriesAsDirty = function () { };
    _EmptyQueryStrategy.prototype.hydrate = function () { };
    _EmptyQueryStrategy.prototype.dehydrate = function () { };
    _EmptyQueryStrategy.prototype.updateContentQueries = function () { };
    _EmptyQueryStrategy.prototype.updateViewQueries = function () { };
    _EmptyQueryStrategy.prototype.findQuery = function (query) {
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    return _EmptyQueryStrategy;
})();
var _emptyQueryStrategy = new _EmptyQueryStrategy();
var InlineQueryStrategy = (function () {
    function InlineQueryStrategy(ei) {
        var protoRefs = ei._proto.protoQueryRefs;
        if (protoRefs.length > 0)
            this.query0 = new QueryRef(protoRefs[0], ei);
        if (protoRefs.length > 1)
            this.query1 = new QueryRef(protoRefs[1], ei);
        if (protoRefs.length > 2)
            this.query2 = new QueryRef(protoRefs[2], ei);
    }
    InlineQueryStrategy.prototype.setContentQueriesAsDirty = function () {
        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery)
            this.query0.dirty = true;
        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery)
            this.query1.dirty = true;
        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery)
            this.query2.dirty = true;
    };
    InlineQueryStrategy.prototype.setViewQueriesAsDirty = function () {
        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery)
            this.query0.dirty = true;
        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery)
            this.query1.dirty = true;
        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery)
            this.query2.dirty = true;
    };
    InlineQueryStrategy.prototype.hydrate = function () {
        if (lang_1.isPresent(this.query0))
            this.query0.hydrate();
        if (lang_1.isPresent(this.query1))
            this.query1.hydrate();
        if (lang_1.isPresent(this.query2))
            this.query2.hydrate();
    };
    InlineQueryStrategy.prototype.dehydrate = function () {
        if (lang_1.isPresent(this.query0))
            this.query0.dehydrate();
        if (lang_1.isPresent(this.query1))
            this.query1.dehydrate();
        if (lang_1.isPresent(this.query2))
            this.query2.dehydrate();
    };
    InlineQueryStrategy.prototype.updateContentQueries = function () {
        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery) {
            this.query0.update();
        }
        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery) {
            this.query1.update();
        }
        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery) {
            this.query2.update();
        }
    };
    InlineQueryStrategy.prototype.updateViewQueries = function () {
        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery) {
            this.query0.update();
        }
        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery) {
            this.query1.update();
        }
        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery) {
            this.query2.update();
        }
    };
    InlineQueryStrategy.prototype.findQuery = function (query) {
        if (lang_1.isPresent(this.query0) && this.query0.protoQueryRef.query === query) {
            return this.query0;
        }
        if (lang_1.isPresent(this.query1) && this.query1.protoQueryRef.query === query) {
            return this.query1;
        }
        if (lang_1.isPresent(this.query2) && this.query2.protoQueryRef.query === query) {
            return this.query2;
        }
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES = 3;
    return InlineQueryStrategy;
})();
var DynamicQueryStrategy = (function () {
    function DynamicQueryStrategy(ei) {
        this.queries = ei._proto.protoQueryRefs.map(function (p) { return new QueryRef(p, ei); });
    }
    DynamicQueryStrategy.prototype.setContentQueriesAsDirty = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (!q.isViewQuery)
                q.dirty = true;
        }
    };
    DynamicQueryStrategy.prototype.setViewQueriesAsDirty = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.isViewQuery)
                q.dirty = true;
        }
    };
    DynamicQueryStrategy.prototype.hydrate = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            q.hydrate();
        }
    };
    DynamicQueryStrategy.prototype.dehydrate = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            q.dehydrate();
        }
    };
    DynamicQueryStrategy.prototype.updateContentQueries = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (!q.isViewQuery) {
                q.update();
            }
        }
    };
    DynamicQueryStrategy.prototype.updateViewQueries = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.isViewQuery) {
                q.update();
            }
        }
    };
    DynamicQueryStrategy.prototype.findQuery = function (query) {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.protoQueryRef.query === query) {
                return q;
            }
        }
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    return DynamicQueryStrategy;
})();
/**
 * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
 * In such a case, inlining fields is beneficial for performances.
 */
var ElementInjectorInlineStrategy = (function () {
    function ElementInjectorInlineStrategy(injectorStrategy, _ei) {
        this.injectorStrategy = injectorStrategy;
        this._ei = _ei;
    }
    ElementInjectorInlineStrategy.prototype.hydrate = function () {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        i.resetConstructionCounter();
        if (p.provider0 instanceof DirectiveProvider && lang_1.isPresent(p.keyId0) && i.obj0 === injector_1.UNDEFINED)
            i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
        if (p.provider1 instanceof DirectiveProvider && lang_1.isPresent(p.keyId1) && i.obj1 === injector_1.UNDEFINED)
            i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
        if (p.provider2 instanceof DirectiveProvider && lang_1.isPresent(p.keyId2) && i.obj2 === injector_1.UNDEFINED)
            i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
        if (p.provider3 instanceof DirectiveProvider && lang_1.isPresent(p.keyId3) && i.obj3 === injector_1.UNDEFINED)
            i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
        if (p.provider4 instanceof DirectiveProvider && lang_1.isPresent(p.keyId4) && i.obj4 === injector_1.UNDEFINED)
            i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
        if (p.provider5 instanceof DirectiveProvider && lang_1.isPresent(p.keyId5) && i.obj5 === injector_1.UNDEFINED)
            i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
        if (p.provider6 instanceof DirectiveProvider && lang_1.isPresent(p.keyId6) && i.obj6 === injector_1.UNDEFINED)
            i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
        if (p.provider7 instanceof DirectiveProvider && lang_1.isPresent(p.keyId7) && i.obj7 === injector_1.UNDEFINED)
            i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
        if (p.provider8 instanceof DirectiveProvider && lang_1.isPresent(p.keyId8) && i.obj8 === injector_1.UNDEFINED)
            i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
        if (p.provider9 instanceof DirectiveProvider && lang_1.isPresent(p.keyId9) && i.obj9 === injector_1.UNDEFINED)
            i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
    };
    ElementInjectorInlineStrategy.prototype.dehydrate = function () {
        var i = this.injectorStrategy;
        i.obj0 = injector_1.UNDEFINED;
        i.obj1 = injector_1.UNDEFINED;
        i.obj2 = injector_1.UNDEFINED;
        i.obj3 = injector_1.UNDEFINED;
        i.obj4 = injector_1.UNDEFINED;
        i.obj5 = injector_1.UNDEFINED;
        i.obj6 = injector_1.UNDEFINED;
        i.obj7 = injector_1.UNDEFINED;
        i.obj8 = injector_1.UNDEFINED;
        i.obj9 = injector_1.UNDEFINED;
    };
    ElementInjectorInlineStrategy.prototype.callOnDestroy = function () {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        if (p.provider0 instanceof DirectiveProvider &&
            p.provider0.callOnDestroy) {
            i.obj0.onDestroy();
        }
        if (p.provider1 instanceof DirectiveProvider &&
            p.provider1.callOnDestroy) {
            i.obj1.onDestroy();
        }
        if (p.provider2 instanceof DirectiveProvider &&
            p.provider2.callOnDestroy) {
            i.obj2.onDestroy();
        }
        if (p.provider3 instanceof DirectiveProvider &&
            p.provider3.callOnDestroy) {
            i.obj3.onDestroy();
        }
        if (p.provider4 instanceof DirectiveProvider &&
            p.provider4.callOnDestroy) {
            i.obj4.onDestroy();
        }
        if (p.provider5 instanceof DirectiveProvider &&
            p.provider5.callOnDestroy) {
            i.obj5.onDestroy();
        }
        if (p.provider6 instanceof DirectiveProvider &&
            p.provider6.callOnDestroy) {
            i.obj6.onDestroy();
        }
        if (p.provider7 instanceof DirectiveProvider &&
            p.provider7.callOnDestroy) {
            i.obj7.onDestroy();
        }
        if (p.provider8 instanceof DirectiveProvider &&
            p.provider8.callOnDestroy) {
            i.obj8.onDestroy();
        }
        if (p.provider9 instanceof DirectiveProvider &&
            p.provider9.callOnDestroy) {
            i.obj9.onDestroy();
        }
    };
    ElementInjectorInlineStrategy.prototype.getComponent = function () { return this.injectorStrategy.obj0; };
    ElementInjectorInlineStrategy.prototype.isComponentKey = function (key) {
        return this._ei._proto._firstProviderIsComponent && lang_1.isPresent(key) &&
            key.id === this.injectorStrategy.protoStrategy.keyId0;
    };
    ElementInjectorInlineStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        if (lang_1.isPresent(p.provider0) && p.provider0.key.token === query.selector) {
            if (i.obj0 === injector_1.UNDEFINED)
                i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
            list.push(i.obj0);
        }
        if (lang_1.isPresent(p.provider1) && p.provider1.key.token === query.selector) {
            if (i.obj1 === injector_1.UNDEFINED)
                i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
            list.push(i.obj1);
        }
        if (lang_1.isPresent(p.provider2) && p.provider2.key.token === query.selector) {
            if (i.obj2 === injector_1.UNDEFINED)
                i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
            list.push(i.obj2);
        }
        if (lang_1.isPresent(p.provider3) && p.provider3.key.token === query.selector) {
            if (i.obj3 === injector_1.UNDEFINED)
                i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
            list.push(i.obj3);
        }
        if (lang_1.isPresent(p.provider4) && p.provider4.key.token === query.selector) {
            if (i.obj4 === injector_1.UNDEFINED)
                i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
            list.push(i.obj4);
        }
        if (lang_1.isPresent(p.provider5) && p.provider5.key.token === query.selector) {
            if (i.obj5 === injector_1.UNDEFINED)
                i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
            list.push(i.obj5);
        }
        if (lang_1.isPresent(p.provider6) && p.provider6.key.token === query.selector) {
            if (i.obj6 === injector_1.UNDEFINED)
                i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
            list.push(i.obj6);
        }
        if (lang_1.isPresent(p.provider7) && p.provider7.key.token === query.selector) {
            if (i.obj7 === injector_1.UNDEFINED)
                i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
            list.push(i.obj7);
        }
        if (lang_1.isPresent(p.provider8) && p.provider8.key.token === query.selector) {
            if (i.obj8 === injector_1.UNDEFINED)
                i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
            list.push(i.obj8);
        }
        if (lang_1.isPresent(p.provider9) && p.provider9.key.token === query.selector) {
            if (i.obj9 === injector_1.UNDEFINED)
                i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
            list.push(i.obj9);
        }
    };
    return ElementInjectorInlineStrategy;
})();
/**
 * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
 * In such a case, inlining fields is beneficial for performances.
 */
var ElementInjectorDynamicStrategy = (function () {
    function ElementInjectorDynamicStrategy(injectorStrategy, _ei) {
        this.injectorStrategy = injectorStrategy;
        this._ei = _ei;
    }
    ElementInjectorDynamicStrategy.prototype.hydrate = function () {
        var inj = this.injectorStrategy;
        var p = inj.protoStrategy;
        inj.resetConstructionCounter();
        for (var i = 0; i < p.keyIds.length; i++) {
            if (p.providers[i] instanceof DirectiveProvider && lang_1.isPresent(p.keyIds[i]) &&
                inj.objs[i] === injector_1.UNDEFINED) {
                inj.objs[i] = inj.instantiateProvider(p.providers[i], p.visibilities[i]);
            }
        }
    };
    ElementInjectorDynamicStrategy.prototype.dehydrate = function () {
        var inj = this.injectorStrategy;
        collection_1.ListWrapper.fill(inj.objs, injector_1.UNDEFINED);
    };
    ElementInjectorDynamicStrategy.prototype.callOnDestroy = function () {
        var ist = this.injectorStrategy;
        var p = ist.protoStrategy;
        for (var i = 0; i < p.providers.length; i++) {
            if (p.providers[i] instanceof DirectiveProvider &&
                p.providers[i].callOnDestroy) {
                ist.objs[i].onDestroy();
            }
        }
    };
    ElementInjectorDynamicStrategy.prototype.getComponent = function () { return this.injectorStrategy.objs[0]; };
    ElementInjectorDynamicStrategy.prototype.isComponentKey = function (key) {
        var p = this.injectorStrategy.protoStrategy;
        return this._ei._proto._firstProviderIsComponent && lang_1.isPresent(key) && key.id === p.keyIds[0];
    };
    ElementInjectorDynamicStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
        var ist = this.injectorStrategy;
        var p = ist.protoStrategy;
        for (var i = 0; i < p.providers.length; i++) {
            if (p.providers[i].key.token === query.selector) {
                if (ist.objs[i] === injector_1.UNDEFINED) {
                    ist.objs[i] = ist.instantiateProvider(p.providers[i], p.visibilities[i]);
                }
                list.push(ist.objs[i]);
            }
        }
    };
    return ElementInjectorDynamicStrategy;
})();
var ProtoQueryRef = (function () {
    function ProtoQueryRef(dirIndex, setter, query) {
        this.dirIndex = dirIndex;
        this.setter = setter;
        this.query = query;
    }
    Object.defineProperty(ProtoQueryRef.prototype, "usesPropertySyntax", {
        get: function () { return lang_1.isPresent(this.setter); },
        enumerable: true,
        configurable: true
    });
    return ProtoQueryRef;
})();
exports.ProtoQueryRef = ProtoQueryRef;
var QueryRef = (function () {
    function QueryRef(protoQueryRef, originator) {
        this.protoQueryRef = protoQueryRef;
        this.originator = originator;
    }
    Object.defineProperty(QueryRef.prototype, "isViewQuery", {
        get: function () { return this.protoQueryRef.query.isViewQuery; },
        enumerable: true,
        configurable: true
    });
    QueryRef.prototype.update = function () {
        if (!this.dirty)
            return;
        this._update();
        this.dirty = false;
        // TODO delete the check once only field queries are supported
        if (this.protoQueryRef.usesPropertySyntax) {
            var dir = this.originator.getDirectiveAtIndex(this.protoQueryRef.dirIndex);
            if (this.protoQueryRef.query.first) {
                this.protoQueryRef.setter(dir, this.list.length > 0 ? this.list.first : null);
            }
            else {
                this.protoQueryRef.setter(dir, this.list);
            }
        }
        this.list.notifyOnChanges();
    };
    QueryRef.prototype._update = function () {
        var aggregator = [];
        if (this.protoQueryRef.query.isViewQuery) {
            var view = this.originator.getView();
            // intentionally skipping originator for view queries.
            var nestedView = view.getNestedView(view.elementOffset + this.originator.getBoundElementIndex());
            if (lang_1.isPresent(nestedView))
                this._visitView(nestedView, aggregator);
        }
        else {
            this._visit(this.originator, aggregator);
        }
        this.list.reset(aggregator);
    };
    ;
    QueryRef.prototype._visit = function (inj, aggregator) {
        var view = inj.getView();
        var startIdx = view.elementOffset + inj._proto.index;
        for (var i = startIdx; i < view.elementOffset + view.ownBindersCount; i++) {
            var curInj = view.elementInjectors[i];
            if (lang_1.isBlank(curInj))
                continue;
            // The first injector after inj, that is outside the subtree rooted at
            // inj has to have a null parent or a parent that is an ancestor of inj.
            if (i > startIdx && (lang_1.isBlank(curInj) || lang_1.isBlank(curInj.parent) ||
                view.elementOffset + curInj.parent._proto.index < startIdx)) {
                break;
            }
            if (!this.protoQueryRef.query.descendants &&
                !(curInj.parent == this.originator || curInj == this.originator))
                continue;
            // We visit the view container(VC) views right after the injector that contains
            // the VC. Theoretically, that might not be the right order if there are
            // child injectors of said injector. Not clear whether if such case can
            // even be constructed with the current apis.
            this._visitInjector(curInj, aggregator);
            var vc = view.viewContainers[i];
            if (lang_1.isPresent(vc))
                this._visitViewContainer(vc, aggregator);
        }
    };
    QueryRef.prototype._visitInjector = function (inj, aggregator) {
        if (this.protoQueryRef.query.isVarBindingQuery) {
            this._aggregateVariableBinding(inj, aggregator);
        }
        else {
            this._aggregateDirective(inj, aggregator);
        }
    };
    QueryRef.prototype._visitViewContainer = function (vc, aggregator) {
        for (var j = 0; j < vc.views.length; j++) {
            this._visitView(vc.views[j], aggregator);
        }
    };
    QueryRef.prototype._visitView = function (view, aggregator) {
        for (var i = view.elementOffset; i < view.elementOffset + view.ownBindersCount; i++) {
            var inj = view.elementInjectors[i];
            if (lang_1.isBlank(inj))
                continue;
            this._visitInjector(inj, aggregator);
            var vc = view.viewContainers[i];
            if (lang_1.isPresent(vc))
                this._visitViewContainer(vc, aggregator);
        }
    };
    QueryRef.prototype._aggregateVariableBinding = function (inj, aggregator) {
        var vb = this.protoQueryRef.query.varBindings;
        for (var i = 0; i < vb.length; ++i) {
            if (inj.hasVariableBinding(vb[i])) {
                aggregator.push(inj.getVariableBinding(vb[i]));
            }
        }
    };
    QueryRef.prototype._aggregateDirective = function (inj, aggregator) {
        inj.addDirectivesMatchingQuery(this.protoQueryRef.query, aggregator);
    };
    QueryRef.prototype.dehydrate = function () { this.list = null; };
    QueryRef.prototype.hydrate = function () {
        this.list = new query_list_1.QueryList();
        this.dirty = true;
    };
    return QueryRef;
})();
exports.QueryRef = QueryRef;

},{"../metadata/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js","../metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","./directive_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js","./element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","./query_list":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js","./template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./view_container_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js","./view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js","angular2/src/core/di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/event_config":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/event_config.js","angular2/src/core/pipes/pipe_provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Represents a location in a View that has an injection, change-detection and render context
 * associated with it.
 *
 * An `ElementRef` is created for each element in the Template that contains a Directive, Component
 * or data-binding.
 *
 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
 * element.
 */
var ElementRef = (function () {
    function ElementRef() {
    }
    Object.defineProperty(ElementRef.prototype, "nativeElement", {
        /**
         * The underlying native element or `null` if direct access to native elements is not supported
         * (e.g. when the application runs in a web worker).
         *
         * <div class="callout is-critical">
         *   <header>Use with caution</header>
         *   <p>
         *    Use this API as the last resort when direct access to DOM is needed. Use templating and
         *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}
         *    which provides API that can safely be used even when direct access to native elements is not
         *    supported.
         *   </p>
         *   <p>
         *    Relying on direct DOM access creates tight coupling between your application and rendering
         *    layers which will make it impossible to separate the two and deploy your application into a
         *    web worker.
         *   </p>
         * </div>
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ElementRef.prototype, "renderView", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return ElementRef;
})();
exports.ElementRef = ElementRef;
var ElementRef_ = (function (_super) {
    __extends(ElementRef_, _super);
    function ElementRef_(parentView, 
        /**
         * Index of the element inside the {@link ViewRef}.
         *
         * This is used internally by the Angular framework to locate elements.
         */
        boundElementIndex, _renderer) {
        _super.call(this);
        this.parentView = parentView;
        this.boundElementIndex = boundElementIndex;
        this._renderer = _renderer;
    }
    Object.defineProperty(ElementRef_.prototype, "renderView", {
        get: function () { return this.parentView.render; },
        set: function (value) { exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementRef_.prototype, "nativeElement", {
        get: function () { return this._renderer.getNativeElementSync(this); },
        enumerable: true,
        configurable: true
    });
    return ElementRef_;
})(ElementRef);
exports.ElementRef_ = ElementRef_;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/event_config.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.EVENT_TARGET_SEPARATOR = ':';
var EventConfig = (function () {
    function EventConfig(fieldName, eventName, isLongForm) {
        this.fieldName = fieldName;
        this.eventName = eventName;
        this.isLongForm = isLongForm;
    }
    EventConfig.parse = function (eventConfig) {
        var fieldName = eventConfig, eventName = eventConfig, isLongForm = false;
        var separatorIdx = eventConfig.indexOf(exports.EVENT_TARGET_SEPARATOR);
        if (separatorIdx > -1) {
            // long format: 'fieldName: eventName'
            fieldName = lang_1.StringWrapper.substring(eventConfig, 0, separatorIdx).trim();
            eventName = lang_1.StringWrapper.substring(eventConfig, separatorIdx + 1).trim();
            isLongForm = true;
        }
        return new EventConfig(fieldName, eventName, isLongForm);
    };
    EventConfig.prototype.getFullName = function () {
        return this.isLongForm ? "" + this.fieldName + exports.EVENT_TARGET_SEPARATOR + this.eventName :
            this.eventName;
    };
    return EventConfig;
})();
exports.EventConfig = EventConfig;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js":[function(require,module,exports){
'use strict';(function (LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
var LifecycleHooks = exports.LifecycleHooks;
/**
 * @internal
 */
exports.LIFECYCLE_HOOKS_VALUES = [
    LifecycleHooks.OnInit,
    LifecycleHooks.OnDestroy,
    LifecycleHooks.DoCheck,
    LifecycleHooks.OnChanges,
    LifecycleHooks.AfterContentInit,
    LifecycleHooks.AfterContentChecked,
    LifecycleHooks.AfterViewInit,
    LifecycleHooks.AfterViewChecked
];

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var metadata_1 = require('angular2/src/core/metadata');
var reflection_1 = require('angular2/src/core/reflection/reflection');
/**
 * Resolve a `Type` for {@link PipeMetadata}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var PipeResolver = (function () {
    function PipeResolver() {
    }
    /**
     * Return {@link PipeMetadata} for a given `Type`.
     */
    PipeResolver.prototype.resolve = function (type) {
        var metas = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
        if (lang_1.isPresent(metas)) {
            for (var i = 0; i < metas.length; i++) {
                var annotation = metas[i];
                if (annotation instanceof metadata_1.PipeMetadata) {
                    return annotation;
                }
            }
        }
        throw new exceptions_1.BaseException("No Pipe decorator found on " + lang_1.stringify(type));
    };
    PipeResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PipeResolver);
    return PipeResolver;
})();
exports.PipeResolver = PipeResolver;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var pipe_provider_1 = require('../pipes/pipe_provider');
var pipes_1 = require('../pipes/pipes');
var view_1 = require('./view');
var element_binder_1 = require('./element_binder');
var element_injector_1 = require('./element_injector');
var directive_resolver_1 = require('./directive_resolver');
var view_resolver_1 = require('./view_resolver');
var pipe_resolver_1 = require('./pipe_resolver');
var pipes_2 = require('angular2/src/core/pipes');
var template_commands_1 = require('./template_commands');
var render_1 = require('angular2/render');
var application_tokens_1 = require('angular2/src/core/application_tokens');
var ProtoViewFactory = (function () {
    function ProtoViewFactory(_renderer, defaultPipes, _directiveResolver, _viewResolver, _pipeResolver, appId) {
        this._renderer = _renderer;
        this._directiveResolver = _directiveResolver;
        this._viewResolver = _viewResolver;
        this._pipeResolver = _pipeResolver;
        this._cache = new Map();
        this._defaultPipes = defaultPipes;
        this._appId = appId;
    }
    ProtoViewFactory.prototype.clearCache = function () { this._cache.clear(); };
    ProtoViewFactory.prototype.createHost = function (compiledHostTemplate) {
        var compiledTemplate = compiledHostTemplate.getTemplate();
        var result = this._cache.get(compiledTemplate.id);
        if (lang_1.isBlank(result)) {
            var templateData = compiledTemplate.getData(this._appId);
            var emptyMap = {};
            result = new view_1.AppProtoView(templateData.commands, view_1.ViewType.HOST, true, templateData.changeDetectorFactory, null, new pipes_1.ProtoPipes(emptyMap));
            this._cache.set(compiledTemplate.id, result);
        }
        return result;
    };
    ProtoViewFactory.prototype._createComponent = function (cmd) {
        var _this = this;
        var nestedProtoView = this._cache.get(cmd.templateId);
        if (lang_1.isBlank(nestedProtoView)) {
            var component = cmd.directives[0];
            var view = this._viewResolver.resolve(component);
            var compiledTemplateData = cmd.template.getData(this._appId);
            this._renderer.registerComponentTemplate(cmd.templateId, compiledTemplateData.commands, compiledTemplateData.styles, cmd.nativeShadow);
            var boundPipes = this._flattenPipes(view).map(function (pipe) { return _this._bindPipe(pipe); });
            nestedProtoView = new view_1.AppProtoView(compiledTemplateData.commands, view_1.ViewType.COMPONENT, true, compiledTemplateData.changeDetectorFactory, null, pipes_1.ProtoPipes.fromProviders(boundPipes));
            // Note: The cache is updated before recursing
            // to be able to resolve cycles
            this._cache.set(cmd.template.id, nestedProtoView);
            this._initializeProtoView(nestedProtoView, null);
        }
        return nestedProtoView;
    };
    ProtoViewFactory.prototype._createEmbeddedTemplate = function (cmd, parent) {
        var nestedProtoView = new view_1.AppProtoView(cmd.children, view_1.ViewType.EMBEDDED, cmd.isMerged, cmd.changeDetectorFactory, arrayToMap(cmd.variableNameAndValues, true), new pipes_1.ProtoPipes(parent.pipes.config));
        if (cmd.isMerged) {
            this.initializeProtoViewIfNeeded(nestedProtoView);
        }
        return nestedProtoView;
    };
    ProtoViewFactory.prototype.initializeProtoViewIfNeeded = function (protoView) {
        if (!protoView.isInitialized()) {
            var render = this._renderer.createProtoView(protoView.templateCmds);
            this._initializeProtoView(protoView, render);
        }
    };
    ProtoViewFactory.prototype._initializeProtoView = function (protoView, render) {
        var initializer = new _ProtoViewInitializer(protoView, this._directiveResolver, this);
        template_commands_1.visitAllCommands(initializer, protoView.templateCmds);
        var mergeInfo = new view_1.AppProtoViewMergeInfo(initializer.mergeEmbeddedViewCount, initializer.mergeElementCount, initializer.mergeViewCount);
        protoView.init(render, initializer.elementBinders, initializer.boundTextCount, mergeInfo, initializer.variableLocations);
    };
    ProtoViewFactory.prototype._bindPipe = function (typeOrProvider) {
        var meta = this._pipeResolver.resolve(typeOrProvider);
        return pipe_provider_1.PipeProvider.createFromType(typeOrProvider, meta);
    };
    ProtoViewFactory.prototype._flattenPipes = function (view) {
        if (lang_1.isBlank(view.pipes))
            return this._defaultPipes;
        var pipes = collection_1.ListWrapper.clone(this._defaultPipes);
        _flattenList(view.pipes, pipes);
        return pipes;
    };
    ProtoViewFactory = __decorate([
        di_1.Injectable(),
        __param(1, di_1.Inject(pipes_2.DEFAULT_PIPES_TOKEN)),
        __param(5, di_1.Inject(application_tokens_1.APP_ID)), 
        __metadata('design:paramtypes', [render_1.Renderer, Array, directive_resolver_1.DirectiveResolver, view_resolver_1.ViewResolver, pipe_resolver_1.PipeResolver, String])
    ], ProtoViewFactory);
    return ProtoViewFactory;
})();
exports.ProtoViewFactory = ProtoViewFactory;
function createComponent(protoViewFactory, cmd) {
    return protoViewFactory._createComponent(cmd);
}
function createEmbeddedTemplate(protoViewFactory, cmd, parent) {
    return protoViewFactory._createEmbeddedTemplate(cmd, parent);
}
var _ProtoViewInitializer = (function () {
    function _ProtoViewInitializer(_protoView, _directiveResolver, _protoViewFactory) {
        this._protoView = _protoView;
        this._directiveResolver = _directiveResolver;
        this._protoViewFactory = _protoViewFactory;
        this.variableLocations = new Map();
        this.boundTextCount = 0;
        this.boundElementIndex = 0;
        this.elementBinderStack = [];
        this.distanceToParentElementBinder = 0;
        this.distanceToParentProtoElementInjector = 0;
        this.elementBinders = [];
        this.mergeEmbeddedViewCount = 0;
        this.mergeElementCount = 0;
        this.mergeViewCount = 1;
    }
    _ProtoViewInitializer.prototype.visitText = function (cmd, context) {
        if (cmd.isBound) {
            this.boundTextCount++;
        }
        return null;
    };
    _ProtoViewInitializer.prototype.visitNgContent = function (cmd, context) { return null; };
    _ProtoViewInitializer.prototype.visitBeginElement = function (cmd, context) {
        if (cmd.isBound) {
            this._visitBeginBoundElement(cmd, null);
        }
        else {
            this._visitBeginElement(cmd, null, null);
        }
        return null;
    };
    _ProtoViewInitializer.prototype.visitEndElement = function (context) { return this._visitEndElement(); };
    _ProtoViewInitializer.prototype.visitBeginComponent = function (cmd, context) {
        var nestedProtoView = createComponent(this._protoViewFactory, cmd);
        return this._visitBeginBoundElement(cmd, nestedProtoView);
    };
    _ProtoViewInitializer.prototype.visitEndComponent = function (context) { return this._visitEndElement(); };
    _ProtoViewInitializer.prototype.visitEmbeddedTemplate = function (cmd, context) {
        var nestedProtoView = createEmbeddedTemplate(this._protoViewFactory, cmd, this._protoView);
        if (cmd.isMerged) {
            this.mergeEmbeddedViewCount++;
        }
        this._visitBeginBoundElement(cmd, nestedProtoView);
        return this._visitEndElement();
    };
    _ProtoViewInitializer.prototype._visitBeginBoundElement = function (cmd, nestedProtoView) {
        if (lang_1.isPresent(nestedProtoView) && nestedProtoView.isMergable) {
            this.mergeElementCount += nestedProtoView.mergeInfo.elementCount;
            this.mergeViewCount += nestedProtoView.mergeInfo.viewCount;
            this.mergeEmbeddedViewCount += nestedProtoView.mergeInfo.embeddedViewCount;
        }
        var elementBinder = _createElementBinder(this._directiveResolver, nestedProtoView, this.elementBinderStack, this.boundElementIndex, this.distanceToParentElementBinder, this.distanceToParentProtoElementInjector, cmd);
        this.elementBinders.push(elementBinder);
        var protoElementInjector = elementBinder.protoElementInjector;
        for (var i = 0; i < cmd.variableNameAndValues.length; i += 2) {
            this.variableLocations.set(cmd.variableNameAndValues[i], this.boundElementIndex);
        }
        this.boundElementIndex++;
        this.mergeElementCount++;
        return this._visitBeginElement(cmd, elementBinder, protoElementInjector);
    };
    _ProtoViewInitializer.prototype._visitBeginElement = function (cmd, elementBinder, protoElementInjector) {
        this.distanceToParentElementBinder =
            lang_1.isPresent(elementBinder) ? 1 : this.distanceToParentElementBinder + 1;
        this.distanceToParentProtoElementInjector =
            lang_1.isPresent(protoElementInjector) ? 1 : this.distanceToParentProtoElementInjector + 1;
        this.elementBinderStack.push(elementBinder);
        return null;
    };
    _ProtoViewInitializer.prototype._visitEndElement = function () {
        var parentElementBinder = this.elementBinderStack.pop();
        var parentProtoElementInjector = lang_1.isPresent(parentElementBinder) ? parentElementBinder.protoElementInjector : null;
        this.distanceToParentElementBinder = lang_1.isPresent(parentElementBinder) ?
            parentElementBinder.distanceToParent :
            this.distanceToParentElementBinder - 1;
        this.distanceToParentProtoElementInjector = lang_1.isPresent(parentProtoElementInjector) ?
            parentProtoElementInjector.distanceToParent :
            this.distanceToParentProtoElementInjector - 1;
        return null;
    };
    return _ProtoViewInitializer;
})();
function _createElementBinder(directiveResolver, nestedProtoView, elementBinderStack, boundElementIndex, distanceToParentBinder, distanceToParentPei, beginElementCmd) {
    var parentElementBinder = null;
    var parentProtoElementInjector = null;
    if (distanceToParentBinder > 0) {
        parentElementBinder = elementBinderStack[elementBinderStack.length - distanceToParentBinder];
    }
    if (lang_1.isBlank(parentElementBinder)) {
        distanceToParentBinder = -1;
    }
    if (distanceToParentPei > 0) {
        var peiBinder = elementBinderStack[elementBinderStack.length - distanceToParentPei];
        if (lang_1.isPresent(peiBinder)) {
            parentProtoElementInjector = peiBinder.protoElementInjector;
        }
    }
    if (lang_1.isBlank(parentProtoElementInjector)) {
        distanceToParentPei = -1;
    }
    var componentDirectiveProvider = null;
    var isEmbeddedTemplate = false;
    var directiveProviders = beginElementCmd.directives.map(function (type) { return provideDirective(directiveResolver, type); });
    if (beginElementCmd instanceof template_commands_1.BeginComponentCmd) {
        componentDirectiveProvider = directiveProviders[0];
    }
    else if (beginElementCmd instanceof template_commands_1.EmbeddedTemplateCmd) {
        isEmbeddedTemplate = true;
    }
    var protoElementInjector = null;
    // Create a protoElementInjector for any element that either has bindings *or* has one
    // or more var- defined *or* for <template> elements:
    // - Elements with a var- defined need a their own element injector
    //   so that, when hydrating, $implicit can be set to the element.
    // - <template> elements need their own ElementInjector so that we can query their TemplateRef
    var hasVariables = beginElementCmd.variableNameAndValues.length > 0;
    if (directiveProviders.length > 0 || hasVariables || isEmbeddedTemplate) {
        var directiveVariableBindings = new Map();
        if (!isEmbeddedTemplate) {
            directiveVariableBindings = createDirectiveVariableBindings(beginElementCmd.variableNameAndValues, directiveProviders);
        }
        protoElementInjector = element_injector_1.ProtoElementInjector.create(parentProtoElementInjector, boundElementIndex, directiveProviders, lang_1.isPresent(componentDirectiveProvider), distanceToParentPei, directiveVariableBindings);
        protoElementInjector.attributes = arrayToMap(beginElementCmd.attrNameAndValues, false);
    }
    return new element_binder_1.ElementBinder(boundElementIndex, parentElementBinder, distanceToParentBinder, protoElementInjector, componentDirectiveProvider, nestedProtoView);
}
function provideDirective(directiveResolver, type) {
    var annotation = directiveResolver.resolve(type);
    return element_injector_1.DirectiveProvider.createFromType(type, annotation);
}
function createDirectiveVariableBindings(variableNameAndValues, directiveProviders) {
    var directiveVariableBindings = new Map();
    for (var i = 0; i < variableNameAndValues.length; i += 2) {
        var templateName = variableNameAndValues[i];
        var dirIndex = variableNameAndValues[i + 1];
        if (lang_1.isNumber(dirIndex)) {
            directiveVariableBindings.set(templateName, dirIndex);
        }
        else {
            // a variable without a directive index -> reference the element
            directiveVariableBindings.set(templateName, null);
        }
    }
    return directiveVariableBindings;
}
exports.createDirectiveVariableBindings = createDirectiveVariableBindings;
function arrayToMap(arr, inverse) {
    var result = new Map();
    for (var i = 0; i < arr.length; i += 2) {
        if (inverse) {
            result.set(arr[i + 1], arr[i]);
        }
        else {
            result.set(arr[i], arr[i + 1]);
        }
    }
    return result;
}
function _flattenList(tree, out) {
    for (var i = 0; i < tree.length; i++) {
        var item = di_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
            _flattenList(item, out);
        }
        else {
            out.push(item);
        }
    }
}

},{"../pipes/pipe_provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js","../pipes/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js","./directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./element_binder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_binder.js","./element_injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js","./pipe_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js","./template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","./view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/render.js","angular2/src/core/application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
/**
 * An unmodifiable list of items that Angular keeps up to date when the state
 * of the application changes.
 *
 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
 *
 * Implements an iterable interface, therefore it can be used in both ES6
 * javascript `for (var i of items)` loops as well as in Angular templates with
 * `*ng-for="#i of myList"`.
 *
 * Changes can be observed by subscribing to the changes `Observable`.
 *
 * NOTE: In the future this class will implement an `Observable` interface.
 *
 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
 * ```javascript
 * @Component({...})
 * class Container {
 *   constructor(@Query(Item) items: QueryList<Item>) {
 *     items.changes.subscribe(_ => console.log(items.length));
 *   }
 * }
 * ```
 */
var QueryList = (function () {
    function QueryList() {
        this._results = [];
        this._emitter = new async_1.EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
        get: function () { return this._emitter; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
        get: function () { return this._results.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
        get: function () { return collection_1.ListWrapper.first(this._results); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
        get: function () { return collection_1.ListWrapper.last(this._results); },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new list with the passsed in function applied to each element.
     */
    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };
    QueryList.prototype.toString = function () { return this._results.toString(); };
    /**
     * @internal
     */
    QueryList.prototype.reset = function (res) { this._results = res; };
    /** @internal */
    QueryList.prototype.notifyOnChanges = function () { this._emitter.next(this); };
    return QueryList;
})();
exports.QueryList = QueryList;

},{"angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var _nextTemplateId = 0;
function nextTemplateId() {
    return _nextTemplateId++;
}
exports.nextTemplateId = nextTemplateId;
/**
 * A compiled host template.
 *
 * This is const as we are storing it as annotation
 * for the compiled component type.
 */
var CompiledHostTemplate = (function () {
    // Note: _templateGetter is a function so that CompiledHostTemplate can be
    // a const!
    function CompiledHostTemplate(_templateGetter) {
        this._templateGetter = _templateGetter;
    }
    CompiledHostTemplate.prototype.getTemplate = function () { return this._templateGetter(); };
    CompiledHostTemplate = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Function])
    ], CompiledHostTemplate);
    return CompiledHostTemplate;
})();
exports.CompiledHostTemplate = CompiledHostTemplate;
/**
 * A compiled template.
 */
var CompiledTemplate = (function () {
    // Note: paramGetter is a function so that we can have cycles between templates!
    // paramGetter returns a tuple with:
    // - ChangeDetector factory function
    // - TemplateCmd[]
    // - styles
    function CompiledTemplate(id, _dataGetter) {
        this.id = id;
        this._dataGetter = _dataGetter;
    }
    CompiledTemplate.prototype.getData = function (appId) {
        var data = this._dataGetter(appId, this.id);
        return new CompiledTemplateData(data[0], data[1], data[2]);
    };
    return CompiledTemplate;
})();
exports.CompiledTemplate = CompiledTemplate;
var CompiledTemplateData = (function () {
    function CompiledTemplateData(changeDetectorFactory, commands, styles) {
        this.changeDetectorFactory = changeDetectorFactory;
        this.commands = commands;
        this.styles = styles;
    }
    return CompiledTemplateData;
})();
exports.CompiledTemplateData = CompiledTemplateData;
var EMPTY_ARR = lang_1.CONST_EXPR([]);
var TextCmd = (function () {
    function TextCmd(value, isBound, ngContentIndex) {
        this.value = value;
        this.isBound = isBound;
        this.ngContentIndex = ngContentIndex;
    }
    TextCmd.prototype.visit = function (visitor, context) {
        return visitor.visitText(this, context);
    };
    return TextCmd;
})();
exports.TextCmd = TextCmd;
function text(value, isBound, ngContentIndex) {
    return new TextCmd(value, isBound, ngContentIndex);
}
exports.text = text;
var NgContentCmd = (function () {
    function NgContentCmd(index, ngContentIndex) {
        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.isBound = false;
    }
    NgContentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitNgContent(this, context);
    };
    return NgContentCmd;
})();
exports.NgContentCmd = NgContentCmd;
function ngContent(index, ngContentIndex) {
    return new NgContentCmd(index, ngContentIndex);
}
exports.ngContent = ngContent;
var BeginElementCmd = (function () {
    function BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        this.name = name;
        this.attrNameAndValues = attrNameAndValues;
        this.eventTargetAndNames = eventTargetAndNames;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.isBound = isBound;
        this.ngContentIndex = ngContentIndex;
    }
    BeginElementCmd.prototype.visit = function (visitor, context) {
        return visitor.visitBeginElement(this, context);
    };
    return BeginElementCmd;
})();
exports.BeginElementCmd = BeginElementCmd;
function beginElement(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
    return new BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex);
}
exports.beginElement = beginElement;
var EndElementCmd = (function () {
    function EndElementCmd() {
    }
    EndElementCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEndElement(context);
    };
    return EndElementCmd;
})();
exports.EndElementCmd = EndElementCmd;
function endElement() {
    return new EndElementCmd();
}
exports.endElement = endElement;
var BeginComponentCmd = (function () {
    function BeginComponentCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template) {
        this.name = name;
        this.attrNameAndValues = attrNameAndValues;
        this.eventTargetAndNames = eventTargetAndNames;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.nativeShadow = nativeShadow;
        this.ngContentIndex = ngContentIndex;
        this.template = template;
        this.isBound = true;
        this.templateId = template.id;
    }
    BeginComponentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitBeginComponent(this, context);
    };
    return BeginComponentCmd;
})();
exports.BeginComponentCmd = BeginComponentCmd;
function beginComponent(name, attrNameAnsValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template) {
    return new BeginComponentCmd(name, attrNameAnsValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template);
}
exports.beginComponent = beginComponent;
var EndComponentCmd = (function () {
    function EndComponentCmd() {
    }
    EndComponentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEndComponent(context);
    };
    return EndComponentCmd;
})();
exports.EndComponentCmd = EndComponentCmd;
function endComponent() {
    return new EndComponentCmd();
}
exports.endComponent = endComponent;
var EmbeddedTemplateCmd = (function () {
    function EmbeddedTemplateCmd(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children) {
        this.attrNameAndValues = attrNameAndValues;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.isMerged = isMerged;
        this.ngContentIndex = ngContentIndex;
        this.changeDetectorFactory = changeDetectorFactory;
        this.children = children;
        this.isBound = true;
        this.name = null;
        this.eventTargetAndNames = EMPTY_ARR;
    }
    EmbeddedTemplateCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateCmd;
})();
exports.EmbeddedTemplateCmd = EmbeddedTemplateCmd;
function embeddedTemplate(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children) {
    return new EmbeddedTemplateCmd(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children);
}
exports.embeddedTemplate = embeddedTemplate;
function visitAllCommands(visitor, cmds, context) {
    if (context === void 0) { context = null; }
    for (var i = 0; i < cmds.length; i++) {
        cmds[i].visit(visitor, context);
    }
}
exports.visitAllCommands = visitAllCommands;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var view_ref_1 = require('./view_ref');
/**
 * Represents an Embedded Template that can be used to instantiate Embedded Views.
 *
 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
 * `TemplateRef` from a Component or a Directive via {@link Query}.
 *
 * To instantiate Embedded Views based on a Template, use
 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
 * View Container.
 */
var TemplateRef = (function () {
    function TemplateRef() {
    }
    return TemplateRef;
})();
exports.TemplateRef = TemplateRef;
var TemplateRef_ = (function (_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(elementRef) {
        _super.call(this);
        this.elementRef = elementRef;
    }
    TemplateRef_.prototype._getProtoView = function () {
        var elementRef = this.elementRef;
        var parentView = view_ref_1.internalView(elementRef.parentView);
        return parentView.proto.elementBinders[elementRef.boundElementIndex - parentView.elementOffset]
            .nestedProtoView;
    };
    Object.defineProperty(TemplateRef_.prototype, "protoViewRef", {
        /**
         * Reference to the ProtoView used for creating Embedded Views that are based on the compiled
         * Embedded Template.
         */
        get: function () { return this._getProtoView().ref; },
        enumerable: true,
        configurable: true
    });
    TemplateRef_.prototype.hasLocal = function (name) {
        return this._getProtoView().templateVariableBindings.has(name);
    };
    return TemplateRef_;
})(TemplateRef);
exports.TemplateRef_ = TemplateRef_;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var interfaces_1 = require('angular2/src/core/change_detection/interfaces');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var view_ref_1 = require('./view_ref');
var util_1 = require('angular2/src/core/render/dom/util');
var view_ref_2 = require("./view_ref");
var interfaces_2 = require('angular2/src/core/change_detection/interfaces');
exports.DebugContext = interfaces_2.DebugContext;
var REFLECT_PREFIX = 'ng-reflect-';
(function (ViewType) {
    // A view that contains the host element with bound component directive.
    // Contains a COMPONENT view
    ViewType[ViewType["HOST"] = 0] = "HOST";
    // The view of the component
    // Can contain 0 to n EMBEDDED views
    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
    // A view that is embedded into another View via a <template> element
    // inside of a COMPONENT view
    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
})(exports.ViewType || (exports.ViewType = {}));
var ViewType = exports.ViewType;
var AppViewContainer = (function () {
    function AppViewContainer() {
        // The order in this list matches the DOM order.
        this.views = [];
    }
    return AppViewContainer;
})();
exports.AppViewContainer = AppViewContainer;
/**
 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
 *
 */
var AppView = (function () {
    function AppView(renderer, proto, viewOffset, elementOffset, textOffset, protoLocals, render, renderFragment, containerElementInjector) {
        this.renderer = renderer;
        this.proto = proto;
        this.viewOffset = viewOffset;
        this.elementOffset = elementOffset;
        this.textOffset = textOffset;
        this.render = render;
        this.renderFragment = renderFragment;
        this.containerElementInjector = containerElementInjector;
        // AppViews that have been merged in depth first order.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.views = null;
        // ElementInjectors of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.elementInjectors = null;
        // ViewContainers of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.viewContainers = null;
        // PreBuiltObjects of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.preBuiltObjects = null;
        this.changeDetector = null;
        /**
         * The context against which data-binding expressions in this view are evaluated against.
         * This is always a component instance.
         */
        this.context = null;
        this.ref = new view_ref_2.ViewRef_(this);
        this.locals = new change_detection_1.Locals(null, collection_1.MapWrapper.clone(protoLocals)); // TODO optimize this
    }
    AppView.prototype.init = function (changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers) {
        this.changeDetector = changeDetector;
        this.elementInjectors = elementInjectors;
        this.rootElementInjectors = rootElementInjectors;
        this.preBuiltObjects = preBuiltObjects;
        this.views = views;
        this.elementRefs = elementRefs;
        this.viewContainers = viewContainers;
    };
    AppView.prototype.setLocal = function (contextName, value) {
        if (!this.hydrated())
            throw new exceptions_1.BaseException('Cannot set locals on dehydrated view.');
        if (!this.proto.templateVariableBindings.has(contextName)) {
            return;
        }
        var templateName = this.proto.templateVariableBindings.get(contextName);
        this.locals.set(templateName, value);
    };
    AppView.prototype.hydrated = function () { return lang_1.isPresent(this.context); };
    /**
     * Triggers the event handlers for the element and the directives.
     *
     * This method is intended to be called from directive EventEmitters.
     *
     * @param {string} eventName
     * @param {*} eventObj
     * @param {number} boundElementIndex
     */
    AppView.prototype.triggerEventHandlers = function (eventName, eventObj, boundElementIndex) {
        var locals = new collection_1.Map();
        locals.set('$event', eventObj);
        this.dispatchEvent(boundElementIndex, eventName, locals);
    };
    // dispatch to element injector or text nodes based on context
    AppView.prototype.notifyOnBinding = function (b, currentValue) {
        if (b.isTextNode()) {
            this.renderer.setText(this.render, b.elementIndex + this.textOffset, currentValue);
        }
        else {
            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
            if (b.isElementProperty()) {
                this.renderer.setElementProperty(elementRef, b.name, currentValue);
            }
            else if (b.isElementAttribute()) {
                this.renderer.setElementAttribute(elementRef, b.name, lang_1.isPresent(currentValue) ? "" + currentValue : null);
            }
            else if (b.isElementClass()) {
                this.renderer.setElementClass(elementRef, b.name, currentValue);
            }
            else if (b.isElementStyle()) {
                var unit = lang_1.isPresent(b.unit) ? b.unit : '';
                this.renderer.setElementStyle(elementRef, b.name, "" + currentValue + unit);
            }
            else {
                throw new exceptions_1.BaseException('Unsupported directive record');
            }
        }
    };
    AppView.prototype.logBindingUpdate = function (b, value) {
        if (b.isDirective() || b.isElementProperty()) {
            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
            this.renderer.setElementAttribute(elementRef, "" + REFLECT_PREFIX + util_1.camelCaseToDashCase(b.name), "" + value);
        }
    };
    AppView.prototype.notifyAfterContentChecked = function () {
        var eiCount = this.proto.elementBinders.length;
        var ei = this.elementInjectors;
        for (var i = eiCount - 1; i >= 0; i--) {
            if (lang_1.isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].afterContentChecked();
        }
    };
    AppView.prototype.notifyAfterViewChecked = function () {
        var eiCount = this.proto.elementBinders.length;
        var ei = this.elementInjectors;
        for (var i = eiCount - 1; i >= 0; i--) {
            if (lang_1.isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].afterViewChecked();
        }
    };
    AppView.prototype.getDirectiveFor = function (directive) {
        var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
        return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
    };
    AppView.prototype.getNestedView = function (boundElementIndex) {
        var eli = this.elementInjectors[boundElementIndex];
        return lang_1.isPresent(eli) ? eli.getNestedView() : null;
    };
    AppView.prototype.getContainerElement = function () {
        return lang_1.isPresent(this.containerElementInjector) ?
            this.containerElementInjector.getElementRef() :
            null;
    };
    AppView.prototype.getDebugContext = function (elementIndex, directiveIndex) {
        try {
            var offsettedIndex = this.elementOffset + elementIndex;
            var hasRefForIndex = offsettedIndex < this.elementRefs.length;
            var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
            var container = this.getContainerElement();
            var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
            var element = lang_1.isPresent(elementRef) ? elementRef.nativeElement : null;
            var componentElement = lang_1.isPresent(container) ? container.nativeElement : null;
            var directive = lang_1.isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
            var injector = lang_1.isPresent(ei) ? ei.getInjector() : null;
            return new interfaces_1.DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);
        }
        catch (e) {
            // TODO: vsavkin log the exception once we have a good way to log errors and warnings
            // if an error happens during getting the debug context, we return null.
            return null;
        }
    };
    AppView.prototype.getDetectorFor = function (directive) {
        var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
        return lang_1.isPresent(childView) ? childView.changeDetector : null;
    };
    AppView.prototype.invokeElementMethod = function (elementIndex, methodName, args) {
        this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
    };
    // implementation of RenderEventDispatcher#dispatchRenderEvent
    AppView.prototype.dispatchRenderEvent = function (boundElementIndex, eventName, locals) {
        var elementRef = this.elementRefs[boundElementIndex];
        var view = view_ref_1.internalView(elementRef.parentView);
        return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
    };
    // returns false if preventDefault must be applied to the DOM event
    AppView.prototype.dispatchEvent = function (boundElementIndex, eventName, locals) {
        try {
            if (this.hydrated()) {
                return !this.changeDetector.handleEvent(eventName, boundElementIndex - this.elementOffset, new change_detection_1.Locals(this.locals, locals));
            }
            else {
                return true;
            }
        }
        catch (e) {
            var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector) :
                null;
            throw new EventEvaluationError(eventName, e, e.stack, context);
        }
    };
    Object.defineProperty(AppView.prototype, "ownBindersCount", {
        get: function () { return this.proto.elementBinders.length; },
        enumerable: true,
        configurable: true
    });
    return AppView;
})();
exports.AppView = AppView;
function _localsToStringMap(locals) {
    var res = {};
    var c = locals;
    while (lang_1.isPresent(c)) {
        res = collection_1.StringMapWrapper.merge(res, collection_1.MapWrapper.toStringMap(c.current));
        c = c.parent;
    }
    return res;
}
/**
 * Error context included when an event handler throws an exception.
 */
var _Context = (function () {
    function _Context(element, componentElement, context, locals, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
    }
    return _Context;
})();
/**
 * Wraps an exception thrown by an event handler.
 */
var EventEvaluationError = (function (_super) {
    __extends(EventEvaluationError, _super);
    function EventEvaluationError(eventName, originalException, originalStack, context) {
        _super.call(this, "Error during evaluation of \"" + eventName + "\"", originalException, originalStack, context);
    }
    return EventEvaluationError;
})(exceptions_1.WrappedException);
var AppProtoViewMergeInfo = (function () {
    function AppProtoViewMergeInfo(embeddedViewCount, elementCount, viewCount) {
        this.embeddedViewCount = embeddedViewCount;
        this.elementCount = elementCount;
        this.viewCount = viewCount;
    }
    return AppProtoViewMergeInfo;
})();
exports.AppProtoViewMergeInfo = AppProtoViewMergeInfo;
/**
 *
 */
var AppProtoView = (function () {
    function AppProtoView(templateCmds, type, isMergable, changeDetectorFactory, templateVariableBindings, pipes) {
        this.templateCmds = templateCmds;
        this.type = type;
        this.isMergable = isMergable;
        this.changeDetectorFactory = changeDetectorFactory;
        this.templateVariableBindings = templateVariableBindings;
        this.pipes = pipes;
        this.elementBinders = null;
        this.mergeInfo = null;
        this.variableLocations = null;
        this.textBindingCount = null;
        this.render = null;
        this.ref = new view_ref_2.ProtoViewRef_(this);
    }
    AppProtoView.prototype.init = function (render, elementBinders, textBindingCount, mergeInfo, variableLocations) {
        var _this = this;
        this.render = render;
        this.elementBinders = elementBinders;
        this.textBindingCount = textBindingCount;
        this.mergeInfo = mergeInfo;
        this.variableLocations = variableLocations;
        this.protoLocals = new collection_1.Map();
        if (lang_1.isPresent(this.templateVariableBindings)) {
            this.templateVariableBindings.forEach(function (templateName, _) { _this.protoLocals.set(templateName, null); });
        }
        if (lang_1.isPresent(variableLocations)) {
            // The view's locals needs to have a full set of variable names at construction time
            // in order to prevent new variables from being set later in the lifecycle. Since we don't
            // want
            // to actually create variable bindings for the $implicit bindings, add to the
            // protoLocals manually.
            variableLocations.forEach(function (_, templateName) { _this.protoLocals.set(templateName, null); });
        }
    };
    AppProtoView.prototype.isInitialized = function () { return lang_1.isPresent(this.elementBinders); };
    return AppProtoView;
})();
exports.AppProtoView = AppProtoView;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/change_detection/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/render/dom/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
var view_ref_1 = require('./view_ref');
/**
 * Represents a container where one or more Views can be attached.
 *
 * The container can contain two kinds of Views. Host Views, created by instantiating a
 * {@link Component} via {@link #createHostView}, and Embedded Views, created by instantiating an
 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
 *
 * The location of the View Container within the containing View is specified by the Anchor
 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
 * have a single View Container.
 *
 * Root elements of Views attached to this container become siblings of the Anchor Element in
 * the Rendered View.
 *
 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
 * with `ViewContainerRef` on the Element, or you obtain it via
 * {@link AppViewManager#getViewContainer}.
 *
 * <!-- TODO(i): we are also considering ElementRef#viewContainer api -->
 */
var ViewContainerRef = (function () {
    function ViewContainerRef() {
    }
    /**
     * Destroys all Views in this container.
     */
    ViewContainerRef.prototype.clear = function () {
        for (var i = this.length - 1; i >= 0; i--) {
            this.remove(i);
        }
    };
    Object.defineProperty(ViewContainerRef.prototype, "length", {
        /**
         * Returns the number of Views currently attached to this container.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ViewContainerRef;
})();
exports.ViewContainerRef = ViewContainerRef;
var ViewContainerRef_ = (function (_super) {
    __extends(ViewContainerRef_, _super);
    function ViewContainerRef_(viewManager, element) {
        _super.call(this);
        this.viewManager = viewManager;
        this.element = element;
    }
    ViewContainerRef_.prototype._getViews = function () {
        var element = this.element;
        var vc = view_ref_1.internalView(element.parentView).viewContainers[element.boundElementIndex];
        return lang_1.isPresent(vc) ? vc.views : [];
    };
    ViewContainerRef_.prototype.get = function (index) { return this._getViews()[index].ref; };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
        get: function () { return this._getViews().length; },
        enumerable: true,
        configurable: true
    });
    // TODO(rado): profile and decide whether bounds checks should be added
    // to the methods below.
    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length;
        return this.viewManager.createEmbeddedViewInContainer(this.element, index, templateRef);
    };
    ViewContainerRef_.prototype.createHostView = function (protoViewRef, index, dynamicallyCreatedProviders) {
        if (protoViewRef === void 0) { protoViewRef = null; }
        if (index === void 0) { index = -1; }
        if (dynamicallyCreatedProviders === void 0) { dynamicallyCreatedProviders = null; }
        if (index == -1)
            index = this.length;
        return this.viewManager.createHostViewInContainer(this.element, index, protoViewRef, dynamicallyCreatedProviders);
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.insert = function (viewRef, index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length;
        return this.viewManager.attachViewInContainer(this.element, index, viewRef);
    };
    ViewContainerRef_.prototype.indexOf = function (viewRef) {
        return collection_1.ListWrapper.indexOf(this._getViews(), view_ref_1.internalView(viewRef));
    };
    // TODO(i): rename to destroy
    ViewContainerRef_.prototype.remove = function (index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length - 1;
        this.viewManager.destroyViewInContainer(this.element, index);
        // view is intentionally not returned to the client.
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.detach = function (index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length - 1;
        return this.viewManager.detachViewInContainer(this.element, index);
    };
    return ViewContainerRef_;
})(ViewContainerRef);
exports.ViewContainerRef_ = ViewContainerRef_;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
/**
 * Listener for view creation / destruction.
 */
var AppViewListener = (function () {
    function AppViewListener() {
    }
    AppViewListener.prototype.viewCreated = function (view) { };
    AppViewListener.prototype.viewDestroyed = function (view) { };
    AppViewListener = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AppViewListener);
    return AppViewListener;
})();
exports.AppViewListener = AppViewListener;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var viewModule = require('./view');
var view_ref_1 = require('./view_ref');
var api_1 = require('angular2/src/core/render/api');
var view_manager_utils_1 = require('./view_manager_utils');
var view_pool_1 = require('./view_pool');
var view_listener_1 = require('./view_listener');
var profile_1 = require('../profile/profile');
var proto_view_factory_1 = require('./proto_view_factory');
/**
 * Service exposing low level API for creating, moving and destroying Views.
 *
 * Most applications should use higher-level abstractions like {@link DynamicComponentLoader} and
 * {@link ViewContainerRef} instead.
 */
var AppViewManager = (function () {
    function AppViewManager() {
    }
    /**
     * Returns the {@link ElementRef} that makes up the specified Host View.
     */
    AppViewManager.prototype.getHostElement = function (hostViewRef) {
        var hostView = view_ref_1.internalView(hostViewRef);
        if (hostView.proto.type !== viewModule.ViewType.HOST) {
            throw new exceptions_1.BaseException('This operation is only allowed on host views');
        }
        return hostView.elementRefs[hostView.elementOffset];
    };
    return AppViewManager;
})();
exports.AppViewManager = AppViewManager;
var AppViewManager_ = (function (_super) {
    __extends(AppViewManager_, _super);
    function AppViewManager_(_viewPool, _viewListener, _utils, _renderer, _protoViewFactory) {
        _super.call(this);
        this._viewPool = _viewPool;
        this._viewListener = _viewListener;
        this._utils = _utils;
        this._renderer = _renderer;
        /** @internal */
        this._createRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#createRootHostView()');
        /** @internal */
        this._destroyRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#destroyRootHostView()');
        /** @internal */
        this._createEmbeddedViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');
        /** @internal */
        this._createHostViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createHostViewInContainer()');
        /** @internal */
        this._destroyViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#destroyViewInContainer()');
        /** @internal */
        this._attachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#attachViewInContainer()');
        /** @internal */
        this._detachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#detachViewInContainer()');
        this._protoViewFactory = _protoViewFactory;
    }
    AppViewManager_.prototype.getViewContainer = function (location) {
        var hostView = view_ref_1.internalView(location.parentView);
        return hostView.elementInjectors[location.boundElementIndex]
            .getViewContainerRef();
    };
    AppViewManager_.prototype.getNamedElementInComponentView = function (hostLocation, variableName) {
        var hostView = view_ref_1.internalView(hostLocation.parentView);
        var boundElementIndex = hostLocation.boundElementIndex;
        var componentView = hostView.getNestedView(boundElementIndex);
        if (lang_1.isBlank(componentView)) {
            throw new exceptions_1.BaseException("There is no component directive at element " + boundElementIndex);
        }
        var binderIdx = componentView.proto.variableLocations.get(variableName);
        if (lang_1.isBlank(binderIdx)) {
            throw new exceptions_1.BaseException("Could not find variable " + variableName);
        }
        return componentView.elementRefs[componentView.elementOffset + binderIdx];
    };
    AppViewManager_.prototype.getComponent = function (hostLocation) {
        var hostView = view_ref_1.internalView(hostLocation.parentView);
        var boundElementIndex = hostLocation.boundElementIndex;
        return this._utils.getComponentInstance(hostView, boundElementIndex);
    };
    AppViewManager_.prototype.createRootHostView = function (hostProtoViewRef, overrideSelector, injector) {
        var s = this._createRootHostViewScope();
        var hostProtoView = view_ref_1.internalProtoView(hostProtoViewRef);
        this._protoViewFactory.initializeProtoViewIfNeeded(hostProtoView);
        var hostElementSelector = overrideSelector;
        if (lang_1.isBlank(hostElementSelector)) {
            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
        }
        var renderViewWithFragments = this._renderer.createRootHostView(hostProtoView.render, hostProtoView.mergeInfo.embeddedViewCount + 1, hostElementSelector);
        var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
        this._renderer.hydrateView(hostView.render);
        this._utils.hydrateRootHostView(hostView, injector);
        return profile_1.wtfLeave(s, hostView.ref);
    };
    AppViewManager_.prototype.destroyRootHostView = function (hostViewRef) {
        // Note: Don't put the hostView into the view pool
        // as it is depending on the element for which it was created.
        var s = this._destroyRootHostViewScope();
        var hostView = view_ref_1.internalView(hostViewRef);
        this._renderer.detachFragment(hostView.renderFragment);
        this._renderer.dehydrateView(hostView.render);
        this._viewDehydrateRecurse(hostView);
        this._viewListener.viewDestroyed(hostView);
        this._renderer.destroyView(hostView.render);
        profile_1.wtfLeave(s);
    };
    AppViewManager_.prototype.createEmbeddedViewInContainer = function (viewContainerLocation, index, templateRef) {
        var s = this._createEmbeddedViewInContainerScope();
        var protoView = view_ref_1.internalProtoView(templateRef.protoViewRef);
        if (protoView.type !== viewModule.ViewType.EMBEDDED) {
            throw new exceptions_1.BaseException('This method can only be called with embedded ProtoViews!');
        }
        this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, index, protoView, templateRef.elementRef, null));
    };
    AppViewManager_.prototype.createHostViewInContainer = function (viewContainerLocation, index, protoViewRef, imperativelyCreatedInjector) {
        var s = this._createHostViewInContainerScope();
        var protoView = view_ref_1.internalProtoView(protoViewRef);
        if (protoView.type !== viewModule.ViewType.HOST) {
            throw new exceptions_1.BaseException('This method can only be called with host ProtoViews!');
        }
        this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, index, protoView, viewContainerLocation, imperativelyCreatedInjector));
    };
    /**
     *
     * See {@link AppViewManager#destroyViewInContainer}.
     * @internal
     */
    AppViewManager_.prototype._createViewInContainer = function (viewContainerLocation, index, protoView, context, imperativelyCreatedInjector) {
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        var contextView = view_ref_1.internalView(context.parentView);
        var contextBoundElementIndex = context.boundElementIndex;
        var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
        var view;
        if (protoView.type === viewModule.ViewType.EMBEDDED && lang_1.isPresent(embeddedFragmentView) &&
            !embeddedFragmentView.hydrated()) {
            // Case 1: instantiate the first view of a template that has been merged into a parent
            view = embeddedFragmentView;
            this._attachRenderView(parentView, boundElementIndex, index, view);
        }
        else {
            // Case 2: instantiate another copy of the template or a host ProtoView.
            // This is a separate case
            // as we only inline one copy of the template into the parent view.
            view = this._createPooledView(protoView);
            this._attachRenderView(parentView, boundElementIndex, index, view);
            this._renderer.hydrateView(view.render);
        }
        this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, index, view);
        this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, index, imperativelyCreatedInjector);
        return view.ref;
    };
    /** @internal */
    AppViewManager_.prototype._attachRenderView = function (parentView, boundElementIndex, index, view) {
        var elementRef = parentView.elementRefs[boundElementIndex];
        if (index === 0) {
            this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
        }
        else {
            var prevView = parentView.viewContainers[boundElementIndex].views[index - 1];
            this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
        }
    };
    AppViewManager_.prototype.destroyViewInContainer = function (viewContainerLocation, index) {
        var s = this._destroyViewInContainerScope();
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        this._destroyViewInContainer(parentView, boundElementIndex, index);
        profile_1.wtfLeave(s);
    };
    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
    AppViewManager_.prototype.attachViewInContainer = function (viewContainerLocation, index, viewRef) {
        var s = this._attachViewInContainerScope();
        var view = view_ref_1.internalView(viewRef);
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        // TODO(tbosch): the public methods attachViewInContainer/detachViewInContainer
        // are used for moving elements without the same container.
        // We will change this into an atomic `move` operation, which should preserve the
        // previous parent injector (see https://github.com/angular/angular/issues/1377).
        // Right now we are destroying any special
        // context view that might have been used.
        this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, index, view);
        this._attachRenderView(parentView, boundElementIndex, index, view);
        return profile_1.wtfLeave(s, viewRef);
    };
    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
    AppViewManager_.prototype.detachViewInContainer = function (viewContainerLocation, index) {
        var s = this._detachViewInContainerScope();
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        this._utils.detachViewInContainer(parentView, boundElementIndex, index);
        this._renderer.detachFragment(view.renderFragment);
        return profile_1.wtfLeave(s, view.ref);
    };
    /** @internal */
    AppViewManager_.prototype._createMainView = function (protoView, renderViewWithFragments) {
        var mergedParentView = this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
        this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
        this._viewListener.viewCreated(mergedParentView);
        return mergedParentView;
    };
    /** @internal */
    AppViewManager_.prototype._createPooledView = function (protoView) {
        var view = this._viewPool.getView(protoView);
        if (lang_1.isBlank(view)) {
            view = this._createMainView(protoView, this._renderer.createView(protoView.render, protoView.mergeInfo.embeddedViewCount + 1));
        }
        return view;
    };
    /** @internal */
    AppViewManager_.prototype._destroyPooledView = function (view) {
        var wasReturned = this._viewPool.returnView(view);
        if (!wasReturned) {
            this._viewListener.viewDestroyed(view);
            this._renderer.destroyView(view.render);
        }
    };
    /** @internal */
    AppViewManager_.prototype._destroyViewInContainer = function (parentView, boundElementIndex, index) {
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        this._viewDehydrateRecurse(view);
        this._utils.detachViewInContainer(parentView, boundElementIndex, index);
        if (view.viewOffset > 0) {
            // Case 1: a view that is part of another view.
            // Just detach the fragment
            this._renderer.detachFragment(view.renderFragment);
        }
        else {
            // Case 2: a view that is not part of another view.
            // dehydrate and destroy it.
            this._renderer.dehydrateView(view.render);
            this._renderer.detachFragment(view.renderFragment);
            this._destroyPooledView(view);
        }
    };
    /** @internal */
    AppViewManager_.prototype._viewDehydrateRecurse = function (view) {
        if (view.hydrated()) {
            this._utils.dehydrateView(view);
        }
        var viewContainers = view.viewContainers;
        var startViewOffset = view.viewOffset;
        var endViewOffset = view.viewOffset + view.proto.mergeInfo.viewCount - 1;
        var elementOffset = view.elementOffset;
        for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = view.views[viewIdx];
            for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length; binderIdx++, elementOffset++) {
                var vc = viewContainers[elementOffset];
                if (lang_1.isPresent(vc)) {
                    for (var j = vc.views.length - 1; j >= 0; j--) {
                        this._destroyViewInContainer(currView, elementOffset, j);
                    }
                }
            }
        }
    };
    AppViewManager_ = __decorate([
        di_1.Injectable(),
        __param(4, di_1.Inject(di_1.forwardRef(function () { return proto_view_factory_1.ProtoViewFactory; }))), 
        __metadata('design:paramtypes', [view_pool_1.AppViewPool, view_listener_1.AppViewListener, view_manager_utils_1.AppViewManagerUtils, api_1.Renderer, Object])
    ], AppViewManager_);
    return AppViewManager_;
})(AppViewManager);
exports.AppViewManager_ = AppViewManager_;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","./proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","./view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","./view_manager_utils":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js","./view_pool":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js","./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var eli = require('./element_injector');
var lang_1 = require('angular2/src/core/facade/lang');
var viewModule = require('./view');
var element_ref_1 = require('./element_ref');
var template_ref_1 = require('./template_ref');
var pipes_1 = require('angular2/src/core/pipes/pipes');
var AppViewManagerUtils = (function () {
    function AppViewManagerUtils() {
    }
    AppViewManagerUtils.prototype.getComponentInstance = function (parentView, boundElementIndex) {
        var eli = parentView.elementInjectors[boundElementIndex];
        return eli.getComponent();
    };
    AppViewManagerUtils.prototype.createView = function (mergedParentViewProto, renderViewWithFragments, viewManager, renderer) {
        var renderFragments = renderViewWithFragments.fragmentRefs;
        var renderView = renderViewWithFragments.viewRef;
        var elementCount = mergedParentViewProto.mergeInfo.elementCount;
        var viewCount = mergedParentViewProto.mergeInfo.viewCount;
        var elementRefs = collection_1.ListWrapper.createFixedSize(elementCount);
        var viewContainers = collection_1.ListWrapper.createFixedSize(elementCount);
        var preBuiltObjects = collection_1.ListWrapper.createFixedSize(elementCount);
        var elementInjectors = collection_1.ListWrapper.createFixedSize(elementCount);
        var views = collection_1.ListWrapper.createFixedSize(viewCount);
        var elementOffset = 0;
        var textOffset = 0;
        var fragmentIdx = 0;
        var containerElementIndicesByViewIndex = collection_1.ListWrapper.createFixedSize(viewCount);
        for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
            var containerElementIndex = containerElementIndicesByViewIndex[viewOffset];
            var containerElementInjector = lang_1.isPresent(containerElementIndex) ? elementInjectors[containerElementIndex] : null;
            var parentView = lang_1.isPresent(containerElementInjector) ? preBuiltObjects[containerElementIndex].view : null;
            var protoView = lang_1.isPresent(containerElementIndex) ?
                parentView.proto.elementBinders[containerElementIndex - parentView.elementOffset]
                    .nestedProtoView :
                mergedParentViewProto;
            var renderFragment = null;
            if (viewOffset === 0 || protoView.type === viewModule.ViewType.EMBEDDED) {
                renderFragment = renderFragments[fragmentIdx++];
            }
            var currentView = new viewModule.AppView(renderer, protoView, viewOffset, elementOffset, textOffset, protoView.protoLocals, renderView, renderFragment, containerElementInjector);
            views[viewOffset] = currentView;
            if (lang_1.isPresent(containerElementIndex)) {
                preBuiltObjects[containerElementIndex].nestedView = currentView;
            }
            var rootElementInjectors = [];
            var nestedViewOffset = viewOffset + 1;
            for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
                var binder = protoView.elementBinders[binderIdx];
                var boundElementIndex = elementOffset + binderIdx;
                var elementInjector = null;
                if (lang_1.isPresent(binder.nestedProtoView) && binder.nestedProtoView.isMergable) {
                    containerElementIndicesByViewIndex[nestedViewOffset] = boundElementIndex;
                    nestedViewOffset += binder.nestedProtoView.mergeInfo.viewCount;
                }
                // elementInjectors and rootElementInjectors
                var protoElementInjector = binder.protoElementInjector;
                if (lang_1.isPresent(protoElementInjector)) {
                    if (lang_1.isPresent(protoElementInjector.parent)) {
                        var parentElementInjector = elementInjectors[elementOffset + protoElementInjector.parent.index];
                        elementInjector = protoElementInjector.instantiate(parentElementInjector);
                    }
                    else {
                        elementInjector = protoElementInjector.instantiate(null);
                        rootElementInjectors.push(elementInjector);
                    }
                }
                elementInjectors[boundElementIndex] = elementInjector;
                // elementRefs
                var el = new element_ref_1.ElementRef_(currentView.ref, boundElementIndex, renderer);
                elementRefs[el.boundElementIndex] = el;
                // preBuiltObjects
                if (lang_1.isPresent(elementInjector)) {
                    var templateRef = lang_1.isPresent(binder.nestedProtoView) &&
                        binder.nestedProtoView.type === viewModule.ViewType.EMBEDDED ?
                        new template_ref_1.TemplateRef_(el) :
                        null;
                    preBuiltObjects[boundElementIndex] =
                        new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
                }
            }
            currentView.init(protoView.changeDetectorFactory(currentView), elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
            if (lang_1.isPresent(parentView) && protoView.type === viewModule.ViewType.COMPONENT) {
                parentView.changeDetector.addShadowDomChild(currentView.changeDetector);
            }
            elementOffset += protoView.elementBinders.length;
            textOffset += protoView.textBindingCount;
        }
        return views[0];
    };
    AppViewManagerUtils.prototype.hydrateRootHostView = function (hostView, injector) {
        this._hydrateView(hostView, injector, null, new Object(), null);
    };
    // Misnomer: this method is attaching next to the view container.
    AppViewManagerUtils.prototype.attachViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, index, view) {
        if (lang_1.isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
        }
        parentView.changeDetector.addChild(view.changeDetector);
        var viewContainer = parentView.viewContainers[boundElementIndex];
        if (lang_1.isBlank(viewContainer)) {
            viewContainer = new viewModule.AppViewContainer();
            parentView.viewContainers[boundElementIndex] = viewContainer;
        }
        collection_1.ListWrapper.insert(viewContainer.views, index, view);
        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
        for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
            if (lang_1.isPresent(elementInjector.parent)) {
                view.rootElementInjectors[i].link(elementInjector.parent);
            }
        }
        elementInjector.traverseAndSetQueriesAsDirty();
    };
    AppViewManagerUtils.prototype.detachViewInContainer = function (parentView, boundElementIndex, index) {
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        parentView.elementInjectors[boundElementIndex].traverseAndSetQueriesAsDirty();
        view.changeDetector.remove();
        collection_1.ListWrapper.removeAt(viewContainer.views, index);
        for (var i = 0; i < view.rootElementInjectors.length; ++i) {
            var inj = view.rootElementInjectors[i];
            inj.unlink();
        }
    };
    AppViewManagerUtils.prototype.hydrateViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, index, imperativelyCreatedProviders) {
        if (lang_1.isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
        }
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
        var injector = lang_1.isPresent(imperativelyCreatedProviders) ?
            di_1.Injector.fromResolvedProviders(imperativelyCreatedProviders) :
            null;
        this._hydrateView(view, injector, elementInjector.getHost(), contextView.context, contextView.locals);
    };
    /** @internal */
    AppViewManagerUtils.prototype._hydrateView = function (initView, imperativelyCreatedInjector, hostElementInjector, context, parentLocals) {
        var viewIdx = initView.viewOffset;
        var endViewOffset = viewIdx + initView.proto.mergeInfo.viewCount - 1;
        while (viewIdx <= endViewOffset) {
            var currView = initView.views[viewIdx];
            var currProtoView = currView.proto;
            if (currView !== initView && currView.proto.type === viewModule.ViewType.EMBEDDED) {
                // Don't hydrate components of embedded fragment views.
                viewIdx += currView.proto.mergeInfo.viewCount;
            }
            else {
                if (currView !== initView) {
                    // hydrate a nested component view
                    imperativelyCreatedInjector = null;
                    parentLocals = null;
                    hostElementInjector = currView.containerElementInjector;
                    context = hostElementInjector.getComponent();
                }
                currView.context = context;
                currView.locals.parent = parentLocals;
                var binders = currProtoView.elementBinders;
                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                    var boundElementIndex = binderIdx + currView.elementOffset;
                    var elementInjector = initView.elementInjectors[boundElementIndex];
                    if (lang_1.isPresent(elementInjector)) {
                        elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector, currView.preBuiltObjects[boundElementIndex]);
                        this._populateViewLocals(currView, elementInjector, boundElementIndex);
                        this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
                    }
                }
                var pipes = lang_1.isPresent(hostElementInjector) ?
                    new pipes_1.Pipes(currView.proto.pipes, hostElementInjector.getInjector()) :
                    null;
                currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
                viewIdx++;
            }
        }
    };
    /** @internal */
    AppViewManagerUtils.prototype._populateViewLocals = function (view, elementInjector, boundElementIdx) {
        if (lang_1.isPresent(elementInjector.getDirectiveVariableBindings())) {
            elementInjector.getDirectiveVariableBindings().forEach(function (directiveIndex, name) {
                if (lang_1.isBlank(directiveIndex)) {
                    view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
                }
                else {
                    view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
                }
            });
        }
    };
    /** @internal */
    AppViewManagerUtils.prototype._setUpEventEmitters = function (view, elementInjector, boundElementIndex) {
        var emitters = elementInjector.getEventEmitterAccessors();
        for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
            var directiveEmitters = emitters[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
                var eventEmitterAccessor = directiveEmitters[eventIndex];
                eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
            }
        }
    };
    AppViewManagerUtils.prototype.dehydrateView = function (initView) {
        var endViewOffset = initView.viewOffset + initView.proto.mergeInfo.viewCount - 1;
        for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = initView.views[viewIdx];
            if (currView.hydrated()) {
                if (lang_1.isPresent(currView.locals)) {
                    currView.locals.clearValues();
                }
                currView.context = null;
                currView.changeDetector.dehydrate();
                var binders = currView.proto.elementBinders;
                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                    var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
                    if (lang_1.isPresent(eli)) {
                        eli.dehydrate();
                    }
                }
            }
        }
    };
    AppViewManagerUtils = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AppViewManagerUtils);
    return AppViewManagerUtils;
})();
exports.AppViewManagerUtils = AppViewManagerUtils;

},{"./element_injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js","./element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/pipes/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
exports.APP_VIEW_POOL_CAPACITY = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppViewPool.viewPoolCapacity'));
var AppViewPool = (function () {
    function AppViewPool(poolCapacityPerProtoView) {
        /** @internal */
        this._pooledViewsPerProtoView = new collection_1.Map();
        this._poolCapacityPerProtoView = poolCapacityPerProtoView;
    }
    AppViewPool.prototype.getView = function (protoView) {
        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
        if (lang_1.isPresent(pooledViews) && pooledViews.length > 0) {
            return pooledViews.pop();
        }
        return null;
    };
    AppViewPool.prototype.returnView = function (view) {
        var protoView = view.proto;
        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
        if (lang_1.isBlank(pooledViews)) {
            pooledViews = [];
            this._pooledViewsPerProtoView.set(protoView, pooledViews);
        }
        var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
        if (haveRemainingCapacity) {
            pooledViews.push(view);
        }
        return haveRemainingCapacity;
    };
    AppViewPool = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(exports.APP_VIEW_POOL_CAPACITY)), 
        __metadata('design:paramtypes', [Object])
    ], AppViewPool);
    return AppViewPool;
})();
exports.AppViewPool = AppViewPool;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
// This is a workaround for privacy in Dart as we don't have library parts
function internalView(viewRef) {
    return viewRef._view;
}
exports.internalView = internalView;
// This is a workaround for privacy in Dart as we don't have library parts
function internalProtoView(protoViewRef) {
    return lang_1.isPresent(protoViewRef) ? protoViewRef._protoView : null;
}
exports.internalProtoView = internalProtoView;
/**
 * Represents an Angular View.
 *
 * <!-- TODO: move the next two paragraphs to the dev guide -->
 * A View is a fundamental building block of the application UI. It is the smallest grouping of
 * Elements which are created and destroyed together.
 *
 * Properties of elements in a View can change, but the structure (number and order) of elements in
 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
 * removing nested Views via a {@link ViewContainer}. Each View can contain many View Containers.
 * <!-- /TODO -->
 *
 * ## Example
 *
 * Given this template...
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ng-for="var item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * ... we have two {@link ProtoViewRef}s:
 *
 * Outer {@link ProtoViewRef}:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ng-for var-item [ng-for-of]="items"></template>
 * </ul>
 * ```
 *
 * Inner {@link ProtoViewRef}:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
 *
 * The outer/inner {@link ProtoViewRef}s are then assembled into views like so:
 *
 * ```
 * <!-- ViewRef: outer-0 -->
 * Count: 2
 * <ul>
 *   <template view-container-ref></template>
 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
 * </ul>
 * <!-- /ViewRef: outer-0 -->
 * ```
 */
var ViewRef = (function () {
    function ViewRef() {
    }
    Object.defineProperty(ViewRef.prototype, "changeDetectorRef", {
        get: function () { return exceptions_1.unimplemented(); },
        set: function (value) {
            exceptions_1.unimplemented(); // TODO: https://github.com/Microsoft/TypeScript/issues/12
        },
        enumerable: true,
        configurable: true
    });
    return ViewRef;
})();
exports.ViewRef = ViewRef;
var ViewRef_ = (function (_super) {
    __extends(ViewRef_, _super);
    function ViewRef_(_view) {
        _super.call(this);
        this._changeDetectorRef = null;
        this._view = _view;
    }
    Object.defineProperty(ViewRef_.prototype, "render", {
        /**
         * Return `RenderViewRef`
         */
        get: function () { return this._view.render; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "renderFragment", {
        /**
         * Return `RenderFragmentRef`
         */
        get: function () { return this._view.renderFragment; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "changeDetectorRef", {
        /**
         * Return `ChangeDetectorRef`
         */
        get: function () {
            if (this._changeDetectorRef === null) {
                this._changeDetectorRef = this._view.changeDetector.ref;
            }
            return this._changeDetectorRef;
        },
        enumerable: true,
        configurable: true
    });
    ViewRef_.prototype.setLocal = function (variableName, value) { this._view.setLocal(variableName, value); };
    return ViewRef_;
})(ViewRef);
exports.ViewRef_ = ViewRef_;
/**
 * Represents an Angular ProtoView.
 *
 * A ProtoView is a prototypical {@link ViewRef View} that is the result of Template compilation and
 * is used by Angular to efficiently create an instance of this View based on the compiled Template.
 *
 * Most ProtoViews are created and used internally by Angular and you don't need to know about them,
 * except in advanced use-cases where you compile components yourself via the low-level
 * {@link Compiler#compileInHost} API.
 *
 *
 * ## Example
 *
 * Given this template:
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ng-for="var item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * Angular desugars and compiles the template into two ProtoViews:
 *
 * Outer ProtoView:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ng-for var-item [ng-for-of]="items"></template>
 * </ul>
 * ```
 *
 * Inner ProtoView:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate ProtoViews.
 */
var ProtoViewRef = (function () {
    function ProtoViewRef() {
    }
    return ProtoViewRef;
})();
exports.ProtoViewRef = ProtoViewRef;
var ProtoViewRef_ = (function (_super) {
    __extends(ProtoViewRef_, _super);
    function ProtoViewRef_(_protoView) {
        _super.call(this);
        this._protoView = _protoView;
    }
    return ProtoViewRef_;
})(ProtoViewRef);
exports.ProtoViewRef_ = ProtoViewRef_;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var view_1 = require('../metadata/view');
var directives_1 = require('../metadata/directives');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var ViewResolver = (function () {
    function ViewResolver() {
        /** @internal */
        this._cache = new collection_1.Map();
    }
    ViewResolver.prototype.resolve = function (component) {
        var view = this._cache.get(component);
        if (lang_1.isBlank(view)) {
            view = this._resolve(component);
            this._cache.set(component, view);
        }
        return view;
    };
    /** @internal */
    ViewResolver.prototype._resolve = function (component) {
        var compMeta;
        var viewMeta;
        reflection_1.reflector.annotations(component).forEach(function (m) {
            if (m instanceof view_1.ViewMetadata) {
                viewMeta = m;
            }
            if (m instanceof directives_1.ComponentMetadata) {
                compMeta = m;
            }
        });
        if (lang_1.isPresent(compMeta)) {
            if (lang_1.isBlank(compMeta.template) && lang_1.isBlank(compMeta.templateUrl) && lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' must have either 'template', 'templateUrl', or '@View' set.");
            }
            else if (lang_1.isPresent(compMeta.template) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("template", component);
            }
            else if (lang_1.isPresent(compMeta.templateUrl) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("templateUrl", component);
            }
            else if (lang_1.isPresent(compMeta.directives) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("directives", component);
            }
            else if (lang_1.isPresent(compMeta.pipes) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("pipes", component);
            }
            else if (lang_1.isPresent(compMeta.encapsulation) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("encapsulation", component);
            }
            else if (lang_1.isPresent(compMeta.styles) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styles", component);
            }
            else if (lang_1.isPresent(compMeta.styleUrls) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styleUrls", component);
            }
            else if (lang_1.isPresent(viewMeta)) {
                return viewMeta;
            }
            else {
                return new view_1.ViewMetadata({
                    templateUrl: compMeta.templateUrl,
                    template: compMeta.template,
                    directives: compMeta.directives,
                    pipes: compMeta.pipes,
                    encapsulation: compMeta.encapsulation,
                    styles: compMeta.styles,
                    styleUrls: compMeta.styleUrls
                });
            }
        }
        else {
            if (lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("No View decorator found on component '" + lang_1.stringify(component) + "'");
            }
            else {
                return viewMeta;
            }
        }
        return null;
    };
    /** @internal */
    ViewResolver.prototype._throwMixingViewAndComponent = function (propertyName, component) {
        throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' cannot have both '" + propertyName + "' and '@View' set at the same time\"");
    };
    ViewResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], ViewResolver);
    return ViewResolver;
})();
exports.ViewResolver = ViewResolver;

},{"../metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","../metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js":[function(require,module,exports){
'use strict';/**
 * This indirection is needed to free up Component, etc symbols in the public API
 * to be used by the decorator versions of these annotations.
 */
var di_1 = require('./metadata/di');
exports.QueryMetadata = di_1.QueryMetadata;
exports.ContentChildrenMetadata = di_1.ContentChildrenMetadata;
exports.ContentChildMetadata = di_1.ContentChildMetadata;
exports.ViewChildrenMetadata = di_1.ViewChildrenMetadata;
exports.ViewQueryMetadata = di_1.ViewQueryMetadata;
exports.ViewChildMetadata = di_1.ViewChildMetadata;
exports.AttributeMetadata = di_1.AttributeMetadata;
var directives_1 = require('./metadata/directives');
exports.ComponentMetadata = directives_1.ComponentMetadata;
exports.DirectiveMetadata = directives_1.DirectiveMetadata;
exports.PipeMetadata = directives_1.PipeMetadata;
exports.InputMetadata = directives_1.InputMetadata;
exports.OutputMetadata = directives_1.OutputMetadata;
exports.HostBindingMetadata = directives_1.HostBindingMetadata;
exports.HostListenerMetadata = directives_1.HostListenerMetadata;
var view_1 = require('./metadata/view');
exports.ViewMetadata = view_1.ViewMetadata;
exports.ViewEncapsulation = view_1.ViewEncapsulation;
var di_2 = require('./metadata/di');
var directives_2 = require('./metadata/directives');
var view_2 = require('./metadata/view');
var decorators_1 = require('./util/decorators');
// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * For details on the `@View` annotation, see {@link ViewMetadata}.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the component.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!'
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 */
exports.Component = decorators_1.makeDecorator(directives_2.ComponentMetadata, function (fn) { return fn.View = exports.View; });
// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ## Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
 * `ng-if`, or an `ng-switch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ## Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the directive.
 *
 * ## Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
exports.Directive = decorators_1.makeDecorator(directives_2.DirectiveMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
exports.View = decorators_1.makeDecorator(view_2.ViewMetadata, function (fn) { return fn.View = exports.View; });
// TODO(alexeagle): remove the duplication of this doc. It is copied from AttributeMetadata.
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
exports.Attribute = decorators_1.makeParamDecorator(di_2.AttributeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ng-for="#pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <content></content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
 *     this.panes = panes;
 *   }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'foo' })
 * class seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'foo'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
exports.Query = decorators_1.makeParamDecorator(di_2.QueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   afterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
exports.ContentChildren = decorators_1.makePropDecorator(di_2.ContentChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   afterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
exports.ContentChild = decorators_1.makePropDecorator(di_2.ContentChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;
 *
 *   afterViewInit() {
 *     // viewChildren is set
 *   }
 * }
 * ```
 */
exports.ViewChildren = decorators_1.makePropDecorator(di_2.ViewChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChild(ItemDirective) viewChild:ItemDirective;
 *
 *   afterViewInit() {
 *     // viewChild is set
 *   }
 * }
 * ```
 */
exports.ViewChild = decorators_1.makePropDecorator(di_2.ViewChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({...})
 * @View({
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.onChange(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
exports.ViewQuery = decorators_1.makeParamDecorator(di_2.ViewQueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
/**
 * Declare reusable pipe function.
 *
 * ## Example
 *
 * ```
 * @Pipe({
 *   name: 'lowercase'
 * })
 * class Lowercase {
 *   transform(v, args) { return v.toLowerCase(); }
 * }
 * ```
 */
exports.Pipe = decorators_1.makeDecorator(directives_2.PipeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.Input = decorators_1.makePropDecorator(directives_2.InputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.next("event"), 1000);
 *     setInterval(() => this.five5Secs.next("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
exports.Output = decorators_1.makePropDecorator(directives_2.OutputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ng-model directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ng-model]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ng-model)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
exports.HostBinding = decorators_1.makePropDecorator(directives_2.HostBindingMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.HostListener = decorators_1.makePropDecorator(directives_2.HostListenerMetadata);

},{"./metadata/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js","./metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","./metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js","./util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/di/metadata');
/**
 * Specifies that a constant attribute value should be injected.
 *
 * The directive can inject constant string literals of host element attributes.
 *
 * ## Example
 *
 * Suppose we have an `<input>` element and want to know its `type`.
 *
 * ```html
 * <input type="text">
 * ```
 *
 * A decorator can inject string literal `text` like so:
 *
 * ```javascript
 * @Directive({
 *   selector: `input'
 * })
 * class InputDirective {
 *   constructor(@Attribute('type') type) {
 *     // type would be `text` in this example
 *   }
 * }
 * ```
 */
var AttributeMetadata = (function (_super) {
    __extends(AttributeMetadata, _super);
    function AttributeMetadata(attributeName) {
        _super.call(this);
        this.attributeName = attributeName;
    }
    Object.defineProperty(AttributeMetadata.prototype, "token", {
        get: function () {
            // Normally one would default a token to a type of an injected value but here
            // the type of a variable is "string" and we can't use primitive type as a return value
            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
            // account.
            return this;
        },
        enumerable: true,
        configurable: true
    });
    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
    AttributeMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], AttributeMetadata);
    return AttributeMetadata;
})(metadata_1.DependencyMetadata);
exports.AttributeMetadata = AttributeMetadata;
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ng-for="#pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <content></content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
  *    this.panes = panes;
  *  }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'foo' })
 * class seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'foo'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
var QueryMetadata = (function (_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        _super.call(this);
        this._selector = _selector;
        this.descendants = descendants;
        this.first = first;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
        /**
         * always `false` to differentiate it with {@link ViewQueryMetadata}.
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
        /**
         * what this is querying for.
         */
        get: function () { return di_1.resolveForwardRef(this._selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
        /**
         * whether this is querying for a variable binding or a directive.
         */
        get: function () { return lang_1.isString(this.selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
        /**
         * returns a list of variable bindings this is querying for.
         * Only applicable if this is a variable bindings query.
         */
        get: function () { return lang_1.StringWrapper.split(this.selector, new RegExp(",")); },
        enumerable: true,
        configurable: true
    });
    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
    QueryMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], QueryMetadata);
    return QueryMetadata;
})(metadata_1.DependencyMetadata);
exports.QueryMetadata = QueryMetadata;
// TODO: add an example after ContentChildren and ViewChildren are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   afterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
var ContentChildrenMetadata = (function (_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;
        _super.call(this, _selector, { descendants: descendants });
    }
    ContentChildrenMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], ContentChildrenMetadata);
    return ContentChildrenMetadata;
})(QueryMetadata);
exports.ContentChildrenMetadata = ContentChildrenMetadata;
// TODO: add an example after ContentChild and ViewChild are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   afterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
var ContentChildMetadata = (function (_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector) {
        _super.call(this, _selector, { descendants: true, first: true });
    }
    ContentChildMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ContentChildMetadata);
    return ContentChildMetadata;
})(QueryMetadata);
exports.ContentChildMetadata = ContentChildMetadata;
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({...})
 * @View({
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.onChange(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
var ViewQueryMetadata = (function (_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        _super.call(this, _selector, { descendants: descendants, first: first });
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
        /**
         * always `true` to differentiate it with {@link QueryMetadata}.
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
    ViewQueryMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], ViewQueryMetadata);
    return ViewQueryMetadata;
})(QueryMetadata);
exports.ViewQueryMetadata = ViewQueryMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;
 *
 *   afterViewInit() {
 *     // viewChildren is set
 *   }
 * }
 * ```
 */
var ViewChildrenMetadata = (function (_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector) {
        _super.call(this, _selector, { descendants: true });
    }
    ViewChildrenMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewChildrenMetadata);
    return ViewChildrenMetadata;
})(ViewQueryMetadata);
exports.ViewChildrenMetadata = ViewChildrenMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChild(ItemDirective) viewChild:ItemDirective;
 *
 *   afterViewInit() {
 *     // viewChild is set
 *   }
 * }
 * ```
 */
var ViewChildMetadata = (function (_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector) {
        _super.call(this, _selector, { descendants: true, first: true });
    }
    ViewChildMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewChildMetadata);
    return ViewChildMetadata;
})(ViewQueryMetadata);
exports.ViewChildMetadata = ViewChildMetadata;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/di/metadata');
var change_detection_1 = require('angular2/src/core/change_detection');
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ## Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
 * `ng-if`, or an `ng-switch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ## Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the directive.
 *
 * ## Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
var DirectiveMetadata = (function (_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, bindings = _b.bindings, providers = _b.providers, exportAs = _b.exportAs, moduleId = _b.moduleId, queries = _b.queries;
        _super.call(this);
        this.selector = selector;
        this._inputs = inputs;
        this._properties = properties;
        this._outputs = outputs;
        this._events = events;
        this.host = host;
        this.exportAs = exportAs;
        this.moduleId = moduleId;
        this.queries = queries;
        this._providers = providers;
        this._bindings = bindings;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
        /**
         * Enumerates the set of data-bound input properties for a directive
         *
         * Angular automatically updates input properties during change detection.
         *
         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property where the value is written.
         * - `bindingProperty` specifies the DOM property where the value is read from.
         *
         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
         *
         * The following example creates a component with two data-bound properties.
         *
         * ```typescript
         * @Component({
         *   selector: 'bank-account',
         *   inputs: ['bankName', 'id: account-id'],
         *   template: `
         *     Bank Name: {{bankName}}
         *     Account Id: {{id}}
         *   `
         * })
         * class BankAccount {
         *   bankName: string;
         *   id: string;
         *
         *   // this property is not bound, and won't be automatically updated by Angular
         *   normalizedBankName: string;
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
         *   `,
         *   directives: [BankAccount]
         * })
         * class App {}
         *
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :
                this._inputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
        get: function () { return this.inputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
        /**
         * Enumerates the set of event-bound output properties.
         *
         * When an output property emits an event, an event handler attached to that event
         * the template is invoked.
         *
         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property that emits events.
         * - `bindingProperty` specifies the DOM property the event handler is attached to.
         *
         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
         *
         * ```typescript
         * @Directive({
         *   selector: 'interval-dir',
         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
         * })
         * class IntervalDir {
         *   everySecond = new EventEmitter();
         *   five5Secs = new EventEmitter();
         *
         *   constructor() {
         *     setInterval(() => this.everySecond.next("event"), 1000);
         *     setInterval(() => this.five5Secs.next("event"), 5000);
         *   }
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
         *     </interval-dir>
         *   `,
         *   directives: [IntervalDir]
         * })
         * class App {
         *   everySecond() { console.log('second'); }
         *   everyFiveSeconds() { console.log('five seconds'); }
         * }
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "events", {
        get: function () { return this.outputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
        /**
         * Defines the set of injectable objects that are visible to a Directive and its light DOM
         * children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'greet',
         *   bindings: [
         *     Greeter
         *   ]
         * })
         * class HelloWorld {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._bindings) && this._bindings.length > 0 ? this._bindings :
                this._providers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "bindings", {
        /** @deprecated */
        get: function () { return this.providers; },
        enumerable: true,
        configurable: true
    });
    DirectiveMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], DirectiveMetadata);
    return DirectiveMetadata;
})(metadata_1.InjectableMetadata);
exports.DirectiveMetadata = DirectiveMetadata;
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * For details on the `@View` annotation, see {@link ViewMetadata}.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the component.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!'
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 */
var ComponentMetadata = (function (_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, bindings = _b.bindings, providers = _b.providers, viewBindings = _b.viewBindings, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? change_detection_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation;
        _super.call(this, {
            selector: selector,
            inputs: inputs,
            outputs: outputs,
            properties: properties,
            events: events,
            host: host,
            exportAs: exportAs,
            moduleId: moduleId,
            bindings: bindings,
            providers: providers,
            queries: queries
        });
        this.changeDetection = changeDetection;
        this._viewProviders = viewProviders;
        this._viewBindings = viewBindings;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
        /**
         * Defines the set of injectable objects that are visible to its view DOM children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'needs-greeter'
         * })
         * class NeedsGreeter {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         *
         * @Component({
         *   selector: 'greet',
         *   viewProviders: [
         *     Greeter
         *   ],
         *   template: `<needs-greeter></needs-greeter>`,
         *   directives: [NeedsGreeter]
         * })
         * class HelloWorld {
         * }
         *
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._viewBindings) && this._viewBindings.length > 0 ? this._viewBindings :
                this._viewProviders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentMetadata.prototype, "viewBindings", {
        get: function () { return this.viewProviders; },
        enumerable: true,
        configurable: true
    });
    ComponentMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ComponentMetadata);
    return ComponentMetadata;
})(DirectiveMetadata);
exports.ComponentMetadata = ComponentMetadata;
/**
 * Declare reusable pipe function.
 *
 * ## Example
 *
 * ```
 * @Pipe({
 *   name: 'lowercase'
 * })
 * class Lowercase {
 *   transform(v, args) { return v.toLowerCase(); }
 * }
 * ```
 */
var PipeMetadata = (function (_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
        var name = _a.name, pure = _a.pure;
        _super.call(this);
        this.name = name;
        this._pure = pure;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
        enumerable: true,
        configurable: true
    });
    PipeMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], PipeMetadata);
    return PipeMetadata;
})(metadata_1.InjectableMetadata);
exports.PipeMetadata = PipeMetadata;
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var InputMetadata = (function () {
    function InputMetadata(
        /**
         * Name used when instantiating a component in the temlate.
         */
        bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    InputMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], InputMetadata);
    return InputMetadata;
})();
exports.InputMetadata = InputMetadata;
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.next("event"), 1000);
 *     setInterval(() => this.five5Secs.next("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
var OutputMetadata = (function () {
    function OutputMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    OutputMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], OutputMetadata);
    return OutputMetadata;
})();
exports.OutputMetadata = OutputMetadata;
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ng-model directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ng-model]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ng-model)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
var HostBindingMetadata = (function () {
    function HostBindingMetadata(hostPropertyName) {
        this.hostPropertyName = hostPropertyName;
    }
    HostBindingMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], HostBindingMetadata);
    return HostBindingMetadata;
})();
exports.HostBindingMetadata = HostBindingMetadata;
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var HostListenerMetadata = (function () {
    function HostListenerMetadata(eventName, args) {
        this.eventName = eventName;
        this.args = args;
    }
    HostListenerMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String, Array])
    ], HostListenerMetadata);
    return HostListenerMetadata;
})();
exports.HostListenerMetadata = HostListenerMetadata;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Defines template and style encapsulation options available for Component's {@link View}.
 *
 * See {@link ViewMetadata#encapsulation}.
 */
(function (ViewEncapsulation) {
    /**
     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
     * Element and pre-processing the style rules provided via
     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
     * attribute to all selectors.
     *
     * This is the default option.
     */
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    /**
     * Use the native encapsulation mechanism of the renderer.
     *
     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
     * creating a ShadowRoot for Component's Host Element.
     */
    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
    /**
     * Don't provide any template or style encapsulation.
     */
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
var ViewEncapsulation = exports.ViewEncapsulation;
exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
var ViewMetadata = (function () {
    function ViewMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
    }
    ViewMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewMetadata);
    return ViewMetadata;
})();
exports.ViewMetadata = ViewMetadata;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module provides a set of common Pipes.
 */
var async_pipe_1 = require('./pipes/async_pipe');
exports.AsyncPipe = async_pipe_1.AsyncPipe;
var date_pipe_1 = require('./pipes/date_pipe');
exports.DatePipe = date_pipe_1.DatePipe;
var default_pipes_1 = require('./pipes/default_pipes');
exports.DEFAULT_PIPES = default_pipes_1.DEFAULT_PIPES;
exports.DEFAULT_PIPES_TOKEN = default_pipes_1.DEFAULT_PIPES_TOKEN;
var json_pipe_1 = require('./pipes/json_pipe');
exports.JsonPipe = json_pipe_1.JsonPipe;
var slice_pipe_1 = require('./pipes/slice_pipe');
exports.SlicePipe = slice_pipe_1.SlicePipe;
var lowercase_pipe_1 = require('./pipes/lowercase_pipe');
exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
var number_pipe_1 = require('./pipes/number_pipe');
exports.NumberPipe = number_pipe_1.NumberPipe;
exports.DecimalPipe = number_pipe_1.DecimalPipe;
exports.PercentPipe = number_pipe_1.PercentPipe;
exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
var uppercase_pipe_1 = require('./pipes/uppercase_pipe');
exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;

},{"./pipes/async_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js","./pipes/date_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js","./pipes/default_pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/default_pipes.js","./pipes/json_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js","./pipes/lowercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js","./pipes/number_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js","./pipes/slice_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js","./pipes/uppercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var change_detection_1 = require('angular2/src/core/change_detection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var ObservableStrategy = (function () {
    function ObservableStrategy() {
    }
    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async_1.ObservableWrapper.subscribe(async, updateLatestValue, function (e) { throw e; });
    };
    ObservableStrategy.prototype.dispose = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    ObservableStrategy.prototype.onDestroy = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    return ObservableStrategy;
})();
var PromiseStrategy = (function () {
    function PromiseStrategy() {
    }
    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.then(updateLatestValue);
    };
    PromiseStrategy.prototype.dispose = function (subscription) { };
    PromiseStrategy.prototype.onDestroy = function (subscription) { };
    return PromiseStrategy;
})();
var _promiseStrategy = new PromiseStrategy();
var _observableStrategy = new ObservableStrategy();
/**
 * The `async` pipe subscribes to an Observable or Promise and returns the latest value it has
 * emitted.
 * When a new value is emitted, the `async` pipe marks the component to be checked for changes.
 *
 * # Example
 * The example below binds the `time` Observable to the view. Every 500ms, the `time` Observable
 * updates the view with the current time.
 *
 * ```
 * import {Observable} from 'angular2/core';
 * @Component({
 *   selector: "task-cmp",
 *   template: "Time: {{ time | async }}"
 * })
 * class Task {
 *   time = new Observable<number>(observer => {
 *     setInterval(_ =>
 *       observer.next(new Date().getTime()), 500);
 *   });
 * }
 * ```
 */
var AsyncPipe = (function () {
    function AsyncPipe(_ref) {
        /** @internal */
        this._latestValue = null;
        /** @internal */
        this._latestReturnedValue = null;
        /** @internal */
        this._subscription = null;
        /** @internal */
        this._obj = null;
        this._strategy = null;
        this._ref = _ref;
    }
    AsyncPipe.prototype.onDestroy = function () {
        if (lang_1.isPresent(this._subscription)) {
            this._dispose();
        }
    };
    AsyncPipe.prototype.transform = function (obj, args) {
        if (lang_1.isBlank(this._obj)) {
            if (lang_1.isPresent(obj)) {
                this._subscribe(obj);
            }
            return null;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform(obj);
        }
        if (this._latestValue === this._latestReturnedValue) {
            return this._latestReturnedValue;
        }
        else {
            this._latestReturnedValue = this._latestValue;
            return change_detection_1.WrappedValue.wrap(this._latestValue);
        }
    };
    /** @internal */
    AsyncPipe.prototype._subscribe = function (obj) {
        var _this = this;
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription =
            this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
    };
    /** @internal */
    AsyncPipe.prototype._selectStrategy = function (obj) {
        if (lang_1.isPromise(obj)) {
            return _promiseStrategy;
        }
        else if (async_1.ObservableWrapper.isObservable(obj)) {
            return _observableStrategy;
        }
        else {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
        }
    };
    /** @internal */
    AsyncPipe.prototype._dispose = function () {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    };
    /** @internal */
    AsyncPipe.prototype._updateLatestValue = function (async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    };
    AsyncPipe = __decorate([
        metadata_1.Pipe({ name: 'async', pure: false }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorRef])
    ], AsyncPipe);
    return AsyncPipe;
})();
exports.AsyncPipe = AsyncPipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var intl_1 = require('angular2/src/core/facade/intl');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var collection_1 = require('angular2/src/core/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
// TODO: move to a global configurable location along with other i18n components.
var defaultLocale = 'en-US';
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a date value to a string based on the requested format.
 *
 * # Usage
 *
 *     expression | date[:format]
 *
 * where `expression` is a date object or a number (milliseconds since UTC epoch) and
 * `format` indicates which date/time components to include:
 *
 *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
 *  |-----------|:------:|--------------|-------------------|-----------|-----------|
 *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
 *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
 *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
 *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
 *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
 *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
 *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
 *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
 *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
 *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
 *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
 *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
 *
 * In javascript, only the components specified will be respected (not the ordering,
 * punctuations, ...) and details of the formatting will be dependent on the locale.
 * On the other hand in Dart version, you can also include quoted text as well as some extra
 * date/time components such as quarter. For more information see:
 * https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/intl/intl.DateFormat.
 *
 * `format` can also be one of the following predefined formats:
 *
 *  - `'medium'`: equivalent to `'yMMMdjms'` (e.g. Sep 3, 2010, 12:05:08 PM for en-US)
 *  - `'short'`: equivalent to `'yMdjm'` (e.g. 9/3/2010, 12:05 PM for en-US)
 *  - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. Friday, September 3, 2010 for en-US)
 *  - `'longDate'`: equivalent to `'yMMMMd'` (e.g. September 3, 2010)
 *  - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. Sep 3, 2010 for en-US)
 *  - `'shortDate'`: equivalent to `'yMd'` (e.g. 9/3/2010 for en-US)
 *  - `'mediumTime'`: equivalent to `'jms'` (e.g. 12:05:08 PM for en-US)
 *  - `'shortTime'`: equivalent to `'jm'` (e.g. 12:05 PM for en-US)
 *
 * Timezone of the formatted text will be the local system timezone of the end-users machine.
 *
 * # Examples
 *
 * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
 * in the _local_ time and locale is 'en-US':
 *
 *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
 *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
 *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
 *     {{ dateObj | date:'mmss' }}        // output is '43:11'
 */
var DatePipe = (function () {
    function DatePipe() {
    }
    DatePipe.prototype.transform = function (value, args) {
        if (lang_1.isBlank(value))
            return null;
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
        }
        var pattern = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';
        if (lang_1.isNumber(value)) {
            value = lang_1.DateWrapper.fromMillis(value);
        }
        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
        }
        return intl_1.DateFormatter.format(value, defaultLocale, pattern);
    };
    DatePipe.prototype.supports = function (obj) { return lang_1.isDate(obj) || lang_1.isNumber(obj); };
    DatePipe._ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
    };
    DatePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'date' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DatePipe);
    return DatePipe;
})();
exports.DatePipe = DatePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/intl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/default_pipes.js":[function(require,module,exports){
'use strict';var async_pipe_1 = require('./async_pipe');
var uppercase_pipe_1 = require('./uppercase_pipe');
var lowercase_pipe_1 = require('./lowercase_pipe');
var json_pipe_1 = require('./json_pipe');
var slice_pipe_1 = require('./slice_pipe');
var date_pipe_1 = require('./date_pipe');
var number_pipe_1 = require('./number_pipe');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var DEFAULT_PIPES_LIST = lang_1.CONST_EXPR([
    async_pipe_1.AsyncPipe,
    uppercase_pipe_1.UpperCasePipe,
    lowercase_pipe_1.LowerCasePipe,
    json_pipe_1.JsonPipe,
    slice_pipe_1.SlicePipe,
    number_pipe_1.DecimalPipe,
    number_pipe_1.PercentPipe,
    number_pipe_1.CurrencyPipe,
    date_pipe_1.DatePipe
]);
exports.DEFAULT_PIPES_TOKEN = lang_1.CONST_EXPR(new di_1.OpaqueToken("Default Pipes"));
exports.DEFAULT_PIPES = lang_1.CONST_EXPR(new di_1.Provider(exports.DEFAULT_PIPES_TOKEN, { useValue: DEFAULT_PIPES_LIST }));

},{"./async_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js","./date_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js","./json_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js","./lowercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js","./number_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js","./slice_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js","./uppercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var InvalidPipeArgumentException = (function (_super) {
    __extends(InvalidPipeArgumentException, _super);
    function InvalidPipeArgumentException(type, value) {
        _super.call(this, "Invalid argument '" + value + "' for pipe '" + type + "'");
    }
    return InvalidPipeArgumentException;
})(exceptions_1.BaseException);
exports.InvalidPipeArgumentException = InvalidPipeArgumentException;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
/**
 * Implements json transforms to any object.
 *
 * # Example
 *
 * In this example we transform the user object to json.
 *
 *  ```
 * @Component({
 *   selector: "user-cmp",
 *   template: "User: {{ user | json }}"
 * })
 * class Username {
 *  user:Object
 *  constructor() {
 *    this.user = { name: "PatrickJS" };
 *  }
 * }
 *
 * ```
 */
var JsonPipe = (function () {
    function JsonPipe() {
    }
    JsonPipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        return lang_1.Json.stringify(value);
    };
    JsonPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'json' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], JsonPipe);
    return JsonPipe;
})();
exports.JsonPipe = JsonPipe;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
/**
 * Implements lowercase transforms to text.
 *
 * # Example
 *
 * In this example we transform the user text lowercase.
 *
 *  ```
 * @Component({
 *   selector: "username-cmp",
 *   template: "Username: {{ user | lowercase }}"
 * })
 * class Username {
 *   user:string;
 * }
 *
 * ```
 */
var LowerCasePipe = (function () {
    function LowerCasePipe() {
    }
    LowerCasePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
        }
        return lang_1.StringWrapper.toLowerCase(value);
    };
    LowerCasePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'lowercase' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], LowerCasePipe);
    return LowerCasePipe;
})();
exports.LowerCasePipe = LowerCasePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var intl_1 = require('angular2/src/core/facade/intl');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var collection_1 = require('angular2/src/core/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var defaultLocale = 'en-US';
var _re = lang_1.RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
var NumberPipe = (function () {
    function NumberPipe() {
    }
    NumberPipe._format = function (value, style, digits, currency, currencyAsSymbol) {
        if (currency === void 0) { currency = null; }
        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
        if (lang_1.isBlank(value))
            return null;
        if (!lang_1.isNumber(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(NumberPipe, value);
        }
        var minInt = 1, minFraction = 0, maxFraction = 3;
        if (lang_1.isPresent(digits)) {
            var parts = lang_1.RegExpWrapper.firstMatch(_re, digits);
            if (lang_1.isBlank(parts)) {
                throw new exceptions_1.BaseException(digits + " is not a valid digit info for number pipes");
            }
            if (lang_1.isPresent(parts[1])) {
                minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (lang_1.isPresent(parts[3])) {
                minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (lang_1.isPresent(parts[5])) {
                maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        return intl_1.NumberFormatter.format(value, defaultLocale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol
        });
    };
    NumberPipe = __decorate([
        lang_1.CONST(),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], NumberPipe);
    return NumberPipe;
})();
exports.NumberPipe = NumberPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local text. i.e. group sizing and separator and other locale-specific
 * configurations are based on the active locale.
 *
 * # Usage
 *
 *     expression | number[:digitInfo]
 *
 * where `expression` is a number and `digitInfo` has the following format:
 *
 *     {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
 *
 * - minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.
 * - minFractionDigits is the minimum number of digits after fraction. Defaults to 0.
 * - maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.
 *
 * For more information on the acceptable range for each of these numbers and other
 * details see your native internationalization library.
 *
 * # Examples
 *
 *     {{ 123 | number }}              // output is 123
 *     {{ 123.1 | number: '.2-3' }}    // output is 123.10
 *     {{ 1 | number: '2.2' }}         // output is 01.00
 */
var DecimalPipe = (function (_super) {
    __extends(DecimalPipe, _super);
    function DecimalPipe() {
        _super.apply(this, arguments);
    }
    DecimalPipe.prototype.transform = function (value, args) {
        var digits = collection_1.ListWrapper.first(args);
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Decimal, digits);
    };
    DecimalPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'number' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DecimalPipe);
    return DecimalPipe;
})(NumberPipe);
exports.DecimalPipe = DecimalPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local percent.
 *
 * # Usage
 *
 *     expression | percent[:digitInfo]
 *
 * For more information about `digitInfo` see {@link DecimalPipe}
 */
var PercentPipe = (function (_super) {
    __extends(PercentPipe, _super);
    function PercentPipe() {
        _super.apply(this, arguments);
    }
    PercentPipe.prototype.transform = function (value, args) {
        var digits = collection_1.ListWrapper.first(args);
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Percent, digits);
    };
    PercentPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'percent' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PercentPipe);
    return PercentPipe;
})(NumberPipe);
exports.PercentPipe = PercentPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local currency.
 *
 * # Usage
 *
 *     expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
 *
 * where `currencyCode` is the ISO 4217 currency code, such as "USD" for the US dollar and
 * "EUR" for the euro. `symbolDisplay` is a boolean indicating whether to use the currency
 * symbol (e.g. $) or the currency code (e.g. USD) in the output. The default for this value
 * is `false`.
 * For more information about `digitInfo` see {@link DecimalPipe}
 */
var CurrencyPipe = (function (_super) {
    __extends(CurrencyPipe, _super);
    function CurrencyPipe() {
        _super.apply(this, arguments);
    }
    CurrencyPipe.prototype.transform = function (value, args) {
        var currencyCode = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'USD';
        var symbolDisplay = lang_1.isPresent(args) && args.length > 1 ? args[1] : false;
        var digits = lang_1.isPresent(args) && args.length > 2 ? args[2] : null;
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    CurrencyPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'currency' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], CurrencyPipe);
    return CurrencyPipe;
})(NumberPipe);
exports.CurrencyPipe = CurrencyPipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/intl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var provider_1 = require('angular2/src/core/di/provider');
var di_1 = require('angular2/src/core/di');
var PipeProvider = (function (_super) {
    __extends(PipeProvider, _super);
    function PipeProvider(name, pure, key, resolvedFactories, multiBinding) {
        _super.call(this, key, resolvedFactories, multiBinding);
        this.name = name;
        this.pure = pure;
    }
    PipeProvider.createFromType = function (type, metadata) {
        var provider = new di_1.Provider(type, { useClass: type });
        var rb = provider_1.resolveProvider(provider);
        return new PipeProvider(metadata.name, metadata.pure, rb.key, rb.resolvedFactories, rb.multiProvider);
    };
    return PipeProvider;
})(provider_1.ResolvedProvider_);
exports.PipeProvider = PipeProvider;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var cd = require('angular2/src/core/change_detection/pipes');
var ProtoPipes = (function () {
    function ProtoPipes(
        /**
        * Map of {@link PipeMetadata} names to {@link PipeMetadata} implementations.
        */
        config) {
        this.config = config;
        this.config = config;
    }
    ProtoPipes.fromProviders = function (providers) {
        var config = {};
        providers.forEach(function (b) { return config[b.name] = b; });
        return new ProtoPipes(config);
    };
    ProtoPipes.prototype.get = function (name) {
        var provider = this.config[name];
        if (lang_1.isBlank(provider))
            throw new exceptions_1.BaseException("Cannot find pipe '" + name + "'.");
        return provider;
    };
    return ProtoPipes;
})();
exports.ProtoPipes = ProtoPipes;
var Pipes = (function () {
    function Pipes(proto, injector) {
        this.proto = proto;
        this.injector = injector;
        /** @internal */
        this._config = {};
    }
    Pipes.prototype.get = function (name) {
        var cached = collection_1.StringMapWrapper.get(this._config, name);
        if (lang_1.isPresent(cached))
            return cached;
        var p = this.proto.get(name);
        var transform = this.injector.instantiateResolved(p);
        var res = new cd.SelectedPipe(transform, p.pure);
        if (p.pure) {
            collection_1.StringMapWrapper.set(this._config, name, res);
        }
        return res;
    };
    return Pipes;
})();
exports.Pipes = Pipes;

},{"angular2/src/core/change_detection/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipes.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var metadata_1 = require('../metadata');
/**
 * Creates a new List or String containing only a subset (slice) of the
 * elements.
 *
 * The starting index of the subset to return is specified by the `start` parameter.
 *
 * The ending index of the subset to return is specified by the optional `end` parameter.
 *
 * # Usage
 *
 *     expression | slice:start[:end]
 *
 * All behavior is based on the expected behavior of the JavaScript API
 * Array.prototype.slice() and String.prototype.slice()
 *
 * Where the input expression is a [List] or [String], and `start` is:
 *
 * - **a positive integer**: return the item at _start_ index and all items after
 * in the list or string expression.
 * - **a negative integer**: return the item at _start_ index from the end and all items after
 * in the list or string expression.
 * - **`|start|` greater than the size of the expression**: return an empty list or string.
 * - **`|start|` negative greater than the size of the expression**: return entire list or
 * string expression.
 *
 * and where `end` is:
 *
 * - **omitted**: return all items until the end of the input
 * - **a positive integer**: return all items before _end_ index of the list or string
 * expression.
 * - **a negative integer**: return all items before _end_ index from the end of the list
 * or string expression.
 *
 * When operating on a [List], the returned list is always a copy even when all
 * the elements are being returned.
 *
 * # Examples
 *
 * ## List Example
 *
 * Assuming `var collection = ['a', 'b', 'c', 'd']`, this `ng-for` directive:
 *
 *     <li *ng-for="var i in collection | slice:1:3">{{i}}</li>
 *
 * produces the following:
 *
 *     <li>b</li>
 *     <li>c</li>
 *
 * ## String Examples
 *
 *     {{ 'abcdefghij' | slice:0:4 }}       // output is 'abcd'
 *     {{ 'abcdefghij' | slice:4:0 }}       // output is ''
 *     {{ 'abcdefghij' | slice:-4 }}      // output is 'ghij'
 *     {{ 'abcdefghij' | slice:-4,-2 }}      // output is 'gh'
 *     {{ 'abcdefghij' | slice: -100 }}    // output is 'abcdefghij'
 *     {{ 'abcdefghij' | slice: 100 }}    // output is ''
 */
var SlicePipe = (function () {
    function SlicePipe() {
    }
    SlicePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(args) || args.length == 0) {
            throw new exceptions_1.BaseException('Slice pipe requires one argument');
        }
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);
        }
        if (lang_1.isBlank(value))
            return value;
        var start = args[0];
        var end = args.length > 1 ? args[1] : null;
        if (lang_1.isString(value)) {
            return lang_1.StringWrapper.slice(value, start, end);
        }
        return collection_1.ListWrapper.slice(value, start, end);
    };
    SlicePipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };
    SlicePipe = __decorate([
        metadata_1.Pipe({ name: 'slice' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], SlicePipe);
    return SlicePipe;
})();
exports.SlicePipe = SlicePipe;

},{"../metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
/**
 * Implements uppercase transforms to text.
 *
 * # Example
 *
 * In this example we transform the user text uppercase.
 *
 *  ```
 * @Component({
 *   selector: "username-cmp",
 *   template: "Username: {{ user | uppercase }}"
 * })
 * class Username {
 *   user:string;
 * }
 *
 * ```
 */
var UpperCasePipe = (function () {
    function UpperCasePipe() {
    }
    UpperCasePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
        }
        return lang_1.StringWrapper.toUpperCase(value);
    };
    UpperCasePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'uppercase' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], UpperCasePipe);
    return UpperCasePipe;
})();
exports.UpperCasePipe = UpperCasePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/platform_bindings.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
exports.EXCEPTION_PROVIDER = di_1.provide(exceptions_1.ExceptionHandler, { useFactory: function () { return new exceptions_1.ExceptionHandler(dom_adapter_1.DOM, false); }, deps: [] });
exports.EXCEPTION_BINDING = exports.EXCEPTION_PROVIDER;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js":[function(require,module,exports){
'use strict';var impl = require("./wtf_impl");
// Change exports to const once https://github.com/angular/ts2dart/issues/150
/**
 * True if WTF is enabled.
 */
exports.wtfEnabled = impl.detectWTF();
function noopScope(arg0, arg1) {
    return null;
}
/**
 * Create trace scope.
 *
 * Scopes must be strictly nested and are analogous to stack frames, but
 * do not have to follow the stack frames. Instead it is recommended that they follow logical
 * nesting. You may want to use
 * [Event
 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
 * as they are defined in WTF.
 *
 * Used to mark scope entry. The return value is used to leave the scope.
 *
 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
 *
 *     someMethod() {
 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
 *        // DO SOME WORK HERE
 *        return wtfLeave(s, 123); // Return value 123
 *     }
 *
 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
 * negatively impact the performance of your application. For this reason we recommend that
 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
 * exception, will produce incorrect trace, but presence of exception signifies logic error which
 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
 * an exception is expected during normal execution while profiling.
 *
 */
exports.wtfCreateScope = exports.wtfEnabled ? impl.createScope : function (signature, flags) { return noopScope; };
/**
 * Used to mark end of Scope.
 *
 * - `scope` to end.
 * - `returnValue` (optional) to be passed to the WTF.
 *
 * Returns the `returnValue for easy chaining.
 */
exports.wtfLeave = exports.wtfEnabled ? impl.leave : function (s, r) { return r; };
/**
 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
 * enabled.
 *
 *     someMethod() {
 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
 *        var future = new Future.delay(5).then((_) {
 *          wtfEndTimeRange(s);
 *        });
 *     }
 */
exports.wtfStartTimeRange = exports.wtfEnabled ? impl.startTimeRange : function (rangeType, action) { return null; };
/**
 * Ends a async time range operation.
 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
 * enabled.
 */
exports.wtfEndTimeRange = exports.wtfEnabled ? impl.endTimeRange : function (r) {
    return null;
};

},{"./wtf_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_impl.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_impl.js":[function(require,module,exports){
'use strict';var lang_1 = require('../facade/lang');
var trace;
var events;
function detectWTF() {
    var wtf = lang_1.global['wtf'];
    if (wtf) {
        trace = wtf['trace'];
        if (trace) {
            events = trace['events'];
            return true;
        }
    }
    return false;
}
exports.detectWTF = detectWTF;
function createScope(signature, flags) {
    if (flags === void 0) { flags = null; }
    return events.createScope(signature, flags);
}
exports.createScope = createScope;
function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
}
exports.leave = leave;
function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
}
exports.startTimeRange = startTimeRange;
function endTimeRange(range) {
    trace.endTimeRange(range);
}
exports.endTimeRange = endTimeRange;

},{"../facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_init.js":[function(require,module,exports){
'use strict';/**
 * This is here because DART requires it. It is noop in JS.
 */
function wtfInit() { }
exports.wtfInit = wtfInit;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js":[function(require,module,exports){
'use strict';var reflector_1 = require('./reflector');
var reflector_2 = require('./reflector');
exports.Reflector = reflector_2.Reflector;
exports.ReflectionInfo = reflector_2.ReflectionInfo;
var reflection_capabilities_1 = require('./reflection_capabilities');
exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());

},{"./reflection_capabilities":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection_capabilities.js","./reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflector.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection_capabilities.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ReflectionCapabilities = (function () {
    function ReflectionCapabilities(reflect) {
        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
    ReflectionCapabilities.prototype.factory = function (t) {
        switch (t.length) {
            case 0:
                return function () { return new t(); };
            case 1:
                return function (a1) { return new t(a1); };
            case 2:
                return function (a1, a2) { return new t(a1, a2); };
            case 3:
                return function (a1, a2, a3) { return new t(a1, a2, a3); };
            case 4:
                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) { return new t(a1, a2, a3, a4, a5, a6); };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) { return new t(a1, a2, a3, a4, a5, a6, a7); };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return new t(a1, a2, a3, a4, a5, a6, a7, a8); };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9); };
            case 10:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                };
            case 11:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                };
            case 12:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                };
            case 13:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                };
            case 14:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                };
            case 15:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                };
            case 16:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                };
            case 17:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                };
            case 18:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
                };
            case 19:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                };
            case 20:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                };
        }
        ;
        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
    };
    /** @internal */
    ReflectionCapabilities.prototype._zipTypesAndAnnotaions = function (paramTypes, paramAnnotations) {
        var result;
        if (typeof paramTypes === 'undefined') {
            result = collection_1.ListWrapper.createFixedSize(paramAnnotations.length);
        }
        else {
            result = collection_1.ListWrapper.createFixedSize(paramTypes.length);
        }
        for (var i = 0; i < result.length; i++) {
            // TS outputs Object for parameters without types, while Traceur omits
            // the annotations. For now we preserve the Traceur behavior to aid
            // migration, but this can be revisited.
            if (typeof paramTypes === 'undefined') {
                result[i] = [];
            }
            else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
            }
            else {
                result[i] = [];
            }
            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
            }
        }
        return result;
    };
    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.parameters)) {
            return typeOrFunc.parameters;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
            }
        }
        return collection_1.ListWrapper.createFixedSize(typeOrFunc.length);
    };
    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.annotations)) {
            var annotations = typeOrFunc.annotations;
            if (lang_1.isFunction(annotations) && annotations.annotations) {
                annotations = annotations.annotations;
            }
            return annotations;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
            if (lang_1.isPresent(annotations))
                return annotations;
        }
        return [];
    };
    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
            var propMetadata = typeOrFunc.propMetadata;
            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
                propMetadata = propMetadata.propMetadata;
            }
            return propMetadata;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
            if (lang_1.isPresent(propMetadata))
                return propMetadata;
        }
        return {};
    };
    ReflectionCapabilities.prototype.interfaces = function (type) {
        throw new exceptions_1.BaseException("JavaScript does not support interfaces");
    };
    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
    ReflectionCapabilities.prototype.setter = function (name) {
        return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function (name) {
        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
        return new Function('o', 'args', functionBody);
    };
    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
    ReflectionCapabilities.prototype.importUri = function (type) { return './'; };
    return ReflectionCapabilities;
})();
exports.ReflectionCapabilities = ReflectionCapabilities;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ReflectionInfo = (function () {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
        this.annotations = annotations;
        this.parameters = parameters;
        this.factory = factory;
        this.interfaces = interfaces;
        this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
})();
exports.ReflectionInfo = ReflectionInfo;
var Reflector = (function () {
    function Reflector(reflectionCapabilities) {
        /** @internal */
        this._injectableInfo = new collection_1.Map();
        /** @internal */
        this._getters = new collection_1.Map();
        /** @internal */
        this._setters = new collection_1.Map();
        /** @internal */
        this._methods = new collection_1.Map();
        this._usedKeys = null;
        this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
    /**
     * Causes `this` reflector to track keys used to access
     * {@link ReflectionInfo} objects.
     */
    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
    /**
     * Lists types for which reflection information was not requested since
     * {@link #trackUsage} was called. This list could later be audited as
     * potential dead code.
     */
    Reflector.prototype.listUnusedKeys = function () {
        var _this = this;
        if (this._usedKeys == null) {
            throw new exceptions_1.BaseException('Usage tracking is disabled');
        }
        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
        return collection_1.ListWrapper.filter(allTypes, function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
    };
    Reflector.prototype.registerFunction = function (func, funcInfo) {
        this._injectableInfo.set(func, funcInfo);
    };
    Reflector.prototype.registerType = function (type, typeInfo) {
        this._injectableInfo.set(type, typeInfo);
    };
    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
    Reflector.prototype.factory = function (type) {
        if (this._containsReflectionInfo(type)) {
            var res = this._getReflectionInfo(type).factory;
            return lang_1.isPresent(res) ? res : null;
        }
        else {
            return this.reflectionCapabilities.factory(type);
        }
    };
    Reflector.prototype.parameters = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).parameters;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.parameters(typeOrFunc);
        }
    };
    Reflector.prototype.annotations = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).annotations;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.annotations(typeOrFunc);
        }
    };
    Reflector.prototype.propMetadata = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
            return lang_1.isPresent(res) ? res : {};
        }
        else {
            return this.reflectionCapabilities.propMetadata(typeOrFunc);
        }
    };
    Reflector.prototype.interfaces = function (type) {
        if (this._injectableInfo.has(type)) {
            var res = this._getReflectionInfo(type).interfaces;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.interfaces(type);
        }
    };
    Reflector.prototype.getter = function (name) {
        if (this._getters.has(name)) {
            return this._getters.get(name);
        }
        else {
            return this.reflectionCapabilities.getter(name);
        }
    };
    Reflector.prototype.setter = function (name) {
        if (this._setters.has(name)) {
            return this._setters.get(name);
        }
        else {
            return this.reflectionCapabilities.setter(name);
        }
    };
    Reflector.prototype.method = function (name) {
        if (this._methods.has(name)) {
            return this._methods.get(name);
        }
        else {
            return this.reflectionCapabilities.method(name);
        }
    };
    /** @internal */
    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
        if (lang_1.isPresent(this._usedKeys)) {
            this._usedKeys.add(typeOrFunc);
        }
        return this._injectableInfo.get(typeOrFunc);
    };
    /** @internal */
    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
    return Reflector;
})();
exports.Reflector = Reflector;
function _mergeMaps(target, config) {
    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
}

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js":[function(require,module,exports){
'use strict';// Public API for render
var render_1 = require('./render/render');
exports.Renderer = render_1.Renderer;
exports.RenderViewRef = render_1.RenderViewRef;
exports.RenderProtoViewRef = render_1.RenderProtoViewRef;
exports.RenderFragmentRef = render_1.RenderFragmentRef;
exports.RenderViewWithFragments = render_1.RenderViewWithFragments;
exports.DOCUMENT = render_1.DOCUMENT;

},{"./render/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js":[function(require,module,exports){
'use strict';/**
 * Represents an Angular ProtoView in the Rendering Context.
 *
 * When you implement a custom {@link Renderer}, `RenderProtoViewRef` specifies what Render View
 * your renderer should create.
 *
 * `RenderProtoViewRef` is a counterpart to {@link ProtoViewRef} available in the Application
 * Context. But unlike `ProtoViewRef`, `RenderProtoViewRef` contains all static nested Proto Views
 * that are recursively merged into a single Render Proto View.

 *
 * <!-- TODO: this is created by Renderer#createProtoView in the new compiler -->
 */
var RenderProtoViewRef = (function () {
    function RenderProtoViewRef() {
    }
    return RenderProtoViewRef;
})();
exports.RenderProtoViewRef = RenderProtoViewRef;
/**
 * Represents a list of sibling Nodes that can be moved by the {@link Renderer} independently of
 * other Render Fragments.
 *
 * Any {@link RenderView} has one Render Fragment.
 *
 * Additionally any View with an Embedded View that contains a {@link NgContent View Projection}
 * results in additional Render Fragment.
 */
/*
  <div>foo</div>
  {{bar}}


  <div>foo</div> -> view 1 / fragment 1
  <ul>
    <template ng-for>
      <li>{{fg}}</li> -> view 2 / fragment 1
    </template>
  </ul>
  {{bar}}


  <div>foo</div> -> view 1 / fragment 1
  <ul>
    <template ng-if>
      <li><ng-content></></li> -> view 1 / fragment 2
    </template>
    <template ng-for>
      <li><ng-content></></li> ->
      <li></li>                -> view 1 / fragment 2 + view 2 / fragment 1..n-1
    </template>
  </ul>
  {{bar}}
 */
// TODO(i): refactor into an interface
var RenderFragmentRef = (function () {
    function RenderFragmentRef() {
    }
    return RenderFragmentRef;
})();
exports.RenderFragmentRef = RenderFragmentRef;
/**
 * Represents an Angular View in the Rendering Context.
 *
 * `RenderViewRef` specifies to the {@link Renderer} what View to update or destroy.
 *
 * Unlike a {@link ViewRef} available in the Application Context, Render View contains all the
 * static Component Views that have been recursively merged into a single Render View.
 *
 * Each `RenderViewRef` contains one or more {@link RenderFragmentRef Render Fragments}, these
 * Fragments are created, hydrated, dehydrated and destroyed as a single unit together with the
 * View.
 */
// TODO(i): refactor into an interface
var RenderViewRef = (function () {
    function RenderViewRef() {
    }
    return RenderViewRef;
})();
exports.RenderViewRef = RenderViewRef;
/**
 * Container class produced by a {@link Renderer} when creating a Render View.
 *
 * An instance of `RenderViewWithFragments` contains a {@link RenderViewRef} and an array of
 * {@link RenderFragmentRef}s belonging to this Render View.
 */
// TODO(i): refactor this by RenderViewWithFragments and adding fragments directly to RenderViewRef
var RenderViewWithFragments = (function () {
    function RenderViewWithFragments(
        /**
         * Reference to the {@link RenderViewRef}.
         */
        viewRef, 
        /**
         * Array of {@link RenderFragmentRef}s ordered in the depth-first order.
         */
        fragmentRefs) {
        this.viewRef = viewRef;
        this.fragmentRefs = fragmentRefs;
    }
    return RenderViewWithFragments;
})();
exports.RenderViewWithFragments = RenderViewWithFragments;
/**
 * Injectable service that provides a low-level interface for modifying the UI.
 *
 * Use this service to bypass Angular's templating and make custom UI changes that can't be
 * expressed declaratively. For example if you need to set a property or an attribute whose name is
 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
 * respectively.
 *
 * If you are implementing a custom renderer, you must implement this interface.
 *
 * The default Renderer implementation is {@link DomRenderer}. Also see {@link WebWorkerRenderer}.
 */
var Renderer = (function () {
    function Renderer() {
    }
    return Renderer;
})();
exports.Renderer = Renderer;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_renderer.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var animation_builder_1 = require('angular2/src/animate/animation_builder');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var event_manager_1 = require('./events/event_manager');
var shared_styles_host_1 = require('./shared_styles_host');
var profile_1 = require('../../profile/profile');
var api_1 = require('../api');
var dom_tokens_1 = require('./dom_tokens');
var view_factory_1 = require('../view_factory');
var view_1 = require('../view');
var util_1 = require('./util');
var DomRenderer = (function (_super) {
    __extends(DomRenderer, _super);
    function DomRenderer() {
        _super.apply(this, arguments);
    }
    DomRenderer.prototype.createProtoView = function (cmds) {
        return new view_1.DefaultProtoViewRef(cmds);
    };
    DomRenderer.prototype.getNativeElementSync = function (location) {
        return resolveInternalDomView(location.renderView).boundElements[location.boundElementIndex];
    };
    DomRenderer.prototype.getRootNodes = function (fragment) { return resolveInternalDomFragment(fragment); };
    DomRenderer.prototype.attachFragmentAfterFragment = function (previousFragmentRef, fragmentRef) {
        var previousFragmentNodes = resolveInternalDomFragment(previousFragmentRef);
        if (previousFragmentNodes.length > 0) {
            var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
            var nodes = resolveInternalDomFragment(fragmentRef);
            moveNodesAfterSibling(sibling, nodes);
            this.animateNodesEnter(nodes);
        }
    };
    /**
     * Iterates through all nodes being added to the DOM and animates them if necessary
     * @param nodes
     */
    DomRenderer.prototype.animateNodesEnter = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            this.animateNodeEnter(nodes[i]);
    };
    DomRenderer.prototype.attachFragmentAfterElement = function (elementRef, fragmentRef) {
        var parentView = resolveInternalDomView(elementRef.renderView);
        var element = parentView.boundElements[elementRef.boundElementIndex];
        var nodes = resolveInternalDomFragment(fragmentRef);
        moveNodesAfterSibling(element, nodes);
        this.animateNodesEnter(nodes);
    };
    DomRenderer.prototype.hydrateView = function (viewRef) { resolveInternalDomView(viewRef).hydrate(); };
    DomRenderer.prototype.dehydrateView = function (viewRef) { resolveInternalDomView(viewRef).dehydrate(); };
    DomRenderer.prototype.createTemplateAnchor = function (attrNameAndValues) {
        return this.createElement('script', attrNameAndValues);
    };
    DomRenderer.prototype.createText = function (value) { return dom_adapter_1.DOM.createTextNode(lang_1.isPresent(value) ? value : ''); };
    DomRenderer.prototype.appendChild = function (parent, child) { dom_adapter_1.DOM.appendChild(parent, child); };
    DomRenderer.prototype.setElementProperty = function (location, propertyName, propertyValue) {
        var view = resolveInternalDomView(location.renderView);
        dom_adapter_1.DOM.setProperty(view.boundElements[location.boundElementIndex], propertyName, propertyValue);
    };
    DomRenderer.prototype.setElementAttribute = function (location, attributeName, attributeValue) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        var dashCasedAttributeName = util_1.camelCaseToDashCase(attributeName);
        if (lang_1.isPresent(attributeValue)) {
            dom_adapter_1.DOM.setAttribute(element, dashCasedAttributeName, lang_1.stringify(attributeValue));
        }
        else {
            dom_adapter_1.DOM.removeAttribute(element, dashCasedAttributeName);
        }
    };
    DomRenderer.prototype.setElementClass = function (location, className, isAdd) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        if (isAdd) {
            dom_adapter_1.DOM.addClass(element, className);
        }
        else {
            dom_adapter_1.DOM.removeClass(element, className);
        }
    };
    DomRenderer.prototype.setElementStyle = function (location, styleName, styleValue) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        var dashCasedStyleName = util_1.camelCaseToDashCase(styleName);
        if (lang_1.isPresent(styleValue)) {
            dom_adapter_1.DOM.setStyle(element, dashCasedStyleName, lang_1.stringify(styleValue));
        }
        else {
            dom_adapter_1.DOM.removeStyle(element, dashCasedStyleName);
        }
    };
    DomRenderer.prototype.invokeElementMethod = function (location, methodName, args) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        dom_adapter_1.DOM.invoke(element, methodName, args);
    };
    DomRenderer.prototype.setText = function (viewRef, textNodeIndex, text) {
        var view = resolveInternalDomView(viewRef);
        dom_adapter_1.DOM.setText(view.boundTextNodes[textNodeIndex], text);
    };
    DomRenderer.prototype.setEventDispatcher = function (viewRef, dispatcher) {
        resolveInternalDomView(viewRef).setEventDispatcher(dispatcher);
    };
    return DomRenderer;
})(api_1.Renderer);
exports.DomRenderer = DomRenderer;
var DomRenderer_ = (function (_super) {
    __extends(DomRenderer_, _super);
    function DomRenderer_(_eventManager, _domSharedStylesHost, _animate, document) {
        _super.call(this);
        this._eventManager = _eventManager;
        this._domSharedStylesHost = _domSharedStylesHost;
        this._animate = _animate;
        this._componentCmds = new Map();
        this._nativeShadowStyles = new Map();
        /** @internal */
        this._createRootHostViewScope = profile_1.wtfCreateScope('DomRenderer#createRootHostView()');
        /** @internal */
        this._createViewScope = profile_1.wtfCreateScope('DomRenderer#createView()');
        /** @internal */
        this._detachFragmentScope = profile_1.wtfCreateScope('DomRenderer#detachFragment()');
        this._document = document;
    }
    DomRenderer_.prototype.registerComponentTemplate = function (templateId, commands, styles, nativeShadow) {
        this._componentCmds.set(templateId, commands);
        if (nativeShadow) {
            this._nativeShadowStyles.set(templateId, styles);
        }
        else {
            this._domSharedStylesHost.addStyles(styles);
        }
    };
    DomRenderer_.prototype.resolveComponentTemplate = function (templateId) {
        return this._componentCmds.get(templateId);
    };
    DomRenderer_.prototype.createRootHostView = function (hostProtoViewRef, fragmentCount, hostElementSelector) {
        var s = this._createRootHostViewScope();
        var element = dom_adapter_1.DOM.querySelector(this._document, hostElementSelector);
        if (lang_1.isBlank(element)) {
            profile_1.wtfLeave(s);
            throw new exceptions_1.BaseException("The selector \"" + hostElementSelector + "\" did not match any elements");
        }
        return profile_1.wtfLeave(s, this._createView(hostProtoViewRef, element));
    };
    DomRenderer_.prototype.createView = function (protoViewRef, fragmentCount) {
        var s = this._createViewScope();
        return profile_1.wtfLeave(s, this._createView(protoViewRef, null));
    };
    DomRenderer_.prototype._createView = function (protoViewRef, inplaceElement) {
        var view = view_factory_1.createRenderView(protoViewRef.cmds, inplaceElement, this);
        var sdRoots = view.nativeShadowRoots;
        for (var i = 0; i < sdRoots.length; i++) {
            this._domSharedStylesHost.addHost(sdRoots[i]);
        }
        return new api_1.RenderViewWithFragments(view, view.fragments);
    };
    DomRenderer_.prototype.destroyView = function (viewRef) {
        var view = viewRef;
        var sdRoots = view.nativeShadowRoots;
        for (var i = 0; i < sdRoots.length; i++) {
            this._domSharedStylesHost.removeHost(sdRoots[i]);
        }
    };
    DomRenderer_.prototype.animateNodeEnter = function (node) {
        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {
            dom_adapter_1.DOM.addClass(node, 'ng-enter');
            this._animate.css()
                .addAnimationClass('ng-enter-active')
                .start(node)
                .onComplete(function () { dom_adapter_1.DOM.removeClass(node, 'ng-enter'); });
        }
    };
    DomRenderer_.prototype.animateNodeLeave = function (node) {
        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {
            dom_adapter_1.DOM.addClass(node, 'ng-leave');
            this._animate.css()
                .addAnimationClass('ng-leave-active')
                .start(node)
                .onComplete(function () {
                dom_adapter_1.DOM.removeClass(node, 'ng-leave');
                dom_adapter_1.DOM.remove(node);
            });
        }
        else {
            dom_adapter_1.DOM.remove(node);
        }
    };
    DomRenderer_.prototype.detachFragment = function (fragmentRef) {
        var s = this._detachFragmentScope();
        var fragmentNodes = resolveInternalDomFragment(fragmentRef);
        for (var i = 0; i < fragmentNodes.length; i++) {
            this.animateNodeLeave(fragmentNodes[i]);
        }
        profile_1.wtfLeave(s);
    };
    DomRenderer_.prototype.createElement = function (name, attrNameAndValues) {
        var el = dom_adapter_1.DOM.createElement(name);
        this._setAttributes(el, attrNameAndValues);
        return el;
    };
    DomRenderer_.prototype.mergeElement = function (existing, attrNameAndValues) {
        dom_adapter_1.DOM.clearNodes(existing);
        this._setAttributes(existing, attrNameAndValues);
    };
    DomRenderer_.prototype._setAttributes = function (node, attrNameAndValues) {
        for (var attrIdx = 0; attrIdx < attrNameAndValues.length; attrIdx += 2) {
            dom_adapter_1.DOM.setAttribute(node, attrNameAndValues[attrIdx], attrNameAndValues[attrIdx + 1]);
        }
    };
    DomRenderer_.prototype.createRootContentInsertionPoint = function () {
        return dom_adapter_1.DOM.createComment('root-content-insertion-point');
    };
    DomRenderer_.prototype.createShadowRoot = function (host, templateId) {
        var sr = dom_adapter_1.DOM.createShadowRoot(host);
        var styles = this._nativeShadowStyles.get(templateId);
        for (var i = 0; i < styles.length; i++) {
            dom_adapter_1.DOM.appendChild(sr, dom_adapter_1.DOM.createStyleElement(styles[i]));
        }
        return sr;
    };
    DomRenderer_.prototype.on = function (element, eventName, callback) {
        this._eventManager.addEventListener(element, eventName, decoratePreventDefault(callback));
    };
    DomRenderer_.prototype.globalOn = function (target, eventName, callback) {
        return this._eventManager.addGlobalEventListener(target, eventName, decoratePreventDefault(callback));
    };
    DomRenderer_ = __decorate([
        di_1.Injectable(),
        __param(3, di_1.Inject(dom_tokens_1.DOCUMENT)), 
        __metadata('design:paramtypes', [event_manager_1.EventManager, shared_styles_host_1.DomSharedStylesHost, animation_builder_1.AnimationBuilder, Object])
    ], DomRenderer_);
    return DomRenderer_;
})(DomRenderer);
exports.DomRenderer_ = DomRenderer_;
function resolveInternalDomView(viewRef) {
    return viewRef;
}
function resolveInternalDomFragment(fragmentRef) {
    return fragmentRef.nodes;
}
function moveNodesAfterSibling(sibling, nodes) {
    if (nodes.length > 0 && lang_1.isPresent(dom_adapter_1.DOM.parentElement(sibling))) {
        for (var i = 0; i < nodes.length; i++) {
            dom_adapter_1.DOM.insertBefore(sibling, nodes[i]);
        }
        dom_adapter_1.DOM.insertBefore(nodes[0], sibling);
    }
}
function moveChildNodes(source, target) {
    var currChild = dom_adapter_1.DOM.firstChild(source);
    while (lang_1.isPresent(currChild)) {
        var nextChild = dom_adapter_1.DOM.nextSibling(currChild);
        dom_adapter_1.DOM.appendChild(target, currChild);
        currChild = nextChild;
    }
}
function decoratePreventDefault(eventHandler) {
    return function (event) {
        var allowDefaultBehavior = eventHandler(event);
        if (!allowDefaultBehavior) {
            // TODO(tbosch): move preventDefault into event plugins...
            dom_adapter_1.DOM.preventDefault(event);
        }
    };
}

},{"../../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","../api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","../view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js","../view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view_factory.js","./dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","./events/event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","./shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js","angular2/src/animate/animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
 *
 * Note: Document might not be available in the Application Context when Application and Rendering
 * Contexts are not the same (e.g. when running the application into a Web Worker).
 */
exports.DOCUMENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('DocumentToken'));

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var ng_zone_1 = require('angular2/src/core/zone/ng_zone');
var di_1 = require('angular2/src/core/di');
exports.EVENT_MANAGER_PLUGINS = lang_1.CONST_EXPR(new di_1.OpaqueToken("EventManagerPlugins"));
var EventManager = (function () {
    function EventManager(plugins, _zone) {
        var _this = this;
        this._zone = _zone;
        plugins.forEach(function (p) { return p.manager = _this; });
        this._plugins = collection_1.ListWrapper.reversed(plugins);
    }
    EventManager.prototype.addEventListener = function (element, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function () { return this._zone; };
    /** @internal */
    EventManager.prototype._findPluginFor = function (eventName) {
        var plugins = this._plugins;
        for (var i = 0; i < plugins.length; i++) {
            var plugin = plugins[i];
            if (plugin.supports(eventName)) {
                return plugin;
            }
        }
        throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
    };
    EventManager = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(exports.EVENT_MANAGER_PLUGINS)), 
        __metadata('design:paramtypes', [Array, ng_zone_1.NgZone])
    ], EventManager);
    return EventManager;
})();
exports.EventManager = EventManager;
var EventManagerPlugin = (function () {
    function EventManagerPlugin() {
    }
    // That is equivalent to having supporting $event.target
    EventManagerPlugin.prototype.supports = function (eventName) { return false; };
    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    return EventManagerPlugin;
})();
exports.EventManagerPlugin = EventManagerPlugin;
var DomEventsPlugin = (function (_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin() {
        _super.apply(this, arguments);
    }
    // This plugin should come last in the list of plugins, because it accepts all
    // events.
    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
        this.manager.getZone().runOutsideAngular(function () { dom_adapter_1.DOM.on(element, eventName, outsideHandler); });
    };
    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var element = dom_adapter_1.DOM.getGlobalEventTarget(target);
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.DOM.onAndCancel(element, eventName, outsideHandler); });
    };
    DomEventsPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DomEventsPlugin);
    return DomEventsPlugin;
})(EventManagerPlugin);
exports.DomEventsPlugin = DomEventsPlugin;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_common.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var event_manager_1 = require('./event_manager');
var collection_1 = require('angular2/src/core/facade/collection');
var _eventNames = {
    // pan
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    // pinch
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    // press
    'press': true,
    'pressup': true,
    // rotate
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    // swipe
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    // tap
    'tap': true,
};
var HammerGesturesPluginCommon = (function (_super) {
    __extends(HammerGesturesPluginCommon, _super);
    function HammerGesturesPluginCommon() {
        _super.call(this);
    }
    HammerGesturesPluginCommon.prototype.supports = function (eventName) {
        eventName = eventName.toLowerCase();
        return collection_1.StringMapWrapper.contains(_eventNames, eventName);
    };
    return HammerGesturesPluginCommon;
})(event_manager_1.EventManagerPlugin);
exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;

},{"./event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_gestures.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var hammer_common_1 = require('./hammer_common');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var di_1 = require('angular2/src/core/di');
var HammerGesturesPlugin = (function (_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin() {
        _super.apply(this, arguments);
    }
    HammerGesturesPlugin.prototype.supports = function (eventName) {
        if (!_super.prototype.supports.call(this, eventName))
            return false;
        if (!lang_1.isPresent(window['Hammer'])) {
            throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
        }
        return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        zone.runOutsideAngular(function () {
            // Creating the manager bind events, must be done outside of angular
            var mc = new Hammer(element);
            mc.get('pinch').set({ enable: true });
            mc.get('rotate').set({ enable: true });
            mc.on(eventName, function (eventObj) { zone.run(function () { handler(eventObj); }); });
        });
    };
    HammerGesturesPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HammerGesturesPlugin);
    return HammerGesturesPlugin;
})(hammer_common_1.HammerGesturesPluginCommon);
exports.HammerGesturesPlugin = HammerGesturesPlugin;

},{"./hammer_common":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_common.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/key_events.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var event_manager_1 = require('./event_manager');
var di_1 = require('angular2/src/core/di');
var modifierKeys = ['alt', 'control', 'meta', 'shift'];
var modifierKeyGetters = {
    'alt': function (event) { return event.altKey; },
    'control': function (event) { return event.ctrlKey; },
    'meta': function (event) { return event.metaKey; },
    'shift': function (event) { return event.shiftKey; }
};
var KeyEventsPlugin = (function (_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin() {
        _super.call(this);
    }
    KeyEventsPlugin.prototype.supports = function (eventName) {
        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
    };
    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
        this.manager.getZone().runOutsideAngular(function () {
            dom_adapter_1.DOM.on(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
        });
    };
    KeyEventsPlugin.parseEventName = function (eventName) {
        var parts = eventName.toLowerCase().split('.');
        var domEventName = parts.shift();
        if ((parts.length === 0) ||
            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||
                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
            return null;
        }
        var key = KeyEventsPlugin._normalizeKey(parts.pop());
        var fullKey = '';
        modifierKeys.forEach(function (modifierName) {
            if (collection_1.ListWrapper.contains(parts, modifierName)) {
                collection_1.ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
            }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
            // returning null instead of throwing to let another plugin process the event
            return null;
        }
        var result = collection_1.StringMapWrapper.create();
        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
        return result;
    };
    KeyEventsPlugin.getEventFullKey = function (event) {
        var fullKey = '';
        var key = dom_adapter_1.DOM.getEventKey(event);
        key = key.toLowerCase();
        if (lang_1.StringWrapper.equals(key, ' ')) {
            key = 'space'; // for readability
        }
        else if (lang_1.StringWrapper.equals(key, '.')) {
            key = 'dot'; // because '.' is used as a separator in event names
        }
        modifierKeys.forEach(function (modifierName) {
            if (modifierName != key) {
                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                    fullKey += modifierName + '.';
                }
            }
        });
        fullKey += key;
        return fullKey;
    };
    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
        return function (event) {
            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                zone.run(function () { return handler(event); });
            }
        };
    };
    KeyEventsPlugin._normalizeKey = function (keyName) {
        // TODO: switch to a StringMap if the mapping grows too much
        switch (keyName) {
            case 'esc':
                return 'escape';
            default:
                return keyName;
        }
    };
    KeyEventsPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], KeyEventsPlugin);
    return KeyEventsPlugin;
})(event_manager_1.EventManagerPlugin);
exports.KeyEventsPlugin = KeyEventsPlugin;

},{"./event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_tokens_1 = require('./dom_tokens');
var SharedStylesHost = (function () {
    function SharedStylesHost() {
        /** @internal */
        this._styles = [];
        /** @internal */
        this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function (styles) {
        var _this = this;
        var additions = [];
        styles.forEach(function (style) {
            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
                _this._stylesSet.add(style);
                _this._styles.push(style);
                additions.push(style);
            }
        });
        this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
    SharedStylesHost = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], SharedStylesHost);
    return SharedStylesHost;
})();
exports.SharedStylesHost = SharedStylesHost;
var DomSharedStylesHost = (function (_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(doc) {
        _super.call(this);
        this._hostNodes = new Set();
        this._hostNodes.add(doc.head);
    }
    /** @internal */
    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
        for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            dom_adapter_1.DOM.appendChild(host, dom_adapter_1.DOM.createStyleElement(style));
        }
    };
    DomSharedStylesHost.prototype.addHost = function (hostNode) {
        this._addStylesToHost(this._styles, hostNode);
        this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };
    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
        var _this = this;
        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
    };
    DomSharedStylesHost = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(dom_tokens_1.DOCUMENT)), 
        __metadata('design:paramtypes', [Object])
    ], DomSharedStylesHost);
    return DomSharedStylesHost;
})(SharedStylesHost);
exports.DomSharedStylesHost = DomSharedStylesHost;

},{"./dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module provides advanced support for extending dom strategy.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./dom/shared_styles_host'));
__export(require('./dom/dom_renderer'));
__export(require('./dom/dom_tokens'));
__export(require('./api'));

},{"./api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","./dom/dom_renderer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_renderer.js","./dom/dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","./dom/shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var api_1 = require('./api');
var DefaultProtoViewRef = (function (_super) {
    __extends(DefaultProtoViewRef, _super);
    function DefaultProtoViewRef(cmds) {
        _super.call(this);
        this.cmds = cmds;
    }
    return DefaultProtoViewRef;
})(api_1.RenderProtoViewRef);
exports.DefaultProtoViewRef = DefaultProtoViewRef;
var DefaultRenderFragmentRef = (function (_super) {
    __extends(DefaultRenderFragmentRef, _super);
    function DefaultRenderFragmentRef(nodes) {
        _super.call(this);
        this.nodes = nodes;
    }
    return DefaultRenderFragmentRef;
})(api_1.RenderFragmentRef);
exports.DefaultRenderFragmentRef = DefaultRenderFragmentRef;
var DefaultRenderView = (function (_super) {
    __extends(DefaultRenderView, _super);
    function DefaultRenderView(fragments, boundTextNodes, boundElements, nativeShadowRoots, globalEventAdders, rootContentInsertionPoints) {
        _super.call(this);
        this.fragments = fragments;
        this.boundTextNodes = boundTextNodes;
        this.boundElements = boundElements;
        this.nativeShadowRoots = nativeShadowRoots;
        this.globalEventAdders = globalEventAdders;
        this.rootContentInsertionPoints = rootContentInsertionPoints;
        this.hydrated = false;
        this.eventDispatcher = null;
        this.globalEventRemovers = null;
    }
    DefaultRenderView.prototype.hydrate = function () {
        if (this.hydrated)
            throw new exceptions_1.BaseException('The view is already hydrated.');
        this.hydrated = true;
        this.globalEventRemovers = collection_1.ListWrapper.createFixedSize(this.globalEventAdders.length);
        for (var i = 0; i < this.globalEventAdders.length; i++) {
            this.globalEventRemovers[i] = this.globalEventAdders[i]();
        }
    };
    DefaultRenderView.prototype.dehydrate = function () {
        if (!this.hydrated)
            throw new exceptions_1.BaseException('The view is already dehydrated.');
        for (var i = 0; i < this.globalEventRemovers.length; i++) {
            this.globalEventRemovers[i]();
        }
        this.globalEventRemovers = null;
        this.hydrated = false;
    };
    DefaultRenderView.prototype.setEventDispatcher = function (dispatcher) { this.eventDispatcher = dispatcher; };
    DefaultRenderView.prototype.dispatchRenderEvent = function (boundElementIndex, eventName, event) {
        var allowDefaultBehavior = true;
        if (lang_1.isPresent(this.eventDispatcher)) {
            var locals = new collection_1.Map();
            locals.set('$event', event);
            allowDefaultBehavior =
                this.eventDispatcher.dispatchRenderEvent(boundElementIndex, eventName, locals);
        }
        return allowDefaultBehavior;
    };
    return DefaultRenderView;
})(api_1.RenderViewRef);
exports.DefaultRenderView = DefaultRenderView;

},{"./api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view_factory.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var view_1 = require('./view');
function createRenderView(fragmentCmds, inplaceElement, nodeFactory) {
    var view;
    var eventDispatcher = function (boundElementIndex, eventName, event) {
        return view.dispatchRenderEvent(boundElementIndex, eventName, event);
    };
    var context = new BuildContext(eventDispatcher, nodeFactory, inplaceElement);
    context.build(fragmentCmds);
    var fragments = [];
    for (var i = 0; i < context.fragments.length; i++) {
        fragments.push(new view_1.DefaultRenderFragmentRef(context.fragments[i]));
    }
    view = new view_1.DefaultRenderView(fragments, context.boundTextNodes, context.boundElements, context.nativeShadowRoots, context.globalEventAdders, context.rootContentInsertionPoints);
    return view;
}
exports.createRenderView = createRenderView;
var BuildContext = (function () {
    function BuildContext(_eventDispatcher, factory, _inplaceElement) {
        this._eventDispatcher = _eventDispatcher;
        this.factory = factory;
        this._inplaceElement = _inplaceElement;
        this._builders = [];
        this.globalEventAdders = [];
        this.boundElements = [];
        this.boundTextNodes = [];
        this.nativeShadowRoots = [];
        this.fragments = [];
        this.rootContentInsertionPoints = [];
        this.componentCount = 0;
        this.isHost = lang_1.isPresent((_inplaceElement));
    }
    BuildContext.prototype.build = function (fragmentCmds) {
        this.enqueueFragmentBuilder(null, fragmentCmds);
        this._build(this._builders[0]);
    };
    BuildContext.prototype._build = function (builder) {
        this._builders = [];
        builder.build(this);
        var enqueuedBuilders = this._builders;
        for (var i = 0; i < enqueuedBuilders.length; i++) {
            this._build(enqueuedBuilders[i]);
        }
    };
    BuildContext.prototype.enqueueComponentBuilder = function (component) {
        this.componentCount++;
        this._builders.push(new RenderViewBuilder(component, null, this.factory.resolveComponentTemplate(component.cmd.templateId)));
    };
    BuildContext.prototype.enqueueFragmentBuilder = function (parentComponent, commands) {
        var rootNodes = [];
        this.fragments.push(rootNodes);
        this._builders.push(new RenderViewBuilder(parentComponent, rootNodes, commands));
    };
    BuildContext.prototype.consumeInplaceElement = function () {
        var result = this._inplaceElement;
        this._inplaceElement = null;
        return result;
    };
    BuildContext.prototype.addEventListener = function (boundElementIndex, target, eventName) {
        if (lang_1.isPresent(target)) {
            var handler = createEventHandler(boundElementIndex, target + ":" + eventName, this._eventDispatcher);
            this.globalEventAdders.push(createGlobalEventAdder(target, eventName, handler, this.factory));
        }
        else {
            var handler = createEventHandler(boundElementIndex, eventName, this._eventDispatcher);
            this.factory.on(this.boundElements[boundElementIndex], eventName, handler);
        }
    };
    return BuildContext;
})();
function createEventHandler(boundElementIndex, eventName, eventDispatcher) {
    return function ($event) { return eventDispatcher(boundElementIndex, eventName, $event); };
}
function createGlobalEventAdder(target, eventName, eventHandler, nodeFactory) {
    return function () { return nodeFactory.globalOn(target, eventName, eventHandler); };
}
var RenderViewBuilder = (function () {
    function RenderViewBuilder(parentComponent, fragmentRootNodes, commands) {
        this.parentComponent = parentComponent;
        this.fragmentRootNodes = fragmentRootNodes;
        this.commands = commands;
        var rootNodesParent = lang_1.isPresent(fragmentRootNodes) ? null : parentComponent.shadowRoot;
        this.parentStack = [rootNodesParent];
    }
    RenderViewBuilder.prototype.build = function (context) {
        for (var i = 0; i < this.commands.length; i++) {
            this.commands[i].visit(this, context);
        }
    };
    Object.defineProperty(RenderViewBuilder.prototype, "parent", {
        get: function () { return this.parentStack[this.parentStack.length - 1]; },
        enumerable: true,
        configurable: true
    });
    RenderViewBuilder.prototype.visitText = function (cmd, context) {
        var text = context.factory.createText(cmd.value);
        this._addChild(text, cmd.ngContentIndex, context);
        if (cmd.isBound) {
            context.boundTextNodes.push(text);
        }
        return null;
    };
    RenderViewBuilder.prototype.visitNgContent = function (cmd, context) {
        if (lang_1.isPresent(this.parentComponent)) {
            if (this.parentComponent.isRoot) {
                var insertionPoint = context.factory.createRootContentInsertionPoint();
                if (this.parent instanceof Component) {
                    context.factory.appendChild(this.parent.shadowRoot, insertionPoint);
                }
                else {
                    context.factory.appendChild(this.parent, insertionPoint);
                }
                context.rootContentInsertionPoints.push(insertionPoint);
            }
            else {
                var projectedNodes = this.parentComponent.project(cmd.index);
                for (var i = 0; i < projectedNodes.length; i++) {
                    var node = projectedNodes[i];
                    this._addChild(node, cmd.ngContentIndex, context);
                }
            }
        }
        return null;
    };
    RenderViewBuilder.prototype.visitBeginElement = function (cmd, context) {
        this.parentStack.push(this._beginElement(cmd, context));
        return null;
    };
    RenderViewBuilder.prototype.visitEndElement = function (context) {
        this._endElement();
        return null;
    };
    RenderViewBuilder.prototype.visitBeginComponent = function (cmd, context) {
        var el = this._beginElement(cmd, context);
        var root = el;
        if (cmd.nativeShadow) {
            root = context.factory.createShadowRoot(el, cmd.templateId);
            context.nativeShadowRoots.push(root);
        }
        var isRoot = context.componentCount === 0 && context.isHost;
        var component = new Component(el, root, cmd, isRoot);
        context.enqueueComponentBuilder(component);
        this.parentStack.push(component);
        return null;
    };
    RenderViewBuilder.prototype.visitEndComponent = function (context) {
        this._endElement();
        return null;
    };
    RenderViewBuilder.prototype.visitEmbeddedTemplate = function (cmd, context) {
        var el = context.factory.createTemplateAnchor(cmd.attrNameAndValues);
        this._addChild(el, cmd.ngContentIndex, context);
        context.boundElements.push(el);
        if (cmd.isMerged) {
            context.enqueueFragmentBuilder(this.parentComponent, cmd.children);
        }
        return null;
    };
    RenderViewBuilder.prototype._beginElement = function (cmd, context) {
        var el = context.consumeInplaceElement();
        if (lang_1.isPresent(el)) {
            context.factory.mergeElement(el, cmd.attrNameAndValues);
            this.fragmentRootNodes.push(el);
        }
        else {
            el = context.factory.createElement(cmd.name, cmd.attrNameAndValues);
            this._addChild(el, cmd.ngContentIndex, context);
        }
        if (cmd.isBound) {
            var boundElementIndex = context.boundElements.length;
            context.boundElements.push(el);
            for (var i = 0; i < cmd.eventTargetAndNames.length; i += 2) {
                var target = cmd.eventTargetAndNames[i];
                var eventName = cmd.eventTargetAndNames[i + 1];
                context.addEventListener(boundElementIndex, target, eventName);
            }
        }
        return el;
    };
    RenderViewBuilder.prototype._endElement = function () { this.parentStack.pop(); };
    RenderViewBuilder.prototype._addChild = function (node, ngContentIndex, context) {
        var parent = this.parent;
        if (lang_1.isPresent(parent)) {
            if (parent instanceof Component) {
                parent.addContentNode(ngContentIndex, node, context);
            }
            else {
                context.factory.appendChild(parent, node);
            }
        }
        else {
            this.fragmentRootNodes.push(node);
        }
    };
    return RenderViewBuilder;
})();
var Component = (function () {
    function Component(hostElement, shadowRoot, cmd, isRoot) {
        this.hostElement = hostElement;
        this.shadowRoot = shadowRoot;
        this.cmd = cmd;
        this.isRoot = isRoot;
        this.contentNodesByNgContentIndex = [];
    }
    Component.prototype.addContentNode = function (ngContentIndex, node, context) {
        if (lang_1.isBlank(ngContentIndex)) {
            if (this.cmd.nativeShadow) {
                context.factory.appendChild(this.hostElement, node);
            }
        }
        else {
            while (this.contentNodesByNgContentIndex.length <= ngContentIndex) {
                this.contentNodesByNgContentIndex.push([]);
            }
            this.contentNodesByNgContentIndex[ngContentIndex].push(node);
        }
    };
    Component.prototype.project = function (ngContentIndex) {
        return ngContentIndex < this.contentNodesByNgContentIndex.length ?
            this.contentNodesByNgContentIndex[ngContentIndex] :
            [];
    };
    return Component;
})();
function addAll(source, target) {
    for (var i = 0; i < source.length; i++) {
        target.push(source[i]);
    }
}

},{"./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services.js":[function(require,module,exports){
'use strict';// Public API for Services
var app_root_url_1 = require('angular2/src/core/compiler/app_root_url');
exports.AppRootUrl = app_root_url_1.AppRootUrl;
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
exports.UrlResolver = url_resolver_1.UrlResolver;
var title_1 = require('angular2/src/core/services/title');
exports.Title = title_1.Title;

},{"angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/services/title":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services/title.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services/title.js":[function(require,module,exports){
'use strict';var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 */
var Title = (function () {
    function Title() {
    }
    /**
     * Get the title of the current HTML document.
     * @returns {string}
     */
    Title.prototype.getTitle = function () { return dom_adapter_1.DOM.getTitle(); };
    /**
     * Set the title of the current HTML document.
     * @param newTitle
     */
    Title.prototype.setTitle = function (newTitle) { dom_adapter_1.DOM.setTitle(newTitle); };
    return Title;
})();
exports.Title = Title;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/browser_testability.js":[function(require,module,exports){
'use strict';var testability_1 = require('angular2/src/core/testability/testability');
var lang_1 = require('angular2/src/core/facade/lang');
var PublicTestability = (function () {
    function PublicTestability(testability) {
        this._testability = testability;
    }
    PublicTestability.prototype.isStable = function () { return this._testability.isStable(); };
    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };
    PublicTestability.prototype.findBindings = function (using, provider, exactMatch) {
        return this.findProviders(using, provider, exactMatch);
    };
    PublicTestability.prototype.findProviders = function (using, provider, exactMatch) {
        return this._testability.findBindings(using, provider, exactMatch);
    };
    return PublicTestability;
})();
var BrowserGetTestability = (function () {
    function BrowserGetTestability() {
    }
    BrowserGetTestability.init = function () { testability_1.setTestabilityGetter(new BrowserGetTestability()); };
    BrowserGetTestability.prototype.addToWindow = function (registry) {
        lang_1.global.getAngularTestability = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            var testability = registry.findTestabilityInTree(elem, findInAncestors);
            if (testability == null) {
                throw new Error('Could not find testability for element.');
            }
            return new PublicTestability(testability);
        };
        lang_1.global.getAllAngularTestabilities = function () {
            var testabilities = registry.getAllTestabilities();
            return testabilities.map(function (testability) { return new PublicTestability(testability); });
        };
    };
    return BrowserGetTestability;
})();
exports.BrowserGetTestability = BrowserGetTestability;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var ng_zone_1 = require('../zone/ng_zone');
var async_1 = require('angular2/src/core/facade/async');
/**
 * The Testability service provides testing hooks that can be accessed from
 * the browser and by services such as Protractor. Each bootstrapped Angular
 * application on the page will have an instance of Testability.
 */
var Testability = (function () {
    function Testability(_ngZone) {
        /** @internal */
        this._pendingCount = 0;
        /** @internal */
        this._callbacks = [];
        /** @internal */
        this._isAngularEventPending = false;
        this._watchAngularEvents(_ngZone);
    }
    /** @internal */
    Testability.prototype._watchAngularEvents = function (_ngZone) {
        var _this = this;
        _ngZone.overrideOnTurnStart(function () { _this._isAngularEventPending = true; });
        _ngZone.overrideOnEventDone(function () {
            _this._isAngularEventPending = false;
            _this._runCallbacksIfReady();
        }, true);
    };
    Testability.prototype.increasePendingRequestCount = function () {
        this._pendingCount += 1;
        return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function () {
        this._pendingCount -= 1;
        if (this._pendingCount < 0) {
            throw new exceptions_1.BaseException('pending async requests below zero');
        }
        this._runCallbacksIfReady();
        return this._pendingCount;
    };
    Testability.prototype.isStable = function () { return this._pendingCount == 0 && !this._isAngularEventPending; };
    /** @internal */
    Testability.prototype._runCallbacksIfReady = function () {
        var _this = this;
        if (!this.isStable()) {
            return; // Not ready
        }
        // Schedules the call backs in a new frame so that it is always async.
        async_1.PromiseWrapper.resolve(null).then(function (_) {
            while (_this._callbacks.length !== 0) {
                (_this._callbacks.pop())();
            }
        });
    };
    Testability.prototype.whenStable = function (callback) {
        this._callbacks.push(callback);
        this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
    // This only accounts for ngZone, and not pending counts. Use `whenStable` to
    // check for stability.
    Testability.prototype.isAngularEventPending = function () { return this._isAngularEventPending; };
    Testability.prototype.findBindings = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability.prototype.findProviders = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [ng_zone_1.NgZone])
    ], Testability);
    return Testability;
})();
exports.Testability = Testability;
var TestabilityRegistry = (function () {
    function TestabilityRegistry() {
        /** @internal */
        this._applications = new collection_1.Map();
        testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
        this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
        if (findInAncestors === void 0) { findInAncestors = true; }
        if (elem == null) {
            return null;
        }
        if (this._applications.has(elem)) {
            return this._applications.get(elem);
        }
        else if (!findInAncestors) {
            return null;
        }
        if (dom_adapter_1.DOM.isShadowRoot(elem)) {
            return this.findTestabilityInTree(dom_adapter_1.DOM.getHost(elem));
        }
        return this.findTestabilityInTree(dom_adapter_1.DOM.parentElement(elem));
    };
    TestabilityRegistry = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], TestabilityRegistry);
    return TestabilityRegistry;
})();
exports.TestabilityRegistry = TestabilityRegistry;
var NoopGetTestability = (function () {
    function NoopGetTestability() {
    }
    NoopGetTestability.prototype.addToWindow = function (registry) { };
    NoopGetTestability = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], NoopGetTestability);
    return NoopGetTestability;
})();
function setTestabilityGetter(getter) {
    testabilityGetter = getter;
}
exports.setTestabilityGetter = setTestabilityGetter;
var testabilityGetter = lang_1.CONST_EXPR(new NoopGetTestability());

},{"../zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util.js":[function(require,module,exports){
'use strict';// Public API for util
var decorators_1 = require('./util/decorators');
exports.Class = decorators_1.Class;

},{"./util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
function extractAnnotation(annotation) {
    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
        // it is a decorator, extract annotation
        annotation = annotation.annotation;
    }
    return annotation;
}
function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
        fnOrArray === Number || fnOrArray === Array) {
        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
    }
    if (lang_1.isFunction(fnOrArray)) {
        return fnOrArray;
    }
    else if (fnOrArray instanceof Array) {
        var annotations = fnOrArray;
        var fn = fnOrArray[fnOrArray.length - 1];
        if (!lang_1.isFunction(fn)) {
            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
        }
        var annoLength = annotations.length - 1;
        if (annoLength != fn.length) {
            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
        }
        var paramsAnnotations = [];
        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
            var paramAnnotations = [];
            paramsAnnotations.push(paramAnnotations);
            var annotation = annotations[i];
            if (annotation instanceof Array) {
                for (var j = 0; j < annotation.length; j++) {
                    paramAnnotations.push(extractAnnotation(annotation[j]));
                }
            }
            else if (lang_1.isFunction(annotation)) {
                paramAnnotations.push(extractAnnotation(annotation));
            }
            else {
                paramAnnotations.push(annotation);
            }
        }
        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
        return fn;
    }
    else {
        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
    }
}
/**
 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
 *
 * ## Basic Example
 *
 * ```
 * var Greeter = ng.Class({
 *   constructor: function(name) {
 *     this.name = name;
 *   },
 *
 *   greet: function() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class Greeter {
 *   constructor(name) {
 *     this.name = name;
 *   }
 *
 *   greet() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * }
 * ```
 *
 * or equivalent to ES5:
 *
 * ```
 * var Greeter = function (name) {
 *   this.name = name;
 * }
 *
 * Greeter.prototype.greet = function () {
 *   alert('Hello ' + this.name + '!');
 * }
 * ```
 *
 * ## Example with parameter annotations
 *
 * ```
 * var MyService = ng.Class({
 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
 *     ...
 *   }]
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class MyService {
 *   constructor(name: string, @Query() queryList: QueryList) {
 *     ...
 *   }
 * }
 * ```
 *
 * ## Example with inheritance
 *
 * ```
 * var Shape = ng.Class({
 *   constructor: (color) {
 *     this.color = color;
 *   }
 * });
 *
 * var Square = ng.Class({
 *   extends: Shape,
 *   constructor: function(color, size) {
 *     Shape.call(this, color);
 *     this.size = size;
 *   }
 * });
 * ```
 */
function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
        if (lang_1.isFunction(clsDef.extends)) {
            constructor.prototype = proto =
                Object.create(clsDef.extends.prototype);
        }
        else {
            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
        }
    }
    for (var key in clsDef) {
        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
            proto[key] = applyParams(clsDef[key], key);
        }
    }
    if (this && this.annotations instanceof Array) {
        Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    return constructor;
}
exports.Class = Class;
var Reflect = lang_1.global.Reflect;
if (!(Reflect && Reflect.getMetadata)) {
    throw 'reflect-metadata shim is required when using class decorators';
}
function makeDecorator(annotationCls, chainFn) {
    if (chainFn === void 0) { chainFn = null; }
    function DecoratorFactory(objOrType) {
        var annotationInstance = new annotationCls(objOrType);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
            chainAnnotation.push(annotationInstance);
            var TypeDecorator = function TypeDecorator(cls) {
                var annotations = Reflect.getOwnMetadata('annotations', cls);
                annotations = annotations || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            };
            TypeDecorator.annotations = chainAnnotation;
            TypeDecorator.Class = Class;
            if (chainFn)
                chainFn(TypeDecorator);
            return TypeDecorator;
        }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return DecoratorFactory;
}
exports.makeDecorator = makeDecorator;
function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var annotationInstance = Object.create(annotationCls.prototype);
        annotationCls.apply(annotationInstance, args);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
        }
        function ParamDecorator(cls, unusedKey, index) {
            var parameters = Reflect.getMetadata('parameters', cls);
            parameters = parameters || [];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            parameters[index] = parameters[index] || [];
            var annotationsForParam = parameters[index];
            annotationsForParam.push(annotationInstance);
            Reflect.defineMetadata('parameters', parameters, cls);
            return cls;
        }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return ParamDecoratorFactory;
}
exports.makeParamDecorator = makeParamDecorator;
function makePropDecorator(decoratorCls) {
    function PropDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var decoratorInstance = Object.create(decoratorCls.prototype);
        decoratorCls.apply(decoratorInstance, args);
        if (this instanceof decoratorCls) {
            return decoratorInstance;
        }
        else {
            return function PropDecorator(target, name) {
                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
                meta = meta || {};
                meta[name] = meta[name] || [];
                meta[name].unshift(decoratorInstance);
                Reflect.defineMetadata('propMetadata', meta, target.constructor);
            };
        }
    }
    PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);
    return PropDecoratorFactory;
}
exports.makePropDecorator = makePropDecorator;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone.js":[function(require,module,exports){
'use strict';// Public API for Zone
var ng_zone_1 = require('./zone/ng_zone');
exports.NgZone = ng_zone_1.NgZone;

},{"./zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var profile_1 = require('../profile/profile');
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link #run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 * ```
 * import {Component, View, NgIf, NgZone} from 'angular2/angular2';
 *
 * @Component({
 *   selector: 'ng-zone-demo'.
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ng-if="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 *   directives: [NgIf]
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *       // reenter the Angular zone and display done
 *       this._ngZone.run(() => {console.log('Outside Done!') });
 *     }}));
 *   }
 *
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 */
var NgZone = (function () {
    /**
     * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be
     *               enabled in development mode as they significantly impact perf.
     */
    function NgZone(_a) {
        var enableLongStackTrace = _a.enableLongStackTrace;
        /** @internal */
        this._runScope = profile_1.wtfCreateScope("NgZone#run()");
        /** @internal */
        this._microtaskScope = profile_1.wtfCreateScope("NgZone#microtask()");
        // Number of microtasks pending from _innerZone (& descendants)
        /** @internal */
        this._pendingMicrotasks = 0;
        // Whether some code has been executed in the _innerZone (& descendants) in the current turn
        /** @internal */
        this._hasExecutedCodeInInnerZone = false;
        // run() call depth in _mountZone. 0 at the end of a macrotask
        // zone.run(() => {         // top-level call
        //   zone.run(() => {});    // nested call -> in-turn
        // });
        /** @internal */
        this._nestedRun = 0;
        /** @internal */
        this._inVmTurnDone = false;
        /** @internal */
        this._pendingTimeouts = [];
        if (lang_1.global.zone) {
            this._disabled = false;
            this._mountZone = lang_1.global.zone;
            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
        }
        else {
            this._disabled = true;
            this._mountZone = null;
        }
    }
    /**
     * Sets the zone hook that is called just before a browser task that is handled by Angular
     * executes.
     *
     * The hook is called once per browser task that is handled by Angular.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnTurnStart = function (onTurnStartHook) {
        this._onTurnStart = lang_1.normalizeBlank(onTurnStartHook);
    };
    /**
     * Sets the zone hook that is called immediately after Angular zone is done processing the current
     * task and any microtasks scheduled from that task.
     *
     * This is where we typically do change-detection.
     *
     * The hook is called once per browser task that is handled by Angular.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnTurnDone = function (onTurnDoneHook) {
        this._onTurnDone = lang_1.normalizeBlank(onTurnDoneHook);
    };
    /**
     * Sets the zone hook that is called immediately after the `onTurnDone` callback is called and any
     * microstasks scheduled from within that callback are drained.
     *
     * `onEventDoneFn` is executed outside Angular zone, which means that we will no longer attempt to
     * sync the UI with any model changes that occur within this callback.
     *
     * This hook is useful for validating application state (e.g. in a test).
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnEventDone = function (onEventDoneFn, opt_waitForAsync) {
        var _this = this;
        if (opt_waitForAsync === void 0) { opt_waitForAsync = false; }
        var normalizedOnEventDone = lang_1.normalizeBlank(onEventDoneFn);
        if (opt_waitForAsync) {
            this._onEventDone = function () {
                if (!_this._pendingTimeouts.length) {
                    normalizedOnEventDone();
                }
            };
        }
        else {
            this._onEventDone = normalizedOnEventDone;
        }
    };
    /**
     * Sets the zone hook that is called when an error is thrown in the Angular zone.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnErrorHandler = function (errorHandler) {
        this._onErrorHandler = lang_1.normalizeBlank(errorHandler);
    };
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     */
    NgZone.prototype.run = function (fn) {
        if (this._disabled) {
            return fn();
        }
        else {
            var s = this._runScope();
            try {
                return this._innerZone.run(fn);
            }
            finally {
                profile_1.wtfLeave(s);
            }
        }
    };
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
     */
    NgZone.prototype.runOutsideAngular = function (fn) {
        if (this._disabled) {
            return fn();
        }
        else {
            return this._mountZone.run(fn);
        }
    };
    /** @internal */
    NgZone.prototype._createInnerZone = function (zone, enableLongStackTrace) {
        var microtaskScope = this._microtaskScope;
        var ngZone = this;
        var errorHandling;
        if (enableLongStackTrace) {
            errorHandling = collection_1.StringMapWrapper.merge(Zone.longStackTraceZone, { onError: function (e) { ngZone._onError(this, e); } });
        }
        else {
            errorHandling = { onError: function (e) { ngZone._onError(this, e); } };
        }
        return zone.fork(errorHandling)
            .fork({
            '$run': function (parentRun) {
                return function () {
                    try {
                        ngZone._nestedRun++;
                        if (!ngZone._hasExecutedCodeInInnerZone) {
                            ngZone._hasExecutedCodeInInnerZone = true;
                            if (ngZone._onTurnStart) {
                                parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
                            }
                        }
                        return parentRun.apply(this, arguments);
                    }
                    finally {
                        ngZone._nestedRun--;
                        // If there are no more pending microtasks, we are at the end of a VM turn (or in
                        // onTurnStart)
                        // _nestedRun will be 0 at the end of a macrotasks (it could be > 0 when there are
                        // nested calls
                        // to run()).
                        if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 &&
                            !this._inVmTurnDone) {
                            if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
                                try {
                                    this._inVmTurnDone = true;
                                    parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
                                }
                                finally {
                                    this._inVmTurnDone = false;
                                    ngZone._hasExecutedCodeInInnerZone = false;
                                }
                            }
                            if (ngZone._pendingMicrotasks === 0 && lang_1.isPresent(ngZone._onEventDone)) {
                                ngZone.runOutsideAngular(ngZone._onEventDone);
                            }
                        }
                    }
                };
            },
            '$scheduleMicrotask': function (parentScheduleMicrotask) {
                return function (fn) {
                    ngZone._pendingMicrotasks++;
                    var microtask = function () {
                        var s = microtaskScope();
                        try {
                            fn();
                        }
                        finally {
                            ngZone._pendingMicrotasks--;
                            profile_1.wtfLeave(s);
                        }
                    };
                    parentScheduleMicrotask.call(this, microtask);
                };
            },
            '$setTimeout': function (parentSetTimeout) {
                return function (fn, delay) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    var id;
                    var cb = function () {
                        fn();
                        collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
                    };
                    id = parentSetTimeout(cb, delay, args);
                    ngZone._pendingTimeouts.push(id);
                    return id;
                };
            },
            '$clearTimeout': function (parentClearTimeout) {
                return function (id) {
                    parentClearTimeout(id);
                    collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
                };
            },
            _innerZone: true
        });
    };
    /** @internal */
    NgZone.prototype._onError = function (zone, e) {
        if (lang_1.isPresent(this._onErrorHandler)) {
            var trace = [lang_1.normalizeBlank(e.stack)];
            while (zone && zone.constructedAtException) {
                trace.push(zone.constructedAtException.get());
                zone = zone.parent;
            }
            this._onErrorHandler(e, trace);
        }
        else {
            console.log('## _onError ##');
            console.log(e.stack);
            throw e;
        }
    };
    return NgZone;
})();
exports.NgZone = NgZone;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/async_route_handler.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var AsyncRouteHandler = (function () {
    function AsyncRouteHandler(_loader, data) {
        this._loader = _loader;
        this.data = data;
        /** @internal */
        this._resolvedComponent = null;
    }
    AsyncRouteHandler.prototype.resolveComponentType = function () {
        var _this = this;
        if (lang_1.isPresent(this._resolvedComponent)) {
            return this._resolvedComponent;
        }
        return this._resolvedComponent = this._loader().then(function (componentType) {
            _this.componentType = componentType;
            return componentType;
        });
    };
    return AsyncRouteHandler;
})();
exports.AsyncRouteHandler = AsyncRouteHandler;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/hash_location_strategy.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var angular2_1 = require('angular2/angular2');
var location_strategy_1 = require('./location_strategy');
/**
 * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
 * {@link Location} service to represent its state in the
 * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
 * of the browser's URL.
 *
 * For instance, if you call `location.go('/foo')`, the browser's URL will become
 * `example.com#/foo`.
 *
 * ## Example
 *
 * ```
 * import {Component, View} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
var HashLocationStrategy = (function (_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy() {
        _super.call(this);
        this._location = dom_adapter_1.DOM.getLocation();
        this._history = dom_adapter_1.DOM.getHistory();
    }
    HashLocationStrategy.prototype.onPopState = function (fn) {
        dom_adapter_1.DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    HashLocationStrategy.prototype.getBaseHref = function () { return ''; };
    HashLocationStrategy.prototype.path = function () {
        // the hash value is always prefixed with a `#`
        // and if it is empty then it will stay empty
        var path = this._location.hash;
        // Dart will complain if a call to substring is
        // executed with a position value that extends the
        // length of string.
        return (path.length > 0 ? path.substring(1) : path) +
            location_strategy_1.normalizeQueryParams(this._location.search);
    };
    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
        var url = path + location_strategy_1.normalizeQueryParams(queryParams);
        if (url.length == 0) {
            url = this._location.pathname;
        }
        else {
            url = '#' + url;
        }
        this._history.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function () { this._history.forward(); };
    HashLocationStrategy.prototype.back = function () { this._history.back(); };
    HashLocationStrategy = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HashLocationStrategy);
    return HashLocationStrategy;
})(location_strategy_1.LocationStrategy);
exports.HashLocationStrategy = HashLocationStrategy;

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * `RouteParams` is an immutable map of parameters for the given route
 * based on the url matcher and optional parameters for that route.
 *
 * You can inject `RouteParams` into the constructor of a component to use it.
 *
 * ## Example
 *
 * ```
 * import {bootstrap, Component} from 'angular2/angular2';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {path: '/user/:id', component: UserCmp, as: 'UserCmp'},
 * ])
 * class AppCmp {}
 *
 * @Component({ template: 'user: {{id}}' })
 * class UserCmp {
 *   string: id;
 *   constructor(params: RouteParams) {
 *     this.id = params.get('id');
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var RouteParams = (function () {
    function RouteParams(params) {
        this.params = params;
    }
    RouteParams.prototype.get = function (param) { return lang_1.normalizeBlank(collection_1.StringMapWrapper.get(this.params, param)); };
    return RouteParams;
})();
exports.RouteParams = RouteParams;
/**
 * `Instruction` is a tree of {@link ComponentInstruction}s with all the information needed
 * to transition each component in the app to a given route, including all auxiliary routes.
 *
 * `Instruction`s can be created using {@link Router#generate}, and can be used to
 * perform route changes with {@link Router#navigateByInstruction}.
 *
 * ## Example
 *
 * ```
 * import {bootstrap, Component} from 'angular2/angular2';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(router: Router) {
 *     var instruction = router.generate(['/MyRoute']);
 *     router.navigateByInstruction(instruction);
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var Instruction = (function () {
    function Instruction(component, child, auxInstruction) {
        this.component = component;
        this.child = child;
        this.auxInstruction = auxInstruction;
    }
    /**
     * Returns a new instruction that shares the state of the existing instruction, but with
     * the given child {@link Instruction} replacing the existing child.
     */
    Instruction.prototype.replaceChild = function (child) {
        return new Instruction(this.component, child, this.auxInstruction);
    };
    return Instruction;
})();
exports.Instruction = Instruction;
/**
 * Represents a partially completed instruction during recognition that only has the
 * primary (non-aux) route instructions matched.
 *
 * `PrimaryInstruction` is an internal class used by `RouteRecognizer` while it's
 * figuring out where to navigate.
 */
var PrimaryInstruction = (function () {
    function PrimaryInstruction(component, child, auxUrls) {
        this.component = component;
        this.child = child;
        this.auxUrls = auxUrls;
    }
    return PrimaryInstruction;
})();
exports.PrimaryInstruction = PrimaryInstruction;
function stringifyInstruction(instruction) {
    return stringifyInstructionPath(instruction) + stringifyInstructionQuery(instruction);
}
exports.stringifyInstruction = stringifyInstruction;
function stringifyInstructionPath(instruction) {
    return instruction.component.urlPath + stringifyAux(instruction) +
        stringifyPrimary(instruction.child);
}
exports.stringifyInstructionPath = stringifyInstructionPath;
function stringifyInstructionQuery(instruction) {
    return instruction.component.urlParams.length > 0 ?
        ('?' + instruction.component.urlParams.join('&')) :
        '';
}
exports.stringifyInstructionQuery = stringifyInstructionQuery;
function stringifyPrimary(instruction) {
    if (lang_1.isBlank(instruction)) {
        return '';
    }
    var params = instruction.component.urlParams.length > 0 ?
        (';' + instruction.component.urlParams.join(';')) :
        '';
    return '/' + instruction.component.urlPath + params + stringifyAux(instruction) +
        stringifyPrimary(instruction.child);
}
function stringifyAux(instruction) {
    var routes = [];
    collection_1.StringMapWrapper.forEach(instruction.auxInstruction, function (auxInstruction, _) {
        routes.push(stringifyPrimary(auxInstruction));
    });
    if (routes.length > 0) {
        return '(' + routes.join('//') + ')';
    }
    return '';
}
/**
 * A `ComponentInstruction` represents the route state for a single component. An `Instruction` is
 * composed of a tree of these `ComponentInstruction`s.
 *
 * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed
 * to route lifecycle hooks, like {@link CanActivate}.
 *
 * `ComponentInstruction`s are [https://en.wikipedia.org/wiki/Hash_consing](hash consed). You should
 * never construct one yourself with "new." Instead, rely on {@link Router/PathRecognizer} to
 * construct `ComponentInstruction`s.
 *
 * You should not modify this object. It should be treated as immutable.
 */
var ComponentInstruction = (function () {
    function ComponentInstruction() {
        this.reuse = false;
    }
    Object.defineProperty(ComponentInstruction.prototype, "componentType", {
        /**
         * Returns the component type of the represented route, or `null` if this instruction
         * hasn't been resolved.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentInstruction.prototype, "specificity", {
        /**
         * Returns the specificity of the route associated with this `Instruction`.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentInstruction.prototype, "terminal", {
        /**
         * Returns `true` if the component type of this instruction has no child {@link RouteConfig},
         * or `false` if it does.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ComponentInstruction;
})();
exports.ComponentInstruction = ComponentInstruction;
var ComponentInstruction_ = (function (_super) {
    __extends(ComponentInstruction_, _super);
    function ComponentInstruction_(urlPath, urlParams, _recognizer, params) {
        if (params === void 0) { params = null; }
        _super.call(this);
        this._recognizer = _recognizer;
        this.urlPath = urlPath;
        this.urlParams = urlParams;
        this.params = params;
    }
    Object.defineProperty(ComponentInstruction_.prototype, "componentType", {
        get: function () { return this._recognizer.handler.componentType; },
        enumerable: true,
        configurable: true
    });
    ComponentInstruction_.prototype.resolveComponentType = function () { return this._recognizer.handler.resolveComponentType(); };
    Object.defineProperty(ComponentInstruction_.prototype, "specificity", {
        get: function () { return this._recognizer.specificity; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentInstruction_.prototype, "terminal", {
        get: function () { return this._recognizer.terminal; },
        enumerable: true,
        configurable: true
    });
    ComponentInstruction_.prototype.routeData = function () { return this._recognizer.handler.data; };
    return ComponentInstruction_;
})(ComponentInstruction);
exports.ComponentInstruction_ = ComponentInstruction_;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js":[function(require,module,exports){
'use strict';/**
 * This indirection is needed to free up Component, etc symbols in the public API
 * to be used by the decorator versions of these annotations.
 */
var decorators_1 = require('angular2/src/core/util/decorators');
var lifecycle_annotations_impl_1 = require('./lifecycle_annotations_impl');
var lifecycle_annotations_impl_2 = require('./lifecycle_annotations_impl');
exports.canReuse = lifecycle_annotations_impl_2.canReuse;
exports.canDeactivate = lifecycle_annotations_impl_2.canDeactivate;
exports.onActivate = lifecycle_annotations_impl_2.onActivate;
exports.onReuse = lifecycle_annotations_impl_2.onReuse;
exports.onDeactivate = lifecycle_annotations_impl_2.onDeactivate;
/**
 * Defines route lifecycle hook `CanActivate`, which is called by the router to determine
 * if a component can be instantiated as part of a navigation.
 *
 * The `CanActivate` hook is called with two {@link ComponentInstruction}s as parameters, the first
 * representing
 * the current route being navigated to, and the second parameter representing the previous route or
 * `null`.
 *
 * Note that unlike other lifecycle hooks, this one uses an annotation rather than an interface.
 * This is because the `CanActivate` function is called before the component is instantiated.
 *
 * If `CanActivate` returns or resolves to `false`, the navigation is cancelled.
 * If `CanActivate` throws or rejects, the navigation is also cancelled.
 * If `CanActivate` returns or resolves to `true`, navigation continues, the component is
 * instantiated, and the {@link OnActivate} hook of that component is called if implemented.
 *
 * ## Example
 * ```
 * import {Component} from 'angular2/angular2';
 * import {CanActivate} from 'angular2/router';
 *
 * @Component({
 *   selector: 'control-panel-cmp',
 *   template: '<div>Control Panel: ...</div>'
 * })
 * @CanActivate(() => checkIfUserIsLoggedIn())
 * class ControlPanelCmp {
 *   // ...
 * }
 *  ```
 */
exports.CanActivate = decorators_1.makeDecorator(lifecycle_annotations_impl_1.CanActivate);

},{"./lifecycle_annotations_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js","angular2/src/core/util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var RouteLifecycleHook = (function () {
    function RouteLifecycleHook(name) {
        this.name = name;
    }
    RouteLifecycleHook = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], RouteLifecycleHook);
    return RouteLifecycleHook;
})();
exports.RouteLifecycleHook = RouteLifecycleHook;
var CanActivate = (function () {
    function CanActivate(fn) {
        this.fn = fn;
    }
    CanActivate = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Function])
    ], CanActivate);
    return CanActivate;
})();
exports.CanActivate = CanActivate;
exports.canReuse = lang_1.CONST_EXPR(new RouteLifecycleHook("canReuse"));
exports.canDeactivate = lang_1.CONST_EXPR(new RouteLifecycleHook("canDeactivate"));
exports.onActivate = lang_1.CONST_EXPR(new RouteLifecycleHook("onActivate"));
exports.onReuse = lang_1.CONST_EXPR(new RouteLifecycleHook("onReuse"));
exports.onDeactivate = lang_1.CONST_EXPR(new RouteLifecycleHook("onDeactivate"));

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var location_strategy_1 = require('./location_strategy');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var lang_2 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var angular2_1 = require('angular2/angular2');
/**
 * The `APP_BASE_HREF` token represents the base href to be used with the
 * {@link PathLocationStrategy}.
 *
 * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
 * representing the URL prefix that should be preserved when generating and recognizing
 * URLs.
 *
 * ## Example
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [
 *   ROUTER_PROVIDERS,
 *   PathLocationStrategy,
 *   provide(APP_BASE_HREF, {useValue: '/my/app'})
 * ]);
 * ```
 */
exports.APP_BASE_HREF = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('appBaseHref'));
/**
 * `Location` is a service that applications can use to interact with a browser's URL.
 * Depending on which {@link LocationStrategy} is used, `Location` will either persist
 * to the URL's path or the URL's hash segment.
 *
 * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
 * `Location` only if you need to interact with or create normalized URLs outside of
 * routing.
 *
 * `Location` is responsible for normalizing the URL against the application's base href.
 * A normalized URL is absolute from the URL host, includes the application's base href, and has no
 * trailing slash:
 * - `/my/app/user/123` is normalized
 * - `my/app/user/123` **is not** normalized
 * - `/my/app/user/123/` **is not** normalized
 *
 * ## Example
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
var Location = (function () {
    function Location(platformStrategy, href) {
        var _this = this;
        this.platformStrategy = platformStrategy;
        /** @internal */
        this._subject = new async_1.EventEmitter();
        var browserBaseHref = lang_1.isPresent(href) ? href : this.platformStrategy.getBaseHref();
        if (lang_2.isBlank(browserBaseHref)) {
            throw new exceptions_1.BaseException("No base href set. Either provide a provider for the APP_BASE_HREF token or add a base element to the document.");
        }
        this._baseHref = stripTrailingSlash(stripIndexHtml(browserBaseHref));
        this.platformStrategy.onPopState(function (_) { async_1.ObservableWrapper.callNext(_this._subject, { 'url': _this.path(), 'pop': true }); });
    }
    /**
     * Returns the normalized URL path.
     */
    Location.prototype.path = function () { return this.normalize(this.platformStrategy.path()); };
    /**
     * Given a string representing a URL, returns the normalized URL path.
     */
    Location.prototype.normalize = function (url) {
        return stripTrailingSlash(_stripBaseHref(this._baseHref, stripIndexHtml(url)));
    };
    /**
     * Given a string representing a URL, returns the normalized URL path.
     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
     * before normalizing.
     */
    Location.prototype.normalizeAbsolutely = function (url) {
        if (!url.startsWith('/')) {
            url = '/' + url;
        }
        return stripTrailingSlash(_addBaseHref(this._baseHref, url));
    };
    /**
     * Changes the browsers URL to the normalized version of the given URL, and pushes a
     * new item onto the platform's history.
     */
    Location.prototype.go = function (path, query) {
        if (query === void 0) { query = ''; }
        var absolutePath = this.normalizeAbsolutely(path);
        this.platformStrategy.pushState(null, '', absolutePath, query);
    };
    /**
     * Navigates forward in the platform's history.
     */
    Location.prototype.forward = function () { this.platformStrategy.forward(); };
    /**
     * Navigates back in the platform's history.
     */
    Location.prototype.back = function () { this.platformStrategy.back(); };
    /**
     * Subscribe to the platform's `popState` events.
     */
    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
        if (onThrow === void 0) { onThrow = null; }
        if (onReturn === void 0) { onReturn = null; }
        async_1.ObservableWrapper.subscribe(this._subject, onNext, onThrow, onReturn);
    };
    Location = __decorate([
        angular2_1.Injectable(),
        __param(1, angular2_1.Optional()),
        __param(1, angular2_1.Inject(exports.APP_BASE_HREF)), 
        __metadata('design:paramtypes', [location_strategy_1.LocationStrategy, String])
    ], Location);
    return Location;
})();
exports.Location = Location;
function _stripBaseHref(baseHref, url) {
    if (baseHref.length > 0 && url.startsWith(baseHref)) {
        return url.substring(baseHref.length);
    }
    return url;
}
function _addBaseHref(baseHref, url) {
    if (!url.startsWith(baseHref)) {
        return baseHref + url;
    }
    return url;
}
function stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
        // '/index.html'.length == 11
        return url.substring(0, url.length - 11);
    }
    return url;
}
function stripTrailingSlash(url) {
    if (/\/$/g.test(url)) {
        url = url.substring(0, url.length - 1);
    }
    return url;
}

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js":[function(require,module,exports){
'use strict';/**
 * `LocationStrategy` is responsible for representing and reading route state
 * from the the browser's URL. Angular provides two strategies:
 * {@link HashLocationStrategy} (default) and {@link PathLocationStrategy}.
 *
 * This is used under the hood of the {@link Location} service.
 *
 * Applications should use the {@link Router} or {@link Location} services to
 * interact with application route state.
 *
 * For instance, {@link HashLocationStrategy} produces URLs like
 * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
 * `http://example.com/foo` as an equivalent URL.
 *
 * See these two classes for more.
 */
var LocationStrategy = (function () {
    function LocationStrategy() {
    }
    return LocationStrategy;
})();
exports.LocationStrategy = LocationStrategy;
function normalizeQueryParams(params) {
    return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
}
exports.normalizeQueryParams = normalizeQueryParams;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_location_strategy.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var angular2_1 = require('angular2/angular2');
var location_strategy_1 = require('./location_strategy');
/**
 * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
 * {@link Location} service to represent its state in the
 * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
 * browser's URL.
 *
 * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
 * provided in {@link ROUTER_PROVIDERS}.
 *
 * If you're using `PathLocationStrategy`, you must provide a provider for
 * {@link APP_BASE_HREF} to a string representing the URL prefix that should
 * be preserved when generating and recognizing URLs.
 *
 * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
 * `location.go('/foo')`, the browser's URL will become
 * `example.com/my/app/foo`.
 *
 * ## Example
 *
 * ```
 * import {Component, provide} from 'angular2/angular2';
 * import {
 *   APP_BASE_HREF
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [
 *   ROUTER_PROVIDERS, // includes binding to PathLocationStrategy
 *   provide(APP_BASE_HREF, {useValue: '/my/app'})
 * ]);
 * ```
 */
var PathLocationStrategy = (function (_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy() {
        _super.call(this);
        this._location = dom_adapter_1.DOM.getLocation();
        this._history = dom_adapter_1.DOM.getHistory();
        this._baseHref = dom_adapter_1.DOM.getBaseHref();
    }
    PathLocationStrategy.prototype.onPopState = function (fn) {
        dom_adapter_1.DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    PathLocationStrategy.prototype.path = function () { return this._location.pathname + location_strategy_1.normalizeQueryParams(this._location.search); };
    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
        this._history.pushState(state, title, (url + location_strategy_1.normalizeQueryParams(queryParams)));
    };
    PathLocationStrategy.prototype.forward = function () { this._history.forward(); };
    PathLocationStrategy.prototype.back = function () { this._history.back(); };
    PathLocationStrategy = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PathLocationStrategy);
    return PathLocationStrategy;
})(location_strategy_1.LocationStrategy);
exports.PathLocationStrategy = PathLocationStrategy;

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_recognizer.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var url_parser_1 = require('./url_parser');
var instruction_1 = require('./instruction');
var TouchMap = (function () {
    function TouchMap(map) {
        var _this = this;
        this.map = {};
        this.keys = {};
        if (lang_1.isPresent(map)) {
            collection_1.StringMapWrapper.forEach(map, function (value, key) {
                _this.map[key] = lang_1.isPresent(value) ? value.toString() : null;
                _this.keys[key] = true;
            });
        }
    }
    TouchMap.prototype.get = function (key) {
        collection_1.StringMapWrapper.delete(this.keys, key);
        return this.map[key];
    };
    TouchMap.prototype.getUnused = function () {
        var _this = this;
        var unused = collection_1.StringMapWrapper.create();
        var keys = collection_1.StringMapWrapper.keys(this.keys);
        keys.forEach(function (key) { return unused[key] = collection_1.StringMapWrapper.get(_this.map, key); });
        return unused;
    };
    return TouchMap;
})();
function normalizeString(obj) {
    if (lang_1.isBlank(obj)) {
        return null;
    }
    else {
        return obj.toString();
    }
}
var ContinuationSegment = (function () {
    function ContinuationSegment() {
        this.name = '';
    }
    ContinuationSegment.prototype.generate = function (params) { return ''; };
    ContinuationSegment.prototype.match = function (path) { return true; };
    return ContinuationSegment;
})();
var StaticSegment = (function () {
    function StaticSegment(path) {
        this.path = path;
        this.name = '';
    }
    StaticSegment.prototype.match = function (path) { return path == this.path; };
    StaticSegment.prototype.generate = function (params) { return this.path; };
    return StaticSegment;
})();
var DynamicSegment = (function () {
    function DynamicSegment(name) {
        this.name = name;
    }
    DynamicSegment.prototype.match = function (path) { return path.length > 0; };
    DynamicSegment.prototype.generate = function (params) {
        if (!collection_1.StringMapWrapper.contains(params.map, this.name)) {
            throw new exceptions_1.BaseException("Route generator for '" + this.name + "' was not included in parameters passed.");
        }
        return normalizeString(params.get(this.name));
    };
    return DynamicSegment;
})();
var StarSegment = (function () {
    function StarSegment(name) {
        this.name = name;
    }
    StarSegment.prototype.match = function (path) { return true; };
    StarSegment.prototype.generate = function (params) { return normalizeString(params.get(this.name)); };
    return StarSegment;
})();
var paramMatcher = /^:([^\/]+)$/g;
var wildcardMatcher = /^\*([^\/]+)$/g;
function parsePathString(route) {
    // normalize route as not starting with a "/". Recognition will
    // also normalize.
    if (lang_1.StringWrapper.startsWith(route, "/")) {
        route = lang_1.StringWrapper.substring(route, 1);
    }
    var segments = splitBySlash(route);
    var results = [];
    var specificity = 0;
    // The "specificity" of a path is used to determine which route is used when multiple routes match
    // a URL.
    // Static segments (like "/foo") are the most specific, followed by dynamic segments (like
    // "/:id"). Star segments
    // add no specificity. Segments at the start of the path are more specific than proceeding ones.
    // The code below uses place values to combine the different types of segments into a single
    // integer that we can
    // sort later. Each static segment is worth hundreds of points of specificity (10000, 9900, ...,
    // 200), and each
    // dynamic segment is worth single points of specificity (100, 99, ... 2).
    if (segments.length > 98) {
        throw new exceptions_1.BaseException("'" + route + "' has more than the maximum supported number of segments.");
    }
    var limit = segments.length - 1;
    for (var i = 0; i <= limit; i++) {
        var segment = segments[i], match;
        if (lang_1.isPresent(match = lang_1.RegExpWrapper.firstMatch(paramMatcher, segment))) {
            results.push(new DynamicSegment(match[1]));
            specificity += (100 - i);
        }
        else if (lang_1.isPresent(match = lang_1.RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
            results.push(new StarSegment(match[1]));
        }
        else if (segment == '...') {
            if (i < limit) {
                // TODO (matsko): setup a proper error here `
                throw new exceptions_1.BaseException("Unexpected \"...\" before the end of the path for \"" + route + "\".");
            }
            results.push(new ContinuationSegment());
        }
        else {
            results.push(new StaticSegment(segment));
            specificity += 100 * (100 - i);
        }
    }
    var result = collection_1.StringMapWrapper.create();
    collection_1.StringMapWrapper.set(result, 'segments', results);
    collection_1.StringMapWrapper.set(result, 'specificity', specificity);
    return result;
}
// this function is used to determine whether a route config path like `/foo/:id` collides with
// `/foo/:name`
function pathDslHash(segments) {
    return segments.map(function (segment) {
        if (segment instanceof StarSegment) {
            return '*';
        }
        else if (segment instanceof ContinuationSegment) {
            return '...';
        }
        else if (segment instanceof DynamicSegment) {
            return ':';
        }
        else if (segment instanceof StaticSegment) {
            return segment.path;
        }
    })
        .join('/');
}
function splitBySlash(url) {
    return url.split('/');
}
var RESERVED_CHARS = lang_1.RegExpWrapper.create('//|\\(|\\)|;|\\?|=');
function assertPath(path) {
    if (lang_1.StringWrapper.contains(path, '#')) {
        throw new exceptions_1.BaseException("Path \"" + path + "\" should not include \"#\". Use \"HashLocationStrategy\" instead.");
    }
    var illegalCharacter = lang_1.RegExpWrapper.firstMatch(RESERVED_CHARS, path);
    if (lang_1.isPresent(illegalCharacter)) {
        throw new exceptions_1.BaseException("Path \"" + path + "\" contains \"" + illegalCharacter[0] + "\" which is not allowed in a route config.");
    }
}
var PathMatch = (function () {
    function PathMatch(instruction, remaining, remainingAux) {
        this.instruction = instruction;
        this.remaining = remaining;
        this.remainingAux = remainingAux;
    }
    return PathMatch;
})();
exports.PathMatch = PathMatch;
// represents something like '/foo/:bar'
var PathRecognizer = (function () {
    // TODO: cache component instruction instances by params and by ParsedUrl instance
    function PathRecognizer(path, handler) {
        this.path = path;
        this.handler = handler;
        this.terminal = true;
        this._cache = new collection_1.Map();
        assertPath(path);
        var parsed = parsePathString(path);
        this._segments = parsed['segments'];
        this.specificity = parsed['specificity'];
        this.hash = pathDslHash(this._segments);
        var lastSegment = this._segments[this._segments.length - 1];
        this.terminal = !(lastSegment instanceof ContinuationSegment);
    }
    PathRecognizer.prototype.recognize = function (beginningSegment) {
        var nextSegment = beginningSegment;
        var currentSegment;
        var positionalParams = {};
        var captured = [];
        for (var i = 0; i < this._segments.length; i += 1) {
            var segment = this._segments[i];
            currentSegment = nextSegment;
            if (segment instanceof ContinuationSegment) {
                break;
            }
            if (lang_1.isPresent(currentSegment)) {
                captured.push(currentSegment.path);
                // the star segment consumes all of the remaining URL, including matrix params
                if (segment instanceof StarSegment) {
                    positionalParams[segment.name] = currentSegment.toString();
                    nextSegment = null;
                    break;
                }
                if (segment instanceof DynamicSegment) {
                    positionalParams[segment.name] = currentSegment.path;
                }
                else if (!segment.match(currentSegment.path)) {
                    return null;
                }
                nextSegment = currentSegment.child;
            }
            else if (!segment.match('')) {
                return null;
            }
        }
        if (this.terminal && lang_1.isPresent(nextSegment)) {
            return null;
        }
        var urlPath = captured.join('/');
        var auxiliary;
        var instruction;
        var urlParams;
        var allParams;
        if (lang_1.isPresent(currentSegment)) {
            // If this is the root component, read query params. Otherwise, read matrix params.
            var paramsSegment = beginningSegment instanceof url_parser_1.RootUrl ? beginningSegment : currentSegment;
            allParams = lang_1.isPresent(paramsSegment.params) ?
                collection_1.StringMapWrapper.merge(paramsSegment.params, positionalParams) :
                positionalParams;
            urlParams = url_parser_1.serializeParams(paramsSegment.params);
            auxiliary = currentSegment.auxiliary;
        }
        else {
            allParams = positionalParams;
            auxiliary = [];
            urlParams = [];
        }
        instruction = this._getInstruction(urlPath, urlParams, this, allParams);
        return new PathMatch(instruction, nextSegment, auxiliary);
    };
    PathRecognizer.prototype.generate = function (params) {
        var paramTokens = new TouchMap(params);
        var path = [];
        for (var i = 0; i < this._segments.length; i++) {
            var segment = this._segments[i];
            if (!(segment instanceof ContinuationSegment)) {
                path.push(segment.generate(paramTokens));
            }
        }
        var urlPath = path.join('/');
        var nonPositionalParams = paramTokens.getUnused();
        var urlParams = url_parser_1.serializeParams(nonPositionalParams);
        return this._getInstruction(urlPath, urlParams, this, params);
    };
    PathRecognizer.prototype._getInstruction = function (urlPath, urlParams, _recognizer, params) {
        var hashKey = urlPath + '?' + urlParams.join('?');
        if (this._cache.has(hashKey)) {
            return this._cache.get(hashKey);
        }
        var instruction = new instruction_1.ComponentInstruction_(urlPath, urlParams, _recognizer, params);
        this._cache.set(hashKey, instruction);
        return instruction;
    };
    return PathRecognizer;
})();
exports.PathRecognizer = PathRecognizer;

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js":[function(require,module,exports){
'use strict';var route_config_impl_1 = require('./route_config_impl');
var decorators_1 = require('angular2/src/core/util/decorators');
var route_config_impl_2 = require('./route_config_impl');
exports.Route = route_config_impl_2.Route;
exports.Redirect = route_config_impl_2.Redirect;
exports.AuxRoute = route_config_impl_2.AuxRoute;
exports.AsyncRoute = route_config_impl_2.AsyncRoute;
exports.RouteConfig = decorators_1.makeDecorator(route_config_impl_1.RouteConfig);

},{"./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","angular2/src/core/util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `RouteConfig` decorator defines routes for a given component.
 *
 * It takes an array of {@link RouteDefinition}s.
 */
var RouteConfig = (function () {
    function RouteConfig(configs) {
        this.configs = configs;
    }
    RouteConfig = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], RouteConfig);
    return RouteConfig;
})();
exports.RouteConfig = RouteConfig;
/**
 * `Route` is a type of {@link RouteDefinition} used to route a path to a component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/home', component: HomeCmp, as: 'HomeCmp' }
 * ])
 * class MyApp {}
 * ```
 */
var Route = (function () {
    function Route(_a) {
        var path = _a.path, component = _a.component, as = _a.as, data = _a.data;
        this.path = path;
        this.component = component;
        this.as = as;
        this.loader = null;
        this.redirectTo = null;
        this.data = data;
    }
    Route = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], Route);
    return Route;
})();
exports.Route = Route;
/**
 * `AuxRoute` is a type of {@link RouteDefinition} used to define an auxiliary route.
 *
 * It takes an object with the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig, AuxRoute} from 'angular2/router';
 *
 * @RouteConfig([
 *   new AuxRoute({path: '/home', component: HomeCmp})
 * ])
 * class MyApp {}
 * ```
 */
var AuxRoute = (function () {
    function AuxRoute(_a) {
        var path = _a.path, component = _a.component, as = _a.as;
        this.data = null;
        // added next two properties to work around https://github.com/Microsoft/TypeScript/issues/4107
        this.loader = null;
        this.redirectTo = null;
        this.path = path;
        this.component = component;
        this.as = as;
    }
    AuxRoute = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], AuxRoute);
    return AuxRoute;
})();
exports.AuxRoute = AuxRoute;
/**
 * `AsyncRoute` is a type of {@link RouteDefinition} used to route a path to an asynchronously
 * loaded component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `loader` is a function that returns a promise that resolves to a component.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/home', loader: () => Promise.resolve(MyLoadedCmp), as: 'MyLoadedCmp'}
 * ])
 * class MyApp {}
 * ```
 */
var AsyncRoute = (function () {
    function AsyncRoute(_a) {
        var path = _a.path, loader = _a.loader, as = _a.as, data = _a.data;
        this.path = path;
        this.loader = loader;
        this.as = as;
        this.data = data;
    }
    AsyncRoute = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], AsyncRoute);
    return AsyncRoute;
})();
exports.AsyncRoute = AsyncRoute;
/**
 * `Redirect` is a type of {@link RouteDefinition} used to route a path to an asynchronously loaded
 * component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `redirectTo` is a string representing the new URL to be matched against.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/', redirectTo: '/home'},
 *   {path: '/home', component: HomeCmp}
 * ])
 * class MyApp {}
 * ```
 */
var Redirect = (function () {
    function Redirect(_a) {
        var path = _a.path, redirectTo = _a.redirectTo;
        this.as = null;
        // added next property to work around https://github.com/Microsoft/TypeScript/issues/4107
        this.loader = null;
        this.data = null;
        this.path = path;
        this.redirectTo = redirectTo;
    }
    Redirect = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], Redirect);
    return Redirect;
})();
exports.Redirect = Redirect;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_nomalizer.js":[function(require,module,exports){
'use strict';var route_config_decorator_1 = require('./route_config_decorator');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Given a JS Object that represents... returns a corresponding Route, AsyncRoute, or Redirect
 */
function normalizeRouteConfig(config) {
    if (config instanceof route_config_decorator_1.Route || config instanceof route_config_decorator_1.Redirect || config instanceof route_config_decorator_1.AsyncRoute ||
        config instanceof route_config_decorator_1.AuxRoute) {
        return config;
    }
    if ((+!!config.component) + (+!!config.redirectTo) + (+!!config.loader) != 1) {
        throw new exceptions_1.BaseException("Route config should contain exactly one \"component\", \"loader\", or \"redirectTo\" property.");
    }
    if (config.loader) {
        return new route_config_decorator_1.AsyncRoute({ path: config.path, loader: config.loader, as: config.as });
    }
    if (config.component) {
        if (typeof config.component == 'object') {
            var componentDefinitionObject = config.component;
            if (componentDefinitionObject.type == 'constructor') {
                return new route_config_decorator_1.Route({
                    path: config.path,
                    component: componentDefinitionObject.constructor,
                    as: config.as
                });
            }
            else if (componentDefinitionObject.type == 'loader') {
                return new route_config_decorator_1.AsyncRoute({ path: config.path, loader: componentDefinitionObject.loader, as: config.as });
            }
            else {
                throw new exceptions_1.BaseException("Invalid component type \"" + componentDefinitionObject.type + "\". Valid types are \"constructor\" and \"loader\".");
            }
        }
        return new route_config_decorator_1.Route(config);
    }
    if (config.redirectTo) {
        return new route_config_decorator_1.Redirect({ path: config.path, redirectTo: config.redirectTo });
    }
    return config;
}
exports.normalizeRouteConfig = normalizeRouteConfig;
function assertComponentExists(component, path) {
    if (!lang_1.isType(component)) {
        throw new exceptions_1.BaseException("Component for route \"" + path + "\" is not defined, or is not a class.");
    }
}
exports.assertComponentExists = assertComponentExists;

},{"./route_config_decorator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js":[function(require,module,exports){
'use strict';var angular2_1 = require('angular2/angular2');
var lang_1 = require('angular2/src/core/facade/lang');
exports.ROUTE_DATA = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('routeData'));

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_definition.js":[function(require,module,exports){
'use strict';
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var lifecycle_annotations_impl_1 = require('./lifecycle_annotations_impl');
var reflection_1 = require('angular2/src/core/reflection/reflection');
function hasLifecycleHook(e, type) {
    if (!(type instanceof lang_1.Type))
        return false;
    return e.name in type.prototype;
}
exports.hasLifecycleHook = hasLifecycleHook;
function getCanActivateHook(type) {
    var annotations = reflection_1.reflector.annotations(type);
    for (var i = 0; i < annotations.length; i += 1) {
        var annotation = annotations[i];
        if (annotation instanceof lifecycle_annotations_impl_1.CanActivate) {
            return annotation.fn;
        }
    }
    return null;
}
exports.getCanActivateHook = getCanActivateHook;

},{"./lifecycle_annotations_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_recognizer.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var path_recognizer_1 = require('./path_recognizer');
var route_config_impl_1 = require('./route_config_impl');
var async_route_handler_1 = require('./async_route_handler');
var sync_route_handler_1 = require('./sync_route_handler');
var url_parser_1 = require('./url_parser');
/**
 * `RouteRecognizer` is responsible for recognizing routes for a single component.
 * It is consumed by `RouteRegistry`, which knows how to recognize an entire hierarchy of
 * components.
 */
var RouteRecognizer = (function () {
    function RouteRecognizer() {
        this.names = new collection_1.Map();
        this.auxRoutes = new collection_1.Map();
        // TODO: optimize this into a trie
        this.matchers = [];
        // TODO: optimize this into a trie
        this.redirects = [];
    }
    RouteRecognizer.prototype.config = function (config) {
        var handler;
        if (lang_1.isPresent(config.as) && config.as[0].toUpperCase() != config.as[0]) {
            var suggestedAlias = config.as[0].toUpperCase() + config.as.substring(1);
            throw new exceptions_1.BaseException("Route '" + config.path + "' with alias '" + config.as + "' does not begin with an uppercase letter. Route aliases should be CamelCase like '" + suggestedAlias + "'.");
        }
        if (config instanceof route_config_impl_1.AuxRoute) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
            var path = lang_1.StringWrapper.startsWith(config.path, '/') ? config.path.substring(1) : config.path;
            var recognizer = new path_recognizer_1.PathRecognizer(config.path, handler);
            this.auxRoutes.set(path, recognizer);
            return recognizer.terminal;
        }
        if (config instanceof route_config_impl_1.Redirect) {
            this.redirects.push(new Redirector(config.path, config.redirectTo));
            return true;
        }
        if (config instanceof route_config_impl_1.Route) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
        }
        else if (config instanceof route_config_impl_1.AsyncRoute) {
            handler = new async_route_handler_1.AsyncRouteHandler(config.loader, config.data);
        }
        var recognizer = new path_recognizer_1.PathRecognizer(config.path, handler);
        this.matchers.forEach(function (matcher) {
            if (recognizer.hash == matcher.hash) {
                throw new exceptions_1.BaseException("Configuration '" + config.path + "' conflicts with existing route '" + matcher.path + "'");
            }
        });
        this.matchers.push(recognizer);
        if (lang_1.isPresent(config.as)) {
            this.names.set(config.as, recognizer);
        }
        return recognizer.terminal;
    };
    /**
     * Given a URL, returns a list of `RouteMatch`es, which are partial recognitions for some route.
     *
     */
    RouteRecognizer.prototype.recognize = function (urlParse) {
        var solutions = [];
        urlParse = this._redirect(urlParse);
        this.matchers.forEach(function (pathRecognizer) {
            var pathMatch = pathRecognizer.recognize(urlParse);
            if (lang_1.isPresent(pathMatch)) {
                solutions.push(pathMatch);
            }
        });
        return solutions;
    };
    /** @internal */
    RouteRecognizer.prototype._redirect = function (urlParse) {
        for (var i = 0; i < this.redirects.length; i += 1) {
            var redirector = this.redirects[i];
            var redirectedUrl = redirector.redirect(urlParse);
            if (lang_1.isPresent(redirectedUrl)) {
                return redirectedUrl;
            }
        }
        return urlParse;
    };
    RouteRecognizer.prototype.recognizeAuxiliary = function (urlParse) {
        var pathRecognizer = this.auxRoutes.get(urlParse.path);
        if (lang_1.isBlank(pathRecognizer)) {
            return null;
        }
        return pathRecognizer.recognize(urlParse);
    };
    RouteRecognizer.prototype.hasRoute = function (name) { return this.names.has(name); };
    RouteRecognizer.prototype.generate = function (name, params) {
        var pathRecognizer = this.names.get(name);
        if (lang_1.isBlank(pathRecognizer)) {
            return null;
        }
        return pathRecognizer.generate(params);
    };
    return RouteRecognizer;
})();
exports.RouteRecognizer = RouteRecognizer;
var Redirector = (function () {
    function Redirector(path, redirectTo) {
        this.segments = [];
        this.toSegments = [];
        if (lang_1.StringWrapper.startsWith(path, '/')) {
            path = path.substring(1);
        }
        this.segments = path.split('/');
        if (lang_1.StringWrapper.startsWith(redirectTo, '/')) {
            redirectTo = redirectTo.substring(1);
        }
        this.toSegments = redirectTo.split('/');
    }
    /**
     * Returns `null` or a `ParsedUrl` representing the new path to match
     */
    Redirector.prototype.redirect = function (urlParse) {
        for (var i = 0; i < this.segments.length; i += 1) {
            if (lang_1.isBlank(urlParse)) {
                return null;
            }
            var segment = this.segments[i];
            if (segment != urlParse.path) {
                return null;
            }
            urlParse = urlParse.child;
        }
        for (var i = this.toSegments.length - 1; i >= 0; i -= 1) {
            var segment = this.toSegments[i];
            urlParse = new url_parser_1.Url(segment, urlParse);
        }
        return urlParse;
    };
    return Redirector;
})();
exports.Redirector = Redirector;

},{"./async_route_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/async_route_handler.js","./path_recognizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_recognizer.js","./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","./sync_route_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/sync_route_handler.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_registry.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var route_recognizer_1 = require('./route_recognizer');
var instruction_1 = require('./instruction');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var route_config_impl_1 = require('./route_config_impl');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var angular2_1 = require('angular2/angular2');
var route_config_nomalizer_1 = require('./route_config_nomalizer');
var url_parser_1 = require('./url_parser');
var _resolveToNull = async_1.PromiseWrapper.resolve(null);
/**
 * The RouteRegistry holds route configurations for each component in an Angular app.
 * It is responsible for creating Instructions from URLs, and generating URLs based on route and
 * parameters.
 */
var RouteRegistry = (function () {
    function RouteRegistry() {
        this._rules = new collection_1.Map();
    }
    /**
     * Given a component and a configuration object, add the route to this registry
     */
    RouteRegistry.prototype.config = function (parentComponent, config) {
        config = route_config_nomalizer_1.normalizeRouteConfig(config);
        // this is here because Dart type guard reasons
        if (config instanceof route_config_impl_1.Route) {
            route_config_nomalizer_1.assertComponentExists(config.component, config.path);
        }
        else if (config instanceof route_config_impl_1.AuxRoute) {
            route_config_nomalizer_1.assertComponentExists(config.component, config.path);
        }
        var recognizer = this._rules.get(parentComponent);
        if (lang_1.isBlank(recognizer)) {
            recognizer = new route_recognizer_1.RouteRecognizer();
            this._rules.set(parentComponent, recognizer);
        }
        var terminal = recognizer.config(config);
        if (config instanceof route_config_impl_1.Route) {
            if (terminal) {
                assertTerminalComponent(config.component, config.path);
            }
            else {
                this.configFromComponent(config.component);
            }
        }
    };
    /**
     * Reads the annotations of a component and configures the registry based on them
     */
    RouteRegistry.prototype.configFromComponent = function (component) {
        var _this = this;
        if (!lang_1.isType(component)) {
            return;
        }
        // Don't read the annotations from a type more than once 
        // this prevents an infinite loop if a component routes recursively.
        if (this._rules.has(component)) {
            return;
        }
        var annotations = reflection_1.reflector.annotations(component);
        if (lang_1.isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                if (annotation instanceof route_config_impl_1.RouteConfig) {
                    var routeCfgs = annotation.configs;
                    routeCfgs.forEach(function (config) { return _this.config(component, config); });
                }
            }
        }
    };
    /**
     * Given a URL and a parent component, return the most specific instruction for navigating
     * the application into the state specified by the url
     */
    RouteRegistry.prototype.recognize = function (url, parentComponent) {
        var parsedUrl = url_parser_1.parser.parse(url);
        return this._recognize(parsedUrl, parentComponent);
    };
    RouteRegistry.prototype._recognize = function (parsedUrl, parentComponent) {
        var _this = this;
        return this._recognizePrimaryRoute(parsedUrl, parentComponent)
            .then(function (instruction) {
            return _this._completeAuxiliaryRouteMatches(instruction, parentComponent);
        });
    };
    RouteRegistry.prototype._recognizePrimaryRoute = function (parsedUrl, parentComponent) {
        var _this = this;
        var componentRecognizer = this._rules.get(parentComponent);
        if (lang_1.isBlank(componentRecognizer)) {
            return _resolveToNull;
        }
        // Matches some beginning part of the given URL
        var possibleMatches = componentRecognizer.recognize(parsedUrl);
        var matchPromises = possibleMatches.map(function (candidate) { return _this._completePrimaryRouteMatch(candidate); });
        return async_1.PromiseWrapper.all(matchPromises).then(mostSpecific);
    };
    RouteRegistry.prototype._completePrimaryRouteMatch = function (partialMatch) {
        var _this = this;
        var instruction = partialMatch.instruction;
        return instruction.resolveComponentType().then(function (componentType) {
            _this.configFromComponent(componentType);
            if (instruction.terminal) {
                return new instruction_1.PrimaryInstruction(instruction, null, partialMatch.remainingAux);
            }
            return _this._recognizePrimaryRoute(partialMatch.remaining, componentType)
                .then(function (childInstruction) {
                if (lang_1.isBlank(childInstruction)) {
                    return null;
                }
                else {
                    return new instruction_1.PrimaryInstruction(instruction, childInstruction, partialMatch.remainingAux);
                }
            });
        });
    };
    RouteRegistry.prototype._completeAuxiliaryRouteMatches = function (instruction, parentComponent) {
        var _this = this;
        if (lang_1.isBlank(instruction)) {
            return _resolveToNull;
        }
        var componentRecognizer = this._rules.get(parentComponent);
        var auxInstructions = {};
        var promises = instruction.auxUrls.map(function (auxSegment) {
            var match = componentRecognizer.recognizeAuxiliary(auxSegment);
            if (lang_1.isBlank(match)) {
                return _resolveToNull;
            }
            return _this._completePrimaryRouteMatch(match).then(function (auxInstruction) {
                if (lang_1.isPresent(auxInstruction)) {
                    return _this._completeAuxiliaryRouteMatches(auxInstruction, parentComponent)
                        .then(function (finishedAuxRoute) {
                        auxInstructions[auxSegment.path] = finishedAuxRoute;
                    });
                }
            });
        });
        return async_1.PromiseWrapper.all(promises).then(function (_) {
            if (lang_1.isBlank(instruction.child)) {
                return new instruction_1.Instruction(instruction.component, null, auxInstructions);
            }
            return _this._completeAuxiliaryRouteMatches(instruction.child, instruction.component.componentType)
                .then(function (completeChild) {
                return new instruction_1.Instruction(instruction.component, completeChild, auxInstructions);
            });
        });
    };
    /**
     * Given a normalized list with component names and params like: `['user', {id: 3 }]`
     * generates a url with a leading slash relative to the provided `parentComponent`.
     */
    RouteRegistry.prototype.generate = function (linkParams, parentComponent) {
        var segments = [];
        var componentCursor = parentComponent;
        var lastInstructionIsTerminal = false;
        for (var i = 0; i < linkParams.length; i += 1) {
            var segment = linkParams[i];
            if (lang_1.isBlank(componentCursor)) {
                throw new exceptions_1.BaseException("Could not find route named \"" + segment + "\".");
            }
            if (!lang_1.isString(segment)) {
                throw new exceptions_1.BaseException("Unexpected segment \"" + segment + "\" in link DSL. Expected a string.");
            }
            else if (segment == '' || segment == '.' || segment == '..') {
                throw new exceptions_1.BaseException("\"" + segment + "/\" is only allowed at the beginning of a link DSL.");
            }
            var params = {};
            if (i + 1 < linkParams.length) {
                var nextSegment = linkParams[i + 1];
                if (lang_1.isStringMap(nextSegment)) {
                    params = nextSegment;
                    i += 1;
                }
            }
            var componentRecognizer = this._rules.get(componentCursor);
            if (lang_1.isBlank(componentRecognizer)) {
                throw new exceptions_1.BaseException("Component \"" + lang_1.getTypeNameForDebugging(componentCursor) + "\" has no route config.");
            }
            var response = componentRecognizer.generate(segment, params);
            if (lang_1.isBlank(response)) {
                throw new exceptions_1.BaseException("Component \"" + lang_1.getTypeNameForDebugging(componentCursor) + "\" has no route named \"" + segment + "\".");
            }
            segments.push(response);
            componentCursor = response.componentType;
            lastInstructionIsTerminal = response.terminal;
        }
        var instruction = null;
        if (!lastInstructionIsTerminal) {
            instruction = this._generateRedirects(componentCursor);
            if (lang_1.isPresent(instruction)) {
                var lastInstruction = instruction;
                while (lang_1.isPresent(lastInstruction.child)) {
                    lastInstruction = lastInstruction.child;
                }
                lastInstructionIsTerminal = lastInstruction.component.terminal;
            }
            if (lang_1.isPresent(componentCursor) && !lastInstructionIsTerminal) {
                throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" does not resolve to a terminal or async instruction.");
            }
        }
        while (segments.length > 0) {
            instruction = new instruction_1.Instruction(segments.pop(), instruction, {});
        }
        return instruction;
    };
    // if the child includes a redirect like : "/" -> "/something",
    // we want to honor that redirection when creating the link
    RouteRegistry.prototype._generateRedirects = function (componentCursor) {
        if (lang_1.isBlank(componentCursor)) {
            return null;
        }
        var componentRecognizer = this._rules.get(componentCursor);
        if (lang_1.isBlank(componentRecognizer)) {
            return null;
        }
        for (var i = 0; i < componentRecognizer.redirects.length; i += 1) {
            var redirect = componentRecognizer.redirects[i];
            // we only handle redirecting from an empty segment
            if (redirect.segments.length == 1 && redirect.segments[0] == '') {
                var toSegments = url_parser_1.pathSegmentsToUrl(redirect.toSegments);
                var matches = componentRecognizer.recognize(toSegments);
                var primaryInstruction = collection_1.ListWrapper.maximum(matches, function (match) { return match.instruction.specificity; });
                if (lang_1.isPresent(primaryInstruction)) {
                    var child = this._generateRedirects(primaryInstruction.instruction.componentType);
                    return new instruction_1.Instruction(primaryInstruction.instruction, child, {});
                }
                return null;
            }
        }
        return null;
    };
    RouteRegistry = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], RouteRegistry);
    return RouteRegistry;
})();
exports.RouteRegistry = RouteRegistry;
/*
 * Given a list of instructions, returns the most specific instruction
 */
function mostSpecific(instructions) {
    return collection_1.ListWrapper.maximum(instructions, function (instruction) { return instruction.component.specificity; });
}
function assertTerminalComponent(component, path) {
    if (!lang_1.isType(component)) {
        return;
    }
    var annotations = reflection_1.reflector.annotations(component);
    if (lang_1.isPresent(annotations)) {
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            if (annotation instanceof route_config_impl_1.RouteConfig) {
                throw new exceptions_1.BaseException("Child routes are not allowed for \"" + path + "\". Use \"...\" on the parent's route path.");
            }
        }
    }
}

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","./route_config_nomalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_nomalizer.js","./route_recognizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_recognizer.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var instruction_1 = require('./instruction');
var route_lifecycle_reflector_1 = require('./route_lifecycle_reflector');
var _resolveToTrue = async_1.PromiseWrapper.resolve(true);
var _resolveToFalse = async_1.PromiseWrapper.resolve(false);
/**
 * The `Router` is responsible for mapping URLs to components.
 *
 * You can see the state of the router by inspecting the read-only field `router.navigating`.
 * This may be useful for showing a spinner, for instance.
 *
 * ## Concepts
 *
 * Routers and component instances have a 1:1 correspondence.
 *
 * The router holds reference to a number of {@link RouterOutlet}.
 * An outlet is a placeholder that the router dynamically fills in depending on the current URL.
 *
 * When the router navigates from a URL, it must first recognize it and serialize it into an
 * `Instruction`.
 * The router uses the `RouteRegistry` to get an `Instruction`.
 */
var Router = (function () {
    function Router(registry, parent, hostComponent) {
        this.registry = registry;
        this.parent = parent;
        this.hostComponent = hostComponent;
        this.navigating = false;
        this._currentInstruction = null;
        this._currentNavigation = _resolveToTrue;
        this._outlet = null;
        this._auxRouters = new collection_1.Map();
        this._subject = new async_1.EventEmitter();
    }
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.childRouter = function (hostComponent) {
        return this._childRouter = new ChildRouter(this, hostComponent);
    };
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.auxRouter = function (hostComponent) { return new ChildRouter(this, hostComponent); };
    /**
     * Register an outlet to notified of primary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerPrimaryOutlet = function (outlet) {
        if (lang_1.isPresent(outlet.name)) {
            throw new exceptions_1.BaseException("registerAuxOutlet expects to be called with an unnamed outlet.");
        }
        this._outlet = outlet;
        if (lang_1.isPresent(this._currentInstruction)) {
            return this.commit(this._currentInstruction, false);
        }
        return _resolveToTrue;
    };
    /**
     * Register an outlet to notified of auxiliary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerAuxOutlet = function (outlet) {
        var outletName = outlet.name;
        if (lang_1.isBlank(outletName)) {
            throw new exceptions_1.BaseException("registerAuxOutlet expects to be called with an outlet with a name.");
        }
        // TODO...
        // what is the host of an aux route???
        var router = this.auxRouter(this.hostComponent);
        this._auxRouters.set(outletName, router);
        router._outlet = outlet;
        var auxInstruction;
        if (lang_1.isPresent(this._currentInstruction) &&
            lang_1.isPresent(auxInstruction = this._currentInstruction.auxInstruction[outletName])) {
            return router.commit(auxInstruction);
        }
        return _resolveToTrue;
    };
    /**
     * Given an instruction, returns `true` if the instruction is currently active,
     * otherwise `false`.
     */
    Router.prototype.isRouteActive = function (instruction) {
        var router = this;
        while (lang_1.isPresent(router.parent) && lang_1.isPresent(instruction.child)) {
            router = router.parent;
            instruction = instruction.child;
        }
        return lang_1.isPresent(this._currentInstruction) &&
            this._currentInstruction.component == instruction.component;
    };
    /**
     * Dynamically update the routing configuration and trigger a navigation.
     *
     * # Usage
     *
     * ```
     * router.config([
     *   { 'path': '/', 'component': IndexComp },
     *   { 'path': '/user/:id', 'component': UserComp },
     * ]);
     * ```
     */
    Router.prototype.config = function (definitions) {
        var _this = this;
        definitions.forEach(function (routeDefinition) { _this.registry.config(_this.hostComponent, routeDefinition); });
        return this.renavigate();
    };
    /**
     * Navigate based on the provided Route Link DSL. It's preferred to navigate with this method
     * over `navigateByUrl`.
     *
     * # Usage
     *
     * This method takes an array representing the Route Link DSL:
     * ```
     * ['./MyCmp', {param: 3}]
     * ```
     * See the {@link RouterLink} directive for more.
     */
    Router.prototype.navigate = function (linkParams) {
        var instruction = this.generate(linkParams);
        return this.navigateByInstruction(instruction, false);
    };
    /**
     * Navigate to a URL. Returns a promise that resolves when navigation is complete.
     * It's preferred to navigate with `navigate` instead of this method, since URLs are more brittle.
     *
     * If the given URL begins with a `/`, router will navigate absolutely.
     * If the given URL does not begin with `/`, the router will navigate relative to this component.
     */
    Router.prototype.navigateByUrl = function (url, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this.lastNavigationAttempt = url;
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this.recognize(url).then(function (instruction) {
                if (lang_1.isBlank(instruction)) {
                    return false;
                }
                return _this._navigate(instruction, _skipLocationChange);
            }));
        });
    };
    /**
     * Navigate via the provided instruction. Returns a promise that resolves when navigation is
     * complete.
     */
    Router.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        if (lang_1.isBlank(instruction)) {
            return _resolveToFalse;
        }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this._navigate(instruction, _skipLocationChange));
        });
    };
    /** @internal */
    Router.prototype._navigate = function (instruction, _skipLocationChange) {
        var _this = this;
        return this._settleInstruction(instruction)
            .then(function (_) { return _this._canReuse(instruction); })
            .then(function (_) { return _this._canActivate(instruction); })
            .then(function (result) {
            if (!result) {
                return false;
            }
            return _this._canDeactivate(instruction)
                .then(function (result) {
                if (result) {
                    return _this.commit(instruction, _skipLocationChange)
                        .then(function (_) {
                        _this._emitNavigationFinish(instruction_1.stringifyInstruction(instruction));
                        return true;
                    });
                }
            });
        });
    };
    // TODO(btford): it'd be nice to remove this method as part of cleaning up the traversal logic
    // Since refactoring `Router.generate` to return an instruction rather than a string, it's not
    // guaranteed that the `componentType`s for the terminal async routes have been loaded by the time
    // we begin navigation. The method below simply traverses instructions and resolves any components
    // for which `componentType` is not present
    /** @internal */
    Router.prototype._settleInstruction = function (instruction) {
        var _this = this;
        var unsettledInstructions = [];
        if (lang_1.isBlank(instruction.component.componentType)) {
            unsettledInstructions.push(instruction.component.resolveComponentType().then(function (type) { _this.registry.configFromComponent(type); }));
        }
        if (lang_1.isPresent(instruction.child)) {
            unsettledInstructions.push(this._settleInstruction(instruction.child));
        }
        collection_1.StringMapWrapper.forEach(instruction.auxInstruction, function (instruction, _) {
            unsettledInstructions.push(_this._settleInstruction(instruction));
        });
        return async_1.PromiseWrapper.all(unsettledInstructions);
    };
    Router.prototype._emitNavigationFinish = function (url) { async_1.ObservableWrapper.callNext(this._subject, url); };
    Router.prototype._afterPromiseFinishNavigating = function (promise) {
        var _this = this;
        return async_1.PromiseWrapper.catchError(promise.then(function (_) { return _this._finishNavigating(); }), function (err) {
            _this._finishNavigating();
            throw err;
        });
    };
    /*
     * Recursively set reuse flags
     */
    /** @internal */
    Router.prototype._canReuse = function (instruction) {
        var _this = this;
        if (lang_1.isBlank(this._outlet)) {
            return _resolveToFalse;
        }
        return this._outlet.canReuse(instruction.component)
            .then(function (result) {
            instruction.component.reuse = result;
            if (result && lang_1.isPresent(_this._childRouter) && lang_1.isPresent(instruction.child)) {
                return _this._childRouter._canReuse(instruction.child);
            }
        });
    };
    Router.prototype._canActivate = function (nextInstruction) {
        return canActivateOne(nextInstruction, this._currentInstruction);
    };
    Router.prototype._canDeactivate = function (instruction) {
        var _this = this;
        if (lang_1.isBlank(this._outlet)) {
            return _resolveToTrue;
        }
        var next;
        var childInstruction = null;
        var reuse = false;
        var componentInstruction = null;
        if (lang_1.isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
            reuse = instruction.component.reuse;
        }
        if (reuse) {
            next = _resolveToTrue;
        }
        else {
            next = this._outlet.canDeactivate(componentInstruction);
        }
        // TODO: aux route lifecycle hooks
        return next.then(function (result) {
            if (result == false) {
                return false;
            }
            if (lang_1.isPresent(_this._childRouter)) {
                return _this._childRouter._canDeactivate(childInstruction);
            }
            return true;
        });
    };
    /**
     * Updates this router and all descendant routers according to the given instruction
     */
    Router.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        this._currentInstruction = instruction;
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._outlet)) {
            var componentInstruction = instruction.component;
            if (componentInstruction.reuse) {
                next = this._outlet.reuse(componentInstruction);
            }
            else {
                next =
                    this.deactivate(instruction).then(function (_) { return _this._outlet.activate(componentInstruction); });
            }
            if (lang_1.isPresent(instruction.child)) {
                next = next.then(function (_) {
                    if (lang_1.isPresent(_this._childRouter)) {
                        return _this._childRouter.commit(instruction.child);
                    }
                });
            }
        }
        var promises = [];
        this._auxRouters.forEach(function (router, name) { promises.push(router.commit(instruction.auxInstruction[name])); });
        return next.then(function (_) { return async_1.PromiseWrapper.all(promises); });
    };
    /** @internal */
    Router.prototype._startNavigating = function () { this.navigating = true; };
    /** @internal */
    Router.prototype._finishNavigating = function () { this.navigating = false; };
    /**
     * Subscribe to URL updates from the router
     */
    Router.prototype.subscribe = function (onNext) {
        return async_1.ObservableWrapper.subscribe(this._subject, onNext);
    };
    /**
     * Removes the contents of this router's outlet and all descendant outlets
     */
    Router.prototype.deactivate = function (instruction) {
        var _this = this;
        var childInstruction = null;
        var componentInstruction = null;
        if (lang_1.isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
        }
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._childRouter)) {
            next = this._childRouter.deactivate(childInstruction);
        }
        if (lang_1.isPresent(this._outlet)) {
            next = next.then(function (_) { return _this._outlet.deactivate(componentInstruction); });
        }
        // TODO: handle aux routes
        return next;
    };
    /**
     * Given a URL, returns an instruction representing the component graph
     */
    Router.prototype.recognize = function (url) {
        return this.registry.recognize(url, this.hostComponent);
    };
    /**
     * Navigates to either the last URL successfully navigated to, or the last URL requested if the
     * router has yet to successfully navigate.
     */
    Router.prototype.renavigate = function () {
        if (lang_1.isBlank(this.lastNavigationAttempt)) {
            return this._currentNavigation;
        }
        return this.navigateByUrl(this.lastNavigationAttempt);
    };
    /**
     * Generate a URL from a component name and optional map of parameters. The URL is relative to the
     * app's base href.
     */
    Router.prototype.generate = function (linkParams) {
        var normalizedLinkParams = splitAndFlattenLinkParams(linkParams);
        var first = collection_1.ListWrapper.first(normalizedLinkParams);
        var rest = collection_1.ListWrapper.slice(normalizedLinkParams, 1);
        var router = this;
        // The first segment should be either '.' (generate from parent) or '' (generate from root).
        // When we normalize above, we strip all the slashes, './' becomes '.' and '/' becomes ''.
        if (first == '') {
            while (lang_1.isPresent(router.parent)) {
                router = router.parent;
            }
        }
        else if (first == '..') {
            router = router.parent;
            while (collection_1.ListWrapper.first(rest) == '..') {
                rest = collection_1.ListWrapper.slice(rest, 1);
                router = router.parent;
                if (lang_1.isBlank(router)) {
                    throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" has too many \"../\" segments.");
                }
            }
        }
        else if (first != '.') {
            throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" must start with \"/\", \"./\", or \"../\"");
        }
        if (rest[rest.length - 1] == '') {
            rest.pop();
        }
        if (rest.length < 1) {
            var msg = "Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" must include a route name.";
            throw new exceptions_1.BaseException(msg);
        }
        // TODO: structural cloning and whatnot
        var url = [];
        var parent = router.parent;
        while (lang_1.isPresent(parent)) {
            url.unshift(parent._currentInstruction);
            parent = parent.parent;
        }
        var nextInstruction = this.registry.generate(rest, router.hostComponent);
        while (url.length > 0) {
            nextInstruction = url.pop().replaceChild(nextInstruction);
        }
        return nextInstruction;
    };
    return Router;
})();
exports.Router = Router;
var RootRouter = (function (_super) {
    __extends(RootRouter, _super);
    function RootRouter(registry, location, primaryComponent) {
        var _this = this;
        _super.call(this, registry, null, primaryComponent);
        this._location = location;
        this._location.subscribe(function (change) {
            return _this.navigateByUrl(change['url'], lang_1.isPresent(change['pop']));
        });
        this.registry.configFromComponent(primaryComponent);
        this.navigateByUrl(location.path());
    }
    RootRouter.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        var emitPath = instruction_1.stringifyInstructionPath(instruction);
        var emitQuery = instruction_1.stringifyInstructionQuery(instruction);
        if (emitPath.length > 0) {
            emitPath = '/' + emitPath;
        }
        var promise = _super.prototype.commit.call(this, instruction);
        if (!_skipLocationChange) {
            promise = promise.then(function (_) { _this._location.go(emitPath, emitQuery); });
        }
        return promise;
    };
    return RootRouter;
})(Router);
exports.RootRouter = RootRouter;
var ChildRouter = (function (_super) {
    __extends(ChildRouter, _super);
    function ChildRouter(parent, hostComponent) {
        _super.call(this, parent.registry, parent, hostComponent);
        this.parent = parent;
    }
    ChildRouter.prototype.navigateByUrl = function (url, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByUrl(url, _skipLocationChange);
    };
    ChildRouter.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByInstruction(instruction, _skipLocationChange);
    };
    return ChildRouter;
})(Router);
/*
 * Given: ['/a/b', {c: 2}]
 * Returns: ['', 'a', 'b', {c: 2}]
 */
var SLASH = new RegExp('/');
function splitAndFlattenLinkParams(linkParams) {
    return collection_1.ListWrapper.reduce(linkParams, function (accumulation, item) {
        if (lang_1.isString(item)) {
            return accumulation.concat(lang_1.StringWrapper.split(item, SLASH));
        }
        accumulation.push(item);
        return accumulation;
    }, []);
}
function canActivateOne(nextInstruction, prevInstruction) {
    var next = _resolveToTrue;
    if (lang_1.isPresent(nextInstruction.child)) {
        next = canActivateOne(nextInstruction.child, lang_1.isPresent(prevInstruction) ? prevInstruction.child : null);
    }
    return next.then(function (result) {
        if (result == false) {
            return false;
        }
        if (nextInstruction.component.reuse) {
            return true;
        }
        var hook = route_lifecycle_reflector_1.getCanActivateHook(nextInstruction.component.componentType);
        if (lang_1.isPresent(hook)) {
            return hook(nextInstruction.component, lang_1.isPresent(prevInstruction) ? prevInstruction.component : null);
        }
        return true;
    });
}

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./route_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_link.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('../core/metadata');
var router_1 = require('./router');
var location_1 = require('./location');
var instruction_1 = require('./instruction');
/**
 * The RouterLink directive lets you link to specific parts of your app.
 *
 * Consider the following route configuration:

 * ```
 * @RouteConfig([
 *   { path: '/user', component: UserCmp, as: 'User' }
 * ]);
 * class MyComp {}
 * ```
 *
 * When linking to this `User` route, you can write:
 *
 * ```
 * <a [router-link]="['./User']">link to user component</a>
 * ```
 *
 * RouterLink expects the value to be an array of route names, followed by the params
 * for that level of routing. For instance `['/Team', {teamId: 1}, 'User', {userId: 2}]`
 * means that we want to generate a link for the `Team` route with params `{teamId: 1}`,
 * and with a child route `User` with params `{userId: 2}`.
 *
 * The first route name should be prepended with `/`, `./`, or `../`.
 * If the route begins with `/`, the router will look up the route from the root of the app.
 * If the route begins with `./`, the router will instead look in the current component's
 * children for the route. And if the route begins with `../`, the router will look at the
 * current component's parent.
 */
var RouterLink = (function () {
    function RouterLink(_router, _location) {
        this._router = _router;
        this._location = _location;
    }
    Object.defineProperty(RouterLink.prototype, "isRouteActive", {
        get: function () { return this._router.isRouteActive(this._navigationInstruction); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLink.prototype, "routeParams", {
        set: function (changes) {
            this._routeParams = changes;
            this._navigationInstruction = this._router.generate(this._routeParams);
            // TODO: is this the right spot for this?
            var navigationHref = '/' + instruction_1.stringifyInstruction(this._navigationInstruction);
            this.visibleHref = this._location.normalizeAbsolutely(navigationHref);
        },
        enumerable: true,
        configurable: true
    });
    RouterLink.prototype.onClick = function () {
        this._router.navigateByInstruction(this._navigationInstruction);
        return false;
    };
    RouterLink = __decorate([
        metadata_1.Directive({
            selector: '[router-link]',
            inputs: ['routeParams: routerLink'],
            host: {
                '(click)': 'onClick()',
                '[attr.href]': 'visibleHref',
                '[class.router-link-active]': 'isRouteActive'
            }
        }), 
        __metadata('design:paramtypes', [router_1.Router, location_1.Location])
    ], RouterLink);
    return RouterLink;
})();
exports.RouterLink = RouterLink;

},{"../core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./location":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js","./router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_outlet.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var angular2_1 = require('angular2/angular2');
var routerMod = require('./router');
var instruction_1 = require('./instruction');
var route_data_1 = require('./route_data');
var hookMod = require('./lifecycle_annotations');
var route_lifecycle_reflector_1 = require('./route_lifecycle_reflector');
var _resolveToTrue = async_1.PromiseWrapper.resolve(true);
/**
 * A router outlet is a placeholder that Angular dynamically fills based on the application's route.
 *
 * ## Use
 *
 * ```
 * <router-outlet></router-outlet>
 * ```
 */
var RouterOutlet = (function () {
    function RouterOutlet(_elementRef, _loader, _parentRouter, nameAttr) {
        this._elementRef = _elementRef;
        this._loader = _loader;
        this._parentRouter = _parentRouter;
        this.name = null;
        this._componentRef = null;
        this._currentInstruction = null;
        if (lang_1.isPresent(nameAttr)) {
            this.name = nameAttr;
            this._parentRouter.registerAuxOutlet(this);
        }
        else {
            this._parentRouter.registerPrimaryOutlet(this);
        }
    }
    /**
     * Called by the Router to instantiate a new component during the commit phase of a navigation.
     * This method in turn is responsible for calling the `onActivate` hook of its child.
     */
    RouterOutlet.prototype.activate = function (nextInstruction) {
        var _this = this;
        var previousInstruction = this._currentInstruction;
        this._currentInstruction = nextInstruction;
        var componentType = nextInstruction.componentType;
        var childRouter = this._parentRouter.childRouter(componentType);
        var providers = angular2_1.Injector.resolve([
            angular2_1.provide(route_data_1.ROUTE_DATA, { useValue: nextInstruction.routeData() }),
            angular2_1.provide(instruction_1.RouteParams, { useValue: new instruction_1.RouteParams(nextInstruction.params) }),
            angular2_1.provide(routerMod.Router, { useValue: childRouter })
        ]);
        return this._loader.loadNextToLocation(componentType, this._elementRef, providers)
            .then(function (componentRef) {
            _this._componentRef = componentRef;
            if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onActivate, componentType)) {
                return _this._componentRef.instance.onActivate(nextInstruction, previousInstruction);
            }
        });
    };
    /**
     * Called by the {@link Router} during the commit phase of a navigation when an outlet
     * reuses a component between different routes.
     * This method in turn is responsible for calling the `onReuse` hook of its child.
     */
    RouterOutlet.prototype.reuse = function (nextInstruction) {
        var previousInstruction = this._currentInstruction;
        this._currentInstruction = nextInstruction;
        if (lang_1.isBlank(this._componentRef)) {
            throw new exceptions_1.BaseException("Cannot reuse an outlet that does not contain a component.");
        }
        return async_1.PromiseWrapper.resolve(route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onReuse, this._currentInstruction.componentType) ?
            this._componentRef.instance.onReuse(nextInstruction, previousInstruction) :
            true);
    };
    /**
     * Called by the {@link Router} when an outlet reuses a component across navigations.
     * This method in turn is responsible for calling the `onReuse` hook of its child.
     */
    RouterOutlet.prototype.deactivate = function (nextInstruction) {
        var _this = this;
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._componentRef) && lang_1.isPresent(this._currentInstruction) &&
            route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onDeactivate, this._currentInstruction.componentType)) {
            next = async_1.PromiseWrapper.resolve(this._componentRef.instance.onDeactivate(nextInstruction, this._currentInstruction));
        }
        return next.then(function (_) {
            if (lang_1.isPresent(_this._componentRef)) {
                _this._componentRef.dispose();
                _this._componentRef = null;
            }
        });
    };
    /**
     * Called by the {@link Router} during recognition phase of a navigation.
     *
     * If this resolves to `false`, the given navigation is cancelled.
     *
     * This method delegates to the child component's `canDeactivate` hook if it exists,
     * and otherwise resolves to true.
     */
    RouterOutlet.prototype.canDeactivate = function (nextInstruction) {
        if (lang_1.isBlank(this._currentInstruction)) {
            return _resolveToTrue;
        }
        if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.canDeactivate, this._currentInstruction.componentType)) {
            return async_1.PromiseWrapper.resolve(this._componentRef.instance.canDeactivate(nextInstruction, this._currentInstruction));
        }
        return _resolveToTrue;
    };
    /**
     * Called by the {@link Router} during recognition phase of a navigation.
     *
     * If the new child component has a different Type than the existing child component,
     * this will resolve to `false`. You can't reuse an old component when the new component
     * is of a different Type.
     *
     * Otherwise, this method delegates to the child component's `canReuse` hook if it exists,
     * or resolves to true if the hook is not present.
     */
    RouterOutlet.prototype.canReuse = function (nextInstruction) {
        var result;
        if (lang_1.isBlank(this._currentInstruction) ||
            this._currentInstruction.componentType != nextInstruction.componentType) {
            result = false;
        }
        else if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.canReuse, this._currentInstruction.componentType)) {
            result = this._componentRef.instance.canReuse(nextInstruction, this._currentInstruction);
        }
        else {
            result = nextInstruction == this._currentInstruction ||
                (lang_1.isPresent(nextInstruction.params) && lang_1.isPresent(this._currentInstruction.params) &&
                    collection_1.StringMapWrapper.equals(nextInstruction.params, this._currentInstruction.params));
        }
        return async_1.PromiseWrapper.resolve(result);
    };
    RouterOutlet = __decorate([
        angular2_1.Directive({ selector: 'router-outlet' }),
        __param(3, angular2_1.Attribute('name')), 
        __metadata('design:paramtypes', [angular2_1.ElementRef, angular2_1.DynamicComponentLoader, routerMod.Router, String])
    ], RouterOutlet);
    return RouterOutlet;
})();
exports.RouterOutlet = RouterOutlet;

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./lifecycle_annotations":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js","./route_data":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js","./route_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js","./router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/sync_route_handler.js":[function(require,module,exports){
'use strict';var async_1 = require('angular2/src/core/facade/async');
var SyncRouteHandler = (function () {
    function SyncRouteHandler(componentType, data) {
        this.componentType = componentType;
        this.data = data;
        /** @internal */
        this._resolvedComponent = null;
        this._resolvedComponent = async_1.PromiseWrapper.resolve(componentType);
    }
    SyncRouteHandler.prototype.resolveComponentType = function () { return this._resolvedComponent; };
    return SyncRouteHandler;
})();
exports.SyncRouteHandler = SyncRouteHandler;

},{"angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * This class represents a parsed URL
 */
var Url = (function () {
    function Url(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = lang_1.CONST_EXPR([]); }
        if (params === void 0) { params = null; }
        this.path = path;
        this.child = child;
        this.auxiliary = auxiliary;
        this.params = params;
    }
    Url.prototype.toString = function () {
        return this.path + this._matrixParamsToString() + this._auxToString() + this._childString();
    };
    Url.prototype.segmentToString = function () { return this.path + this._matrixParamsToString(); };
    /** @internal */
    Url.prototype._auxToString = function () {
        return this.auxiliary.length > 0 ?
            ('(' + this.auxiliary.map(function (sibling) { return sibling.toString(); }).join('//') + ')') :
            '';
    };
    Url.prototype._matrixParamsToString = function () {
        if (lang_1.isBlank(this.params)) {
            return '';
        }
        return ';' + serializeParams(this.params).join(';');
    };
    /** @internal */
    Url.prototype._childString = function () { return lang_1.isPresent(this.child) ? ('/' + this.child.toString()) : ''; };
    return Url;
})();
exports.Url = Url;
var RootUrl = (function (_super) {
    __extends(RootUrl, _super);
    function RootUrl(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = lang_1.CONST_EXPR([]); }
        if (params === void 0) { params = null; }
        _super.call(this, path, child, auxiliary, params);
    }
    RootUrl.prototype.toString = function () {
        return this.path + this._auxToString() + this._childString() + this._queryParamsToString();
    };
    RootUrl.prototype.segmentToString = function () { return this.path + this._queryParamsToString(); };
    RootUrl.prototype._queryParamsToString = function () {
        if (lang_1.isBlank(this.params)) {
            return '';
        }
        return '?' + serializeParams(this.params).join('&');
    };
    return RootUrl;
})(Url);
exports.RootUrl = RootUrl;
function pathSegmentsToUrl(pathSegments) {
    var url = new Url(pathSegments[pathSegments.length - 1]);
    for (var i = pathSegments.length - 2; i >= 0; i -= 1) {
        url = new Url(pathSegments[i], url);
    }
    return url;
}
exports.pathSegmentsToUrl = pathSegmentsToUrl;
var SEGMENT_RE = lang_1.RegExpWrapper.create('^[^\\/\\(\\)\\?;=&#]+');
function matchUrlSegment(str) {
    var match = lang_1.RegExpWrapper.firstMatch(SEGMENT_RE, str);
    return lang_1.isPresent(match) ? match[0] : '';
}
var UrlParser = (function () {
    function UrlParser() {
    }
    UrlParser.prototype.peekStartsWith = function (str) { return lang_1.StringWrapper.startsWith(this._remaining, str); };
    UrlParser.prototype.capture = function (str) {
        if (!lang_1.StringWrapper.startsWith(this._remaining, str)) {
            throw new exceptions_1.BaseException("Expected \"" + str + "\".");
        }
        this._remaining = this._remaining.substring(str.length);
    };
    UrlParser.prototype.parse = function (url) {
        this._remaining = url;
        if (url == '' || url == '/') {
            return new Url('');
        }
        return this.parseRoot();
    };
    // segment + (aux segments) + (query params)
    UrlParser.prototype.parseRoot = function () {
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        if (this.peekStartsWith(';')) {
            // TODO: should these params just be dropped?
            this.parseMatrixParams();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        var queryParams = null;
        if (this.peekStartsWith('?')) {
            queryParams = this.parseQueryParams();
        }
        return new RootUrl(path, child, aux, queryParams);
    };
    // segment + (matrix params) + (aux segments)
    UrlParser.prototype.parseSegment = function () {
        if (this._remaining.length == 0) {
            return null;
        }
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var matrixParams = null;
        if (this.peekStartsWith(';')) {
            matrixParams = this.parseMatrixParams();
        }
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        return new Url(path, child, aux, matrixParams);
    };
    UrlParser.prototype.parseQueryParams = function () {
        var params = {};
        this.capture('?');
        this.parseParam(params);
        while (this._remaining.length > 0 && this.peekStartsWith('&')) {
            this.capture('&');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseMatrixParams = function () {
        var params = {};
        while (this._remaining.length > 0 && this.peekStartsWith(';')) {
            this.capture(';');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseParam = function (params) {
        var key = matchUrlSegment(this._remaining);
        if (lang_1.isBlank(key)) {
            return;
        }
        this.capture(key);
        var value = true;
        if (this.peekStartsWith('=')) {
            this.capture('=');
            var valueMatch = matchUrlSegment(this._remaining);
            if (lang_1.isPresent(valueMatch)) {
                value = valueMatch;
                this.capture(value);
            }
        }
        params[key] = value;
    };
    UrlParser.prototype.parseAuxiliaryRoutes = function () {
        var routes = [];
        this.capture('(');
        while (!this.peekStartsWith(')') && this._remaining.length > 0) {
            routes.push(this.parseSegment());
            if (this.peekStartsWith('//')) {
                this.capture('//');
            }
        }
        this.capture(')');
        return routes;
    };
    return UrlParser;
})();
exports.UrlParser = UrlParser;
exports.parser = new UrlParser();
function serializeParams(paramMap) {
    var params = [];
    if (lang_1.isPresent(paramMap)) {
        collection_1.StringMapWrapper.forEach(paramMap, function (value, key) {
            if (value == true) {
                params.push(key);
            }
            else {
                params.push(key + '=' + value);
            }
        });
    }
    return params;
}
exports.serializeParams = serializeParams;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/transform/template_compiler/change_detector_codegen.js":[function(require,module,exports){
'use strict';// Note: This class is only here so that we can reference it from TypeScript code.
// The actual implementation lives under modules_dart.
// TODO(tbosch): Move the corresponding code into angular2/src/core/compiler once
// the new compiler is done.
var Codegen = (function () {
    function Codegen(moduleAlias) {
    }
    Codegen.prototype.generate = function (typeName, changeDetectorTypeName, def) {
        throw "Not implemented in JS";
    };
    Codegen.prototype.toString = function () { throw "Not implemented in JS"; };
    return Codegen;
})();
exports.Codegen = Codegen;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/dist/js/npm.js":[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/affix.js","../../js/alert.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/alert.js","../../js/button.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/button.js","../../js/carousel.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/carousel.js","../../js/collapse.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/collapse.js","../../js/dropdown.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/dropdown.js","../../js/modal.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/modal.js","../../js/popover.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/popover.js","../../js/scrollspy.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/scrollspy.js","../../js/tab.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tab.js","../../js/tooltip.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tooltip.js","../../js/transition.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/transition.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/affix.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.5
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.5'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/alert.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.5
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.5'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/button.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.5
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.5'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/carousel.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.5
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.5'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/collapse.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.5
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.5'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/dropdown.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.5
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.5'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/modal.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.5
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.5'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/popover.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.5
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.5'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/scrollspy.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.5
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.5'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tab.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.5
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.5'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tooltip.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.5
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.5'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/transition.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.5
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.3.1
    License: https://www.firebase.com/terms/terms-of-service.html */
(function() {var g,aa=this;function n(a){return void 0!==a}function ba(){}function ca(a){a.ub=function(){return a.uf?a.uf:a.uf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.bh=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Yg=function(a,c,f){for(var h=Array(arguments.length-2),k=2;k<arguments.length;k++)h[k-2]=arguments[k];return b.prototype[c].apply(a,h)}};function r(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function na(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function oa(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function pa(a){var b=0,c;for(c in a)b++;return b}function qa(a){for(var b in a)return b}function ra(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function sa(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function ta(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function ua(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function va(a,b){var c=ua(a,b,void 0);return c&&a[c]}function wa(a){for(var b in a)return!1;return!0}function xa(a){var b={},c;for(c in a)b[c]=a[c];return b}var ya="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function za(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<ya.length;f++)c=ya[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Aa(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function Ba(){this.Sd=void 0}
function Ca(a,b,c){switch(typeof b){case "string":Da(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],Ca(a,a.Sd?a.Sd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),Da(f,c),
c.push(":"),Ca(a,a.Sd?a.Sd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var Ea={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Fa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Da(a,b){b.push('"',a.replace(Fa,function(a){if(a in Ea)return Ea[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return Ea[a]=e+b.toString(16)}),'"')};function Ga(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var Ha;a:{var Ia=aa.navigator;if(Ia){var Ja=Ia.userAgent;if(Ja){Ha=Ja;break a}}Ha=""};function Ka(){this.Va=-1};function La(){this.Va=-1;this.Va=64;this.N=[];this.me=[];this.Wf=[];this.Ld=[];this.Ld[0]=128;for(var a=1;a<this.Va;++a)this.Ld[a]=0;this.de=this.ac=0;this.reset()}ma(La,Ka);La.prototype.reset=function(){this.N[0]=1732584193;this.N[1]=4023233417;this.N[2]=2562383102;this.N[3]=271733878;this.N[4]=3285377520;this.de=this.ac=0};
function Ma(a,b,c){c||(c=0);var d=a.Wf;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.N[0];c=a.N[1];for(var h=a.N[2],k=a.N[3],l=a.N[4],m,e=0;80>e;e++)40>e?20>e?(f=k^c&(h^k),m=1518500249):(f=c^h^k,m=1859775393):60>e?(f=c&h|k&(c|h),m=2400959708):(f=c^h^k,m=3395469782),f=(b<<
5|b>>>27)+f+l+m+d[e]&4294967295,l=k,k=h,h=(c<<30|c>>>2)&4294967295,c=b,b=f;a.N[0]=a.N[0]+b&4294967295;a.N[1]=a.N[1]+c&4294967295;a.N[2]=a.N[2]+h&4294967295;a.N[3]=a.N[3]+k&4294967295;a.N[4]=a.N[4]+l&4294967295}
La.prototype.update=function(a,b){if(null!=a){n(b)||(b=a.length);for(var c=b-this.Va,d=0,e=this.me,f=this.ac;d<b;){if(0==f)for(;d<=c;)Ma(this,a,d),d+=this.Va;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Va){Ma(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Va){Ma(this,e);f=0;break}}this.ac=f;this.de+=b}};var u=Array.prototype,Na=u.indexOf?function(a,b,c){return u.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Oa=u.forEach?function(a,b,c){u.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Pa=u.filter?function(a,b,c){return u.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,h=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in h){var l=h[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Qa=u.map?function(a,b,c){return u.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,h=0;h<d;h++)h in f&&(e[h]=b.call(c,f[h],h,a));return e},Ra=u.reduce?function(a,b,c,d){for(var e=[],f=1,h=arguments.length;f<h;f++)e.push(arguments[f]);d&&(e[0]=q(b,d));return u.reduce.apply(a,e)}:function(a,b,c,d){var e=c;Oa(a,function(c,h){e=b.call(d,e,c,h,a)});return e},Sa=u.every?function(a,b,
c){return u.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ta(a,b){var c=Ua(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Ua(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Va(a,b){var c=Na(a,b);0<=c&&u.splice.call(a,c,1)}function Wa(a,b,c){return 2>=arguments.length?u.slice.call(a,b):u.slice.call(a,b,c)}
function Xa(a,b){a.sort(b||Ya)}function Ya(a,b){return a>b?1:a<b?-1:0};var Za=-1!=Ha.indexOf("Opera")||-1!=Ha.indexOf("OPR"),$a=-1!=Ha.indexOf("Trident")||-1!=Ha.indexOf("MSIE"),ab=-1!=Ha.indexOf("Gecko")&&-1==Ha.toLowerCase().indexOf("webkit")&&!(-1!=Ha.indexOf("Trident")||-1!=Ha.indexOf("MSIE")),bb=-1!=Ha.toLowerCase().indexOf("webkit");
(function(){var a="",b;if(Za&&aa.opera)return a=aa.opera.version,ha(a)?a():a;ab?b=/rv\:([^\);]+)(\)|;)/:$a?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:bb&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Ha))?a[1]:"");return $a&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var cb=null,db=null,eb=null;function fb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");gb();for(var c=b?db:cb,d=[],e=0;e<a.length;e+=3){var f=a[e],h=e+1<a.length,k=h?a[e+1]:0,l=e+2<a.length,m=l?a[e+2]:0,t=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|m>>6,m=m&63;l||(m=64,h||(k=64));d.push(c[t],c[f],c[k],c[m])}return d.join("")}
function gb(){if(!cb){cb={};db={};eb={};for(var a=0;65>a;a++)cb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),db[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),eb[db[a]]=a,62<=a&&(eb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)]=a)}};var hb=hb||"2.3.1";function v(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function w(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ib(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function jb(a){var b={};ib(a,function(a,d){b[a]=d});return b};function kb(a){var b=[];ib(a,function(a,d){ea(d)?Oa(d,function(d){b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))}):b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))});return b.length?"&"+b.join("&"):""}function lb(a){var b={};a=a.replace(/^\?/,"").split("&");Oa(a,function(a){a&&(a=a.split("="),b[a[0]]=a[1])});return b};function x(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function y(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function A(a,b,c,d){if((!d||n(c))&&!ha(c))throw Error(y(a,b,d)+"must be a valid function.");}function mb(a,b,c){if(n(c)&&(!ia(c)||null===c))throw Error(y(a,b,!0)+"must be a valid context object.");};function nb(a){return"undefined"!==typeof JSON&&n(JSON.parse)?JSON.parse(a):Aa(a)}function B(a){if("undefined"!==typeof JSON&&n(JSON.stringify))a=JSON.stringify(a);else{var b=[];Ca(new Ba,a,b);a=b.join("")}return a};function ob(){this.Wd=C}ob.prototype.j=function(a){return this.Wd.Q(a)};ob.prototype.toString=function(){return this.Wd.toString()};function pb(){}pb.prototype.qf=function(){return null};pb.prototype.ye=function(){return null};var qb=new pb;function rb(a,b,c){this.Tf=a;this.Ka=b;this.Kd=c}rb.prototype.qf=function(a){var b=this.Ka.O;if(sb(b,a))return b.j().R(a);b=null!=this.Kd?new tb(this.Kd,!0,!1):this.Ka.w();return this.Tf.xc(a,b)};rb.prototype.ye=function(a,b,c){var d=null!=this.Kd?this.Kd:ub(this.Ka);a=this.Tf.ne(d,b,1,c,a);return 0===a.length?null:a[0]};function vb(){this.tb=[]}function wb(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Zb();null===c||f.ca(c.Zb())||(a.tb.push(c),c=null);null===c&&(c=new xb(f));c.add(e)}c&&a.tb.push(c)}function yb(a,b,c){wb(a,c);zb(a,function(a){return a.ca(b)})}function Ab(a,b,c){wb(a,c);zb(a,function(a){return a.contains(b)||b.contains(a)})}
function zb(a,b){for(var c=!0,d=0;d<a.tb.length;d++){var e=a.tb[d];if(e)if(e=e.Zb(),b(e)){for(var e=a.tb[d],f=0;f<e.vd.length;f++){var h=e.vd[f];if(null!==h){e.vd[f]=null;var k=h.Vb();Bb&&Cb("event: "+h.toString());Db(k)}}a.tb[d]=null}else c=!1}c&&(a.tb=[])}function xb(a){this.ra=a;this.vd=[]}xb.prototype.add=function(a){this.vd.push(a)};xb.prototype.Zb=function(){return this.ra};function D(a,b,c,d){this.type=a;this.Ja=b;this.Wa=c;this.Ke=d;this.Qd=void 0}function Eb(a){return new D(Fb,a)}var Fb="value";function Gb(a,b,c,d){this.ue=b;this.Zd=c;this.Qd=d;this.ud=a}Gb.prototype.Zb=function(){var a=this.Zd.Ib();return"value"===this.ud?a.path:a.parent().path};Gb.prototype.ze=function(){return this.ud};Gb.prototype.Vb=function(){return this.ue.Vb(this)};Gb.prototype.toString=function(){return this.Zb().toString()+":"+this.ud+":"+B(this.Zd.mf())};function Hb(a,b,c){this.ue=a;this.error=b;this.path=c}Hb.prototype.Zb=function(){return this.path};Hb.prototype.ze=function(){return"cancel"};
Hb.prototype.Vb=function(){return this.ue.Vb(this)};Hb.prototype.toString=function(){return this.path.toString()+":cancel"};function tb(a,b,c){this.A=a;this.ea=b;this.Ub=c}function Ib(a){return a.ea}function Jb(a){return a.Ub}function Kb(a,b){return b.e()?a.ea&&!a.Ub:sb(a,E(b))}function sb(a,b){return a.ea&&!a.Ub||a.A.Da(b)}tb.prototype.j=function(){return this.A};function Lb(a){this.gg=a;this.Dd=null}Lb.prototype.get=function(){var a=this.gg.get(),b=xa(a);if(this.Dd)for(var c in this.Dd)b[c]-=this.Dd[c];this.Dd=a;return b};function Mb(a,b){this.Of={};this.fd=new Lb(a);this.ba=b;var c=1E4+2E4*Math.random();setTimeout(q(this.If,this),Math.floor(c))}Mb.prototype.If=function(){var a=this.fd.get(),b={},c=!1,d;for(d in a)0<a[d]&&v(this.Of,d)&&(b[d]=a[d],c=!0);c&&this.ba.Ue(b);setTimeout(q(this.If,this),Math.floor(6E5*Math.random()))};function Nb(){this.Ec={}}function Ob(a,b,c){n(c)||(c=1);v(a.Ec,b)||(a.Ec[b]=0);a.Ec[b]+=c}Nb.prototype.get=function(){return xa(this.Ec)};var Pb={},Qb={};function Rb(a){a=a.toString();Pb[a]||(Pb[a]=new Nb);return Pb[a]}function Sb(a,b){var c=a.toString();Qb[c]||(Qb[c]=b());return Qb[c]};function F(a,b){this.name=a;this.S=b}function Tb(a,b){return new F(a,b)};function Ub(a,b){return Vb(a.name,b.name)}function Wb(a,b){return Vb(a,b)};function Xb(a,b,c){this.type=Yb;this.source=a;this.path=b;this.Ga=c}Xb.prototype.Xc=function(a){return this.path.e()?new Xb(this.source,G,this.Ga.R(a)):new Xb(this.source,H(this.path),this.Ga)};Xb.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function Zb(a,b){this.type=$b;this.source=a;this.path=b}Zb.prototype.Xc=function(){return this.path.e()?new Zb(this.source,G):new Zb(this.source,H(this.path))};Zb.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function ac(a,b){this.La=a;this.wa=b?b:bc}g=ac.prototype;g.Oa=function(a,b){return new ac(this.La,this.wa.Oa(a,b,this.La).Y(null,null,!1,null,null))};g.remove=function(a){return new ac(this.La,this.wa.remove(a,this.La).Y(null,null,!1,null,null))};g.get=function(a){for(var b,c=this.wa;!c.e();){b=this.La(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function cc(a,b){for(var c,d=a.wa,e=null;!d.e();){c=a.La(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}g.e=function(){return this.wa.e()};g.count=function(){return this.wa.count()};g.Sc=function(){return this.wa.Sc()};g.fc=function(){return this.wa.fc()};g.ia=function(a){return this.wa.ia(a)};
g.Xb=function(a){return new dc(this.wa,null,this.La,!1,a)};g.Yb=function(a,b){return new dc(this.wa,a,this.La,!1,b)};g.$b=function(a,b){return new dc(this.wa,a,this.La,!0,b)};g.sf=function(a){return new dc(this.wa,null,this.La,!0,a)};function dc(a,b,c,d,e){this.Ud=e||null;this.Fe=d;this.Pa=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.Fe?a.left:a.right;else if(0===e){this.Pa.push(a);break}else this.Pa.push(a),a=this.Fe?a.right:a.left}
function J(a){if(0===a.Pa.length)return null;var b=a.Pa.pop(),c;c=a.Ud?a.Ud(b.key,b.value):{key:b.key,value:b.value};if(a.Fe)for(b=b.left;!b.e();)a.Pa.push(b),b=b.right;else for(b=b.right;!b.e();)a.Pa.push(b),b=b.left;return c}function ec(a){if(0===a.Pa.length)return null;var b;b=a.Pa;b=b[b.length-1];return a.Ud?a.Ud(b.key,b.value):{key:b.key,value:b.value}}function fc(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:bc;this.right=null!=e?e:bc}g=fc.prototype;
g.Y=function(a,b,c,d,e){return new fc(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};g.count=function(){return this.left.count()+1+this.right.count()};g.e=function(){return!1};g.ia=function(a){return this.left.ia(a)||a(this.key,this.value)||this.right.ia(a)};function gc(a){return a.left.e()?a:gc(a.left)}g.Sc=function(){return gc(this).key};g.fc=function(){return this.right.e()?this.key:this.right.fc()};
g.Oa=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.Y(null,null,null,e.left.Oa(a,b,c),null):0===d?e.Y(null,b,null,null,null):e.Y(null,null,null,null,e.right.Oa(a,b,c));return hc(e)};function ic(a){if(a.left.e())return bc;a.left.fa()||a.left.left.fa()||(a=jc(a));a=a.Y(null,null,null,ic(a.left),null);return hc(a)}
g.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.fa()||c.left.left.fa()||(c=jc(c)),c=c.Y(null,null,null,c.left.remove(a,b),null);else{c.left.fa()&&(c=kc(c));c.right.e()||c.right.fa()||c.right.left.fa()||(c=lc(c),c.left.left.fa()&&(c=kc(c),c=lc(c)));if(0===b(a,c.key)){if(c.right.e())return bc;d=gc(c.right);c=c.Y(d.key,d.value,null,null,ic(c.right))}c=c.Y(null,null,null,null,c.right.remove(a,b))}return hc(c)};g.fa=function(){return this.color};
function hc(a){a.right.fa()&&!a.left.fa()&&(a=mc(a));a.left.fa()&&a.left.left.fa()&&(a=kc(a));a.left.fa()&&a.right.fa()&&(a=lc(a));return a}function jc(a){a=lc(a);a.right.left.fa()&&(a=a.Y(null,null,null,null,kc(a.right)),a=mc(a),a=lc(a));return a}function mc(a){return a.right.Y(null,null,a.color,a.Y(null,null,!0,null,a.right.left),null)}function kc(a){return a.left.Y(null,null,a.color,null,a.Y(null,null,!0,a.left.right,null))}
function lc(a){return a.Y(null,null,!a.color,a.left.Y(null,null,!a.left.color,null,null),a.right.Y(null,null,!a.right.color,null,null))}function nc(){}g=nc.prototype;g.Y=function(){return this};g.Oa=function(a,b){return new fc(a,b,null)};g.remove=function(){return this};g.count=function(){return 0};g.e=function(){return!0};g.ia=function(){return!1};g.Sc=function(){return null};g.fc=function(){return null};g.fa=function(){return!1};var bc=new nc;function oc(a,b){return a&&"object"===typeof a?(K(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function pc(a,b){var c=new qc;rc(a,new L(""),function(a,e){c.nc(a,sc(e,b))});return c}function sc(a,b){var c=a.C().I(),c=oc(c,b),d;if(a.K()){var e=oc(a.Ca(),b);return e!==a.Ca()||c!==a.C().I()?new tc(e,M(c)):a}d=a;c!==a.C().I()&&(d=d.ga(new tc(c)));a.P(N,function(a,c){var e=sc(c,b);e!==c&&(d=d.U(a,e))});return d};function uc(){this.wc={}}uc.prototype.set=function(a,b){null==b?delete this.wc[a]:this.wc[a]=b};uc.prototype.get=function(a){return v(this.wc,a)?this.wc[a]:null};uc.prototype.remove=function(a){delete this.wc[a]};uc.prototype.wf=!0;function vc(a){this.Fc=a;this.Pd="firebase:"}g=vc.prototype;g.set=function(a,b){null==b?this.Fc.removeItem(this.Pd+a):this.Fc.setItem(this.Pd+a,B(b))};g.get=function(a){a=this.Fc.getItem(this.Pd+a);return null==a?null:nb(a)};g.remove=function(a){this.Fc.removeItem(this.Pd+a)};g.wf=!1;g.toString=function(){return this.Fc.toString()};function wc(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new vc(b)}}catch(c){}return new uc}var xc=wc("localStorage"),yc=wc("sessionStorage");function zc(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.kb=b;this.hc=c;this.Wg=d;this.Od=e||"";this.Ya=xc.get("host:"+a)||this.host}function Ac(a,b){b!==a.Ya&&(a.Ya=b,"s-"===a.Ya.substr(0,2)&&xc.set("host:"+a.host,a.Ya))}
function Bc(a,b,c){K("string"===typeof b,"typeof type must == string");K("object"===typeof c,"typeof params must == object");if(b===Cc)b=(a.kb?"wss://":"ws://")+a.Ya+"/.ws?";else if(b===Dc)b=(a.kb?"https://":"http://")+a.Ya+"/.lp?";else throw Error("Unknown connection type: "+b);a.host!==a.Ya&&(c.ns=a.hc);var d=[];r(c,function(a,b){d.push(b+"="+a)});return b+d.join("&")}zc.prototype.toString=function(){var a=(this.kb?"https://":"http://")+this.host;this.Od&&(a+="<"+this.Od+">");return a};var Ec=function(){var a=1;return function(){return a++}}();function K(a,b){if(!a)throw Fc(b);}function Fc(a){return Error("Firebase ("+hb+") INTERNAL ASSERT FAILED: "+a)}
function Gc(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{gb();for(var c=eb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],h=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==h||null==k||null==l)throw Error();d.push(f<<2|h>>4);64!=k&&(d.push(h<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Wa(d,c,
c+8192));b=a}}return b}catch(m){Cb("base64Decode failed: ",m)}return null}function Hc(a){var b=Ic(a);a=new La;a.update(b);var b=[],c=8*a.de;56>a.ac?a.update(a.Ld,56-a.ac):a.update(a.Ld,a.Va-(a.ac-56));for(var d=a.Va-1;56<=d;d--)a.me[d]=c&255,c/=256;Ma(a,a.me);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.N[d]>>e&255,++c;return fb(b)}
function Jc(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+Jc.apply(null,arguments[c]):"object"===typeof arguments[c]?b+B(arguments[c]):b+arguments[c],b+=" ";return b}var Bb=null,Kc=!0;function Cb(a){!0===Kc&&(Kc=!1,null===Bb&&!0===yc.get("logging_enabled")&&Lc(!0));if(Bb){var b=Jc.apply(null,arguments);Bb(b)}}function Mc(a){return function(){Cb(a,arguments)}}
function Nc(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+Jc.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function Oc(a){var b=Jc.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function O(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+Jc.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function Pc(a){var b="",c="",d="",e="",f=!0,h="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(h=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var m=a[l];try{m=decodeURIComponent(m.replace(/\+/g," "))}catch(t){}e+="/"+m}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===h||"wss"===h,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Tg:d,kb:f,scheme:h,$c:e}}function Qc(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function Rc(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function Vb(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=Sc(a),d=Sc(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function Tc(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+B(b));}
function Uc(a){if("object"!==typeof a||null===a)return B(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=B(b[d]),c+=":",c+=Uc(a[b[d]]);return c+"}"}function Vc(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function Wc(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else r(a,b)}
function Xc(a){K(!Qc(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;--a)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;--a)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Yc=/^-?\d{1,10}$/;function Sc(a){return Yc.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Db(a){try{a()}catch(b){setTimeout(function(){O("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function P(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Db(function(){a.apply(null,c)})}};function Ic(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,K(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b}function Zc(a){for(var b=0,c=0;c<a.length;c++){var d=a.charCodeAt(c);128>d?b++:2048>d?b+=2:55296<=d&&56319>=d?(b+=4,c++):b+=3}return b};function $c(a){var b={},c={},d={},e="";try{var f=a.split("."),b=nb(Gc(f[0])||""),c=nb(Gc(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(h){}return{Zg:b,Bc:c,data:d,Qg:e}}function ad(a){a=$c(a).Bc;return"object"===typeof a&&a.hasOwnProperty("iat")?w(a,"iat"):null}function bd(a){a=$c(a);var b=a.Bc;return!!a.Qg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function cd(a){this.W=a;this.g=a.n.g}function dd(a,b,c,d){var e=[],f=[];Oa(b,function(b){"child_changed"===b.type&&a.g.Ad(b.Ke,b.Ja)&&f.push(new D("child_moved",b.Ja,b.Wa))});ed(a,e,"child_removed",b,d,c);ed(a,e,"child_added",b,d,c);ed(a,e,"child_moved",f,d,c);ed(a,e,"child_changed",b,d,c);ed(a,e,Fb,b,d,c);return e}function ed(a,b,c,d,e,f){d=Pa(d,function(a){return a.type===c});Xa(d,q(a.hg,a));Oa(d,function(c){var d=fd(a,c,f);Oa(e,function(e){e.Kf(c.type)&&b.push(e.createEvent(d,a.W))})})}
function fd(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Qd=c.rf(b.Wa,b.Ja,a.g));return b}cd.prototype.hg=function(a,b){if(null==a.Wa||null==b.Wa)throw Fc("Should only compare child_ events.");return this.g.compare(new F(a.Wa,a.Ja),new F(b.Wa,b.Ja))};function gd(){this.bb={}}
function hd(a,b){var c=b.type,d=b.Wa;K("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");K(".priority"!==d,"Only non-priority child changes can be tracked.");var e=w(a.bb,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.bb[d]=new D("child_changed",b.Ja,d,e.Ja);else if("child_removed"==c&&"child_added"==f)delete a.bb[d];else if("child_removed"==c&&"child_changed"==f)a.bb[d]=new D("child_removed",e.Ke,d);else if("child_changed"==c&&
"child_added"==f)a.bb[d]=new D("child_added",b.Ja,d);else if("child_changed"==c&&"child_changed"==f)a.bb[d]=new D("child_changed",b.Ja,d,e.Ke);else throw Fc("Illegal combination of changes: "+b+" occurred after "+e);}else a.bb[d]=b};function id(a,b,c){this.Rb=a;this.pb=b;this.rb=c||null}g=id.prototype;g.Kf=function(a){return"value"===a};g.createEvent=function(a,b){var c=b.n.g;return new Gb("value",this,new Q(a.Ja,b.Ib(),c))};g.Vb=function(a){var b=this.rb;if("cancel"===a.ze()){K(this.pb,"Raising a cancel event on a listener with no cancel callback");var c=this.pb;return function(){c.call(b,a.error)}}var d=this.Rb;return function(){d.call(b,a.Zd)}};g.gf=function(a,b){return this.pb?new Hb(this,a,b):null};
g.matches=function(a){return a instanceof id?a.Rb&&this.Rb?a.Rb===this.Rb&&a.rb===this.rb:!0:!1};g.tf=function(){return null!==this.Rb};function jd(a,b,c){this.ha=a;this.pb=b;this.rb=c}g=jd.prototype;g.Kf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ha};g.gf=function(a,b){return this.pb?new Hb(this,a,b):null};
g.createEvent=function(a,b){K(null!=a.Wa,"Child events should have a childName.");var c=b.Ib().u(a.Wa);return new Gb(a.type,this,new Q(a.Ja,c,b.n.g),a.Qd)};g.Vb=function(a){var b=this.rb;if("cancel"===a.ze()){K(this.pb,"Raising a cancel event on a listener with no cancel callback");var c=this.pb;return function(){c.call(b,a.error)}}var d=this.ha[a.ud];return function(){d.call(b,a.Zd,a.Qd)}};
g.matches=function(a){if(a instanceof jd){if(!this.ha||!a.ha)return!0;if(this.rb===a.rb){var b=pa(a.ha);if(b===pa(this.ha)){if(1===b){var b=qa(a.ha),c=qa(this.ha);return c===b&&(!a.ha[b]||!this.ha[c]||a.ha[b]===this.ha[c])}return oa(this.ha,function(b,c){return a.ha[c]===b})}}}return!1};g.tf=function(){return null!==this.ha};function kd(a){this.g=a}g=kd.prototype;g.G=function(a,b,c,d,e,f){K(a.Jc(this.g),"A node must be indexed if only a child is updated");e=a.R(b);if(e.Q(d).ca(c.Q(d))&&e.e()==c.e())return a;null!=f&&(c.e()?a.Da(b)?hd(f,new D("child_removed",e,b)):K(a.K(),"A child remove without an old child only makes sense on a leaf node"):e.e()?hd(f,new D("child_added",c,b)):hd(f,new D("child_changed",c,b,e)));return a.K()&&c.e()?a:a.U(b,c).lb(this.g)};
g.xa=function(a,b,c){null!=c&&(a.K()||a.P(N,function(a,e){b.Da(a)||hd(c,new D("child_removed",e,a))}),b.K()||b.P(N,function(b,e){if(a.Da(b)){var f=a.R(b);f.ca(e)||hd(c,new D("child_changed",e,b,f))}else hd(c,new D("child_added",e,b))}));return b.lb(this.g)};g.ga=function(a,b){return a.e()?C:a.ga(b)};g.Na=function(){return!1};g.Wb=function(){return this};function ld(a){this.Be=new kd(a.g);this.g=a.g;var b;a.ma?(b=md(a),b=a.g.Pc(nd(a),b)):b=a.g.Tc();this.ed=b;a.pa?(b=od(a),a=a.g.Pc(pd(a),b)):a=a.g.Qc();this.Gc=a}g=ld.prototype;g.matches=function(a){return 0>=this.g.compare(this.ed,a)&&0>=this.g.compare(a,this.Gc)};g.G=function(a,b,c,d,e,f){this.matches(new F(b,c))||(c=C);return this.Be.G(a,b,c,d,e,f)};
g.xa=function(a,b,c){b.K()&&(b=C);var d=b.lb(this.g),d=d.ga(C),e=this;b.P(N,function(a,b){e.matches(new F(a,b))||(d=d.U(a,C))});return this.Be.xa(a,d,c)};g.ga=function(a){return a};g.Na=function(){return!0};g.Wb=function(){return this.Be};function qd(a){this.sa=new ld(a);this.g=a.g;K(a.ja,"Only valid if limit has been set");this.ka=a.ka;this.Jb=!rd(a)}g=qd.prototype;g.G=function(a,b,c,d,e,f){this.sa.matches(new F(b,c))||(c=C);return a.R(b).ca(c)?a:a.Db()<this.ka?this.sa.Wb().G(a,b,c,d,e,f):sd(this,a,b,c,e,f)};
g.xa=function(a,b,c){var d;if(b.K()||b.e())d=C.lb(this.g);else if(2*this.ka<b.Db()&&b.Jc(this.g)){d=C.lb(this.g);b=this.Jb?b.$b(this.sa.Gc,this.g):b.Yb(this.sa.ed,this.g);for(var e=0;0<b.Pa.length&&e<this.ka;){var f=J(b),h;if(h=this.Jb?0>=this.g.compare(this.sa.ed,f):0>=this.g.compare(f,this.sa.Gc))d=d.U(f.name,f.S),e++;else break}}else{d=b.lb(this.g);d=d.ga(C);var k,l,m;if(this.Jb){b=d.sf(this.g);k=this.sa.Gc;l=this.sa.ed;var t=td(this.g);m=function(a,b){return t(b,a)}}else b=d.Xb(this.g),k=this.sa.ed,
l=this.sa.Gc,m=td(this.g);for(var e=0,z=!1;0<b.Pa.length;)f=J(b),!z&&0>=m(k,f)&&(z=!0),(h=z&&e<this.ka&&0>=m(f,l))?e++:d=d.U(f.name,C)}return this.sa.Wb().xa(a,d,c)};g.ga=function(a){return a};g.Na=function(){return!0};g.Wb=function(){return this.sa.Wb()};
function sd(a,b,c,d,e,f){var h;if(a.Jb){var k=td(a.g);h=function(a,b){return k(b,a)}}else h=td(a.g);K(b.Db()==a.ka,"");var l=new F(c,d),m=a.Jb?ud(b,a.g):vd(b,a.g),t=a.sa.matches(l);if(b.Da(c)){for(var z=b.R(c),m=e.ye(a.g,m,a.Jb);null!=m&&(m.name==c||b.Da(m.name));)m=e.ye(a.g,m,a.Jb);e=null==m?1:h(m,l);if(t&&!d.e()&&0<=e)return null!=f&&hd(f,new D("child_changed",d,c,z)),b.U(c,d);null!=f&&hd(f,new D("child_removed",z,c));b=b.U(c,C);return null!=m&&a.sa.matches(m)?(null!=f&&hd(f,new D("child_added",
m.S,m.name)),b.U(m.name,m.S)):b}return d.e()?b:t&&0<=h(m,l)?(null!=f&&(hd(f,new D("child_removed",m.S,m.name)),hd(f,new D("child_added",d,c))),b.U(c,d).U(m.name,C)):b};function wd(a,b){this.je=a;this.fg=b}function xd(a){this.V=a}
xd.prototype.ab=function(a,b,c,d){var e=new gd,f;if(b.type===Yb)b.source.we?c=yd(this,a,b.path,b.Ga,c,d,e):(K(b.source.pf,"Unknown source."),f=b.source.af||Jb(a.w())&&!b.path.e(),c=Ad(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===Bd)b.source.we?c=Cd(this,a,b.path,b.children,c,d,e):(K(b.source.pf,"Unknown source."),f=b.source.af||Jb(a.w()),c=Dd(this,a,b.path,b.children,c,d,f,e));else if(b.type===Ed)if(b.Vd)if(b=b.path,null!=c.tc(b))c=a;else{f=new rb(c,a,d);d=a.O.j();if(b.e()||".priority"===E(b))Ib(a.w())?
b=c.za(ub(a)):(b=a.w().j(),K(b instanceof R,"serverChildren would be complete if leaf node"),b=c.yc(b)),b=this.V.xa(d,b,e);else{var h=E(b),k=c.xc(h,a.w());null==k&&sb(a.w(),h)&&(k=d.R(h));b=null!=k?this.V.G(d,h,k,H(b),f,e):a.O.j().Da(h)?this.V.G(d,h,C,H(b),f,e):d;b.e()&&Ib(a.w())&&(d=c.za(ub(a)),d.K()&&(b=this.V.xa(b,d,e)))}d=Ib(a.w())||null!=c.tc(G);c=Fd(a,b,d,this.V.Na())}else c=Gd(this,a,b.path,b.Qb,c,d,e);else if(b.type===$b)d=b.path,b=a.w(),f=b.j(),h=b.ea||d.e(),c=Hd(this,new Id(a.O,new tb(f,
h,b.Ub)),d,c,qb,e);else throw Fc("Unknown operation type: "+b.type);e=ra(e.bb);d=c;b=d.O;b.ea&&(f=b.j().K()||b.j().e(),h=Jd(a),(0<e.length||!a.O.ea||f&&!b.j().ca(h)||!b.j().C().ca(h.C()))&&e.push(Eb(Jd(d))));return new wd(c,e)};
function Hd(a,b,c,d,e,f){var h=b.O;if(null!=d.tc(c))return b;var k;if(c.e())K(Ib(b.w()),"If change path is empty, we must have complete server data"),Jb(b.w())?(e=ub(b),d=d.yc(e instanceof R?e:C)):d=d.za(ub(b)),f=a.V.xa(b.O.j(),d,f);else{var l=E(c);if(".priority"==l)K(1==Kd(c),"Can't have a priority with additional path components"),f=h.j(),k=b.w().j(),d=d.ld(c,f,k),f=null!=d?a.V.ga(f,d):h.j();else{var m=H(c);sb(h,l)?(k=b.w().j(),d=d.ld(c,h.j(),k),d=null!=d?h.j().R(l).G(m,d):h.j().R(l)):d=d.xc(l,
b.w());f=null!=d?a.V.G(h.j(),l,d,m,e,f):h.j()}}return Fd(b,f,h.ea||c.e(),a.V.Na())}function Ad(a,b,c,d,e,f,h,k){var l=b.w();h=h?a.V:a.V.Wb();if(c.e())d=h.xa(l.j(),d,null);else if(h.Na()&&!l.Ub)d=l.j().G(c,d),d=h.xa(l.j(),d,null);else{var m=E(c);if(!Kb(l,c)&&1<Kd(c))return b;var t=H(c);d=l.j().R(m).G(t,d);d=".priority"==m?h.ga(l.j(),d):h.G(l.j(),m,d,t,qb,null)}l=l.ea||c.e();b=new Id(b.O,new tb(d,l,h.Na()));return Hd(a,b,c,e,new rb(e,b,f),k)}
function yd(a,b,c,d,e,f,h){var k=b.O;e=new rb(e,b,f);if(c.e())h=a.V.xa(b.O.j(),d,h),a=Fd(b,h,!0,a.V.Na());else if(f=E(c),".priority"===f)h=a.V.ga(b.O.j(),d),a=Fd(b,h,k.ea,k.Ub);else{c=H(c);var l=k.j().R(f);if(!c.e()){var m=e.qf(f);d=null!=m?".priority"===Ld(c)&&m.Q(c.parent()).e()?m:m.G(c,d):C}l.ca(d)?a=b:(h=a.V.G(k.j(),f,d,c,e,h),a=Fd(b,h,k.ea,a.V.Na()))}return a}
function Cd(a,b,c,d,e,f,h){var k=b;Md(d,function(d,m){var t=c.u(d);sb(b.O,E(t))&&(k=yd(a,k,t,m,e,f,h))});Md(d,function(d,m){var t=c.u(d);sb(b.O,E(t))||(k=yd(a,k,t,m,e,f,h))});return k}function Nd(a,b){Md(b,function(b,d){a=a.G(b,d)});return a}
function Dd(a,b,c,d,e,f,h,k){if(b.w().j().e()&&!Ib(b.w()))return b;var l=b;c=c.e()?d:Od(Pd,c,d);var m=b.w().j();c.children.ia(function(c,d){if(m.Da(c)){var I=b.w().j().R(c),I=Nd(I,d);l=Ad(a,l,new L(c),I,e,f,h,k)}});c.children.ia(function(c,d){var I=!sb(b.w(),c)&&null==d.value;m.Da(c)||I||(I=b.w().j().R(c),I=Nd(I,d),l=Ad(a,l,new L(c),I,e,f,h,k))});return l}
function Gd(a,b,c,d,e,f,h){if(null!=e.tc(c))return b;var k=Jb(b.w()),l=b.w();if(null!=d.value){if(c.e()&&l.ea||Kb(l,c))return Ad(a,b,c,l.j().Q(c),e,f,k,h);if(c.e()){var m=Pd;l.j().P(Qd,function(a,b){m=m.set(new L(a),b)});return Dd(a,b,c,m,e,f,k,h)}return b}m=Pd;Md(d,function(a){var b=c.u(a);Kb(l,b)&&(m=m.set(a,l.j().Q(b)))});return Dd(a,b,c,m,e,f,k,h)};function Rd(){}var Sd={};function td(a){return q(a.compare,a)}Rd.prototype.Ad=function(a,b){return 0!==this.compare(new F("[MIN_NAME]",a),new F("[MIN_NAME]",b))};Rd.prototype.Tc=function(){return Td};function Ud(a){K(!a.e()&&".priority"!==E(a),"Can't create PathIndex with empty path or .priority key");this.cc=a}ma(Ud,Rd);g=Ud.prototype;g.Ic=function(a){return!a.Q(this.cc).e()};g.compare=function(a,b){var c=a.S.Q(this.cc),d=b.S.Q(this.cc),c=c.Dc(d);return 0===c?Vb(a.name,b.name):c};
g.Pc=function(a,b){var c=M(a),c=C.G(this.cc,c);return new F(b,c)};g.Qc=function(){var a=C.G(this.cc,Vd);return new F("[MAX_NAME]",a)};g.toString=function(){return this.cc.slice().join("/")};function Wd(){}ma(Wd,Rd);g=Wd.prototype;g.compare=function(a,b){var c=a.S.C(),d=b.S.C(),c=c.Dc(d);return 0===c?Vb(a.name,b.name):c};g.Ic=function(a){return!a.C().e()};g.Ad=function(a,b){return!a.C().ca(b.C())};g.Tc=function(){return Td};g.Qc=function(){return new F("[MAX_NAME]",new tc("[PRIORITY-POST]",Vd))};
g.Pc=function(a,b){var c=M(a);return new F(b,new tc("[PRIORITY-POST]",c))};g.toString=function(){return".priority"};var N=new Wd;function Xd(){}ma(Xd,Rd);g=Xd.prototype;g.compare=function(a,b){return Vb(a.name,b.name)};g.Ic=function(){throw Fc("KeyIndex.isDefinedOn not expected to be called.");};g.Ad=function(){return!1};g.Tc=function(){return Td};g.Qc=function(){return new F("[MAX_NAME]",C)};g.Pc=function(a){K(p(a),"KeyIndex indexValue must always be a string.");return new F(a,C)};g.toString=function(){return".key"};
var Qd=new Xd;function Yd(){}ma(Yd,Rd);g=Yd.prototype;g.compare=function(a,b){var c=a.S.Dc(b.S);return 0===c?Vb(a.name,b.name):c};g.Ic=function(){return!0};g.Ad=function(a,b){return!a.ca(b)};g.Tc=function(){return Td};g.Qc=function(){return Zd};g.Pc=function(a,b){var c=M(a);return new F(b,c)};g.toString=function(){return".value"};var $d=new Yd;function ae(){this.Tb=this.pa=this.Lb=this.ma=this.ja=!1;this.ka=0;this.Nb="";this.ec=null;this.xb="";this.bc=null;this.vb="";this.g=N}var be=new ae;function rd(a){return""===a.Nb?a.ma:"l"===a.Nb}function nd(a){K(a.ma,"Only valid if start has been set");return a.ec}function md(a){K(a.ma,"Only valid if start has been set");return a.Lb?a.xb:"[MIN_NAME]"}function pd(a){K(a.pa,"Only valid if end has been set");return a.bc}
function od(a){K(a.pa,"Only valid if end has been set");return a.Tb?a.vb:"[MAX_NAME]"}function ce(a){var b=new ae;b.ja=a.ja;b.ka=a.ka;b.ma=a.ma;b.ec=a.ec;b.Lb=a.Lb;b.xb=a.xb;b.pa=a.pa;b.bc=a.bc;b.Tb=a.Tb;b.vb=a.vb;b.g=a.g;return b}g=ae.prototype;g.He=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="";return b};g.Ie=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="l";return b};g.Je=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="r";return b};
g.$d=function(a,b){var c=ce(this);c.ma=!0;n(a)||(a=null);c.ec=a;null!=b?(c.Lb=!0,c.xb=b):(c.Lb=!1,c.xb="");return c};g.td=function(a,b){var c=ce(this);c.pa=!0;n(a)||(a=null);c.bc=a;n(b)?(c.Tb=!0,c.vb=b):(c.ah=!1,c.vb="");return c};function de(a,b){var c=ce(a);c.g=b;return c}function ee(a){var b={};a.ma&&(b.sp=a.ec,a.Lb&&(b.sn=a.xb));a.pa&&(b.ep=a.bc,a.Tb&&(b.en=a.vb));if(a.ja){b.l=a.ka;var c=a.Nb;""===c&&(c=rd(a)?"l":"r");b.vf=c}a.g!==N&&(b.i=a.g.toString());return b}
function S(a){return!(a.ma||a.pa||a.ja)}function fe(a){return S(a)&&a.g==N}function ge(a){var b={};if(fe(a))return b;var c;a.g===N?c="$priority":a.g===$d?c="$value":a.g===Qd?c="$key":(K(a.g instanceof Ud,"Unrecognized index type!"),c=a.g.toString());b.orderBy=B(c);a.ma&&(b.startAt=B(a.ec),a.Lb&&(b.startAt+=","+B(a.xb)));a.pa&&(b.endAt=B(a.bc),a.Tb&&(b.endAt+=","+B(a.vb)));a.ja&&(rd(a)?b.limitToFirst=a.ka:b.limitToLast=a.ka);return b}g.toString=function(){return B(ee(this))};function he(a,b){this.Bd=a;this.dc=b}he.prototype.get=function(a){var b=w(this.Bd,a);if(!b)throw Error("No index defined for "+a);return b===Sd?null:b};function ie(a,b,c){var d=na(a.Bd,function(d,f){var h=w(a.dc,f);K(h,"Missing index implementation for "+f);if(d===Sd){if(h.Ic(b.S)){for(var k=[],l=c.Xb(Tb),m=J(l);m;)m.name!=b.name&&k.push(m),m=J(l);k.push(b);return je(k,td(h))}return Sd}h=c.get(b.name);k=d;h&&(k=k.remove(new F(b.name,h)));return k.Oa(b,b.S)});return new he(d,a.dc)}
function ke(a,b,c){var d=na(a.Bd,function(a){if(a===Sd)return a;var d=c.get(b.name);return d?a.remove(new F(b.name,d)):a});return new he(d,a.dc)}var le=new he({".priority":Sd},{".priority":N});function tc(a,b){this.B=a;K(n(this.B)&&null!==this.B,"LeafNode shouldn't be created with null/undefined value.");this.aa=b||C;me(this.aa);this.Cb=null}var ne=["object","boolean","number","string"];g=tc.prototype;g.K=function(){return!0};g.C=function(){return this.aa};g.ga=function(a){return new tc(this.B,a)};g.R=function(a){return".priority"===a?this.aa:C};g.Q=function(a){return a.e()?this:".priority"===E(a)?this.aa:C};g.Da=function(){return!1};g.rf=function(){return null};
g.U=function(a,b){return".priority"===a?this.ga(b):b.e()&&".priority"!==a?this:C.U(a,b).ga(this.aa)};g.G=function(a,b){var c=E(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;K(".priority"!==c||1===Kd(a),".priority must be the last token in a path");return this.U(c,C.G(H(a),b))};g.e=function(){return!1};g.Db=function(){return 0};g.P=function(){return!1};g.I=function(a){return a&&!this.C().e()?{".value":this.Ca(),".priority":this.C().I()}:this.Ca()};
g.hash=function(){if(null===this.Cb){var a="";this.aa.e()||(a+="priority:"+oe(this.aa.I())+":");var b=typeof this.B,a=a+(b+":"),a="number"===b?a+Xc(this.B):a+this.B;this.Cb=Hc(a)}return this.Cb};g.Ca=function(){return this.B};g.Dc=function(a){if(a===C)return 1;if(a instanceof R)return-1;K(a.K(),"Unknown node type");var b=typeof a.B,c=typeof this.B,d=Na(ne,b),e=Na(ne,c);K(0<=d,"Unknown leaf type: "+b);K(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.B<a.B?-1:this.B===a.B?0:1:e-d};
g.lb=function(){return this};g.Jc=function(){return!0};g.ca=function(a){return a===this?!0:a.K()?this.B===a.B&&this.aa.ca(a.aa):!1};g.toString=function(){return B(this.I(!0))};function R(a,b,c){this.m=a;(this.aa=b)&&me(this.aa);a.e()&&K(!this.aa||this.aa.e(),"An empty node cannot have a priority");this.wb=c;this.Cb=null}g=R.prototype;g.K=function(){return!1};g.C=function(){return this.aa||C};g.ga=function(a){return this.m.e()?this:new R(this.m,a,this.wb)};g.R=function(a){if(".priority"===a)return this.C();a=this.m.get(a);return null===a?C:a};g.Q=function(a){var b=E(a);return null===b?this:this.R(b).Q(H(a))};g.Da=function(a){return null!==this.m.get(a)};
g.U=function(a,b){K(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.ga(b);var c=new F(a,b),d,e;b.e()?(d=this.m.remove(a),c=ke(this.wb,c,this.m)):(d=this.m.Oa(a,b),c=ie(this.wb,c,this.m));e=d.e()?C:this.aa;return new R(d,e,c)};g.G=function(a,b){var c=E(a);if(null===c)return b;K(".priority"!==E(a)||1===Kd(a),".priority must be the last token in a path");var d=this.R(c).G(H(a),b);return this.U(c,d)};g.e=function(){return this.m.e()};g.Db=function(){return this.m.count()};
var pe=/^(0|[1-9]\d*)$/;g=R.prototype;g.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.P(N,function(f,h){b[f]=h.I(a);c++;e&&pe.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],h;for(h in b)f[h]=b[h];return f}a&&!this.C().e()&&(b[".priority"]=this.C().I());return b};g.hash=function(){if(null===this.Cb){var a="";this.C().e()||(a+="priority:"+oe(this.C().I())+":");this.P(N,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.Cb=""===a?"":Hc(a)}return this.Cb};
g.rf=function(a,b,c){return(c=qe(this,c))?(a=cc(c,new F(a,b)))?a.name:null:cc(this.m,a)};function ud(a,b){var c;c=(c=qe(a,b))?(c=c.Sc())&&c.name:a.m.Sc();return c?new F(c,a.m.get(c)):null}function vd(a,b){var c;c=(c=qe(a,b))?(c=c.fc())&&c.name:a.m.fc();return c?new F(c,a.m.get(c)):null}g.P=function(a,b){var c=qe(this,a);return c?c.ia(function(a){return b(a.name,a.S)}):this.m.ia(b)};g.Xb=function(a){return this.Yb(a.Tc(),a)};
g.Yb=function(a,b){var c=qe(this,b);if(c)return c.Yb(a,function(a){return a});for(var c=this.m.Yb(a.name,Tb),d=ec(c);null!=d&&0>b.compare(d,a);)J(c),d=ec(c);return c};g.sf=function(a){return this.$b(a.Qc(),a)};g.$b=function(a,b){var c=qe(this,b);if(c)return c.$b(a,function(a){return a});for(var c=this.m.$b(a.name,Tb),d=ec(c);null!=d&&0<b.compare(d,a);)J(c),d=ec(c);return c};g.Dc=function(a){return this.e()?a.e()?0:-1:a.K()||a.e()?1:a===Vd?-1:0};
g.lb=function(a){if(a===Qd||ta(this.wb.dc,a.toString()))return this;var b=this.wb,c=this.m;K(a!==Qd,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Xb(Tb),f=J(c);f;)e=e||a.Ic(f.S),d.push(f),f=J(c);d=e?je(d,td(a)):Sd;e=a.toString();c=xa(b.dc);c[e]=a;a=xa(b.Bd);a[e]=d;return new R(this.m,this.aa,new he(a,c))};g.Jc=function(a){return a===Qd||ta(this.wb.dc,a.toString())};
g.ca=function(a){if(a===this)return!0;if(a.K())return!1;if(this.C().ca(a.C())&&this.m.count()===a.m.count()){var b=this.Xb(N);a=a.Xb(N);for(var c=J(b),d=J(a);c&&d;){if(c.name!==d.name||!c.S.ca(d.S))return!1;c=J(b);d=J(a)}return null===c&&null===d}return!1};function qe(a,b){return b===Qd?null:a.wb.get(b.toString())}g.toString=function(){return B(this.I(!0))};function M(a,b){if(null===a)return C;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);K(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new tc(a,M(c));if(a instanceof Array){var d=C,e=a;r(e,function(a,b){if(v(e,b)&&"."!==b.substring(0,1)){var c=M(a);if(c.K()||!c.e())d=
d.U(b,c)}});return d.ga(M(c))}var f=[],h=!1,k=a;ib(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=M(k[a]);b.e()||(h=h||!b.C().e(),f.push(new F(a,b)))}});if(0==f.length)return C;var l=je(f,Ub,function(a){return a.name},Wb);if(h){var m=je(f,td(N));return new R(l,M(c),new he({".priority":m},{".priority":N}))}return new R(l,M(c),le)}var re=Math.log(2);
function se(a){this.count=parseInt(Math.log(a+1)/re,10);this.jf=this.count-1;this.eg=a+1&parseInt(Array(this.count+1).join("1"),2)}function te(a){var b=!(a.eg&1<<a.jf);a.jf--;return b}
function je(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var m=a[b],t=c?c(m):m;return new fc(t,m.S,!1,null,null)}var m=parseInt(f/2,10)+b,f=e(b,m),z=e(m+1,d),m=a[m],t=c?c(m):m;return new fc(t,m.S,!1,f,z)}a.sort(b);var f=function(b){function d(b,h){var k=t-b,z=t;t-=b;var z=e(k+1,z),k=a[k],I=c?c(k):k,z=new fc(I,k.S,h,null,z);f?f.left=z:m=z;f=z}for(var f=null,m=null,t=a.length,z=0;z<b.count;++z){var I=te(b),zd=Math.pow(2,b.count-(z+1));I?d(zd,!1):(d(zd,!1),d(zd,!0))}return m}(new se(a.length));
return null!==f?new ac(d||b,f):new ac(d||b)}function oe(a){return"number"===typeof a?"number:"+Xc(a):"string:"+a}function me(a){if(a.K()){var b=a.I();K("string"===typeof b||"number"===typeof b||"object"===typeof b&&v(b,".sv"),"Priority must be a string or number.")}else K(a===Vd||a.e(),"priority of unexpected type.");K(a===Vd||a.C().e(),"Priority nodes can't have a priority of their own.")}var C=new R(new ac(Wb),null,le);function ue(){R.call(this,new ac(Wb),C,le)}ma(ue,R);g=ue.prototype;
g.Dc=function(a){return a===this?0:1};g.ca=function(a){return a===this};g.C=function(){return this};g.R=function(){return C};g.e=function(){return!1};var Vd=new ue,Td=new F("[MIN_NAME]",C),Zd=new F("[MAX_NAME]",Vd);function Id(a,b){this.O=a;this.Yd=b}function Fd(a,b,c,d){return new Id(new tb(b,c,d),a.Yd)}function Jd(a){return a.O.ea?a.O.j():null}Id.prototype.w=function(){return this.Yd};function ub(a){return a.Yd.ea?a.Yd.j():null};function ve(a,b){this.W=a;var c=a.n,d=new kd(c.g),c=S(c)?new kd(c.g):c.ja?new qd(c):new ld(c);this.Hf=new xd(c);var e=b.w(),f=b.O,h=d.xa(C,e.j(),null),k=c.xa(C,f.j(),null);this.Ka=new Id(new tb(k,f.ea,c.Na()),new tb(h,e.ea,d.Na()));this.Xa=[];this.lg=new cd(a)}function we(a){return a.W}g=ve.prototype;g.w=function(){return this.Ka.w().j()};g.fb=function(a){var b=ub(this.Ka);return b&&(S(this.W.n)||!a.e()&&!b.R(E(a)).e())?b.Q(a):null};g.e=function(){return 0===this.Xa.length};g.Pb=function(a){this.Xa.push(a)};
g.jb=function(a,b){var c=[];if(b){K(null==a,"A cancel should cancel all event registrations.");var d=this.W.path;Oa(this.Xa,function(a){(a=a.gf(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Xa.length;++f){var h=this.Xa[f];if(!h.matches(a))e.push(h);else if(a.tf()){e=e.concat(this.Xa.slice(f+1));break}}this.Xa=e}else this.Xa=[];return c};
g.ab=function(a,b,c){a.type===Bd&&null!==a.source.Hb&&(K(ub(this.Ka),"We should always have a full cache before handling merges"),K(Jd(this.Ka),"Missing event cache, even though we have a server cache"));var d=this.Ka;a=this.Hf.ab(d,a,b,c);b=this.Hf;c=a.je;K(c.O.j().Jc(b.V.g),"Event snap not indexed");K(c.w().j().Jc(b.V.g),"Server snap not indexed");K(Ib(a.je.w())||!Ib(d.w()),"Once a server snap is complete, it should never go back");this.Ka=a.je;return xe(this,a.fg,a.je.O.j(),null)};
function ye(a,b){var c=a.Ka.O,d=[];c.j().K()||c.j().P(N,function(a,b){d.push(new D("child_added",b,a))});c.ea&&d.push(Eb(c.j()));return xe(a,d,c.j(),b)}function xe(a,b,c,d){return dd(a.lg,b,c,d?[d]:a.Xa)};function ze(a,b,c){this.type=Bd;this.source=a;this.path=b;this.children=c}ze.prototype.Xc=function(a){if(this.path.e())return a=this.children.subtree(new L(a)),a.e()?null:a.value?new Xb(this.source,G,a.value):new ze(this.source,G,a);K(E(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new ze(this.source,H(this.path),this.children)};ze.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};function Ae(a,b){this.f=Mc("p:rest:");this.F=a;this.Gb=b;this.Aa=null;this.$={}}function Be(a,b){if(n(b))return"tag$"+b;K(fe(a.n),"should have a tag if it's not a default query.");return a.path.toString()}g=Ae.prototype;
g.yf=function(a,b,c,d){var e=a.path.toString();this.f("Listen called for "+e+" "+a.va());var f=Be(a,c),h={};this.$[f]=h;a=ge(a.n);var k=this;Ce(this,e+".json",a,function(a,b){var t=b;404===a&&(a=t=null);null===a&&k.Gb(e,t,!1,c);w(k.$,f)===h&&d(a?401==a?"permission_denied":"rest_error:"+a:"ok",null)})};g.Rf=function(a,b){var c=Be(a,b);delete this.$[c]};g.M=function(a,b){this.Aa=a;var c=$c(a),d=c.data,c=c.Bc&&c.Bc.exp;b&&b("ok",{auth:d,expires:c})};g.ge=function(a){this.Aa=null;a("ok",null)};g.Me=function(){};
g.Cf=function(){};g.Jd=function(){};g.put=function(){};g.zf=function(){};g.Ue=function(){};
function Ce(a,b,c,d){c=c||{};c.format="export";a.Aa&&(c.auth=a.Aa);var e=(a.F.kb?"https://":"http://")+a.F.host+b+"?"+kb(c);a.f("Sending REST request for "+e);var f=new XMLHttpRequest;f.onreadystatechange=function(){if(d&&4===f.readyState){a.f("REST Response for "+e+" received. status:",f.status,"response:",f.responseText);var b=null;if(200<=f.status&&300>f.status){try{b=nb(f.responseText)}catch(c){O("Failed to parse JSON response for "+e+": "+f.responseText)}d(null,b)}else 401!==f.status&&404!==
f.status&&O("Got unsuccessful REST response for "+e+" Status: "+f.status),d(f.status);d=null}};f.open("GET",e,!0);f.send()};function De(a){K(ea(a)&&0<a.length,"Requires a non-empty array");this.Xf=a;this.Oc={}}De.prototype.fe=function(a,b){var c;c=this.Oc[a]||[];var d=c.length;if(0<d){for(var e=Array(d),f=0;f<d;f++)e[f]=c[f];c=e}else c=[];for(d=0;d<c.length;d++)c[d].zc.apply(c[d].Ma,Array.prototype.slice.call(arguments,1))};De.prototype.Eb=function(a,b,c){Ee(this,a);this.Oc[a]=this.Oc[a]||[];this.Oc[a].push({zc:b,Ma:c});(a=this.Ae(a))&&b.apply(c,a)};
De.prototype.ic=function(a,b,c){Ee(this,a);a=this.Oc[a]||[];for(var d=0;d<a.length;d++)if(a[d].zc===b&&(!c||c===a[d].Ma)){a.splice(d,1);break}};function Ee(a,b){K(Ta(a.Xf,function(a){return a===b}),"Unknown event: "+b)};var Fe=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);K(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);K(20===c.length,"nextPushId: Length should be 20.");
return c}}();function Ge(){De.call(this,["online"]);this.kc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.kc||(a.kc=!0,a.fe("online",!0))},!1);window.addEventListener("offline",function(){a.kc&&(a.kc=!1,a.fe("online",!1))},!1)}}ma(Ge,De);Ge.prototype.Ae=function(a){K("online"===a,"Unknown event type: "+a);return[this.kc]};ca(Ge);function He(){De.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.Ob=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.Ob&&(c.Ob=b,c.fe("visible",b))},!1)}}ma(He,De);He.prototype.Ae=function(a){K("visible"===a,"Unknown event type: "+a);return[this.Ob]};ca(He);function L(a,b){if(1==arguments.length){this.o=a.split("/");for(var c=0,d=0;d<this.o.length;d++)0<this.o[d].length&&(this.o[c]=this.o[d],c++);this.o.length=c;this.Z=0}else this.o=a,this.Z=b}function T(a,b){var c=E(a);if(null===c)return b;if(c===E(b))return T(H(a),H(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
function Ie(a,b){for(var c=a.slice(),d=b.slice(),e=0;e<c.length&&e<d.length;e++){var f=Vb(c[e],d[e]);if(0!==f)return f}return c.length===d.length?0:c.length<d.length?-1:1}function E(a){return a.Z>=a.o.length?null:a.o[a.Z]}function Kd(a){return a.o.length-a.Z}function H(a){var b=a.Z;b<a.o.length&&b++;return new L(a.o,b)}function Ld(a){return a.Z<a.o.length?a.o[a.o.length-1]:null}g=L.prototype;
g.toString=function(){for(var a="",b=this.Z;b<this.o.length;b++)""!==this.o[b]&&(a+="/"+this.o[b]);return a||"/"};g.slice=function(a){return this.o.slice(this.Z+(a||0))};g.parent=function(){if(this.Z>=this.o.length)return null;for(var a=[],b=this.Z;b<this.o.length-1;b++)a.push(this.o[b]);return new L(a,0)};
g.u=function(a){for(var b=[],c=this.Z;c<this.o.length;c++)b.push(this.o[c]);if(a instanceof L)for(c=a.Z;c<a.o.length;c++)b.push(a.o[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new L(b,0)};g.e=function(){return this.Z>=this.o.length};g.ca=function(a){if(Kd(this)!==Kd(a))return!1;for(var b=this.Z,c=a.Z;b<=this.o.length;b++,c++)if(this.o[b]!==a.o[c])return!1;return!0};
g.contains=function(a){var b=this.Z,c=a.Z;if(Kd(this)>Kd(a))return!1;for(;b<this.o.length;){if(this.o[b]!==a.o[c])return!1;++b;++c}return!0};var G=new L("");function Je(a,b){this.Qa=a.slice();this.Ha=Math.max(1,this.Qa.length);this.lf=b;for(var c=0;c<this.Qa.length;c++)this.Ha+=Zc(this.Qa[c]);Ke(this)}Je.prototype.push=function(a){0<this.Qa.length&&(this.Ha+=1);this.Qa.push(a);this.Ha+=Zc(a);Ke(this)};Je.prototype.pop=function(){var a=this.Qa.pop();this.Ha-=Zc(a);0<this.Qa.length&&--this.Ha};
function Ke(a){if(768<a.Ha)throw Error(a.lf+"has a key path longer than 768 bytes ("+a.Ha+").");if(32<a.Qa.length)throw Error(a.lf+"path specified exceeds the maximum depth that can be written (32) or object contains a cycle "+Le(a));}function Le(a){return 0==a.Qa.length?"":"in property '"+a.Qa.join(".")+"'"};function Me(a,b){this.value=a;this.children=b||Ne}var Ne=new ac(function(a,b){return a===b?0:a<b?-1:1});function Oe(a){var b=Pd;r(a,function(a,d){b=b.set(new L(d),a)});return b}g=Me.prototype;g.e=function(){return null===this.value&&this.children.e()};function Pe(a,b,c){if(null!=a.value&&c(a.value))return{path:G,value:a.value};if(b.e())return null;var d=E(b);a=a.children.get(d);return null!==a?(b=Pe(a,H(b),c),null!=b?{path:(new L(d)).u(b.path),value:b.value}:null):null}
function Qe(a,b){return Pe(a,b,function(){return!0})}g.subtree=function(a){if(a.e())return this;var b=this.children.get(E(a));return null!==b?b.subtree(H(a)):Pd};g.set=function(a,b){if(a.e())return new Me(b,this.children);var c=E(a),d=(this.children.get(c)||Pd).set(H(a),b),c=this.children.Oa(c,d);return new Me(this.value,c)};
g.remove=function(a){if(a.e())return this.children.e()?Pd:new Me(null,this.children);var b=E(a),c=this.children.get(b);return c?(a=c.remove(H(a)),b=a.e()?this.children.remove(b):this.children.Oa(b,a),null===this.value&&b.e()?Pd:new Me(this.value,b)):this};g.get=function(a){if(a.e())return this.value;var b=this.children.get(E(a));return b?b.get(H(a)):null};
function Od(a,b,c){if(b.e())return c;var d=E(b);b=Od(a.children.get(d)||Pd,H(b),c);d=b.e()?a.children.remove(d):a.children.Oa(d,b);return new Me(a.value,d)}function Re(a,b){return Se(a,G,b)}function Se(a,b,c){var d={};a.children.ia(function(a,f){d[a]=Se(f,b.u(a),c)});return c(b,a.value,d)}function Te(a,b,c){return Ue(a,b,G,c)}function Ue(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=E(b);return(a=a.children.get(e))?Ue(a,H(b),c.u(e),d):null}
function Ve(a,b,c){var d=G;if(!b.e()){var e=!0;a.value&&(e=c(d,a.value));!0===e&&(e=E(b),(a=a.children.get(e))&&We(a,H(b),d.u(e),c))}}function We(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=E(b);return(a=a.children.get(e))?We(a,H(b),c.u(e),d):Pd}function Md(a,b){Xe(a,G,b)}function Xe(a,b,c){a.children.ia(function(a,e){Xe(e,b.u(a),c)});a.value&&c(b,a.value)}function Ye(a,b){a.children.ia(function(a,d){d.value&&b(a,d.value)})}var Pd=new Me(null);
Me.prototype.toString=function(){var a={};Md(this,function(b,c){a[b.toString()]=c.toString()});return B(a)};function Ze(a,b,c){this.type=Ed;this.source=$e;this.path=a;this.Qb=b;this.Vd=c}Ze.prototype.Xc=function(a){if(this.path.e()){if(null!=this.Qb.value)return K(this.Qb.children.e(),"affectedTree should not have overlapping affected paths."),this;a=this.Qb.subtree(new L(a));return new Ze(G,a,this.Vd)}K(E(this.path)===a,"operationForChild called for unrelated child.");return new Ze(H(this.path),this.Qb,this.Vd)};
Ze.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Vd+" affectedTree="+this.Qb+")"};var Yb=0,Bd=1,Ed=2,$b=3;function af(a,b,c,d){this.we=a;this.pf=b;this.Hb=c;this.af=d;K(!d||b,"Tagged queries must be from server.")}var $e=new af(!0,!1,null,!1),bf=new af(!1,!0,null,!1);af.prototype.toString=function(){return this.we?"user":this.af?"server(queryID="+this.Hb+")":"server"};function cf(a){this.X=a}var df=new cf(new Me(null));function ef(a,b,c){if(b.e())return new cf(new Me(c));var d=Qe(a.X,b);if(null!=d){var e=d.path,d=d.value;b=T(e,b);d=d.G(b,c);return new cf(a.X.set(e,d))}a=Od(a.X,b,new Me(c));return new cf(a)}function ff(a,b,c){var d=a;ib(c,function(a,c){d=ef(d,b.u(a),c)});return d}cf.prototype.Rd=function(a){if(a.e())return df;a=Od(this.X,a,Pd);return new cf(a)};function gf(a,b){var c=Qe(a.X,b);return null!=c?a.X.get(c.path).Q(T(c.path,b)):null}
function hf(a){var b=[],c=a.X.value;null!=c?c.K()||c.P(N,function(a,c){b.push(new F(a,c))}):a.X.children.ia(function(a,c){null!=c.value&&b.push(new F(a,c.value))});return b}function jf(a,b){if(b.e())return a;var c=gf(a,b);return null!=c?new cf(new Me(c)):new cf(a.X.subtree(b))}cf.prototype.e=function(){return this.X.e()};cf.prototype.apply=function(a){return kf(G,this.X,a)};
function kf(a,b,c){if(null!=b.value)return c.G(a,b.value);var d=null;b.children.ia(function(b,f){".priority"===b?(K(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=kf(a.u(b),f,c)});c.Q(a).e()||null===d||(c=c.G(a.u(".priority"),d));return c};function lf(){this.T=df;this.na=[];this.Mc=-1}function mf(a,b){for(var c=0;c<a.na.length;c++){var d=a.na[c];if(d.kd===b)return d}return null}g=lf.prototype;
g.Rd=function(a){var b=Ua(this.na,function(b){return b.kd===a});K(0<=b,"removeWrite called with nonexistent writeId.");var c=this.na[b];this.na.splice(b,1);for(var d=c.visible,e=!1,f=this.na.length-1;d&&0<=f;){var h=this.na[f];h.visible&&(f>=b&&nf(h,c.path)?d=!1:c.path.contains(h.path)&&(e=!0));f--}if(d){if(e)this.T=of(this.na,pf,G),this.Mc=0<this.na.length?this.na[this.na.length-1].kd:-1;else if(c.Ga)this.T=this.T.Rd(c.path);else{var k=this;r(c.children,function(a,b){k.T=k.T.Rd(c.path.u(b))})}return!0}return!1};
g.za=function(a,b,c,d){if(c||d){var e=jf(this.T,a);return!d&&e.e()?b:d||null!=b||null!=gf(e,G)?(e=of(this.na,function(b){return(b.visible||d)&&(!c||!(0<=Na(c,b.kd)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||C,e.apply(b)):null}e=gf(this.T,a);if(null!=e)return e;e=jf(this.T,a);return e.e()?b:null!=b||null!=gf(e,G)?(b=b||C,e.apply(b)):null};
g.yc=function(a,b){var c=C,d=gf(this.T,a);if(d)d.K()||d.P(N,function(a,b){c=c.U(a,b)});else if(b){var e=jf(this.T,a);b.P(N,function(a,b){var d=jf(e,new L(a)).apply(b);c=c.U(a,d)});Oa(hf(e),function(a){c=c.U(a.name,a.S)})}else e=jf(this.T,a),Oa(hf(e),function(a){c=c.U(a.name,a.S)});return c};g.ld=function(a,b,c,d){K(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.u(b);if(null!=gf(this.T,a))return null;a=jf(this.T,a);return a.e()?d.Q(b):a.apply(d.Q(b))};
g.xc=function(a,b,c){a=a.u(b);var d=gf(this.T,a);return null!=d?d:sb(c,b)?jf(this.T,a).apply(c.j().R(b)):null};g.tc=function(a){return gf(this.T,a)};g.ne=function(a,b,c,d,e,f){var h;a=jf(this.T,a);h=gf(a,G);if(null==h)if(null!=b)h=a.apply(b);else return[];h=h.lb(f);if(h.e()||h.K())return[];b=[];a=td(f);e=e?h.$b(c,f):h.Yb(c,f);for(f=J(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=J(e);return b};
function nf(a,b){return a.Ga?a.path.contains(b):!!ua(a.children,function(c,d){return a.path.u(d).contains(b)})}function pf(a){return a.visible}
function of(a,b,c){for(var d=df,e=0;e<a.length;++e){var f=a[e];if(b(f)){var h=f.path;if(f.Ga)c.contains(h)?(h=T(c,h),d=ef(d,h,f.Ga)):h.contains(c)&&(h=T(h,c),d=ef(d,G,f.Ga.Q(h)));else if(f.children)if(c.contains(h))h=T(c,h),d=ff(d,h,f.children);else{if(h.contains(c))if(h=T(h,c),h.e())d=ff(d,G,f.children);else if(f=w(f.children,E(h)))f=f.Q(H(h)),d=ef(d,G,f)}else throw Fc("WriteRecord should have .snap or .children");}}return d}function qf(a,b){this.Mb=a;this.X=b}g=qf.prototype;
g.za=function(a,b,c){return this.X.za(this.Mb,a,b,c)};g.yc=function(a){return this.X.yc(this.Mb,a)};g.ld=function(a,b,c){return this.X.ld(this.Mb,a,b,c)};g.tc=function(a){return this.X.tc(this.Mb.u(a))};g.ne=function(a,b,c,d,e){return this.X.ne(this.Mb,a,b,c,d,e)};g.xc=function(a,b){return this.X.xc(this.Mb,a,b)};g.u=function(a){return new qf(this.Mb.u(a),this.X)};function rf(){this.ya={}}g=rf.prototype;g.e=function(){return wa(this.ya)};g.ab=function(a,b,c){var d=a.source.Hb;if(null!==d)return d=w(this.ya,d),K(null!=d,"SyncTree gave us an op for an invalid query."),d.ab(a,b,c);var e=[];r(this.ya,function(d){e=e.concat(d.ab(a,b,c))});return e};g.Pb=function(a,b,c,d,e){var f=a.va(),h=w(this.ya,f);if(!h){var h=c.za(e?d:null),k=!1;h?k=!0:(h=d instanceof R?c.yc(d):C,k=!1);h=new ve(a,new Id(new tb(h,k,!1),new tb(d,e,!1)));this.ya[f]=h}h.Pb(b);return ye(h,b)};
g.jb=function(a,b,c){var d=a.va(),e=[],f=[],h=null!=sf(this);if("default"===d){var k=this;r(this.ya,function(a,d){f=f.concat(a.jb(b,c));a.e()&&(delete k.ya[d],S(a.W.n)||e.push(a.W))})}else{var l=w(this.ya,d);l&&(f=f.concat(l.jb(b,c)),l.e()&&(delete this.ya[d],S(l.W.n)||e.push(l.W)))}h&&null==sf(this)&&e.push(new U(a.k,a.path));return{Kg:e,mg:f}};function tf(a){return Pa(ra(a.ya),function(a){return!S(a.W.n)})}g.fb=function(a){var b=null;r(this.ya,function(c){b=b||c.fb(a)});return b};
function uf(a,b){if(S(b.n))return sf(a);var c=b.va();return w(a.ya,c)}function sf(a){return va(a.ya,function(a){return S(a.W.n)})||null};function vf(a){this.ta=Pd;this.ib=new lf;this.$e={};this.mc={};this.Nc=a}function wf(a,b,c,d,e){var f=a.ib,h=e;K(d>f.Mc,"Stacking an older write on top of newer ones");n(h)||(h=!0);f.na.push({path:b,Ga:c,kd:d,visible:h});h&&(f.T=ef(f.T,b,c));f.Mc=d;return e?xf(a,new Xb($e,b,c)):[]}function yf(a,b,c,d){var e=a.ib;K(d>e.Mc,"Stacking an older merge on top of newer ones");e.na.push({path:b,children:c,kd:d,visible:!0});e.T=ff(e.T,b,c);e.Mc=d;c=Oe(c);return xf(a,new ze($e,b,c))}
function zf(a,b,c){c=c||!1;var d=mf(a.ib,b);if(a.ib.Rd(b)){var e=Pd;null!=d.Ga?e=e.set(G,!0):ib(d.children,function(a,b){e=e.set(new L(a),b)});return xf(a,new Ze(d.path,e,c))}return[]}function Af(a,b,c){c=Oe(c);return xf(a,new ze(bf,b,c))}function Bf(a,b,c,d){d=Cf(a,d);if(null!=d){var e=Df(d);d=e.path;e=e.Hb;b=T(d,b);c=new Xb(new af(!1,!0,e,!0),b,c);return Ef(a,d,c)}return[]}
function Ff(a,b,c,d){if(d=Cf(a,d)){var e=Df(d);d=e.path;e=e.Hb;b=T(d,b);c=Oe(c);c=new ze(new af(!1,!0,e,!0),b,c);return Ef(a,d,c)}return[]}
vf.prototype.Pb=function(a,b){var c=a.path,d=null,e=!1;Ve(this.ta,c,function(a,b){var f=T(a,c);d=b.fb(f);e=e||null!=sf(b);return!d});var f=this.ta.get(c);f?(e=e||null!=sf(f),d=d||f.fb(G)):(f=new rf,this.ta=this.ta.set(c,f));var h;null!=d?h=!0:(h=!1,d=C,Ye(this.ta.subtree(c),function(a,b){var c=b.fb(G);c&&(d=d.U(a,c))}));var k=null!=uf(f,a);if(!k&&!S(a.n)){var l=Gf(a);K(!(l in this.mc),"View does not exist, but we have a tag");var m=Hf++;this.mc[l]=m;this.$e["_"+m]=l}h=f.Pb(a,b,new qf(c,this.ib),d,
h);k||e||(f=uf(f,a),h=h.concat(If(this,a,f)));return h};
vf.prototype.jb=function(a,b,c){var d=a.path,e=this.ta.get(d),f=[];if(e&&("default"===a.va()||null!=uf(e,a))){f=e.jb(a,b,c);e.e()&&(this.ta=this.ta.remove(d));e=f.Kg;f=f.mg;b=-1!==Ua(e,function(a){return S(a.n)});var h=Te(this.ta,d,function(a,b){return null!=sf(b)});if(b&&!h&&(d=this.ta.subtree(d),!d.e()))for(var d=Jf(d),k=0;k<d.length;++k){var l=d[k],m=l.W,l=Kf(this,l);this.Nc.Xe(Lf(m),Mf(this,m),l.xd,l.H)}if(!h&&0<e.length&&!c)if(b)this.Nc.ae(Lf(a),null);else{var t=this;Oa(e,function(a){a.va();
var b=t.mc[Gf(a)];t.Nc.ae(Lf(a),b)})}Nf(this,e)}return f};vf.prototype.za=function(a,b){var c=this.ib,d=Te(this.ta,a,function(b,c){var d=T(b,a);if(d=c.fb(d))return d});return c.za(a,d,b,!0)};function Jf(a){return Re(a,function(a,c,d){if(c&&null!=sf(c))return[sf(c)];var e=[];c&&(e=tf(c));r(d,function(a){e=e.concat(a)});return e})}function Nf(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!S(d.n)){var d=Gf(d),e=a.mc[d];delete a.mc[d];delete a.$e["_"+e]}}}
function Lf(a){return S(a.n)&&!fe(a.n)?a.Ib():a}function If(a,b,c){var d=b.path,e=Mf(a,b);c=Kf(a,c);b=a.Nc.Xe(Lf(b),e,c.xd,c.H);d=a.ta.subtree(d);if(e)K(null==sf(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=Re(d,function(a,b,c){if(!a.e()&&b&&null!=sf(b))return[we(sf(b))];var d=[];b&&(d=d.concat(Qa(tf(b),function(a){return a.W})));r(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Nc.ae(Lf(c),Mf(a,c));return b}
function Kf(a,b){var c=b.W,d=Mf(a,c);return{xd:function(){return(b.w()||C).hash()},H:function(b){if("ok"===b){if(d){var f=c.path;if(b=Cf(a,d)){var h=Df(b);b=h.path;h=h.Hb;f=T(b,f);f=new Zb(new af(!1,!0,h,!0),f);b=Ef(a,b,f)}else b=[]}else b=xf(a,new Zb(bf,c.path));return b}f="Unknown Error";"too_big"===b?f="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?f="Client doesn't have permission to access the desired data.":"unavailable"==b&&
(f="The service is unavailable");f=Error(b+": "+f);f.code=b.toUpperCase();return a.jb(c,null,f)}}}function Gf(a){return a.path.toString()+"$"+a.va()}function Df(a){var b=a.indexOf("$");K(-1!==b&&b<a.length-1,"Bad queryKey.");return{Hb:a.substr(b+1),path:new L(a.substr(0,b))}}function Cf(a,b){var c=a.$e,d="_"+b;return d in c?c[d]:void 0}function Mf(a,b){var c=Gf(b);return w(a.mc,c)}var Hf=1;
function Ef(a,b,c){var d=a.ta.get(b);K(d,"Missing sync point for query tag that we're tracking");return d.ab(c,new qf(b,a.ib),null)}function xf(a,b){return Of(a,b,a.ta,null,new qf(G,a.ib))}function Of(a,b,c,d,e){if(b.path.e())return Pf(a,b,c,d,e);var f=c.get(G);null==d&&null!=f&&(d=f.fb(G));var h=[],k=E(b.path),l=b.Xc(k);if((c=c.children.get(k))&&l)var m=d?d.R(k):null,k=e.u(k),h=h.concat(Of(a,l,c,m,k));f&&(h=h.concat(f.ab(b,e,d)));return h}
function Pf(a,b,c,d,e){var f=c.get(G);null==d&&null!=f&&(d=f.fb(G));var h=[];c.children.ia(function(c,f){var m=d?d.R(c):null,t=e.u(c),z=b.Xc(c);z&&(h=h.concat(Pf(a,z,f,m,t)))});f&&(h=h.concat(f.ab(b,e,d)));return h};function Qf(){this.children={};this.nd=0;this.value=null}function Rf(a,b,c){this.Gd=a?a:"";this.Zc=b?b:null;this.A=c?c:new Qf}function Sf(a,b){for(var c=b instanceof L?b:new L(b),d=a,e;null!==(e=E(c));)d=new Rf(e,d,w(d.A.children,e)||new Qf),c=H(c);return d}g=Rf.prototype;g.Ca=function(){return this.A.value};function Tf(a,b){K("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Uf(a)}g.clear=function(){this.A.value=null;this.A.children={};this.A.nd=0;Uf(this)};
g.wd=function(){return 0<this.A.nd};g.e=function(){return null===this.Ca()&&!this.wd()};g.P=function(a){var b=this;r(this.A.children,function(c,d){a(new Rf(d,b,c))})};function Vf(a,b,c,d){c&&!d&&b(a);a.P(function(a){Vf(a,b,!0,d)});c&&d&&b(a)}function Wf(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}g.path=function(){return new L(null===this.Zc?this.Gd:this.Zc.path()+"/"+this.Gd)};g.name=function(){return this.Gd};g.parent=function(){return this.Zc};
function Uf(a){if(null!==a.Zc){var b=a.Zc,c=a.Gd,d=a.e(),e=v(b.A.children,c);d&&e?(delete b.A.children[c],b.A.nd--,Uf(b)):d||e||(b.A.children[c]=a.A,b.A.nd++,Uf(b))}};var Xf=/[\[\].#$\/\u0000-\u001F\u007F]/,Yf=/[\[\].#$\u0000-\u001F\u007F]/,Zf=/^[a-zA-Z][a-zA-Z._\-+]+$/;function $f(a){return p(a)&&0!==a.length&&!Xf.test(a)}function ag(a){return null===a||p(a)||ga(a)&&!Qc(a)||ia(a)&&v(a,".sv")}function bg(a,b,c,d){d&&!n(b)||cg(y(a,1,d),b,c)}
function cg(a,b,c){c instanceof L&&(c=new Je(c,a));if(!n(b))throw Error(a+"contains undefined "+Le(c));if(ha(b))throw Error(a+"contains a function "+Le(c)+" with contents: "+b.toString());if(Qc(b))throw Error(a+"contains "+b.toString()+" "+Le(c));if(p(b)&&b.length>10485760/3&&10485760<Zc(b))throw Error(a+"contains a string greater than 10485760 utf8 bytes "+Le(c)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var d=!1,e=!1;ib(b,function(b,h){if(".value"===b)d=!0;else if(".priority"!==b&&".sv"!==b&&(e=
!0,!$f(b)))throw Error(a+" contains an invalid key ("+b+") "+Le(c)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');c.push(b);cg(a,h,c);c.pop()});if(d&&e)throw Error(a+' contains ".value" child '+Le(c)+" in addition to actual children.");}}
function dg(a,b){var c,d;for(c=0;c<b.length;c++){d=b[c];for(var e=d.slice(),f=0;f<e.length;f++)if((".priority"!==e[f]||f!==e.length-1)&&!$f(e[f]))throw Error(a+"contains an invalid key ("+e[f]+") in path "+d.toString()+'. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');}b.sort(Ie);e=null;for(c=0;c<b.length;c++){d=b[c];if(null!==e&&e.contains(d))throw Error(a+"contains a path "+e.toString()+" that is ancestor of another path "+d.toString());e=d}}
function eg(a,b,c){var d=y(a,1,!1);if(!ia(b)||ea(b))throw Error(d+" must be an object containing the children to replace.");var e=[];ib(b,function(a,b){var k=new L(a);cg(d,b,c.u(k));if(".priority"===Ld(k)&&!ag(b))throw Error(d+"contains an invalid value for '"+k.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");e.push(k)});dg(d,e)}
function fg(a,b,c){if(Qc(c))throw Error(y(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!ag(c))throw Error(y(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function gg(a,b,c){if(!c||n(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(y(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function hg(a,b){if(n(b)&&!$f(b))throw Error(y(a,2,!0)+'was an invalid key: "'+b+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function ig(a,b){if(!p(b)||0===b.length||Yf.test(b))throw Error(y(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function jg(a,b){if(".info"===E(b))throw Error(a+" failed: Can't modify data under /.info/");}function kg(a,b){if(!p(b))throw Error(y(a,1,!1)+"must be a valid credential (a string).");}function lg(a,b,c){if(!p(c))throw Error(y(a,b,!1)+"must be a valid string.");}
function mg(a,b){lg(a,1,b);if(!Zf.test(b))throw Error(y(a,1,!1)+"'"+b+"' is not a valid authentication provider.");}function ng(a,b,c,d){if(!d||n(c))if(!ia(c)||null===c)throw Error(y(a,b,d)+"must be a valid object.");}function og(a,b,c){if(!ia(b)||!v(b,c))throw Error(y(a,1,!1)+'must contain the key "'+c+'"');if(!p(w(b,c)))throw Error(y(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function pg(){this.set={}}g=pg.prototype;g.add=function(a,b){this.set[a]=null!==b?b:!0};g.contains=function(a){return v(this.set,a)};g.get=function(a){return this.contains(a)?this.set[a]:void 0};g.remove=function(a){delete this.set[a]};g.clear=function(){this.set={}};g.e=function(){return wa(this.set)};g.count=function(){return pa(this.set)};function qg(a,b){r(a.set,function(a,d){b(d,a)})}g.keys=function(){var a=[];r(this.set,function(b,c){a.push(c)});return a};function qc(){this.m=this.B=null}qc.prototype.find=function(a){if(null!=this.B)return this.B.Q(a);if(a.e()||null==this.m)return null;var b=E(a);a=H(a);return this.m.contains(b)?this.m.get(b).find(a):null};qc.prototype.nc=function(a,b){if(a.e())this.B=b,this.m=null;else if(null!==this.B)this.B=this.B.G(a,b);else{null==this.m&&(this.m=new pg);var c=E(a);this.m.contains(c)||this.m.add(c,new qc);c=this.m.get(c);a=H(a);c.nc(a,b)}};
function rg(a,b){if(b.e())return a.B=null,a.m=null,!0;if(null!==a.B){if(a.B.K())return!1;var c=a.B;a.B=null;c.P(N,function(b,c){a.nc(new L(b),c)});return rg(a,b)}return null!==a.m?(c=E(b),b=H(b),a.m.contains(c)&&rg(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function rc(a,b,c){null!==a.B?c(b,a.B):a.P(function(a,e){var f=new L(b.toString()+"/"+a);rc(e,f,c)})}qc.prototype.P=function(a){null!==this.m&&qg(this.m,function(b,c){a(b,c)})};var sg="auth.firebase.com";function tg(a,b,c){this.od=a||{};this.ee=b||{};this.$a=c||{};this.od.remember||(this.od.remember="default")}var ug=["remember","redirectTo"];function vg(a){var b={},c={};ib(a||{},function(a,e){0<=Na(ug,a)?b[a]=e:c[a]=e});return new tg(b,{},c)};function wg(a,b){this.Qe=["session",a.Od,a.hc].join(":");this.be=b}wg.prototype.set=function(a,b){if(!b)if(this.be.length)b=this.be[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Qe,a)};wg.prototype.get=function(){var a=Qa(this.be,q(this.qg,this)),a=Pa(a,function(a){return null!==a});Xa(a,function(a,c){return ad(c.token)-ad(a.token)});return 0<a.length?a.shift():null};wg.prototype.qg=function(a){try{var b=a.get(this.Qe);if(b&&b.token)return b}catch(c){}return null};
wg.prototype.clear=function(){var a=this;Oa(this.be,function(b){b.remove(a.Qe)})};function xg(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function yg(){return"undefined"!==typeof window&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(xg())}function zg(){return"undefined"!==typeof location&&/^file:\//.test(location.href)}
function Ag(a){var b=xg();if(""===b)return!1;if("Microsoft Internet Explorer"===navigator.appName){if((b=b.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a}else if(-1<b.indexOf("Trident")&&(b=b.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a;return!1};function Bg(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function Cg(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function Dg(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function Eg(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function Fg(a){var b="";try{a=a.replace("#","");var c=lb(a);c&&v(c,"__firebase_request_key")&&(b=w(c,"__firebase_request_key"))}catch(d){}return b}function Gg(){var a=Pc(sg);return a.scheme+"://"+a.host+"/v2"}function Hg(a){return Gg()+"/"+a+"/auth/channel"};function Ig(a){var b=this;this.Ac=a;this.ce="*";Ag(8)?this.Rc=this.zd=Bg():(this.Rc=window.opener,this.zd=window);if(!b.Rc)throw"Unable to find relay frame";Cg(this.zd,"message",q(this.jc,this));Cg(this.zd,"message",q(this.Bf,this));try{Jg(this,{a:"ready"})}catch(c){Cg(this.Rc,"load",function(){Jg(b,{a:"ready"})})}Cg(window,"unload",q(this.Bg,this))}function Jg(a,b){b=B(b);Ag(8)?a.Rc.doPost(b,a.ce):a.Rc.postMessage(b,a.ce)}
Ig.prototype.jc=function(a){var b=this,c;try{c=nb(a.data)}catch(d){}c&&"request"===c.a&&(Dg(window,"message",this.jc),this.ce=a.origin,this.Ac&&setTimeout(function(){b.Ac(b.ce,c.d,function(a,c){b.dg=!c;b.Ac=void 0;Jg(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Ig.prototype.Bg=function(){try{Dg(this.zd,"message",this.Bf)}catch(a){}this.Ac&&(Jg(this,{a:"error",d:"unknown closed window"}),this.Ac=void 0);try{window.close()}catch(b){}};Ig.prototype.Bf=function(a){if(this.dg&&"die"===a.data)try{window.close()}catch(b){}};function Kg(a){this.pc=Ga()+Ga()+Ga();this.Ef=a}Kg.prototype.open=function(a,b){yc.set("redirect_request_id",this.pc);yc.set("redirect_request_id",this.pc);b.requestId=this.pc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+kb(b);window.location=a};Kg.isAvailable=function(){return!zg()&&!yg()};Kg.prototype.Cc=function(){return"redirect"};var Lg={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function Mg(a){var b=Error(w(Lg,a),a);b.code=a;return b};function Ng(a){var b;(b=!a.window_features)||(b=xg(),b=-1!==b.indexOf("Fennec/")||-1!==b.indexOf("Firefox/")&&-1!==b.indexOf("Android"));b&&(a.window_features=void 0);a.window_name||(a.window_name="_blank");this.options=a}
Ng.prototype.open=function(a,b,c){function d(a){h&&(document.body.removeChild(h),h=void 0);t&&(t=clearInterval(t));Dg(window,"message",e);Dg(window,"unload",d);if(m&&!a)try{m.close()}catch(b){k.postMessage("die",l)}m=k=void 0}function e(a){if(a.origin===l)try{var b=nb(a.data);"ready"===b.a?k.postMessage(z,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=Ag(8),h,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=Eg(a);if(l!==Eg(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(h=document.createElement("iframe"),h.setAttribute("src",this.options.relay_url),h.style.display="none",h.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(h),k=h.contentWindow);a+=(/\?/.test(a)?"":"?")+kb(b);var m=window.open(a,this.options.window_name,this.options.window_features);k||(k=m);var t=setInterval(function(){m&&m.closed&&
(d(!1),c&&(c(Mg("USER_CANCELLED")),c=null))},500),z=B({a:"request",d:b});Cg(window,"unload",d);Cg(window,"message",e)}};
Ng.isAvailable=function(){var a;if(a="postMessage"in window&&!zg())(a=yg()||"undefined"!==typeof navigator&&(!!xg().match(/Windows Phone/)||!!window.Windows&&/^ms-appx:/.test(location.href)))||(a=xg(),a="undefined"!==typeof navigator&&"undefined"!==typeof window&&!!(a.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||a.match(/CriOS/)||a.match(/Twitter for iPhone/)||a.match(/FBAN\/FBIOS/)||window.navigator.standalone)),a=!a;return a&&!xg().match(/PhantomJS/)};Ng.prototype.Cc=function(){return"popup"};function Og(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
Og.prototype.open=function(a,b,c){function d(){c&&(c(Mg("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),h;Cg(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=nb(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(Mg("SERVER_ERROR")):c(Mg("NETWORK_ERROR"));c=null;Dg(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+kb(b),h=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(h=B(b));"application/x-www-form-urlencoded"===k&&(h=kb(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};za(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(h)};Og.isAvailable=function(){var a;if(a=!!window.XMLHttpRequest)a=xg(),a=!(a.match(/MSIE/)||a.match(/Trident/))||Ag(10);return a};Og.prototype.Cc=function(){return"json"};function Pg(a){this.pc=Ga()+Ga()+Ga();this.Ef=a}
Pg.prototype.open=function(a,b,c){function d(){c&&(c(Mg("USER_CANCELLED")),c=null)}var e=this,f=Pc(sg),h;b.requestId=this.pc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=kb(b);(h=window.open(a,"_blank","location=no"))&&ha(h.addEventListener)?(h.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{try{var m=document.createElement("a");m.href=a.url;b=m.host===f.host&&"/blank/page.html"===m.pathname;break a}catch(t){}b=!1}b&&(a=Fg(a.url),h.removeEventListener("exit",
d),h.close(),a=new tg(null,null,{requestId:e.pc,requestKey:a}),e.Ef.requestWithCredential("/auth/session",a,c),c=null)}),h.addEventListener("exit",d)):c(Mg("TRANSPORT_UNAVAILABLE"))};Pg.isAvailable=function(){return yg()};Pg.prototype.Cc=function(){return"redirect"};function Qg(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Qg.prototype.open=function(a,b,c){function d(){c&&(c(Mg("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;wa(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);Dg(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+kb(b);
Cg(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Rg(f,a,c)};
function Rg(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(Mg("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(Mg("NETWORK_ERROR"))}},0)}Qg.isAvailable=function(){return"undefined"!==typeof document&&null!=document.createElement};
Qg.prototype.Cc=function(){return"json"};function Sg(a,b,c,d){De.call(this,["auth_status"]);this.F=a;this.df=b;this.Vg=c;this.Le=d;this.sc=new wg(a,[xc,yc]);this.mb=null;this.Se=!1;Tg(this)}ma(Sg,De);g=Sg.prototype;g.xe=function(){return this.mb||null};function Tg(a){yc.get("redirect_request_id")&&Ug(a);var b=a.sc.get();b&&b.token?(Vg(a,b),a.df(b.token,function(c,d){Wg(a,c,d,!1,b.token,b)},function(b,d){Xg(a,"resumeSession()",b,d)})):Vg(a,null)}
function Yg(a,b,c,d,e,f){"firebaseio-demo.com"===a.F.domain&&O("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.df(b,function(f,k){Wg(a,f,k,!0,b,c,d||{},e)},function(b,c){Xg(a,"auth()",b,c,f)})}function Zg(a,b){a.sc.clear();Vg(a,null);a.Vg(function(a,d){if("ok"===a)P(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;P(b,f)}})}
function Wg(a,b,c,d,e,f,h,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=bd(e)?e:"",c=null,b&&v(b,"uid")?c=w(b,"uid"):v(f,"uid")&&(c=w(f,"uid")),f.uid=c,c="custom",b&&v(b,"provider")?c=w(b,"provider"):v(f,"provider")&&(c=w(f,"provider")),f.provider=c,a.sc.clear(),bd(e)&&(h=h||{},c=xc,"sessionOnly"===h.remember&&(c=yc),"none"!==h.remember&&a.sc.set(f,c)),Vg(a,f)),P(k,null,f)):(a.sc.clear(),Vg(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,P(k,f))}
function Xg(a,b,c,d,e){O(b+" was canceled: "+d);a.sc.clear();Vg(a,null);a=Error(d);a.code=c.toUpperCase();P(e,a)}function $g(a,b,c,d,e){ah(a);c=new tg(d||{},{},c||{});bh(a,[Og,Qg],"/auth/"+b,c,e)}
function ch(a,b,c,d){ah(a);var e=[Ng,Pg];c=vg(c);"anonymous"===b||"password"===b?setTimeout(function(){P(d,Mg("TRANSPORT_UNAVAILABLE"))},0):(c.ee.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.ee.relay_url=Hg(a.F.hc),c.ee.requestWithCredential=q(a.qc,a),bh(a,e,"/auth/"+b,c,d))}
function Ug(a){var b=yc.get("redirect_request_id");if(b){var c=yc.get("redirect_client_options");yc.remove("redirect_request_id");yc.remove("redirect_client_options");var d=[Og,Qg],b={requestId:b,requestKey:Fg(document.location.hash)},c=new tg(c,{},b);a.Se=!0;try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}bh(a,d,"/auth/session",c,function(){this.Se=!1}.bind(a))}}
g.se=function(a,b){ah(this);var c=vg(a);c.$a._method="POST";this.qc("/users",c,function(a,c){a?P(b,a):P(b,a,c)})};g.Te=function(a,b){var c=this;ah(this);var d="/users/"+encodeURIComponent(a.email),e=vg(a);e.$a._method="DELETE";this.qc(d,e,function(a,d){!a&&d&&d.uid&&c.mb&&c.mb.uid&&c.mb.uid===d.uid&&Zg(c);P(b,a)})};g.pe=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=vg(a);d.$a._method="PUT";d.$a.password=a.newPassword;this.qc(c,d,function(a){P(b,a)})};
g.oe=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=vg(a);d.$a._method="PUT";d.$a.email=a.newEmail;d.$a.password=a.password;this.qc(c,d,function(a){P(b,a)})};g.Ve=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=vg(a);d.$a._method="POST";this.qc(c,d,function(a){P(b,a)})};g.qc=function(a,b,c){dh(this,[Og,Qg],a,b,c)};
function bh(a,b,c,d,e){dh(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Yg(a,c.token,c,d.od,function(a,b){a?P(e,a):P(e,null,b)}):P(e,b||Mg("UNKNOWN_ERROR"))})}
function dh(a,b,c,d,e){b=Pa(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){P(e,Mg("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.ee),d=jb(d.$a),d.v="js-"+hb,d.transport=b.Cc(),d.suppress_status_codes=!0,a=Gg()+"/"+a.F.hc+c,b.open(a,d,function(a,b){if(a)P(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;P(e,c)}else P(e,null,b)}))}
function Vg(a,b){var c=null!==a.mb||null!==b;a.mb=b;c&&a.fe("auth_status",b);a.Le(null!==b)}g.Ae=function(a){K("auth_status"===a,'initial event must be of type "auth_status"');return this.Se?null:[this.mb]};function ah(a){var b=a.F;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===sg)throw Error("This custom Firebase server ('"+a.F.domain+"') does not support delegated login.");};var Cc="websocket",Dc="long_polling";function eh(a){this.jc=a;this.Nd=[];this.Sb=0;this.qe=-1;this.Fb=null}function fh(a,b,c){a.qe=b;a.Fb=c;a.qe<a.Sb&&(a.Fb(),a.Fb=null)}function gh(a,b,c){for(a.Nd[b]=c;a.Nd[a.Sb];){var d=a.Nd[a.Sb];delete a.Nd[a.Sb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Db(function(){f.jc(d[e])})}if(a.Sb===a.qe){a.Fb&&(clearTimeout(a.Fb),a.Fb(),a.Fb=null);break}a.Sb++}};function hh(a,b,c,d){this.re=a;this.f=Mc(a);this.nb=this.ob=0;this.Ua=Rb(b);this.Qf=c;this.Hc=!1;this.Bb=d;this.jd=function(a){return Bc(b,Dc,a)}}var ih,jh;
hh.prototype.open=function(a,b){this.hf=0;this.la=b;this.Af=new eh(a);this.zb=!1;var c=this;this.qb=setTimeout(function(){c.f("Timed out trying to connect.");c.gb();c.qb=null},Math.floor(3E4));Rc(function(){if(!c.zb){c.Sa=new kh(function(a,b,d,k,l){lh(c,arguments);if(c.Sa)if(c.qb&&(clearTimeout(c.qb),c.qb=null),c.Hc=!0,"start"==a)c.id=b,c.Gf=d;else if("close"===a)b?(c.Sa.Xd=!1,fh(c.Af,b,function(){c.gb()})):c.gb();else throw Error("Unrecognized command received: "+a);},function(a,b){lh(c,arguments);
gh(c.Af,a,b)},function(){c.gb()},c.jd);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Sa.he&&(a.cb=c.Sa.he);a.v="5";c.Qf&&(a.s=c.Qf);c.Bb&&(a.ls=c.Bb);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.jd(a);c.f("Connecting via long-poll to "+a);mh(c.Sa,a,function(){})}})};
hh.prototype.start=function(){var a=this.Sa,b=this.Gf;a.ug=this.id;a.vg=b;for(a.le=!0;nh(a););a=this.id;b=this.Gf;this.gc=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.gc.src=this.jd(c);this.gc.style.display="none";document.body.appendChild(this.gc)};
hh.isAvailable=function(){return ih||!jh&&"undefined"!==typeof document&&null!=document.createElement&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Xg)&&!0};g=hh.prototype;g.Ed=function(){};g.dd=function(){this.zb=!0;this.Sa&&(this.Sa.close(),this.Sa=null);this.gc&&(document.body.removeChild(this.gc),this.gc=null);this.qb&&(clearTimeout(this.qb),this.qb=null)};
g.gb=function(){this.zb||(this.f("Longpoll is closing itself"),this.dd(),this.la&&(this.la(this.Hc),this.la=null))};g.close=function(){this.zb||(this.f("Longpoll is being closed."),this.dd())};g.send=function(a){a=B(a);this.ob+=a.length;Ob(this.Ua,"bytes_sent",a.length);a=Ic(a);a=fb(a,!0);a=Vc(a,1840);for(var b=0;b<a.length;b++){var c=this.Sa;c.ad.push({Mg:this.hf,Ug:a.length,kf:a[b]});c.le&&nh(c);this.hf++}};function lh(a,b){var c=B(b).length;a.nb+=c;Ob(a.Ua,"bytes_received",c)}
function kh(a,b,c,d){this.jd=d;this.hb=c;this.Pe=new pg;this.ad=[];this.te=Math.floor(1E8*Math.random());this.Xd=!0;this.he=Ec();window["pLPCommand"+this.he]=a;window["pRTLPCB"+this.he]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||Cb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.eb=a.contentDocument:a.contentWindow?a.eb=a.contentWindow.document:a.document&&(a.eb=a.document);this.Ea=a;a="";this.Ea.src&&"javascript:"===this.Ea.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ea.eb.open(),this.Ea.eb.write(a),this.Ea.eb.close()}catch(f){Cb("frame writing exception"),f.stack&&Cb(f.stack),Cb(f)}}
kh.prototype.close=function(){this.le=!1;if(this.Ea){this.Ea.eb.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ea&&(document.body.removeChild(a.Ea),a.Ea=null)},Math.floor(0))}var b=this.hb;b&&(this.hb=null,b())};
function nh(a){if(a.le&&a.Xd&&a.Pe.count()<(0<a.ad.length?2:1)){a.te++;var b={};b.id=a.ug;b.pw=a.vg;b.ser=a.te;for(var b=a.jd(b),c="",d=0;0<a.ad.length;)if(1870>=a.ad[0].kf.length+30+c.length){var e=a.ad.shift(),c=c+"&seg"+d+"="+e.Mg+"&ts"+d+"="+e.Ug+"&d"+d+"="+e.kf;d++}else break;oh(a,b+c,a.te);return!0}return!1}function oh(a,b,c){function d(){a.Pe.remove(c);nh(a)}a.Pe.add(c,1);var e=setTimeout(d,Math.floor(25E3));mh(a,b,function(){clearTimeout(e);d()})}
function mh(a,b,c){setTimeout(function(){try{if(a.Xd){var d=a.Ea.eb.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){Cb("Long-poll script failed to load: "+b);a.Xd=!1;a.close()};a.Ea.eb.body.appendChild(d)}}catch(e){}},Math.floor(1))};var ph=null;"undefined"!==typeof MozWebSocket?ph=MozWebSocket:"undefined"!==typeof WebSocket&&(ph=WebSocket);function qh(a,b,c,d){this.re=a;this.f=Mc(this.re);this.frames=this.Kc=null;this.nb=this.ob=this.bf=0;this.Ua=Rb(b);a={v:"5"};"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");c&&(a.s=c);d&&(a.ls=d);this.ef=Bc(b,Cc,a)}var rh;
qh.prototype.open=function(a,b){this.hb=b;this.zg=a;this.f("Websocket connecting to "+this.ef);this.Hc=!1;xc.set("previous_websocket_failure",!0);try{this.ua=new ph(this.ef)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.gb();return}var e=this;this.ua.onopen=function(){e.f("Websocket connected.");e.Hc=!0};this.ua.onclose=function(){e.f("Websocket connection was disconnected.");e.ua=null;e.gb()};this.ua.onmessage=function(a){if(null!==e.ua)if(a=a.data,e.nb+=
a.length,Ob(e.Ua,"bytes_received",a.length),sh(e),null!==e.frames)th(e,a);else{a:{K(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.bf=b;e.frames=[];a=null;break a}}e.bf=1;e.frames=[]}null!==a&&th(e,a)}};this.ua.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.gb()}};qh.prototype.start=function(){};
qh.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==ph&&!rh};qh.responsesRequiredToBeHealthy=2;qh.healthyTimeout=3E4;g=qh.prototype;g.Ed=function(){xc.remove("previous_websocket_failure")};function th(a,b){a.frames.push(b);if(a.frames.length==a.bf){var c=a.frames.join("");a.frames=null;c=nb(c);a.zg(c)}}
g.send=function(a){sh(this);a=B(a);this.ob+=a.length;Ob(this.Ua,"bytes_sent",a.length);a=Vc(a,16384);1<a.length&&this.ua.send(String(a.length));for(var b=0;b<a.length;b++)this.ua.send(a[b])};g.dd=function(){this.zb=!0;this.Kc&&(clearInterval(this.Kc),this.Kc=null);this.ua&&(this.ua.close(),this.ua=null)};g.gb=function(){this.zb||(this.f("WebSocket is closing itself"),this.dd(),this.hb&&(this.hb(this.Hc),this.hb=null))};g.close=function(){this.zb||(this.f("WebSocket is being closed"),this.dd())};
function sh(a){clearInterval(a.Kc);a.Kc=setInterval(function(){a.ua&&a.ua.send("0");sh(a)},Math.floor(45E3))};function uh(a){vh(this,a)}var wh=[hh,qh];function vh(a,b){var c=qh&&qh.isAvailable(),d=c&&!(xc.wf||!0===xc.get("previous_websocket_failure"));b.Wg&&(c||O("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.gd=[qh];else{var e=a.gd=[];Wc(wh,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function xh(a){if(0<a.gd.length)return a.gd[0];throw Error("No transports available");};function yh(a,b,c,d,e,f,h){this.id=a;this.f=Mc("c:"+this.id+":");this.jc=c;this.Wc=d;this.la=e;this.Ne=f;this.F=b;this.Md=[];this.ff=0;this.Pf=new uh(b);this.Ta=0;this.Bb=h;this.f("Connection created");zh(this)}
function zh(a){var b=xh(a.Pf);a.J=new b("c:"+a.id+":"+a.ff++,a.F,void 0,a.Bb);a.Re=b.responsesRequiredToBeHealthy||0;var c=Ah(a,a.J),d=Bh(a,a.J);a.hd=a.J;a.cd=a.J;a.D=null;a.Ab=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.yd=setTimeout(function(){a.yd=null;a.Ab||(a.J&&102400<a.J.nb?(a.f("Connection exceeded healthy timeout but has received "+a.J.nb+" bytes.  Marking connection healthy."),a.Ab=!0,a.J.Ed()):a.J&&10240<a.J.ob?a.f("Connection exceeded healthy timeout but has sent "+
a.J.ob+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function Bh(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Ta?1===a.Ta&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.F.Ya.substr(0,2)&&(xc.remove("host:"+a.F.host),a.F.Ya=a.F.host)),a.close()):b===a.D?(a.f("Secondary connection lost."),c=a.D,a.D=null,a.hd!==c&&a.cd!==c||a.close()):a.f("closing an old connection")}}
function Ah(a,b){return function(c){if(2!=a.Ta)if(b===a.cd){var d=Tc("t",c);c=Tc("d",c);if("c"==d){if(d=Tc("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Nf=c.s;Ac(a.F,f);0==a.Ta&&(a.J.start(),Ch(a,a.J,d),"5"!==e&&O("Protocol version mismatch detected"),c=a.Pf,(c=1<c.gd.length?c.gd[1]:null)&&Dh(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.cd=a.D;for(c=0;c<a.Md.length;++c)a.Id(a.Md[c]);a.Md=[];Eh(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.Ne&&(a.Ne(c),a.Ne=null),a.la=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ac(a.F,c),1===a.Ta?a.close():(Fh(a),zh(a))):"e"===d?Nc("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Gh(a),Hh(a)):Nc("Unknown control packet command: "+d)}else"d"==d&&a.Id(c)}else if(b===a.D)if(d=Tc("t",c),c=Tc("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ih(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.D.close(),a.hd!==a.D&&a.cd!==a.D||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.Mf--,Ih(a)));else if("d"==d)a.Md.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}yh.prototype.Fa=function(a){Jh(this,{t:"d",d:a})};function Eh(a){a.hd===a.D&&a.cd===a.D&&(a.f("cleaning up and promoting a connection: "+a.D.re),a.J=a.D,a.D=null)}
function Ih(a){0>=a.Mf?(a.f("Secondary connection is healthy."),a.Ab=!0,a.D.Ed(),a.D.start(),a.f("sending client ack on secondary"),a.D.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.hd=a.D,Eh(a)):(a.f("sending ping on secondary."),a.D.send({t:"c",d:{t:"p",d:{}}}))}yh.prototype.Id=function(a){Gh(this);this.jc(a)};function Gh(a){a.Ab||(a.Re--,0>=a.Re&&(a.f("Primary connection is healthy."),a.Ab=!0,a.J.Ed()))}
function Dh(a,b){a.D=new b("c:"+a.id+":"+a.ff++,a.F,a.Nf);a.Mf=b.responsesRequiredToBeHealthy||0;a.D.open(Ah(a,a.D),Bh(a,a.D));setTimeout(function(){a.D&&(a.f("Timed out trying to upgrade."),a.D.close())},Math.floor(6E4))}function Ch(a,b,c){a.f("Realtime connection established.");a.J=b;a.Ta=1;a.Wc&&(a.Wc(c,a.Nf),a.Wc=null);0===a.Re?(a.f("Primary connection is healthy."),a.Ab=!0):setTimeout(function(){Hh(a)},Math.floor(5E3))}
function Hh(a){a.Ab||1!==a.Ta||(a.f("sending ping on primary."),Jh(a,{t:"c",d:{t:"p",d:{}}}))}function Jh(a,b){if(1!==a.Ta)throw"Connection is not connected";a.hd.send(b)}yh.prototype.close=function(){2!==this.Ta&&(this.f("Closing realtime connection."),this.Ta=2,Fh(this),this.la&&(this.la(),this.la=null))};function Fh(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.D&&(a.D.close(),a.D=null);a.yd&&(clearTimeout(a.yd),a.yd=null)};function Kh(a,b,c,d){this.id=Lh++;this.f=Mc("p:"+this.id+":");this.xf=this.Ee=!1;this.$={};this.qa=[];this.Yc=0;this.Vc=[];this.oa=!1;this.Za=1E3;this.Fd=3E5;this.Gb=b;this.Uc=c;this.Oe=d;this.F=a;this.sb=this.Aa=this.Ia=this.Bb=this.We=null;this.Ob=!1;this.Td={};this.Lg=0;this.nf=!0;this.Lc=this.Ge=null;Mh(this,0);He.ub().Eb("visible",this.Cg,this);-1===a.host.indexOf("fblocal")&&Ge.ub().Eb("online",this.Ag,this)}var Lh=0,Nh=0;g=Kh.prototype;
g.Fa=function(a,b,c){var d=++this.Lg;a={r:d,a:a,b:b};this.f(B(a));K(this.oa,"sendRequest call when we're not connected not allowed.");this.Ia.Fa(a);c&&(this.Td[d]=c)};g.yf=function(a,b,c,d){var e=a.va(),f=a.path.toString();this.f("Listen called for "+f+" "+e);this.$[f]=this.$[f]||{};K(fe(a.n)||!S(a.n),"listen() called for non-default but complete query");K(!this.$[f][e],"listen() called twice for same path/queryId.");a={H:d,xd:b,Ig:a,tag:c};this.$[f][e]=a;this.oa&&Oh(this,a)};
function Oh(a,b){var c=b.Ig,d=c.path.toString(),e=c.va();a.f("Listen on "+d+" for "+e);var f={p:d};b.tag&&(f.q=ee(c.n),f.t=b.tag);f.h=b.xd();a.Fa("q",f,function(f){var k=f.d,l=f.s;if(k&&"object"===typeof k&&v(k,"w")){var m=w(k,"w");ea(m)&&0<=Na(m,"no_index")&&O("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}(a.$[d]&&a.$[d][e])===b&&(a.f("listen response",f),"ok"!==l&&Ph(a,d,e),b.H&&b.H(l,
k))})}g.M=function(a,b,c){this.Aa={ig:a,of:!1,zc:b,md:c};this.f("Authenticating using credential: "+a);Qh(this);(b=40==a.length)||(a=$c(a).Bc,b="object"===typeof a&&!0===w(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.Fd=3E4)};g.ge=function(a){delete this.Aa;this.oa&&this.Fa("unauth",{},function(b){a(b.s,b.d)})};
function Qh(a){var b=a.Aa;a.oa&&b&&a.Fa("auth",{cred:b.ig},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Aa===b&&delete a.Aa;b.of?"ok"!==d&&b.md&&b.md(d,c):(b.of=!0,b.zc&&b.zc(d,c))})}g.Rf=function(a,b){var c=a.path.toString(),d=a.va();this.f("Unlisten called for "+c+" "+d);K(fe(a.n)||!S(a.n),"unlisten() called for non-default but complete query");if(Ph(this,c,d)&&this.oa){var e=ee(a.n);this.f("Unlisten on "+c+" for "+d);c={p:c};b&&(c.q=e,c.t=b);this.Fa("n",c)}};
g.Me=function(a,b,c){this.oa?Rh(this,"o",a,b,c):this.Vc.push({$c:a,action:"o",data:b,H:c})};g.Cf=function(a,b,c){this.oa?Rh(this,"om",a,b,c):this.Vc.push({$c:a,action:"om",data:b,H:c})};g.Jd=function(a,b){this.oa?Rh(this,"oc",a,null,b):this.Vc.push({$c:a,action:"oc",data:null,H:b})};function Rh(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Fa(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}g.put=function(a,b,c,d){Sh(this,"p",a,b,c,d)};
g.zf=function(a,b,c,d){Sh(this,"m",a,b,c,d)};function Sh(a,b,c,d,e,f){d={p:c,d:d};n(f)&&(d.h=f);a.qa.push({action:b,Jf:d,H:e});a.Yc++;b=a.qa.length-1;a.oa?Th(a,b):a.f("Buffering put: "+c)}function Th(a,b){var c=a.qa[b].action,d=a.qa[b].Jf,e=a.qa[b].H;a.qa[b].Jg=a.oa;a.Fa(c,d,function(d){a.f(c+" response",d);delete a.qa[b];a.Yc--;0===a.Yc&&(a.qa=[]);e&&e(d.s,d.d)})}
g.Ue=function(a){this.oa&&(a={c:a},this.f("reportStats",a),this.Fa("s",a,function(a){"ok"!==a.s&&this.f("reportStats","Error sending stats: "+a.d)}))};
g.Id=function(a){if("r"in a){this.f("from server: "+B(a));var b=a.r,c=this.Td[b];c&&(delete this.Td[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.Gb(c.p,c.d,!1,c.t):"m"===b?this.Gb(c.p,c.d,!0,c.t):"c"===b?Uh(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Aa,delete this.Aa,c&&c.md&&c.md(a,b)):"sd"===b?this.We?this.We(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):Nc("Unrecognized action received from server: "+B(b)+"\nAre you using the latest client?"))}};g.Wc=function(a,b){this.f("connection ready");this.oa=!0;this.Lc=(new Date).getTime();this.Oe({serverTimeOffset:a-(new Date).getTime()});this.Bb=b;if(this.nf){var c={};c["sdk.js."+hb.replace(/\./g,"-")]=1;yg()&&(c["framework.cordova"]=1);this.Ue(c)}Vh(this);this.nf=!1;this.Uc(!0)};
function Mh(a,b){K(!a.Ia,"Scheduling a connect when we're already connected/ing?");a.sb&&clearTimeout(a.sb);a.sb=setTimeout(function(){a.sb=null;Wh(a)},Math.floor(b))}g.Cg=function(a){a&&!this.Ob&&this.Za===this.Fd&&(this.f("Window became visible.  Reducing delay."),this.Za=1E3,this.Ia||Mh(this,0));this.Ob=a};g.Ag=function(a){a?(this.f("Browser went online."),this.Za=1E3,this.Ia||Mh(this,0)):(this.f("Browser went offline.  Killing connection."),this.Ia&&this.Ia.close())};
g.Df=function(){this.f("data client disconnected");this.oa=!1;this.Ia=null;for(var a=0;a<this.qa.length;a++){var b=this.qa[a];b&&"h"in b.Jf&&b.Jg&&(b.H&&b.H("disconnect"),delete this.qa[a],this.Yc--)}0===this.Yc&&(this.qa=[]);this.Td={};Xh(this)&&(this.Ob?this.Lc&&(3E4<(new Date).getTime()-this.Lc&&(this.Za=1E3),this.Lc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Za=this.Fd,this.Ge=(new Date).getTime()),a=Math.max(0,this.Za-((new Date).getTime()-this.Ge)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Mh(this,a),this.Za=Math.min(this.Fd,1.3*this.Za));this.Uc(!1)};function Wh(a){if(Xh(a)){a.f("Making a connection attempt");a.Ge=(new Date).getTime();a.Lc=null;var b=q(a.Id,a),c=q(a.Wc,a),d=q(a.Df,a),e=a.id+":"+Nh++;a.Ia=new yh(e,a.F,b,c,d,function(b){O(b+" ("+a.F.toString()+")");a.xf=!0},a.Bb)}}g.yb=function(){this.Ee=!0;this.Ia?this.Ia.close():(this.sb&&(clearTimeout(this.sb),this.sb=null),this.oa&&this.Df())};g.rc=function(){this.Ee=!1;this.Za=1E3;this.Ia||Mh(this,0)};
function Uh(a,b,c){c=c?Qa(c,function(a){return Uc(a)}).join("$"):"default";(a=Ph(a,b,c))&&a.H&&a.H("permission_denied")}function Ph(a,b,c){b=(new L(b)).toString();var d;n(a.$[b])?(d=a.$[b][c],delete a.$[b][c],0===pa(a.$[b])&&delete a.$[b]):d=void 0;return d}function Vh(a){Qh(a);r(a.$,function(b){r(b,function(b){Oh(a,b)})});for(var b=0;b<a.qa.length;b++)a.qa[b]&&Th(a,b);for(;a.Vc.length;)b=a.Vc.shift(),Rh(a,b.action,b.$c,b.data,b.H)}function Xh(a){var b;b=Ge.ub().kc;return!a.xf&&!a.Ee&&b};var V={og:function(){ih=rh=!0}};V.forceLongPolling=V.og;V.pg=function(){jh=!0};V.forceWebSockets=V.pg;V.Pg=function(a,b){a.k.Ra.We=b};V.setSecurityDebugCallback=V.Pg;V.Ye=function(a,b){a.k.Ye(b)};V.stats=V.Ye;V.Ze=function(a,b){a.k.Ze(b)};V.statsIncrementCounter=V.Ze;V.sd=function(a){return a.k.sd};V.dataUpdateCount=V.sd;V.sg=function(a,b){a.k.De=b};V.interceptServerData=V.sg;V.yg=function(a){new Ig(a)};V.onPopupOpen=V.yg;V.Ng=function(a){sg=a};V.setAuthenticationServer=V.Ng;function Q(a,b,c){this.A=a;this.W=b;this.g=c}Q.prototype.I=function(){x("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};Q.prototype.val=Q.prototype.I;Q.prototype.mf=function(){x("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};Q.prototype.exportVal=Q.prototype.mf;Q.prototype.ng=function(){x("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};Q.prototype.exists=Q.prototype.ng;
Q.prototype.u=function(a){x("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));ig("Firebase.DataSnapshot.child",a);var b=new L(a),c=this.W.u(b);return new Q(this.A.Q(b),c,N)};Q.prototype.child=Q.prototype.u;Q.prototype.Da=function(a){x("Firebase.DataSnapshot.hasChild",1,1,arguments.length);ig("Firebase.DataSnapshot.hasChild",a);var b=new L(a);return!this.A.Q(b).e()};Q.prototype.hasChild=Q.prototype.Da;
Q.prototype.C=function(){x("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.C().I()};Q.prototype.getPriority=Q.prototype.C;Q.prototype.forEach=function(a){x("Firebase.DataSnapshot.forEach",1,1,arguments.length);A("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.K())return!1;var b=this;return!!this.A.P(this.g,function(c,d){return a(new Q(d,b.W.u(c),N))})};Q.prototype.forEach=Q.prototype.forEach;
Q.prototype.wd=function(){x("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.K()?!1:!this.A.e()};Q.prototype.hasChildren=Q.prototype.wd;Q.prototype.name=function(){O("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");x("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};Q.prototype.name=Q.prototype.name;Q.prototype.key=function(){x("Firebase.DataSnapshot.key",0,0,arguments.length);return this.W.key()};
Q.prototype.key=Q.prototype.key;Q.prototype.Db=function(){x("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.Db()};Q.prototype.numChildren=Q.prototype.Db;Q.prototype.Ib=function(){x("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.W};Q.prototype.ref=Q.prototype.Ib;function Yh(a,b){this.F=a;this.Ua=Rb(a);this.fd=null;this.da=new vb;this.Hd=1;this.Ra=null;b||0<=("object"===typeof window&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)?(this.ba=new Ae(this.F,q(this.Gb,this)),setTimeout(q(this.Uc,this,!0),0)):this.ba=this.Ra=new Kh(this.F,q(this.Gb,this),q(this.Uc,this),q(this.Oe,this));this.Sg=Sb(a,q(function(){return new Mb(this.Ua,this.ba)},this));this.uc=new Rf;
this.Ce=new ob;var c=this;this.Cd=new vf({Xe:function(a,b,f,h){b=[];f=c.Ce.j(a.path);f.e()||(b=xf(c.Cd,new Xb(bf,a.path,f)),setTimeout(function(){h("ok")},0));return b},ae:ba});Zh(this,"connected",!1);this.la=new qc;this.M=new Sg(a,q(this.ba.M,this.ba),q(this.ba.ge,this.ba),q(this.Le,this));this.sd=0;this.De=null;this.L=new vf({Xe:function(a,b,f,h){c.ba.yf(a,f,b,function(b,e){var f=h(b,e);Ab(c.da,a.path,f)});return[]},ae:function(a,b){c.ba.Rf(a,b)}})}g=Yh.prototype;
g.toString=function(){return(this.F.kb?"https://":"http://")+this.F.host};g.name=function(){return this.F.hc};function $h(a){a=a.Ce.j(new L(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function ai(a){a=a={timestamp:$h(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}
g.Gb=function(a,b,c,d){this.sd++;var e=new L(a);b=this.De?this.De(a,b):b;a=[];d?c?(b=na(b,function(a){return M(a)}),a=Ff(this.L,e,b,d)):(b=M(b),a=Bf(this.L,e,b,d)):c?(d=na(b,function(a){return M(a)}),a=Af(this.L,e,d)):(d=M(b),a=xf(this.L,new Xb(bf,e,d)));d=e;0<a.length&&(d=bi(this,e));Ab(this.da,d,a)};g.Uc=function(a){Zh(this,"connected",a);!1===a&&ci(this)};g.Oe=function(a){var b=this;Wc(a,function(a,d){Zh(b,d,a)})};g.Le=function(a){Zh(this,"authenticated",a)};
function Zh(a,b,c){b=new L("/.info/"+b);c=M(c);var d=a.Ce;d.Wd=d.Wd.G(b,c);c=xf(a.Cd,new Xb(bf,b,c));Ab(a.da,b,c)}g.Kb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,$g:c});var e=ai(this);b=M(b,c);var e=sc(b,e),f=this.Hd++,e=wf(this.L,a,e,f,!0);wb(this.da,e);var h=this;this.ba.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||O("set at "+a+" failed: "+b);e=zf(h.L,f,!e);Ab(h.da,a,e);di(d,b,c)});e=ei(this,a);bi(this,e);Ab(this.da,e,[])};
g.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=ai(this),f={};r(b,function(a,b){d=!1;var c=M(a);f[b]=sc(c,e)});if(d)Cb("update() called with empty data.  Don't do anything."),di(c,"ok");else{var h=this.Hd++,k=yf(this.L,a,f,h);wb(this.da,k);var l=this;this.ba.zf(a.toString(),b,function(b,d){var e="ok"===b;e||O("update at "+a+" failed: "+b);var e=zf(l.L,h,!e),f=a;0<e.length&&(f=bi(l,a));Ab(l.da,f,e);di(c,b,d)});b=ei(this,a);bi(this,b);Ab(this.da,a,[])}};
function ci(a){a.f("onDisconnectEvents");var b=ai(a),c=[];rc(pc(a.la,b),G,function(b,e){c=c.concat(xf(a.L,new Xb(bf,b,e)));var f=ei(a,b);bi(a,f)});a.la=new qc;Ab(a.da,G,c)}g.Jd=function(a,b){var c=this;this.ba.Jd(a.toString(),function(d,e){"ok"===d&&rg(c.la,a);di(b,d,e)})};function fi(a,b,c,d){var e=M(c);a.ba.Me(b.toString(),e.I(!0),function(c,h){"ok"===c&&a.la.nc(b,e);di(d,c,h)})}function gi(a,b,c,d,e){var f=M(c,d);a.ba.Me(b.toString(),f.I(!0),function(c,d){"ok"===c&&a.la.nc(b,f);di(e,c,d)})}
function hi(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(Cb("onDisconnect().update() called with empty data.  Don't do anything."),di(d,"ok")):a.ba.Cf(b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var m=M(c[l]);a.la.nc(b.u(l),m)}di(d,e,f)})}function ii(a,b,c){c=".info"===E(b.path)?a.Cd.Pb(b,c):a.L.Pb(b,c);yb(a.da,b.path,c)}g.yb=function(){this.Ra&&this.Ra.yb()};g.rc=function(){this.Ra&&this.Ra.rc()};
g.Ye=function(a){if("undefined"!==typeof console){a?(this.fd||(this.fd=new Lb(this.Ua)),a=this.fd.get()):a=this.Ua.get();var b=Ra(sa(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};g.Ze=function(a){Ob(this.Ua,a);this.Sg.Of[a]=!0};g.f=function(a){var b="";this.Ra&&(b=this.Ra.id+":");Cb(b,arguments)};
function di(a,b,c){a&&Db(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function ji(a,b,c,d,e){function f(){}a.f("transaction on "+b);var h=new U(a,b);h.Eb("value",f);c={path:b,update:c,H:d,status:null,Ff:Ec(),cf:e,Lf:0,ie:function(){h.ic("value",f)},ke:null,Ba:null,pd:null,qd:null,rd:null};d=a.L.za(b,void 0)||C;c.pd=d;d=c.update(d.I());if(n(d)){cg("transaction failed: Data returned ",d,c.path);c.status=1;e=Sf(a.uc,b);var k=e.Ca()||[];k.push(c);Tf(e,k);"object"===typeof d&&null!==d&&v(d,".priority")?(k=w(d,".priority"),K(ag(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.L.za(b)||C).C().I();e=ai(a);d=M(d,k);e=sc(d,e);c.qd=d;c.rd=e;c.Ba=a.Hd++;c=wf(a.L,b,e,c.Ba,c.cf);Ab(a.da,b,c);ki(a)}else c.ie(),c.qd=null,c.rd=null,c.H&&(a=new Q(c.pd,new U(a,c.path),N),c.H(null,!1,a))}function ki(a,b){var c=b||a.uc;b||li(a,c);if(null!==c.Ca()){var d=mi(a,c);K(0<d.length,"Sending zero length transaction queue");Sa(d,function(a){return 1===a.status})&&ni(a,c.path(),d)}else c.wd()&&c.P(function(b){ki(a,b)})}
function ni(a,b,c){for(var d=Qa(c,function(a){return a.Ba}),e=a.L.za(b,d)||C,d=e,e=e.hash(),f=0;f<c.length;f++){var h=c[f];K(1===h.status,"tryToSendTransactionQueue_: items in queue should all be run.");h.status=2;h.Lf++;var k=T(b,h.path),d=d.G(k,h.qd)}d=d.I(!0);a.ba.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(zf(a.L,c[f].Ba));if(c[f].H){var h=c[f].rd,k=new U(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new Q(h,k,N)))}c[f].ie()}li(a,Sf(a.uc,b));ki(a);Ab(a.da,b,e);for(f=0;f<d.length;f++)Db(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(O("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].ke=d;bi(a,b)}},e)}function bi(a,b){var c=oi(a,b),d=c.path(),c=mi(a,c);pi(a,c,d);return d}
function pi(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Qa(b,function(a){return a.Ba}),h=0;h<b.length;h++){var k=b[h],l=T(c,k.path),m=!1,t;K(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)m=!0,t=k.ke,e=e.concat(zf(a.L,k.Ba,!0));else if(1===k.status)if(25<=k.Lf)m=!0,t="maxretry",e=e.concat(zf(a.L,k.Ba,!0));else{var z=a.L.za(k.path,f)||C;k.pd=z;var I=b[h].update(z.I());n(I)?(cg("transaction failed: Data returned ",I,k.path),l=M(I),"object"===typeof I&&null!=
I&&v(I,".priority")||(l=l.ga(z.C())),z=k.Ba,I=ai(a),I=sc(l,I),k.qd=l,k.rd=I,k.Ba=a.Hd++,Va(f,z),e=e.concat(wf(a.L,k.path,I,k.Ba,k.cf)),e=e.concat(zf(a.L,z,!0))):(m=!0,t="nodata",e=e.concat(zf(a.L,k.Ba,!0)))}Ab(a.da,c,e);e=[];m&&(b[h].status=3,setTimeout(b[h].ie,Math.floor(0)),b[h].H&&("nodata"===t?(k=new U(a,b[h].path),d.push(q(b[h].H,null,null,!1,new Q(b[h].pd,k,N)))):d.push(q(b[h].H,null,Error(t),!1,null))))}li(a,a.uc);for(h=0;h<d.length;h++)Db(d[h]);ki(a)}}
function oi(a,b){for(var c,d=a.uc;null!==(c=E(b))&&null===d.Ca();)d=Sf(d,c),b=H(b);return d}function mi(a,b){var c=[];qi(a,b,c);c.sort(function(a,b){return a.Ff-b.Ff});return c}function qi(a,b,c){var d=b.Ca();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.P(function(b){qi(a,b,c)})}function li(a,b){var c=b.Ca();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Tf(b,0<c.length?c:null)}b.P(function(b){li(a,b)})}
function ei(a,b){var c=oi(a,b).path(),d=Sf(a.uc,b);Wf(d,function(b){ri(a,b)});ri(a,d);Vf(d,function(b){ri(a,b)});return c}
function ri(a,b){var c=b.Ca();if(null!==c){for(var d=[],e=[],f=-1,h=0;h<c.length;h++)4!==c[h].status&&(2===c[h].status?(K(f===h-1,"All SENT items should be at beginning of queue."),f=h,c[h].status=4,c[h].ke="set"):(K(1===c[h].status,"Unexpected transaction status in abort"),c[h].ie(),e=e.concat(zf(a.L,c[h].Ba,!0)),c[h].H&&d.push(q(c[h].H,null,Error("set"),!1,null))));-1===f?Tf(b,null):c.length=f+1;Ab(a.da,b.path(),e);for(h=0;h<d.length;h++)Db(d[h])}};function W(){this.oc={};this.Sf=!1}W.prototype.yb=function(){for(var a in this.oc)this.oc[a].yb()};W.prototype.rc=function(){for(var a in this.oc)this.oc[a].rc()};W.prototype.ve=function(){this.Sf=!0};ca(W);W.prototype.interrupt=W.prototype.yb;W.prototype.resume=W.prototype.rc;function X(a,b){this.bd=a;this.ra=b}X.prototype.cancel=function(a){x("Firebase.onDisconnect().cancel",0,1,arguments.length);A("Firebase.onDisconnect().cancel",1,a,!0);this.bd.Jd(this.ra,a||null)};X.prototype.cancel=X.prototype.cancel;X.prototype.remove=function(a){x("Firebase.onDisconnect().remove",0,1,arguments.length);jg("Firebase.onDisconnect().remove",this.ra);A("Firebase.onDisconnect().remove",1,a,!0);fi(this.bd,this.ra,null,a)};X.prototype.remove=X.prototype.remove;
X.prototype.set=function(a,b){x("Firebase.onDisconnect().set",1,2,arguments.length);jg("Firebase.onDisconnect().set",this.ra);bg("Firebase.onDisconnect().set",a,this.ra,!1);A("Firebase.onDisconnect().set",2,b,!0);fi(this.bd,this.ra,a,b)};X.prototype.set=X.prototype.set;
X.prototype.Kb=function(a,b,c){x("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);jg("Firebase.onDisconnect().setWithPriority",this.ra);bg("Firebase.onDisconnect().setWithPriority",a,this.ra,!1);fg("Firebase.onDisconnect().setWithPriority",2,b);A("Firebase.onDisconnect().setWithPriority",3,c,!0);gi(this.bd,this.ra,a,b,c)};X.prototype.setWithPriority=X.prototype.Kb;
X.prototype.update=function(a,b){x("Firebase.onDisconnect().update",1,2,arguments.length);jg("Firebase.onDisconnect().update",this.ra);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}eg("Firebase.onDisconnect().update",a,this.ra);A("Firebase.onDisconnect().update",2,b,!0);
hi(this.bd,this.ra,a,b)};X.prototype.update=X.prototype.update;function Y(a,b,c,d){this.k=a;this.path=b;this.n=c;this.lc=d}
function si(a){var b=null,c=null;a.ma&&(b=nd(a));a.pa&&(c=pd(a));if(a.g===Qd){if(a.ma){if("[MIN_NAME]"!=md(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.pa){if("[MAX_NAME]"!=od(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===N){if(null!=b&&!ag(b)||null!=c&&!ag(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(K(a.g instanceof Ud||a.g===$d,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function ti(a){if(a.ma&&a.pa&&a.ja&&(!a.ja||""===a.Nb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function ui(a,b){if(!0===a.lc)throw Error(b+": You can't combine multiple orderBy calls.");}g=Y.prototype;g.Ib=function(){x("Query.ref",0,0,arguments.length);return new U(this.k,this.path)};
g.Eb=function(a,b,c,d){x("Query.on",2,4,arguments.length);gg("Query.on",a,!1);A("Query.on",2,b,!1);var e=vi("Query.on",c,d);if("value"===a)ii(this.k,this,new id(b,e.cancel||null,e.Ma||null));else{var f={};f[a]=b;ii(this.k,this,new jd(f,e.cancel,e.Ma))}return b};
g.ic=function(a,b,c){x("Query.off",0,3,arguments.length);gg("Query.off",a,!0);A("Query.off",2,b,!0);mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new id(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new jd(e,null,c||null));e=this.k;d=".info"===E(this.path)?e.Cd.jb(this,d):e.L.jb(this,d);yb(e.da,this.path,d)};
g.Dg=function(a,b){function c(h){f&&(f=!1,e.ic(a,c),b.call(d.Ma,h))}x("Query.once",2,4,arguments.length);gg("Query.once",a,!1);A("Query.once",2,b,!1);var d=vi("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.Eb(a,c,function(b){e.ic(a,c);d.cancel&&d.cancel.call(d.Ma,b)})};
g.He=function(a){O("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");x("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.He(a);ti(b);return new Y(this.k,this.path,b,this.lc)};
g.Ie=function(a){x("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Ie(a),this.lc)};
g.Je=function(a){x("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Je(a),this.lc)};
g.Eg=function(a){x("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');ig("Query.orderByChild",a);ui(this,"Query.orderByChild");var b=new L(a);if(b.e())throw Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
b=new Ud(b);b=de(this.n,b);si(b);return new Y(this.k,this.path,b,!0)};g.Fg=function(){x("Query.orderByKey",0,0,arguments.length);ui(this,"Query.orderByKey");var a=de(this.n,Qd);si(a);return new Y(this.k,this.path,a,!0)};g.Gg=function(){x("Query.orderByPriority",0,0,arguments.length);ui(this,"Query.orderByPriority");var a=de(this.n,N);si(a);return new Y(this.k,this.path,a,!0)};
g.Hg=function(){x("Query.orderByValue",0,0,arguments.length);ui(this,"Query.orderByValue");var a=de(this.n,$d);si(a);return new Y(this.k,this.path,a,!0)};g.$d=function(a,b){x("Query.startAt",0,2,arguments.length);bg("Query.startAt",a,this.path,!0);hg("Query.startAt",b);var c=this.n.$d(a,b);ti(c);si(c);if(this.n.ma)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");n(a)||(b=a=null);return new Y(this.k,this.path,c,this.lc)};
g.td=function(a,b){x("Query.endAt",0,2,arguments.length);bg("Query.endAt",a,this.path,!0);hg("Query.endAt",b);var c=this.n.td(a,b);ti(c);si(c);if(this.n.pa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Y(this.k,this.path,c,this.lc)};
g.kg=function(a,b){x("Query.equalTo",1,2,arguments.length);bg("Query.equalTo",a,this.path,!1);hg("Query.equalTo",b);if(this.n.ma)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.pa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.$d(a,b).td(a,b)};
g.toString=function(){x("Query.toString",0,0,arguments.length);for(var a=this.path,b="",c=a.Z;c<a.o.length;c++)""!==a.o[c]&&(b+="/"+encodeURIComponent(String(a.o[c])));return this.k.toString()+(b||"/")};g.va=function(){var a=Uc(ee(this.n));return"{}"===a?"default":a};
function vi(a,b,c){var d={cancel:null,Ma:null};if(b&&c)d.cancel=b,A(a,3,d.cancel,!0),d.Ma=c,mb(a,4,d.Ma);else if(b)if("object"===typeof b&&null!==b)d.Ma=b;else if("function"===typeof b)d.cancel=b;else throw Error(y(a,3,!0)+" must either be a cancel callback or a context object.");return d}Y.prototype.ref=Y.prototype.Ib;Y.prototype.on=Y.prototype.Eb;Y.prototype.off=Y.prototype.ic;Y.prototype.once=Y.prototype.Dg;Y.prototype.limit=Y.prototype.He;Y.prototype.limitToFirst=Y.prototype.Ie;
Y.prototype.limitToLast=Y.prototype.Je;Y.prototype.orderByChild=Y.prototype.Eg;Y.prototype.orderByKey=Y.prototype.Fg;Y.prototype.orderByPriority=Y.prototype.Gg;Y.prototype.orderByValue=Y.prototype.Hg;Y.prototype.startAt=Y.prototype.$d;Y.prototype.endAt=Y.prototype.td;Y.prototype.equalTo=Y.prototype.kg;Y.prototype.toString=Y.prototype.toString;var Z={};Z.vc=Kh;Z.DataConnection=Z.vc;Kh.prototype.Rg=function(a,b){this.Fa("q",{p:a},b)};Z.vc.prototype.simpleListen=Z.vc.prototype.Rg;Kh.prototype.jg=function(a,b){this.Fa("echo",{d:a},b)};Z.vc.prototype.echo=Z.vc.prototype.jg;Kh.prototype.interrupt=Kh.prototype.yb;Z.Vf=yh;Z.RealTimeConnection=Z.Vf;yh.prototype.sendRequest=yh.prototype.Fa;yh.prototype.close=yh.prototype.close;
Z.rg=function(a){var b=Kh.prototype.put;Kh.prototype.put=function(c,d,e,f){n(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Kh.prototype.put=b}};Z.hijackHash=Z.rg;Z.Uf=zc;Z.ConnectionTarget=Z.Uf;Z.va=function(a){return a.va()};Z.queryIdentifier=Z.va;Z.tg=function(a){return a.k.Ra.$};Z.listens=Z.tg;Z.ve=function(a){a.ve()};Z.forceRestClient=Z.ve;function U(a,b){var c,d,e;if(a instanceof Yh)c=a,d=b;else{x("new Firebase",1,2,arguments.length);d=Pc(arguments[0]);c=d.Tg;"firebase"===d.domain&&Oc(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c&&"undefined"!=c||Oc("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.kb||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&O("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new zc(d.host,d.kb,c,"ws"===d.scheme||"wss"===d.scheme);d=new L(d.$c);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!$f(c.hc))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Yf.test(e)));if(f)throw Error(y("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof W)e=b;else if(p(b))e=W.ub(),c.Od=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=W.ub();f=c.toString();var h=w(e.oc,f);h||(h=new Yh(c,e.Sf),e.oc[f]=h);c=h}Y.call(this,c,d,be,!1)}ma(U,Y);var wi=U,xi=["Firebase"],yi=aa;xi[0]in yi||!yi.execScript||yi.execScript("var "+xi[0]);for(var zi;xi.length&&(zi=xi.shift());)!xi.length&&n(wi)?yi[zi]=wi:yi=yi[zi]?yi[zi]:yi[zi]={};U.goOffline=function(){x("Firebase.goOffline",0,0,arguments.length);W.ub().yb()};U.goOnline=function(){x("Firebase.goOnline",0,0,arguments.length);W.ub().rc()};
function Lc(a,b){K(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?Bb=q(console.log,console):"object"===typeof console.log&&(Bb=function(a){console.log(a)})),b&&yc.set("logging_enabled",!0)):a?Bb=a:(Bb=null,yc.remove("logging_enabled"))}U.enableLogging=Lc;U.ServerValue={TIMESTAMP:{".sv":"timestamp"}};U.SDK_VERSION=hb;U.INTERNAL=V;U.Context=W;U.TEST_ACCESS=Z;
U.prototype.name=function(){O("Firebase.name() being deprecated. Please use Firebase.key() instead.");x("Firebase.name",0,0,arguments.length);return this.key()};U.prototype.name=U.prototype.name;U.prototype.key=function(){x("Firebase.key",0,0,arguments.length);return this.path.e()?null:Ld(this.path)};U.prototype.key=U.prototype.key;
U.prototype.u=function(a){x("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof L))if(null===E(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));ig("Firebase.child",b)}else ig("Firebase.child",a);return new U(this.k,this.path.u(a))};U.prototype.child=U.prototype.u;U.prototype.parent=function(){x("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new U(this.k,a)};U.prototype.parent=U.prototype.parent;
U.prototype.root=function(){x("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};U.prototype.root=U.prototype.root;U.prototype.set=function(a,b){x("Firebase.set",1,2,arguments.length);jg("Firebase.set",this.path);bg("Firebase.set",a,this.path,!1);A("Firebase.set",2,b,!0);this.k.Kb(this.path,a,null,b||null)};U.prototype.set=U.prototype.set;
U.prototype.update=function(a,b){x("Firebase.update",1,2,arguments.length);jg("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}eg("Firebase.update",a,this.path);A("Firebase.update",2,b,!0);this.k.update(this.path,a,b||null)};U.prototype.update=U.prototype.update;
U.prototype.Kb=function(a,b,c){x("Firebase.setWithPriority",2,3,arguments.length);jg("Firebase.setWithPriority",this.path);bg("Firebase.setWithPriority",a,this.path,!1);fg("Firebase.setWithPriority",2,b);A("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Kb(this.path,a,b,c||null)};U.prototype.setWithPriority=U.prototype.Kb;
U.prototype.remove=function(a){x("Firebase.remove",0,1,arguments.length);jg("Firebase.remove",this.path);A("Firebase.remove",1,a,!0);this.set(null,a)};U.prototype.remove=U.prototype.remove;
U.prototype.transaction=function(a,b,c){x("Firebase.transaction",1,3,arguments.length);jg("Firebase.transaction",this.path);A("Firebase.transaction",1,a,!1);A("Firebase.transaction",2,b,!0);if(n(c)&&"boolean"!=typeof c)throw Error(y("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);ji(this.k,this.path,a,b||null,c)};U.prototype.transaction=U.prototype.transaction;
U.prototype.Og=function(a,b){x("Firebase.setPriority",1,2,arguments.length);jg("Firebase.setPriority",this.path);fg("Firebase.setPriority",1,a);A("Firebase.setPriority",2,b,!0);this.k.Kb(this.path.u(".priority"),a,null,b)};U.prototype.setPriority=U.prototype.Og;
U.prototype.push=function(a,b){x("Firebase.push",0,2,arguments.length);jg("Firebase.push",this.path);bg("Firebase.push",a,this.path,!0);A("Firebase.push",2,b,!0);var c=$h(this.k),c=Fe(c),c=this.u(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};U.prototype.push=U.prototype.push;U.prototype.hb=function(){jg("Firebase.onDisconnect",this.path);return new X(this.k,this.path)};U.prototype.onDisconnect=U.prototype.hb;
U.prototype.M=function(a,b,c){O("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");x("Firebase.auth",1,3,arguments.length);kg("Firebase.auth",a);A("Firebase.auth",2,b,!0);A("Firebase.auth",3,b,!0);Yg(this.k.M,a,{},{remember:"none"},b,c)};U.prototype.auth=U.prototype.M;U.prototype.ge=function(a){x("Firebase.unauth",0,1,arguments.length);A("Firebase.unauth",1,a,!0);Zg(this.k.M,a)};U.prototype.unauth=U.prototype.ge;
U.prototype.xe=function(){x("Firebase.getAuth",0,0,arguments.length);return this.k.M.xe()};U.prototype.getAuth=U.prototype.xe;U.prototype.xg=function(a,b){x("Firebase.onAuth",1,2,arguments.length);A("Firebase.onAuth",1,a,!1);mb("Firebase.onAuth",2,b);this.k.M.Eb("auth_status",a,b)};U.prototype.onAuth=U.prototype.xg;U.prototype.wg=function(a,b){x("Firebase.offAuth",1,2,arguments.length);A("Firebase.offAuth",1,a,!1);mb("Firebase.offAuth",2,b);this.k.M.ic("auth_status",a,b)};U.prototype.offAuth=U.prototype.wg;
U.prototype.Zf=function(a,b,c){x("Firebase.authWithCustomToken",2,3,arguments.length);kg("Firebase.authWithCustomToken",a);A("Firebase.authWithCustomToken",2,b,!1);ng("Firebase.authWithCustomToken",3,c,!0);Yg(this.k.M,a,{},c||{},b)};U.prototype.authWithCustomToken=U.prototype.Zf;U.prototype.$f=function(a,b,c){x("Firebase.authWithOAuthPopup",2,3,arguments.length);mg("Firebase.authWithOAuthPopup",a);A("Firebase.authWithOAuthPopup",2,b,!1);ng("Firebase.authWithOAuthPopup",3,c,!0);ch(this.k.M,a,c,b)};
U.prototype.authWithOAuthPopup=U.prototype.$f;U.prototype.ag=function(a,b,c){x("Firebase.authWithOAuthRedirect",2,3,arguments.length);mg("Firebase.authWithOAuthRedirect",a);A("Firebase.authWithOAuthRedirect",2,b,!1);ng("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.M;ah(d);var e=[Kg],f=vg(c);"anonymous"===a||"firebase"===a?P(b,Mg("TRANSPORT_UNAVAILABLE")):(yc.set("redirect_client_options",f.od),bh(d,e,"/auth/"+a,f,b))};U.prototype.authWithOAuthRedirect=U.prototype.ag;
U.prototype.bg=function(a,b,c,d){x("Firebase.authWithOAuthToken",3,4,arguments.length);mg("Firebase.authWithOAuthToken",a);A("Firebase.authWithOAuthToken",3,c,!1);ng("Firebase.authWithOAuthToken",4,d,!0);p(b)?(lg("Firebase.authWithOAuthToken",2,b),$g(this.k.M,a+"/token",{access_token:b},d,c)):(ng("Firebase.authWithOAuthToken",2,b,!1),$g(this.k.M,a+"/token",b,d,c))};U.prototype.authWithOAuthToken=U.prototype.bg;
U.prototype.Yf=function(a,b){x("Firebase.authAnonymously",1,2,arguments.length);A("Firebase.authAnonymously",1,a,!1);ng("Firebase.authAnonymously",2,b,!0);$g(this.k.M,"anonymous",{},b,a)};U.prototype.authAnonymously=U.prototype.Yf;
U.prototype.cg=function(a,b,c){x("Firebase.authWithPassword",2,3,arguments.length);ng("Firebase.authWithPassword",1,a,!1);og("Firebase.authWithPassword",a,"email");og("Firebase.authWithPassword",a,"password");A("Firebase.authWithPassword",2,b,!1);ng("Firebase.authWithPassword",3,c,!0);$g(this.k.M,"password",a,c,b)};U.prototype.authWithPassword=U.prototype.cg;
U.prototype.se=function(a,b){x("Firebase.createUser",2,2,arguments.length);ng("Firebase.createUser",1,a,!1);og("Firebase.createUser",a,"email");og("Firebase.createUser",a,"password");A("Firebase.createUser",2,b,!1);this.k.M.se(a,b)};U.prototype.createUser=U.prototype.se;U.prototype.Te=function(a,b){x("Firebase.removeUser",2,2,arguments.length);ng("Firebase.removeUser",1,a,!1);og("Firebase.removeUser",a,"email");og("Firebase.removeUser",a,"password");A("Firebase.removeUser",2,b,!1);this.k.M.Te(a,b)};
U.prototype.removeUser=U.prototype.Te;U.prototype.pe=function(a,b){x("Firebase.changePassword",2,2,arguments.length);ng("Firebase.changePassword",1,a,!1);og("Firebase.changePassword",a,"email");og("Firebase.changePassword",a,"oldPassword");og("Firebase.changePassword",a,"newPassword");A("Firebase.changePassword",2,b,!1);this.k.M.pe(a,b)};U.prototype.changePassword=U.prototype.pe;
U.prototype.oe=function(a,b){x("Firebase.changeEmail",2,2,arguments.length);ng("Firebase.changeEmail",1,a,!1);og("Firebase.changeEmail",a,"oldEmail");og("Firebase.changeEmail",a,"newEmail");og("Firebase.changeEmail",a,"password");A("Firebase.changeEmail",2,b,!1);this.k.M.oe(a,b)};U.prototype.changeEmail=U.prototype.oe;
U.prototype.Ve=function(a,b){x("Firebase.resetPassword",2,2,arguments.length);ng("Firebase.resetPassword",1,a,!1);og("Firebase.resetPassword",a,"email");A("Firebase.resetPassword",2,b,!1);this.k.M.Ve(a,b)};U.prototype.resetPassword=U.prototype.Ve;})();

module.exports = Firebase;

},{}]},{},["/Users/dave/lh2/angular2/study-tracker/client/app/main.ts"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQvYXBwL21haW4udHMiLCJjbGllbnQvYXBwL3BsYW4udHMiLCJjbGllbnQvYXBwL3NpZ25pbi50cyIsImNsaWVudC9hcHAvdXNlcnMudHMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvYW5ndWxhcjIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvYm9vdHN0cmFwLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL2NvcmUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbGlmZWN5Y2xlX2hvb2tzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9ub2RlX21vZHVsZXMvQHJlYWN0aXZleC9yeGpzL2Rpc3QvY2pzL1N1YmplY3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvU3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvc3ViamVjdHMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9ub2RlX21vZHVsZXMvQHJlYWN0aXZleC9yeGpzL2Rpc3QvY2pzL3V0aWwvU3ltYm9sX29ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL25vb3AuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3Rocm93RXJyb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3RyeU9yT25FcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9wcm9maWxlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2FuaW1hdGUvYW5pbWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9hbmltYXRlL2FuaW1hdGlvbl9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9hbmltYXRlL2Jyb3dzZXJfZGV0YWlscy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvYW5pbWF0ZS9jc3NfYW5pbWF0aW9uX2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2FuaW1hdGUvY3NzX2FuaW1hdGlvbl9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2FwcGxpY2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2FwcGxpY2F0aW9uX2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9hcHBsaWNhdGlvbl9yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvYXBwbGljYXRpb25fdG9rZW5zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Jvb3RzdHJhcC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYmluZGluZ19yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdG9yX3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvYWxlc2NlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY29kZWdlbl9mYWNhZGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jb2RlZ2VuX2xvZ2ljX3V0aWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jb2RlZ2VuX25hbWVfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2RpZmZlcnMvZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9kaWZmZXJzL2RlZmF1bHRfa2V5dmFsdWVfZGlmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9rZXl2YWx1ZV9kaWZmZXJzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlyZWN0aXZlX3JlY29yZC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2R5bmFtaWNfY2hhbmdlX2RldGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZXZlbnRfYmluZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2V4Y2VwdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9pbnRlcmZhY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vaml0X3Byb3RvX2NoYW5nZV9kZXRlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL29ic2VydmFibGVfZmFjYWRlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGFyc2VyL2FzdC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3BhcnNlci9sZXhlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3BhcnNlci9sb2NhbHMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wYXJzZXIvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGlwZV9saWZlY3ljbGVfcmVmbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGlwZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wcm90b19jaGFuZ2VfZGV0ZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wcm90b19yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9hcHBfcm9vdF91cmwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY2hhbmdlX2RlZmluaXRpb25fZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY29tbWFuZF9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9kaXJlY3RpdmVfbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvaHRtbF9hc3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvaHRtbF9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvcnVudGltZV9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9ydW50aW1lX21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NjaGVtYS9kb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NlbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NoYWRvd19jc3MuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc291cmNlX21vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zdHlsZV9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zdHlsZV91cmxfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfYXN0LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX25vcm1hbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX3ByZXBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci91cmxfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIveGhyX2ltcGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGVidWcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGVidWcvZGVidWdfZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kZWJ1Zy9kZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9leGNlcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2ZvcndhcmRfcmVmLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2luamVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9vcGFxdWVfdG9rZW4uanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvdHlwZV9saXRlcmFsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9uZ19jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaXJlY3RpdmVzL25nX2Zvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaXJlY3RpdmVzL25nX2lmLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpcmVjdGl2ZXMvbmdfc3R5bGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9uZ19zd2l0Y2guanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9vYnNlcnZhYmxlX2xpc3RfZGlmZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kb20vYnJvd3Nlcl9hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kb20vZ2VuZXJpY19icm93c2VyX2FkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9uX2hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2ludGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL21hdGguanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvY2hlY2tib3hfdmFsdWVfYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9jb250cm9sX2NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX3N0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL25nX2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX2NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfbW9kZWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZm9ybV9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlmZV9jeWNsZS9saWZlX2N5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpZmVjeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9kaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZGlyZWN0aXZlX3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2VsZW1lbnRfYmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9lbGVtZW50X2luamVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9lbGVtZW50X3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZXZlbnRfY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9pbnRlcmZhY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9waXBlX3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9wcm90b192aWV3X2ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3F1ZXJ5X2xpc3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3RlbXBsYXRlX2NvbW1hbmRzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci90ZW1wbGF0ZV9yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19saXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X21hbmFnZXJfdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvZGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvZGlyZWN0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL2FzeW5jX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvZGF0ZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL2RlZmF1bHRfcGlwZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9qc29uX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvbG93ZXJjYXNlX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvbnVtYmVyX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvcGlwZV9wcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9waXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9zbGljZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL3VwcGVyY2FzZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BsYXRmb3JtX2JpbmRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Byb2ZpbGUvcHJvZmlsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9wcm9maWxlL3d0Zl9pbXBsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Byb2ZpbGUvd3RmX2luaXQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9hcGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9kb21fcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9kb21fdG9rZW5zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9kb20vZXZlbnRzL2V2ZW50X21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMvaGFtbWVyX2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL2V2ZW50cy9oYW1tZXJfZ2VzdHVyZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMva2V5X2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3NoYXJlZF9zdHlsZXNfaG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvdmlld19mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3NlcnZpY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3NlcnZpY2VzL3RpdGxlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Rlc3RhYmlsaXR5L2Jyb3dzZXJfdGVzdGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvdGVzdGFiaWxpdHkvdGVzdGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS91dGlsL2RlY29yYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvem9uZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS96b25lL25nX3pvbmUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9hc3luY19yb3V0ZV9oYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvaGFzaF9sb2NhdGlvbl9zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL2luc3RydWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvbGlmZWN5Y2xlX2Fubm90YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9sb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL2xvY2F0aW9uX3N0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcGF0aF9sb2NhdGlvbl9zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3BhdGhfcmVjb2duaXplci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2NvbmZpZ19kZWNvcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9jb25maWdfaW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2NvbmZpZ19ub21hbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcm91dGVfZGVmaW5pdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9yZWNvZ25pemVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcm91dGVfcmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZXJfbGluay5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlcl9vdXRsZXQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9zeW5jX3JvdXRlX2hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci91cmxfcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy90cmFuc2Zvcm0vdGVtcGxhdGVfY29tcGlsZXIvY2hhbmdlX2RldGVjdG9yX2NvZGVnZW4uanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvbnBtLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9hZmZpeC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvYWxlcnQuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2J1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvY2Fyb3VzZWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2NvbGxhcHNlLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9kcm9wZG93bi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvbW9kYWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3BvcG92ZXIuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3Njcm9sbHNweS5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvdGFiLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxrRUFBa0U7QUFDbEUsNkRBQTZEO0FBQzdELDZEQUE2RDs7Ozs7Ozs7Ozs7O0FBRTdELE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUVyQix5QkFBc0UsbUJBQW1CLENBQUMsQ0FBQTtBQUUxRix1QkFBc0UsaUJBQWlCLENBQUMsQ0FBQTtBQUN4Rix1QkFBc0UsaUJBQWlCLENBQUMsQ0FBQTtBQUN4Rix1QkFBc0UsaUJBQWlCLENBQUMsQ0FBQTtBQUV4RixzQkFBd0IsU0FBUyxDQUFDLENBQUE7QUFDbEMsdUJBQXdCLFVBQVUsQ0FBQyxDQUFBO0FBQ25DLHFCQUF3QixRQUFRLENBQUMsQ0FBQTtBQUlqQyxJQUFJLFFBQVEsR0FBSyxPQUFPLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUV6RDtJQTBCSSxzQkFBWSxNQUFlO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUksSUFBSSxRQUFRLENBQUMsc0NBQXNDLENBQUMsQ0FBQztRQUNuRSxPQUFPLENBQUMsR0FBRyxDQUFDLHNDQUFzQyxDQUFDLENBQUE7SUFDdkQsQ0FBQztJQUVELHdDQUFpQixHQUFqQixVQUFrQixRQUFRO1FBQ3RCLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBQzFCLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVqRCxnRUFBZ0U7UUFDaEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUksU0FBUztJQUMzQyxDQUFDO0lBdENMO1FBQUMsb0JBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxLQUFLO1NBQ2xCLENBQUM7UUFFRCxlQUFJLENBQUM7WUFDRixVQUFVLEVBQUUsQ0FBQyxtQkFBVSxFQUFFLHFCQUFZLEVBQUUsaUJBQVMsQ0FBQztZQUVqRCxRQUFRLEVBQUUsMExBTUw7U0FDUixDQUFDO1FBRUQsb0JBQVcsQ0FBQztZQUNULEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBSyxFQUFFLEVBQUUsTUFBTSxFQUFJLFNBQVMsRUFBRSxXQUFJLEVBQUU7WUFDbkQsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFHLEVBQUUsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLGVBQU0sRUFBRTtTQUN4RCxDQUFDOztxQkFvQkQ7SUFBRCxtQkFBQztBQUFELENBdkNBLEFBdUNDLElBQUE7QUFFRCwyRUFBMkU7QUFDM0UsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFO0lBQzFDLG9CQUFTLENBQUMsWUFBWTtJQUVaLDJDQUEyQztJQUMzQztRQUNWLHlCQUFnQjtRQUNGLGtCQUFPLENBQUMseUJBQWdCLEVBQUUsRUFBQyxRQUFRLEVBQUUsNkJBQW9CLEVBQUMsQ0FBQztLQUM5RCxDQUVELENBQUM7QUFFZixDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7OztBQ3pFVixrRUFBa0U7QUFDbEUsNkRBQTZEOzs7Ozs7Ozs7Ozs7QUFFN0QseUJBQWdDLG1CQUFtQixDQUFDLENBQUE7QUFJcEQ7SUFlSTtRQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMseUJBQXlCLENBQUMsQ0FBQTtRQUV0QyxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFLLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDNUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQU0sSUFBSSxFQUFFLE1BQU0sRUFBRTtZQUN6QyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQzVDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFLLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBRXRELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUNqQyxNQUFNLEVBQVksSUFBSTtZQUN0QixTQUFTLEVBQVMsQ0FBQztZQUNuQixlQUFlLEVBQUcsSUFBSTtZQUN0QixPQUFPLEVBQVcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRTtZQUN4RCxTQUFTLEVBQUssVUFBUyxJQUFJO2dCQUM5QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDcEQsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQ2IsSUFBSSxHQUFHLDBEQUEwRCxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQztnQkFDeEcsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDSixJQUFJLEdBQUcseUNBQXlDLEdBQUcsSUFBSSxDQUFDO2dCQUM1RCxDQUFDO2dCQUNELE1BQU0sQ0FBQyxJQUFJLENBQUE7WUFDUixDQUFDO1lBQ00sV0FBVyxFQUFPLFVBQVMsSUFBSTtnQkFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzVDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNqQixNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUM3QyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ25DLENBQUM7WUFDUyxDQUFDO1lBQ0QsT0FBTyxFQUFXLFVBQVMsSUFBSTtnQkFDM0IsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2pCLE1BQU0sQ0FBQyxFQUFDLEVBQUUsRUFBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDO2dCQUNsRCxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ2hCLENBQUM7WUFDTCxDQUFDO1NBQ0osQ0FBQyxDQUFDO1FBRVYsa0NBQWtDO1FBQ2xDLCtGQUErRjtRQUMvRixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLHFCQUFxQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsQ0FBQztZQUNsRSxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQUM7SUFDQSxDQUFDO0lBMURMO1FBQUMsb0JBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxNQUFNO1NBQ25CLENBQUM7UUFFRCxlQUFJLENBQUM7WUFDRixRQUFRLEVBQUUsZ1JBTUw7U0FDUixDQUFDOzthQStDRDtJQUFELFdBQUM7QUFBRCxDQTNEQSxBQTJEQyxJQUFBO0FBN0NZLFlBQUksT0E2Q2hCLENBQUE7OztBQ2xFRCxrRUFBa0U7QUFDbEUsNkRBQTZEO0FBQzdELDZEQUE2RDs7Ozs7Ozs7Ozs7O0FBRTdELHlCQUF1QyxtQkFBbUIsQ0FBQyxDQUFBO0FBQzNELHVCQUF1QyxpQkFBaUIsQ0FBQyxDQUFBO0FBSXpEO0lBY0k7SUFDQSxDQUFDO0lBZkw7UUFBQyxvQkFBUyxDQUFDO1lBQ1AsUUFBUSxFQUFFLFFBQVE7U0FDckIsQ0FBQztRQUVELGVBQUksQ0FBQztZQUNGLFVBQVUsRUFBRSxDQUFDLG1CQUFVLENBQUM7WUFFeEIsUUFBUSxFQUFFLCtDQUVMO1NBQ1IsQ0FBQzs7ZUFNRDtJQUFELGFBQUM7QUFBRCxDQWhCQSxBQWdCQyxJQUFBO0FBSlksY0FBTSxTQUlsQixDQUFBOzs7QUN6QkQsa0VBQWtFO0FBQ2xFLDZEQUE2RDs7Ozs7Ozs7Ozs7O0FBRTdELHlCQUE0QyxtQkFBbUIsQ0FBQyxDQUFBO0FBRXJELFlBQUksR0FBRyxFQUFFLENBQUM7QUFFckI7SUFpREk7UUFDSSxPQUFPLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxDQUFDLENBQUE7UUFFakQsaURBQWlEO1FBQ2pELCtEQUErRDtRQUUvRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksdUJBQVksRUFBRSxDQUFDO1FBRXBDLElBQUksQ0FBQyxNQUFNLEdBQU0sSUFBSSxDQUFDLENBQUUsNEJBQTRCO1FBQ3BELElBQUksQ0FBQyxLQUFLLEdBQU8sSUFBSSxDQUFDO1FBRXRCLElBQUksQ0FBQyxJQUFJLEdBQVEsWUFBSSxDQUFDO1FBRXRCLGFBQWE7UUFDYixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsMENBQTBDLENBQUMsQ0FBQTtJQUMzRCxDQUFDO0lBRUQsMEJBQU0sR0FBTjtRQUNJLGtEQUFrRDtRQUNsRCw0REFBNEQ7UUFFNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHFDQUFxQztJQUNwRSxDQUFDO0lBRUQsa0NBQWMsR0FBZCxVQUFlLE1BQU0sRUFBRSxLQUFLO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUVoQixJQUFJLENBQUMsS0FBSyxHQUFJLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUVkLHVDQUF1QztRQUN2QyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFTLFFBQVE7WUFDL0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCx5QkFBSyxHQUFMLFVBQU0sUUFBUTtRQUNqQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFFVCxFQUFFLENBQUMsQ0FBQyxRQUFRLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMxQixLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUM7UUFDWCxDQUFDO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsVUFBUyxLQUFLLEVBQUUsUUFBUTtZQUM1RCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNSLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssdUJBQXVCLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxtREFBbUQ7b0JBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLFVBQVMsS0FBSzt3QkFDckQsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs0QkFDUixPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxLQUFLLENBQUMsQ0FBQzt3QkFDeEMsQ0FBQztvQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFDUCxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNKLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUN4QyxDQUFDO1lBQ0wsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNsQixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsa0NBQWtDO2dCQUNqRSxPQUFPLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3RFLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDSixPQUFPLENBQUMsR0FBRyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7WUFDbkUsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELDBCQUFNLEdBQU47UUFDSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELGtDQUFjLEdBQWQsVUFBZSxRQUFRO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFLLFFBQVEsQ0FBQztRQUVqQyxJQUFJLFFBQVEsQ0FBQztRQUViLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDWCxRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNqQyxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDSixRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLENBQUM7UUFFRCxNQUFNLENBQUEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLEtBQUssUUFBUTtnQkFDVCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBUSxJQUFJLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7Z0JBQ3BGLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUM7Z0JBQ3JGLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUM7Z0JBQ3ZFLEtBQUssQ0FBQztZQUNWO2dCQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFRLEtBQUssQ0FBQztnQkFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQVMsSUFBSSxDQUFDO2dCQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBVSxJQUFJLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztnQkFDakMsS0FBSyxDQUFDO1FBQ1YsQ0FBQztJQUNMLENBQUM7SUFuSkw7UUFBQyxvQkFBUyxDQUFDO1lBQ1AsUUFBUSxFQUFFLFlBQVk7WUFDdEIsTUFBTSxFQUFJLENBQUMsV0FBVyxDQUFDLENBQUssK0NBQStDO1NBQzlFLENBQUM7UUFFRCxlQUFJLENBQUM7WUFDRixRQUFRLEVBQUUsd3NCQWlCUDtTQUNOLENBQUM7O2tCQTRIRDtJQUFELGdCQUFDO0FBQUQsQ0FwSkEsQUFvSkMsSUFBQTtBQTFIWSxpQkFBUyxZQTBIckIsQ0FBQTs7O0FDM0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzViQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyL2FuZ3VsYXIyLmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvZmlyZWJhc2UvZmlyZWJhc2UuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy9yZXF1aXJlanMvcmVxdWlyZS5kLnRzXCIgLz5cblxucmVxdWlyZShcImJvb3RzdHJhcFwiKTtcblxuaW1wb3J0IHtDb21wb25lbnQsIFZpZXcsIGJvb3RzdHJhcCwgcHJvdmlkZX0gICAgICAgICAgICAgICAgICAgICBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XG5cbmltcG9ydCB7Uk9VVEVSX1BST1ZJREVSUywgUm91dGVDb25maWcsIFJvdXRlcn0gICAgICAgICAgICAgICAgICAgZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcbmltcG9ydCB7Um91dGUsIExvY2F0aW9uLCBMb2NhdGlvblN0cmF0ZWd5LCBIYXNoTG9jYXRpb25TdHJhdGVneX0gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcbmltcG9ydCB7Um91dGVyTGluaywgUm91dGVyT3V0bGV0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcblxuaW1wb3J0IHtVc2VyQmxvY2t9IGZyb20gJy4vdXNlcnMnO1xuaW1wb3J0IHtTaWduSW59ICAgIGZyb20gJy4vc2lnbmluJztcbmltcG9ydCB7UGxhbn0gICAgICBmcm9tICcuL3BsYW4nO1xuXG5kZWNsYXJlIHZhciBqUXVlcnk6YW55O1xuXG52YXIgRmlyZWJhc2UgICA9IHJlcXVpcmUoJ2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMnKTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhcHAnXG59KVxuXG5AVmlldyh7XG4gICAgZGlyZWN0aXZlczogW1JvdXRlckxpbmssIFJvdXRlck91dGxldCwgVXNlckJsb2NrXSxcblxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDx1c2VyLWJsb2NrIChpbml0ZXZlbnQpPVwicmVnaXN0ZXJVc2VyQmxvY2soJGV2ZW50KVwiPiA8L3VzZXItYmxvY2s+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICAgIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGBcbn0pXG5cbkBSb3V0ZUNvbmZpZyhbXG4gICAgeyBwYXRoOiAnL3BsYW4nLCAgICBhczogJ1BsYW4nLCAgIGNvbXBvbmVudDogUGxhbiB9LFxuICAgIHsgcGF0aDogJy9zaWduaW4nLCAgYXM6ICdTaWduSW4nLCBjb21wb25lbnQ6IFNpZ25JbiB9XG5dKVxuXG5jbGFzcyBTdHVkeVRyYWNrZXIge1xuICAgIHVzZXJCbG9jayAgIDogVXNlckJsb2NrO1xuICAgIGZiUmVmICAgICAgIDogRmlyZWJhc2U7XG4gICAgcm91dGVyICAgICAgOiBSb3V0ZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIgOiBSb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuZmJSZWYgID0gbmV3IEZpcmViYXNlKCdodHRwczovL3N0dWR5LXRyYWNrZXIuZmlyZWJhc2Vpby5jb20nKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJtYWluLnRzOiBpbiBTdHVkeVRyYWNrZXIgY29uc3RydWN0b3JcIilcbiAgICB9XG5cbiAgICByZWdpc3RlclVzZXJCbG9jayh1c2VyQ29tcCkge1xuICAgICAgICB0aGlzLnVzZXJCbG9jayA9IHVzZXJDb21wO1xuICAgICAgICB1c2VyQ29tcC5yZWdpc3RlclBhcmVudCh0aGlzLCB0aGlzLmZiUmVmKTtcblxuXHQvLyBOT1RFOiBoZXJlIHdlIHVzZSB0aGUgcm91dGVyICpuYW1lKiBub3QgdGhlIGFjdHVhbCByb3V0ZSBVUkwhXG5cdHRoaXMucm91dGVyLm5hdmlnYXRlKFsnLi9QbGFuJ10pOyAgICAvLyBTaWduSW5cbiAgICB9XG59XG5cbi8vIHNpbWlsYXIgdG8galF1ZXJ5KGRvY3VtZW50KS5yZWFkeSgpLCBidXQgZG9lc24ndCB3b3JrIGluIG9sZCBJRSBicm93c2Vyc1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7IFxuICAgIGJvb3RzdHJhcChTdHVkeVRyYWNrZXIsIFxuXG4gICAgICAgICAgICAgIC8vIExpc3Qgb2YgdW5pdmVyc2FsbHkgaW5qZWN0YWJsZSBwcm92aWRlcnNcbiAgICAgICAgICAgICAgW1xuXHRcdCAgUk9VVEVSX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGUoTG9jYXRpb25TdHJhdGVneSwge3VzZUNsYXNzOiBIYXNoTG9jYXRpb25TdHJhdGVneX0pXG4gICAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgICk7XG5cbn0sIGZhbHNlKTtcblxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL25vZGVfbW9kdWxlcy9hbmd1bGFyMi9hbmd1bGFyMi5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi90eXBpbmdzL3JlcXVpcmVqcy9yZXF1aXJlLmQudHNcIiAvPlxuXG5pbXBvcnQge0NvbXBvbmVudCwgVmlld30gICBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XG5cbmRlY2xhcmUgdmFyIGpRdWVyeTphbnk7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncGxhbidcbn0pXG5cbkBWaWV3KHtcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtcHJvdmlkZT1cInR5cGVhaGVhZFwiIGlkPVwiY2F0ZWdvcnktc2VsZWN0XCIgcGxhY2Vob2xkZXI9XCJFbnRlciBhIGNsYXNzXCI+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sbGFwc2VcIiBpZD1cImNhdGVnb3J5LWFkZFwiPlxuICBcdCAgICBTZWxlY3QgYSBjb2xvciBmb3IgbmV3IGNsYXNzIDxiIGlkPVwiY2F0ZWdvcnktYWRkLW5hbWVcIj48L2I+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIGBcbn0pXG5cbmV4cG9ydCBjbGFzcyBQbGFuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJwbGFuLnRzOiBpbiBjb25zdHJ1Y3RvclwiKVxuXG4gICAgICAgIHZhciBkYXRhID0gW3sgaWQ6IDEsIGNvbG9yOiAnYmx1ZScsICAgIG5hbWU6ICdTY2llbmNlJyB9LCBcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogMiwgY29sb3I6ICdyZWQnLCAgICAgbmFtZTogJ01hdGgnIH0sIFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiAzLCBjb2xvcjogJyNBQTIyQkInLCBuYW1lOiAnRW5nbGlzaCcgfSwgXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IDQsIGNvbG9yOiAnIzIyMicsICAgIG5hbWU6ICdBcnQnIH1dO1xuXG4gICAgICAgIGpRdWVyeShcIiNjYXRlZ29yeS1zZWxlY3RcIikudHlwZWFoZWFkKHtcbiAgICAgICAgICAgIHNvdXJjZSAgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBtaW5MZW5ndGggICAgICAgOiAwLFxuICAgICAgICAgICAgc2hvd0hpbnRPbkZvY3VzIDogdHJ1ZSxcbiAgICAgICAgICAgIGFkZEl0ZW0gICAgICAgICA6IHsgaWQ6IC0xLCBuYW1lOiAnKEFkZCBjbGFzcyknIH0sXG5cdCAgICBmb3JtYXR0ZXIgICA6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgaHRtbCA9IHRoaXMuaGlnaGxpZ2h0ZXIodGhpcy5kaXNwbGF5VGV4dChpdGVtKSk7XG5cdFx0aWYgKGl0ZW0uY29sb3IpIHtcblx0XHQgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tY29sb3ItYm94XCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBpdGVtLmNvbG9yICsgJ1wiPiA8L2Rpdj4nICsgaHRtbDtcblx0XHR9IGVsc2Uge1xuXHRcdCAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1jb2xvci1ib3hcIj4gPC9kaXY+JyArIGh0bWw7XG5cdFx0fVxuXHRcdHJldHVybiBodG1sXG5cdCAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJTZWxlY3QgICAgIDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWN0ZWRcIiwgaXRlbSk7XG5cdFx0aWYgKGl0ZW0uaWQgPT09IC0yKSB7XG5cdFx0ICAgIGpRdWVyeShcIiNjYXRlZ29yeS1hZGQtbmFtZVwiKS50ZXh0KGl0ZW0ubmFtZSk7XG5cdFx0ICAgIGpRdWVyeShcIiNjYXRlZ29yeS1hZGRcIikuc2hvdygpO1xuXHRcdH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVyICAgICAgICAgOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7aWQgOiAtMiwgbmFtZSA6IHRoaXMuJGVsZW1lbnQudmFsKCkgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cdC8vIEZpeCBmb3IgYnVnIGluIElPUyBhcyByZXBvcnRlZDpcblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjE5MDc4My93aHktZG9lc250LWJvb3RzdHJhcC1idXR0b24tZHJvcGRvd24td29yay1vbi1pb3Ncblx0alF1ZXJ5KCdib2R5Jykub24oJ3RvdWNoc3RhcnQuZHJvcGRvd24nLCAnLmRyb3Bkb3duLW1lbnUnLCBmdW5jdGlvbiAoZSkgeyBcblx0ICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IFxuXHR9KTtcbiAgICB9XG59XG5cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9ub2RlX21vZHVsZXMvYW5ndWxhcjIvYW5ndWxhcjIuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy9maXJlYmFzZS9maXJlYmFzZS5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi90eXBpbmdzL3JlcXVpcmVqcy9yZXF1aXJlLmQudHNcIiAvPlxuXG5pbXBvcnQge0NvbXBvbmVudCwgVmlld30gICAgICAgICAgZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xuaW1wb3J0IHtSb3V0ZXJMaW5rfSAgICAgICAgICAgICAgIGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XG5cbmRlY2xhcmUgdmFyIGpRdWVyeTphbnk7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnc2lnbmluJ1xufSlcblxuQFZpZXcoe1xuICAgIGRpcmVjdGl2ZXM6IFtSb3V0ZXJMaW5rXSxcblxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxoMT4gUGxlYXNlIHNpZ24gaW4gPC9oMT5cbiAgICAgICAgYFxufSlcblxuZXhwb3J0IGNsYXNzIFNpZ25JbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyL2FuZ3VsYXIyLmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvZmlyZWJhc2UvZmlyZWJhc2UuZC50c1wiIC8+XG5cbmltcG9ydCB7Q29tcG9uZW50LCBWaWV3LCBFdmVudEVtaXR0ZXJ9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcblxuZXhwb3J0IHZhciBVc2VyID0ge307XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXNlci1ibG9jaycsXG4gICAgZXZlbnRzOiAgIFsnaW5pdGV2ZW50J10gICAgIC8vIE5PVEUgdGhhdCBldmVudCBuYW1lcyBtdXN0IGJlIGFsbCBsb3dlciBjYXNlXG59KVxuXG5AVmlldyh7XG4gICAgdGVtcGxhdGU6IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25pbi1mb3JtXCI+XG4gICAgICAgICAgPGRpdiBbaGlkZGVuXT1cInVzZXIuaXNMb2dnZWRJblwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzPVwiZm9ybS1zaWduaW4taGVhZGluZ1wiPlBsZWFzZSBzaWduIGluIHVzaW5nOjwvaDM+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1sZyBidG4tcHJpbWFyeSBidG4tYmxvY2tcIiAoY2xpY2spPVwibG9naW4oJ2dvb2dsZScpXCI+ICBHb29nbGUgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tbGcgYnRuLXByaW1hcnkgYnRuLWJsb2NrXCIgKGNsaWNrKT1cImxvZ2luKCdmYWNlYm9vaycpXCI+RmFjZWJvb2s8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgW2hpZGRlbl09XCIhdXNlci5pc0xvZ2dlZEluXCI+XG4gICAgICAgICAgICBIZWxsbyB7e3VzZXIuZmlyc3ROYW1lfX0gPGltZyBzcmM9XCJ7e3VzZXIucHJvZmlsZUltYWdlVVJMfX1cIi8+IFxuICAgICAgICAgICAgPGEgY2xhc3M9XCJidG5cIiAoY2xpY2spPVwibG9nb3V0KClcIj5cbiAgICAgICAgICAgICAgU2lnbiBvdXRcbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIGBcbn0pXG5cbmV4cG9ydCBjbGFzcyBVc2VyQmxvY2sge1xuICAgIHVzZXIgOiBhbnk7XG4gICAgXG4gICAgLy9cbiAgICAvLyBDdXJyZW50bHkgYSAzLXN0ZXAgaW5pdGlhbGl6YXRpb24gdG8gaG9vay11cCBjaGlsZCB0byBwYXJlbnQgY29tcG9uZW50c1xuICAgIC8vXG4gICAgLy8gICBjb25zdHJ1Y3RvcigpIC0gW25hbWUgZml4ZWQgYnkgSlMvVHlwZXNjcmlwdF0gbG9jYWwgKG5vbi1hbmd1bGFyMi1kZXBlbmRlbnQpIGRhdGEgb25seSBcbiAgICAvL1xuICAgIC8vICAgb25Jbml0KCkgICAgICAtIFtuYW1lIGZpeGVkIGJ5IGFuZ3VsYXIyXSBhbmd1bGFyMiBsaWZlY3ljbGUgaW5pdC1kb25lIGV2ZW50IGNhbGxiYWNrIFxuICAgIC8vICAgICAgICAgICAgICAgICAgIEdlbmVyYXRlIGEgaW5pdGV2ZW50IFtEQiBjb252ZW50aW9uIG5hbWVdIHRvIGFsZXJ0IHBhcmVudCBvZiBuZXcgY2hpbGQgY29tcG9uZW50LlxuICAgIC8vICAgICAgICAgICAgICAgICAgIChQYXJlbnQgY29tcG9uZW50IHdpbGwgdGhlbiB0eXBpY2FsbHkgaGF2ZSBhIHJlZ2lzdGVyPENoaWxkQ29tcG9uZW50VHlwZT4oKSBldmVudCBoYW5kbGVyKVxuICAgIC8vXG4gICAgLy8gICByZWdpc3RlclBhcmVudCgpIC0gW0RCIGNvbnZlbnRpb24gbmFtZV0gY2FsbGVkIGJ5IHBhcmVudCBjb21wb25lbnRcbiAgICAvL1xuICAgIC8vIFRPRE86IEVhc2llciBtZXRob2QgdG8gZ2V0IHBvaW50ZXJzIHRvIHBhcmVudCAmIGNoaWxkcmVuIGNvbXBvbmVudHMgXG4gICAgLy8gICAgICAgKGFuZC9vciB0aGVpciBuZWVkZWQgZGF0YSlcbiAgICAvL1xuICAgIC8vXG5cbiAgICBwYXJlbnQgICAgICAgIDogYW55OyAgXG4gICAgZmJSZWYgICAgICAgICA6IEZpcmViYXNlOyAgICAgIC8vIFRvRG86IHVzZSBkZXBlbmRlbmN5IGluamVjdG9yIHRvIGdldCBEYXRhYmFzZSBzZXJ2aWNlXG4gICAgaW5pdGV2ZW50ICAgICA6IEV2ZW50RW1pdHRlcjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInVzZXJzLnRzOiBpbiBVc2VyQmxvY2sgY29uc3RydWN0b3JcIilcblxuICAgICAgICAvLyBPbmx5IGluaXRpYWxpemUgbG9jYWxseSBpbnN0YXRpYXRlZCBkYXRhIGhlcmUgXG4gICAgICAgIC8vIChhbmd1bGFyMi1kZXBlbmRlbnQgZGF0YSBoYXMgbm90IHlldCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkKVxuXG4gICAgICAgIHRoaXMuaW5pdGV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgICAgIHRoaXMucGFyZW50ICAgID0gbnVsbDsgIC8vIHdpbGwgYmUgc2V0IGJ5IHRoZSBwYXJlbnRcbiAgICAgICAgdGhpcy5mYlJlZiAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudXNlciAgICAgID0gVXNlcjtcblxuICAgICAgICAvLyBJbml0aWFsaXplXG4gICAgICAgIHRoaXMudXBkYXRlVXNlckRhdGEobnVsbCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJ1c2Vycy50czogZmluaXNoZWQgVXNlckJsb2NrIGNvbnN0cnVjdG9yXCIpXG4gICAgfVxuXG4gICAgb25Jbml0KCkge1xuICAgICAgICAvLyBvbkluaXQoKSBpcyBhIGFuZ3VsYXIyIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIFxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuZ3VsYXIyIGhhcyBjb21wbGV0ZWQgaW5pdGlhbGl6YXRpb25cblxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uSW5pdDogZm9yIFVzZXJzIENvbXBvbmVudFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0ZXZlbnQubmV4dCh0aGlzKTsgLy8gc2VuZCBpbml0ZXZlbnQgdG8gcGFyZW50IGNvbXBvbmVudFxuICAgIH1cblxuICAgIHJlZ2lzdGVyUGFyZW50KHBhcmVudCwgZmJSZWYpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHRoaXMuZmJSZWYgID0gZmJSZWY7XG5cdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhdXRoZW50aWNhdGlvbiBjYWxsYmFja1xuICAgICAgICB0aGlzLmZiUmVmLm9uQXV0aChmdW5jdGlvbihhdXRoRGF0YSkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVVc2VyRGF0YShhdXRoRGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZ2luKHByb3ZpZGVyKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAocHJvdmlkZXIgPT09ICdmYWNlYm9vaycpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiU29ycnksIEZhY2Vib29rIHNpZ25pbiBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmJSZWYuYXV0aFdpdGhPQXV0aFBvcHVwKHByb3ZpZGVyLCBmdW5jdGlvbihlcnJvciwgYXV0aERhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIGR1ZSB0byBub3QgYWxsb3dpbmcgcG9wLXVwcyBpbiB0aGlzIGVudlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZiUmVmLmF1dGhXaXRoT0F1dGhSZWRpcmVjdChcImdvb2dsZVwiLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpbiBGYWlsZWQhXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9naW4gRmFpbGVkIVwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhdXRoRGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlVXNlckRhdGEoYXV0aERhdGEpOyAvLyBhY2NlbGVyYXRlIHRoZSBwcm9jZXNzIGEgbGl0dGxlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBdXRoZW50aWNhdGVkIHN1Y2Nlc3NmdWxseSB3aXRoIHBheWxvYWQ6XCIsIGF1dGhEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpbiBhcHBhcmVudGx5IGZhaWxlZCwgYnV0IHdpdGhvdXQgZXJyb3IgaW5mb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9nb3V0KCkge1xuICAgICAgICB0aGlzLmZiUmVmLnVuYXV0aCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXJEYXRhKG51bGwpO1xuICAgIH1cblxuICAgIHVwZGF0ZVVzZXJEYXRhKGF1dGhEYXRhKSB7XG4gICAgICAgIHRoaXMudXNlci5fYXV0aERhdGEgICA9IGF1dGhEYXRhO1xuXG4gICAgICAgIHZhciBwcm92aWRlcjtcblxuICAgICAgICBpZiAoYXV0aERhdGEpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gYXV0aERhdGEucHJvdmlkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2gocHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSAnZ29vZ2xlJzpcbiAgICAgICAgICAgIHRoaXMudXNlci5pc0xvZ2dlZEluICAgICAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VyLmZpcnN0TmFtZSAgICAgICA9IHRoaXMudXNlci5fYXV0aERhdGEuZ29vZ2xlLmNhY2hlZFVzZXJQcm9maWxlLmdpdmVuX25hbWU7XG4gICAgICAgICAgICB0aGlzLnVzZXIubGFzdE5hbWUgICAgICAgID0gdGhpcy51c2VyLl9hdXRoRGF0YS5nb29nbGUuY2FjaGVkVXNlclByb2ZpbGUuZmFtaWx5X25hbWU7XG4gICAgICAgICAgICB0aGlzLnVzZXIucHJvZmlsZUltYWdlVVJMID0gdGhpcy51c2VyLl9hdXRoRGF0YS5nb29nbGUucHJvZmlsZUltYWdlVVJMO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLnVzZXIuaXNMb2dnZWRJbiAgICAgID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVzZXIuZmlyc3ROYW1lICAgICAgID0gbnVsbDsgXG4gICAgICAgICAgICB0aGlzLnVzZXIubGFzdE5hbWUgICAgICAgID0gbnVsbDsgXG4gICAgICAgICAgICB0aGlzLnVzZXIucHJvZmlsZUltYWdlVVJMID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2NvcmUnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vcHJvZmlsZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9saWZlY3ljbGVfaG9va3MnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYm9vdHN0cmFwJykpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmd1bGFyMi5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgZm9yIGRhcnQgYXBwbGljYXRpb25zIGFuZCBmb3IgaW50ZXJuYWwgZXhhbXBsZXNcclxuICogdGhhdCBjb21waWxlIHdpdGggYm90aCBKYXZhU2NyaXB0IGFuZCBEYXJ0LlxyXG4gKi9cclxudmFyIGJvb3RzdHJhcF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvYm9vdHN0cmFwJyk7XHJcbmV4cG9ydHMuYm9vdHN0cmFwID0gYm9vdHN0cmFwXzEuYm9vdHN0cmFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuanMubWFwIiwiJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG4vKipcclxuICogQG1vZHVsZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3RhcnRpbmcgcG9pbnQgdG8gaW1wb3J0IGFsbCBwdWJsaWMgY29yZSBBUElzLlxyXG4gKi9cclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9tZXRhZGF0YScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS91dGlsJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2RpJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL3BpcGVzJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2ZhY2FkZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9hcHBsaWNhdGlvbicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9ib290c3RyYXAnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvc2VydmljZXMnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvbGlua2VyJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2xpZmVjeWNsZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS96b25lJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL3JlbmRlcicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9kaXJlY3RpdmVzJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2Zvcm1zJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2RlYnVnJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24nKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZWZpbmVzIGludGVyZmFjZXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgZGlyZWN0aXZlcyB3aGVuIHRoZXkgbmVlZCB0byBob29rIGludG8gdGhlIGNoYW5nZVxyXG4gKiBkZXRlY3Rpb24gbWVjaGFuaXNtLlxyXG4gKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmZWN5Y2xlX2hvb2tzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9TdWJzY3JpYmVyID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG5cbnZhciBfU3Vic2NyaWJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJzY3JpYmVyKTtcblxudmFyIF91dGlsU3ltYm9sX29ic2VydmFibGUgPSByZXF1aXJlKCcuL3V0aWwvU3ltYm9sX29ic2VydmFibGUnKTtcblxudmFyIF91dGlsU3ltYm9sX29ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbFN5bWJvbF9vYnNlcnZhYmxlKTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFueSBzZXQgb2YgdmFsdWVzIG92ZXIgYW55IGFtb3VudCBvZiB0aW1lLiBUaGlzIHRoZSBtb3N0IGJhc2ljIGJ1aWxkaW5nIGJsb2NrXG4gKiBvZiBSeEpTLlxuICpcbiAqIEBjbGFzcyBPYnNlcnZhYmxlPFQ+XG4gKi9cblxudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpc1xuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBPYnNlcnZhYmxlIGlzIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3IgYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeVxuICAgICAqIG9mIGEgc3VjY2VzZnVsIGNvbXBsZXRpb24uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JzZXJ2YWJsZSk7XG5cbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlLlxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqIEBkZXNjcmlwdGlvbiBjcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqIEBkZXNjcmlwdGlvbiBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKi9cblxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiBsaWZ0KG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAZGVzY3JpcHRpb24gYW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKi9cblxuICAgIE9ic2VydmFibGUucHJvdG90eXBlW191dGlsU3ltYm9sX29ic2VydmFibGUyWydkZWZhdWx0J11dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBzdWJzY3JpYmVcbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfEZ1bmN0aW9ufSBvYnNlcnZlck9yTmV4dCAob3B0aW9uYWwpIGVpdGhlciBhbiBvYnNlcnZlciBkZWZpbmluZyBhbGwgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZCxcbiAgICAgKiAgb3IgdGhlIGZpcnN0IG9mIHRocmVlIHBvc3NpYmxlIGhhbmRsZXJzLCB3aGljaCBpcyB0aGUgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgKG9wdGlvbmFsKSBhIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gYW4gZXJyb3IuIElmIG5vIGVycm9yIGhhbmRsZXIgaXMgcHJvdmlkZWQsXG4gICAgICogIHRoZSBlcnJvciB3aWxsIGJlIHRocm93biBhcyB1bmhhbmRsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbn0gYSBzdWJzY3JpcHRpb24gcmVmZXJlbmNlIHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzXG4gICAgICogQGRlc2NyaXB0aW9uIHJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcbiAgICAgKiAgZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbVxuICAgICAqL1xuXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCAmJiB0eXBlb2Ygb2JzZXJ2ZXJPck5leHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCBpbnN0YW5jZW9mIF9TdWJzY3JpYmVyMlsnZGVmYXVsdCddKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlciA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyID0gbmV3IF9TdWJzY3JpYmVyMlsnZGVmYXVsdCddKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBzdWJzY3JpYmVyID0gX1N1YnNjcmliZXIyWydkZWZhdWx0J10uY3JlYXRlKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5hZGQodGhpcy5fc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgYSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cblxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKG5leHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKG5leHQsIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5fc3Vic2NyaWJlKHRoaXMub3BlcmF0b3IuY2FsbChzdWJzY3JpYmVyKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gT2JzZXJ2YWJsZTtcbk9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9PYnNlcnZhYmxlMiA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xuXG52YXIgX09ic2VydmFibGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2JzZXJ2YWJsZTIpO1xuXG52YXIgX1N1YnNjcmliZXIgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcblxudmFyIF9TdWJzY3JpYmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmliZXIpO1xuXG52YXIgX1N1YnNjcmlwdGlvbiA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbik7XG5cbnZhciBfc3ViamVjdHNTdWJqZWN0U3Vic2NyaXB0aW9uID0gcmVxdWlyZSgnLi9zdWJqZWN0cy9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG5cbnZhciBfc3ViamVjdHNTdWJqZWN0U3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1YmplY3RzU3ViamVjdFN1YnNjcmlwdGlvbik7XG5cbnZhciBzdWJzY3JpcHRpb25BZGQgPSBfU3Vic2NyaXB0aW9uMlsnZGVmYXVsdCddLnByb3RvdHlwZS5hZGQ7XG52YXIgc3Vic2NyaXB0aW9uUmVtb3ZlID0gX1N1YnNjcmlwdGlvbjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUucmVtb3ZlO1xudmFyIHN1YnNjcmlwdGlvblVuc3Vic2NyaWJlID0gX1N1YnNjcmlwdGlvbjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUudW5zdWJzY3JpYmU7XG52YXIgc3Vic2NyaWJlck5leHQgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUubmV4dDtcbnZhciBzdWJzY3JpYmVyRXJyb3IgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuZXJyb3I7XG52YXIgc3Vic2NyaWJlckNvbXBsZXRlID0gX1N1YnNjcmliZXIyWydkZWZhdWx0J10ucHJvdG90eXBlLmNvbXBsZXRlO1xudmFyIF9zdWJzY3JpYmVyTmV4dCA9IF9TdWJzY3JpYmVyMlsnZGVmYXVsdCddLnByb3RvdHlwZS5fbmV4dDtcbnZhciBfc3Vic2NyaWJlckVycm9yID0gX1N1YnNjcmliZXIyWydkZWZhdWx0J10ucHJvdG90eXBlLl9lcnJvcjtcbnZhciBfc3Vic2NyaWJlckNvbXBsZXRlID0gX1N1YnNjcmliZXIyWydkZWZhdWx0J10ucHJvdG90eXBlLl9jb21wbGV0ZTtcbnZhciBfb2JzZXJ2YWJsZVN1YnNjcmliZSA9IF9PYnNlcnZhYmxlM1snZGVmYXVsdCddLnByb3RvdHlwZS5fc3Vic2NyaWJlO1xuXG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX09ic2VydmFibGUpIHtcbiAgICBfaW5oZXJpdHMoU3ViamVjdCwgX09ic2VydmFibGUpO1xuXG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YmplY3QpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgX09ic2VydmFibGUuY2FsbC5hcHBseShfT2JzZXJ2YWJsZSwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yU2lnbmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGxldGVTaWduYWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlkaXJlY3Rpb25hbFN1YmplY3Qoc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiBsaWZ0KG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEJpZGlyZWN0aW9uYWxTdWJqZWN0KHRoaXMsIHRoaXMuZGVzdGluYXRpb24gfHwgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiBfc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVycm9yU2lnbmFsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMuZXJyb3JJbnN0YW5jZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb21wbGV0ZVNpZ25hbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJzY3JpYmUgdG8gYSBkaXNwb3NlZCBTdWJqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICByZXR1cm4gbmV3IF9zdWJqZWN0c1N1YmplY3RTdWJzY3JpcHRpb24yWydkZWZhdWx0J10odGhpcywgc3Vic2NyaWJlcik7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uQWRkLmNhbGwodGhpcywgc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBzdWJzY3JpcHRpb25SZW1vdmUuY2FsbCh0aGlzLCBzdWJzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IHZvaWQgMDtcbiAgICAgICAgc3Vic2NyaXB0aW9uVW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JTaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5lcnJvckluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbXBsZXRlU2lnbmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQgfHwgdGhpcy5jb21wbGV0ZVNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3JTaWduYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9ySW5zdGFuY2UgPSBfZXJyb3I7XG4gICAgICAgIGlmICh0aGlzLmRpc3BhdGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3IoX2Vycm9yKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCB8fCB0aGlzLmVycm9yU2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wbGV0ZVNpZ25hbCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmRpc3BhdGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnMuc2xpY2UoMCk7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzW2luZGV4XS5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiBfZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIC8vIG9wdGltaXphdGlvbiAtLSBibG9jayBuZXh0LCBjb21wbGV0ZSwgYW5kIHVuc3Vic2NyaWJlIHdoaWxlIGRpc3BhdGNoaW5nXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIG9ic2VydmVyc1tpbmRleF0uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gX2NvbXBsZXRlKCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIC0tIGJsb2NrIG5leHQsIGNvbXBsZXRlLCBhbmQgdW5zdWJzY3JpYmUgd2hpbGUgZGlzcGF0Y2hpbmdcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB2b2lkIDA7IC8vIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIG9ic2VydmVyc1tpbmRleF0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJqZWN0O1xufSkoX09ic2VydmFibGUzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdWJqZWN0O1xuXG52YXIgQmlkaXJlY3Rpb25hbFN1YmplY3QgPSAoZnVuY3Rpb24gKF9TdWJqZWN0KSB7XG4gICAgX2luaGVyaXRzKEJpZGlyZWN0aW9uYWxTdWJqZWN0LCBfU3ViamVjdCk7XG5cbiAgICBmdW5jdGlvbiBCaWRpcmVjdGlvbmFsU3ViamVjdChzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaWRpcmVjdGlvbmFsU3ViamVjdCk7XG5cbiAgICAgICAgX1N1YmplY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIF9zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gX29ic2VydmFibGVTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuXG4gICAgQmlkaXJlY3Rpb25hbFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0KHgpIHtcbiAgICAgICAgc3Vic2NyaWJlck5leHQuY2FsbCh0aGlzLCB4KTtcbiAgICB9O1xuXG4gICAgQmlkaXJlY3Rpb25hbFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICBzdWJzY3JpYmVyRXJyb3IuY2FsbCh0aGlzLCBlKTtcbiAgICB9O1xuXG4gICAgQmlkaXJlY3Rpb25hbFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHN1YnNjcmliZXJDb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiBfbmV4dCh4KSB7XG4gICAgICAgIF9zdWJzY3JpYmVyTmV4dC5jYWxsKHRoaXMsIHgpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gX2Vycm9yKGUpIHtcbiAgICAgICAgX3N1YnNjcmliZXJFcnJvci5jYWxsKHRoaXMsIGUpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gX2NvbXBsZXRlKCkge1xuICAgICAgICBfc3Vic2NyaWJlckNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBCaWRpcmVjdGlvbmFsU3ViamVjdDtcbn0pKFN1YmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdXRpbE5vb3AgPSByZXF1aXJlKCcuL3V0aWwvbm9vcCcpO1xuXG52YXIgX3V0aWxOb29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxOb29wKTtcblxudmFyIF91dGlsVGhyb3dFcnJvciA9IHJlcXVpcmUoJy4vdXRpbC90aHJvd0Vycm9yJyk7XG5cbnZhciBfdXRpbFRocm93RXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbFRocm93RXJyb3IpO1xuXG52YXIgX3V0aWxUcnlPck9uRXJyb3IgPSByZXF1aXJlKCcuL3V0aWwvdHJ5T3JPbkVycm9yJyk7XG5cbnZhciBfdXRpbFRyeU9yT25FcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsVHJ5T3JPbkVycm9yKTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcblxudmFyIF9TdWJzY3JpcHRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaXB0aW9uMik7XG5cbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfU3Vic2NyaXB0aW9uKSB7XG4gICAgX2luaGVyaXRzKFN1YnNjcmliZXIsIF9TdWJzY3JpcHRpb24pO1xuXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaWJlcik7XG5cbiAgICAgICAgX1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIGlmICghZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gZGVzdGluYXRpb24uX3N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcigpO1xuICAgICAgICBzdWJzY3JpYmVyLl9uZXh0ID0gdHlwZW9mIG5leHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdXRpbFRyeU9yT25FcnJvcjJbJ2RlZmF1bHQnXShuZXh0KSB8fCBfdXRpbE5vb3AyWydkZWZhdWx0J107XG4gICAgICAgIHN1YnNjcmliZXIuX2Vycm9yID0gdHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIgJiYgZXJyb3IgfHwgX3V0aWxUaHJvd0Vycm9yMlsnZGVmYXVsdCddO1xuICAgICAgICBzdWJzY3JpYmVyLl9jb21wbGV0ZSA9IHR5cGVvZiBjb21wbGV0ZSA9PT0gXCJmdW5jdGlvblwiICYmIGNvbXBsZXRlIHx8IF91dGlsTm9vcDJbJ2RlZmF1bHQnXTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gX2Vycm9yKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIF9jb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc3ViKSB7XG4gICAgICAgIC8vIHJvdXRlIGFkZCB0byB0aGUgc2hhcmVkIFN1YnNjcmlwdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgdmFyIF9zdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChfc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uLmFkZChzdWIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX1N1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgc3ViKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc3ViKSB7XG4gICAgICAgIC8vIHJvdXRlIHJlbW92ZSB0byB0aGUgc2hhcmVkIFN1YnNjcmlwdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnJlbW92ZShzdWIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX1N1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgc3ViKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9TdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9lcnJvcjIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihfZXJyb3IyKTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFN1YnNjcmliZXIsIFt7XG4gICAgICAgIGtleTogJ2lzVW5zdWJzY3JpYmVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHJvdXRlIHRvIHRoZSBzaGFyZWQgU3Vic2NyaXB0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1Vuc3Vic2NyaWJlZCB8fCBzdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1Vuc3Vic2NyaWJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcm91dGUgdG8gdGhlIHNoYXJlZCBTdWJzY3JpcHRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzVW5zdWJzY3JpYmVkID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzVW5zdWJzY3JpYmVkID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0pKF9TdWJzY3JpcHRpb24zWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdWJzY3JpYmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihfdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoX3Vuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IF91bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gX3Vuc3Vic2NyaWJlKCkge307XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IHRoaXMuX3Vuc3Vic2NyaWJlO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB2b2lkIDA7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBzdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1tpbmRleF0udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmOlxuICAgICAgICAvLyAgMS4gdGhlIHN1YnNjcmlwdGlvbiBpcyBudWxsXG4gICAgICAgIC8vICAyLiB3ZSdyZSBhdHRlbXB0aW5nIHRvIGFkZCBvdXIgdGhpc1xuICAgICAgICAvLyAgMy4gd2UncmUgYXR0ZW1wdGluZyB0byBhZGQgdGhlIHN0YXRpYyBgZW1wdHlgIFN1YnNjcmlwdGlvblxuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbiB8fCBzdWJzY3JpcHRpb24gPT09IHRoaXMgfHwgc3Vic2NyaXB0aW9uID09PSBTdWJzY3JpcHRpb24uRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmlzVW5zdWJzY3JpYmVkIHx8IHR5cGVvZiBzdWIudW5zdWJzY3JpYmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHN1YnNjcmlwdGlvbiAnICsgc3Vic2NyaXB0aW9uICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIHJldHVybiBlYXJseSBpZjpcbiAgICAgICAgLy8gIDEuIHRoZSBzdWJzY3JpcHRpb24gaXMgbnVsbFxuICAgICAgICAvLyAgMi4gd2UncmUgYXR0ZW1wdGluZyB0byByZW1vdmUgb3VydGhpc1xuICAgICAgICAvLyAgMy4gd2UncmUgYXR0ZW1wdGluZyB0byByZW1vdmUgdGhlIHN0YXRpYyBgZW1wdHlgIFN1YnNjcmlwdGlvblxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uID09IG51bGwgfHwgc3Vic2NyaXB0aW9uID09PSB0aGlzIHx8IHN1YnNjcmlwdGlvbiA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN1YnNjcmlwdGlvbjtcblxuU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgIGVtcHR5LmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZW1wdHk7XG59KShuZXcgU3Vic2NyaXB0aW9uKCkpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuXG52YXIgX1N1YnNjcmlwdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJzY3JpcHRpb24yKTtcblxudmFyIFN1YmplY3RTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9TdWJzY3JpcHRpb24pIHtcbiAgICBfaW5oZXJpdHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX1N1YnNjcmlwdGlvbik7XG5cbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIG9ic2VydmVyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJqZWN0U3Vic2NyaXB0aW9uKTtcblxuICAgICAgICBfU3Vic2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMgfHwgb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCB8fCBzdWJqZWN0LmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufSkoX1N1YnNjcmlwdGlvbjNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN1YmplY3RTdWJzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuXG5pZiAoIV9yb290LnJvb3QuU3ltYm9sKSB7XG4gICAgX3Jvb3Qucm9vdC5TeW1ib2wgPSB7fTtcbn1cbmlmICghX3Jvb3Qucm9vdC5TeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgIGlmICh0eXBlb2YgX3Jvb3Qucm9vdC5TeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9yb290LnJvb3QuU3ltYm9sLm9ic2VydmFibGUgPSBfcm9vdC5yb290LlN5bWJvbFsnZm9yJ10oJ29ic2VydmFibGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfcm9vdC5yb290LlN5bWJvbC5vYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxufVxuZXhwb3J0c1snZGVmYXVsdCddID0gX3Jvb3Qucm9vdC5TeW1ib2wub2JzZXJ2YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBub29wO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlLFxuICAgICdudW1iZXInOiBmYWxzZSxcbiAgICAnc3RyaW5nJzogZmFsc2UsXG4gICAgJ3VuZGVmaW5lZCc6IGZhbHNlXG59O1xudmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZiB8fCBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3c7XG5leHBvcnRzLnJvb3QgPSByb290O1xudmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcbnZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xudmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG5pZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgZXhwb3J0cy5yb290ID0gcm9vdCA9IGZyZWVHbG9iYWw7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHRocm93RXJyb3I7XG5cbmZ1bmN0aW9uIHRocm93RXJyb3IoZSkge1xuICB0aHJvdyBlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB0cnlPck9uRXJyb3I7XG5cbmZ1bmN0aW9uIHRyeU9yT25FcnJvcih0YXJnZXQpIHtcbiAgICBmdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJ5Q2F0Y2hlci50YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlDYXRjaGVyLnRhcmdldCA9IHRhcmdldDtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7dmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvcHJvZmlsZS9wcm9maWxlJyk7XHJcbmV4cG9ydHMud3RmQ3JlYXRlU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGU7XHJcbmV4cG9ydHMud3RmTGVhdmUgPSBwcm9maWxlXzEud3RmTGVhdmU7XHJcbmV4cG9ydHMud3RmU3RhcnRUaW1lUmFuZ2UgPSBwcm9maWxlXzEud3RmU3RhcnRUaW1lUmFuZ2U7XHJcbmV4cG9ydHMud3RmRW5kVGltZVJhbmdlID0gcHJvZmlsZV8xLnd0ZkVuZFRpbWVSYW5nZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZmlsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgb25seSB1c2VkIGZvciBkYXJ0IGFwcGxpY2F0aW9ucyBhbmQgZm9yIGludGVybmFsIGV4YW1wbGVzXHJcbiAqIHRoYXQgY29tcGlsZSB3aXRoIGJvdGggSmF2YVNjcmlwdCBhbmQgRGFydC5cclxuICpcclxuICogSmF2YVNjcmlwdCB1c2VycyBzaG91bGQgaW1wb3J0IGZyb20gYW5ndWxhcjIvY29yZS5cclxuICovXHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvcmVuZGVyJykpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBNYXBzIGFwcGxpY2F0aW9uIFVSTHMgaW50byBhcHBsaWNhdGlvbiBzdGF0ZXMsIHRvIHN1cHBvcnQgZGVlcC1saW5raW5nIGFuZCBuYXZpZ2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciByb3V0ZXJfMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZXInKTtcclxuZXhwb3J0cy5Sb3V0ZXIgPSByb3V0ZXJfMS5Sb3V0ZXI7XHJcbnZhciByb3V0ZXJfb3V0bGV0XzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVyX291dGxldCcpO1xyXG5leHBvcnRzLlJvdXRlck91dGxldCA9IHJvdXRlcl9vdXRsZXRfMS5Sb3V0ZXJPdXRsZXQ7XHJcbnZhciByb3V0ZXJfbGlua18xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlcl9saW5rJyk7XHJcbmV4cG9ydHMuUm91dGVyTGluayA9IHJvdXRlcl9saW5rXzEuUm91dGVyTGluaztcclxudmFyIGluc3RydWN0aW9uXzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvaW5zdHJ1Y3Rpb24nKTtcclxuZXhwb3J0cy5Sb3V0ZVBhcmFtcyA9IGluc3RydWN0aW9uXzEuUm91dGVQYXJhbXM7XHJcbnZhciByb3V0ZV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlX3JlZ2lzdHJ5Jyk7XHJcbmV4cG9ydHMuUm91dGVSZWdpc3RyeSA9IHJvdXRlX3JlZ2lzdHJ5XzEuUm91dGVSZWdpc3RyeTtcclxudmFyIGxvY2F0aW9uX3N0cmF0ZWd5XzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvbG9jYXRpb25fc3RyYXRlZ3knKTtcclxuZXhwb3J0cy5Mb2NhdGlvblN0cmF0ZWd5ID0gbG9jYXRpb25fc3RyYXRlZ3lfMS5Mb2NhdGlvblN0cmF0ZWd5O1xyXG52YXIgaGFzaF9sb2NhdGlvbl9zdHJhdGVneV8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL2hhc2hfbG9jYXRpb25fc3RyYXRlZ3knKTtcclxuZXhwb3J0cy5IYXNoTG9jYXRpb25TdHJhdGVneSA9IGhhc2hfbG9jYXRpb25fc3RyYXRlZ3lfMS5IYXNoTG9jYXRpb25TdHJhdGVneTtcclxudmFyIHBhdGhfbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9wYXRoX2xvY2F0aW9uX3N0cmF0ZWd5Jyk7XHJcbmV4cG9ydHMuUGF0aExvY2F0aW9uU3RyYXRlZ3kgPSBwYXRoX2xvY2F0aW9uX3N0cmF0ZWd5XzEuUGF0aExvY2F0aW9uU3RyYXRlZ3k7XHJcbnZhciBsb2NhdGlvbl8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL2xvY2F0aW9uJyk7XHJcbmV4cG9ydHMuTG9jYXRpb24gPSBsb2NhdGlvbl8xLkxvY2F0aW9uO1xyXG5leHBvcnRzLkFQUF9CQVNFX0hSRUYgPSBsb2NhdGlvbl8xLkFQUF9CQVNFX0hSRUY7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZV9jb25maWdfZGVjb3JhdG9yJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVfZGVmaW5pdGlvbicpKTtcclxudmFyIGxpZmVjeWNsZV9hbm5vdGF0aW9uc18xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL2xpZmVjeWNsZV9hbm5vdGF0aW9ucycpO1xyXG5leHBvcnRzLkNhbkFjdGl2YXRlID0gbGlmZWN5Y2xlX2Fubm90YXRpb25zXzEuQ2FuQWN0aXZhdGU7XHJcbnZhciBpbnN0cnVjdGlvbl8yID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL2luc3RydWN0aW9uJyk7XHJcbmV4cG9ydHMuSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbl8yLkluc3RydWN0aW9uO1xyXG5leHBvcnRzLkNvbXBvbmVudEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25fMi5Db21wb25lbnRJbnN0cnVjdGlvbjtcclxudmFyIGFuZ3VsYXIyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG5leHBvcnRzLk9wYXF1ZVRva2VuID0gYW5ndWxhcjJfMS5PcGFxdWVUb2tlbjtcclxudmFyIHJvdXRlX2RhdGFfMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZV9kYXRhJyk7XHJcbmV4cG9ydHMuUk9VVEVfREFUQSA9IHJvdXRlX2RhdGFfMS5ST1VURV9EQVRBO1xyXG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMiA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG52YXIgcGF0aF9sb2NhdGlvbl9zdHJhdGVneV8yID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3BhdGhfbG9jYXRpb25fc3RyYXRlZ3knKTtcclxudmFyIHJvdXRlcl8yID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlcicpO1xyXG52YXIgcm91dGVyX291dGxldF8yID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlcl9vdXRsZXQnKTtcclxudmFyIHJvdXRlcl9saW5rXzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVyX2xpbmsnKTtcclxudmFyIHJvdXRlX3JlZ2lzdHJ5XzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVfcmVnaXN0cnknKTtcclxudmFyIGxvY2F0aW9uXzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvbG9jYXRpb24nKTtcclxudmFyIGFuZ3VsYXIyXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuLyoqXHJcbiAqIFRva2VuIHVzZWQgdG8gYmluZCB0aGUgY29tcG9uZW50IHdpdGggdGhlIHRvcC1sZXZlbCB7QGxpbmsgUm91dGVDb25maWd9cyBmb3IgdGhlXHJcbiAqIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9pUlVQOEI1T1VieENXUTNBY0lEbSkpXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge1xyXG4gKiAgIFJPVVRFUl9ESVJFQ1RJVkVTLFxyXG4gKiAgIFJPVVRFUl9QUk9WSURFUlMsXHJcbiAqICAgUm91dGVDb25maWdcclxuICogfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogIHsuLi59LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge1xyXG4gKiAgIC8vIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtST1VURVJfUFJPVklERVJTXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5ST1VURVJfUFJJTUFSWV9DT01QT05FTlQgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgYW5ndWxhcjJfMi5PcGFxdWVUb2tlbignUm91dGVyUHJpbWFyeUNvbXBvbmVudCcpKTtcclxuLyoqXHJcbiAqIEEgbGlzdCBvZiBkaXJlY3RpdmVzLiBUbyB1c2UgdGhlIHJvdXRlciBkaXJlY3RpdmVzIGxpa2Uge0BsaW5rIFJvdXRlck91dGxldH0gYW5kXHJcbiAqIHtAbGluayBSb3V0ZXJMaW5rfSwgYWRkIHRoaXMgdG8geW91ciBgZGlyZWN0aXZlc2AgYXJyYXkgaW4gdGhlIHtAbGluayBWaWV3fSBkZWNvcmF0b3Igb2YgeW91clxyXG4gKiBjb21wb25lbnQuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2lSVVA4QjVPVWJ4Q1dRM0FjSURtKSlcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7Uk9VVEVSX0RJUkVDVElWRVMsIFJPVVRFUl9QUk9WSURFUlMsIFJvdXRlQ29uZmlnfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogIHsuLi59LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge1xyXG4gKiAgICAvLyAuLi5cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBbUk9VVEVSX1BST1ZJREVSU10pO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuUk9VVEVSX0RJUkVDVElWRVMgPSBsYW5nXzEuQ09OU1RfRVhQUihbcm91dGVyX291dGxldF8yLlJvdXRlck91dGxldCwgcm91dGVyX2xpbmtfMi5Sb3V0ZXJMaW5rXSk7XHJcbi8qKlxyXG4gKiBBIGxpc3Qgb2Yge0BsaW5rIFByb3ZpZGVyfXMuIFRvIHVzZSB0aGUgcm91dGVyLCB5b3UgbXVzdCBhZGQgdGhpcyB0byB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9pUlVQOEI1T1VieENXUTNBY0lEbSkpXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge1xyXG4gKiAgIFJPVVRFUl9ESVJFQ1RJVkVTLFxyXG4gKiAgIFJPVVRFUl9QUk9WSURFUlMsXHJcbiAqICAgUm91dGVDb25maWdcclxuICogfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogIHsuLi59LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge1xyXG4gKiAgIC8vIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtST1VURVJfUFJPVklERVJTXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5ST1VURVJfUFJPVklERVJTID0gbGFuZ18xLkNPTlNUX0VYUFIoW1xyXG4gICAgcm91dGVfcmVnaXN0cnlfMi5Sb3V0ZVJlZ2lzdHJ5LFxyXG4gICAgbGFuZ18xLkNPTlNUX0VYUFIobmV3IGFuZ3VsYXIyXzIuUHJvdmlkZXIobG9jYXRpb25fc3RyYXRlZ3lfMi5Mb2NhdGlvblN0cmF0ZWd5LCB7IHVzZUNsYXNzOiBwYXRoX2xvY2F0aW9uX3N0cmF0ZWd5XzIuUGF0aExvY2F0aW9uU3RyYXRlZ3kgfSkpLFxyXG4gICAgbG9jYXRpb25fMi5Mb2NhdGlvbixcclxuICAgIGxhbmdfMS5DT05TVF9FWFBSKG5ldyBhbmd1bGFyMl8yLlByb3ZpZGVyKHJvdXRlcl8yLlJvdXRlciwge1xyXG4gICAgICAgIHVzZUZhY3Rvcnk6IHJvdXRlckZhY3RvcnksXHJcbiAgICAgICAgZGVwczogbGFuZ18xLkNPTlNUX0VYUFIoW3JvdXRlX3JlZ2lzdHJ5XzIuUm91dGVSZWdpc3RyeSwgbG9jYXRpb25fMi5Mb2NhdGlvbiwgZXhwb3J0cy5ST1VURVJfUFJJTUFSWV9DT01QT05FTlRdKVxyXG4gICAgfSkpLFxyXG4gICAgbGFuZ18xLkNPTlNUX0VYUFIobmV3IGFuZ3VsYXIyXzIuUHJvdmlkZXIoZXhwb3J0cy5ST1VURVJfUFJJTUFSWV9DT01QT05FTlQsIHsgdXNlRmFjdG9yeTogcm91dGVyUHJpbWFyeUNvbXBvbmVudEZhY3RvcnksIGRlcHM6IGxhbmdfMS5DT05TVF9FWFBSKFthbmd1bGFyMl8yLkFwcGxpY2F0aW9uUmVmXSkgfSkpXHJcbl0pO1xyXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmV4cG9ydHMuUk9VVEVSX0JJTkRJTkdTID0gZXhwb3J0cy5ST1VURVJfUFJPVklERVJTO1xyXG5mdW5jdGlvbiByb3V0ZXJGYWN0b3J5KHJlZ2lzdHJ5LCBsb2NhdGlvbiwgcHJpbWFyeUNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIG5ldyByb3V0ZXJfMi5Sb290Um91dGVyKHJlZ2lzdHJ5LCBsb2NhdGlvbiwgcHJpbWFyeUNvbXBvbmVudCk7XHJcbn1cclxuZnVuY3Rpb24gcm91dGVyUHJpbWFyeUNvbXBvbmVudEZhY3RvcnkoYXBwKSB7XHJcbiAgICBpZiAoYXBwLmNvbXBvbmVudFR5cGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQm9vdHN0cmFwIGF0IGxlYXN0IG9uZSBjb21wb25lbnQgYmVmb3JlIGluamVjdGluZyBSb3V0ZXIuXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcC5jb21wb25lbnRUeXBlc1swXTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbWF0aF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL21hdGgnKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9kb20vdXRpbCcpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgc3RhcnQgdGltZSBhbmQgc3RhcnRzIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gZGF0YVxyXG4gICAgICogQHBhcmFtIGJyb3dzZXJEZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbGVtZW50LCBkYXRhLCBicm93c2VyRGV0YWlscykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuYnJvd3NlckRldGFpbHMgPSBicm93c2VyRGV0YWlscztcclxuICAgICAgICAvKiogZnVuY3Rpb25zIHRvIGJlIGNhbGxlZCB1cG9uIGNvbXBsZXRpb24gKi9cclxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIC8qKiBmdW5jdGlvbnMgZm9yIHJlbW92aW5nIGV2ZW50IGxpc3RlbmVycyAqL1xyXG4gICAgICAgIHRoaXMuZXZlbnRDbGVhckZ1bmN0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8qKiBmbGFnIHVzZWQgdG8gdHJhY2sgd2hldGhlciBvciBub3QgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQgKi9cclxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0cmluZ1ByZWZpeCA9ICcnO1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbGFuZ18xLkRhdGVXcmFwcGVyLnRvTWlsbGlzKGxhbmdfMS5EYXRlV3JhcHBlci5ub3coKSk7XHJcbiAgICAgICAgdGhpcy5fc3RyaW5nUHJlZml4ID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0QW5pbWF0aW9uUHJlZml4KCk7XHJcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xyXG4gICAgICAgIHRoaXMud2FpdChmdW5jdGlvbiAodGltZXN0YW1wKSB7IHJldHVybiBfdGhpcy5zdGFydCgpOyB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb24ucHJvdG90eXBlLCBcInRvdGFsVGltZVwiLCB7XHJcbiAgICAgICAgLyoqIHRvdGFsIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIGFuaW1hdGlvbiBzaG91bGQgdGFrZSBpbmNsdWRpbmcgZGVsYXkgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5jb21wdXRlZERlbGF5ICE9IG51bGwgPyB0aGlzLmNvbXB1dGVkRGVsYXkgOiAwO1xyXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmNvbXB1dGVkRHVyYXRpb24gIT0gbnVsbCA/IHRoaXMuY29tcHV0ZWREdXJhdGlvbiA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxheSArIGR1cmF0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCByZXF1aXJlcyAyIGZyYW1lcyBmb3Igc29tZSByZWFzb25cclxuICAgICAgICB0aGlzLmJyb3dzZXJEZXRhaWxzLnJhZihjYWxsYmFjaywgMik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIHRoZSBpbml0aWFsIHN0eWxlcyBiZWZvcmUgdGhlIGFuaW1hdGlvbiBpcyBzdGFydGVkXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5mcm9tU3R5bGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXModGhpcy5kYXRhLmZyb21TdHlsZXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEuZHVyYXRpb24gIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyh7ICd0cmFuc2l0aW9uRHVyYXRpb24nOiB0aGlzLmRhdGEuZHVyYXRpb24udG9TdHJpbmcoKSArICdtcycgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kZWxheSAhPSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKHsgJ3RyYW5zaXRpb25EZWxheSc6IHRoaXMuZGF0YS5kZWxheS50b1N0cmluZygpICsgJ21zJyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIHNldHVwIGhhcyBvY2N1cnJlZCwgdGhpcyBtZXRob2QgYWRkcyB0aGUgYW5pbWF0aW9uIHN0eWxlc1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWRkQ2xhc3Nlcyh0aGlzLmRhdGEuY2xhc3Nlc1RvQWRkKTtcclxuICAgICAgICB0aGlzLmFkZENsYXNzZXModGhpcy5kYXRhLmFuaW1hdGlvbkNsYXNzZXMpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3Nlcyh0aGlzLmRhdGEuY2xhc3Nlc1RvUmVtb3ZlKTtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLnRvU3R5bGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXModGhpcy5kYXRhLnRvU3R5bGVzKTtcclxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZXMgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlZERlbGF5ID1cclxuICAgICAgICAgICAgbWF0aF8xLk1hdGgubWF4KHRoaXMucGFyc2VEdXJhdGlvblN0cmluZyhjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMuX3N0cmluZ1ByZWZpeCArICd0cmFuc2l0aW9uLWRlbGF5JykpLCB0aGlzLnBhcnNlRHVyYXRpb25TdHJpbmcodGhpcy5lbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUodGhpcy5fc3RyaW5nUHJlZml4ICsgJ3RyYW5zaXRpb24tZGVsYXknKSkpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWREdXJhdGlvbiA9IG1hdGhfMS5NYXRoLm1heCh0aGlzLnBhcnNlRHVyYXRpb25TdHJpbmcoY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLl9zdHJpbmdQcmVmaXggKyAndHJhbnNpdGlvbi1kdXJhdGlvbicpKSwgdGhpcy5wYXJzZUR1cmF0aW9uU3RyaW5nKHRoaXMuZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMuX3N0cmluZ1ByZWZpeCArICd0cmFuc2l0aW9uLWR1cmF0aW9uJykpKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50cygpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHN0eWxlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGRhc2hDYXNlS2V5ID0gdXRpbF8xLmNhbWVsQ2FzZVRvRGFzaENhc2Uoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZG9tX2FkYXB0ZXJfMS5ET00uZ2V0U3R5bGUoX3RoaXMuZWxlbWVudCwgZGFzaENhc2VLZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0U3R5bGUoX3RoaXMuZWxlbWVudCwgZGFzaENhc2VLZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0U3R5bGUoX3RoaXMuZWxlbWVudCwgX3RoaXMuX3N0cmluZ1ByZWZpeCArIGRhc2hDYXNlS2V5LCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgcHJvdmlkZWQgY2xhc3NlcyB0byB0aGUgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGNsYXNzZXNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBjbGFzc2VzW2ldKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGNsYXNzZXMgZnJvbSB0aGUgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGNsYXNzZXNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZW1vdmVDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBjbGFzc2VzW2ldKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgZXZlbnRzIHRvIHRyYWNrIHdoZW4gYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYWRkRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxUaW1lID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2xlYXJGdW5jdGlvbnMucHVzaChkb21fYWRhcHRlcl8xLkRPTS5vbkFuZENhbmNlbCh0aGlzLmVsZW1lbnQsIGRvbV9hZGFwdGVyXzEuRE9NLmdldFRyYW5zaXRpb25FbmQoKSwgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVBbmltYXRpb25FdmVudChldmVudCk7IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaGFuZGxlQW5pbWF0aW9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBtYXRoXzEuTWF0aC5yb3VuZChldmVudC5lbGFwc2VkVGltZSAqIDEwMDApO1xyXG4gICAgICAgIGlmICghdGhpcy5icm93c2VyRGV0YWlscy5lbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkpXHJcbiAgICAgICAgICAgIGVsYXBzZWRUaW1lICs9IHRoaXMuY29tcHV0ZWREZWxheTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGFsbCBhbmltYXRpb24gY2FsbGJhY2tzIGFuZCByZW1vdmVzIHRlbXBvcmFyeSBjbGFzc2VzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3Nlcyh0aGlzLmRhdGEuYW5pbWF0aW9uQ2xhc3Nlcyk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5ldmVudENsZWFyRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50Q2xlYXJGdW5jdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuaW1hdGlvbiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIHVwb24gY29tcGxldGlvblxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9ufVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBkdXJhdGlvbiBzdHJpbmcgdG8gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBkdXJhdGlvblxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5wYXJzZUR1cmF0aW9uU3RyaW5nID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcclxuICAgICAgICAvLyBkdXJhdGlvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIHRvIGJlIHZhbGlkLiAobnVtYmVyICsgdHlwZSlcclxuICAgICAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCB8fCBkdXJhdGlvbi5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZHVyYXRpb24uc3Vic3RyaW5nKGR1cmF0aW9uLmxlbmd0aCAtIDIpID09ICdtcycpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnQodGhpcy5zdHJpcExldHRlcnMoZHVyYXRpb24pLCAxMCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZHVyYXRpb24uc3Vic3RyaW5nKGR1cmF0aW9uLmxlbmd0aCAtIDEpID09ICdzJykge1xyXG4gICAgICAgICAgICB2YXIgbXMgPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUZsb2F0KHRoaXMuc3RyaXBMZXR0ZXJzKGR1cmF0aW9uKSkgKiAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRoXzEuTWF0aC5mbG9vcihtcyk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RyaXBzIHRoZSBsZXR0ZXJzIGZyb20gdGhlIGR1cmF0aW9uIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0clxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdHJpcExldHRlcnMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc3RyLCBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJ1teMC05XSskJywgJycpLCAnJyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvbjtcclxufSkoKTtcclxuZXhwb3J0cy5BbmltYXRpb24gPSBBbmltYXRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY3NzX2FuaW1hdGlvbl9idWlsZGVyXzEgPSByZXF1aXJlKCcuL2Nzc19hbmltYXRpb25fYnVpbGRlcicpO1xyXG52YXIgYnJvd3Nlcl9kZXRhaWxzXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXJfZGV0YWlscycpO1xyXG52YXIgQW5pbWF0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIERJXHJcbiAgICAgKiBAcGFyYW0gYnJvd3NlckRldGFpbHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uQnVpbGRlcihicm93c2VyRGV0YWlscykge1xyXG4gICAgICAgIHRoaXMuYnJvd3NlckRldGFpbHMgPSBicm93c2VyRGV0YWlscztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDU1MgQW5pbWF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7Q3NzQW5pbWF0aW9uQnVpbGRlcn1cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGNzc19hbmltYXRpb25fYnVpbGRlcl8xLkNzc0FuaW1hdGlvbkJ1aWxkZXIodGhpcy5icm93c2VyRGV0YWlscyk7IH07XHJcbiAgICBBbmltYXRpb25CdWlsZGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2Jyb3dzZXJfZGV0YWlsc18xLkJyb3dzZXJEZXRhaWxzXSlcclxuICAgIF0sIEFuaW1hdGlvbkJ1aWxkZXIpO1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvbkJ1aWxkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQW5pbWF0aW9uQnVpbGRlciA9IEFuaW1hdGlvbkJ1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbl9idWlsZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBtYXRoXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbWF0aCcpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgQnJvd3NlckRldGFpbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlckRldGFpbHMoKSB7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRvZXNFbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiBgZXZlbnQuZWxhcHNlZFRpbWVgIGluY2x1ZGVzIHRyYW5zaXRpb24gZGVsYXkgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci4gIEF0IHRoaXNcclxuICAgICAqIHRpbWUsIENocm9tZSBhbmQgT3BlcmEgc2VlbSB0byBiZSB0aGUgb25seSBicm93c2VycyB0aGF0IGluY2x1ZGUgdGhpcy5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckRldGFpbHMucHJvdG90eXBlLmRvZXNFbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZGl2ID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0QXR0cmlidXRlKGRpdiwgJ3N0eWxlJywgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTk5OTlweDsgbGVmdDogLTk5OTlweDsgd2lkdGg6IDFweDtcXG4gICAgICBoZWlnaHQ6IDFweDsgdHJhbnNpdGlvbjogYWxsIDFtcyBsaW5lYXIgMW1zO1wiKTtcclxuICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHRoYXQgd2Ugd2FpdCBmb3IgMiBmcmFtZXMgZm9yIHNvbWUgcmVhc29uXHJcbiAgICAgICAgdGhpcy5yYWYoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5vbihkaXYsICd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IG1hdGhfMS5NYXRoLnJvdW5kKGV2ZW50LmVsYXBzZWRUaW1lICogMTAwMCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkgPSBlbGFwc2VkID09IDI7XHJcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmUoZGl2KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldFN0eWxlKGRpdiwgJ3dpZHRoJywgJzJweCcpO1xyXG4gICAgICAgIH0sIDIpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEZXRhaWxzLnByb3RvdHlwZS5yYWYgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGZyYW1lcykge1xyXG4gICAgICAgIGlmIChmcmFtZXMgPT09IHZvaWQgMCkgeyBmcmFtZXMgPSAxOyB9XHJcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IFJhZlF1ZXVlKGNhbGxiYWNrLCBmcmFtZXMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBxdWV1ZS5jYW5jZWwoKTsgfTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRGV0YWlscyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgQnJvd3NlckRldGFpbHMpO1xyXG4gICAgcmV0dXJuIEJyb3dzZXJEZXRhaWxzO1xyXG59KSgpO1xyXG5leHBvcnRzLkJyb3dzZXJEZXRhaWxzID0gQnJvd3NlckRldGFpbHM7XHJcbnZhciBSYWZRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYWZRdWV1ZShjYWxsYmFjaywgZnJhbWVzKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzO1xyXG4gICAgICAgIHRoaXMuX3JhZigpO1xyXG4gICAgfVxyXG4gICAgUmFmUXVldWUucHJvdG90eXBlLl9yYWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUlkID0gZG9tX2FkYXB0ZXJfMS5ET00ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHsgcmV0dXJuIF90aGlzLl9uZXh0RnJhbWUodGltZXN0YW1wKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUmFmUXVldWUucHJvdG90eXBlLl9uZXh0RnJhbWUgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMtLTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZXMgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lc3RhbXApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSYWZRdWV1ZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuY3VycmVudEZyYW1lSWQpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lSWQgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSYWZRdWV1ZTtcclxufSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9kZXRhaWxzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgY3NzX2FuaW1hdGlvbl9vcHRpb25zXzEgPSByZXF1aXJlKCcuL2Nzc19hbmltYXRpb25fb3B0aW9ucycpO1xyXG52YXIgYW5pbWF0aW9uXzEgPSByZXF1aXJlKCcuL2FuaW1hdGlvbicpO1xyXG52YXIgQ3NzQW5pbWF0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VwdHMgcHVibGljIHByb3BlcnRpZXMgZm9yIENzc0FuaW1hdGlvbkJ1aWxkZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ3NzQW5pbWF0aW9uQnVpbGRlcihicm93c2VyRGV0YWlscykge1xyXG4gICAgICAgIHRoaXMuYnJvd3NlckRldGFpbHMgPSBicm93c2VyRGV0YWlscztcclxuICAgICAgICAvKiogQHR5cGUge0Nzc0FuaW1hdGlvbk9wdGlvbnN9ICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IGNzc19hbmltYXRpb25fb3B0aW9uc18xLkNzc0FuaW1hdGlvbk9wdGlvbnMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRlbXBvcmFyeSBjbGFzcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkQW5pbWF0aW9uQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLmFuaW1hdGlvbkNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNsYXNzIHRoYXQgd2lsbCByZW1haW4gb24gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWRcclxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLmNsYXNzZXNUb0FkZC5wdXNoKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxyXG4gICAgICovXHJcbiAgICBDc3NBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB0aGlzLmRhdGEuY2xhc3Nlc1RvUmVtb3ZlLnB1c2goY2xhc3NOYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiAoYW5kIG92ZXJyaWRlcyBhbnkgZGVmaW5lZCB0aHJvdWdoIENTUylcclxuICAgICAqIEBwYXJhbSBkdXJhdGlvblxyXG4gICAgICovXHJcbiAgICBDc3NBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5zZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGF0YS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYW5pbWF0aW9uIGRlbGF5IChhbmQgb3ZlcnJpZGVzIGFueSBkZWZpbmVkIHRocm91Z2ggQ1NTKVxyXG4gICAgICogQHBhcmFtIGRlbGF5XHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldERlbGF5ID0gZnVuY3Rpb24gKGRlbGF5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLmRlbGF5ID0gZGVsYXk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN0eWxlcyBmb3IgYm90aCB0aGUgaW5pdGlhbCBzdGF0ZSBhbmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gZnJvbVxyXG4gICAgICogQHBhcmFtIHRvXHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldEZyb21TdHlsZXMoZnJvbSkuc2V0VG9TdHlsZXModG8pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCBzdHlsZXMgZm9yIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBmcm9tXHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldEZyb21TdHlsZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xyXG4gICAgICAgIHRoaXMuZGF0YS5mcm9tU3R5bGVzID0gZnJvbTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlc3RpbmF0aW9uIHN0eWxlcyBmb3IgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIHRvXHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldFRvU3R5bGVzID0gZnVuY3Rpb24gKHRvKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLnRvU3R5bGVzID0gdG87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGFuaW1hdGlvbiBhbmQgcmV0dXJucyBhIHByb21pc2VcclxuICAgICAqIEBwYXJhbSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbGVtZW50LCB0aGlzLmRhdGEsIHRoaXMuYnJvd3NlckRldGFpbHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDc3NBbmltYXRpb25CdWlsZGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNzc0FuaW1hdGlvbkJ1aWxkZXIgPSBDc3NBbmltYXRpb25CdWlsZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3NfYW5pbWF0aW9uX2J1aWxkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBDc3NBbmltYXRpb25PcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENzc0FuaW1hdGlvbk9wdGlvbnMoKSB7XHJcbiAgICAgICAgLyoqIGNsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgKi9cclxuICAgICAgICB0aGlzLmNsYXNzZXNUb0FkZCA9IFtdO1xyXG4gICAgICAgIC8qKiBjbGFzc2VzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3Nlc1RvUmVtb3ZlID0gW107XHJcbiAgICAgICAgLyoqIGNsYXNzZXMgdG8gYmUgYWRkZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICovXHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25DbGFzc2VzID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ3NzQW5pbWF0aW9uT3B0aW9ucztcclxufSkoKTtcclxuZXhwb3J0cy5Dc3NBbmltYXRpb25PcHRpb25zID0gQ3NzQW5pbWF0aW9uT3B0aW9ucztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzX2FuaW1hdGlvbl9vcHRpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jb21waWxlcicpO1xyXG52YXIgYXBwbGljYXRpb25fY29tbW9uXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX2NvbW1vbicpO1xyXG52YXIgYXBwbGljYXRpb25fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX3Rva2VucycpO1xyXG5leHBvcnRzLkFQUF9DT01QT05FTlQgPSBhcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfQ09NUE9ORU5UO1xyXG5leHBvcnRzLkFQUF9JRCA9IGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JRDtcclxudmFyIGFwcGxpY2F0aW9uX2NvbW1vbl8yID0gcmVxdWlyZSgnLi9hcHBsaWNhdGlvbl9jb21tb24nKTtcclxuZXhwb3J0cy5wbGF0Zm9ybSA9IGFwcGxpY2F0aW9uX2NvbW1vbl8yLnBsYXRmb3JtO1xyXG52YXIgYXBwbGljYXRpb25fcmVmXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX3JlZicpO1xyXG5leHBvcnRzLlBsYXRmb3JtUmVmID0gYXBwbGljYXRpb25fcmVmXzEuUGxhdGZvcm1SZWY7XHJcbmV4cG9ydHMuQXBwbGljYXRpb25SZWYgPSBhcHBsaWNhdGlvbl9yZWZfMS5BcHBsaWNhdGlvblJlZjtcclxuZXhwb3J0cy5hcHBsaWNhdGlvbkNvbW1vbkJpbmRpbmdzID0gYXBwbGljYXRpb25fcmVmXzEuYXBwbGljYXRpb25Db21tb25CaW5kaW5ncztcclxuZXhwb3J0cy5jcmVhdGVOZ1pvbmUgPSBhcHBsaWNhdGlvbl9yZWZfMS5jcmVhdGVOZ1pvbmU7XHJcbmV4cG9ydHMucGxhdGZvcm1Db21tb24gPSBhcHBsaWNhdGlvbl9yZWZfMS5wbGF0Zm9ybUNvbW1vbjtcclxuZXhwb3J0cy5wbGF0Zm9ybUJpbmRpbmdzID0gYXBwbGljYXRpb25fcmVmXzEucGxhdGZvcm1CaW5kaW5ncztcclxuLy8vIFNlZSBbY29tbW9uQm9vdHN0cmFwXSBmb3IgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbi5cclxuZnVuY3Rpb24gYm9vdHN0cmFwKGFwcENvbXBvbmVudFR5cGUsIGFwcEJpbmRpbmdzKSB7XHJcbiAgICBpZiAoYXBwQmluZGluZ3MgPT09IHZvaWQgMCkgeyBhcHBCaW5kaW5ncyA9IG51bGw7IH1cclxuICAgIHZhciBiaW5kaW5ncyA9IFtjb21waWxlcl8xLmNvbXBpbGVyUHJvdmlkZXJzKCldO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXBwQmluZGluZ3MpKSB7XHJcbiAgICAgICAgYmluZGluZ3MucHVzaChhcHBCaW5kaW5ncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwbGljYXRpb25fY29tbW9uXzEuY29tbW9uQm9vdHN0cmFwKGFwcENvbXBvbmVudFR5cGUsIGJpbmRpbmdzKTtcclxufVxyXG5leHBvcnRzLmJvb3RzdHJhcCA9IGJvb3RzdHJhcDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBmb3Jtc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGJyb3dzZXJfYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2Jyb3dzZXJfYWRhcHRlcicpO1xyXG52YXIgYnJvd3Nlcl90ZXN0YWJpbGl0eV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvdGVzdGFiaWxpdHkvYnJvd3Nlcl90ZXN0YWJpbGl0eScpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgeGhyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHInKTtcclxudmFyIHhocl9pbXBsXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHJfaW1wbCcpO1xyXG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMvZXZlbnRfbWFuYWdlcicpO1xyXG52YXIga2V5X2V2ZW50c18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMva2V5X2V2ZW50cycpO1xyXG52YXIgaGFtbWVyX2dlc3R1cmVzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL2V2ZW50cy9oYW1tZXJfZ2VzdHVyZXMnKTtcclxudmFyIHRlc3RhYmlsaXR5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eScpO1xyXG52YXIgYXBpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvYXBpJyk7XHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9yZW5kZXInKTtcclxudmFyIHNoYXJlZF9zdHlsZXNfaG9zdF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9zaGFyZWRfc3R5bGVzX2hvc3QnKTtcclxudmFyIHBsYXRmb3JtX2JpbmRpbmdzXzEgPSByZXF1aXJlKCcuL3BsYXRmb3JtX2JpbmRpbmdzJyk7XHJcbnZhciBhbmltYXRpb25fYnVpbGRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2FuaW1hdGUvYW5pbWF0aW9uX2J1aWxkZXInKTtcclxudmFyIGJyb3dzZXJfZGV0YWlsc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2FuaW1hdGUvYnJvd3Nlcl9kZXRhaWxzJyk7XHJcbnZhciB3dGZfaW5pdF8xID0gcmVxdWlyZSgnLi9wcm9maWxlL3d0Zl9pbml0Jyk7XHJcbnZhciBhcHBsaWNhdGlvbl9yZWZfMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fcmVmJyk7XHJcbi8qKlxyXG4gKiBBIGRlZmF1bHQgc2V0IG9mIHByb3ZpZGVycyB3aGljaCBhcHBseSBvbmx5IHRvIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24gcnVubmluZyBvblxyXG4gKiB0aGUgVUkgdGhyZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbGljYXRpb25Eb21CaW5kaW5ncygpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhkb21fYWRhcHRlcl8xLkRPTSkpIHtcclxuICAgICAgICB0aHJvdyBcIk11c3Qgc2V0IGEgcm9vdCBET00gYWRhcHRlciBmaXJzdC5cIjtcclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKHJlbmRlcl8xLkRPQ1VNRU5ULCB7IHVzZVZhbHVlOiBkb21fYWRhcHRlcl8xLkRPTS5kZWZhdWx0RG9jKCkgfSksXHJcbiAgICAgICAgZXZlbnRfbWFuYWdlcl8xLkV2ZW50TWFuYWdlcixcclxuICAgICAgICBuZXcgZGlfMS5Qcm92aWRlcihldmVudF9tYW5hZ2VyXzEuRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCB7IHVzZUNsYXNzOiBldmVudF9tYW5hZ2VyXzEuRG9tRXZlbnRzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9KSxcclxuICAgICAgICBuZXcgZGlfMS5Qcm92aWRlcihldmVudF9tYW5hZ2VyXzEuRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCB7IHVzZUNsYXNzOiBrZXlfZXZlbnRzXzEuS2V5RXZlbnRzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9KSxcclxuICAgICAgICBuZXcgZGlfMS5Qcm92aWRlcihldmVudF9tYW5hZ2VyXzEuRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCB7IHVzZUNsYXNzOiBoYW1tZXJfZ2VzdHVyZXNfMS5IYW1tZXJHZXN0dXJlc1BsdWdpbiwgbXVsdGk6IHRydWUgfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKHJlbmRlcl8xLkRvbVJlbmRlcmVyLCB7IHVzZUNsYXNzOiByZW5kZXJfMS5Eb21SZW5kZXJlcl8gfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGFwaV8xLlJlbmRlcmVyLCB7IHVzZUV4aXN0aW5nOiByZW5kZXJfMS5Eb21SZW5kZXJlciB9KSxcclxuICAgICAgICBzaGFyZWRfc3R5bGVzX2hvc3RfMS5Eb21TaGFyZWRTdHlsZXNIb3N0LFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShzaGFyZWRfc3R5bGVzX2hvc3RfMS5TaGFyZWRTdHlsZXNIb3N0LCB7IHVzZUV4aXN0aW5nOiBzaGFyZWRfc3R5bGVzX2hvc3RfMS5Eb21TaGFyZWRTdHlsZXNIb3N0IH0pLFxyXG4gICAgICAgIHBsYXRmb3JtX2JpbmRpbmdzXzEuRVhDRVBUSU9OX1BST1ZJREVSLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZSh4aHJfMS5YSFIsIHsgdXNlVmFsdWU6IG5ldyB4aHJfaW1wbF8xLlhIUkltcGwoKSB9KSxcclxuICAgICAgICB0ZXN0YWJpbGl0eV8xLlRlc3RhYmlsaXR5LFxyXG4gICAgICAgIGJyb3dzZXJfZGV0YWlsc18xLkJyb3dzZXJEZXRhaWxzLFxyXG4gICAgICAgIGFuaW1hdGlvbl9idWlsZGVyXzEuQW5pbWF0aW9uQnVpbGRlcixcclxuICAgICAgICBmb3Jtc18xLkZPUk1fUFJPVklERVJTXHJcbiAgICBdO1xyXG59XHJcbmV4cG9ydHMuYXBwbGljYXRpb25Eb21CaW5kaW5ncyA9IGFwcGxpY2F0aW9uRG9tQmluZGluZ3M7XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIHRoZSBBbmd1bGFyICdwbGF0Zm9ybScgb24gdGhlIHBhZ2UuXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgUGxhdGZvcm1SZWZ9IGZvciBkZXRhaWxzIG9uIHRoZSBBbmd1bGFyIHBsYXRmb3JtLlxyXG4gKlxyXG4gKiAjIFdpdGhvdXQgc3BlY2lmaWVkIHByb3ZpZGVyc1xyXG4gKlxyXG4gKiBJZiBubyBwcm92aWRlcnMgYXJlIHNwZWNpZmllZCwgYHBsYXRmb3JtYCdzIGJlaGF2aW9yIGRlcGVuZHMgb24gd2hldGhlciBhbiBleGlzdGluZ1xyXG4gKiBwbGF0Zm9ybSBleGlzdHM6XHJcbiAqXHJcbiAqIElmIG5vIHBsYXRmb3JtIGV4aXN0cywgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBkZWZhdWx0IHtAbGluayBwbGF0Zm9ybUJpbmRpbmdzfS5cclxuICpcclxuICogSWYgYSBwbGF0Zm9ybSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSByZXR1cm5lZCAocmVnYXJkbGVzcyBvZiB3aGF0IHByb3ZpZGVycyBpdFxyXG4gKiB3YXMgY3JlYXRlZCB3aXRoKS4gVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZlYXR1cmUsIGFsbG93aW5nIGZvciBtdWx0aXBsZSBhcHBsaWNhdGlvbnNcclxuICogdG8gYmUgbG9hZGVkIGludG8gdGhlIHNhbWUgcGxhdGZvcm0gd2l0aG91dCBhd2FyZW5lc3Mgb2YgZWFjaCBvdGhlci5cclxuICpcclxuICogIyBXaXRoIHNwZWNpZmllZCBwcm92aWRlcnNcclxuICpcclxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBzcGVjaWZ5IHByb3ZpZGVycyB0byBiZSBtYWRlIGluIHRoZSBuZXcgcGxhdGZvcm0uIFRoZXNlIHByb3ZpZGVyc1xyXG4gKiB3aWxsIGJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBhcHBsaWNhdGlvbnMgb24gdGhlIHBhZ2UuIEZvciBleGFtcGxlLCBhbiBhYnN0cmFjdGlvbiBmb3JcclxuICogdGhlIGJyb3dzZXIgY29va2llIGphciBzaG91bGQgYmUgYm91bmQgYXQgdGhlIHBsYXRmb3JtIGxldmVsLCBiZWNhdXNlIHRoZXJlIGlzIG9ubHkgb25lXHJcbiAqIGNvb2tpZSBqYXIgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBhcHBsaWNhdGlvbnMgb24gdGhlIGFnZSB3aWxsIGJlIGFjY2Vzc2luZyBpdC5cclxuICpcclxuICogSWYgcHJvdmlkZXJzIGFyZSBzcGVjaWZpZWQgZGlyZWN0bHksIGBwbGF0Zm9ybWAgd2lsbCBjcmVhdGUgdGhlIEFuZ3VsYXIgcGxhdGZvcm0gd2l0aFxyXG4gKiB0aGVtIGlmIGEgcGxhdGZvcm0gZGlkIG5vdCBleGlzdCBhbHJlYWR5LiBJZiBpdCBkaWQgZXhpc3QsIGhvd2V2ZXIsIGFuIGVycm9yIHdpbGwgYmVcclxuICogdGhyb3duLlxyXG4gKlxyXG4gKiAjIERPTSBBcHBsaWNhdGlvbnNcclxuICpcclxuICogVGhpcyB2ZXJzaW9uIG9mIGBwbGF0Zm9ybWAgaW5pdGlhbGl6ZXMgQW5ndWxhciB0byBydW4gaW4gdGhlIFVJIHRocmVhZCwgd2l0aCBkaXJlY3RcclxuICogRE9NIGFjY2Vzcy4gV2ViLXdvcmtlciBhcHBsaWNhdGlvbnMgc2hvdWxkIGNhbGwgYHBsYXRmb3JtYCBmcm9tXHJcbiAqIGBzcmMvd2ViX3dvcmtlcnMvd29ya2VyL2FwcGxpY2F0aW9uX2NvbW1vbmAgaW5zdGVhZC5cclxuICovXHJcbmZ1bmN0aW9uIHBsYXRmb3JtKGJpbmRpbmdzKSB7XHJcbiAgICByZXR1cm4gYXBwbGljYXRpb25fcmVmXzEucGxhdGZvcm1Db21tb24oYmluZGluZ3MsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBicm93c2VyX2FkYXB0ZXJfMS5Ccm93c2VyRG9tQWRhcHRlci5tYWtlQ3VycmVudCgpO1xyXG4gICAgICAgIHd0Zl9pbml0XzEud3RmSW5pdCgpO1xyXG4gICAgICAgIGJyb3dzZXJfdGVzdGFiaWxpdHlfMS5Ccm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCgpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG4vKipcclxuICogQm9vdHN0cmFwcGluZyBmb3IgQW5ndWxhciBhcHBsaWNhdGlvbnMuXHJcbiAqXHJcbiAqIFlvdSBpbnN0YW50aWF0ZSBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIGJ5IGV4cGxpY2l0bHkgc3BlY2lmeWluZyBhIGNvbXBvbmVudCB0byB1c2VcclxuICogYXMgdGhlIHJvb3QgY29tcG9uZW50IGZvciB5b3VyIGFwcGxpY2F0aW9uIHZpYSB0aGUgYGJvb3RzdHJhcCgpYCBtZXRob2QuXHJcbiAqXHJcbiAqICMjIFNpbXBsZSBFeGFtcGxlXHJcbiAqXHJcbiAqIEFzc3VtaW5nIHRoaXMgYGluZGV4Lmh0bWxgOlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDxodG1sPlxyXG4gKiAgIDwhLS0gbG9hZCBBbmd1bGFyIHNjcmlwdCB0YWdzIGhlcmUuIC0tPlxyXG4gKiAgIDxib2R5PlxyXG4gKiAgICAgPG15LWFwcD5sb2FkaW5nLi4uPC9teS1hcHA+XHJcbiAqICAgPC9ib2R5PlxyXG4gKiA8L2h0bWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbiBhcHBsaWNhdGlvbiBpcyBib290c3RyYXBwZWQgaW5zaWRlIGFuIGV4aXN0aW5nIGJyb3dzZXIgRE9NLCB0eXBpY2FsbHkgYGluZGV4Lmh0bWxgLlxyXG4gKiBVbmxpa2UgQW5ndWxhciAxLCBBbmd1bGFyIDIgZG9lcyBub3QgY29tcGlsZS9wcm9jZXNzIHByb3ZpZGVycyBpbiBgaW5kZXguaHRtbGAuIFRoaXMgaXNcclxuICogbWFpbmx5IGZvciBzZWN1cml0eSByZWFzb25zLCBhcyB3ZWxsIGFzIGFyY2hpdGVjdHVyYWwgY2hhbmdlcyBpbiBBbmd1bGFyIDIuIFRoaXMgbWVhbnNcclxuICogdGhhdCBgaW5kZXguaHRtbGAgY2FuIHNhZmVseSBiZSBwcm9jZXNzZWQgdXNpbmcgc2VydmVyLXNpZGUgdGVjaG5vbG9naWVzIHN1Y2ggYXNcclxuICogcHJvdmlkZXJzLiBCaW5kaW5ncyBjYW4gdGh1cyB1c2UgZG91YmxlLWN1cmx5IGB7eyBzeW50YXggfX1gIHdpdGhvdXQgY29sbGlzaW9uIGZyb21cclxuICogQW5ndWxhciAyIGNvbXBvbmVudCBkb3VibGUtY3VybHkgYHt7IHN5bnRheCB9fWAuXHJcbiAqXHJcbiAqIFdlIGNhbiB1c2UgdGhpcyBzY3JpcHQgY29kZTpcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAqICAgIHRlbXBsYXRlOiAnSGVsbG8ge3sgbmFtZSB9fSEnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIE15QXBwIHtcclxuICogICBuYW1lOnN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIG1haW4oKSB7XHJcbiAqICAgcmV0dXJuIGJvb3RzdHJhcChNeUFwcCk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGFwcCBkZXZlbG9wZXIgaW52b2tlcyBgYm9vdHN0cmFwKClgIHdpdGggdGhlIHJvb3QgY29tcG9uZW50IGBNeUFwcGAgYXMgaXRzXHJcbiAqIGFyZ3VtZW50LCBBbmd1bGFyIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgdGFza3M6XHJcbiAqXHJcbiAqICAxLiBJdCB1c2VzIHRoZSBjb21wb25lbnQncyBgc2VsZWN0b3JgIHByb3BlcnR5IHRvIGxvY2F0ZSB0aGUgRE9NIGVsZW1lbnQgd2hpY2ggbmVlZHNcclxuICogICAgIHRvIGJlIHVwZ3JhZGVkIGludG8gdGhlIGFuZ3VsYXIgY29tcG9uZW50LlxyXG4gKiAgMi4gSXQgY3JlYXRlcyBhIG5ldyBjaGlsZCBpbmplY3RvciAoZnJvbSB0aGUgcGxhdGZvcm0gaW5qZWN0b3IpLiBPcHRpb25hbGx5LCB5b3UgY2FuXHJcbiAqICAgICBhbHNvIG92ZXJyaWRlIHRoZSBpbmplY3RvciBjb25maWd1cmF0aW9uIGZvciBhbiBhcHAgYnkgaW52b2tpbmcgYGJvb3RzdHJhcGAgd2l0aCB0aGVcclxuICogICAgIGBjb21wb25lbnRJbmplY3RhYmxlQmluZGluZ3NgIGFyZ3VtZW50LlxyXG4gKiAgMy4gSXQgY3JlYXRlcyBhIG5ldyBgWm9uZWAgYW5kIGNvbm5lY3RzIGl0IHRvIHRoZSBhbmd1bGFyIGFwcGxpY2F0aW9uJ3MgY2hhbmdlIGRldGVjdGlvblxyXG4gKiAgICAgZG9tYWluIGluc3RhbmNlLlxyXG4gKiAgNC4gSXQgY3JlYXRlcyBhIHNoYWRvdyBET00gb24gdGhlIHNlbGVjdGVkIGNvbXBvbmVudCdzIGhvc3QgZWxlbWVudCBhbmQgbG9hZHMgdGhlXHJcbiAqICAgICB0ZW1wbGF0ZSBpbnRvIGl0LlxyXG4gKiAgNS4gSXQgaW5zdGFudGlhdGVzIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50LlxyXG4gKiAgNi4gRmluYWxseSwgQW5ndWxhciBwZXJmb3JtcyBjaGFuZ2UgZGV0ZWN0aW9uIHRvIGFwcGx5IHRoZSBpbml0aWFsIGRhdGEgcHJvdmlkZXJzIGZvciB0aGVcclxuICogICAgIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyBJbnN0YW50aWF0aW5nIE11bHRpcGxlIEFwcGxpY2F0aW9ucyBvbiBhIFNpbmdsZSBQYWdlXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byBkbyB0aGlzLlxyXG4gKlxyXG4gKiAjIyMgSXNvbGF0ZWQgQXBwbGljYXRpb25zXHJcbiAqXHJcbiAqIEFuZ3VsYXIgY3JlYXRlcyBhIG5ldyBhcHBsaWNhdGlvbiBlYWNoIHRpbWUgdGhhdCB0aGUgYGJvb3RzdHJhcCgpYCBtZXRob2QgaXMgaW52b2tlZC5cclxuICogV2hlbiBtdWx0aXBsZSBhcHBsaWNhdGlvbnMgYXJlIGNyZWF0ZWQgZm9yIGEgcGFnZSwgQW5ndWxhciB0cmVhdHMgZWFjaCBhcHBsaWNhdGlvbiBhc1xyXG4gKiBpbmRlcGVuZGVudCB3aXRoaW4gYW4gaXNvbGF0ZWQgY2hhbmdlIGRldGVjdGlvbiBhbmQgYFpvbmVgIGRvbWFpbi4gSWYgeW91IG5lZWQgdG8gc2hhcmVcclxuICogZGF0YSBiZXR3ZWVuIGFwcGxpY2F0aW9ucywgdXNlIHRoZSBzdHJhdGVneSBkZXNjcmliZWQgaW4gdGhlIG5leHQgc2VjdGlvbiwgXCJBcHBsaWNhdGlvbnNcclxuICogVGhhdCBTaGFyZSBDaGFuZ2UgRGV0ZWN0aW9uLlwiXHJcbiAqXHJcbiAqXHJcbiAqICMjIyBBcHBsaWNhdGlvbnMgVGhhdCBTaGFyZSBDaGFuZ2UgRGV0ZWN0aW9uXHJcbiAqXHJcbiAqIElmIHlvdSBuZWVkIHRvIGJvb3RzdHJhcCBtdWx0aXBsZSBhcHBsaWNhdGlvbnMgdGhhdCBzaGFyZSBjb21tb24gZGF0YSwgdGhlIGFwcGxpY2F0aW9uc1xyXG4gKiBtdXN0IHNoYXJlIGEgY29tbW9uIGNoYW5nZSBkZXRlY3Rpb24gYW5kIHpvbmUuIFRvIGRvIHRoYXQsIGNyZWF0ZSBhIG1ldGEtY29tcG9uZW50IHRoYXRcclxuICogbGlzdHMgdGhlIGFwcGxpY2F0aW9uIGNvbXBvbmVudHMgaW4gaXRzIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiBCeSBvbmx5IGludm9raW5nIHRoZSBgYm9vdHN0cmFwKClgIG1ldGhvZCBvbmNlLCB3aXRoIHRoZSBtZXRhLWNvbXBvbmVudCBhcyBpdHMgYXJndW1lbnQsXHJcbiAqIHlvdSBlbnN1cmUgdGhhdCBvbmx5IGEgc2luZ2xlIGNoYW5nZSBkZXRlY3Rpb24gem9uZSBpcyBjcmVhdGVkIGFuZCB0aGVyZWZvcmUgZGF0YSBjYW4gYmVcclxuICogc2hhcmVkIGFjcm9zcyB0aGUgYXBwbGljYXRpb25zLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyBQbGF0Zm9ybSBJbmplY3RvclxyXG4gKlxyXG4gKiBXaGVuIHdvcmtpbmcgd2l0aGluIGEgYnJvd3NlciB3aW5kb3csIHRoZXJlIGFyZSBtYW55IHNpbmdsZXRvbiByZXNvdXJjZXM6IGNvb2tpZXMsIHRpdGxlLFxyXG4gKiBsb2NhdGlvbiwgYW5kIG90aGVycy4gQW5ndWxhciBzZXJ2aWNlcyB0aGF0IHJlcHJlc2VudCB0aGVzZSByZXNvdXJjZXMgbXVzdCBsaWtld2lzZSBiZVxyXG4gKiBzaGFyZWQgYWNyb3NzIGFsbCBBbmd1bGFyIGFwcGxpY2F0aW9ucyB0aGF0IG9jY3VweSB0aGUgc2FtZSBicm93c2VyIHdpbmRvdy4gRm9yIHRoaXNcclxuICogcmVhc29uLCBBbmd1bGFyIGNyZWF0ZXMgZXhhY3RseSBvbmUgZ2xvYmFsIHBsYXRmb3JtIGluamVjdG9yIHdoaWNoIHN0b3JlcyBhbGwgc2hhcmVkXHJcbiAqIHNlcnZpY2VzLCBhbmQgZWFjaCBhbmd1bGFyIGFwcGxpY2F0aW9uIGluamVjdG9yIGhhcyB0aGUgcGxhdGZvcm0gaW5qZWN0b3IgYXMgaXRzIHBhcmVudC5cclxuICpcclxuICogRWFjaCBhcHBsaWNhdGlvbiBoYXMgaXRzIG93biBwcml2YXRlIGluamVjdG9yIGFzIHdlbGwuIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlXHJcbiAqIGFwcGxpY2F0aW9ucyBvbiBhIHBhZ2UsIEFuZ3VsYXIgdHJlYXRzIGVhY2ggYXBwbGljYXRpb24gaW5qZWN0b3IncyBzZXJ2aWNlcyBhcyBwcml2YXRlXHJcbiAqIHRvIHRoYXQgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqXHJcbiAqICMgQVBJXHJcbiAqIC0gYGFwcENvbXBvbmVudFR5cGVgOiBUaGUgcm9vdCBjb21wb25lbnQgd2hpY2ggc2hvdWxkIGFjdCBhcyB0aGUgYXBwbGljYXRpb24uIFRoaXMgaXNcclxuICogICBhIHJlZmVyZW5jZSB0byBhIGBUeXBlYCB3aGljaCBpcyBhbm5vdGF0ZWQgd2l0aCBgQENvbXBvbmVudCguLi4pYC5cclxuICogLSBgY29tcG9uZW50SW5qZWN0YWJsZUJpbmRpbmdzYDogQW4gYWRkaXRpb25hbCBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZVxyXG4gKiAgIGFwcCBpbmplY3RvciB0byBvdmVycmlkZSBkZWZhdWx0IGluamVjdGlvbiBiZWhhdmlvci5cclxuICogLSBgZXJyb3JSZXBvcnRlcmA6IGBmdW5jdGlvbihleGNlcHRpb246YW55LCBzdGFja1RyYWNlOnN0cmluZylgIGEgZGVmYXVsdCBlcnJvciByZXBvcnRlclxyXG4gKiAgIGZvciB1bmhhbmRsZWQgZXhjZXB0aW9ucy5cclxuICpcclxuICogUmV0dXJucyBhIGBQcm9taXNlYCBvZiB7QGxpbmsgQ29tcG9uZW50UmVmfS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbW1vbkJvb3RzdHJhcChhcHBDb21wb25lbnRUeXBlLCBhcHBCaW5kaW5ncykge1xyXG4gICAgaWYgKGFwcEJpbmRpbmdzID09PSB2b2lkIDApIHsgYXBwQmluZGluZ3MgPSBudWxsOyB9XHJcbiAgICB2YXIgcCA9IHBsYXRmb3JtKCk7XHJcbiAgICB2YXIgYmluZGluZ3MgPSBbYXBwbGljYXRpb25fcmVmXzEuYXBwbGljYXRpb25Db21tb25CaW5kaW5ncygpLCBhcHBsaWNhdGlvbkRvbUJpbmRpbmdzKCldO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXBwQmluZGluZ3MpKSB7XHJcbiAgICAgICAgYmluZGluZ3MucHVzaChhcHBCaW5kaW5ncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcC5hcHBsaWNhdGlvbihiaW5kaW5ncykuYm9vdHN0cmFwKGFwcENvbXBvbmVudFR5cGUpO1xyXG59XHJcbmV4cG9ydHMuY29tbW9uQm9vdHN0cmFwID0gY29tbW9uQm9vdHN0cmFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhdGlvbl9jb21tb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBuZ196b25lXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS96b25lL25nX3pvbmUnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGFwcGxpY2F0aW9uX3Rva2Vuc18xID0gcmVxdWlyZSgnLi9hcHBsaWNhdGlvbl90b2tlbnMnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxudmFyIHRlc3RhYmlsaXR5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eScpO1xyXG52YXIgZHluYW1pY19jb21wb25lbnRfbG9hZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZHluYW1pY19jb21wb25lbnRfbG9hZGVyJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgdmlld19yZWZfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X3JlZicpO1xyXG52YXIgbGlmZV9jeWNsZV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlmZV9jeWNsZS9saWZlX2N5Y2xlJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIHZpZXdfcG9vbF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcG9vbCcpO1xyXG52YXIgdmlld19tYW5hZ2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19tYW5hZ2VyJyk7XHJcbnZhciB2aWV3X21hbmFnZXJfdXRpbHNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X21hbmFnZXJfdXRpbHMnKTtcclxudmFyIHZpZXdfbGlzdGVuZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X2xpc3RlbmVyJyk7XHJcbnZhciBwcm90b192aWV3X2ZhY3RvcnlfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3Byb3RvX3ZpZXdfZmFjdG9yeScpO1xyXG52YXIgcGlwZXNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzJyk7XHJcbnZhciB2aWV3X3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL2xpbmtlci92aWV3X3Jlc29sdmVyJyk7XHJcbnZhciBkaXJlY3RpdmVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2RpcmVjdGl2ZV9yZXNvbHZlcicpO1xyXG52YXIgcGlwZV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvcGlwZV9yZXNvbHZlcicpO1xyXG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9jb21waWxlcicpO1xyXG52YXIgZHluYW1pY19jb21wb25lbnRfbG9hZGVyXzIgPSByZXF1aXJlKFwiLi9saW5rZXIvZHluYW1pY19jb21wb25lbnRfbG9hZGVyXCIpO1xyXG52YXIgdmlld19tYW5hZ2VyXzIgPSByZXF1aXJlKFwiLi9saW5rZXIvdmlld19tYW5hZ2VyXCIpO1xyXG52YXIgY29tcGlsZXJfMiA9IHJlcXVpcmUoXCIuL2xpbmtlci9jb21waWxlclwiKTtcclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgdGhlIHNldCBvZiBwcm92aWRlcnMgbWVhbnQgZm9yIHVzZSBhdCB0aGUgcGxhdGZvcm0gbGV2ZWwuXHJcbiAqXHJcbiAqIFRoZXNlIGFyZSBwcm92aWRlcnMgdGhhdCBzaG91bGQgYmUgc2luZ2xldG9ucyBzaGFyZWQgYW1vbmcgYWxsIEFuZ3VsYXIgYXBwbGljYXRpb25zXHJcbiAqIHJ1bm5pbmcgb24gdGhlIHBhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBwbGF0Zm9ybUJpbmRpbmdzKCkge1xyXG4gICAgcmV0dXJuIFtkaV8xLnByb3ZpZGUocmVmbGVjdGlvbl8xLlJlZmxlY3RvciwgeyB1c2VWYWx1ZTogcmVmbGVjdGlvbl8xLnJlZmxlY3RvciB9KSwgdGVzdGFiaWxpdHlfMS5UZXN0YWJpbGl0eVJlZ2lzdHJ5XTtcclxufVxyXG5leHBvcnRzLnBsYXRmb3JtQmluZGluZ3MgPSBwbGF0Zm9ybUJpbmRpbmdzO1xyXG4vKipcclxuICogQ29uc3RydWN0IHByb3ZpZGVycyBzcGVjaWZpYyB0byBhbiBpbmRpdmlkdWFsIHJvb3QgY29tcG9uZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gX2NvbXBvbmVudFByb3ZpZGVycyhhcHBDb21wb25lbnRUeXBlKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGRpXzEucHJvdmlkZShhcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfQ09NUE9ORU5ULCB7IHVzZVZhbHVlOiBhcHBDb21wb25lbnRUeXBlIH0pLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShhcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfQ09NUE9ORU5UX1JFRl9QUk9NSVNFLCB7XHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChkeW5hbWljQ29tcG9uZW50TG9hZGVyLCBpbmplY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhyYWRvKTogaW52ZXN0aWdhdGUgd2hldGhlciB0byBzdXBwb3J0IGJpbmRpbmdzIG9uIHJvb3QgY29tcG9uZW50LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNDb21wb25lbnRMb2FkZXIubG9hZEFzUm9vdChhcHBDb21wb25lbnRUeXBlLCBudWxsLCBpbmplY3RvcilcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdG9yLmdldCh0ZXN0YWJpbGl0eV8xLlRlc3RhYmlsaXR5UmVnaXN0cnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVnaXN0ZXJBcHBsaWNhdGlvbihjb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCwgaW5qZWN0b3IuZ2V0KHRlc3RhYmlsaXR5XzEuVGVzdGFiaWxpdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZXBzOiBbZHluYW1pY19jb21wb25lbnRfbG9hZGVyXzEuRHluYW1pY0NvbXBvbmVudExvYWRlciwgZGlfMS5JbmplY3Rvcl1cclxuICAgICAgICB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUoYXBwQ29tcG9uZW50VHlwZSwge1xyXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50aGVuKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi5pbnN0YW5jZTsgfSk7IH0sXHJcbiAgICAgICAgICAgIGRlcHM6IFthcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfQ09NUE9ORU5UX1JFRl9QUk9NSVNFXVxyXG4gICAgICAgIH0pLFxyXG4gICAgXTtcclxufVxyXG4vKipcclxuICogQ29uc3RydWN0IGEgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzIHdoaWNoIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBhbnkgQW5ndWxhclxyXG4gKiBhcHBsaWNhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IHJ1bnMgb24gdGhlIFVJIHRocmVhZCBvciBpbiBhIHdlYiB3b3JrZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBsaWNhdGlvbkNvbW1vbkJpbmRpbmdzKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBkaV8xLnByb3ZpZGUoY29tcGlsZXJfMS5Db21waWxlciwgeyB1c2VDbGFzczogY29tcGlsZXJfMi5Db21waWxlcl8gfSksXHJcbiAgICAgICAgYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lEX1JBTkRPTV9QUk9WSURFUixcclxuICAgICAgICB2aWV3X3Bvb2xfMS5BcHBWaWV3UG9vbCxcclxuICAgICAgICBkaV8xLnByb3ZpZGUodmlld19wb29sXzEuQVBQX1ZJRVdfUE9PTF9DQVBBQ0lUWSwgeyB1c2VWYWx1ZTogMTAwMDAgfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKHZpZXdfbWFuYWdlcl8xLkFwcFZpZXdNYW5hZ2VyLCB7IHVzZUNsYXNzOiB2aWV3X21hbmFnZXJfMi5BcHBWaWV3TWFuYWdlcl8gfSksXHJcbiAgICAgICAgdmlld19tYW5hZ2VyX3V0aWxzXzEuQXBwVmlld01hbmFnZXJVdGlscyxcclxuICAgICAgICB2aWV3X2xpc3RlbmVyXzEuQXBwVmlld0xpc3RlbmVyLFxyXG4gICAgICAgIHByb3RvX3ZpZXdfZmFjdG9yeV8xLlByb3RvVmlld0ZhY3RvcnksXHJcbiAgICAgICAgdmlld19yZXNvbHZlcl8xLlZpZXdSZXNvbHZlcixcclxuICAgICAgICBwaXBlc18xLkRFRkFVTFRfUElQRVMsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGNoYW5nZV9kZXRlY3Rpb25fMS5JdGVyYWJsZURpZmZlcnMsIHsgdXNlVmFsdWU6IGNoYW5nZV9kZXRlY3Rpb25fMS5kZWZhdWx0SXRlcmFibGVEaWZmZXJzIH0pLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzLCB7IHVzZVZhbHVlOiBjaGFuZ2VfZGV0ZWN0aW9uXzEuZGVmYXVsdEtleVZhbHVlRGlmZmVycyB9KSxcclxuICAgICAgICBkaXJlY3RpdmVfcmVzb2x2ZXJfMS5EaXJlY3RpdmVSZXNvbHZlcixcclxuICAgICAgICBwaXBlX3Jlc29sdmVyXzEuUGlwZVJlc29sdmVyLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMS5EeW5hbWljQ29tcG9uZW50TG9hZGVyLCB7IHVzZUNsYXNzOiBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMi5EeW5hbWljQ29tcG9uZW50TG9hZGVyXyB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUobGlmZV9jeWNsZV8xLkxpZmVDeWNsZSwge1xyXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoZXhjZXB0aW9uSGFuZGxlcikgeyByZXR1cm4gbmV3IGxpZmVfY3ljbGVfMS5MaWZlQ3ljbGVfKG51bGwsIGxhbmdfMS5hc3NlcnRpb25zRW5hYmxlZCgpKTsgfSxcclxuICAgICAgICAgICAgZGVwczogW2V4Y2VwdGlvbnNfMS5FeGNlcHRpb25IYW5kbGVyXVxyXG4gICAgICAgIH0pXHJcbiAgICBdO1xyXG59XHJcbmV4cG9ydHMuYXBwbGljYXRpb25Db21tb25CaW5kaW5ncyA9IGFwcGxpY2F0aW9uQ29tbW9uQmluZGluZ3M7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gQW5ndWxhciB6b25lLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTmdab25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBuZ196b25lXzEuTmdab25lKHsgZW5hYmxlTG9uZ1N0YWNrVHJhY2U6IGxhbmdfMS5hc3NlcnRpb25zRW5hYmxlZCgpIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlTmdab25lID0gY3JlYXRlTmdab25lO1xyXG52YXIgX3BsYXRmb3JtO1xyXG5mdW5jdGlvbiBwbGF0Zm9ybUNvbW1vbihiaW5kaW5ncywgaW5pdGlhbGl6ZXIpIHtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF9wbGF0Zm9ybSkpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoYmluZGluZ3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcGxhdGZvcm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IFwicGxhdGZvcm0oKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBwZXIgcGFnZVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5pdGlhbGl6ZXIpKSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZXIoKTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhiaW5kaW5ncykpIHtcclxuICAgICAgICBiaW5kaW5ncyA9IHBsYXRmb3JtQmluZGluZ3MoKTtcclxuICAgIH1cclxuICAgIF9wbGF0Zm9ybSA9IG5ldyBQbGF0Zm9ybVJlZl8oZGlfMS5JbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKGJpbmRpbmdzKSwgZnVuY3Rpb24gKCkgeyBfcGxhdGZvcm0gPSBudWxsOyB9KTtcclxuICAgIHJldHVybiBfcGxhdGZvcm07XHJcbn1cclxuZXhwb3J0cy5wbGF0Zm9ybUNvbW1vbiA9IHBsYXRmb3JtQ29tbW9uO1xyXG4vKipcclxuICogVGhlIEFuZ3VsYXIgcGxhdGZvcm0gaXMgdGhlIGVudHJ5IHBvaW50IGZvciBBbmd1bGFyIG9uIGEgd2ViIHBhZ2UuIEVhY2ggcGFnZVxyXG4gKiBoYXMgZXhhY3RseSBvbmUgcGxhdGZvcm0sIGFuZCBzZXJ2aWNlcyAoc3VjaCBhcyByZWZsZWN0aW9uKSB3aGljaCBhcmUgY29tbW9uXHJcbiAqIHRvIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gcnVubmluZyBvbiB0aGUgcGFnZSBhcmUgYm91bmQgaW4gaXRzIHNjb3BlLlxyXG4gKlxyXG4gKiBBIHBhZ2UncyBwbGF0Zm9ybSBpcyBpbml0aWFsaXplZCBpbXBsaWNpdGx5IHdoZW4ge0BsaW5rIGJvb3RzdHJhcH0oKSBpcyBjYWxsZWQsIG9yXHJcbiAqIGV4cGxpY2l0bHkgYnkgY2FsbGluZyB7QGxpbmsgcGxhdGZvcm19KCkuXHJcbiAqL1xyXG52YXIgUGxhdGZvcm1SZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGxhdGZvcm1SZWYoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgcGxhdGZvcm0ge0BsaW5rIEluamVjdG9yfSwgd2hpY2ggaXMgdGhlIHBhcmVudCBpbmplY3RvciBmb3JcclxuICAgICAgICAgKiBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIGFuZCBwcm92aWRlcyBzaW5nbGV0b24gcHJvdmlkZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICByZXR1cm4gUGxhdGZvcm1SZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGxhdGZvcm1SZWYgPSBQbGF0Zm9ybVJlZjtcclxudmFyIFBsYXRmb3JtUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGxhdGZvcm1SZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGxhdGZvcm1SZWZfKF9pbmplY3RvciwgX2Rpc3Bvc2UpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlID0gX2Rpc3Bvc2U7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5qZWN0b3I7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5hcHBsaWNhdGlvbiA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xyXG4gICAgICAgIHZhciBhcHAgPSB0aGlzLl9pbml0QXBwKGNyZWF0ZU5nWm9uZSgpLCBiaW5kaW5ncyk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmFzeW5jQXBwbGljYXRpb24gPSBmdW5jdGlvbiAoYmluZGluZ0ZuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgem9uZSA9IGNyZWF0ZU5nWm9uZSgpO1xyXG4gICAgICAgIHZhciBjb21wbGV0ZXIgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLmNvbXBsZXRlcigpO1xyXG4gICAgICAgIHpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYXN5bmNfMS5Qcm9taXNlV3JhcHBlci50aGVuKGJpbmRpbmdGbih6b25lKSwgZnVuY3Rpb24gKGJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVzb2x2ZShfdGhpcy5faW5pdEFwcCh6b25lLCBiaW5kaW5ncykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGVyLnByb21pc2U7XHJcbiAgICB9O1xyXG4gICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5faW5pdEFwcCA9IGZ1bmN0aW9uICh6b25lLCBwcm92aWRlcnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpbmplY3RvcjtcclxuICAgICAgICB2YXIgYXBwO1xyXG4gICAgICAgIHpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goZGlfMS5wcm92aWRlKG5nX3pvbmVfMS5OZ1pvbmUsIHsgdXNlVmFsdWU6IHpvbmUgfSkpO1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChkaV8xLnByb3ZpZGUoQXBwbGljYXRpb25SZWYsIHsgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwOyB9LCBkZXBzOiBbXSB9KSk7XHJcbiAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBfdGhpcy5pbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQocHJvdmlkZXJzKTtcclxuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIgPSBpbmplY3Rvci5nZXQoZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgem9uZS5vdmVycmlkZU9uRXJyb3JIYW5kbGVyKGZ1bmN0aW9uIChlLCBzKSB7IHJldHVybiBleGNlcHRpb25IYW5kbGVyLmNhbGwoZSwgcyk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleGNlcHRpb25IYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIuY2FsbChlLCBlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmxvZ0Vycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXBwID0gbmV3IEFwcGxpY2F0aW9uUmVmXyh0aGlzLCB6b25lLCBpbmplY3Rvcik7XHJcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnB1c2goYXBwKTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxuICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7IHJldHVybiBhcHAuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fYXBwbGljYXRpb25EaXNwb3NlZCA9IGZ1bmN0aW9uIChhcHApIHsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hcHBsaWNhdGlvbnMsIGFwcCk7IH07XHJcbiAgICByZXR1cm4gUGxhdGZvcm1SZWZfO1xyXG59KShQbGF0Zm9ybVJlZik7XHJcbmV4cG9ydHMuUGxhdGZvcm1SZWZfID0gUGxhdGZvcm1SZWZfO1xyXG4vKipcclxuICogQSByZWZlcmVuY2UgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIGEgcGFnZS5cclxuICpcclxuICogRm9yIG1vcmUgYWJvdXQgQW5ndWxhciBhcHBsaWNhdGlvbnMsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3Ige0BsaW5rIGJvb3RzdHJhcH0uXHJcbiAqL1xyXG52YXIgQXBwbGljYXRpb25SZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwbGljYXRpb25SZWYoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYXBwbGljYXRpb24ge0BsaW5rIEluamVjdG9yfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJ6b25lXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYXBwbGljYXRpb24ge0BsaW5rIE5nWm9uZX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50IHR5cGVzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEFwcGxpY2F0aW9uUmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcGxpY2F0aW9uUmVmID0gQXBwbGljYXRpb25SZWY7XHJcbnZhciBBcHBsaWNhdGlvblJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFwcGxpY2F0aW9uUmVmXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmXyhfcGxhdGZvcm0sIF96b25lLCBfaW5qZWN0b3IpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcclxuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XHJcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5fYm9vdHN0cmFwTGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50VHlwZXMgPSBbXTtcclxuICAgIH1cclxuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUucmVnaXN0ZXJCb290c3RyYXBMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH07XHJcbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBwcm92aWRlcnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wbGV0ZXIgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLmNvbXBsZXRlcigpO1xyXG4gICAgICAgIHRoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFByb3ZpZGVycyA9IF9jb21wb25lbnRQcm92aWRlcnMoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVycykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3ZpZGVycy5wdXNoKHByb3ZpZGVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbkhhbmRsZXIgPSBfdGhpcy5faW5qZWN0b3IuZ2V0KGV4Y2VwdGlvbnNfMS5FeGNlcHRpb25IYW5kbGVyKTtcclxuICAgICAgICAgICAgX3RoaXMuX3Jvb3RDb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluamVjdG9yID0gX3RoaXMuX2luamVjdG9yLnJlc29sdmVBbmRDcmVhdGVDaGlsZChjb21wb25lbnRQcm92aWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBSZWZUb2tlbiA9IGluamVjdG9yLmdldChhcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfQ09NUE9ORU5UX1JFRl9QUk9NSVNFKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBDaGFuZ2VEZXRlY3RvciA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGNvbXBvbmVudFJlZi5ob3N0VmlldykuY2hhbmdlRGV0ZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxjID0gaW5qZWN0b3IuZ2V0KGxpZmVfY3ljbGVfMS5MaWZlQ3ljbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxjLnJlZ2lzdGVyV2l0aChfdGhpcy5fem9uZSwgYXBwQ2hhbmdlRGV0ZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxjLnRpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVzb2x2ZShjb21wb25lbnRSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yb290Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudFJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoY29tcG9uZW50UmVmKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tSZXN1bHQgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnRoZW4oY29tcFJlZlRva2VuLCB0aWNrKTtcclxuICAgICAgICAgICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIudGhlbih0aWNrUmVzdWx0LCBmdW5jdGlvbiAoXykgeyB9KTtcclxuICAgICAgICAgICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIudGhlbih0aWNrUmVzdWx0LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBzdGFja1RyYWNlKSB7IHJldHVybiBjb21wbGV0ZXIucmVqZWN0KGVyciwgc3RhY2tUcmFjZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyLmNhbGwoZSwgZS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVqZWN0KGUsIGUuc3RhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlci5wcm9taXNlO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcInpvbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fem9uZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXHJcbiAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWYuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybS5fYXBwbGljYXRpb25EaXNwb3NlZCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290Q29tcG9uZW50VHlwZXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFwcGxpY2F0aW9uUmVmXztcclxufSkoQXBwbGljYXRpb25SZWYpO1xyXG5leHBvcnRzLkFwcGxpY2F0aW9uUmVmXyA9IEFwcGxpY2F0aW9uUmVmXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYXRpb25fcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0cy5BUFBfQ09NUE9ORU5UX1JFRl9QUk9NSVNFID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oJ1Byb21pc2U8Q29tcG9uZW50UmVmPicpKTtcclxuLyoqXHJcbiAqIEFuIHtAbGluayBhbmd1bGFyMi9kaS9PcGFxdWVUb2tlbn0gcmVwcmVzZW50aW5nIHRoZSBhcHBsaWNhdGlvbiByb290IHR5cGUgaW4gdGhlIHtAbGlua1xyXG4gKiBJbmplY3Rvcn0uXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KC4uLilcclxuICogY2xhc3MgTXlBcHAge1xyXG4gKiAgIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChNeUFwcCkudGhlbigoYXBwUmVmOkFwcGxpY2F0aW9uUmVmKSB7XHJcbiAqICAgZXhwZWN0KGFwcFJlZi5pbmplY3Rvci5nZXQoYXBwQ29tcG9uZW50VHlwZVRva2VuKSkudG9FcXVhbChNeUFwcCk7XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuQVBQX0NPTVBPTkVOVCA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLk9wYXF1ZVRva2VuKCdBcHBDb21wb25lbnQnKSk7XHJcbi8qKlxyXG4gKiBBIERJIFRva2VuIHJlcHJlc2VudGluZyBhIHVuaXF1ZSBzdHJpbmcgaWQgYXNzaWduZWQgdG8gdGhlIGFwcGxpY2F0aW9uIGJ5IEFuZ3VsYXIgYW5kIHVzZWRcclxuICogcHJpbWFyaWx5IGZvciBwcmVmaXhpbmcgYXBwbGljYXRpb24gYXR0cmlidXRlcyBhbmQgQ1NTIHN0eWxlcyB3aGVuXHJcbiAqIHtAbGluayBWaWV3RW5jYXBzdWxhdGlvbiNFbXVsYXRlZH0gaXMgYmVpbmcgdXNlZC5cclxuICpcclxuICogSWYgeW91IG5lZWQgdG8gYXZvaWQgcmFuZG9tbHkgZ2VuZXJhdGVkIHZhbHVlIHRvIGJlIHVzZWQgYXMgYW4gYXBwbGljYXRpb24gaWQsIHlvdSBjYW4gcHJvdmlkZVxyXG4gKiBhIGN1c3RvbSB2YWx1ZSB2aWEgYSBESSBwcm92aWRlciA8IS0tIFRPRE86IHByb3ZpZGVyIC0tPiBjb25maWd1cmluZyB0aGUgcm9vdCB7QGxpbmsgSW5qZWN0b3J9XHJcbiAqIHVzaW5nIHRoaXMgdG9rZW4uXHJcbiAqL1xyXG5leHBvcnRzLkFQUF9JRCA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLk9wYXF1ZVRva2VuKCdBcHBJZCcpKTtcclxuZnVuY3Rpb24gX2FwcElkUmFuZG9tUHJvdmlkZXJGYWN0b3J5KCkge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCk7XHJcbn1cclxuLyoqXHJcbiAqIEJpbmRpbmdzIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIHJhbmRvbSBBUFBfSURfVE9LRU4uXHJcbiAqL1xyXG5leHBvcnRzLkFQUF9JRF9SQU5ET01fUFJPVklERVIgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihleHBvcnRzLkFQUF9JRCwgeyB1c2VGYWN0b3J5OiBfYXBwSWRSYW5kb21Qcm92aWRlckZhY3RvcnksIGRlcHM6IFtdIH0pKTtcclxuZnVuY3Rpb24gX3JhbmRvbUNoYXIoKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKDk3ICsgbGFuZ18xLk1hdGguZmxvb3IobGFuZ18xLk1hdGgucmFuZG9tKCkgKiAyNSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2F0aW9uX3Rva2Vucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gTm90ZTogVGhpcyBmaWxlIG9ubHkgZXhpc3RzIHNvIHRoYXQgRGFydCB1c2VycyBjYW4gaW1wb3J0XHJcbi8vIGJvb3RzdHJhcCBmcm9tIGFuZ3VsYXIyL2Jvb3RzdHJhcC4gSlMgdXNlcnMgc2hvdWxkIGltcG9ydFxyXG4vLyBmcm9tIGFuZ3VsYXIyL2NvcmUuXHJcbnZhciBhcHBsaWNhdGlvbl8xID0gcmVxdWlyZSgnLi9hcHBsaWNhdGlvbicpO1xyXG5leHBvcnRzLmJvb3RzdHJhcCA9IGFwcGxpY2F0aW9uXzEuYm9vdHN0cmFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDaGFuZ2UgZGV0ZWN0aW9uIGVuYWJsZXMgZGF0YSBiaW5kaW5nIGluIEFuZ3VsYXIuXHJcbiAqL1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcclxuZXhwb3J0cy5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbiA9IGNoYW5nZV9kZXRlY3Rpb25fMS5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbjtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25FcnJvciA9IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25FcnJvcjtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclJlZjtcclxuZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuV3JhcHBlZFZhbHVlO1xyXG5leHBvcnRzLlNpbXBsZUNoYW5nZSA9IGNoYW5nZV9kZXRlY3Rpb25fMS5TaW1wbGVDaGFuZ2U7XHJcbmV4cG9ydHMuSXRlcmFibGVEaWZmZXJzID0gY2hhbmdlX2RldGVjdGlvbl8xLkl0ZXJhYmxlRGlmZmVycztcclxuZXhwb3J0cy5LZXlWYWx1ZURpZmZlcnMgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rpb25fdXRpbCcpO1xyXG52YXIgY2hhbmdlX2RldGVjdG9yX3JlZl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0b3JfcmVmJyk7XHJcbnZhciBleGNlcHRpb25zXzIgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4uL3Byb2ZpbGUvcHJvZmlsZScpO1xyXG52YXIgb2JzZXJ2YWJsZV9mYWNhZGVfMSA9IHJlcXVpcmUoJy4vb2JzZXJ2YWJsZV9mYWNhZGUnKTtcclxudmFyIF9zY29wZV9jaGVjayA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZShcIkNoYW5nZURldGVjdG9yI2NoZWNrKGFzY2lpIGlkLCBib29sIHRocm93T25DaGFuZ2UpXCIpO1xyXG52YXIgX0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX0NvbnRleHQoZWxlbWVudCwgY29tcG9uZW50RWxlbWVudCwgY29udGV4dCwgbG9jYWxzLCBpbmplY3RvciwgZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRFbGVtZW50ID0gY29tcG9uZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbG9jYWxzO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9Db250ZXh0O1xyXG59KSgpO1xyXG52YXIgQWJzdHJhY3RDaGFuZ2VEZXRlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENoYW5nZURldGVjdG9yKGlkLCBkaXNwYXRjaGVyLCBudW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzLCBiaW5kaW5nVGFyZ2V0cywgZGlyZWN0aXZlSW5kaWNlcywgc3RyYXRlZ3kpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcclxuICAgICAgICB0aGlzLm51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMgPSBudW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1RhcmdldHMgPSBiaW5kaW5nVGFyZ2V0cztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZUluZGljZXMgPSBkaXJlY3RpdmVJbmRpY2VzO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcclxuICAgICAgICB0aGlzLmxpZ2h0RG9tQ2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbUNoaWxkcmVuID0gW107XHJcbiAgICAgICAgLy8gVGhlIG5hbWVzIG9mIHRoZSBiZWxvdyBmaWVsZHMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBjb2RlZ2VuX25hbWVfdXRpbC50cyBvclxyXG4gICAgICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24gd2lsbCBmYWlsLlxyXG4gICAgICAgIHRoaXMuYWxyZWFkeUNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2FscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBpcGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlZiA9IG5ldyBjaGFuZ2VfZGV0ZWN0b3JfcmVmXzEuQ2hhbmdlRGV0ZWN0b3JSZWZfKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2QpIHtcclxuICAgICAgICB0aGlzLmxpZ2h0RG9tQ2hpbGRyZW4ucHVzaChjZCk7XHJcbiAgICAgICAgY2QucGFyZW50ID0gdGhpcztcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjZCkgeyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMubGlnaHREb21DaGlsZHJlbiwgY2QpOyB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuYWRkU2hhZG93RG9tQ2hpbGQgPSBmdW5jdGlvbiAoY2QpIHtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbUNoaWxkcmVuLnB1c2goY2QpO1xyXG4gICAgICAgIGNkLnBhcmVudCA9IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUucmVtb3ZlU2hhZG93RG9tQ2hpbGQgPSBmdW5jdGlvbiAoY2QpIHsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLnNoYWRvd0RvbUNoaWxkcmVuLCBjZCk7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7IHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpOyB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbEluZGV4LCBsb2NhbHMpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5oYW5kbGVFdmVudEludGVybmFsKGV2ZW50TmFtZSwgZWxJbmRleCwgbG9jYWxzKTtcclxuICAgICAgICB0aGlzLm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmhhbmRsZUV2ZW50SW50ZXJuYWwgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbEluZGV4LCBsb2NhbHMpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5ydW5EZXRlY3RDaGFuZ2VzKGZhbHNlKTsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJOb3QgaW1wbGVtZW50ZWRcIik7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5ydW5EZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZXRhY2hlZCB8fFxyXG4gICAgICAgICAgICB0aGlzLm1vZGUgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgcyA9IF9zY29wZV9jaGVjayh0aGlzLmlkLCB0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJblJlY29yZHModGhyb3dPbkNoYW5nZSk7XHJcbiAgICAgICAgdGhpcy5fZGV0ZWN0Q2hhbmdlc0luTGlnaHREb21DaGlsZHJlbih0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICBpZiAoIXRocm93T25DaGFuZ2UpXHJcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzKCk7XHJcbiAgICAgICAgdGhpcy5fZGV0ZWN0Q2hhbmdlc0luU2hhZG93RG9tQ2hpbGRyZW4odGhyb3dPbkNoYW5nZSk7XHJcbiAgICAgICAgaWYgKCF0aHJvd09uQ2hhbmdlKVxyXG4gICAgICAgICAgICB0aGlzLmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcygpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZSlcclxuICAgICAgICAgICAgdGhpcy5tb2RlID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tlZDtcclxuICAgICAgICB0aGlzLmFscmVhZHlDaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICBwcm9maWxlXzEud3RmTGVhdmUocyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4uIFN1YmNsYXNzZXMgc2hvdWxkIGluc3RlYWQgcHJvdmlkZSBhblxyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgYGRldGVjdENoYW5nZXNJblJlY29yZHNJbnRlcm5hbGAgd2hpY2ggZG9lcyB0aGUgd29yayBvZiBkZXRlY3RpbmcgY2hhbmdlc1xyXG4gICAgLy8gYW5kIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgY2FsbC5cclxuICAgIC8vIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhhdCBgZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsYCB3aWxsIHNldCB0aGUgcHJvcGVydHlcclxuICAgIC8vIGB0aGlzLnByb3BlcnR5QmluZGluZ0luZGV4YCB0byB0aGUgcHJvcGVydHlCaW5kaW5nSW5kZXggb2YgdGhlIGZpcnN0IHByb3RvIHJlY29yZC4gVGhpcyBpcyB0b1xyXG4gICAgLy8gZmFjaWxpdGF0ZSBlcnJvciByZXBvcnRpbmcuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzSW5SZWNvcmRzID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaHlkcmF0ZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRocm93RGVoeWRyYXRlZEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsKHRocm93T25DaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGUsIGUuc3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGFueSB3b3JrIG5lY2Vzc2FyeSB0byBkZXRlY3QgYW5kIHJlcG9ydFxyXG4gICAgLy8gY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGNoYW5nZXMgc2hvdWxkIGJlIHJlcG9ydGVkIHZpYSBgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hZGRDaGFuZ2VgLCBsaWZlY3ljbGVcclxuICAgIC8vIG1ldGhvZHMgc2hvdWxkIGJlIGNhbGxlZCwgZXRjLlxyXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYWxzbyBzZXQgYHRoaXMucHJvcGVydHlCaW5kaW5nSW5kZXhgIHRvIHRoZSBwcm9wZXJ0eUJpbmRpbmdJbmRleCBvZlxyXG4gICAgLy8gdGhlXHJcbiAgICAvLyBmaXJzdCBwcm90byByZWNvcmQgdG8gZmFjaWxpdGF0ZSBlcnJvciByZXBvcnRpbmcuIFNlZSB7QGxpbmsgI2RldGVjdENoYW5nZXNJblJlY29yZHN9LlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHsgfTtcclxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuLiBTdWJjbGFzc2VzIHNob3VsZCBpbnN0ZWFkIHByb3ZpZGUgYW5cclxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBoeWRyYXRlRGlyZWN0aXZlc2AuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oeWRyYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIGxvY2FscywgZGlyZWN0aXZlcywgcGlwZXMpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmNoYW5nZURldGVjdGlvbk1vZGUodGhpcy5zdHJhdGVneSk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICBpZiAodGhpcy5zdHJhdGVneSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoT2JzZXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVDb21wb25lbnQoY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbG9jYWxzO1xyXG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcclxuICAgICAgICB0aGlzLmh5ZHJhdGVEaXJlY3RpdmVzKGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIHRoaXMuYWxyZWFkeUNoZWNrZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBoeWRyYXRlIGFueSBkaXJlY3RpdmVzLlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykgeyB9O1xyXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4uIFN1YmNsYXNzZXMgc2hvdWxkIGluc3RlYWQgcHJvdmlkZSBhblxyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgYGRlaHlkcmF0ZURpcmVjdGl2ZXNgLlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVoeWRyYXRlRGlyZWN0aXZlcyh0cnVlKTtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiBXb3JrcyBvbmx5IGluIERhcnQuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzcmliZUZyb21PYnNlcnZhYmxlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBpcGVzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkZWh5ZHJhdGUgYW55IGRpcmVjdGl2ZXMuIFRoaXMgbWV0aG9kIHNob3VsZCByZXZlcnNlXHJcbiAgICAvLyBhbnkgd29yayBkb25lIGluIGBoeWRyYXRlRGlyZWN0aXZlc2AuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZWh5ZHJhdGVEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRlc3Ryb3lQaXBlcykgeyB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaHlkcmF0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgIT09IG51bGw7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLm5vdGlmeUFmdGVyQ29udGVudENoZWNrZWQoKTtcclxuICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsKCk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLm5vdGlmeUFmdGVyVmlld0NoZWNrZWQoKTtcclxuICAgICAgICB0aGlzLmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsKCk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZGV0ZWN0Q2hhbmdlc0luTGlnaHREb21DaGlsZHJlbiA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxpZ2h0RG9tQ2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNbaV0ucnVuRGV0ZWN0Q2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX2RldGVjdENoYW5nZXNJblNoYWRvd0RvbUNoaWxkcmVuID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuc2hhZG93RG9tQ2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNbaV0ucnVuRGV0ZWN0Q2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUubWFya0FzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1vZGUgPSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja09uY2U7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcztcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChjKSAmJiBjLm1vZGUgIT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRldGFjaGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjLm1vZGUgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICBjLm1vZGUgPSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja09uY2U7XHJcbiAgICAgICAgICAgIGMgPSBjLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gV29ya3Mgb25seSBpbiBEYXJ0LlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3Vuc3Vic3JpYmVGcm9tT2JzZXJ2YWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5zdWJzY3JpcHRpb25zKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnN1YnNjcmlwdGlvbnNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5jYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLm9ic2VydmVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvYnNlcnZhYmxlX2ZhY2FkZV8xLmlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXJyYXlUb1N0b3JlT2JzZXJ2YWJsZXMoKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuc3Vic2NyaXB0aW9uc1tpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbXNbaW5kZXhdID0gdmFsdWUuY2hhbmdlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSB2YWx1ZS5jaGFuZ2VzLmxpc3RlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMucmVmLm1hcmtGb3JDaGVjaygpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmVhbXNbaW5kZXhdICE9PSB2YWx1ZS5jaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaW5kZXhdLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1zW2luZGV4XSA9IHZhbHVlLmNoYW5nZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gdmFsdWUuY2hhbmdlcy5saXN0ZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnJlZi5tYXJrRm9yQ2hlY2soKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLm9ic2VydmVEaXJlY3RpdmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAob2JzZXJ2YWJsZV9mYWNhZGVfMS5pc09ic2VydmFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFycmF5VG9TdG9yZU9ic2VydmFibGVzKCk7XHJcbiAgICAgICAgICAgIHZhciBhcnJheUluZGV4ID0gdGhpcy5udW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzICsgaW5kZXggKyAyOyAvLyArMSBpcyBjb21wb25lbnRcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zW2FycmF5SW5kZXhdID0gdmFsdWUuY2hhbmdlcztcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zW2FycmF5SW5kZXhdID0gdmFsdWUuY2hhbmdlcy5saXN0ZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnJlZi5tYXJrRm9yQ2hlY2soKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICAvLyBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiBXb3JrcyBvbmx5IGluIERhcnQuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5vYnNlcnZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAob2JzZXJ2YWJsZV9mYWNhZGVfMS5pc09ic2VydmFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFycmF5VG9TdG9yZU9ic2VydmFibGVzKCk7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubnVtYmVyT2ZQcm9wZXJ0eVByb3RvUmVjb3JkcyArIDE7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtc1tpbmRleF0gPSB2YWx1ZS5jaGFuZ2VzO1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gdmFsdWUuY2hhbmdlcy5saXN0ZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnJlZi5tYXJrRm9yQ2hlY2soKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fY3JlYXRlQXJyYXlUb1N0b3JlT2JzZXJ2YWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuc3Vic2NyaXB0aW9ucykpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSh0aGlzLm51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVJbmRpY2VzLmxlbmd0aCArIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHRoaXMubnVtYmVyT2ZQcm9wZXJ0eVByb3RvUmVjb3JkcyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZUluZGljZXMubGVuZ3RoICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmdldERpcmVjdGl2ZUZvciA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLmdldERpcmVjdGl2ZUZvcih0aGlzLmRpcmVjdGl2ZUluZGljZXNbaW5kZXhdKTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5nZXREZXRlY3RvckZvciA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLmdldERldGVjdG9yRm9yKHRoaXMuZGlyZWN0aXZlSW5kaWNlc1tpbmRleF0pO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLm5vdGlmeURpc3BhdGNoZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIubm90aWZ5T25CaW5kaW5nKHRoaXMuX2N1cnJlbnRCaW5kaW5nKCksIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5sb2dCaW5kaW5nVXBkYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmxvZ0JpbmRpbmdVcGRhdGUodGhpcy5fY3VycmVudEJpbmRpbmcoKSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmFkZENoYW5nZSA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY2hhbmdlcykpIHtcclxuICAgICAgICAgICAgY2hhbmdlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFuZ2VzW3RoaXMuX2N1cnJlbnRCaW5kaW5nKCkubmFtZV0gPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLnNpbXBsZUNoYW5nZShvbGRWYWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKGV4Y2VwdGlvbiwgc3RhY2spIHtcclxuICAgICAgICB2YXIgZXJyb3I7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmRpc3BhdGNoZXIuZ2V0RGVidWdDb250ZXh0KHRoaXMuX2N1cnJlbnRCaW5kaW5nKCkuZWxlbWVudEluZGV4LCBudWxsKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBsYW5nXzEuaXNQcmVzZW50KGMpID8gbmV3IF9Db250ZXh0KGMuZWxlbWVudCwgYy5jb21wb25lbnRFbGVtZW50LCBjLmNvbnRleHQsIGMubG9jYWxzLCBjLmluamVjdG9yLCB0aGlzLl9jdXJyZW50QmluZGluZygpLmRlYnVnKSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBleGNlcHRpb25zXzIuQ2hhbmdlRGV0ZWN0aW9uRXJyb3IodGhpcy5fY3VycmVudEJpbmRpbmcoKS5kZWJ1ZywgZXhjZXB0aW9uLCBzdGFjaywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbnMgZHVyaW5nIGdldHRpbmcgdGhlIGRlYnVnIGNvbnRleHQsIHdlIHRocm93IGEgQ2hhbmdlRGV0ZWN0aW9uRXJyb3JcclxuICAgICAgICAgICAgLy8gd2l0aG91dCB0aGUgZXh0cmEgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgIGVycm9yID0gbmV3IGV4Y2VwdGlvbnNfMi5DaGFuZ2VEZXRlY3Rpb25FcnJvcihudWxsLCBleGNlcHRpb24sIHN0YWNrLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUudGhyb3dPbkNoYW5nZUVycm9yID0gZnVuY3Rpb24gKG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24odGhpcy5fY3VycmVudEJpbmRpbmcoKS5kZWJ1Zywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS50aHJvd0RlaHlkcmF0ZWRFcnJvciA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5EZWh5ZHJhdGVkRXhjZXB0aW9uKCk7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fY3VycmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ1RhcmdldHNbdGhpcy5wcm9wZXJ0eUJpbmRpbmdJbmRleF07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQWJzdHJhY3RDaGFuZ2VEZXRlY3RvciA9IEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBESVJFQ1RJVkVfTElGRUNZQ0xFID0gXCJkaXJlY3RpdmVMaWZlY3ljbGVcIjtcclxudmFyIEJJTkRJTkcgPSBcIm5hdGl2ZVwiO1xyXG52YXIgRElSRUNUSVZFID0gXCJkaXJlY3RpdmVcIjtcclxudmFyIEVMRU1FTlRfUFJPUEVSVFkgPSBcImVsZW1lbnRQcm9wZXJ0eVwiO1xyXG52YXIgRUxFTUVOVF9BVFRSSUJVVEUgPSBcImVsZW1lbnRBdHRyaWJ1dGVcIjtcclxudmFyIEVMRU1FTlRfQ0xBU1MgPSBcImVsZW1lbnRDbGFzc1wiO1xyXG52YXIgRUxFTUVOVF9TVFlMRSA9IFwiZWxlbWVudFN0eWxlXCI7XHJcbnZhciBURVhUX05PREUgPSBcInRleHROb2RlXCI7XHJcbnZhciBFVkVOVCA9IFwiZXZlbnRcIjtcclxudmFyIEhPU1RfRVZFTlQgPSBcImhvc3RFdmVudFwiO1xyXG52YXIgQmluZGluZ1RhcmdldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaW5kaW5nVGFyZ2V0KG1vZGUsIGVsZW1lbnRJbmRleCwgbmFtZSwgdW5pdCwgZGVidWcpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEluZGV4ID0gZWxlbWVudEluZGV4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcclxuICAgICAgICB0aGlzLmRlYnVnID0gZGVidWc7XHJcbiAgICB9XHJcbiAgICBCaW5kaW5nVGFyZ2V0LnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRElSRUNUSVZFOyB9O1xyXG4gICAgQmluZGluZ1RhcmdldC5wcm90b3R5cGUuaXNFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IEVMRU1FTlRfUFJPUEVSVFk7IH07XHJcbiAgICBCaW5kaW5nVGFyZ2V0LnByb3RvdHlwZS5pc0VsZW1lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IEVMRU1FTlRfQVRUUklCVVRFOyB9O1xyXG4gICAgQmluZGluZ1RhcmdldC5wcm90b3R5cGUuaXNFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IEVMRU1FTlRfQ0xBU1M7IH07XHJcbiAgICBCaW5kaW5nVGFyZ2V0LnByb3RvdHlwZS5pc0VsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRUxFTUVOVF9TVFlMRTsgfTtcclxuICAgIEJpbmRpbmdUYXJnZXQucHJvdG90eXBlLmlzVGV4dE5vZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IFRFWFRfTk9ERTsgfTtcclxuICAgIHJldHVybiBCaW5kaW5nVGFyZ2V0O1xyXG59KSgpO1xyXG5leHBvcnRzLkJpbmRpbmdUYXJnZXQgPSBCaW5kaW5nVGFyZ2V0O1xyXG52YXIgQmluZGluZ1JlY29yZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaW5kaW5nUmVjb3JkKG1vZGUsIHRhcmdldCwgaW1wbGljaXRSZWNlaXZlciwgYXN0LCBzZXR0ZXIsIGxpZmVjeWNsZUV2ZW50LCBkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuaW1wbGljaXRSZWNlaXZlciA9IGltcGxpY2l0UmVjZWl2ZXI7XHJcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XHJcbiAgICAgICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5saWZlY3ljbGVFdmVudCA9IGxpZmVjeWNsZUV2ZW50O1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlUmVjb3JkID0gZGlyZWN0aXZlUmVjb3JkO1xyXG4gICAgfVxyXG4gICAgQmluZGluZ1JlY29yZC5wcm90b3R5cGUuaXNEaXJlY3RpdmVMaWZlY3ljbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IERJUkVDVElWRV9MSUZFQ1lDTEU7IH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLnByb3RvdHlwZS5jYWxsT25DaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZGlyZWN0aXZlUmVjb3JkKSAmJiB0aGlzLmRpcmVjdGl2ZVJlY29yZC5jYWxsT25DaGFuZ2VzO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQucHJvdG90eXBlLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsodGhpcy5kaXJlY3RpdmVSZWNvcmQpIHx8IHRoaXMuZGlyZWN0aXZlUmVjb3JkLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRGlyZWN0aXZlRG9DaGVjayA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoRElSRUNUSVZFX0xJRkVDWUNMRSwgbnVsbCwgMCwgbnVsbCwgbnVsbCwgXCJEb0NoZWNrXCIsIGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVEaXJlY3RpdmVPbkluaXQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKERJUkVDVElWRV9MSUZFQ1lDTEUsIG51bGwsIDAsIG51bGwsIG51bGwsIFwiT25Jbml0XCIsIGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVEaXJlY3RpdmVPbkNoYW5nZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKERJUkVDVElWRV9MSUZFQ1lDTEUsIG51bGwsIDAsIG51bGwsIG51bGwsIFwiT25DaGFuZ2VzXCIsIGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JEaXJlY3RpdmUgPSBmdW5jdGlvbiAoYXN0LCBwcm9wZXJ0eU5hbWUsIHNldHRlciwgZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IGRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChESVJFQ1RJVkUsIGVsZW1lbnRJbmRleCwgcHJvcGVydHlOYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKERJUkVDVElWRSwgdCwgMCwgYXN0LCBzZXR0ZXIsIG51bGwsIGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBlbGVtZW50SW5kZXgsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9QUk9QRVJUWSwgZWxlbWVudEluZGV4LCBwcm9wZXJ0eU5hbWUsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgMCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBlbGVtZW50SW5kZXgsIGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVMRU1FTlRfQVRUUklCVVRFLCBlbGVtZW50SW5kZXgsIGF0dHJpYnV0ZU5hbWUsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgMCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChhc3QsIGVsZW1lbnRJbmRleCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChFTEVNRU5UX0NMQVNTLCBlbGVtZW50SW5kZXgsIGNsYXNzTmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCAwLCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudFN0eWxlID0gZnVuY3Rpb24gKGFzdCwgZWxlbWVudEluZGV4LCBzdHlsZU5hbWUsIHVuaXQpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVMRU1FTlRfU1RZTEUsIGVsZW1lbnRJbmRleCwgc3R5bGVOYW1lLCB1bml0LCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEJJTkRJTkcsIHQsIDAsIGFzdCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JIb3N0UHJvcGVydHkgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgsIGFzdCwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChFTEVNRU5UX1BST1BFUlRZLCBkaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXgsIHByb3BlcnR5TmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCBkaXJlY3RpdmVJbmRleCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgsIGFzdCwgYXR0cmlidXRlTmFtZSkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9BVFRSSUJVVEUsIGRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleCwgYXR0cmlidXRlTmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCBkaXJlY3RpdmVJbmRleCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RDbGFzcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbmRleCwgYXN0LCBjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVMRU1FTlRfQ0xBU1MsIGRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleCwgY2xhc3NOYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEJJTkRJTkcsIHQsIGRpcmVjdGl2ZUluZGV4LCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdFN0eWxlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4LCBhc3QsIHN0eWxlTmFtZSwgdW5pdCkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9TVFlMRSwgZGlyZWN0aXZlSW5kZXguZWxlbWVudEluZGV4LCBzdHlsZU5hbWUsIHVuaXQsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgZGlyZWN0aXZlSW5kZXgsIGFzdCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JUZXh0Tm9kZSA9IGZ1bmN0aW9uIChhc3QsIGVsZW1lbnRJbmRleCkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoVEVYVF9OT0RFLCBlbGVtZW50SW5kZXgsIG51bGwsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgMCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnROYW1lLCBlbGVtZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVWRU5ULCBlbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChFVkVOVCwgdCwgMCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGV2ZW50TmFtZSwgZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUluZGV4ID0gZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4O1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoSE9TVF9FVkVOVCwgZGlyZWN0aXZlSW5kZXguZWxlbWVudEluZGV4LCBldmVudE5hbWUsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoSE9TVF9FVkVOVCwgdCwgZGlyZWN0aXZlSW5kZXgsIGFzdCwgbnVsbCwgbnVsbCwgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmluZGluZ1JlY29yZDtcclxufSkoKTtcclxuZXhwb3J0cy5CaW5kaW5nUmVjb3JkID0gQmluZGluZ1JlY29yZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZ19yZWNvcmQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBpdGVyYWJsZV9kaWZmZXJzXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMvaXRlcmFibGVfZGlmZmVycycpO1xyXG52YXIgZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXJfMSA9IHJlcXVpcmUoJy4vZGlmZmVycy9kZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcicpO1xyXG52YXIga2V5dmFsdWVfZGlmZmVyc18xID0gcmVxdWlyZSgnLi9kaWZmZXJzL2tleXZhbHVlX2RpZmZlcnMnKTtcclxudmFyIGRlZmF1bHRfa2V5dmFsdWVfZGlmZmVyXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMvZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3RfMSA9IHJlcXVpcmUoJy4vcGFyc2VyL2FzdCcpO1xyXG5leHBvcnRzLkFTVFdpdGhTb3VyY2UgPSBhc3RfMS5BU1RXaXRoU291cmNlO1xyXG5leHBvcnRzLkFTVCA9IGFzdF8xLkFTVDtcclxuZXhwb3J0cy5Bc3RUcmFuc2Zvcm1lciA9IGFzdF8xLkFzdFRyYW5zZm9ybWVyO1xyXG5leHBvcnRzLlByb3BlcnR5UmVhZCA9IGFzdF8xLlByb3BlcnR5UmVhZDtcclxuZXhwb3J0cy5MaXRlcmFsQXJyYXkgPSBhc3RfMS5MaXRlcmFsQXJyYXk7XHJcbmV4cG9ydHMuSW1wbGljaXRSZWNlaXZlciA9IGFzdF8xLkltcGxpY2l0UmVjZWl2ZXI7XHJcbnZhciBsZXhlcl8xID0gcmVxdWlyZSgnLi9wYXJzZXIvbGV4ZXInKTtcclxuZXhwb3J0cy5MZXhlciA9IGxleGVyXzEuTGV4ZXI7XHJcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoJy4vcGFyc2VyL3BhcnNlcicpO1xyXG5leHBvcnRzLlBhcnNlciA9IHBhcnNlcl8xLlBhcnNlcjtcclxudmFyIGxvY2Fsc18xID0gcmVxdWlyZSgnLi9wYXJzZXIvbG9jYWxzJyk7XHJcbmV4cG9ydHMuTG9jYWxzID0gbG9jYWxzXzEuTG9jYWxzO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi9leGNlcHRpb25zJyk7XHJcbmV4cG9ydHMuRGVoeWRyYXRlZEV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnNfMS5EZWh5ZHJhdGVkRXhjZXB0aW9uO1xyXG5leHBvcnRzLkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uID0gZXhjZXB0aW9uc18xLkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvbkVycm9yID0gZXhjZXB0aW9uc18xLkNoYW5nZURldGVjdGlvbkVycm9yO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uID0gaW50ZXJmYWNlc18xLkNoYW5nZURldGVjdG9yRGVmaW5pdGlvbjtcclxuZXhwb3J0cy5EZWJ1Z0NvbnRleHQgPSBpbnRlcmZhY2VzXzEuRGVidWdDb250ZXh0O1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9yR2VuQ29uZmlnID0gaW50ZXJmYWNlc18xLkNoYW5nZURldGVjdG9yR2VuQ29uZmlnO1xyXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XHJcbmV4cG9ydHMuQ0hBTkdFX0RFQ1RJT05fU1RSQVRFR1lfVkFMVUVTID0gY29uc3RhbnRzXzEuQ0hBTkdFX0RFQ1RJT05fU1RSQVRFR1lfVkFMVUVTO1xyXG52YXIgcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEgPSByZXF1aXJlKCcuL3Byb3RvX2NoYW5nZV9kZXRlY3RvcicpO1xyXG5leHBvcnRzLkR5bmFtaWNQcm90b0NoYW5nZURldGVjdG9yID0gcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEuRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3I7XHJcbnZhciBqaXRfcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEgPSByZXF1aXJlKCcuL2ppdF9wcm90b19jaGFuZ2VfZGV0ZWN0b3InKTtcclxuZXhwb3J0cy5KaXRQcm90b0NoYW5nZURldGVjdG9yID0gaml0X3Byb3RvX2NoYW5nZV9kZXRlY3Rvcl8xLkppdFByb3RvQ2hhbmdlRGV0ZWN0b3I7XHJcbnZhciBiaW5kaW5nX3JlY29yZF8xID0gcmVxdWlyZSgnLi9iaW5kaW5nX3JlY29yZCcpO1xyXG5leHBvcnRzLkJpbmRpbmdSZWNvcmQgPSBiaW5kaW5nX3JlY29yZF8xLkJpbmRpbmdSZWNvcmQ7XHJcbmV4cG9ydHMuQmluZGluZ1RhcmdldCA9IGJpbmRpbmdfcmVjb3JkXzEuQmluZGluZ1RhcmdldDtcclxudmFyIGRpcmVjdGl2ZV9yZWNvcmRfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX3JlY29yZCcpO1xyXG5leHBvcnRzLkRpcmVjdGl2ZUluZGV4ID0gZGlyZWN0aXZlX3JlY29yZF8xLkRpcmVjdGl2ZUluZGV4O1xyXG5leHBvcnRzLkRpcmVjdGl2ZVJlY29yZCA9IGRpcmVjdGl2ZV9yZWNvcmRfMS5EaXJlY3RpdmVSZWNvcmQ7XHJcbnZhciBkeW5hbWljX2NoYW5nZV9kZXRlY3Rvcl8xID0gcmVxdWlyZSgnLi9keW5hbWljX2NoYW5nZV9kZXRlY3RvcicpO1xyXG5leHBvcnRzLkR5bmFtaWNDaGFuZ2VEZXRlY3RvciA9IGR5bmFtaWNfY2hhbmdlX2RldGVjdG9yXzEuRHluYW1pY0NoYW5nZURldGVjdG9yO1xyXG52YXIgY2hhbmdlX2RldGVjdG9yX3JlZl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0b3JfcmVmJyk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSBjaGFuZ2VfZGV0ZWN0b3JfcmVmXzEuQ2hhbmdlRGV0ZWN0b3JSZWY7XHJcbnZhciBpdGVyYWJsZV9kaWZmZXJzXzIgPSByZXF1aXJlKCcuL2RpZmZlcnMvaXRlcmFibGVfZGlmZmVycycpO1xyXG5leHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IGl0ZXJhYmxlX2RpZmZlcnNfMi5JdGVyYWJsZURpZmZlcnM7XHJcbnZhciBrZXl2YWx1ZV9kaWZmZXJzXzIgPSByZXF1aXJlKCcuL2RpZmZlcnMva2V5dmFsdWVfZGlmZmVycycpO1xyXG5leHBvcnRzLktleVZhbHVlRGlmZmVycyA9IGtleXZhbHVlX2RpZmZlcnNfMi5LZXlWYWx1ZURpZmZlcnM7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdGlvbl91dGlsJyk7XHJcbmV4cG9ydHMuV3JhcHBlZFZhbHVlID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuV3JhcHBlZFZhbHVlO1xyXG5leHBvcnRzLlNpbXBsZUNoYW5nZSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLlNpbXBsZUNoYW5nZTtcclxuLyoqXHJcbiAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYE9iamVjdGBzIGFuZCBgTWFwYHMuXHJcbiAqL1xyXG5leHBvcnRzLmtleVZhbERpZmYgPSBsYW5nXzEuQ09OU1RfRVhQUihbbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRlZmF1bHRfa2V5dmFsdWVfZGlmZmVyXzEuRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSgpKV0pO1xyXG4vKipcclxuICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgSXRlcmFibGVgIHR5cGVzIHN1Y2ggYXMgYEFycmF5YHMuXHJcbiAqL1xyXG5leHBvcnRzLml0ZXJhYmxlRGlmZiA9IGxhbmdfMS5DT05TVF9FWFBSKFtsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXJfMS5EZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCkpXSk7XHJcbmV4cG9ydHMuZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBpdGVyYWJsZV9kaWZmZXJzXzEuSXRlcmFibGVEaWZmZXJzKGV4cG9ydHMuaXRlcmFibGVEaWZmKSk7XHJcbmV4cG9ydHMuZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBrZXl2YWx1ZV9kaWZmZXJzXzEuS2V5VmFsdWVEaWZmZXJzKGV4cG9ydHMua2V5VmFsRGlmZikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBhYnN0cmFjdF9jaGFuZ2VfZGV0ZWN0b3JfMSA9IHJlcXVpcmUoJy4vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdGlvbl91dGlsJyk7XHJcbnZhciBjb2RlZ2VuX25hbWVfdXRpbF8xID0gcmVxdWlyZSgnLi9jb2RlZ2VuX25hbWVfdXRpbCcpO1xyXG52YXIgY29kZWdlbl9sb2dpY191dGlsXzEgPSByZXF1aXJlKCcuL2NvZGVnZW5fbG9naWNfdXRpbCcpO1xyXG52YXIgY29kZWdlbl9mYWNhZGVfMSA9IHJlcXVpcmUoJy4vY29kZWdlbl9mYWNhZGUnKTtcclxudmFyIHByb3RvX2NoYW5nZV9kZXRlY3Rvcl8xID0gcmVxdWlyZSgnLi9wcm90b19jaGFuZ2VfZGV0ZWN0b3InKTtcclxuLyoqXHJcbiAqIFRoZSBjb2RlIGdlbmVyYXRvciB0YWtlcyBhIGxpc3Qgb2YgcHJvdG8gcmVjb3JkcyBhbmQgY3JlYXRlcyBhIGZ1bmN0aW9uL2NsYXNzXHJcbiAqIHRoYXQgXCJlbXVsYXRlc1wiIHdoYXQgdGhlIGRldmVsb3BlciB3b3VsZCB3cml0ZSBieSBoYW5kIHRvIGltcGxlbWVudCB0aGUgc2FtZVxyXG4gKiBraW5kIG9mIGJlaGF2aW91ci5cclxuICpcclxuICogVGhpcyBjb2RlIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgRGFydCB0cmFuc2Zvcm1lcidzXHJcbiAqIGBhbmd1bGFyMi50cmFuc2Zvcm0udGVtcGxhdGVfY29tcGlsZXIuY2hhbmdlX2RldGVjdG9yX2NvZGVnZW5gIGxpYnJhcnkuIElmIHlvdSBtYWtlIHVwZGF0ZXNcclxuICogaGVyZSwgcGxlYXNlIG1ha2UgZXF1aXZhbGVudCBjaGFuZ2VzIHRoZXJlLlxyXG4qL1xyXG52YXIgSVNfQ0hBTkdFRF9MT0NBTCA9IFwiaXNDaGFuZ2VkXCI7XHJcbnZhciBDSEFOR0VTX0xPQ0FMID0gXCJjaGFuZ2VzXCI7XHJcbnZhciBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvcihkZWZpbml0aW9uLCBjaGFuZ2VEZXRlY3Rpb25VdGlsVmFyTmFtZSwgYWJzdHJhY3RDaGFuZ2VEZXRlY3RvclZhck5hbWUpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lID0gY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWU7XHJcbiAgICAgICAgdGhpcy5hYnN0cmFjdENoYW5nZURldGVjdG9yVmFyTmFtZSA9IGFic3RyYWN0Q2hhbmdlRGV0ZWN0b3JWYXJOYW1lO1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eUJpbmRpbmdSZWNvcmRzID0gcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEuY3JlYXRlUHJvcGVydHlSZWNvcmRzKGRlZmluaXRpb24pO1xyXG4gICAgICAgIHZhciBldmVudEJpbmRpbmdSZWNvcmRzID0gcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEuY3JlYXRlRXZlbnRSZWNvcmRzKGRlZmluaXRpb24pO1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eUJpbmRpbmdUYXJnZXRzID0gZGVmaW5pdGlvbi5iaW5kaW5nUmVjb3Jkcy5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIudGFyZ2V0OyB9KTtcclxuICAgICAgICB0aGlzLmlkID0gZGVmaW5pdGlvbi5pZDtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gZGVmaW5pdGlvbi5zdHJhdGVneTtcclxuICAgICAgICB0aGlzLmdlbkNvbmZpZyA9IGRlZmluaXRpb24uZ2VuQ29uZmlnO1xyXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IHByb3BlcnR5QmluZGluZ1JlY29yZHM7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdUYXJnZXRzID0gcHJvcGVydHlCaW5kaW5nVGFyZ2V0cztcclxuICAgICAgICB0aGlzLmV2ZW50QmluZGluZ3MgPSBldmVudEJpbmRpbmdSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlUmVjb3JkcyA9IGRlZmluaXRpb24uZGlyZWN0aXZlUmVjb3JkcztcclxuICAgICAgICB0aGlzLl9uYW1lcyA9IG5ldyBjb2RlZ2VuX25hbWVfdXRpbF8xLkNvZGVnZW5OYW1lVXRpbCh0aGlzLnJlY29yZHMsIHRoaXMuZXZlbnRCaW5kaW5ncywgdGhpcy5kaXJlY3RpdmVSZWNvcmRzLCB0aGlzLmNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lKTtcclxuICAgICAgICB0aGlzLl9sb2dpYyA9IG5ldyBjb2RlZ2VuX2xvZ2ljX3V0aWxfMS5Db2RlZ2VuTG9naWNVdGlsKHRoaXMuX25hbWVzLCB0aGlzLmNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lLCB0aGlzLmNoYW5nZURldGVjdGlvblN0cmF0ZWd5KTtcclxuICAgICAgICB0aGlzLnR5cGVOYW1lID0gY29kZWdlbl9uYW1lX3V0aWxfMS5zYW5pdGl6ZU5hbWUoXCJDaGFuZ2VEZXRlY3Rvcl9cIiArIHRoaXMuaWQpO1xyXG4gICAgfVxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5U291cmNlID0gXCJcXG4gICAgICBcIiArIHRoaXMuZ2VuZXJhdGVTb3VyY2UoKSArIFwiXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRpc3BhdGNoZXIpIHtcXG4gICAgICAgIHJldHVybiBuZXcgXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIoZGlzcGF0Y2hlcik7XFxuICAgICAgfVxcbiAgICBcIjtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHRoaXMuYWJzdHJhY3RDaGFuZ2VEZXRlY3RvclZhck5hbWUsIHRoaXMuY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWUsIGZhY3RvcnlTb3VyY2UpKGFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvcl8xLkFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IsIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwpO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIHZhciBcIiArIHRoaXMudHlwZU5hbWUgKyBcIiA9IGZ1bmN0aW9uIFwiICsgdGhpcy50eXBlTmFtZSArIFwiKGRpc3BhdGNoZXIpIHtcXG4gICAgICAgIFwiICsgdGhpcy5hYnN0cmFjdENoYW5nZURldGVjdG9yVmFyTmFtZSArIFwiLmNhbGwoXFxuICAgICAgICAgICAgdGhpcywgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiLCBkaXNwYXRjaGVyLCBcIiArIHRoaXMucmVjb3Jkcy5sZW5ndGggKyBcIixcXG4gICAgICAgICAgICBcIiArIHRoaXMudHlwZU5hbWUgKyBcIi5nZW5fcHJvcGVydHlCaW5kaW5nVGFyZ2V0cywgXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIuZ2VuX2RpcmVjdGl2ZUluZGljZXMsXFxuICAgICAgICAgICAgXCIgKyBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeSh0aGlzLmNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSArIFwiKTtcXG4gICAgICAgIHRoaXMuZGVoeWRyYXRlRGlyZWN0aXZlcyhmYWxzZSk7XFxuICAgICAgfVxcblxcbiAgICAgIFwiICsgdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXCIgKyB0aGlzLmFic3RyYWN0Q2hhbmdlRGV0ZWN0b3JWYXJOYW1lICsgXCIucHJvdG90eXBlKTtcXG5cXG4gICAgICBcIiArIHRoaXMudHlwZU5hbWUgKyBcIi5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsID0gZnVuY3Rpb24odGhyb3dPbkNoYW5nZSkge1xcbiAgICAgICAgXCIgKyB0aGlzLl9uYW1lcy5nZW5Jbml0TG9jYWxzKCkgKyBcIlxcbiAgICAgICAgdmFyIFwiICsgSVNfQ0hBTkdFRF9MT0NBTCArIFwiID0gZmFsc2U7XFxuICAgICAgICB2YXIgXCIgKyBDSEFOR0VTX0xPQ0FMICsgXCIgPSBudWxsO1xcblxcbiAgICAgICAgXCIgKyB0aGlzLnJlY29yZHMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy5fZ2VuUmVjb3JkKHIpOyB9KS5qb2luKFwiXFxuXCIpICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgXCIgKyB0aGlzLl9tYXliZUdlbkhhbmRsZUV2ZW50SW50ZXJuYWwoKSArIFwiXFxuXFxuICAgICAgXCIgKyB0aGlzLl9nZW5DaGVja05vQ2hhbmdlcygpICsgXCJcXG5cXG4gICAgICBcIiArIHRoaXMuX21heWJlR2VuQWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzKCkgKyBcIlxcblxcbiAgICAgIFwiICsgdGhpcy5fbWF5YmVHZW5BZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoKSArIFwiXFxuXFxuICAgICAgXCIgKyB0aGlzLl9tYXliZUdlbkh5ZHJhdGVEaXJlY3RpdmVzKCkgKyBcIlxcblxcbiAgICAgIFwiICsgdGhpcy5fbWF5YmVHZW5EZWh5ZHJhdGVEaXJlY3RpdmVzKCkgKyBcIlxcblxcbiAgICAgIFwiICsgdGhpcy5fZ2VuUHJvcGVydHlCaW5kaW5nVGFyZ2V0cygpICsgXCJcXG5cXG4gICAgICBcIiArIHRoaXMuX2dlbkRpcmVjdGl2ZUluZGljZXMoKSArIFwiXFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuUHJvcGVydHlCaW5kaW5nVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuX2xvZ2ljLmdlblByb3BlcnR5QmluZGluZ1RhcmdldHModGhpcy5wcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCB0aGlzLmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lICsgXCIuZ2VuX3Byb3BlcnR5QmluZGluZ1RhcmdldHMgPSBcIiArIHRhcmdldHMgKyBcIjtcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkRpcmVjdGl2ZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLl9sb2dpYy5nZW5EaXJlY3RpdmVJbmRpY2VzKHRoaXMuZGlyZWN0aXZlUmVjb3Jkcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU5hbWUgKyBcIi5nZW5fZGlyZWN0aXZlSW5kaWNlcyA9IFwiICsgaW5kaWNlcyArIFwiO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVHZW5IYW5kbGVFdmVudEludGVybmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRCaW5kaW5ncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuZXZlbnRCaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGViKSB7IHJldHVybiBfdGhpcy5fZ2VuRXZlbnRCaW5kaW5nKGViKTsgfSkuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIHRoaXMudHlwZU5hbWUgKyBcIi5wcm90b3R5cGUuaGFuZGxlRXZlbnRJbnRlcm5hbCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZWxJbmRleCwgbG9jYWxzKSB7XFxuICAgICAgICAgIHZhciBcIiArIHRoaXMuX25hbWVzLmdldFByZXZlbnREZWZhdWx0QWNjZXNvcigpICsgXCIgPSBmYWxzZTtcXG4gICAgICAgICAgXCIgKyB0aGlzLl9uYW1lcy5nZW5Jbml0RXZlbnRMb2NhbHMoKSArIFwiXFxuICAgICAgICAgIFwiICsgaGFuZGxlcnMgKyBcIlxcbiAgICAgICAgICByZXR1cm4gXCIgKyB0aGlzLl9uYW1lcy5nZXRQcmV2ZW50RGVmYXVsdEFjY2Vzb3IoKSArIFwiO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkV2ZW50QmluZGluZyA9IGZ1bmN0aW9uIChlYikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlY3MgPSBlYi5yZWNvcmRzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMuX2dlbkV2ZW50QmluZGluZ0V2YWwoZWIsIHIpOyB9KS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICBpZiAoZXZlbnROYW1lID09PSBcXFwiXCIgKyBlYi5ldmVudE5hbWUgKyBcIlxcXCIgJiYgZWxJbmRleCA9PT0gXCIgKyBlYi5lbEluZGV4ICsgXCIpIHtcXG4gICAgICBcIiArIHJlY3MgKyBcIlxcbiAgICB9XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5FdmVudEJpbmRpbmdFdmFsID0gZnVuY3Rpb24gKGViLCByKSB7XHJcbiAgICAgICAgaWYgKHIubGFzdEluQmluZGluZykge1xyXG4gICAgICAgICAgICB2YXIgZXZhbFJlY29yZCA9IHRoaXMuX2xvZ2ljLmdlbkV2ZW50QmluZGluZ0V2YWxWYWx1ZShlYiwgcik7XHJcbiAgICAgICAgICAgIHZhciBtYXJrUGF0aCA9IHRoaXMuX2dlbk1hcmtQYXRoVG9Sb290QXNDaGVja09uY2Uocik7XHJcbiAgICAgICAgICAgIHZhciBwcmV2RGVmYXVsdCA9IHRoaXMuX2dlblVwZGF0ZVByZXZlbnREZWZhdWx0KGViLCByKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2YWxSZWNvcmQgKyBcIlxcblwiICsgbWFya1BhdGggKyBcIlxcblwiICsgcHJldkRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9naWMuZ2VuRXZlbnRCaW5kaW5nRXZhbFZhbHVlKGViLCByKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5NYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgYnIgPSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgaWYgKGJyLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzLmdldERldGVjdG9yTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpO1wiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlblVwZGF0ZVByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGViLCByKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5fbmFtZXMuZ2V0RXZlbnRMb2NhbE5hbWUoZWIsIHIuc2VsZkluZGV4KTtcclxuICAgICAgICByZXR1cm4gXCJpZiAoXCIgKyBsb2NhbCArIFwiID09PSBmYWxzZSkgeyBcIiArIHRoaXMuX25hbWVzLmdldFByZXZlbnREZWZhdWx0QWNjZXNvcigpICsgXCIgPSB0cnVlfTtcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX21heWJlR2VuRGVoeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVzdHJveVBpcGVzQ29kZSA9IHRoaXMuX25hbWVzLmdlblBpcGVPbkRlc3Ryb3koKTtcclxuICAgICAgICBpZiAoZGVzdHJveVBpcGVzQ29kZSkge1xyXG4gICAgICAgICAgICBkZXN0cm95UGlwZXNDb2RlID0gXCJpZiAoZGVzdHJveVBpcGVzKSB7IFwiICsgZGVzdHJveVBpcGVzQ29kZSArIFwiIH1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlaHlkcmF0ZUZpZWxkc0NvZGUgPSB0aGlzLl9uYW1lcy5nZW5EZWh5ZHJhdGVGaWVsZHMoKTtcclxuICAgICAgICBpZiAoIWRlc3Ryb3lQaXBlc0NvZGUgJiYgIWRlaHlkcmF0ZUZpZWxkc0NvZGUpXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5kZWh5ZHJhdGVEaXJlY3RpdmVzID0gZnVuY3Rpb24oZGVzdHJveVBpcGVzKSB7XFxuICAgICAgICBcIiArIGRlc3Ryb3lQaXBlc0NvZGUgKyBcIlxcbiAgICAgICAgXCIgKyBkZWh5ZHJhdGVGaWVsZHNDb2RlICsgXCJcXG4gICAgfVwiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVHZW5IeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHlkcmF0ZURpcmVjdGl2ZXNDb2RlID0gdGhpcy5fbG9naWMuZ2VuSHlkcmF0ZURpcmVjdGl2ZXModGhpcy5kaXJlY3RpdmVSZWNvcmRzKTtcclxuICAgICAgICB2YXIgaHlkcmF0ZURldGVjdG9yc0NvZGUgPSB0aGlzLl9sb2dpYy5nZW5IeWRyYXRlRGV0ZWN0b3JzKHRoaXMuZGlyZWN0aXZlUmVjb3Jkcyk7XHJcbiAgICAgICAgaWYgKCFoeWRyYXRlRGlyZWN0aXZlc0NvZGUgJiYgIWh5ZHJhdGVEZXRlY3RvcnNDb2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU5hbWUgKyBcIi5wcm90b3R5cGUuaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbihkaXJlY3RpdmVzKSB7XFxuICAgICAgXCIgKyBoeWRyYXRlRGlyZWN0aXZlc0NvZGUgKyBcIlxcbiAgICAgIFwiICsgaHlkcmF0ZURldGVjdG9yc0NvZGUgKyBcIlxcbiAgICB9XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9tYXliZUdlbkFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm90aWZpY2F0aW9ucyA9IHRoaXMuX2xvZ2ljLmdlbkNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3ModGhpcy5kaXJlY3RpdmVSZWNvcmRzKTtcclxuICAgICAgICBpZiAobm90aWZpY2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVOb3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9ucy5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIFwiICsgdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NJbnRlcm5hbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBcIiArIGRpcmVjdGl2ZU5vdGlmaWNhdGlvbnMgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX21heWJlR2VuQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25zID0gdGhpcy5fbG9naWMuZ2VuVmlld0xpZmVjeWNsZUNhbGxiYWNrcyh0aGlzLmRpcmVjdGl2ZVJlY29yZHMpO1xyXG4gICAgICAgIGlmIChub3RpZmljYXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIucHJvdG90eXBlLmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIFwiICsgZGlyZWN0aXZlTm90aWZpY2F0aW9ucyArIFwiXFxuICAgICAgICB9XFxuICAgICAgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuUmVjb3JkID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgcmVjO1xyXG4gICAgICAgIGlmIChyLmlzTGlmZUN5Y2xlUmVjb3JkKCkpIHtcclxuICAgICAgICAgICAgcmVjID0gdGhpcy5fZ2VuRGlyZWN0aXZlTGlmZWN5Y2xlKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyLmlzUGlwZVJlY29yZCgpKSB7XHJcbiAgICAgICAgICAgIHJlYyA9IHRoaXMuX2dlblBpcGVDaGVjayhyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlYyA9IHRoaXMuX2dlblJlZmVyZW5jZUNoZWNrKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIHRoaXMuX21heWJlRmlyc3RJbkJpbmRpbmcocikgKyBcIlxcbiAgICAgIFwiICsgcmVjICsgXCJcXG4gICAgICBcIiArIHRoaXMuX21heWJlR2VuTGFzdEluRGlyZWN0aXZlKHIpICsgXCJcXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5EaXJlY3RpdmVMaWZlY3ljbGUgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIGlmIChyLm5hbWUgPT09IFwiRG9DaGVja1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5PbkNoZWNrKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyLm5hbWUgPT09IFwiT25Jbml0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbk9uSW5pdChyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoci5uYW1lID09PSBcIk9uQ2hhbmdlc1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5PbkNoYW5nZShyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gbGlmZWN5Y2xlIGV2ZW50ICdcIiArIHIubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5QaXBlQ2hlY2sgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoci5jb250ZXh0SW5kZXgpO1xyXG4gICAgICAgIHZhciBhcmdTdHJpbmcgPSByLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIF90aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoYXJnKTsgfSkuam9pbihcIiwgXCIpO1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX25hbWVzLmdldEZpZWxkTmFtZShyLnNlbGZJbmRleCk7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0TG9jYWxOYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgcGlwZSA9IHRoaXMuX25hbWVzLmdldFBpcGVOYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgcGlwZU5hbWUgPSByLm5hbWU7XHJcbiAgICAgICAgdmFyIGluaXQgPSBcIlxcbiAgICAgIGlmIChcIiArIHBpcGUgKyBcIiA9PT0gXCIgKyB0aGlzLmNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lICsgXCIudW5pbml0aWFsaXplZCkge1xcbiAgICAgICAgXCIgKyBwaXBlICsgXCIgPSBcIiArIHRoaXMuX25hbWVzLmdldFBpcGVzQWNjZXNzb3JOYW1lKCkgKyBcIi5nZXQoJ1wiICsgcGlwZU5hbWUgKyBcIicpO1xcbiAgICAgIH1cXG4gICAgXCI7XHJcbiAgICAgICAgdmFyIHJlYWQgPSBuZXdWYWx1ZSArIFwiID0gXCIgKyBwaXBlICsgXCIucGlwZS50cmFuc2Zvcm0oXCIgKyBjb250ZXh0ICsgXCIsIFtcIiArIGFyZ1N0cmluZyArIFwiXSk7XCI7XHJcbiAgICAgICAgdmFyIGNvbnRleE9yQXJnQ2hlY2sgPSByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGhpcy5fbmFtZXMuZ2V0Q2hhbmdlTmFtZShhKTsgfSk7XHJcbiAgICAgICAgY29udGV4T3JBcmdDaGVjay5wdXNoKHRoaXMuX25hbWVzLmdldENoYW5nZU5hbWUoci5jb250ZXh0SW5kZXgpKTtcclxuICAgICAgICB2YXIgY29uZGl0aW9uID0gXCIhXCIgKyBwaXBlICsgXCIucHVyZSB8fCAoXCIgKyBjb250ZXhPckFyZ0NoZWNrLmpvaW4oXCIgfHwgXCIpICsgXCIpXCI7XHJcbiAgICAgICAgdmFyIGNoZWNrID0gXCJcXG4gICAgICBpZiAoXCIgKyBvbGRWYWx1ZSArIFwiICE9PSBcIiArIG5ld1ZhbHVlICsgXCIpIHtcXG4gICAgICAgIFwiICsgbmV3VmFsdWUgKyBcIiA9IFwiICsgdGhpcy5jaGFuZ2VEZXRlY3Rpb25VdGlsVmFyTmFtZSArIFwiLnVud3JhcFZhbHVlKFwiICsgbmV3VmFsdWUgKyBcIilcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuQ2hhbmdlTWFya2VyKHIpICsgXCJcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuVXBkYXRlRGlyZWN0aXZlT3JFbGVtZW50KHIpICsgXCJcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuQWRkVG9DaGFuZ2VzKHIpICsgXCJcXG4gICAgICAgIFwiICsgb2xkVmFsdWUgKyBcIiA9IFwiICsgbmV3VmFsdWUgKyBcIjtcXG4gICAgICB9XFxuICAgIFwiO1xyXG4gICAgICAgIHZhciBnZW5Db2RlID0gci5zaG91bGRCZUNoZWNrZWQoKSA/IFwiXCIgKyByZWFkICsgY2hlY2sgOiByZWFkO1xyXG4gICAgICAgIGlmIChyLmlzVXNlZEJ5T3RoZXJSZWNvcmQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5pdCArIFwiIGlmIChcIiArIGNvbmRpdGlvbiArIFwiKSB7IFwiICsgZ2VuQ29kZSArIFwiIH0gZWxzZSB7IFwiICsgbmV3VmFsdWUgKyBcIiA9IFwiICsgb2xkVmFsdWUgKyBcIjsgfVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluaXQgKyBcIiBpZiAoXCIgKyBjb25kaXRpb24gKyBcIikgeyBcIiArIGdlbkNvZGUgKyBcIiB9XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuUmVmZXJlbmNlQ2hlY2sgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0RmllbGROYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciByZWFkID0gXCJcXG4gICAgICBcIiArIHRoaXMuX2xvZ2ljLmdlblByb3BlcnR5QmluZGluZ0V2YWxWYWx1ZShyKSArIFwiXFxuICAgIFwiO1xyXG4gICAgICAgIHZhciBjaGVjayA9IFwiXFxuICAgICAgaWYgKFwiICsgbmV3VmFsdWUgKyBcIiAhPT0gXCIgKyBvbGRWYWx1ZSArIFwiKSB7XFxuICAgICAgICBcIiArIHRoaXMuX2dlbkNoYW5nZU1hcmtlcihyKSArIFwiXFxuICAgICAgICBcIiArIHRoaXMuX2dlblVwZGF0ZURpcmVjdGl2ZU9yRWxlbWVudChyKSArIFwiXFxuICAgICAgICBcIiArIHRoaXMuX2dlbkFkZFRvQ2hhbmdlcyhyKSArIFwiXFxuICAgICAgICBcIiArIG9sZFZhbHVlICsgXCIgPSBcIiArIG5ld1ZhbHVlICsgXCI7XFxuICAgICAgfVxcbiAgICBcIjtcclxuICAgICAgICB2YXIgZ2VuQ29kZSA9IHIuc2hvdWxkQmVDaGVja2VkKCkgPyBcIlwiICsgcmVhZCArIGNoZWNrIDogcmVhZDtcclxuICAgICAgICBpZiAoci5pc1B1cmVGdW5jdGlvbigpKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGhpcy5fbmFtZXMuZ2V0Q2hhbmdlTmFtZShhKTsgfSkuam9pbihcIiB8fCBcIik7XHJcbiAgICAgICAgICAgIGlmIChyLmlzVXNlZEJ5T3RoZXJSZWNvcmQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaWYgKFwiICsgY29uZGl0aW9uICsgXCIpIHsgXCIgKyBnZW5Db2RlICsgXCIgfSBlbHNlIHsgXCIgKyBuZXdWYWx1ZSArIFwiID0gXCIgKyBvbGRWYWx1ZSArIFwiOyB9XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpZiAoXCIgKyBjb25kaXRpb24gKyBcIikgeyBcIiArIGdlbkNvZGUgKyBcIiB9XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZW5Db2RlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkNoYW5nZU1hcmtlciA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgcmV0dXJuIHIuYXJndW1lbnRUb1B1cmVGdW5jdGlvbiA/IHRoaXMuX25hbWVzLmdldENoYW5nZU5hbWUoci5zZWxmSW5kZXgpICsgXCIgPSB0cnVlXCIgOiBcIlwiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuVXBkYXRlRGlyZWN0aXZlT3JFbGVtZW50ID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICBpZiAoIXIubGFzdEluQmluZGluZylcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0TG9jYWxOYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRGaWVsZE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciBub3RpZnlEZWJ1ZyA9IHRoaXMuZ2VuQ29uZmlnLmxvZ0JpbmRpbmdVcGRhdGUgPyBcInRoaXMubG9nQmluZGluZ1VwZGF0ZShcIiArIG5ld1ZhbHVlICsgXCIpO1wiIDogXCJcIjtcclxuICAgICAgICB2YXIgYnIgPSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgaWYgKGJyLnRhcmdldC5pc0RpcmVjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVQcm9wZXJ0eSA9IHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoYnIuZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4KSArIFwiLlwiICsgYnIudGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyB0aGlzLl9nZW5UaHJvd09uQ2hhbmdlQ2hlY2sob2xkVmFsdWUsIG5ld1ZhbHVlKSArIFwiXFxuICAgICAgICBcIiArIGRpcmVjdGl2ZVByb3BlcnR5ICsgXCIgPSBcIiArIG5ld1ZhbHVlICsgXCI7XFxuICAgICAgICBcIiArIG5vdGlmeURlYnVnICsgXCJcXG4gICAgICAgIFwiICsgSVNfQ0hBTkdFRF9MT0NBTCArIFwiID0gdHJ1ZTtcXG4gICAgICBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyB0aGlzLl9nZW5UaHJvd09uQ2hhbmdlQ2hlY2sob2xkVmFsdWUsIG5ld1ZhbHVlKSArIFwiXFxuICAgICAgICB0aGlzLm5vdGlmeURpc3BhdGNoZXIoXCIgKyBuZXdWYWx1ZSArIFwiKTtcXG4gICAgICAgIFwiICsgbm90aWZ5RGVidWcgKyBcIlxcbiAgICAgIFwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlblRocm93T25DaGFuZ2VDaGVjayA9IGZ1bmN0aW9uIChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5nZW5Db25maWcuZ2VuQ2hlY2tOb0NoYW5nZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBpZih0aHJvd09uQ2hhbmdlKSB7XFxuICAgICAgICAgIHRoaXMudGhyb3dPbkNoYW5nZUVycm9yKFwiICsgb2xkVmFsdWUgKyBcIiwgXCIgKyBuZXdWYWx1ZSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdlbkNvbmZpZy5nZW5DaGVja05vQ2hhbmdlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5jaGVja05vQ2hhbmdlcyA9IGZ1bmN0aW9uKCkgeyB0aGlzLnJ1bkRldGVjdENoYW5nZXModHJ1ZSk7IH1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5BZGRUb0NoYW5nZXMgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuX25hbWVzLmdldExvY2FsTmFtZShyLnNlbGZJbmRleCk7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0RmllbGROYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICBpZiAoIXIuYmluZGluZ1JlY29yZC5jYWxsT25DaGFuZ2VzKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHJldHVybiBDSEFOR0VTX0xPQ0FMICsgXCIgPSB0aGlzLmFkZENoYW5nZShcIiArIENIQU5HRVNfTE9DQUwgKyBcIiwgXCIgKyBvbGRWYWx1ZSArIFwiLCBcIiArIG5ld1ZhbHVlICsgXCIpO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVGaXJzdEluQmluZGluZyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIHByZXYgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLnByb3RvQnlJbmRleCh0aGlzLnJlY29yZHMsIHIuc2VsZkluZGV4IC0gMSk7XHJcbiAgICAgICAgdmFyIGZpcnN0SW5CaW5kbmcgPSBsYW5nXzEuaXNCbGFuayhwcmV2KSB8fCBwcmV2LmJpbmRpbmdSZWNvcmQgIT09IHIuYmluZGluZ1JlY29yZDtcclxuICAgICAgICByZXR1cm4gZmlyc3RJbkJpbmRuZyAmJiAhci5iaW5kaW5nUmVjb3JkLmlzRGlyZWN0aXZlTGlmZWN5Y2xlKCkgP1xyXG4gICAgICAgICAgICB0aGlzLl9uYW1lcy5nZXRQcm9wZXJ0eUJpbmRpbmdJbmRleCgpICsgXCIgPSBcIiArIHIucHJvcGVydHlCaW5kaW5nSW5kZXggKyBcIjtcIiA6XHJcbiAgICAgICAgICAgICcnO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVHZW5MYXN0SW5EaXJlY3RpdmUgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIGlmICghci5sYXN0SW5EaXJlY3RpdmUpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgQ0hBTkdFU19MT0NBTCArIFwiID0gbnVsbDtcXG4gICAgICBcIiArIHRoaXMuX2dlbk5vdGlmeU9uUHVzaERldGVjdG9ycyhyKSArIFwiXFxuICAgICAgXCIgKyBJU19DSEFOR0VEX0xPQ0FMICsgXCIgPSBmYWxzZTtcXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5PbkNoZWNrID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgYnIgPSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgcmV0dXJuIFwiaWYgKCF0aHJvd09uQ2hhbmdlKSBcIiArIHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoYnIuZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4KSArIFwiLmRvQ2hlY2soKTtcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbk9uSW5pdCA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIGJyID0gci5iaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgIHJldHVybiBcImlmICghdGhyb3dPbkNoYW5nZSAmJiAhXCIgKyB0aGlzLl9uYW1lcy5nZXRBbHJlYWR5Q2hlY2tlZE5hbWUoKSArIFwiKSBcIiArIHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoYnIuZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4KSArIFwiLm9uSW5pdCgpO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuT25DaGFuZ2UgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBiciA9IHIuYmluZGluZ1JlY29yZDtcclxuICAgICAgICByZXR1cm4gXCJpZiAoIXRocm93T25DaGFuZ2UgJiYgXCIgKyBDSEFOR0VTX0xPQ0FMICsgXCIpIFwiICsgdGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIub25DaGFuZ2VzKFwiICsgQ0hBTkdFU19MT0NBTCArIFwiKTtcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbk5vdGlmeU9uUHVzaERldGVjdG9ycyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIGJyID0gci5iaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgIGlmICghci5sYXN0SW5EaXJlY3RpdmUgfHwgYnIuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHZhciByZXRWYWwgPSBcIlxcbiAgICAgIGlmKFwiICsgSVNfQ0hBTkdFRF9MT0NBTCArIFwiKSB7XFxuICAgICAgICBcIiArIHRoaXMuX25hbWVzLmdldERldGVjdG9yTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIubWFya0FzQ2hlY2tPbmNlKCk7XFxuICAgICAgfVxcbiAgICBcIjtcclxuICAgICAgICByZXR1cm4gcmV0VmFsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvcjtcclxufSkoKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvciA9IENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBwaXBlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vcGlwZV9saWZlY3ljbGVfcmVmbGVjdG9yJyk7XHJcbnZhciBiaW5kaW5nX3JlY29yZF8xID0gcmVxdWlyZSgnLi9iaW5kaW5nX3JlY29yZCcpO1xyXG52YXIgZGlyZWN0aXZlX3JlY29yZF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfcmVjb3JkJyk7XHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVzdWx0IG9mIGEge0BsaW5rIFBpcGVNZXRhZGF0YX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXHJcbiAqIHJlZmVyZW5jZVxyXG4gKiBoYXMgbm90IGNoYW5nZWQuXHJcbiAqXHJcbiAqIFRoZSB3cmFwcGVkIHZhbHVlIHdpbGwgYmUgdW53cmFwcGVkIGJ5IGNoYW5nZSBkZXRlY3Rpb24sIGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlIHdpbGwgYmUgc3RvcmVkLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XHJcbiAqICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xyXG4gKiAgfSBlbHNlIHtcclxuICogICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xyXG4gKiAgICByZXR1cm4gV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpOyAvLyB0aGlzIHdpbGwgZm9yY2UgdXBkYXRlXHJcbiAqICB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFdyYXBwZWRWYWx1ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXcmFwcGVkVmFsdWUod3JhcHBlZCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZCA9IHdyYXBwZWQ7XHJcbiAgICB9XHJcbiAgICBXcmFwcGVkVmFsdWUud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciB3ID0gX3dyYXBwZWRWYWx1ZXNbX3dyYXBwZWRJbmRleCsrICUgNV07XHJcbiAgICAgICAgdy53cmFwcGVkID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHc7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdyYXBwZWRWYWx1ZTtcclxufSkoKTtcclxuZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBXcmFwcGVkVmFsdWU7XHJcbnZhciBfd3JhcHBlZFZhbHVlcyA9IFtcclxuICAgIG5ldyBXcmFwcGVkVmFsdWUobnVsbCksXHJcbiAgICBuZXcgV3JhcHBlZFZhbHVlKG51bGwpLFxyXG4gICAgbmV3IFdyYXBwZWRWYWx1ZShudWxsKSxcclxuICAgIG5ldyBXcmFwcGVkVmFsdWUobnVsbCksXHJcbiAgICBuZXcgV3JhcHBlZFZhbHVlKG51bGwpXHJcbl07XHJcbnZhciBfd3JhcHBlZEluZGV4ID0gMDtcclxudmFyIFNpbXBsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaW1wbGVDaGFuZ2UocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcclxuICAgIH1cclxuICAgIFNpbXBsZUNoYW5nZS5wcm90b3R5cGUuaXNGaXJzdENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZSA9PT0gQ2hhbmdlRGV0ZWN0aW9uVXRpbC51bmluaXRpYWxpemVkOyB9O1xyXG4gICAgcmV0dXJuIFNpbXBsZUNoYW5nZTtcclxufSkoKTtcclxuZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBTaW1wbGVDaGFuZ2U7XHJcbnZhciBfc2ltcGxlQ2hhbmdlc0luZGV4ID0gMDtcclxudmFyIF9zaW1wbGVDaGFuZ2VzID0gW1xyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbClcclxuXTtcclxuZnVuY3Rpb24gX3NpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcclxuICAgIHZhciBpbmRleCA9IF9zaW1wbGVDaGFuZ2VzSW5kZXgrKyAlIDIwO1xyXG4gICAgdmFyIHMgPSBfc2ltcGxlQ2hhbmdlc1tpbmRleF07XHJcbiAgICBzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xyXG4gICAgcy5jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWU7XHJcbiAgICByZXR1cm4gcztcclxufVxyXG4vKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSAqL1xyXG52YXIgQ2hhbmdlRGV0ZWN0aW9uVXRpbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3Rpb25VdGlsKCkge1xyXG4gICAgfVxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMSA9IGZ1bmN0aW9uIChhMSkgeyByZXR1cm4gW2ExXTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7IHJldHVybiBbYTEsIGEyXTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjMgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykgeyByZXR1cm4gW2ExLCBhMiwgYTNdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNCA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gW2ExLCBhMiwgYTMsIGE0XTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjUgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBbYTEsIGEyLCBhMywgYTQsIGE1XTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjYgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgeyByZXR1cm4gW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTZdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNyA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykgeyByZXR1cm4gW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3XTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjggPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7XHJcbiAgICAgICAgcmV0dXJuIFthMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYThdO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjkgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xyXG4gICAgICAgIHJldHVybiBbYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOV07XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbmVnYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhdmFsdWU7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9hZGQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgKyByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX3N1YnRyYWN0ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0IC0gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9tdWx0aXBseSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAqIHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZGl2aWRlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0IC8gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9yZW1haW5kZXIgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgJSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2VxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA9PSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX25vdF9lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9pZGVudGljYWwgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgPT09IHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbm90X2lkZW50aWNhbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9sZXNzX3RoZW4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgPCByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2dyZWF0ZXJfdGhlbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA+IHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbGVzc19vcl9lcXVhbHNfdGhlbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA8PSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2dyZWF0ZXJfb3JfZXF1YWxzX3RoZW4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9sb2dpY2FsX2FuZCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAmJiByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xvZ2ljYWxfb3IgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmNvbmQgPSBmdW5jdGlvbiAoY29uZCwgdHJ1ZVZhbCwgZmFsc2VWYWwpIHsgcmV0dXJuIGNvbmQgPyB0cnVlVmFsIDogZmFsc2VWYWw7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm1hcEZuID0gZnVuY3Rpb24gKGtleXMpIHtcclxuICAgICAgICBmdW5jdGlvbiBidWlsZE1hcCh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldChyZXMsIGtleXNbaV0sIHZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEpIHsgcmV0dXJuIGJ1aWxkTWFwKFthMV0pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMikgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMl0pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHsgcmV0dXJuIGJ1aWxkTWFwKFthMSwgYTIsIGEzXSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHsgcmV0dXJuIGJ1aWxkTWFwKFthMSwgYTIsIGEzLCBhNF0pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0LCBhNV0pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHsgcmV0dXJuIGJ1aWxkTWFwKFthMSwgYTIsIGEzLCBhNCwgYTUsIGE2XSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHsgcmV0dXJuIGJ1aWxkTWFwKFthMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhN10pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOF0pOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTldKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJEb2VzIG5vdCBzdXBwb3J0IGxpdGVyYWwgbWFwcyB3aXRoIG1vcmUgdGhhbiA5IGVsZW1lbnRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmtleWVkQWNjZXNzID0gZnVuY3Rpb24gKG9iaiwgYXJncykgeyByZXR1cm4gb2JqW2FyZ3NbMF1dOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC51bndyYXBWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUud3JhcHBlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5jaGFuZ2VEZXRlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KHN0cmF0ZWd5KSA/IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzIDpcclxuICAgICAgICAgICAgY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tPbmNlO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuc2ltcGxlQ2hhbmdlID0gZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBfc2ltcGxlQ2hhbmdlKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5pc1ZhbHVlQmxhbmsgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGxhbmdfMS5pc0JsYW5rKHZhbHVlKTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwucyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgPyBcIlwiICsgdmFsdWUgOiAnJzsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwucHJvdG9CeUluZGV4ID0gZnVuY3Rpb24gKHByb3Rvcywgc2VsZkluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGZJbmRleCA8IDEgP1xyXG4gICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgcHJvdG9zW3NlbGZJbmRleCAtIDFdOyAvLyBzZWxmIGluZGV4IGlzIHNoaWZ0ZWQgYnkgb25lIGJlY2F1c2Ugb2YgY29udGV4dFxyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuY2FsbFBpcGVPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc2VsZWN0ZWRQaXBlKSB7XHJcbiAgICAgICAgaWYgKHBpcGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmltcGxlbWVudHNPbkRlc3Ryb3koc2VsZWN0ZWRQaXBlLnBpcGUpKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkUGlwZS5waXBlLm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmJpbmRpbmdUYXJnZXQgPSBmdW5jdGlvbiAobW9kZSwgZWxlbWVudEluZGV4LCBuYW1lLCB1bml0LCBkZWJ1Zykge1xyXG4gICAgICAgIHJldHVybiBuZXcgYmluZGluZ19yZWNvcmRfMS5CaW5kaW5nVGFyZ2V0KG1vZGUsIGVsZW1lbnRJbmRleCwgbmFtZSwgdW5pdCwgZGVidWcpO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuZGlyZWN0aXZlSW5kZXggPSBmdW5jdGlvbiAoZWxlbWVudEluZGV4LCBkaXJlY3RpdmVJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgZGlyZWN0aXZlX3JlY29yZF8xLkRpcmVjdGl2ZUluZGV4KGVsZW1lbnRJbmRleCwgZGlyZWN0aXZlSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwudW5pbml0aWFsaXplZCA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBPYmplY3QoKSk7XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uVXRpbDtcclxufSkoKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25VdGlsID0gQ2hhbmdlRGV0ZWN0aW9uVXRpbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdGlvbl91dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG52YXIgQ2hhbmdlRGV0ZWN0b3JSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JSZWYoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSBDaGFuZ2VEZXRlY3RvclJlZjtcclxudmFyIENoYW5nZURldGVjdG9yUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hhbmdlRGV0ZWN0b3JSZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JSZWZfKF9jZCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NkID0gX2NkO1xyXG4gICAgfVxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWZfLnByb3RvdHlwZS5tYXJrRm9yQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NkLm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UoKTsgfTtcclxuICAgIENoYW5nZURldGVjdG9yUmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jZC5tb2RlID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGV0YWNoZWQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZl8ucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NkLmRldGVjdENoYW5nZXMoKTsgfTtcclxuICAgIENoYW5nZURldGVjdG9yUmVmXy5wcm90b3R5cGUucmVhdHRhY2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY2QubW9kZSA9IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzO1xyXG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdG9yUmVmXztcclxufSkoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9yUmVmXyA9IENoYW5nZURldGVjdG9yUmVmXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdG9yX3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgcHJvdG9fcmVjb3JkXzEgPSByZXF1aXJlKCcuL3Byb3RvX3JlY29yZCcpO1xyXG4vKipcclxuICogUmVtb3ZlcyBcImR1cGxpY2F0ZVwiIHJlY29yZHMuIEl0IGFzc3VtaW5nIHRoYXQgcmVjb3JkIGV2YWx1YXRpb24gZG9lcyBub3RcclxuICogaGF2ZSBzaWRlLWVmZmVjdHMuXHJcbiAqXHJcbiAqIFJlY29yZHMgdGhhdCBhcmUgbm90IGxhc3QgaW4gYmluZGluZ3MgYXJlIHJlbW92ZWQgYW5kIGFsbCB0aGUgaW5kaWNlc1xyXG4gKiBvZiB0aGUgcmVjb3JkcyB0aGF0IGRlcGVuZCBvbiB0aGVtIGFyZSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBSZWNvcmRzIHRoYXQgYXJlIGxhc3QgaW4gYmluZGluZ3MgQ0FOTk9UIGJlIHJlbW92ZWQsIGFuZCBpbnN0ZWFkIGFyZVxyXG4gKiByZXBsYWNlZCB3aXRoIHZlcnkgY2hlYXAgU0VMRiByZWNvcmRzLlxyXG4gKi9cclxuZnVuY3Rpb24gY29hbGVzY2UocmVjb3Jkcykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgdmFyIGluZGV4TWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciByID0gcmVjb3Jkc1tpXTtcclxuICAgICAgICB2YXIgcmVjb3JkID0gX3JlcGxhY2VJbmRpY2VzKHIsIHJlcy5sZW5ndGggKyAxLCBpbmRleE1hcCk7XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nUmVjb3JkID0gX2ZpbmRNYXRjaGluZyhyZWNvcmQsIHJlcyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hpbmdSZWNvcmQpICYmIHJlY29yZC5sYXN0SW5CaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKF9zZWxmUmVjb3JkKHJlY29yZCwgbWF0Y2hpbmdSZWNvcmQuc2VsZkluZGV4LCByZXMubGVuZ3RoICsgMSkpO1xyXG4gICAgICAgICAgICBpbmRleE1hcC5zZXQoci5zZWxmSW5kZXgsIG1hdGNoaW5nUmVjb3JkLnNlbGZJbmRleCk7XHJcbiAgICAgICAgICAgIG1hdGNoaW5nUmVjb3JkLnJlZmVyZW5jZWRCeVNlbGYgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoaW5nUmVjb3JkKSAmJiAhcmVjb3JkLmxhc3RJbkJpbmRpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHJlY29yZC5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1JlY29yZC5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRleE1hcC5zZXQoci5zZWxmSW5kZXgsIG1hdGNoaW5nUmVjb3JkLnNlbGZJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgICAgICBpbmRleE1hcC5zZXQoci5zZWxmSW5kZXgsIHJlY29yZC5zZWxmSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5jb2FsZXNjZSA9IGNvYWxlc2NlO1xyXG5mdW5jdGlvbiBfc2VsZlJlY29yZChyLCBjb250ZXh0SW5kZXgsIHNlbGZJbmRleCkge1xyXG4gICAgcmV0dXJuIG5ldyBwcm90b19yZWNvcmRfMS5Qcm90b1JlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNlbGYsIFwic2VsZlwiLCBudWxsLCBbXSwgci5maXhlZEFyZ3MsIGNvbnRleHRJbmRleCwgci5kaXJlY3RpdmVJbmRleCwgc2VsZkluZGV4LCByLmJpbmRpbmdSZWNvcmQsIHIubGFzdEluQmluZGluZywgci5sYXN0SW5EaXJlY3RpdmUsIGZhbHNlLCBmYWxzZSwgci5wcm9wZXJ0eUJpbmRpbmdJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gX2ZpbmRNYXRjaGluZyhyLCBycykge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maW5kKHJzLCBmdW5jdGlvbiAocnIpIHsgcmV0dXJuIHJyLm1vZGUgIT09IHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuRGlyZWN0aXZlTGlmZWN5Y2xlICYmIF9zYW1lRGlySW5kZXgocnIsIHIpICYmXHJcbiAgICAgICAgcnIubW9kZSA9PT0gci5tb2RlICYmIGxhbmdfMS5sb29zZUlkZW50aWNhbChyci5mdW5jT3JWYWx1ZSwgci5mdW5jT3JWYWx1ZSkgJiZcclxuICAgICAgICByci5jb250ZXh0SW5kZXggPT09IHIuY29udGV4dEluZGV4ICYmIGxhbmdfMS5sb29zZUlkZW50aWNhbChyci5uYW1lLCByLm5hbWUpICYmXHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmVxdWFscyhyci5hcmdzLCByLmFyZ3MpOyB9KTtcclxufVxyXG5mdW5jdGlvbiBfc2FtZURpckluZGV4KGEsIGIpIHtcclxuICAgIHZhciBkaTEgPSBsYW5nXzEuaXNCbGFuayhhLmRpcmVjdGl2ZUluZGV4KSA/IG51bGwgOiBhLmRpcmVjdGl2ZUluZGV4LmRpcmVjdGl2ZUluZGV4O1xyXG4gICAgdmFyIGVpMSA9IGxhbmdfMS5pc0JsYW5rKGEuZGlyZWN0aXZlSW5kZXgpID8gbnVsbCA6IGEuZGlyZWN0aXZlSW5kZXguZWxlbWVudEluZGV4O1xyXG4gICAgdmFyIGRpMiA9IGxhbmdfMS5pc0JsYW5rKGIuZGlyZWN0aXZlSW5kZXgpID8gbnVsbCA6IGIuZGlyZWN0aXZlSW5kZXguZGlyZWN0aXZlSW5kZXg7XHJcbiAgICB2YXIgZWkyID0gbGFuZ18xLmlzQmxhbmsoYi5kaXJlY3RpdmVJbmRleCkgPyBudWxsIDogYi5kaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXg7XHJcbiAgICByZXR1cm4gZGkxID09PSBkaTIgJiYgZWkxID09PSBlaTI7XHJcbn1cclxuZnVuY3Rpb24gX3JlcGxhY2VJbmRpY2VzKHIsIHNlbGZJbmRleCwgaW5kZXhNYXApIHtcclxuICAgIHZhciBhcmdzID0gci5hcmdzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gX21hcChpbmRleE1hcCwgYSk7IH0pO1xyXG4gICAgdmFyIGNvbnRleHRJbmRleCA9IF9tYXAoaW5kZXhNYXAsIHIuY29udGV4dEluZGV4KTtcclxuICAgIHJldHVybiBuZXcgcHJvdG9fcmVjb3JkXzEuUHJvdG9SZWNvcmQoci5tb2RlLCByLm5hbWUsIHIuZnVuY09yVmFsdWUsIGFyZ3MsIHIuZml4ZWRBcmdzLCBjb250ZXh0SW5kZXgsIHIuZGlyZWN0aXZlSW5kZXgsIHNlbGZJbmRleCwgci5iaW5kaW5nUmVjb3JkLCByLmxhc3RJbkJpbmRpbmcsIHIubGFzdEluRGlyZWN0aXZlLCByLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24sIHIucmVmZXJlbmNlZEJ5U2VsZiwgci5wcm9wZXJ0eUJpbmRpbmdJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gX21hcChpbmRleE1hcCwgdmFsdWUpIHtcclxuICAgIHZhciByID0gaW5kZXhNYXAuZ2V0KHZhbHVlKTtcclxuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHIpID8gciA6IHZhbHVlO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvYWxlc2NlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogQ29udmVydHMgYGZ1bmNPclZhbHVlYCB0byBhIHN0cmluZyB3aGljaCBjYW4gYmUgdXNlZCBpbiBnZW5lcmF0ZWQgY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvZGlmeShvYmopIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG59XHJcbmV4cG9ydHMuY29kaWZ5ID0gY29kaWZ5O1xyXG5mdW5jdGlvbiByYXdTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gXCInXCIgKyBzdHIgKyBcIidcIjtcclxufVxyXG5leHBvcnRzLnJhd1N0cmluZyA9IHJhd1N0cmluZztcclxuLyoqXHJcbiAqIENvbWJpbmUgdGhlIHN0cmluZ3Mgb2YgZ2VuZXJhdGVkIGNvZGUgaW50byBhIHNpbmdsZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLlxyXG4gKiBFYWNoIGVsZW1lbnQgb2YgYHZhbHNgIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nIGxpdGVyYWwgb3IgYSBjb2RlZ2VuJ2RcclxuICogY2FsbCB0byBhIG1ldGhvZCByZXR1cm5pbmcgYSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21iaW5lR2VuZXJhdGVkU3RyaW5ncyh2YWxzKSB7XHJcbiAgICByZXR1cm4gdmFscy5qb2luKCcgKyAnKTtcclxufVxyXG5leHBvcnRzLmNvbWJpbmVHZW5lcmF0ZWRTdHJpbmdzID0gY29tYmluZUdlbmVyYXRlZFN0cmluZ3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVnZW5fZmFjYWRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvZGVnZW5fZmFjYWRlXzEgPSByZXF1aXJlKCcuL2NvZGVnZW5fZmFjYWRlJyk7XHJcbnZhciBwcm90b19yZWNvcmRfMSA9IHJlcXVpcmUoJy4vcHJvdG9fcmVjb3JkJyk7XHJcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG4vKipcclxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyBjaGFuZ2UgZGV0ZWN0aW9uIGxvZ2ljIGZvciBjaGFuZ2UgZGV0ZWN0b3IgY2xhc3Nlcy5cclxuICovXHJcbnZhciBDb2RlZ2VuTG9naWNVdGlsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvZGVnZW5Mb2dpY1V0aWwoX25hbWVzLCBfdXRpbE5hbWUsIF9jaGFuZ2VEZXRlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9uYW1lcyA9IF9uYW1lcztcclxuICAgICAgICB0aGlzLl91dGlsTmFtZSA9IF91dGlsTmFtZTtcclxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3Rpb24gPSBfY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBzdGF0ZW1lbnQgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgdmFyaWFibGUgcmVwcmVzZW50aW5nIGBwcm90b1JlY2Agd2l0aCB0aGUgY3VycmVudFxyXG4gICAgICogdmFsdWUgb2YgdGhlIHJlY29yZC4gVXNlZCBieSBwcm9wZXJ0eSBiaW5kaW5ncy5cclxuICAgICAqL1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuZ2VuUHJvcGVydHlCaW5kaW5nRXZhbFZhbHVlID0gZnVuY3Rpb24gKHByb3RvUmVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuRXZhbFZhbHVlKHByb3RvUmVjLCBmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBfdGhpcy5fbmFtZXMuZ2V0TG9jYWxOYW1lKGlkeCk7IH0sIHRoaXMuX25hbWVzLmdldExvY2Fsc0FjY2Vzc29yTmFtZSgpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHN0YXRlbWVudCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCB2YXJpYWJsZSByZXByZXNlbnRpbmcgYHByb3RvUmVjYCB3aXRoIHRoZSBjdXJyZW50XHJcbiAgICAgKiB2YWx1ZSBvZiB0aGUgcmVjb3JkLiBVc2VkIGJ5IGV2ZW50IGJpbmRpbmdzLlxyXG4gICAgICovXHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5FdmVudEJpbmRpbmdFdmFsVmFsdWUgPSBmdW5jdGlvbiAoZXZlbnRSZWNvcmQsIHByb3RvUmVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuRXZhbFZhbHVlKHByb3RvUmVjLCBmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBfdGhpcy5fbmFtZXMuZ2V0RXZlbnRMb2NhbE5hbWUoZXZlbnRSZWNvcmQsIGlkeCk7IH0sIFwibG9jYWxzXCIpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLl9nZW5FdmFsVmFsdWUgPSBmdW5jdGlvbiAocHJvdG9SZWMsIGdldExvY2FsTmFtZSwgbG9jYWxzQWNjZXNzb3IpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IChwcm90b1JlYy5jb250ZXh0SW5kZXggPT0gLTEpID9cclxuICAgICAgICAgICAgdGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShwcm90b1JlYy5kaXJlY3RpdmVJbmRleCkgOlxyXG4gICAgICAgICAgICBnZXRMb2NhbE5hbWUocHJvdG9SZWMuY29udGV4dEluZGV4KTtcclxuICAgICAgICB2YXIgYXJnU3RyaW5nID0gcHJvdG9SZWMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gZ2V0TG9jYWxOYW1lKGFyZyk7IH0pLmpvaW4oXCIsIFwiKTtcclxuICAgICAgICB2YXIgcmhzO1xyXG4gICAgICAgIHN3aXRjaCAocHJvdG9SZWMubW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2VsZjpcclxuICAgICAgICAgICAgICAgIHJocyA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbnN0OlxyXG4gICAgICAgICAgICAgICAgcmhzID0gY29kZWdlbl9mYWNhZGVfMS5jb2RpZnkocHJvdG9SZWMuZnVuY09yVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Qcm9wZXJ0eVJlYWQ6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl9vYnNlcnZlKGNvbnRleHQgKyBcIi5cIiArIHByb3RvUmVjLm5hbWUsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2FmZVByb3BlcnR5OlxyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWQgPSB0aGlzLl9vYnNlcnZlKGNvbnRleHQgKyBcIi5cIiArIHByb3RvUmVjLm5hbWUsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIHJocyA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXRpbE5hbWUgKyBcIi5pc1ZhbHVlQmxhbmsoXCIgKyBjb250ZXh0ICsgXCIpID8gbnVsbCA6IFwiICsgdGhpcy5fb2JzZXJ2ZShyZWFkLCBwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByb3BlcnR5V3JpdGU6XHJcbiAgICAgICAgICAgICAgICByaHMgPSBjb250ZXh0ICsgXCIuXCIgKyBwcm90b1JlYy5uYW1lICsgXCIgPSBcIiArIGdldExvY2FsTmFtZShwcm90b1JlYy5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuTG9jYWw6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl9vYnNlcnZlKGxvY2Fsc0FjY2Vzc29yICsgXCIuZ2V0KFwiICsgY29kZWdlbl9mYWNhZGVfMS5yYXdTdHJpbmcocHJvdG9SZWMubmFtZSkgKyBcIilcIiwgcHJvdG9SZWMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnZva2VNZXRob2Q6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl9vYnNlcnZlKGNvbnRleHQgKyBcIi5cIiArIHByb3RvUmVjLm5hbWUgKyBcIihcIiArIGFyZ1N0cmluZyArIFwiKVwiLCBwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNhZmVNZXRob2RJbnZva2U6XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52b2tlID0gY29udGV4dCArIFwiLlwiICsgcHJvdG9SZWMubmFtZSArIFwiKFwiICsgYXJnU3RyaW5nICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICByaHMgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3V0aWxOYW1lICsgXCIuaXNWYWx1ZUJsYW5rKFwiICsgY29udGV4dCArIFwiKSA/IG51bGwgOiBcIiArIHRoaXMuX29ic2VydmUoaW52b2tlLCBwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludm9rZUNsb3N1cmU6XHJcbiAgICAgICAgICAgICAgICByaHMgPSBjb250ZXh0ICsgXCIoXCIgKyBhcmdTdHJpbmcgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJpbWl0aXZlT3A6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl91dGlsTmFtZSArIFwiLlwiICsgcHJvdG9SZWMubmFtZSArIFwiKFwiICsgYXJnU3RyaW5nICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbGxlY3Rpb25MaXRlcmFsOlxyXG4gICAgICAgICAgICAgICAgcmhzID0gdGhpcy5fdXRpbE5hbWUgKyBcIi5cIiArIHByb3RvUmVjLm5hbWUgKyBcIihcIiArIGFyZ1N0cmluZyArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnRlcnBvbGF0ZTpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX2dlbkludGVycG9sYXRpb24ocHJvdG9SZWMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5LZXllZFJlYWQ6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl9vYnNlcnZlKGNvbnRleHQgKyBcIltcIiArIGdldExvY2FsTmFtZShwcm90b1JlYy5hcmdzWzBdKSArIFwiXVwiLCBwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkV3JpdGU6XHJcbiAgICAgICAgICAgICAgICByaHMgPSBjb250ZXh0ICsgXCJbXCIgKyBnZXRMb2NhbE5hbWUocHJvdG9SZWMuYXJnc1swXSkgKyBcIl0gPSBcIiArIGdldExvY2FsTmFtZShwcm90b1JlYy5hcmdzWzFdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ2hhaW46XHJcbiAgICAgICAgICAgICAgICByaHMgPSAnbnVsbCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gb3BlcmF0aW9uIFwiICsgcHJvdG9SZWMubW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXRMb2NhbE5hbWUocHJvdG9SZWMuc2VsZkluZGV4KSArIFwiID0gXCIgKyByaHMgKyBcIjtcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5fb2JzZXJ2ZSA9IGZ1bmN0aW9uIChleHAsIHJlYykge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlRGV0ZWN0aW9uID09PSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hPYnNlcnZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInRoaXMub2JzZXJ2ZVZhbHVlKFwiICsgZXhwICsgXCIsIFwiICsgcmVjLnNlbGZJbmRleCArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuZ2VuUHJvcGVydHlCaW5kaW5nVGFyZ2V0cyA9IGZ1bmN0aW9uIChwcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCBnZW5EZWJ1Z0luZm8pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBicyA9IHByb3BlcnR5QmluZGluZ1RhcmdldHMubWFwKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcclxuICAgICAgICAgICAgdmFyIGRlYnVnID0gZ2VuRGVidWdJbmZvID8gY29kZWdlbl9mYWNhZGVfMS5jb2RpZnkoYi5kZWJ1ZykgOiBcIm51bGxcIjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91dGlsTmFtZSArIFwiLmJpbmRpbmdUYXJnZXQoXCIgKyBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShiLm1vZGUpICsgXCIsIFwiICsgYi5lbGVtZW50SW5kZXggKyBcIiwgXCIgKyBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShiLm5hbWUpICsgXCIsIFwiICsgY29kZWdlbl9mYWNhZGVfMS5jb2RpZnkoYi51bml0KSArIFwiLCBcIiArIGRlYnVnICsgXCIpXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgYnMuam9pbihcIiwgXCIpICsgXCJdXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuZ2VuRGlyZWN0aXZlSW5kaWNlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYnMgPSBkaXJlY3RpdmVSZWNvcmRzLm1hcChmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLl91dGlsTmFtZSArIFwiLmRpcmVjdGl2ZUluZGV4KFwiICsgYi5kaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXggKyBcIiwgXCIgKyBiLmRpcmVjdGl2ZUluZGV4LmRpcmVjdGl2ZUluZGV4ICsgXCIpXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIGJzLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLl9nZW5JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHByb3RvUmVjKSB7XHJcbiAgICAgICAgdmFyIGlWYWxzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm90b1JlYy5hcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlWYWxzLnB1c2goY29kZWdlbl9mYWNhZGVfMS5jb2RpZnkocHJvdG9SZWMuZml4ZWRBcmdzW2ldKSk7XHJcbiAgICAgICAgICAgIGlWYWxzLnB1c2godGhpcy5fdXRpbE5hbWUgKyBcIi5zKFwiICsgdGhpcy5fbmFtZXMuZ2V0TG9jYWxOYW1lKHByb3RvUmVjLmFyZ3NbaV0pICsgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpVmFscy5wdXNoKGNvZGVnZW5fZmFjYWRlXzEuY29kaWZ5KHByb3RvUmVjLmZpeGVkQXJnc1twcm90b1JlYy5hcmdzLmxlbmd0aF0pKTtcclxuICAgICAgICByZXR1cm4gY29kZWdlbl9mYWNhZGVfMS5jb21iaW5lR2VuZXJhdGVkU3RyaW5ncyhpVmFscyk7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuZ2VuSHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3Jkcykge1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZVJlY29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBkaXJlY3RpdmVSZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICByZXMucHVzaCh0aGlzLl9uYW1lcy5nZXREaXJlY3RpdmVOYW1lKHIuZGlyZWN0aXZlSW5kZXgpICsgXCIgPSBcIiArIHRoaXMuX2dlblJlYWREaXJlY3RpdmUoaSkgKyBcIjtcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5fZ2VuUmVhZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlRGV0ZWN0aW9uID09PSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hPYnNlcnZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInRoaXMub2JzZXJ2ZURpcmVjdGl2ZSh0aGlzLmdldERpcmVjdGl2ZUZvcihkaXJlY3RpdmVzLCBcIiArIGluZGV4ICsgXCIpLCBcIiArIGluZGV4ICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ0aGlzLmdldERpcmVjdGl2ZUZvcihkaXJlY3RpdmVzLCBcIiArIGluZGV4ICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLmdlbkh5ZHJhdGVEZXRlY3RvcnMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3Jkcykge1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZVJlY29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBkaXJlY3RpdmVSZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXIuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX25hbWVzLmdldERldGVjdG9yTmFtZShyLmRpcmVjdGl2ZUluZGV4KSArIFwiID0gdGhpcy5nZXREZXRlY3RvckZvcihkaXJlY3RpdmVzLCBcIiArIGkgKyBcIik7XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5Db250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVJlY29yZHMpIHtcclxuICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgLy8gTk9URShrZWdsdW5lcSk6IE9yZGVyIGlzIGltcG9ydGFudCFcclxuICAgICAgICBmb3IgKHZhciBpID0gZGlyZWN0aXZlUmVjb3Jkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyZWN0aXZlUmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJDb250ZW50SW5pdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goXCJpZighIFwiICsgdGhpcy5fbmFtZXMuZ2V0QWxyZWFkeUNoZWNrZWROYW1lKCkgKyBcIikgXCIgKyB0aGlzLl9uYW1lcy5nZXREaXJlY3RpdmVOYW1lKGRpci5kaXJlY3RpdmVJbmRleCkgKyBcIi5hZnRlckNvbnRlbnRJbml0KCk7XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyQ29udGVudENoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoZGlyLmRpcmVjdGl2ZUluZGV4KSArIFwiLmFmdGVyQ29udGVudENoZWNrZWQoKTtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5WaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVJlY29yZHMpIHtcclxuICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgLy8gTk9URShrZWdsdW5lcSk6IE9yZGVyIGlzIGltcG9ydGFudCFcclxuICAgICAgICBmb3IgKHZhciBpID0gZGlyZWN0aXZlUmVjb3Jkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyZWN0aXZlUmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJWaWV3SW5pdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goXCJpZighIFwiICsgdGhpcy5fbmFtZXMuZ2V0QWxyZWFkeUNoZWNrZWROYW1lKCkgKyBcIikgXCIgKyB0aGlzLl9uYW1lcy5nZXREaXJlY3RpdmVOYW1lKGRpci5kaXJlY3RpdmVJbmRleCkgKyBcIi5hZnRlclZpZXdJbml0KCk7XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyVmlld0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoZGlyLmRpcmVjdGl2ZUluZGV4KSArIFwiLmFmdGVyVmlld0NoZWNrZWQoKTtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29kZWdlbkxvZ2ljVXRpbDtcclxufSkoKTtcclxuZXhwb3J0cy5Db2RlZ2VuTG9naWNVdGlsID0gQ29kZWdlbkxvZ2ljVXRpbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWdlbl9sb2dpY191dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbi8vIFRoZSBuYW1lcyBvZiB0aGVzZSBmaWVsZHMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBhYnN0cmFjdF9jaGFuZ2VfZGV0ZWN0b3IudHMgb3IgY2hhbmdlXHJcbi8vIGRldGVjdGlvbiB3aWxsIGZhaWwuXHJcbnZhciBfQUxSRUFEWV9DSEVDS0VEX0FDQ0VTU09SID0gXCJhbHJlYWR5Q2hlY2tlZFwiO1xyXG52YXIgX0NPTlRFWFRfQUNDRVNTT1IgPSBcImNvbnRleHRcIjtcclxudmFyIF9QUk9QX0JJTkRJTkdfSU5ERVggPSBcInByb3BlcnR5QmluZGluZ0luZGV4XCI7XHJcbnZhciBfRElSRUNUSVZFU19BQ0NFU1NPUiA9IFwiZGlyZWN0aXZlSW5kaWNlc1wiO1xyXG52YXIgX0RJU1BBVENIRVJfQUNDRVNTT1IgPSBcImRpc3BhdGNoZXJcIjtcclxudmFyIF9MT0NBTFNfQUNDRVNTT1IgPSBcImxvY2Fsc1wiO1xyXG52YXIgX01PREVfQUNDRVNTT1IgPSBcIm1vZGVcIjtcclxudmFyIF9QSVBFU19BQ0NFU1NPUiA9IFwicGlwZXNcIjtcclxudmFyIF9QUk9UT1NfQUNDRVNTT1IgPSBcInByb3Rvc1wiO1xyXG4vLyBgY29udGV4dGAgaXMgYWx3YXlzIGZpcnN0LlxyXG5leHBvcnRzLkNPTlRFWFRfSU5ERVggPSAwO1xyXG52YXIgX0ZJRUxEX1BSRUZJWCA9ICd0aGlzLic7XHJcbnZhciBfd2hpdGVTcGFjZVJlZ0V4cCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZShcIlxcXFxXXCIsIFwiZ1wiKTtcclxuLyoqXHJcbiAqIFJldHVybnMgYHNgIHdpdGggYWxsIG5vbi1pZGVudGlmaWVyIGNoYXJhY3RlcnMgcmVtb3ZlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNhbml0aXplTmFtZShzKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzLCBfd2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xyXG59XHJcbmV4cG9ydHMuc2FuaXRpemVOYW1lID0gc2FuaXRpemVOYW1lO1xyXG4vKipcclxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyBmaWVsZCBhbmQgbG9jYWwgdmFyaWFibGUgbmFtZXMgZm9yIGNoYW5nZSBkZXRlY3RvciBjbGFzc2VzLlxyXG4gKiBBbHNvIHByb3ZpZGVzIHNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zLCBmb3IgZXhhbXBsZSwgZGVjbGFyaW5nIHZhcmlhYmxlcywgZGVzdHJveWluZyBwaXBlcyxcclxuICogYW5kIGRlaHlkcmF0aW5nIHRoZSBkZXRlY3Rvci5cclxuICovXHJcbnZhciBDb2RlZ2VuTmFtZVV0aWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29kZWdlbk5hbWVVdGlsKF9yZWNvcmRzLCBfZXZlbnRCaW5kaW5ncywgX2RpcmVjdGl2ZVJlY29yZHMsIF91dGlsTmFtZSkge1xyXG4gICAgICAgIHRoaXMuX3JlY29yZHMgPSBfcmVjb3JkcztcclxuICAgICAgICB0aGlzLl9ldmVudEJpbmRpbmdzID0gX2V2ZW50QmluZGluZ3M7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVjb3JkcyA9IF9kaXJlY3RpdmVSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuX3V0aWxOYW1lID0gX3V0aWxOYW1lO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9zYW5pdGl6ZWRFdmVudE5hbWVzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9zYW5pdGl6ZWROYW1lcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodGhpcy5fcmVjb3Jkcy5sZW5ndGggKyAxKTtcclxuICAgICAgICB0aGlzLl9zYW5pdGl6ZWROYW1lc1tleHBvcnRzLkNPTlRFWFRfSU5ERVhdID0gX0NPTlRFWFRfQUNDRVNTT1I7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSB0aGlzLl9yZWNvcmRzLmxlbmd0aDsgaSA8IGlMZW47ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zYW5pdGl6ZWROYW1lc1tpICsgMV0gPSBzYW5pdGl6ZU5hbWUoXCJcIiArIHRoaXMuX3JlY29yZHNbaV0ubmFtZSArIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBlYkluZGV4ID0gMDsgZWJJbmRleCA8IF9ldmVudEJpbmRpbmdzLmxlbmd0aDsgKytlYkluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBlYiA9IF9ldmVudEJpbmRpbmdzW2ViSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBbX0NPTlRFWFRfQUNDRVNTT1JdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGViLnJlY29yZHMubGVuZ3RoOyBpIDwgaUxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHNhbml0aXplTmFtZShcIlwiICsgZWIucmVjb3Jkc1tpXS5uYW1lICsgaSArIFwiX1wiICsgZWJJbmRleCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nhbml0aXplZEV2ZW50TmFtZXMuc2V0KGViLCBuYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5fYWRkRmllbGRQcmVmaXggPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gXCJcIiArIF9GSUVMRF9QUkVGSVggKyBuYW1lOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXREaXNwYXRjaGVyTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9ESVNQQVRDSEVSX0FDQ0VTU09SKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0UGlwZXNBY2Nlc3Nvck5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfUElQRVNfQUNDRVNTT1IpOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRQcm90b3NOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgoX1BST1RPU19BQ0NFU1NPUik7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldERpcmVjdGl2ZXNBY2Nlc3Nvck5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfRElSRUNUSVZFU19BQ0NFU1NPUik7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldExvY2Fsc0FjY2Vzc29yTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9MT0NBTFNfQUNDRVNTT1IpOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRBbHJlYWR5Q2hlY2tlZE5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfQUxSRUFEWV9DSEVDS0VEX0FDQ0VTU09SKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0TW9kZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfTU9ERV9BQ0NFU1NPUik7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldFByb3BlcnR5QmluZGluZ0luZGV4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgoX1BST1BfQklORElOR19JTkRFWCk7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldExvY2FsTmFtZSA9IGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIFwibF9cIiArIHRoaXMuX3Nhbml0aXplZE5hbWVzW2lkeF07IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldEV2ZW50TG9jYWxOYW1lID0gZnVuY3Rpb24gKGViLCBpZHgpIHtcclxuICAgICAgICByZXR1cm4gXCJsX1wiICsgdGhpcy5fc2FuaXRpemVkRXZlbnROYW1lcy5nZXQoZWIpW2lkeF07XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRDaGFuZ2VOYW1lID0gZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gXCJjX1wiICsgdGhpcy5fc2FuaXRpemVkTmFtZXNbaWR4XTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSBzdGF0ZW1lbnQgaW5pdGlhbGl6aW5nIGxvY2FsIHZhcmlhYmxlcyB1c2VkIHdoZW4gZGV0ZWN0aW5nIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2VuSW5pdExvY2FscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gW107XHJcbiAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSB0aGlzLmdldEZpZWxkQ291bnQoKTsgaSA8IGlMZW47ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSBleHBvcnRzLkNPTlRFWFRfSU5ERVgpIHtcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZ2V0TG9jYWxOYW1lKGkpICsgXCIgPSBcIiArIHRoaXMuZ2V0RmllbGROYW1lKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWMgPSB0aGlzLl9yZWNvcmRzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWMuYXJndW1lbnRUb1B1cmVGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VOYW1lID0gdGhpcy5nZXRDaGFuZ2VOYW1lKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZ2V0TG9jYWxOYW1lKGkpICsgXCIsXCIgKyBjaGFuZ2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKGNoYW5nZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goXCJcIiArIHRoaXMuZ2V0TG9jYWxOYW1lKGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXNzaWdubWVudHNDb2RlID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkoYXNzaWdubWVudHMpID8gJycgOiBhc3NpZ25tZW50cy5qb2luKCc9JykgKyBcIiA9IGZhbHNlO1wiO1xyXG4gICAgICAgIHJldHVybiBcInZhciBcIiArIGRlY2xhcmF0aW9ucy5qb2luKCcsJykgKyBcIjtcIiArIGFzc2lnbm1lbnRzQ29kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgc3RhdGVtZW50IGluaXRpYWxpemluZyBsb2NhbCB2YXJpYWJsZXMgZm9yIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICovXHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdlbkluaXRFdmVudExvY2FscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXMgPSBbKHRoaXMuZ2V0TG9jYWxOYW1lKGV4cG9ydHMuQ09OVEVYVF9JTkRFWCkgKyBcIiA9IFwiICsgdGhpcy5nZXRGaWVsZE5hbWUoZXhwb3J0cy5DT05URVhUX0lOREVYKSldO1xyXG4gICAgICAgIHRoaXMuX3Nhbml0aXplZEV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZXMsIGViKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBleHBvcnRzLkNPTlRFWFRfSU5ERVgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChcIlwiICsgX3RoaXMuZ2V0RXZlbnRMb2NhbE5hbWUoZWIsIGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXMubGVuZ3RoID4gMSA/IFwidmFyIFwiICsgcmVzLmpvaW4oJywnKSArIFwiO1wiIDogJyc7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRQcmV2ZW50RGVmYXVsdEFjY2Vzb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcInByZXZlbnREZWZhdWx0XCI7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldEZpZWxkQ291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zYW5pdGl6ZWROYW1lcy5sZW5ndGg7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldEZpZWxkTmFtZSA9IGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KHRoaXMuX3Nhbml0aXplZE5hbWVzW2lkeF0pOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRBbGxGaWVsZE5hbWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmaWVsZExpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IHRoaXMuZ2V0RmllbGRDb3VudCgpOyBrIDwga0xlbjsgKytrKSB7XHJcbiAgICAgICAgICAgIGlmIChrID09PSAwIHx8IHRoaXMuX3JlY29yZHNbayAtIDFdLnNob3VsZEJlQ2hlY2tlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZExpc3QucHVzaCh0aGlzLmdldEZpZWxkTmFtZShrKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSB0aGlzLl9yZWNvcmRzLmxlbmd0aDsgaSA8IGlMZW47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcmVjID0gdGhpcy5fcmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKHJlYy5pc1BpcGVSZWNvcmQoKSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0LnB1c2godGhpcy5nZXRQaXBlTmFtZShyZWMuc2VsZkluZGV4KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9kaXJlY3RpdmVSZWNvcmRzLmxlbmd0aDsgaiA8IGpMZW47ICsraikge1xyXG4gICAgICAgICAgICB2YXIgZFJlYyA9IHRoaXMuX2RpcmVjdGl2ZVJlY29yZHNbal07XHJcbiAgICAgICAgICAgIGZpZWxkTGlzdC5wdXNoKHRoaXMuZ2V0RGlyZWN0aXZlTmFtZShkUmVjLmRpcmVjdGl2ZUluZGV4KSk7XHJcbiAgICAgICAgICAgIGlmICghZFJlYy5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0LnB1c2godGhpcy5nZXREZXRlY3Rvck5hbWUoZFJlYy5kaXJlY3RpdmVJbmRleCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWVsZExpc3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgc3RhdGVtZW50cyB3aGljaCBjbGVhciBhbGwgZmllbGRzIHNvIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBpcyBkZWh5ZHJhdGVkLlxyXG4gICAgICovXHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdlbkRlaHlkcmF0ZUZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRBbGxGaWVsZE5hbWVzKCk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZUF0KGZpZWxkcywgZXhwb3J0cy5DT05URVhUX0lOREVYKTtcclxuICAgICAgICBpZiAoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkoZmllbGRzKSlcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIC8vIEF0IGxlYXN0IG9uZSBhc3NpZ25tZW50LlxyXG4gICAgICAgIGZpZWxkcy5wdXNoKHRoaXMuX3V0aWxOYW1lICsgXCIudW5pbml0aWFsaXplZDtcIik7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5qb2luKCcgPSAnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBzdGF0ZW1lbnRzIGRlc3Ryb3lpbmcgYWxsIHBpcGUgdmFyaWFibGVzLlxyXG4gICAgICovXHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdlblBpcGVPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbHRlcih0aGlzLl9yZWNvcmRzLCBmdW5jdGlvbiAocikgeyByZXR1cm4gci5pc1BpcGVSZWNvcmQoKTsgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gKF90aGlzLl91dGlsTmFtZSArIFwiLmNhbGxQaXBlT25EZXN0cm95KFwiICsgX3RoaXMuZ2V0UGlwZU5hbWUoci5zZWxmSW5kZXgpICsgXCIpO1wiKTsgfSlcclxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0UGlwZU5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KHRoaXMuX3Nhbml0aXplZE5hbWVzW2lkeF0gKyBcIl9waXBlXCIpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlTmFtZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KFwiZGlyZWN0aXZlX1wiICsgZC5uYW1lKTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldERldGVjdG9yTmFtZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChcImRldGVjdG9yX1wiICsgZC5uYW1lKTsgfTtcclxuICAgIHJldHVybiBDb2RlZ2VuTmFtZVV0aWw7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29kZWdlbk5hbWVVdGlsID0gQ29kZWdlbk5hbWVVdGlsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlZ2VuX25hbWVfdXRpbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbihmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcclxuICAgIC8qKlxyXG4gICAgICogYENoZWNrZWRPbmNlYCBtZWFucyB0aGF0IGFmdGVyIGNhbGxpbmcgZGV0ZWN0Q2hhbmdlcyB0aGUgbW9kZSBvZiB0aGUgY2hhbmdlIGRldGVjdG9yXHJcbiAgICAgKiB3aWxsIGJlY29tZSBgQ2hlY2tlZGAuXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiQ2hlY2tPbmNlXCJdID0gMF0gPSBcIkNoZWNrT25jZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgQ2hlY2tlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHNob3VsZCBiZSBza2lwcGVkIHVudGlsIGl0cyBtb2RlIGNoYW5nZXMgdG9cclxuICAgICAqIGBDaGVja09uY2VgLlxyXG4gICAgICovXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgQ2hlY2tBbHdheXNgIG1lYW5zIHRoYXQgYWZ0ZXIgY2FsbGluZyBkZXRlY3RDaGFuZ2VzIHRoZSBtb2RlIG9mIHRoZSBjaGFuZ2UgZGV0ZWN0b3JcclxuICAgICAqIHdpbGwgcmVtYWluIGBDaGVja0Fsd2F5c2AuXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiQ2hlY2tBbHdheXNcIl0gPSAyXSA9IFwiQ2hlY2tBbHdheXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogYERldGFjaGVkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3Igc3ViIHRyZWUgaXMgbm90IGEgcGFydCBvZiB0aGUgbWFpbiB0cmVlIGFuZFxyXG4gICAgICogc2hvdWxkIGJlIHNraXBwZWQuXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGV0YWNoZWRcIl0gPSAzXSA9IFwiRGV0YWNoZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogYE9uUHVzaGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yJ3MgbW9kZSB3aWxsIGJlIHNldCB0byBgQ2hlY2tPbmNlYCBkdXJpbmcgaHlkcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIk9uUHVzaFwiXSA9IDRdID0gXCJPblB1c2hcIjtcclxuICAgIC8qKlxyXG4gICAgICogYERlZmF1bHRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvcidzIG1vZGUgd2lsbCBiZSBzZXQgdG8gYENoZWNrQWx3YXlzYCBkdXJpbmcgaHlkcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRlZmF1bHRcIl0gPSA1XSA9IFwiRGVmYXVsdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiBXb3JrcyBvbmx5IGluIERhcnQuXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoT2JzZXJ2ZVwiXSA9IDZdID0gXCJPblB1c2hPYnNlcnZlXCI7XHJcbn0pKGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xyXG52YXIgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xyXG5leHBvcnRzLkNIQU5HRV9ERUNUSU9OX1NUUkFURUdZX1ZBTFVFUyA9IFtcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZSxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrZWQsXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja0Fsd2F5cyxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRldGFjaGVkLFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmVcclxuXTtcclxuZnVuY3Rpb24gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcclxuICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkgfHxcclxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9PT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdDtcclxufVxyXG5leHBvcnRzLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkoKSB7XHJcbiAgICB9XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUob2JqKTsgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZFJlZikgeyByZXR1cm4gbmV3IERlZmF1bHRJdGVyYWJsZURpZmZlcigpOyB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSk7XHJcbiAgICByZXR1cm4gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeTtcclxufSkoKTtcclxuZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeTtcclxudmFyIERlZmF1bHRJdGVyYWJsZURpZmZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZWZhdWx0SXRlcmFibGVEaWZmZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbnVsbDtcclxuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdXNlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIChkdXJpbmcgJiBhY3Jvc3MgYF9jaGVjaygpYCBjYWxscylcclxuICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbnVsbDtcclxuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgcmVtb3ZlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIGR1cmluZyBgX2NoZWNrKClgIGNhbGxzLlxyXG4gICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJdEhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2l0SGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faXRUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwiY29sbGVjdGlvblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xsZWN0aW9uOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c0l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xyXG4gICAgICAgICAgICBmbihyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xyXG4gICAgICAgICAgICBmbihyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hNb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMi5pc0JsYW5rKGNvbGxlY3Rpb24pKVxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gW107XHJcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIGNvbGxlY3Rpb24gKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrKGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgLy8gdG9kbyh2aWNiKTogb3B0aW0gZm9yIFVubW9kaWZpYWJsZUxpc3RWaWV3IChmcm96ZW4gYXJyYXlzKVxyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9yZXNldCgpO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSB0aGlzLl9pdEhlYWQ7XHJcbiAgICAgICAgdmFyIG1heUJlRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgdmFyIGl0ZW07XHJcbiAgICAgICAgaWYgKGxhbmdfMi5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gY29sbGVjdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2xlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbGFuZ18yLmxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF5QmVEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLml0ZXJhdGVMaXN0TGlrZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbGFuZ18yLmxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl9taXNtYXRjaChyZWNvcmQsIGl0ZW0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBtYXlCZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heUJlRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pc2tvKTogY2FuIHdlIGxpbWl0IHRoaXMgdG8gZHVwbGljYXRlcyBvbmx5P1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJ1bmNhdGUocmVjb3JkKTtcclxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImlzRGlydHlcIiwge1xyXG4gICAgICAgIC8vIENvbGxlY3Rpb25DaGFuZ2VzIGlzIGNvbnNpZGVyZWQgZGlydHkgaWYgaXQgaGFzIGFueSBhZGRpdGlvbnMsIG1vdmVzIG9yIHJlbW92YWxzLlxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9tb3Zlc0hlYWQgIT09IG51bGwgfHwgdGhpcy5fcmVtb3ZhbHNIZWFkICE9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc3RhdGUgb2YgdGhlIGNoYW5nZSBvYmplY3RzIHRvIHNob3cgbm8gY2hhbmdlcy4gVGhpcyBtZWFucyBzZXQgcHJldmlvdXNLZXkgdG9cclxuICAgICAqIGN1cnJlbnRLZXksIGFuZCBjbGVhciBhbGwgb2YgdGhlIHF1ZXVlcyAoYWRkaXRpb25zLCBtb3ZlcywgcmVtb3ZhbHMpLlxyXG4gICAgICogU2V0IHRoZSBwcmV2aW91c0luZGV4ZXMgb2YgbW92ZWQgYW5kIGFkZGVkIGl0ZW1zIHRvIHRoZWlyIGN1cnJlbnRJbmRleGVzXHJcbiAgICAgKiBSZXNldCB0aGUgbGlzdCBvZiBhZGRpdGlvbnMsIG1vdmVzIGFuZCByZW1vdmFsc1xyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkO1xyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0UHJldmlvdXMgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21vdmVzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSBuZXh0UmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgZGlmZmVyZW5jZXMgYmV0d2VlbiBjb2xsZWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiAtIGByZWNvcmRgIGlzIHRoZSByZWNvcmQgd2hpY2ggd2Ugc2F3IGF0IHRoaXMgcG9zaXRpb24gbGFzdCB0aW1lLiBJZiBudWxsIHRoZW4gaXQgaXMgYSBuZXdcclxuICAgICAqICAgaXRlbS5cclxuICAgICAqIC0gYGl0ZW1gIGlzIHRoZSBjdXJyZW50IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqIC0gYGluZGV4YCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbWlzbWF0Y2ggPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpbmRleCkge1xyXG4gICAgICAgIC8vIFRoZSBwcmV2aW91cyByZWNvcmQgYWZ0ZXIgd2hpY2ggd2Ugd2lsbCBhcHBlbmQgdGhlIGN1cnJlbnQgb25lLlxyXG4gICAgICAgIHZhciBwcmV2aW91c1JlY29yZDtcclxuICAgICAgICBpZiAocmVjb3JkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gdGhpcy5faXRUYWlsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSByZWNvcmQuX3ByZXY7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmVjb3JkIGZyb20gdGhlIGNvbGxlY3Rpb24gc2luY2Ugd2Uga25vdyBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgaXRlbS5cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc2VlIGlmIHdlIGhhdmUgc2VlbiB0aGUgaXRlbSBiZWZvcmUuXHJcbiAgICAgICAgcmVjb3JkID0gdGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9saW5rZWRSZWNvcmRzLmdldChpdGVtLCBpbmRleCk7XHJcbiAgICAgICAgaWYgKHJlY29yZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBiZWZvcmUsIHdlIG5lZWQgdG8gbW92ZSBpdCBmb3J3YXJkIGluIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXIocmVjb3JkLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTmV2ZXIgc2VlbiBpdCwgY2hlY2sgZXZpY3RlZCBsaXN0LlxyXG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtKTtcclxuICAgICAgICAgICAgaWYgKHJlY29yZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gaXRlbSB3aGljaCB3ZSBoYXZlIGV2aWN0ZWQgZWFybGllcjogcmVpbnNlcnQgaXQgYmFjayBpbnRvIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVpbnNlcnRBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIG5ldyBpdGVtOiBhZGQgaXQuXHJcbiAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9hZGRBZnRlcihuZXcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtKSwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjaGVjayBpcyBvbmx5IG5lZWRlZCBpZiBhbiBhcnJheSBjb250YWlucyBkdXBsaWNhdGVzLiAoU2hvcnQgY2lyY3VpdCBvZiBub3RoaW5nIGRpcnR5KVxyXG4gICAgICpcclxuICAgICAqIFVzZSBjYXNlOiBgW2EsIGFdYCA9PiBgW2IsIGEsIGFdYFxyXG4gICAgICpcclxuICAgICAqIElmIHdlIGRpZCBub3QgaGF2ZSB0aGlzIGNoZWNrIHRoZW4gdGhlIGluc2VydGlvbiBvZiBgYmAgd291bGQ6XHJcbiAgICAgKiAgIDEpIGV2aWN0IGZpcnN0IGBhYFxyXG4gICAgICogICAyKSBpbnNlcnQgYGJgIGF0IGAwYCBpbmRleC5cclxuICAgICAqICAgMykgbGVhdmUgYGFgIGF0IGluZGV4IGAxYCBhcyBpcy4gPC0tIHRoaXMgaXMgd3JvbmchXHJcbiAgICAgKiAgIDMpIHJlaW5zZXJ0IGBhYCBhdCBpbmRleCAyLiA8LS0gdGhpcyBpcyB3cm9uZyFcclxuICAgICAqXHJcbiAgICAgKiBUaGUgY29ycmVjdCBiZWhhdmlvciBpczpcclxuICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXHJcbiAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxyXG4gICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMS5cclxuICAgICAqICAgMykgbW92ZSBgYWAgYXQgZnJvbSBgMWAgdG8gYDJgLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBEb3VibGUgY2hlY2sgdGhhdCB3ZSBoYXZlIG5vdCBldmljdGVkIGEgZHVwbGljYXRlIGl0ZW0uIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGl0ZW0gdHlwZSBtYXlcclxuICAgICAqIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQ6XHJcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9mIGIgd2lsbCBldmljdCB0aGUgZmlyc3QgJ2EnLiBJZiB3ZSBkb24ndCByZWluc2VydCBpdCBub3cgaXQgd2lsbCBiZSByZWluc2VydGVkXHJcbiAgICAgKiBhdCB0aGUgZW5kLiBXaGljaCB3aWxsIHNob3cgdXAgYXMgdGhlIHR3byAnYSdzIHN3aXRjaGluZyBwb3NpdGlvbi4gVGhpcyBpcyBpbmNvcnJlY3QsIHNpbmNlIGFcclxuICAgICAqIGJldHRlciB3YXkgdG8gdGhpbmsgb2YgaXQgaXMgYXMgaW5zZXJ0IG9mICdiJyByYXRoZXIgdGhlbiBzd2l0Y2ggJ2EnIHdpdGggJ2InIGFuZCB0aGVuIGFkZCAnYSdcclxuICAgICAqIGF0IHRoZSBlbmQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3ZlcmlmeVJlaW5zZXJ0aW9uID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgcmVpbnNlcnRSZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAocmVpbnNlcnRSZWNvcmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fcmVpbnNlcnRBZnRlcihyZWluc2VydFJlY29yZCwgcmVjb3JkLl9wcmV2LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlY29yZC5jdXJyZW50SW5kZXggIT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHJpZCBvZiBhbnkgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfXMgZnJvbSB0aGUgcHJldmlvdXMgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIC0gYHJlY29yZGAgVGhlIGZpcnN0IGV4Y2VzcyB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0uXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIEFueXRoaW5nIGFmdGVyIHRoYXQgbmVlZHMgdG8gYmUgcmVtb3ZlZDtcclxuICAgICAgICB3aGlsZSAocmVjb3JkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcclxuICAgICAgICAgICAgcmVjb3JkID0gbmV4dFJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pdFRhaWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faXRUYWlsLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fcmVpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2UmVtb3ZlZDtcclxuICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XHJcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByZXYuX25leHRSZW1vdmVkID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHQuX3ByZXZSZW1vdmVkID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21vdmVBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fdW5saW5rKHJlY29yZCk7XHJcbiAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcclxuICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLl9hZGRpdGlvbnNIZWFkID09PSBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydChfYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID09PSBudWxsKTtcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09PSBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQgIT0gcHJldlJlY29yZCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldiA9PT0gbnVsbCk7XHJcbiAgICAgICAgdmFyIG5leHQgPSBwcmV2UmVjb3JkID09PSBudWxsID8gdGhpcy5faXRIZWFkIDogcHJldlJlY29yZC5fbmV4dDtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgLy8gYXNzZXJ0KG5leHQgIT0gcmVjb3JkKTtcclxuICAgICAgICAvLyBhc3NlcnQocHJldlJlY29yZCAhPSByZWNvcmQpO1xyXG4gICAgICAgIHJlY29yZC5fbmV4dCA9IG5leHQ7XHJcbiAgICAgICAgcmVjb3JkLl9wcmV2ID0gcHJldlJlY29yZDtcclxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlJlY29yZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2UmVjb3JkLl9uZXh0ID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcclxuICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3VubGluayA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzLnJlbW92ZShyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldjtcclxuICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX3ByZXYgPSBudWxsKSA9PT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX25leHQgPSBudWxsKSA9PT0gbnVsbCk7XHJcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dC5fcHJldiA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9Nb3ZlcyA9IGZ1bmN0aW9uIChyZWNvcmQsIHRvSW5kZXgpIHtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dE1vdmVkID09PSBudWxsKTtcclxuICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzSW5kZXggPT09IHRvSW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNIZWFkID09PSBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNIZWFkID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgICAgICAvLyBhc3NlcnQoX21vdmVzVGFpbC5fbmV4dE1vdmVkID09PSBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNUYWlsLl9uZXh0TW92ZWQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcclxuICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gbnVsbDtcclxuICAgICAgICByZWNvcmQuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5fcmVtb3ZhbHNUYWlsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9yZW1vdmFsc0hlYWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSB0aGlzLl9yZW1vdmFsc0hlYWQgPSByZWNvcmQ7XHJcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0UmVtb3ZlZCA9PT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldmlvdXMgPSBbXTtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbnMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW92ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21vdmVzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRNb3ZlZCkge1xyXG4gICAgICAgICAgICBtb3Zlcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1vdmFscyA9IFtdO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcclxuICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJjb2xsZWN0aW9uOiBcIiArIGxpc3Quam9pbignLCAnKSArIFwiXFxuXCIgKyBcInByZXZpb3VzOiBcIiArIHByZXZpb3VzLmpvaW4oJywgJykgKyBcIlxcblwiICtcclxuICAgICAgICAgICAgXCJhZGRpdGlvbnM6IFwiICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyBcIlxcblwiICsgXCJtb3ZlczogXCIgKyBtb3Zlcy5qb2luKCcsICcpICsgXCJcXG5cIiArXHJcbiAgICAgICAgICAgIFwicmVtb3ZhbHM6IFwiICsgcmVtb3ZhbHMuam9pbignLCAnKSArIFwiXFxuXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXIgPSBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XHJcbnZhciBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNJbmRleCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcHJldkR1cCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHREdXAgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9wcmV2UmVtb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dEFkZGVkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dE1vdmVkID0gbnVsbDtcclxuICAgIH1cclxuICAgIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4ID9cclxuICAgICAgICAgICAgbGFuZ18yLnN0cmluZ2lmeSh0aGlzLml0ZW0pIDpcclxuICAgICAgICAgICAgbGFuZ18yLnN0cmluZ2lmeSh0aGlzLml0ZW0pICsgJ1snICsgbGFuZ18yLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzSW5kZXgpICsgJy0+JyArXHJcbiAgICAgICAgICAgICAgICBsYW5nXzIuc3RyaW5naWZ5KHRoaXMuY3VycmVudEluZGV4KSArICddJztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcclxufSkoKTtcclxuZXhwb3J0cy5Db2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcclxuLy8gQSBsaW5rZWQgbGlzdCBvZiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkcyB3aXRoIHRoZSBzYW1lIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQuaXRlbVxyXG52YXIgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmQgdGhlIHJlY29yZCB0byB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGJ5IGRlc2lnbiBhbGwgcmVjb3JkcyBpbiB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGhvbGQgdGhlIHNhbWUgdmFsdWUgaW4gcmVjb3JkLml0ZW0uXHJcbiAgICAgKi9cclxuICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gcmVjb3JkO1xyXG4gICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xyXG4gICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLml0ZW0gPT0gIF9oZWFkLml0ZW0gfHxcclxuICAgICAgICAgICAgLy8gICAgICAgcmVjb3JkLml0ZW0gaXMgbnVtICYmIHJlY29yZC5pdGVtLmlzTmFOICYmIF9oZWFkLml0ZW0gaXMgbnVtICYmIF9oZWFkLml0ZW0uaXNOYU4pO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsLl9uZXh0RHVwID0gcmVjb3JkO1xyXG4gICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSB0aGlzLl90YWlsO1xyXG4gICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBoYXZpbmcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5pdGVtID09IGl0ZW0gYW5kXHJcbiAgICAvLyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLmN1cnJlbnRJbmRleCA+PSBhZnRlckluZGV4XHJcbiAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpdGVtLCBhZnRlckluZGV4KSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0RHVwKSB7XHJcbiAgICAgICAgICAgIGlmICgoYWZ0ZXJJbmRleCA9PT0gbnVsbCB8fCBhZnRlckluZGV4IDwgcmVjb3JkLmN1cnJlbnRJbmRleCkgJiZcclxuICAgICAgICAgICAgICAgIGxhbmdfMi5sb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgb25lIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfSBmcm9tIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAvLyBhc3NlcnQoKCkge1xyXG4gICAgICAgIC8vICAvLyB2ZXJpZnkgdGhhdCB0aGUgcmVjb3JkIGJlaW5nIHJlbW92ZWQgaXMgaW4gdGhlIGxpc3QuXHJcbiAgICAgICAgLy8gIGZvciAoQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBjdXJzb3IgPSBfaGVhZDsgY3Vyc29yICE9IG51bGw7IGN1cnNvciA9IGN1cnNvci5fbmV4dER1cCkge1xyXG4gICAgICAgIC8vICAgIGlmIChpZGVudGljYWwoY3Vyc29yLCByZWNvcmQpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyAgfVxyXG4gICAgICAgIC8vICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy99KTtcclxuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldkR1cDtcclxuICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dER1cDtcclxuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByZXYuX25leHREdXAgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHQuX3ByZXZEdXAgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZCA9PT0gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0O1xyXG59KSgpO1xyXG52YXIgX0R1cGxpY2F0ZU1hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfRHVwbGljYXRlTWFwKCkge1xyXG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYikgaGFuZGxlIGNvcm5lciBjYXNlc1xyXG4gICAgICAgIHZhciBrZXkgPSBsYW5nXzIuZ2V0TWFwS2V5KHJlY29yZC5pdGVtKTtcclxuICAgICAgICB2YXIgZHVwbGljYXRlcyA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghbGFuZ18yLmlzUHJlc2VudChkdXBsaWNhdGVzKSkge1xyXG4gICAgICAgICAgICBkdXBsaWNhdGVzID0gbmV3IF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBkdXBsaWNhdGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHVwbGljYXRlcy5hZGQocmVjb3JkKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBgdmFsdWVgIHVzaW5nIGtleS4gQmVjYXVzZSB0aGUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCB2YWx1ZSBtYXliZSBvbmUgd2hpY2ggd2VcclxuICAgICAqIGhhdmUgYWxyZWFkeSBpdGVyYXRlZCBvdmVyLCB3ZSB1c2UgdGhlIGFmdGVySW5kZXggdG8gcHJldGVuZCBpdCBpcyBub3QgdGhlcmUuXHJcbiAgICAgKlxyXG4gICAgICogVXNlIGNhc2U6IGBbYSwgYiwgYywgYSwgYV1gIGlmIHdlIGFyZSBhdCBpbmRleCBgM2Agd2hpY2ggaXMgdGhlIHNlY29uZCBgYWAgdGhlbiBhc2tpbmcgaWYgd2VcclxuICAgICAqIGhhdmUgYW55IG1vcmUgYGFgcyBuZWVkcyB0byByZXR1cm4gdGhlIGxhc3QgYGFgIG5vdCB0aGUgZmlyc3Qgb3Igc2Vjb25kLlxyXG4gICAgICovXHJcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUsIGFmdGVySW5kZXgpIHtcclxuICAgICAgICBpZiAoYWZ0ZXJJbmRleCA9PT0gdm9pZCAwKSB7IGFmdGVySW5kZXggPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGtleSA9IGxhbmdfMi5nZXRNYXBLZXkodmFsdWUpO1xyXG4gICAgICAgIHZhciByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMi5pc0JsYW5rKHJlY29yZExpc3QpID8gbnVsbCA6IHJlY29yZExpc3QuZ2V0KHZhbHVlLCBhZnRlckluZGV4KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgYWxzbyBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBpZiBpdCBnZXRzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGxhbmdfMi5nZXRNYXBLZXkocmVjb3JkLml0ZW0pO1xyXG4gICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAvLyBhc3NlcnQodGhpcy5tYXAuY29udGFpbnNLZXkoa2V5KSk7XHJcbiAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZHVwbGljYXRlcyB3aGVuIGl0IGdldHMgZW1wdHlcclxuICAgICAgICBpZiAocmVjb3JkTGlzdC5yZW1vdmUocmVjb3JkKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1hcC5zaXplID09PSAwOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1hcC5jbGVhcigpOyB9O1xyXG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnX0R1cGxpY2F0ZU1hcCgnICsgbGFuZ18yLnN0cmluZ2lmeSh0aGlzLm1hcCkgKyAnKSc7IH07XHJcbiAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcclxufSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKSB7XHJcbiAgICB9XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1hcCB8fCBsYW5nXzEuaXNKc09iamVjdChvYmopOyB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNkUmVmKSB7IHJldHVybiBuZXcgRGVmYXVsdEtleVZhbHVlRGlmZmVyKCk7IH07XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5KTtcclxuICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5O1xyXG59KSgpO1xyXG5leHBvcnRzLkRlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5O1xyXG52YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlcigpIHtcclxuICAgICAgICB0aGlzLl9yZWNvcmRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZGl0aW9uc0hlYWQgIT09IG51bGwgfHwgdGhpcy5fY2hhbmdlc0hlYWQgIT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xyXG4gICAgICAgICAgICBmbihyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hDaGFuZ2VkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWFwKSlcclxuICAgICAgICAgICAgbWFwID0gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIuY3JlYXRlRnJvbVBhaXJzKFtdKTtcclxuICAgICAgICBpZiAoIShtYXAgaW5zdGFuY2VvZiBNYXAgfHwgbGFuZ18xLmlzSnNPYmplY3QobWFwKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRXJyb3IgdHJ5aW5nIHRvIGRpZmYgJ1wiICsgbWFwICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGVjayhtYXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLl9yZWNvcmRzO1xyXG4gICAgICAgIHZhciBvbGRTZXFSZWNvcmQgPSB0aGlzLl9tYXBIZWFkO1xyXG4gICAgICAgIHZhciBsYXN0T2xkU2VxUmVjb3JkID0gbnVsbDtcclxuICAgICAgICB2YXIgbGFzdE5ld1NlcVJlY29yZCA9IG51bGw7XHJcbiAgICAgICAgdmFyIHNlcUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9mb3JFYWNoKG1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1NlcVJlY29yZDtcclxuICAgICAgICAgICAgaWYgKG9sZFNlcVJlY29yZCAhPT0gbnVsbCAmJiBrZXkgPT09IG9sZFNlcVJlY29yZC5rZXkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG9sZFNlcVJlY29yZDtcclxuICAgICAgICAgICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHZhbHVlLCBvbGRTZXFSZWNvcmQuY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFNlcVJlY29yZC5wcmV2aW91c1ZhbHVlID0gb2xkU2VxUmVjb3JkLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQuY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvQ2hhbmdlcyhvbGRTZXFSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VxQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkU2VxUmVjb3JkLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVNlcShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUb1JlbW92YWxzKG9sZFNlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3Jkcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IHJlY29yZHMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSBuZXcgS1ZDaGFuZ2VSZWNvcmQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChrZXksIG5ld1NlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUb0FkZGl0aW9ucyhuZXdTZXFSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZXFDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzSW5SZW1vdmFscyhuZXdTZXFSZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUZyb21SZW1vdmFscyhuZXdTZXFSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3ROZXdTZXFSZWNvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXBIZWFkID0gbmV3U2VxUmVjb3JkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZC5fbmV4dCA9IG5ld1NlcVJlY29yZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0T2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkO1xyXG4gICAgICAgICAgICBsYXN0TmV3U2VxUmVjb3JkID0gbmV3U2VxUmVjb3JkO1xyXG4gICAgICAgICAgICBvbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQgPT09IG51bGwgPyBudWxsIDogb2xkU2VxUmVjb3JkLl9uZXh0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RydW5jYXRlKGxhc3RPbGRTZXFSZWNvcmQsIG9sZFNlcVJlY29yZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgc3RhdGUgb2YgdGhlIG1hcHBpbmdcclxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0UHJldmlvdXMgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c1ZhbHVlID0gcmVjb3JkLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpIG9uY2UgYXNzZXJ0IGlzIHN1cHBvcnRlZFxyXG4gICAgICAgICAgICAvLyBhc3NlcnQoKCkge1xyXG4gICAgICAgICAgICAvLyAgdmFyIHIgPSBfY2hhbmdlc0hlYWQ7XHJcbiAgICAgICAgICAgIC8vICB3aGlsZSAociAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHZhciBuZXh0UmVjb3JkID0gci5fbmV4dENoYW5nZWQ7XHJcbiAgICAgICAgICAgIC8vICAgIHIuX25leHRDaGFuZ2VkID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gICAgciA9IG5leHRSZWNvcmQ7XHJcbiAgICAgICAgICAgIC8vICB9XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICByID0gX2FkZGl0aW9uc0hlYWQ7XHJcbiAgICAgICAgICAgIC8vICB3aGlsZSAociAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHZhciBuZXh0UmVjb3JkID0gci5fbmV4dEFkZGVkO1xyXG4gICAgICAgICAgICAvLyAgICByLl9uZXh0QWRkZWQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgICByID0gbmV4dFJlY29yZDtcclxuICAgICAgICAgICAgLy8gIH1cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gIHIgPSBfcmVtb3ZhbHNIZWFkO1xyXG4gICAgICAgICAgICAvLyAgd2hpbGUgKHIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyAgICB2YXIgbmV4dFJlY29yZCA9IHIuX25leHRSZW1vdmVkO1xyXG4gICAgICAgICAgICAvLyAgICByLl9uZXh0UmVtb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vICAgIHIgPSBuZXh0UmVjb3JkO1xyXG4gICAgICAgICAgICAvLyAgfVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIC8vfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKGxhc3RSZWNvcmQsIHJlY29yZCkge1xyXG4gICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RSZWNvcmQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJlY29yZC5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XHJcbiAgICAgICAgICAgIC8vIGFzc2VydCgoKCkge1xyXG4gICAgICAgICAgICAvLyAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAvL30pKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkVG9SZW1vdmFscyhyZWNvcmQpO1xyXG4gICAgICAgICAgICBsYXN0UmVjb3JkID0gcmVjb3JkO1xyXG4gICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciByZWMgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlYyAhPT0gbnVsbDsgcmVjID0gcmVjLl9uZXh0UmVtb3ZlZCkge1xyXG4gICAgICAgICAgICByZWMucHJldmlvdXNWYWx1ZSA9IHJlYy5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgIHJlYy5jdXJyZW50VmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRzLmRlbGV0ZShyZWMua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5faXNJblJlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgIT09IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpIGFzc2VydFxyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRDaGFuZ2VkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX3ByZXZSZW1vdmVkID09IG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc0hlYWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IHJlY29yZDtcclxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tU2VxID0gZnVuY3Rpb24gKHByZXYsIHJlY29yZCkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xyXG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XHJcbiAgICAgICAgLy8gYXNzZXJ0KCgoKSB7XHJcbiAgICAgICAgLy8gIHJlY29yZC5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgLy8gIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vfSkoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVJlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dENoYW5nZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZSZW1vdmVkO1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcclxuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5fbmV4dFJlbW92ZWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dC5fcHJldlJlbW92ZWQgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9BZGRpdGlvbnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKTogYXNzZXJ0XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dENoYW5nZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldlJlbW92ZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc0hlYWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSByZWNvcmQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpIGFzc2VydFxyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0Q2hhbmdlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0UmVtb3ZlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2UmVtb3ZlZCA9PSBudWxsKTtcclxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlc0hlYWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsLl9uZXh0Q2hhbmdlZCA9IHJlY29yZDtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgdmFyIHByZXZpb3VzID0gW107XHJcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgYWRkaXRpb25zID0gW107XHJcbiAgICAgICAgdmFyIHJlbW92YWxzID0gW107XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2gobGFuZ18xLnN0cmluZ2lmeShyZWNvcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGxhbmdfMS5zdHJpbmdpZnkocmVjb3JkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbnMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHJlbW92YWxzLnB1c2gobGFuZ18xLnN0cmluZ2lmeShyZWNvcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwibWFwOiBcIiArIGl0ZW1zLmpvaW4oJywgJykgKyBcIlxcblwiICsgXCJwcmV2aW91czogXCIgKyBwcmV2aW91cy5qb2luKCcsICcpICsgXCJcXG5cIiArXHJcbiAgICAgICAgICAgIFwiYWRkaXRpb25zOiBcIiArIGFkZGl0aW9ucy5qb2luKCcsICcpICsgXCJcXG5cIiArIFwiY2hhbmdlczogXCIgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyBcIlxcblwiICtcclxuICAgICAgICAgICAgXCJyZW1vdmFsczogXCIgKyByZW1vdmFscy5qb2luKCcsICcpICsgXCJcXG5cIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcclxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gob2JqLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVmYXVsdEtleVZhbHVlRGlmZmVyID0gRGVmYXVsdEtleVZhbHVlRGlmZmVyO1xyXG52YXIgS1ZDaGFuZ2VSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gS1ZDaGFuZ2VSZWNvcmQoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0UmVtb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dENoYW5nZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgS1ZDaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEubG9vc2VJZGVudGljYWwodGhpcy5wcmV2aW91c1ZhbHVlLCB0aGlzLmN1cnJlbnRWYWx1ZSkgP1xyXG4gICAgICAgICAgICBsYW5nXzEuc3RyaW5naWZ5KHRoaXMua2V5KSA6XHJcbiAgICAgICAgICAgIChsYW5nXzEuc3RyaW5naWZ5KHRoaXMua2V5KSArICdbJyArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5wcmV2aW91c1ZhbHVlKSArICctPicgK1xyXG4gICAgICAgICAgICAgICAgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRWYWx1ZSkgKyAnXScpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBLVkNoYW5nZVJlY29yZDtcclxufSkoKTtcclxuZXhwb3J0cy5LVkNoYW5nZVJlY29yZCA9IEtWQ2hhbmdlUmVjb3JkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X2tleXZhbHVlX2RpZmZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG4vKipcclxuICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBpdGVyYWJsZSBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0ZvciwgTmdDbGFzcywgYW5kIG90aGVycy5cclxuICovXHJcbnZhciBJdGVyYWJsZURpZmZlcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvcGllZCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbG9uZShwYXJlbnQuZmFjdG9yaWVzKTtcclxuICAgICAgICAgICAgZmFjdG9yaWVzID0gZmFjdG9yaWVzLmNvbmNhdChjb3BpZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiB7QGxpbmsgSXRlcmFibGVEaWZmZXJGYWN0b3J5fSBhbmQgcmV0dXJucyBhIHByb3ZpZGVyIHVzZWQgdG8gZXh0ZW5kIHRoZVxyXG4gICAgICogaW5oZXJpdGVkIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGZhY3RvcmllcyBhbmQgcmV0dXJuIGEgbmV3XHJcbiAgICAgKiB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGV4dGVuZCBhbiBleGlzdGluZyBsaXN0IG9mIGZhY3RvcmllcyxcclxuICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAqIFRoaXMgc3RlcCBpcyBhbGwgdGhhdCdzIHJlcXVpcmVkIHRvIG1ha2UgYSBuZXcge0BsaW5rIEl0ZXJhYmxlRGlmZmVyfSBhdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogIyBFeGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAQ29tcG9uZW50KHtcclxuICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xyXG4gICAgICogICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVMaXN0RGlmZmVyKCldKVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkaV8xLlByb3ZpZGVyKEl0ZXJhYmxlRGlmZmVycywge1xyXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm9vdHN0cmFwKCksIHdoaWNoIHdvdWxkIG92ZXJyaWRlIGRlZmF1bHQgcGlwZXMgaW5zdGVhZCBvZiBleHRlbmRpbmcgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0Nhbm5vdCBleHRlbmQgSXRlcmFibGVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnMuY3JlYXRlKGZhY3RvcmllcywgcGFyZW50KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXHJcbiAgICAgICAgICAgIGRlcHM6IFtbSXRlcmFibGVEaWZmZXJzLCBuZXcgZGlfMS5Ta2lwU2VsZk1ldGFkYXRhKCksIG5ldyBkaV8xLk9wdGlvbmFsTWV0YWRhdGEoKV1dXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSXRlcmFibGVEaWZmZXJzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmluZCh0aGlzLmZhY3RvcmllcywgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoaXRlcmFibGUpOyB9KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChmYWN0b3J5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGl0ZXJhYmxlICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJdGVyYWJsZURpZmZlcnMgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXldKVxyXG4gICAgXSwgSXRlcmFibGVEaWZmZXJzKTtcclxuICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSXRlcmFibGVEaWZmZXJzID0gSXRlcmFibGVEaWZmZXJzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYWJsZV9kaWZmZXJzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbi8qKlxyXG4gKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IE1hcCBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0NsYXNzLCBOZ1N0eWxlLCBhbmQgb3RoZXJzLlxyXG4gKi9cclxudmFyIEtleVZhbHVlRGlmZmVycyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XHJcbiAgICB9XHJcbiAgICBLZXlWYWx1ZURpZmZlcnMuY3JlYXRlID0gZnVuY3Rpb24gKGZhY3RvcmllcywgcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50KSkge1xyXG4gICAgICAgICAgICB2YXIgY29waWVkID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xyXG4gICAgICAgICAgICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMuY29uY2F0KGNvcGllZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBLZXlWYWx1ZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXHJcbiAgICAgKiBpbmhlcml0ZWQge0BsaW5rIEtleVZhbHVlRGlmZmVyc30gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZmFjdG9yaWVzIGFuZCByZXR1cm4gYSBuZXdcclxuICAgICAqIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGxpc3Qgb2YgZmFjdG9yaWVzLFxyXG4gICAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgS2V5VmFsdWVEaWZmZXJ9IGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiAjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBDb21wb25lbnQoe1xyXG4gICAgICogICB2aWV3UHJvdmlkZXJzOiBbXHJcbiAgICAgKiAgICAgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZChbbmV3IEltbXV0YWJsZU1hcERpZmZlcigpXSlcclxuICAgICAqICAgXVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBLZXlWYWx1ZURpZmZlcnMuZXh0ZW5kID0gZnVuY3Rpb24gKGZhY3Rvcmllcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgZGlfMS5Qcm92aWRlcihLZXlWYWx1ZURpZmZlcnMsIHtcclxuICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEtleVZhbHVlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdDYW5ub3QgZXh0ZW5kIEtleVZhbHVlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIERlcGVuZGVuY3kgdGVjaG5pY2FsbHkgaXNuJ3Qgb3B0aW9uYWwsIGJ1dCB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIHRoaXMgd2F5LlxyXG4gICAgICAgICAgICBkZXBzOiBbW0tleVZhbHVlRGlmZmVycywgbmV3IGRpXzEuU2tpcFNlbGZNZXRhZGF0YSgpLCBuZXcgZGlfMS5PcHRpb25hbE1ldGFkYXRhKCldXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEtleVZhbHVlRGlmZmVycy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbmQodGhpcy5mYWN0b3JpZXMsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGt2KTsgfSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZmFjdG9yeSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyBrdiArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS2V5VmFsdWVEaWZmZXJzID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0FycmF5XSlcclxuICAgIF0sIEtleVZhbHVlRGlmZmVycyk7XHJcbiAgICByZXR1cm4gS2V5VmFsdWVEaWZmZXJzO1xyXG59KSgpO1xyXG5leHBvcnRzLktleVZhbHVlRGlmZmVycyA9IEtleVZhbHVlRGlmZmVycztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5dmFsdWVfZGlmZmVycy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBEaXJlY3RpdmVJbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVJbmRleChlbGVtZW50SW5kZXgsIGRpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50SW5kZXggPSBlbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVJbmRleCA9IGRpcmVjdGl2ZUluZGV4O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZUluZGV4LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWxlbWVudEluZGV4ICsgXCJfXCIgKyB0aGlzLmRpcmVjdGl2ZUluZGV4OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEaXJlY3RpdmVJbmRleDtcclxufSkoKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVJbmRleCA9IERpcmVjdGl2ZUluZGV4O1xyXG52YXIgRGlyZWN0aXZlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVJlY29yZChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBkaXJlY3RpdmVJbmRleCA9IF9iLmRpcmVjdGl2ZUluZGV4LCBjYWxsQWZ0ZXJDb250ZW50SW5pdCA9IF9iLmNhbGxBZnRlckNvbnRlbnRJbml0LCBjYWxsQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IF9iLmNhbGxBZnRlckNvbnRlbnRDaGVja2VkLCBjYWxsQWZ0ZXJWaWV3SW5pdCA9IF9iLmNhbGxBZnRlclZpZXdJbml0LCBjYWxsQWZ0ZXJWaWV3Q2hlY2tlZCA9IF9iLmNhbGxBZnRlclZpZXdDaGVja2VkLCBjYWxsT25DaGFuZ2VzID0gX2IuY2FsbE9uQ2hhbmdlcywgY2FsbERvQ2hlY2sgPSBfYi5jYWxsRG9DaGVjaywgY2FsbE9uSW5pdCA9IF9iLmNhbGxPbkluaXQsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbjtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZUluZGV4ID0gZGlyZWN0aXZlSW5kZXg7XHJcbiAgICAgICAgdGhpcy5jYWxsQWZ0ZXJDb250ZW50SW5pdCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNhbGxBZnRlckNvbnRlbnRJbml0KTtcclxuICAgICAgICB0aGlzLmNhbGxBZnRlckNvbnRlbnRDaGVja2VkID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbEFmdGVyQ29udGVudENoZWNrZWQpO1xyXG4gICAgICAgIHRoaXMuY2FsbE9uQ2hhbmdlcyA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNhbGxPbkNoYW5nZXMpO1xyXG4gICAgICAgIHRoaXMuY2FsbEFmdGVyVmlld0luaXQgPSBsYW5nXzEubm9ybWFsaXplQm9vbChjYWxsQWZ0ZXJWaWV3SW5pdCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQWZ0ZXJWaWV3Q2hlY2tlZCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNhbGxBZnRlclZpZXdDaGVja2VkKTtcclxuICAgICAgICB0aGlzLmNhbGxEb0NoZWNrID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbERvQ2hlY2spO1xyXG4gICAgICAgIHRoaXMuY2FsbE9uSW5pdCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNhbGxPbkluaXQpO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgRGlyZWN0aXZlUmVjb3JkLnByb3RvdHlwZS5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KHRoaXMuY2hhbmdlRGV0ZWN0aW9uKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlUmVjb3JkO1xyXG59KSgpO1xyXG5leHBvcnRzLkRpcmVjdGl2ZVJlY29yZCA9IERpcmVjdGl2ZVJlY29yZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlX3JlY29yZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvcl8xID0gcmVxdWlyZSgnLi9hYnN0cmFjdF9jaGFuZ2VfZGV0ZWN0b3InKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwnKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIHByb3RvX3JlY29yZF8xID0gcmVxdWlyZSgnLi9wcm90b19yZWNvcmQnKTtcclxudmFyIER5bmFtaWNDaGFuZ2VEZXRlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRHluYW1pY0NoYW5nZURldGVjdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRHluYW1pY0NoYW5nZURldGVjdG9yKGlkLCBkaXNwYXRjaGVyLCBudW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzLCBwcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCBkaXJlY3RpdmVJbmRpY2VzLCBzdHJhdGVneSwgX3JlY29yZHMsIF9ldmVudEJpbmRpbmdzLCBfZGlyZWN0aXZlUmVjb3JkcywgX2dlbkNvbmZpZykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlkLCBkaXNwYXRjaGVyLCBudW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzLCBwcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCBkaXJlY3RpdmVJbmRpY2VzLCBzdHJhdGVneSk7XHJcbiAgICAgICAgdGhpcy5fcmVjb3JkcyA9IF9yZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50QmluZGluZ3MgPSBfZXZlbnRCaW5kaW5ncztcclxuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZWNvcmRzID0gX2RpcmVjdGl2ZVJlY29yZHM7XHJcbiAgICAgICAgdGhpcy5fZ2VuQ29uZmlnID0gX2dlbkNvbmZpZztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xyXG4gICAgICAgIHZhciBsZW4gPSBfcmVjb3Jkcy5sZW5ndGggKyAxO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShsZW4pO1xyXG4gICAgICAgIHRoaXMubG9jYWxQaXBlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICB0aGlzLnByZXZDb250ZXh0cyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGxlbik7XHJcbiAgICAgICAgdGhpcy5kZWh5ZHJhdGVEaXJlY3RpdmVzKGZhbHNlKTtcclxuICAgIH1cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaGFuZGxlRXZlbnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsSW5kZXgsIGxvY2Fscykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWF0Y2hpbmdFdmVudEJpbmRpbmdzKGV2ZW50TmFtZSwgZWxJbmRleClcclxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHJlYykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX3Byb2Nlc3NFdmVudEJpbmRpbmcocmVjLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByZXZlbnREZWZhdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3Byb2Nlc3NFdmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoZWIsIGxvY2Fscykge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGViLnJlY29yZHMubGVuZ3RoKTtcclxuICAgICAgICB2YWx1ZXNbMF0gPSB0aGlzLnZhbHVlc1swXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGViLnJlY29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHByb3RvID0gZWIucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJWYWx1ZShwcm90bywgdmFsdWVzLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICBpZiAocHJvdG8ubGFzdEluQmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya1BhdGhBc0NoZWNrT25jZShwcm90byk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWxmKHByb3RvLCByZXMsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGJlIHJlYWNoZWRcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fbWFya1BhdGhBc0NoZWNrT25jZSA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgIGlmICghcHJvdG8uYmluZGluZ1JlY29yZC5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24oKSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gcHJvdG8uYmluZGluZ1JlY29yZC5kaXJlY3RpdmVSZWNvcmQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldERldGVjdG9yRm9yKGRpci5kaXJlY3RpdmVJbmRleCkubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9tYXRjaGluZ0V2ZW50QmluZGluZ3MgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWx0ZXIodGhpcy5fZXZlbnRCaW5kaW5ncywgZnVuY3Rpb24gKGViKSB7IHJldHVybiBlYi5ldmVudE5hbWUgPT0gZXZlbnROYW1lICYmIGViLmVsSW5kZXggPT09IGVsSW5kZXg7IH0pO1xyXG4gICAgfTtcclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHRoaXMudmFsdWVzWzBdID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdGl2ZUluZGljZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGlyZWN0aXZlSW5kaWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub2JzZXJ2ZURpcmVjdGl2ZS5jYWxsKHRoaXMsIGRpcmVjdGl2ZXMuZ2V0RGlyZWN0aXZlRm9yKGluZGV4KSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZWh5ZHJhdGVEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRlc3Ryb3lQaXBlcykge1xyXG4gICAgICAgIGlmIChkZXN0cm95UGlwZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBpcGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVzWzBdID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKHRoaXMudmFsdWVzLCBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLnVuaW5pdGlhbGl6ZWQsIDEpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKHRoaXMuY2hhbmdlcywgZmFsc2UpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKHRoaXMubG9jYWxQaXBlcywgbnVsbCk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbGwodGhpcy5wcmV2Q29udGV4dHMsIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwudW5pbml0aWFsaXplZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZGVzdHJveVBpcGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbFBpcGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMubG9jYWxQaXBlc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuY2FsbFBpcGVPbkRlc3Ryb3kodGhpcy5sb2NhbFBpcGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJ1bkRldGVjdENoYW5nZXModHJ1ZSk7IH07XHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdENoYW5nZXNJblJlY29yZHNJbnRlcm5hbCA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XHJcbiAgICAgICAgdmFyIHByb3RvcyA9IHRoaXMuX3JlY29yZHM7XHJcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBudWxsO1xyXG4gICAgICAgIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3Rvcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBwcm90b3NbaV07XHJcbiAgICAgICAgICAgIHZhciBiaW5kaW5nUmVjb3JkID0gcHJvdG8uYmluZGluZ1JlY29yZDtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVJlY29yZCA9IGJpbmRpbmdSZWNvcmQuZGlyZWN0aXZlUmVjb3JkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZmlyc3RJbkJpbmRpbmcocHJvdG8pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5QmluZGluZ0luZGV4ID0gcHJvdG8ucHJvcGVydHlCaW5kaW5nSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3RvLmlzTGlmZUN5Y2xlUmVjb3JkKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90by5uYW1lID09PSBcIkRvQ2hlY2tcIiAmJiAhdGhyb3dPbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpLmRvQ2hlY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvLm5hbWUgPT09IFwiT25Jbml0XCIgJiYgIXRocm93T25DaGFuZ2UgJiYgIXRoaXMuYWxyZWFkeUNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXREaXJlY3RpdmVGb3IoZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4KS5vbkluaXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvLm5hbWUgPT09IFwiT25DaGFuZ2VzXCIgJiYgbGFuZ18xLmlzUHJlc2VudChjaGFuZ2VzKSAmJiAhdGhyb3dPbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpLm9uQ2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB0aGlzLl9jaGVjayhwcm90bywgdGhyb3dPbkNoYW5nZSwgdGhpcy52YWx1ZXMsIHRoaXMubG9jYWxzKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3RpdmVPckVsZW1lbnQoY2hhbmdlLCBiaW5kaW5nUmVjb3JkKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLl9hZGRDaGFuZ2UoYmluZGluZ1JlY29yZCwgY2hhbmdlLCBjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvdG8ubGFzdEluRGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQgJiYgIWJpbmRpbmdSZWNvcmQuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXREZXRlY3RvckZvcihkaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpLm1hcmtBc0NoZWNrT25jZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZmlyc3RJbkJpbmRpbmcgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBwcmV2ID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5wcm90b0J5SW5kZXgodGhpcy5fcmVjb3Jkcywgci5zZWxmSW5kZXggLSAxKTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsocHJldikgfHwgcHJldi5iaW5kaW5nUmVjb3JkICE9PSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGlycyA9IHRoaXMuX2RpcmVjdGl2ZVJlY29yZHM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRpcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdmFyIGRpciA9IGRpcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyQ29udGVudEluaXQgJiYgIXRoaXMuYWxyZWFkeUNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXIuZGlyZWN0aXZlSW5kZXgpLmFmdGVyQ29udGVudEluaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyLmNhbGxBZnRlckNvbnRlbnRDaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXREaXJlY3RpdmVGb3IoZGlyLmRpcmVjdGl2ZUluZGV4KS5hZnRlckNvbnRlbnRDaGVja2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGlycyA9IHRoaXMuX2RpcmVjdGl2ZVJlY29yZHM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRpcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdmFyIGRpciA9IGRpcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyVmlld0luaXQgJiYgIXRoaXMuYWxyZWFkeUNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXIuZGlyZWN0aXZlSW5kZXgpLmFmdGVyVmlld0luaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyLmNhbGxBZnRlclZpZXdDaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXREaXJlY3RpdmVGb3IoZGlyLmRpcmVjdGl2ZUluZGV4KS5hZnRlclZpZXdDaGVja2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fdXBkYXRlRGlyZWN0aXZlT3JFbGVtZW50ID0gZnVuY3Rpb24gKGNoYW5nZSwgYmluZGluZ1JlY29yZCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhiaW5kaW5nUmVjb3JkLmRpcmVjdGl2ZVJlY29yZCkpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5ub3RpZnlEaXNwYXRjaGVyLmNhbGwodGhpcywgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5kZXggPSBiaW5kaW5nUmVjb3JkLmRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleDtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZC5zZXR0ZXIodGhpcy5fZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZUluZGV4KSwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmxvZ0JpbmRpbmdVcGRhdGUuY2FsbCh0aGlzLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fYWRkQ2hhbmdlID0gZnVuY3Rpb24gKGJpbmRpbmdSZWNvcmQsIGNoYW5nZSwgY2hhbmdlcykge1xyXG4gICAgICAgIGlmIChiaW5kaW5nUmVjb3JkLmNhbGxPbkNoYW5nZXMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hZGRDaGFuZ2UuY2FsbCh0aGlzLCBjaGFuZ2VzLCBjaGFuZ2UucHJldmlvdXNWYWx1ZSwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZ2V0RGlyZWN0aXZlRm9yID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4KSB7IHJldHVybiB0aGlzLmRpcmVjdGl2ZXMuZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZUluZGV4KTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX2dldERldGVjdG9yRm9yID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4KSB7IHJldHVybiB0aGlzLmRpcmVjdGl2ZXMuZ2V0RGV0ZWN0b3JGb3IoZGlyZWN0aXZlSW5kZXgpOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fY2hlY2sgPSBmdW5jdGlvbiAocHJvdG8sIHRocm93T25DaGFuZ2UsIHZhbHVlcywgbG9jYWxzKSB7XHJcbiAgICAgICAgaWYgKHByb3RvLmlzUGlwZVJlY29yZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waXBlQ2hlY2socHJvdG8sIHRocm93T25DaGFuZ2UsIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlQ2hlY2socHJvdG8sIHRocm93T25DaGFuZ2UsIHZhbHVlcywgbG9jYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcmVmZXJlbmNlQ2hlY2sgPSBmdW5jdGlvbiAocHJvdG8sIHRocm93T25DaGFuZ2UsIHZhbHVlcywgbG9jYWxzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3B1cmVGdW5jQW5kQXJnc0RpZE5vdENoYW5nZShwcm90bykpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2hhbmdlZChwcm90bywgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJWYWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJWYWx1ZShwcm90bywgdmFsdWVzLCBsb2NhbHMpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0cmF0ZWd5ID09PSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hPYnNlcnZlKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub2JzZXJ2ZVZhbHVlLmNhbGwodGhpcywgY3VyclZhbHVlLCBwcm90by5zZWxmSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvdG8uc2hvdWxkQmVDaGVja2VkKCkpIHtcclxuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuX3JlYWRTZWxmKHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAoIWlzU2FtZShwcmV2VmFsdWUsIGN1cnJWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90by5sYXN0SW5CaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuc2ltcGxlQ2hhbmdlKHByZXZWYWx1ZSwgY3VyclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkNoYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd09uQ2hhbmdlRXJyb3IocHJldlZhbHVlLCBjdXJyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VsZihwcm90bywgY3VyclZhbHVlLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVNlbGYocHJvdG8sIGN1cnJWYWx1ZSwgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZVNlbGYocHJvdG8sIGN1cnJWYWx1ZSwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2hhbmdlZChwcm90bywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJyVmFsdWUgPSBmdW5jdGlvbiAocHJvdG8sIHZhbHVlcywgbG9jYWxzKSB7XHJcbiAgICAgICAgc3dpdGNoIChwcm90by5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TZWxmOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ29uc3Q6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uZnVuY09yVmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Qcm9wZXJ0eVJlYWQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLmZ1bmNPclZhbHVlKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2FmZVByb3BlcnR5OlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhjb250ZXh0KSA/IG51bGwgOiBwcm90by5mdW5jT3JWYWx1ZShjb250ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByb3BlcnR5V3JpdGU6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcylbMF07XHJcbiAgICAgICAgICAgICAgICBwcm90by5mdW5jT3JWYWx1ZShjb250ZXh0LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5LZXllZFdyaXRlOlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpWzFdO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Mb2NhbDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbHMuZ2V0KHByb3RvLm5hbWUpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW52b2tlTWV0aG9kOlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uZnVuY09yVmFsdWUoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TYWZlTWV0aG9kSW52b2tlOlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5mdW5jT3JWYWx1ZShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkUmVhZDpcclxuICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKVswXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKVthcmddO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ2hhaW46XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludm9rZUNsb3N1cmU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ18xLkZ1bmN0aW9uV3JhcHBlci5hcHBseSh0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKSwgdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcykpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW50ZXJwb2xhdGU6XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5QcmltaXRpdmVPcDpcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbGxlY3Rpb25MaXRlcmFsOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5GdW5jdGlvbldyYXBwZXIuYXBwbHkocHJvdG8uZnVuY09yVmFsdWUsIHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gb3BlcmF0aW9uIFwiICsgcHJvdG8ubW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3BpcGVDaGVjayA9IGZ1bmN0aW9uIChwcm90bywgdGhyb3dPbkNoYW5nZSwgdmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9yZWFkQ29udGV4dChwcm90bywgdmFsdWVzKTtcclxuICAgICAgICB2YXIgc2VsZWN0ZWRQaXBlID0gdGhpcy5fcGlwZUZvcihwcm90bywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZFBpcGUucHVyZSB8fCB0aGlzLl9hcmdzT3JDb250ZXh0Q2hhbmdlZChwcm90bykpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJWYWx1ZSA9IHNlbGVjdGVkUGlwZS5waXBlLnRyYW5zZm9ybShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKHByb3RvLnNob3VsZEJlQ2hlY2tlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5fcmVhZFNlbGYocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZShwcmV2VmFsdWUsIGN1cnJWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyVmFsdWUgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLnVud3JhcFZhbHVlKGN1cnJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3RvLmxhc3RJbkJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuc2ltcGxlQ2hhbmdlKHByZXZWYWx1ZSwgY3VyclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm93T25DaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93T25DaGFuZ2VFcnJvcihwcmV2VmFsdWUsIGN1cnJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VsZihwcm90bywgY3VyclZhbHVlLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VsZihwcm90bywgY3VyclZhbHVlLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2hhbmdlZChwcm90bywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWxmKHByb3RvLCBjdXJyVmFsdWUsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3BpcGVGb3IgPSBmdW5jdGlvbiAocHJvdG8sIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc3RvcmVkUGlwZSA9IHRoaXMuX3JlYWRQaXBlKHByb3RvKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG9yZWRQaXBlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlZFBpcGU7XHJcbiAgICAgICAgdmFyIHBpcGUgPSB0aGlzLnBpcGVzLmdldChwcm90by5uYW1lKTtcclxuICAgICAgICB0aGlzLl93cml0ZVBpcGUocHJvdG8sIHBpcGUpO1xyXG4gICAgICAgIHJldHVybiBwaXBlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3JlYWRDb250ZXh0ID0gZnVuY3Rpb24gKHByb3RvLCB2YWx1ZXMpIHtcclxuICAgICAgICBpZiAocHJvdG8uY29udGV4dEluZGV4ID09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREaXJlY3RpdmVGb3IocHJvdG8uZGlyZWN0aXZlSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1twcm90by5jb250ZXh0SW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzW3Byb3RvLmNvbnRleHRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcmVhZFNlbGYgPSBmdW5jdGlvbiAocHJvdG8sIHZhbHVlcykgeyByZXR1cm4gdmFsdWVzW3Byb3RvLnNlbGZJbmRleF07IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl93cml0ZVNlbGYgPSBmdW5jdGlvbiAocHJvdG8sIHZhbHVlLCB2YWx1ZXMpIHsgdmFsdWVzW3Byb3RvLnNlbGZJbmRleF0gPSB2YWx1ZTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3JlYWRQaXBlID0gZnVuY3Rpb24gKHByb3RvKSB7IHJldHVybiB0aGlzLmxvY2FsUGlwZXNbcHJvdG8uc2VsZkluZGV4XTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3dyaXRlUGlwZSA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWUpIHsgdGhpcy5sb2NhbFBpcGVzW3Byb3RvLnNlbGZJbmRleF0gPSB2YWx1ZTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3NldENoYW5nZWQgPSBmdW5jdGlvbiAocHJvdG8sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHByb3RvLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24pXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc1twcm90by5zZWxmSW5kZXhdID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcHVyZUZ1bmNBbmRBcmdzRGlkTm90Q2hhbmdlID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3RvLmlzUHVyZUZ1bmN0aW9uKCkgJiYgIXRoaXMuX2FyZ3NDaGFuZ2VkKHByb3RvKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9hcmdzQ2hhbmdlZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgIHZhciBhcmdzID0gcHJvdG8uYXJncztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlc1thcmdzW2ldXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX2FyZ3NPckNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FyZ3NDaGFuZ2VkKHByb3RvKSB8fCB0aGlzLmNoYW5nZXNbcHJvdG8uY29udGV4dEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9yZWFkQXJncyA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocHJvdG8uYXJncy5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBhcmdzID0gcHJvdG8uYXJncztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gdmFsdWVzW2FyZ3NbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEeW5hbWljQ2hhbmdlRGV0ZWN0b3I7XHJcbn0pKGFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvcl8xLkFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IpO1xyXG5leHBvcnRzLkR5bmFtaWNDaGFuZ2VEZXRlY3RvciA9IER5bmFtaWNDaGFuZ2VEZXRlY3RvcjtcclxuZnVuY3Rpb24gaXNTYW1lKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBTdHJpbmcgJiYgYiBpbnN0YW5jZW9mIFN0cmluZyAmJiBhID09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoKGEgIT09IGEpICYmIChiICE9PSBiKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljX2NoYW5nZV9kZXRlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIEV2ZW50QmluZGluZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEJpbmRpbmcoZXZlbnROYW1lLCBlbEluZGV4LCBkaXJJbmRleCwgcmVjb3Jkcykge1xyXG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xyXG4gICAgICAgIHRoaXMuZWxJbmRleCA9IGVsSW5kZXg7XHJcbiAgICAgICAgdGhpcy5kaXJJbmRleCA9IGRpckluZGV4O1xyXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRXZlbnRCaW5kaW5nO1xyXG59KSgpO1xyXG5leHBvcnRzLkV2ZW50QmluZGluZyA9IEV2ZW50QmluZGluZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRfYmluZGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9uc1wiKTtcclxuLyoqXHJcbiAqIEFuIGVycm9yIHRocm93biBpZiBhcHBsaWNhdGlvbiBjaGFuZ2VzIG1vZGVsIGJyZWFraW5nIHRoZSB0b3AtZG93biBkYXRhIGZsb3cuXHJcbiAqXHJcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIG9ubHkgdGhyb3duIGluIGRldiBtb2RlLlxyXG4gKlxyXG4gKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgb25jZSB0aGUgZGV2IG1vZGUgb3B0aW9uIGlzIGNvbmZpZ3VyYWJsZSAtLT5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3BhcmVudCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxjaGlsZCBbcHJvcF09XCJwYXJlbnRQcm9wXCI+PC9jaGlsZD5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtmb3J3YXJkUmVmKCgpID0+IENoaWxkKV1cclxuICogfSlcclxuICogY2xhc3MgUGFyZW50IHtcclxuICogICBwYXJlbnRQcm9wID0gXCJpbml0XCI7XHJcbiAqIH1cclxuICpcclxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxyXG4gKiBjbGFzcyBDaGlsZCB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIHBhcmVudDogUGFyZW50KSB7fVxyXG4gKlxyXG4gKiAgIHNldCBwcm9wKHYpIHtcclxuICogICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgcGFyZW50IHByb3BlcnR5LCB3aGljaCBpcyBkaXNhbGxvd2VkIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAqICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uXHJcbiAqICAgICB0aGlzLnBhcmVudC5wYXJlbnRQcm9wID0gXCJ1cGRhdGVkXCI7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uKGV4cCwgb2xkVmFsdWUsIGN1cnJWYWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIChcIkV4cHJlc3Npb24gJ1wiICsgZXhwICsgXCInIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBcIikgK1xyXG4gICAgICAgICAgICAoXCJQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJ1wiKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb247XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbiA9IEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gYW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uIHJhaXNlcyBhbiBleGNlcHRpb24uXHJcbiAqXHJcbiAqIFRoaXMgZXJyb3Igd3JhcHMgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbiB0byBhdHRhY2ggYWRkaXRpb25hbCBjb250ZXh0dWFsIGluZm9ybWF0aW9uIHRoYXQgY2FuXHJcbiAqIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvMkt5d296P3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxyXG4gKiBjbGFzcyBDaGlsZCB7XHJcbiAqICAgcHJvcDtcclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxjaGlsZCBbcHJvcF09XCJmaWVsZC5maXJzdFwiPjwvY2hpbGQ+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbQ2hpbGRdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7XHJcbiAqICAgZmllbGQgPSBudWxsO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHApO1xyXG4gKiBgYGBcclxuICpcclxuICogWW91IGNhbiBhY2Nlc3MgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbiBhbmQgc3RhY2sgdGhyb3VnaCB0aGUgYG9yaWdpbmFsRXhjZXB0aW9uYCBhbmRcclxuICogYG9yaWdpbmFsU3RhY2tgIHByb3BlcnRpZXMuXHJcbiAqL1xyXG52YXIgQ2hhbmdlRGV0ZWN0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENoYW5nZURldGVjdGlvbkVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uRXJyb3IoZXhwLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG9yaWdpbmFsRXhjZXB0aW9uICsgXCIgaW4gW1wiICsgZXhwICsgXCJdXCIsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmxvY2F0aW9uID0gZXhwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdGlvbkVycm9yO1xyXG59KShleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uRXJyb3IgPSBDaGFuZ2VEZXRlY3Rpb25FcnJvcjtcclxuLyoqXHJcbiAqIFRocm93biB3aGVuIGNoYW5nZSBkZXRlY3RvciBleGVjdXRlcyBvbiBkZWh5ZHJhdGVkIHZpZXcuXHJcbiAqXHJcbiAqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIGEgYnVnIGluIHRoZSBmcmFtZXdvcmsuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgQW5ndWxhciBlcnJvci5cclxuICovXHJcbnZhciBEZWh5ZHJhdGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWh5ZHJhdGVkRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVoeWRyYXRlZEV4Y2VwdGlvbigpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdCB0byBkZXRlY3QgY2hhbmdlcyBvbiBhIGRlaHlkcmF0ZWQgZGV0ZWN0b3IuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGVoeWRyYXRlZEV4Y2VwdGlvbjtcclxufSkoZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pO1xyXG5leHBvcnRzLkRlaHlkcmF0ZWRFeGNlcHRpb24gPSBEZWh5ZHJhdGVkRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNlcHRpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgRGVidWdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlYnVnQ29udGV4dChlbGVtZW50LCBjb21wb25lbnRFbGVtZW50LCBkaXJlY3RpdmUsIGNvbnRleHQsIGxvY2FscywgaW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50RWxlbWVudCA9IGNvbXBvbmVudEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLmxvY2FscyA9IGxvY2FscztcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGVidWdDb250ZXh0O1xyXG59KSgpO1xyXG5leHBvcnRzLkRlYnVnQ29udGV4dCA9IERlYnVnQ29udGV4dDtcclxudmFyIENoYW5nZURldGVjdG9yR2VuQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdG9yR2VuQ29uZmlnKGdlbkNoZWNrTm9DaGFuZ2VzLCBnZW5EZWJ1Z0luZm8sIGxvZ0JpbmRpbmdVcGRhdGUsIHVzZUppdCkge1xyXG4gICAgICAgIHRoaXMuZ2VuQ2hlY2tOb0NoYW5nZXMgPSBnZW5DaGVja05vQ2hhbmdlcztcclxuICAgICAgICB0aGlzLmdlbkRlYnVnSW5mbyA9IGdlbkRlYnVnSW5mbztcclxuICAgICAgICB0aGlzLmxvZ0JpbmRpbmdVcGRhdGUgPSBsb2dCaW5kaW5nVXBkYXRlO1xyXG4gICAgICAgIHRoaXMudXNlSml0ID0gdXNlSml0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdG9yR2VuQ29uZmlnO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9yR2VuQ29uZmlnID0gQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWc7XHJcbnZhciBDaGFuZ2VEZXRlY3RvckRlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uKGlkLCBzdHJhdGVneSwgdmFyaWFibGVOYW1lcywgYmluZGluZ1JlY29yZHMsIGV2ZW50UmVjb3JkcywgZGlyZWN0aXZlUmVjb3JkcywgZ2VuQ29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSB2YXJpYWJsZU5hbWVzO1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1JlY29yZHMgPSBiaW5kaW5nUmVjb3JkcztcclxuICAgICAgICB0aGlzLmV2ZW50UmVjb3JkcyA9IGV2ZW50UmVjb3JkcztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZVJlY29yZHMgPSBkaXJlY3RpdmVSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuZ2VuQ29uZmlnID0gZ2VuQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdG9yRGVmaW5pdGlvbjtcclxufSkoKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvckRlZmluaXRpb24gPSBDaGFuZ2VEZXRlY3RvckRlZmluaXRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3JfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yJyk7XHJcbnZhciBKaXRQcm90b0NoYW5nZURldGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEppdFByb3RvQ2hhbmdlRGV0ZWN0b3IoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XHJcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IHRoaXMuX2NyZWF0ZUZhY3RvcnkoZGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBKaXRQcm90b0NoYW5nZURldGVjdG9yLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIEppdFByb3RvQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsgcmV0dXJuIHRoaXMuX2ZhY3RvcnkoZGlzcGF0Y2hlcik7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBKaXRQcm90b0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3JfMS5DaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvcihkZWZpbml0aW9uLCAndXRpbCcsICdBYnN0cmFjdENoYW5nZURldGVjdG9yJykuZ2VuZXJhdGUoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSml0UHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxufSkoKTtcclxuZXhwb3J0cy5KaXRQcm90b0NoYW5nZURldGVjdG9yID0gSml0UHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aml0X3Byb3RvX2NoYW5nZV9kZXRlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5pc09ic2VydmFibGUgPSBpc09ic2VydmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGVfZmFjYWRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nXCIpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uXCIpO1xyXG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFTVCgpIHtcclxuICAgIH1cclxuICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIEFTVC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkFTVFwiOyB9O1xyXG4gICAgcmV0dXJuIEFTVDtcclxufSkoKTtcclxuZXhwb3J0cy5BU1QgPSBBU1Q7XHJcbnZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVtcHR5RXhwciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVtcHR5RXhwcigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIEVtcHR5RXhwci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1wdHlFeHByO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkVtcHR5RXhwciA9IEVtcHR5RXhwcjtcclxudmFyIEltcGxpY2l0UmVjZWl2ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEltcGxpY2l0UmVjZWl2ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgSW1wbGljaXRSZWNlaXZlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcyk7IH07XHJcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5JbXBsaWNpdFJlY2VpdmVyID0gSW1wbGljaXRSZWNlaXZlcjtcclxuLyoqXHJcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cclxuICovXHJcbnZhciBDaGFpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDaGFpbihleHByZXNzaW9ucykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuICAgIH1cclxuICAgIENoYWluLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q2hhaW4odGhpcyk7IH07XHJcbiAgICByZXR1cm4gQ2hhaW47XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuQ2hhaW4gPSBDaGFpbjtcclxudmFyIENvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnRydWVFeHAgPSB0cnVlRXhwO1xyXG4gICAgICAgIHRoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcclxuICAgIH1cclxuICAgIENvbmRpdGlvbmFsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcyk7IH07XHJcbiAgICByZXR1cm4gQ29uZGl0aW9uYWw7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuQ29uZGl0aW9uYWwgPSBDb25kaXRpb25hbDtcclxudmFyIElmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIElmKGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnRydWVFeHAgPSB0cnVlRXhwO1xyXG4gICAgICAgIHRoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcclxuICAgIH1cclxuICAgIElmLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWYodGhpcyk7IH07XHJcbiAgICByZXR1cm4gSWY7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuSWYgPSBJZjtcclxudmFyIFByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBuYW1lLCBnZXR0ZXIpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcclxuICAgIH1cclxuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5UmVhZCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBQcm9wZXJ0eVJlYWQ7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuUHJvcGVydHlSZWFkID0gUHJvcGVydHlSZWFkO1xyXG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUHJvcGVydHlXcml0ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUocmVjZWl2ZXIsIG5hbWUsIHNldHRlciwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBQcm9wZXJ0eVdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlXcml0ZSh0aGlzKTsgfTtcclxuICAgIHJldHVybiBQcm9wZXJ0eVdyaXRlO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLlByb3BlcnR5V3JpdGUgPSBQcm9wZXJ0eVdyaXRlO1xyXG52YXIgU2FmZVByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2FmZVByb3BlcnR5UmVhZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNhZmVQcm9wZXJ0eVJlYWQocmVjZWl2ZXIsIG5hbWUsIGdldHRlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgfVxyXG4gICAgU2FmZVByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcyk7IH07XHJcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5TYWZlUHJvcGVydHlSZWFkID0gU2FmZVByb3BlcnR5UmVhZDtcclxudmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gS2V5ZWRSZWFkKG9iaiwga2V5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICB9XHJcbiAgICBLZXllZFJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcyk7IH07XHJcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLktleWVkUmVhZCA9IEtleWVkUmVhZDtcclxudmFyIEtleWVkV3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEtleWVkV3JpdGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBLZXllZFdyaXRlKG9iaiwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIEtleWVkV3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFdyaXRlKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIEtleWVkV3JpdGU7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuS2V5ZWRXcml0ZSA9IEtleWVkV3JpdGU7XHJcbnZhciBCaW5kaW5nUGlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmluZGluZ1BpcGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCaW5kaW5nUGlwZShleHAsIG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmV4cCA9IGV4cDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICB9XHJcbiAgICBCaW5kaW5nUGlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFBpcGUodGhpcyk7IH07XHJcbiAgICByZXR1cm4gQmluZGluZ1BpcGU7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuQmluZGluZ1BpcGUgPSBCaW5kaW5nUGlwZTtcclxudmFyIExpdGVyYWxQcmltaXRpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXRlcmFsUHJpbWl0aXZlKHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgTGl0ZXJhbFByaW1pdGl2ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxQcmltaXRpdmUodGhpcyk7IH07XHJcbiAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5MaXRlcmFsUHJpbWl0aXZlID0gTGl0ZXJhbFByaW1pdGl2ZTtcclxudmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbEFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG4gICAgfVxyXG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5KHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIExpdGVyYWxBcnJheTtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5MaXRlcmFsQXJyYXkgPSBMaXRlcmFsQXJyYXk7XHJcbnZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGl0ZXJhbE1hcChrZXlzLCB2YWx1ZXMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgfVxyXG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXAodGhpcyk7IH07XHJcbiAgICByZXR1cm4gTGl0ZXJhbE1hcDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5MaXRlcmFsTWFwID0gTGl0ZXJhbE1hcDtcclxudmFyIEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEludGVycG9sYXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcbiAgICB9XHJcbiAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XHJcbnZhciBCaW5hcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJpbmFyeShvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICBCaW5hcnkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcyk7IH07XHJcbiAgICByZXR1cm4gQmluYXJ5O1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkJpbmFyeSA9IEJpbmFyeTtcclxudmFyIFByZWZpeE5vdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUHJlZml4Tm90LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZml4Tm90KGV4cHJlc3Npb24pIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgUHJlZml4Tm90LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIFByZWZpeE5vdDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5QcmVmaXhOb3QgPSBQcmVmaXhOb3Q7XHJcbnZhciBNZXRob2RDYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZXRob2RDYWxsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChyZWNlaXZlciwgbmFtZSwgZm4sIGFyZ3MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmZuID0gZm47XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIE1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRNZXRob2RDYWxsKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIE1ldGhvZENhbGw7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuTWV0aG9kQ2FsbCA9IE1ldGhvZENhbGw7XHJcbnZhciBTYWZlTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2FmZU1ldGhvZENhbGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTYWZlTWV0aG9kQ2FsbChyZWNlaXZlciwgbmFtZSwgZm4sIGFyZ3MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmZuID0gZm47XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZU1ldGhvZENhbGwodGhpcyk7IH07XHJcbiAgICByZXR1cm4gU2FmZU1ldGhvZENhbGw7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuU2FmZU1ldGhvZENhbGwgPSBTYWZlTWV0aG9kQ2FsbDtcclxudmFyIEZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHRhcmdldCwgYXJncykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICB9XHJcbiAgICBGdW5jdGlvbkNhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGwodGhpcyk7IH07XHJcbiAgICByZXR1cm4gRnVuY3Rpb25DYWxsO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkZ1bmN0aW9uQ2FsbCA9IEZ1bmN0aW9uQ2FsbDtcclxudmFyIEFTVFdpdGhTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCBsb2NhdGlvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIEFTVFdpdGhTb3VyY2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IpOyB9O1xyXG4gICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcclxuICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkFTVFdpdGhTb3VyY2UgPSBBU1RXaXRoU291cmNlO1xyXG52YXIgVGVtcGxhdGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5rZXlJc1ZhciA9IGtleUlzVmFyO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVtcGxhdGVCaW5kaW5nID0gVGVtcGxhdGVCaW5kaW5nO1xyXG52YXIgUmVjdXJzaXZlQXN0VmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVBc3RWaXNpdG9yKCkge1xyXG4gICAgfVxyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XHJcbiAgICAgICAgYXN0LnJpZ2h0LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XHJcbiAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWYgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LnRhcmdldC52aXNpdCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XHJcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTsgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcyk7IH0pO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSBSZWN1cnNpdmVBc3RWaXNpdG9yO1xyXG52YXIgQXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXN0VHJhbnNmb3JtZXIoKSB7XHJcbiAgICB9XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0OyB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnN0cmluZ3MsIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUoYXN0LnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LmdldHRlcik7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LnNldHRlciwgYXN0LnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZChhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3QuZ2V0dGVyKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kQ2FsbChhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3QuZm4sIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC5mbiwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChhc3QudGFyZ2V0LnZpc2l0KHRoaXMpLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LmtleXMsIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcykpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Qub3BlcmF0aW9uLCBhc3QubGVmdC52aXNpdCh0aGlzKSwgYXN0LnJpZ2h0LnZpc2l0KHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpKTsgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwoYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKSwgYXN0LnRydWVFeHAudmlzaXQodGhpcyksIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdQaXBlKGFzdC5leHAudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5vYmoudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFdyaXRlKGFzdC5vYmoudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcyksIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcclxuICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShhc3RzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBuZXcgQ2hhaW4odGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTsgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdElmID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBmYWxzZUV4cCA9IGxhbmdfMS5pc1ByZXNlbnQoYXN0LmZhbHNlRXhwKSA/IGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJZihhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgZmFsc2VFeHApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBc3RUcmFuc2Zvcm1lcjtcclxufSkoKTtcclxuZXhwb3J0cy5Bc3RUcmFuc2Zvcm1lciA9IEFzdFRyYW5zZm9ybWVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9kZWNvcmF0b3JzJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb25cIik7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmdcIik7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG4oZnVuY3Rpb24gKFRva2VuVHlwZSkge1xyXG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcclxuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJJZGVudGlmaWVyXCJdID0gMV0gPSBcIklkZW50aWZpZXJcIjtcclxuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJLZXl3b3JkXCJdID0gMl0gPSBcIktleXdvcmRcIjtcclxuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XHJcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiT3BlcmF0b3JcIl0gPSA0XSA9IFwiT3BlcmF0b3JcIjtcclxuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJOdW1iZXJcIl0gPSA1XSA9IFwiTnVtYmVyXCI7XHJcbn0pKGV4cG9ydHMuVG9rZW5UeXBlIHx8IChleHBvcnRzLlRva2VuVHlwZSA9IHt9KSk7XHJcbnZhciBUb2tlblR5cGUgPSBleHBvcnRzLlRva2VuVHlwZTtcclxudmFyIExleGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExleGVyKCkge1xyXG4gICAgfVxyXG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcclxuICAgICAgICB2YXIgdG9rZW5zID0gW107XHJcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcclxuICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH07XHJcbiAgICBMZXhlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlY29yYXRvcnNfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBMZXhlcik7XHJcbiAgICByZXR1cm4gTGV4ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTGV4ZXIgPSBMZXhlcjtcclxudmFyIFRva2VuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XHJcbiAgICAgICAgdGhpcy5zdHJWYWx1ZSA9IHN0clZhbHVlO1xyXG4gICAgfVxyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuQ2hhcmFjdGVyICYmIHRoaXMubnVtVmFsdWUgPT0gY29kZSk7XHJcbiAgICB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLlN0cmluZyk7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvciAmJiB0aGlzLnN0clZhbHVlID09IG9wZXJhdGVyKTtcclxuICAgIH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuSWRlbnRpZmllcik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCk7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVmFyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwidmFyXCIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZE51bGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJudWxsXCIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwidW5kZWZpbmVkXCIpO1xyXG4gICAgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUcnVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwidHJ1ZVwiKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRJZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcImlmXCIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEVsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJlbHNlXCIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEZhbHNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwiZmFsc2VcIik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gLTEgaW5zdGVhZCBvZiBOVUxMIG9rP1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXIpID8gdGhpcy5udW1WYWx1ZSA6IC0xO1xyXG4gICAgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5DaGFyYWN0ZXI6XHJcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLktleXdvcmQ6XHJcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk9wZXJhdG9yOlxyXG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJWYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVG9rZW47XHJcbn0pKCk7XHJcbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcclxuZnVuY3Rpb24gbmV3Q2hhcmFjdGVyVG9rZW4oaW5kZXgsIGNvZGUpIHtcclxuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5DaGFyYWN0ZXIsIGNvZGUsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShjb2RlKSk7XHJcbn1cclxuZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCB0ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuSWRlbnRpZmllciwgMCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbmV3S2V5d29yZFRva2VuKGluZGV4LCB0ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuS2V5d29yZCwgMCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBuZXdTdHJpbmdUb2tlbihpbmRleCwgdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLlN0cmluZywgMCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbmV3TnVtYmVyVG9rZW4oaW5kZXgsIG4pIHtcclxuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5OdW1iZXIsIG4sIFwiXCIpO1xyXG59XHJcbmV4cG9ydHMuRU9GID0gbmV3IFRva2VuKC0xLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCAwLCBcIlwiKTtcclxuZXhwb3J0cy4kRU9GID0gMDtcclxuZXhwb3J0cy4kVEFCID0gOTtcclxuZXhwb3J0cy4kTEYgPSAxMDtcclxuZXhwb3J0cy4kVlRBQiA9IDExO1xyXG5leHBvcnRzLiRGRiA9IDEyO1xyXG5leHBvcnRzLiRDUiA9IDEzO1xyXG5leHBvcnRzLiRTUEFDRSA9IDMyO1xyXG5leHBvcnRzLiRCQU5HID0gMzM7XHJcbmV4cG9ydHMuJERRID0gMzQ7XHJcbmV4cG9ydHMuJEhBU0ggPSAzNTtcclxuZXhwb3J0cy4kJCA9IDM2O1xyXG5leHBvcnRzLiRQRVJDRU5UID0gMzc7XHJcbmV4cG9ydHMuJEFNUEVSU0FORCA9IDM4O1xyXG5leHBvcnRzLiRTUSA9IDM5O1xyXG5leHBvcnRzLiRMUEFSRU4gPSA0MDtcclxuZXhwb3J0cy4kUlBBUkVOID0gNDE7XHJcbmV4cG9ydHMuJFNUQVIgPSA0MjtcclxuZXhwb3J0cy4kUExVUyA9IDQzO1xyXG5leHBvcnRzLiRDT01NQSA9IDQ0O1xyXG5leHBvcnRzLiRNSU5VUyA9IDQ1O1xyXG5leHBvcnRzLiRQRVJJT0QgPSA0NjtcclxuZXhwb3J0cy4kU0xBU0ggPSA0NztcclxuZXhwb3J0cy4kQ09MT04gPSA1ODtcclxuZXhwb3J0cy4kU0VNSUNPTE9OID0gNTk7XHJcbmV4cG9ydHMuJExUID0gNjA7XHJcbmV4cG9ydHMuJEVRID0gNjE7XHJcbmV4cG9ydHMuJEdUID0gNjI7XHJcbmV4cG9ydHMuJFFVRVNUSU9OID0gNjM7XHJcbnZhciAkMCA9IDQ4O1xyXG52YXIgJDkgPSA1NztcclxudmFyICRBID0gNjUsICRFID0gNjksICRaID0gOTA7XHJcbmV4cG9ydHMuJExCUkFDS0VUID0gOTE7XHJcbmV4cG9ydHMuJEJBQ0tTTEFTSCA9IDkyO1xyXG5leHBvcnRzLiRSQlJBQ0tFVCA9IDkzO1xyXG52YXIgJENBUkVUID0gOTQ7XHJcbnZhciAkXyA9IDk1O1xyXG52YXIgJGEgPSA5NywgJGUgPSAxMDEsICRmID0gMTAyLCAkbiA9IDExMCwgJHIgPSAxMTQsICR0ID0gMTE2LCAkdSA9IDExNywgJHYgPSAxMTgsICR6ID0gMTIyO1xyXG5leHBvcnRzLiRMQlJBQ0UgPSAxMjM7XHJcbmV4cG9ydHMuJEJBUiA9IDEyNDtcclxuZXhwb3J0cy4kUkJSQUNFID0gMTI1O1xyXG52YXIgJE5CU1AgPSAxNjA7XHJcbnZhciBTY2FubmVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNjYW5uZXJFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNjYW5uZXJFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIFNjYW5uZXJFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lc3NhZ2U7IH07XHJcbiAgICByZXR1cm4gU2Nhbm5lckVycm9yO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuU2Nhbm5lckVycm9yID0gU2Nhbm5lckVycm9yO1xyXG52YXIgX1NjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX1NjYW5uZXIoaW5wdXQpIHtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5wZWVrID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICB9XHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBlZWsgPVxyXG4gICAgICAgICAgICArK3RoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGggPyBleHBvcnRzLiRFT0YgOiBsYW5nXzEuU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0KHRoaXMuaW5wdXQsIHRoaXMuaW5kZXgpO1xyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dCwgbGVuZ3RoID0gdGhpcy5sZW5ndGgsIHBlZWsgPSB0aGlzLnBlZWssIGluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXHJcbiAgICAgICAgd2hpbGUgKHBlZWsgPD0gZXhwb3J0cy4kU1BBQ0UpIHtcclxuICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwZWVrID0gZXhwb3J0cy4kRU9GO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZWVrID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChpbnB1dCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGVlayA9IHBlZWs7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cclxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcbiAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGluZGV4O1xyXG4gICAgICAgIHN3aXRjaCAocGVlaykge1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFBFUklPRDpcclxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGlnaXQodGhpcy5wZWVrKSA/IHRoaXMuc2Nhbk51bWJlcihzdGFydCkgOiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgZXhwb3J0cy4kUEVSSU9EKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRMUEFSRU46XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUlBBUkVOOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJExCUkFDRTpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRSQlJBQ0U6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kTEJSQUNLRVQ6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUkJSQUNLRVQ6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQ09NTUE6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQ09MT046XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU0VNSUNPTE9OOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU1E6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kRFE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kSEFTSDpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRQTFVTOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJE1JTlVTOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFNUQVI6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU0xBU0g6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUEVSQ0VOVDpcclxuICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUVVFU1RJT046XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnPycsIGV4cG9ydHMuJFBFUklPRCwgJy4nKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRMVDpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRHVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSwgZXhwb3J0cy4kRVEsICc9Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQkFORzpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRFUTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSwgZXhwb3J0cy4kRVEsICc9JywgZXhwb3J0cy4kRVEsICc9Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQU1QRVJTQU5EOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJyYnLCBleHBvcnRzLiRBTVBFUlNBTkQsICcmJyk7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQkFSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCBleHBvcnRzLiRCQVIsICd8Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgJE5CU1A6XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKHRoaXMucGVlaykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVG9rZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFtcIiArIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSArIFwiXVwiLCAwKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNoYXJhY3RlciA9IGZ1bmN0aW9uIChzdGFydCwgY29kZSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnBlZWsgPT0gY29kZSk7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCBjb2RlKTtcclxuICAgIH07XHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBzdHIpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5wZWVrID09IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQoc3RyLCAwKSk7XHJcbiAgICAgICAgYXNzZXJ0KGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhPUEVSQVRPUlMsIHN0cikpO1xyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IGluZGV4IGluIHRoZSBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxyXG4gICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcclxuICAgICAqIEBwYXJhbSB0d28gc2Vjb25kIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiB0aGUgc2Vjb25kIGNvZGUgcG9pbnQgbWF0Y2hlcylcclxuICAgICAqIEBwYXJhbSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxyXG4gICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcclxuICAgICAqIEByZXR1cm5zIHtUb2tlbn1cclxuICAgICAqL1xyXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMucGVlayA9PSBsYW5nXzEuU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0KG9uZSwgMCkpO1xyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHZhciBzdHIgPSBvbmU7XHJcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PSB0d29Db2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICBzdHIgKz0gdHdvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aHJlZUNvZGUpICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHN0ciArPSB0aHJlZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhPUEVSQVRPUlMsIHN0cikpO1xyXG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhc3NlcnQoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5wZWVrKSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxyXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMoS0VZV09SRFMsIHN0cikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0tleXdvcmRUb2tlbihzdGFydCwgc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcbiAgICAgICAgYXNzZXJ0KGlzRGlnaXQodGhpcy5wZWVrKSk7XHJcbiAgICAgICAgdmFyIHNpbXBsZSA9ICh0aGlzLmluZGV4ID09PSBzdGFydCk7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEaWdpdCh0aGlzLnBlZWspKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09IGV4cG9ydHMuJFBFUklPRCkge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvbmVudFN0YXJ0KHRoaXMucGVlaykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRXhwb25lbnRTaWduKHRoaXMucGVlaykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdJbnZhbGlkIGV4cG9uZW50JywgLTEpO1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgdmFyIHZhbHVlID0gc2ltcGxlID8gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlRmxvYXQoc3RyKTtcclxuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5wZWVrID09IGV4cG9ydHMuJFNRIHx8IHRoaXMucGVlayA9PSBleHBvcnRzLiREUSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnBlZWs7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cclxuICAgICAgICB2YXIgYnVmZmVyO1xyXG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrID09IGV4cG9ydHMuJEJBQ0tTTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBsYW5nXzEuU3RyaW5nSm9pbmVyKCk7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZENvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICR1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnQoaGV4LCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQobGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpKTtcclxuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09IGV4cG9ydHMuJEVPRikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHVuZXNjYXBlZCBzdHJpbmcgdmFsdWUuXHJcbiAgICAgICAgdmFyIHVuZXNjYXBlZCA9IGxhc3Q7XHJcbiAgICAgICAgaWYgKGJ1ZmZlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5hZGQobGFzdCk7XHJcbiAgICAgICAgICAgIHVuZXNjYXBlZCA9IGJ1ZmZlci50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHVuZXNjYXBlZCk7XHJcbiAgICB9O1xyXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XHJcbiAgICAgICAgdGhyb3cgbmV3IFNjYW5uZXJFcnJvcihcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX1NjYW5uZXI7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XHJcbiAgICByZXR1cm4gKGNvZGUgPj0gZXhwb3J0cy4kVEFCICYmIGNvZGUgPD0gZXhwb3J0cy4kU1BBQ0UpIHx8IChjb2RlID09ICROQlNQKTtcclxufVxyXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XHJcbiAgICByZXR1cm4gKCRhIDw9IGNvZGUgJiYgY29kZSA8PSAkeikgfHwgKCRBIDw9IGNvZGUgJiYgY29kZSA8PSAkWikgfHwgKGNvZGUgPT0gJF8pIHx8IChjb2RlID09IGV4cG9ydHMuJCQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY29kZSkge1xyXG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8ICgkMCA8PSBjb2RlICYmIGNvZGUgPD0gJDkpIHx8XHJcbiAgICAgICAgKGNvZGUgPT0gJF8pIHx8IChjb2RlID09IGV4cG9ydHMuJCQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xyXG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcclxufVxyXG5mdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPT0gJGUgfHwgY29kZSA9PSAkRTtcclxufVxyXG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA9PSBleHBvcnRzLiRNSU5VUyB8fCBjb2RlID09IGV4cG9ydHMuJFBMVVM7XHJcbn1cclxuZnVuY3Rpb24gdW5lc2NhcGUoY29kZSkge1xyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgY2FzZSAkbjpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuJExGO1xyXG4gICAgICAgIGNhc2UgJGY6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLiRGRjtcclxuICAgICAgICBjYXNlICRyOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kQ1I7XHJcbiAgICAgICAgY2FzZSAkdDpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuJFRBQjtcclxuICAgICAgICBjYXNlICR2OlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kVlRBQjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH1cclxufVxyXG52YXIgT1BFUkFUT1JTID0gY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuY3JlYXRlRnJvbUxpc3QoW1xyXG4gICAgJysnLFxyXG4gICAgJy0nLFxyXG4gICAgJyonLFxyXG4gICAgJy8nLFxyXG4gICAgJyUnLFxyXG4gICAgJ14nLFxyXG4gICAgJz0nLFxyXG4gICAgJz09JyxcclxuICAgICchPScsXHJcbiAgICAnPT09JyxcclxuICAgICchPT0nLFxyXG4gICAgJzwnLFxyXG4gICAgJz4nLFxyXG4gICAgJzw9JyxcclxuICAgICc+PScsXHJcbiAgICAnJiYnLFxyXG4gICAgJ3x8JyxcclxuICAgICcmJyxcclxuICAgICd8JyxcclxuICAgICchJyxcclxuICAgICc/JyxcclxuICAgICcjJyxcclxuICAgICc/LidcclxuXSk7XHJcbnZhciBLRVlXT1JEUyA9IGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmNyZWF0ZUZyb21MaXN0KFsndmFyJywgJ251bGwnLCAndW5kZWZpbmVkJywgJ3RydWUnLCAnZmFsc2UnLCAnaWYnLCAnZWxzZSddKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBMb2NhbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9jYWxzKHBhcmVudCwgY3VycmVudCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBMb2NhbHMucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jb250YWlucyhuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIExvY2Fscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmdldChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kICdcIiArIG5hbWUgKyBcIidcIik7XHJcbiAgICB9O1xyXG4gICAgTG9jYWxzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAvLyBUT0RPKHJhZG8pOiBjb25zaWRlciByZW1vdmluZyB0aGlzIGNoZWNrIGlmIHdlIGNhbiBndWFyYW50ZWUgdGhpcyBpcyBub3RcclxuICAgICAgICAvLyBleHBvc2VkIHRvIHRoZSBwdWJsaWMgQVBJLlxyXG4gICAgICAgIC8vIFRPRE86IHZzYXZraW4gbWF5YmUgaXQgc2hvdWxkIGNoZWNrIG9ubHkgdGhlIGxvY2FsIG1hcFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXQobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiU2V0dGluZyBvZiBuZXcga2V5cyBwb3N0LWNvbnN0cnVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkLiBLZXk6IFwiICsgbmFtZSArIFwiLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9jYWxzLnByb3RvdHlwZS5jbGVhclZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIuY2xlYXJWYWx1ZXModGhpcy5jdXJyZW50KTsgfTtcclxuICAgIHJldHVybiBMb2NhbHM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9jYWxzID0gTG9jYWxzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9kZWNvcmF0b3JzJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsZXhlcl8xID0gcmVxdWlyZSgnLi9sZXhlcicpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciBhc3RfMSA9IHJlcXVpcmUoJy4vYXN0Jyk7XHJcbnZhciBfaW1wbGljaXRSZWNlaXZlciA9IG5ldyBhc3RfMS5JbXBsaWNpdFJlY2VpdmVyKCk7XHJcbi8vIFRPRE8odGJvc2NoKTogQ2Fubm90IG1ha2UgdGhpcyBjb25zdC9maW5hbCByaWdodCBub3cgYmVjYXVzZSBvZiB0aGUgdHJhbnNwaWxlci4uLlxyXG52YXIgSU5URVJQT0xBVElPTl9SRUdFWFAgPSAvXFx7XFx7KC4qPylcXH1cXH0vZztcclxudmFyIFBhcnNlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYXJzZUV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhcnNlRXhjZXB0aW9uKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIlBhcnNlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgXCIgKyBlcnJMb2NhdGlvbiArIFwiIFtcIiArIGlucHV0ICsgXCJdIGluIFwiICsgY3R4TG9jYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBhcnNlRXhjZXB0aW9uO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGFyc2VyKC8qKiBAaW50ZXJuYWwgKi8gX2xleGVyLCBwcm92aWRlZFJlZmxlY3Rvcikge1xyXG4gICAgICAgIGlmIChwcm92aWRlZFJlZmxlY3RvciA9PT0gdm9pZCAwKSB7IHByb3ZpZGVkUmVmbGVjdG9yID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xyXG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZWRSZWZsZWN0b3IpID8gcHJvdmlkZWRSZWZsZWN0b3IgOiByZWZsZWN0aW9uXzEucmVmbGVjdG9yO1xyXG4gICAgfVxyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24pO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XHJcbiAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRoaXMuX3JlZmxlY3RvciwgdHJ1ZSkucGFyc2VDaGFpbigpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uKTtcclxuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQpO1xyXG4gICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCB0aGlzLl9yZWZsZWN0b3IsIGZhbHNlKS5wYXJzZUNoYWluKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24pO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XHJcbiAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRoaXMuX3JlZmxlY3RvciwgZmFsc2UpLnBhcnNlU2ltcGxlQmluZGluZygpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcclxuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgdGhpcy5fcmVmbGVjdG9yLCBmYWxzZSkucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKCk7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQoaW5wdXQsIElOVEVSUE9MQVRJT05fUkVHRVhQKTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpeGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShwYXJ0KTtcclxuICAgICAgICAgICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCB0aGlzLl9yZWZsZWN0b3IsIGZhbHNlKS5wYXJzZUNoYWluKCk7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIGkpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShuZXcgYXN0XzEuSW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucyksIGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS53cmFwTGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkFTVFdpdGhTb3VyY2UobmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUoaW5wdXQpLCBpbnB1dCwgbG9jYXRpb24pO1xyXG4gICAgfTtcclxuICAgIFBhcnNlci5wcm90b3R5cGUuX2NoZWNrTm9JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGlucHV0LCBJTlRFUlBPTEFUSU9OX1JFR0VYUCk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdHb3QgaW50ZXJwb2xhdGlvbiAoe3t9fSkgd2hlcmUgZXhwcmVzc2lvbiB3YXMgZXhwZWN0ZWQnLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4KSB7XHJcbiAgICAgICAgdmFyIGVyckxvY2F0aW9uID0gJyc7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xyXG4gICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/IHBhcnRzW2pdIDogXCJ7e1wiICsgcGFydHNbal0gKyBcIn19XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlcnJMb2NhdGlvbi5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVjb3JhdG9yc18xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbGV4ZXJfMS5MZXhlciwgcmVmbGVjdGlvbl8xLlJlZmxlY3Rvcl0pXHJcbiAgICBdLCBQYXJzZXIpO1xyXG4gICAgcmV0dXJuIFBhcnNlcjtcclxufSkoKTtcclxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XHJcbnZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCByZWZsZWN0b3IsIHBhcnNlQWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcclxuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcclxuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcclxuICAgICAgICB0aGlzLnBhcnNlQWN0aW9uID0gcGFyc2VBY3Rpb247XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiBpIDwgdGhpcy50b2tlbnMubGVuZ3RoID8gdGhpcy50b2tlbnNbaV0gOiBsZXhlcl8xLkVPRjtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJuZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGVlaygwKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IHRoaXMubmV4dC5pbmRleCA6IHRoaXMuaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluZGV4Kys7IH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5vcHRpb25hbEtleXdvcmRWYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVla0tleXdvcmRWYXIoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRWYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkVmFyKCkgfHwgdGhpcy5uZXh0LmlzT3BlcmF0b3IoJyMnKTsgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3Rlcihjb2RlKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKGNvZGUpKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcclxuICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xyXG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciBvciBrZXl3b3JkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xyXG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSAmJiAhbi5pc1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyLCBrZXl3b3JkLCBvciBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBleHBycyA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZVBpcGUoKTtcclxuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kU0VNSUNPTE9OKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkJpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb25cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XHJcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyB0aGlzLm5leHQgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkVtcHR5RXhwcigpO1xyXG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQ2hhaW4oZXhwcnMpO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhc3QgPSB0aGlzLnBhcnNlQ2hhaW4oKTtcclxuICAgICAgICBpZiAoIVNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlNpbXBsZSBiaW5kaW5nIGV4cHJlc3Npb24gY2FuIG9ubHkgY29udGFpbiBmaWVsZCBhY2Nlc3MgYW5kIGNvbnN0YW50cydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3Q7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVBpcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcInxcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRDT0xPTikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluZGluZ1BpcGUocmVzdWx0LCBuYW1lLCBhcmdzKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwifFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTsgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/JykpIHtcclxuICAgICAgICAgICAgdmFyIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRDT0xPTikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmlucHV0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5vID0gdGhpcy5wYXJzZVBpcGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5Db25kaXRpb25hbChyZXN1bHQsIHllcywgbm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxPciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAnfHwnXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfHwnKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCd8fCcsIHJlc3VsdCwgdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gJyYmJ1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcclxuICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcmJicpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJyYmJywgcmVzdWx0LCB0aGlzLnBhcnNlRXF1YWxpdHkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICc9PScsJyE9JywnPT09JywnIT09J1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz09JykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJz09JywgcmVzdWx0LCB0aGlzLnBhcnNlUmVsYXRpb25hbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz09PScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc9PT0nLCByZXN1bHQsIHRoaXMucGFyc2VSZWxhdGlvbmFsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIT0nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnIT0nLCByZXN1bHQsIHRoaXMucGFyc2VSZWxhdGlvbmFsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIT09JykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJyE9PScsIHJlc3VsdCwgdGhpcy5wYXJzZVJlbGF0aW9uYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICc8JywgJz4nLCAnPD0nLCAnPj0nXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJzwnKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPCcsIHJlc3VsdCwgdGhpcy5wYXJzZUFkZGl0aXZlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc+JywgcmVzdWx0LCB0aGlzLnBhcnNlQWRkaXRpdmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc8PScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc8PScsIHJlc3VsdCwgdGhpcy5wYXJzZUFkZGl0aXZlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPj0nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPj0nLCByZXN1bHQsIHRoaXMucGFyc2VBZGRpdGl2ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFkZGl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICcrJywgJy0nXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJysnKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnKycsIHJlc3VsdCwgdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCctJywgcmVzdWx0LCB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VNdWx0aXBsaWNhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAnKicsICclJywgJy8nXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcqJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJyonLCByZXN1bHQsIHRoaXMucGFyc2VQcmVmaXgoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCclJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJyUnLCByZXN1bHQsIHRoaXMucGFyc2VQcmVmaXgoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcvJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJy8nLCByZXN1bHQsIHRoaXMucGFyc2VQcmVmaXgoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmVmaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignKycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJlZml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuQmluYXJ5KCctJywgbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUoMCksIHRoaXMucGFyc2VQcmVmaXgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuUHJlZml4Tm90KHRoaXMucGFyc2VQcmVmaXgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxDaGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJFBFUklPRCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/LicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0tFVCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLnBhcnNlUGlwZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNLRVQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcIj1cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuS2V5ZWRXcml0ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLktleWVkUmVhZChyZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMUEFSRU4pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSUEFSRU4pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkZ1bmN0aW9uQ2FsbChyZXN1bHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMUEFSRU4pKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUGlwZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSUEFSRU4pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkTnVsbCgpIHx8IHRoaXMubmV4dC5pc0tleXdvcmRVbmRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVHJ1ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcnNlQWN0aW9uICYmIHRoaXMubmV4dC5pc0tleXdvcmRJZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRMUEFSRU4pO1xyXG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKTtcclxuICAgICAgICAgICAgdmFyIGlmRXhwID0gdGhpcy5wYXJzZUV4cHJlc3Npb25PckJsb2NrKCk7XHJcbiAgICAgICAgICAgIHZhciBlbHNlRXhwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzS2V5d29yZEVsc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlRXhwID0gdGhpcy5wYXJzZUV4cHJlc3Npb25PckJsb2NrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5JZihjb25kaXRpb24sIGlmRXhwLCBlbHNlRXhwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0tFVCkpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJlc3Npb25MaXN0KGxleGVyXzEuJFJCUkFDS0VUKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNLRVQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxBcnJheShlbGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwoX2ltcGxpY2l0UmVjZWl2ZXIsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNTdHJpbmcoKSkge1xyXG4gICAgICAgICAgICB2YXIgbGl0ZXJhbFZhbHVlID0gdGhpcy5uZXh0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUobGl0ZXJhbFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246IFwiICsgdGhpcy5pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIHRoaXMubmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVycm9yKCkgdGhyb3dzLCBzbyB3ZSBkb24ndCByZWFjaCBoZXJlLlxyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkZlbGwgdGhyb3VnaCBhbGwgY2FzZXMgaW4gcGFyc2VQcmltYXJ5XCIpO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmICghdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKHRlcm1pbmF0b3IpKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTU1BKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxpdGVyYWxNYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kTEJSQUNFKTtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNFKSkge1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kQ09MT04pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5MaXRlcmFsTWFwKGtleXMsIHZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgaXNTYWZlKSB7XHJcbiAgICAgICAgaWYgKGlzU2FmZSA9PT0gdm9pZCAwKSB7IGlzU2FmZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kTFBBUkVOKSkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKGxleGVyXzEuJFJQQVJFTik7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMucmVmbGVjdG9yLm1ldGhvZChpZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1NhZmUgPyBuZXcgYXN0XzEuU2FmZU1ldGhvZENhbGwocmVjZWl2ZXIsIGlkLCBmbiwgYXJncykgOlxyXG4gICAgICAgICAgICAgICAgbmV3IGFzdF8xLk1ldGhvZENhbGwocmVjZWl2ZXIsIGlkLCBmbiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNTYWZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwiPVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJUaGUgJz8uJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuU2FmZVByb3BlcnR5UmVhZChyZWNlaXZlciwgaWQsIHRoaXMucmVmbGVjdG9yLmdldHRlcihpZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcIj1cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkJpbmRpbmdzIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLlByb3BlcnR5V3JpdGUocmVjZWl2ZXIsIGlkLCB0aGlzLnJlZmxlY3Rvci5zZXR0ZXIoaWQpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLlByb3BlcnR5UmVhZChyZWNlaXZlciwgaWQsIHRoaXMucmVmbGVjdG9yLmdldHRlcihpZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKSlcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbmFscyA9IFtdO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcclxuICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTU1BKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWxzO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uT3JCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0UpKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMucGFyc2VCbG9ja0NvbnRlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQmxvY2tDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4cHJzID0gW107XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIXRoaXMubmV4dC5pc0NoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpKSB7XHJcbiAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kU0VNSUNPTE9OKSkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kU0VNSUNPTE9OKSkge1xyXG4gICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkVtcHR5RXhwcigpO1xyXG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQ2hhaW4oZXhwcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gaWRlbnRpZmllciwgYSBrZXl3b3JkLCBhIHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIGAtYCBpbmJldHdlZW4uXHJcbiAgICAgKi9cclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB2YXIgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy0nKTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChvcGVyYXRvckZvdW5kKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gW107XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGtleUlzVmFyID0gdGhpcy5vcHRpb25hbEtleXdvcmRWYXIoKTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XHJcbiAgICAgICAgICAgIGlmICgha2V5SXNWYXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArICctJyArIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTE9OKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcIj1cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnXFwkaW1wbGljaXQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCAhPT0gbGV4ZXJfMS5FT0YgJiYgIXRoaXMucGVla0tleXdvcmRWYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IGFzdF8xLkFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIHRoaXMubG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IGFzdF8xLlRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTU1BKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbmRleCkpXHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICB2YXIgbG9jYXRpb24gPSAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcclxuICAgICAgICAgICAgXCJhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXCI7XHJcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmxvY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX1BhcnNlQVNUO1xyXG59KSgpO1xyXG5leHBvcnRzLl9QYXJzZUFTVCA9IF9QYXJzZUFTVDtcclxudmFyIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCkge1xyXG4gICAgICAgIHRoaXMuc2ltcGxlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBzID0gbmV3IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCk7XHJcbiAgICAgICAgYXN0LnZpc2l0KHMpO1xyXG4gICAgICAgIHJldHVybiBzLnNpbXBsZTtcclxuICAgIH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCkgeyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0KSB7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xyXG4gICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGFzdHMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gYXN0c1tpXS52aXNpdCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdElmID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgcmV0dXJuIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyO1xyXG59KSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO2Z1bmN0aW9uIGltcGxlbWVudHNPbkRlc3Ryb3kocGlwZSkge1xyXG4gICAgcmV0dXJuIHBpcGUuY29uc3RydWN0b3IucHJvdG90eXBlLm9uRGVzdHJveTtcclxufVxyXG5leHBvcnRzLmltcGxlbWVudHNPbkRlc3Ryb3kgPSBpbXBsZW1lbnRzT25EZXN0cm95O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlX2xpZmVjeWNsZV9yZWZsZWN0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBTZWxlY3RlZFBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0ZWRQaXBlKHBpcGUsIHB1cmUpIHtcclxuICAgICAgICB0aGlzLnBpcGUgPSBwaXBlO1xyXG4gICAgICAgIHRoaXMucHVyZSA9IHB1cmU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2VsZWN0ZWRQaXBlO1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGVjdGVkUGlwZSA9IFNlbGVjdGVkUGlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBhc3RfMSA9IHJlcXVpcmUoJy4vcGFyc2VyL2FzdCcpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rpb25fdXRpbCcpO1xyXG52YXIgZHluYW1pY19jaGFuZ2VfZGV0ZWN0b3JfMSA9IHJlcXVpcmUoJy4vZHluYW1pY19jaGFuZ2VfZGV0ZWN0b3InKTtcclxudmFyIGRpcmVjdGl2ZV9yZWNvcmRfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX3JlY29yZCcpO1xyXG52YXIgZXZlbnRfYmluZGluZ18xID0gcmVxdWlyZSgnLi9ldmVudF9iaW5kaW5nJyk7XHJcbnZhciBjb2FsZXNjZV8xID0gcmVxdWlyZSgnLi9jb2FsZXNjZScpO1xyXG52YXIgcHJvdG9fcmVjb3JkXzEgPSByZXF1aXJlKCcuL3Byb3RvX3JlY29yZCcpO1xyXG52YXIgRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3IoX2RlZmluaXRpb24pIHtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gX2RlZmluaXRpb247XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlCaW5kaW5nUmVjb3JkcyA9IGNyZWF0ZVByb3BlcnR5UmVjb3JkcyhfZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRCaW5kaW5nUmVjb3JkcyA9IGNyZWF0ZUV2ZW50UmVjb3JkcyhfZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlCaW5kaW5nVGFyZ2V0cyA9IHRoaXMuX2RlZmluaXRpb24uYmluZGluZ1JlY29yZHMubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnRhcmdldDsgfSk7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlSW5kaWNlcyA9IHRoaXMuX2RlZmluaXRpb24uZGlyZWN0aXZlUmVjb3Jkcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGlyZWN0aXZlSW5kZXg7IH0pO1xyXG4gICAgfVxyXG4gICAgRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGR5bmFtaWNfY2hhbmdlX2RldGVjdG9yXzEuRHluYW1pY0NoYW5nZURldGVjdG9yKHRoaXMuX2RlZmluaXRpb24uaWQsIGRpc3BhdGNoZXIsIHRoaXMuX3Byb3BlcnR5QmluZGluZ1JlY29yZHMubGVuZ3RoLCB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCB0aGlzLl9kaXJlY3RpdmVJbmRpY2VzLCB0aGlzLl9kZWZpbml0aW9uLnN0cmF0ZWd5LCB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdSZWNvcmRzLCB0aGlzLl9ldmVudEJpbmRpbmdSZWNvcmRzLCB0aGlzLl9kZWZpbml0aW9uLmRpcmVjdGl2ZVJlY29yZHMsIHRoaXMuX2RlZmluaXRpb24uZ2VuQ29uZmlnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3IgPSBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlSZWNvcmRzKGRlZmluaXRpb24pIHtcclxuICAgIHZhciByZWNvcmRCdWlsZGVyID0gbmV3IFByb3RvUmVjb3JkQnVpbGRlcigpO1xyXG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoZGVmaW5pdGlvbi5iaW5kaW5nUmVjb3JkcywgZnVuY3Rpb24gKGIsIGluZGV4KSB7IHJldHVybiByZWNvcmRCdWlsZGVyLmFkZChiLCBkZWZpbml0aW9uLnZhcmlhYmxlTmFtZXMsIGluZGV4KTsgfSk7XHJcbiAgICByZXR1cm4gY29hbGVzY2VfMS5jb2FsZXNjZShyZWNvcmRCdWlsZGVyLnJlY29yZHMpO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlUHJvcGVydHlSZWNvcmRzID0gY3JlYXRlUHJvcGVydHlSZWNvcmRzO1xyXG5mdW5jdGlvbiBjcmVhdGVFdmVudFJlY29yZHMoZGVmaW5pdGlvbikge1xyXG4gICAgLy8gVE9ETzogdnNhdmtpbjogcmVtb3ZlICRldmVudCB3aGVuIHRoZSBjb21waWxlciBoYW5kbGVzIHJlbmRlci1zaWRlIHZhcmlhYmxlcyBwcm9wZXJseVxyXG4gICAgdmFyIHZhck5hbWVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChbJyRldmVudCddLCBkZWZpbml0aW9uLnZhcmlhYmxlTmFtZXMpO1xyXG4gICAgcmV0dXJuIGRlZmluaXRpb24uZXZlbnRSZWNvcmRzLm1hcChmdW5jdGlvbiAoZXIpIHtcclxuICAgICAgICB2YXIgcmVjb3JkcyA9IF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5jcmVhdGUoZXIsIHZhck5hbWVzKTtcclxuICAgICAgICB2YXIgZGlySW5kZXggPSBlci5pbXBsaWNpdFJlY2VpdmVyIGluc3RhbmNlb2YgZGlyZWN0aXZlX3JlY29yZF8xLkRpcmVjdGl2ZUluZGV4ID8gZXIuaW1wbGljaXRSZWNlaXZlciA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBldmVudF9iaW5kaW5nXzEuRXZlbnRCaW5kaW5nKGVyLnRhcmdldC5uYW1lLCBlci50YXJnZXQuZWxlbWVudEluZGV4LCBkaXJJbmRleCwgcmVjb3Jkcyk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUV2ZW50UmVjb3JkcyA9IGNyZWF0ZUV2ZW50UmVjb3JkcztcclxudmFyIFByb3RvUmVjb3JkQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b1JlY29yZEJ1aWxkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XHJcbiAgICB9XHJcbiAgICBQcm90b1JlY29yZEJ1aWxkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChiLCB2YXJpYWJsZU5hbWVzLCBiaW5kaW5nSW5kZXgpIHtcclxuICAgICAgICB2YXIgb2xkTGFzdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5sYXN0KHRoaXMucmVjb3Jkcyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob2xkTGFzdCkgJiYgb2xkTGFzdC5iaW5kaW5nUmVjb3JkLmRpcmVjdGl2ZVJlY29yZCA9PSBiLmRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgICAgICBvbGRMYXN0Lmxhc3RJbkRpcmVjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbnVtYmVyT2ZSZWNvcmRzQmVmb3JlID0gdGhpcy5yZWNvcmRzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLl9hcHBlbmRSZWNvcmRzKGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCk7XHJcbiAgICAgICAgdmFyIG5ld0xhc3QgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIubGFzdCh0aGlzLnJlY29yZHMpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5ld0xhc3QpICYmIG5ld0xhc3QgIT09IG9sZExhc3QpIHtcclxuICAgICAgICAgICAgbmV3TGFzdC5sYXN0SW5CaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmV3TGFzdC5sYXN0SW5EaXJlY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBcmd1bWVudFRvUHVyZUZ1bmN0aW9uKG51bWJlck9mUmVjb3Jkc0JlZm9yZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFByb3RvUmVjb3JkQnVpbGRlci5wcm90b3R5cGUuX3NldEFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0aGlzLnJlY29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHJlYyA9IHRoaXMucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKHJlYy5pc1B1cmVGdW5jdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICByZWMuYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmRJbmRleCkgeyByZXR1cm4gX3RoaXMucmVjb3Jkc1tyZWNvcmRJbmRleCAtIDFdLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPVxyXG4gICAgICAgICAgICAgICAgICAgIHRydWU7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWMubW9kZSA9PT0gcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5QaXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZWMuYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmRJbmRleCkgeyByZXR1cm4gX3RoaXMucmVjb3Jkc1tyZWNvcmRJbmRleCAtIDFdLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPVxyXG4gICAgICAgICAgICAgICAgICAgIHRydWU7IH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzW3JlYy5jb250ZXh0SW5kZXggLSAxXS5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBQcm90b1JlY29yZEJ1aWxkZXIucHJvdG90eXBlLl9hcHBlbmRSZWNvcmRzID0gZnVuY3Rpb24gKGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCkge1xyXG4gICAgICAgIGlmIChiLmlzRGlyZWN0aXZlTGlmZWN5Y2xlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRzLnB1c2gobmV3IHByb3RvX3JlY29yZF8xLlByb3RvUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuRGlyZWN0aXZlTGlmZWN5Y2xlLCBiLmxpZmVjeWNsZUV2ZW50LCBudWxsLCBbXSwgW10sIC0xLCBudWxsLCB0aGlzLnJlY29yZHMubGVuZ3RoICsgMSwgYiwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIG51bGwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5hcHBlbmQodGhpcy5yZWNvcmRzLCBiLCB2YXJpYWJsZU5hbWVzLCBiaW5kaW5nSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJvdG9SZWNvcmRCdWlsZGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvUmVjb3JkQnVpbGRlciA9IFByb3RvUmVjb3JkQnVpbGRlcjtcclxudmFyIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3JkcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMoX3JlY29yZHMsIF9iaW5kaW5nUmVjb3JkLCBfdmFyaWFibGVOYW1lcywgX2JpbmRpbmdJbmRleCkge1xyXG4gICAgICAgIHRoaXMuX3JlY29yZHMgPSBfcmVjb3JkcztcclxuICAgICAgICB0aGlzLl9iaW5kaW5nUmVjb3JkID0gX2JpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgdGhpcy5fdmFyaWFibGVOYW1lcyA9IF92YXJpYWJsZU5hbWVzO1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdJbmRleCA9IF9iaW5kaW5nSW5kZXg7XHJcbiAgICB9XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMuYXBwZW5kID0gZnVuY3Rpb24gKHJlY29yZHMsIGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCkge1xyXG4gICAgICAgIHZhciBjID0gbmV3IF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3JkcyhyZWNvcmRzLCBiLCB2YXJpYWJsZU5hbWVzLCBiaW5kaW5nSW5kZXgpO1xyXG4gICAgICAgIGIuYXN0LnZpc2l0KGMpO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5jcmVhdGUgPSBmdW5jdGlvbiAoYiwgdmFyaWFibGVOYW1lcykge1xyXG4gICAgICAgIHZhciByZWMgPSBbXTtcclxuICAgICAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMuYXBwZW5kKHJlYywgYiwgdmFyaWFibGVOYW1lcywgbnVsbCk7XHJcbiAgICAgICAgcmVjW3JlYy5sZW5ndGggLSAxXS5sYXN0SW5CaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gcmVjO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdGhpcy5fYmluZGluZ1JlY29yZC5pbXBsaWNpdFJlY2VpdmVyOyB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl92aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnRlcnBvbGF0ZSwgXCJpbnRlcnBvbGF0ZVwiLCBfaW50ZXJwb2xhdGlvbkZuKGFzdC5zdHJpbmdzKSwgYXJncywgYXN0LnN0cmluZ3MsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Db25zdCwgXCJsaXRlcmFsXCIsIGFzdC52YWx1ZSwgW10sIG51bGwsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3ZhcmlhYmxlTmFtZXMpICYmIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyh0aGlzLl92YXJpYWJsZU5hbWVzLCBhc3QubmFtZSkgJiZcclxuICAgICAgICAgICAgYXN0LnJlY2VpdmVyIGluc3RhbmNlb2YgYXN0XzEuSW1wbGljaXRSZWNlaXZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuTG9jYWwsIGFzdC5uYW1lLCBhc3QubmFtZSwgW10sIG51bGwsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Qcm9wZXJ0eVJlYWQsIGFzdC5uYW1lLCBhc3QuZ2V0dGVyLCBbXSwgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl92YXJpYWJsZU5hbWVzKSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnModGhpcy5fdmFyaWFibGVOYW1lcywgYXN0Lm5hbWUpICYmXHJcbiAgICAgICAgICAgIGFzdC5yZWNlaXZlciBpbnN0YW5jZW9mIGFzdF8xLkltcGxpY2l0UmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IHJlYXNzaWduIGEgdmFyaWFibGUgYmluZGluZyBcIiArIGFzdC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJvcGVydHlXcml0ZSwgYXN0Lm5hbWUsIGFzdC5zZXR0ZXIsIFt2YWx1ZV0sIG51bGwsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGFzdC5vYmoudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGtleSA9IGFzdC5rZXkudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5LZXllZFdyaXRlLCBudWxsLCBudWxsLCBba2V5LCB2YWx1ZV0sIG51bGwsIG9iaik7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TYWZlUHJvcGVydHksIGFzdC5uYW1lLCBhc3QuZ2V0dGVyLCBbXSwgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3Zpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl92YXJpYWJsZU5hbWVzKSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnModGhpcy5fdmFyaWFibGVOYW1lcywgYXN0Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Mb2NhbCwgYXN0Lm5hbWUsIGFzdC5uYW1lLCBbXSwgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW52b2tlQ2xvc3VyZSwgXCJjbG9zdXJlXCIsIG51bGwsIGFyZ3MsIG51bGwsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW52b2tlTWV0aG9kLCBhc3QubmFtZSwgYXN0LmZuLCBhcmdzLCBudWxsLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl92aXNpdEFsbChhc3QuYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNhZmVNZXRob2RJbnZva2UsIGFzdC5uYW1lLCBhc3QuZm4sIGFyZ3MsIG51bGwsIHJlY2VpdmVyKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBhc3QudGFyZ2V0LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5fdmlzaXRBbGwoYXN0LmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnZva2VDbG9zdXJlLCBcImNsb3N1cmVcIiwgbnVsbCwgYXJncywgbnVsbCwgdGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBwcmltaXRpdmVOYW1lID0gXCJhcnJheUZuXCIgKyBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Db2xsZWN0aW9uTGl0ZXJhbCwgcHJpbWl0aXZlTmFtZSwgX2FycmF5Rm4oYXN0LmV4cHJlc3Npb25zLmxlbmd0aCksIHRoaXMuX3Zpc2l0QWxsKGFzdC5leHByZXNzaW9ucyksIG51bGwsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Db2xsZWN0aW9uTGl0ZXJhbCwgX21hcFByaW1pdGl2ZU5hbWUoYXN0LmtleXMpLCBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm1hcEZuKGFzdC5rZXlzKSwgdGhpcy5fdmlzaXRBbGwoYXN0LnZhbHVlcyksIG51bGwsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBhc3QubGVmdC52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSBhc3QucmlnaHQudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByaW1pdGl2ZU9wLCBfb3BlcmF0aW9uVG9QcmltaXRpdmVOYW1lKGFzdC5vcGVyYXRpb24pLCBfb3BlcmF0aW9uVG9GdW5jdGlvbihhc3Qub3BlcmF0aW9uKSwgW2xlZnQsIHJpZ2h0XSwgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgZXhwID0gYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByaW1pdGl2ZU9wLCBcIm9wZXJhdGlvbl9uZWdhdGVcIiwgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbmVnYXRlLCBbZXhwXSwgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBjID0gYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIgdCA9IGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciBmID0gYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5QcmltaXRpdmVPcCwgXCJjb25kXCIsIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuY29uZCwgW2MsIHQsIGZdLCBudWxsLCAwKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhc3QuZXhwLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5fdmlzaXRBbGwoYXN0LmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5QaXBlLCBhc3QubmFtZSwgYXN0Lm5hbWUsIGFyZ3MsIG51bGwsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBvYmogPSBhc3Qub2JqLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciBrZXkgPSBhc3Qua2V5LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5LZXllZFJlYWQsIFwia2V5ZWRBY2Nlc3NcIiwgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5rZXllZEFjY2VzcywgW2tleV0sIG51bGwsIG9iaik7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhc3QuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZpc2l0KF90aGlzKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNoYWluLCBcImNoYWluXCIsIG51bGwsIGFyZ3MsIG51bGwsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRJZiA9IGZ1bmN0aW9uIChhc3QpIHsgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdOb3Qgc3VwcG9ydGVkJyk7IH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLl92aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUoYXN0cy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXNbaV0gPSBhc3RzW2ldLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUuX2FkZFJlY29yZCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBmdW5jT3JWYWx1ZSwgYXJncywgZml4ZWRBcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHNlbGZJbmRleCA9IHRoaXMuX3JlY29yZHMubGVuZ3RoICsgMTtcclxuICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIGRpcmVjdGl2ZV9yZWNvcmRfMS5EaXJlY3RpdmVJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRzLnB1c2gobmV3IHByb3RvX3JlY29yZF8xLlByb3RvUmVjb3JkKHR5cGUsIG5hbWUsIGZ1bmNPclZhbHVlLCBhcmdzLCBmaXhlZEFyZ3MsIC0xLCBjb250ZXh0LCBzZWxmSW5kZXgsIHRoaXMuX2JpbmRpbmdSZWNvcmQsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0aGlzLl9iaW5kaW5nSW5kZXgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZHMucHVzaChuZXcgcHJvdG9fcmVjb3JkXzEuUHJvdG9SZWNvcmQodHlwZSwgbmFtZSwgZnVuY09yVmFsdWUsIGFyZ3MsIGZpeGVkQXJncywgY29udGV4dCwgbnVsbCwgc2VsZkluZGV4LCB0aGlzLl9iaW5kaW5nUmVjb3JkLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdGhpcy5fYmluZGluZ0luZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxmSW5kZXg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3JkcztcclxufSkoKTtcclxuZnVuY3Rpb24gX2FycmF5Rm4obGVuZ3RoKSB7XHJcbiAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjA7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMTtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm4yO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjM7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNDtcclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm41O1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjY7XHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNztcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm44O1xyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRG9lcyBub3Qgc3VwcG9ydCBsaXRlcmFsIG1hcHMgd2l0aCBtb3JlIHRoYW4gOSBlbGVtZW50c1wiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbWFwUHJpbWl0aXZlTmFtZShrZXlzKSB7XHJcbiAgICB2YXIgc3RyaW5naWZpZWRLZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGxhbmdfMS5pc1N0cmluZyhrKSA/IFwiXFxcIlwiICsgayArIFwiXFxcIlwiIDogXCJcIiArIGs7IH0pLmpvaW4oJywgJyk7XHJcbiAgICByZXR1cm4gXCJtYXBGbihbXCIgKyBzdHJpbmdpZmllZEtleXMgKyBcIl0pXCI7XHJcbn1cclxuZnVuY3Rpb24gX29wZXJhdGlvblRvUHJpbWl0aXZlTmFtZShvcGVyYXRpb24pIHtcclxuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9hZGRcIjtcclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX3N1YnRyYWN0XCI7XHJcbiAgICAgICAgY2FzZSAnKic6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9tdWx0aXBseVwiO1xyXG4gICAgICAgIGNhc2UgJy8nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25fZGl2aWRlXCI7XHJcbiAgICAgICAgY2FzZSAnJSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9yZW1haW5kZXJcIjtcclxuICAgICAgICBjYXNlICc9PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9lcXVhbHNcIjtcclxuICAgICAgICBjYXNlICchPSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9ub3RfZXF1YWxzXCI7XHJcbiAgICAgICAgY2FzZSAnPT09JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2lkZW50aWNhbFwiO1xyXG4gICAgICAgIGNhc2UgJyE9PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9ub3RfaWRlbnRpY2FsXCI7XHJcbiAgICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9sZXNzX3RoZW5cIjtcclxuICAgICAgICBjYXNlICc+JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2dyZWF0ZXJfdGhlblwiO1xyXG4gICAgICAgIGNhc2UgJzw9JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2xlc3Nfb3JfZXF1YWxzX3RoZW5cIjtcclxuICAgICAgICBjYXNlICc+PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9ncmVhdGVyX29yX2VxdWFsc190aGVuXCI7XHJcbiAgICAgICAgY2FzZSAnJiYnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25fbG9naWNhbF9hbmRcIjtcclxuICAgICAgICBjYXNlICd8fCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9sb2dpY2FsX29yXCI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIFwiICsgb3BlcmF0aW9uKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfb3BlcmF0aW9uVG9GdW5jdGlvbihvcGVyYXRpb24pIHtcclxuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9hZGQ7XHJcbiAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9zdWJ0cmFjdDtcclxuICAgICAgICBjYXNlICcqJzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX211bHRpcGx5O1xyXG4gICAgICAgIGNhc2UgJy8nOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZGl2aWRlO1xyXG4gICAgICAgIGNhc2UgJyUnOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fcmVtYWluZGVyO1xyXG4gICAgICAgIGNhc2UgJz09JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2VxdWFscztcclxuICAgICAgICBjYXNlICchPSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9ub3RfZXF1YWxzO1xyXG4gICAgICAgIGNhc2UgJz09PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9pZGVudGljYWw7XHJcbiAgICAgICAgY2FzZSAnIT09JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX25vdF9pZGVudGljYWw7XHJcbiAgICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9sZXNzX3RoZW47XHJcbiAgICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9ncmVhdGVyX3RoZW47XHJcbiAgICAgICAgY2FzZSAnPD0nOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbGVzc19vcl9lcXVhbHNfdGhlbjtcclxuICAgICAgICBjYXNlICc+PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9ncmVhdGVyX29yX2VxdWFsc190aGVuO1xyXG4gICAgICAgIGNhc2UgJyYmJzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xvZ2ljYWxfYW5kO1xyXG4gICAgICAgIGNhc2UgJ3x8JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xvZ2ljYWxfb3I7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgb3BlcmF0aW9uIFwiICsgb3BlcmF0aW9uKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzKHYpIHtcclxuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHYpID8gXCJcIiArIHYgOiAnJztcclxufVxyXG5mdW5jdGlvbiBfaW50ZXJwb2xhdGlvbkZuKHN0cmluZ3MpIHtcclxuICAgIHZhciBsZW5ndGggPSBzdHJpbmdzLmxlbmd0aDtcclxuICAgIHZhciBjMCA9IGxlbmd0aCA+IDAgPyBzdHJpbmdzWzBdIDogbnVsbDtcclxuICAgIHZhciBjMSA9IGxlbmd0aCA+IDEgPyBzdHJpbmdzWzFdIDogbnVsbDtcclxuICAgIHZhciBjMiA9IGxlbmd0aCA+IDIgPyBzdHJpbmdzWzJdIDogbnVsbDtcclxuICAgIHZhciBjMyA9IGxlbmd0aCA+IDMgPyBzdHJpbmdzWzNdIDogbnVsbDtcclxuICAgIHZhciBjNCA9IGxlbmd0aCA+IDQgPyBzdHJpbmdzWzRdIDogbnVsbDtcclxuICAgIHZhciBjNSA9IGxlbmd0aCA+IDUgPyBzdHJpbmdzWzVdIDogbnVsbDtcclxuICAgIHZhciBjNiA9IGxlbmd0aCA+IDYgPyBzdHJpbmdzWzZdIDogbnVsbDtcclxuICAgIHZhciBjNyA9IGxlbmd0aCA+IDcgPyBzdHJpbmdzWzddIDogbnVsbDtcclxuICAgIHZhciBjOCA9IGxlbmd0aCA+IDggPyBzdHJpbmdzWzhdIDogbnVsbDtcclxuICAgIHZhciBjOSA9IGxlbmd0aCA+IDkgPyBzdHJpbmdzWzldIDogbnVsbDtcclxuICAgIHN3aXRjaCAobGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSkgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxOyB9O1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIpIHsgcmV0dXJuIGMwICsgcyhhMSkgKyBjMSArIHMoYTIpICsgYzI7IH07XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHsgcmV0dXJuIGMwICsgcyhhMSkgKyBjMSArIHMoYTIpICsgYzIgKyBzKGEzKSArIGMzOyB9O1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMiArIHMoYTMpICsgYzMgKyBzKGE0KSArIGM0OyB9O1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIHMoYTEpICsgYzEgKyBzKGEyKSArIGMyICsgcyhhMykgKyBjMyArIHMoYTQpICsgYzQgKyBzKGE1KSArIGM1O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMiArIHMoYTMpICsgYzMgKyBzKGE0KSArIGM0ICsgcyhhNSkgKyBjNSArIHMoYTYpICsgYzY7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7IHJldHVybiBjMCArIHMoYTEpICsgYzEgKyBzKGEyKSArIGMyICsgcyhhMykgKyBjMyArIHMoYTQpICtcclxuICAgICAgICAgICAgICAgIGM0ICsgcyhhNSkgKyBjNSArIHMoYTYpICsgYzYgKyBzKGE3KSArIGM3OyB9O1xyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHsgcmV0dXJuIGMwICsgcyhhMSkgKyBjMSArIHMoYTIpICsgYzIgKyBzKGEzKSArIGMzICsgcyhhNCkgK1xyXG4gICAgICAgICAgICAgICAgYzQgKyBzKGE1KSArIGM1ICsgcyhhNikgKyBjNiArIHMoYTcpICsgYzcgKyBzKGE4KSArXHJcbiAgICAgICAgICAgICAgICBjODsgfTtcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMiArIHMoYTMpICsgYzMgK1xyXG4gICAgICAgICAgICAgICAgcyhhNCkgKyBjNCArIHMoYTUpICsgYzUgKyBzKGE2KSArIGM2ICsgcyhhNykgK1xyXG4gICAgICAgICAgICAgICAgYzcgKyBzKGE4KSArIGM4ICsgcyhhOSkgKyBjOTsgfTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJEb2VzIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiA5IGV4cHJlc3Npb25zXCIpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvX2NoYW5nZV9kZXRlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7KGZ1bmN0aW9uIChSZWNvcmRUeXBlKSB7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJTZWxmXCJdID0gMF0gPSBcIlNlbGZcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIkNvbnN0XCJdID0gMV0gPSBcIkNvbnN0XCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJQcmltaXRpdmVPcFwiXSA9IDJdID0gXCJQcmltaXRpdmVPcFwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiUHJvcGVydHlSZWFkXCJdID0gM10gPSBcIlByb3BlcnR5UmVhZFwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiUHJvcGVydHlXcml0ZVwiXSA9IDRdID0gXCJQcm9wZXJ0eVdyaXRlXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJMb2NhbFwiXSA9IDVdID0gXCJMb2NhbFwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiSW52b2tlTWV0aG9kXCJdID0gNl0gPSBcIkludm9rZU1ldGhvZFwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiSW52b2tlQ2xvc3VyZVwiXSA9IDddID0gXCJJbnZva2VDbG9zdXJlXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJLZXllZFJlYWRcIl0gPSA4XSA9IFwiS2V5ZWRSZWFkXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJLZXllZFdyaXRlXCJdID0gOV0gPSBcIktleWVkV3JpdGVcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIlBpcGVcIl0gPSAxMF0gPSBcIlBpcGVcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIkludGVycG9sYXRlXCJdID0gMTFdID0gXCJJbnRlcnBvbGF0ZVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiU2FmZVByb3BlcnR5XCJdID0gMTJdID0gXCJTYWZlUHJvcGVydHlcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIkNvbGxlY3Rpb25MaXRlcmFsXCJdID0gMTNdID0gXCJDb2xsZWN0aW9uTGl0ZXJhbFwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiU2FmZU1ldGhvZEludm9rZVwiXSA9IDE0XSA9IFwiU2FmZU1ldGhvZEludm9rZVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiRGlyZWN0aXZlTGlmZWN5Y2xlXCJdID0gMTVdID0gXCJEaXJlY3RpdmVMaWZlY3ljbGVcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIkNoYWluXCJdID0gMTZdID0gXCJDaGFpblwiO1xyXG59KShleHBvcnRzLlJlY29yZFR5cGUgfHwgKGV4cG9ydHMuUmVjb3JkVHlwZSA9IHt9KSk7XHJcbnZhciBSZWNvcmRUeXBlID0gZXhwb3J0cy5SZWNvcmRUeXBlO1xyXG52YXIgUHJvdG9SZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9SZWNvcmQobW9kZSwgbmFtZSwgZnVuY09yVmFsdWUsIGFyZ3MsIGZpeGVkQXJncywgY29udGV4dEluZGV4LCBkaXJlY3RpdmVJbmRleCwgc2VsZkluZGV4LCBiaW5kaW5nUmVjb3JkLCBsYXN0SW5CaW5kaW5nLCBsYXN0SW5EaXJlY3RpdmUsIGFyZ3VtZW50VG9QdXJlRnVuY3Rpb24sIHJlZmVyZW5jZWRCeVNlbGYsIHByb3BlcnR5QmluZGluZ0luZGV4KSB7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZnVuY09yVmFsdWUgPSBmdW5jT3JWYWx1ZTtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgIHRoaXMuZml4ZWRBcmdzID0gZml4ZWRBcmdzO1xyXG4gICAgICAgIHRoaXMuY29udGV4dEluZGV4ID0gY29udGV4dEluZGV4O1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlSW5kZXggPSBkaXJlY3RpdmVJbmRleDtcclxuICAgICAgICB0aGlzLnNlbGZJbmRleCA9IHNlbGZJbmRleDtcclxuICAgICAgICB0aGlzLmJpbmRpbmdSZWNvcmQgPSBiaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgIHRoaXMubGFzdEluQmluZGluZyA9IGxhc3RJbkJpbmRpbmc7XHJcbiAgICAgICAgdGhpcy5sYXN0SW5EaXJlY3RpdmUgPSBsYXN0SW5EaXJlY3RpdmU7XHJcbiAgICAgICAgdGhpcy5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uID0gYXJndW1lbnRUb1B1cmVGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZWRCeVNlbGYgPSByZWZlcmVuY2VkQnlTZWxmO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlCaW5kaW5nSW5kZXggPSBwcm9wZXJ0eUJpbmRpbmdJbmRleDtcclxuICAgIH1cclxuICAgIFByb3RvUmVjb3JkLnByb3RvdHlwZS5pc1B1cmVGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBSZWNvcmRUeXBlLkludGVycG9sYXRlIHx8IHRoaXMubW9kZSA9PT0gUmVjb3JkVHlwZS5Db2xsZWN0aW9uTGl0ZXJhbDtcclxuICAgIH07XHJcbiAgICBQcm90b1JlY29yZC5wcm90b3R5cGUuaXNVc2VkQnlPdGhlclJlY29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmxhc3RJbkJpbmRpbmcgfHwgdGhpcy5yZWZlcmVuY2VkQnlTZWxmOyB9O1xyXG4gICAgUHJvdG9SZWNvcmQucHJvdG90eXBlLnNob3VsZEJlQ2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uIHx8IHRoaXMubGFzdEluQmluZGluZyB8fCB0aGlzLmlzUHVyZUZ1bmN0aW9uKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5pc1BpcGVSZWNvcmQoKTtcclxuICAgIH07XHJcbiAgICBQcm90b1JlY29yZC5wcm90b3R5cGUuaXNQaXBlUmVjb3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tb2RlID09PSBSZWNvcmRUeXBlLlBpcGU7IH07XHJcbiAgICBQcm90b1JlY29yZC5wcm90b3R5cGUuaXNMaWZlQ3ljbGVSZWNvcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IFJlY29yZFR5cGUuRGlyZWN0aXZlTGlmZWN5Y2xlOyB9O1xyXG4gICAgcmV0dXJuIFByb3RvUmVjb3JkO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvUmVjb3JkID0gUHJvdG9SZWNvcmQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvX3JlY29yZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGFwcF9yb290X3VybF8xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL2FwcF9yb290X3VybFwiKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyXCIpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9kaVwiKTtcclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBvZiB7QGxpbmsgQXBwUm9vdFVybH0gdGhhdCB1c2VzIGEgRE9NIGFuY2hvciB0YWcgdG8gc2V0IHRoZSByb290IHVybCB0b1xyXG4gKiB0aGUgY3VycmVudCBwYWdlJ3MgdXJsLlxyXG4gKi9cclxudmFyIEFuY2hvckJhc2VkQXBwUm9vdFVybCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQW5jaG9yQmFzZWRBcHBSb290VXJsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQW5jaG9yQmFzZWRBcHBSb290VXJsKCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiXCIpO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIHJvb3QgdXJsIHRvIHBhc3MgdG8gQXBwUm9vdFVybFxyXG4gICAgICAgIHZhciBhID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlc29sdmVBbmRTZXRIcmVmKGEsICcuLycsIG51bGwpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRIcmVmKGEpO1xyXG4gICAgfVxyXG4gICAgQW5jaG9yQmFzZWRBcHBSb290VXJsID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBBbmNob3JCYXNlZEFwcFJvb3RVcmwpO1xyXG4gICAgcmV0dXJuIEFuY2hvckJhc2VkQXBwUm9vdFVybDtcclxufSkoYXBwX3Jvb3RfdXJsXzEuQXBwUm9vdFVybCk7XHJcbmV4cG9ydHMuQW5jaG9yQmFzZWRBcHBSb290VXJsID0gQW5jaG9yQmFzZWRBcHBSb290VXJsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmNob3JfYmFzZWRfYXBwX3Jvb3RfdXJsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgYXBwIHJvb3QgdXJsIGZvciB0aGUgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIFVzZWQgYnkgdGhlIHtAbGluayBDb21waWxlcn0gd2hlbiByZXNvbHZpbmcgSFRNTCBhbmQgQ1NTIHRlbXBsYXRlIFVSTHMuXHJcbiAqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cclxuICpcclxuICogU2VlIHtAbGluayBDb21waWxlcn1cclxuICovXHJcbnZhciBBcHBSb290VXJsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFJvb3RVcmwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBBcHBSb290VXJsID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXHJcbiAgICBdLCBBcHBSb290VXJsKTtcclxuICAgIHJldHVybiBBcHBSb290VXJsO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFJvb3RVcmwgPSBBcHBSb290VXJsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBfcm9vdF91cmwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciB0ZW1wbGF0ZV9hc3RfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfYXN0Jyk7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvaW50ZXJmYWNlcycpO1xyXG5mdW5jdGlvbiBjcmVhdGVDaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zKGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudFN0cmF0ZWd5LCBnZW5Db25maWcsIHBhcnNlZFRlbXBsYXRlKSB7XHJcbiAgICB2YXIgcHZWaXNpdG9ycyA9IFtdO1xyXG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgUHJvdG9WaWV3VmlzaXRvcihudWxsLCBwdlZpc2l0b3JzLCBjb21wb25lbnRTdHJhdGVneSk7XHJcbiAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHBhcnNlZFRlbXBsYXRlKTtcclxuICAgIHJldHVybiBjcmVhdGVDaGFuZ2VEZWZpbml0aW9ucyhwdlZpc2l0b3JzLCBjb21wb25lbnRUeXBlLCBnZW5Db25maWcpO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyA9IGNyZWF0ZUNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnM7XHJcbnZhciBQcm90b1ZpZXdWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvVmlld1Zpc2l0b3IocGFyZW50LCBhbGxWaXNpdG9ycywgc3RyYXRlZ3kpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmFsbFZpc2l0b3JzID0gYWxsVmlzaXRvcnM7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMuYm91bmRUZXh0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYm91bmRFbGVtZW50Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1JlY29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50UmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlUmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmlld0luZGV4ID0gYWxsVmlzaXRvcnMubGVuZ3RoO1xyXG4gICAgICAgIGFsbFZpc2l0b3JzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRDb3VudCsrO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXN0LmRpcmVjdGl2ZXNbaV0udmlzaXQodGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZFZpc2l0b3IgPSBuZXcgUHJvdG9WaWV3VmlzaXRvcih0aGlzLCB0aGlzLmFsbFZpc2l0b3JzLCBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCk7XHJcbiAgICAgICAgLy8gQXR0ZW50aW9uOiB2YXJpYWJsZXMgcHJlc2VudCBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZSBjb3VudCB0b3dhcmRzXHJcbiAgICAgICAgLy8gdGhlIGVtYmVkZGVkIHRlbXBsYXRlIGFuZCBub3QgdGhlIHRlbXBsYXRlIGFuY2hvciFcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKGNoaWxkVmlzaXRvciwgYXN0LnZhcnMpO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwoY2hpbGRWaXNpdG9yLCBhc3QuY2hpbGRyZW4pO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoYXN0LmlzQm91bmQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kRWxlbWVudENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmlucHV0cywgbnVsbCk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3Qub3V0cHV0cyk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuZXhwb3J0QXNWYXJzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5kaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFzdC5kaXJlY3RpdmVzW2ldLnZpc2l0KHRoaXMsIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChhc3QubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXRFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIHZhciBiaW5kaW5nUmVjb3JkID0gbGFuZ18xLmlzUHJlc2VudChkaXJlY3RpdmVSZWNvcmQpID9cclxuICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdEV2ZW50KGFzdC5oYW5kbGVyLCBhc3QuZnVsbE5hbWUsIGRpcmVjdGl2ZVJlY29yZCkgOlxyXG4gICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVGb3JFdmVudChhc3QuaGFuZGxlciwgYXN0LmZ1bGxOYW1lLCB0aGlzLmJvdW5kRWxlbWVudENvdW50IC0gMSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlY29yZHMucHVzaChiaW5kaW5nUmVjb3JkKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IHRoaXMuYm91bmRFbGVtZW50Q291bnQgLSAxO1xyXG4gICAgICAgIHZhciBkaXJJbmRleCA9IGxhbmdfMS5pc1ByZXNlbnQoZGlyZWN0aXZlUmVjb3JkKSA/IGRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCA6IG51bGw7XHJcbiAgICAgICAgdmFyIGJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgaWYgKGFzdC50eXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmQgPVxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChkaXJJbmRleCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RQcm9wZXJ0eShkaXJJbmRleCwgYXN0LnZhbHVlLCBhc3QubmFtZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRQcm9wZXJ0eShhc3QudmFsdWUsIGJvdW5kRWxlbWVudEluZGV4LCBhc3QubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFzdC50eXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICBiaW5kaW5nUmVjb3JkID1cclxuICAgICAgICAgICAgICAgIGxhbmdfMS5pc1ByZXNlbnQoZGlySW5kZXgpID9cclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVGb3JIb3N0QXR0cmlidXRlKGRpckluZGV4LCBhc3QudmFsdWUsIGFzdC5uYW1lKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudEF0dHJpYnV0ZShhc3QudmFsdWUsIGJvdW5kRWxlbWVudEluZGV4LCBhc3QubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFzdC50eXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmQgPVxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChkaXJJbmRleCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RDbGFzcyhkaXJJbmRleCwgYXN0LnZhbHVlLCBhc3QubmFtZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRDbGFzcyhhc3QudmFsdWUsIGJvdW5kRWxlbWVudEluZGV4LCBhc3QubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFzdC50eXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmQgPVxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChkaXJJbmRleCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RTdHlsZShkaXJJbmRleCwgYXN0LnZhbHVlLCBhc3QubmFtZSwgYXN0LnVuaXQpIDpcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVGb3JFbGVtZW50U3R5bGUoYXN0LnZhbHVlLCBib3VuZEVsZW1lbnRJbmRleCwgYXN0Lm5hbWUsIGFzdC51bml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nUmVjb3Jkcy5wdXNoKGJpbmRpbmdSZWNvcmQpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYm91bmRUZXh0SW5kZXggPSB0aGlzLmJvdW5kVGV4dENvdW50Kys7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nUmVjb3Jkcy5wdXNoKGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvclRleHROb2RlKGFzdC52YWx1ZSwgYm91bmRUZXh0SW5kZXgpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAoYXN0LCBkaXJlY3RpdmVJbmRleEFzTnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUluZGV4ID0gbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5EaXJlY3RpdmVJbmRleCh0aGlzLmJvdW5kRWxlbWVudENvdW50IC0gMSwgZGlyZWN0aXZlSW5kZXhBc051bWJlcik7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZU1ldGFkYXRhID0gYXN0LmRpcmVjdGl2ZTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlUmVjb3JkID0gbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5EaXJlY3RpdmVSZWNvcmQoe1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVJbmRleDogZGlyZWN0aXZlSW5kZXgsXHJcbiAgICAgICAgICAgIGNhbGxBZnRlckNvbnRlbnRJbml0OiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0KSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxBZnRlckNvbnRlbnRDaGVja2VkOiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkKSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxBZnRlclZpZXdJbml0OiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0KSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxBZnRlclZpZXdDaGVja2VkOiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkKSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxPbkNoYW5nZXM6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcykgIT09IC0xLFxyXG4gICAgICAgICAgICBjYWxsRG9DaGVjazogZGlyZWN0aXZlTWV0YWRhdGEubGlmZWN5Y2xlSG9va3MuaW5kZXhPZihpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuRG9DaGVjaykgIT09IC0xLFxyXG4gICAgICAgICAgICBjYWxsT25Jbml0OiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5PbkluaXQpICE9PSAtMSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmVNZXRhZGF0YS5jaGFuZ2VEZXRlY3Rpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZVJlY29yZHMucHVzaChkaXJlY3RpdmVSZWNvcmQpO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmlucHV0cywgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgICAgICB2YXIgYmluZGluZ1JlY29yZHMgPSB0aGlzLmJpbmRpbmdSZWNvcmRzO1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmVSZWNvcmQuY2FsbE9uQ2hhbmdlcykge1xyXG4gICAgICAgICAgICBiaW5kaW5nUmVjb3Jkcy5wdXNoKGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZURpcmVjdGl2ZU9uQ2hhbmdlcyhkaXJlY3RpdmVSZWNvcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVJlY29yZC5jYWxsT25Jbml0KSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmRzLnB1c2goY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRGlyZWN0aXZlT25Jbml0KGRpcmVjdGl2ZVJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlUmVjb3JkLmNhbGxEb0NoZWNrKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmRzLnB1c2goY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRGlyZWN0aXZlRG9DaGVjayhkaXJlY3RpdmVSZWNvcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuaG9zdFByb3BlcnRpZXMsIGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuaG9zdEV2ZW50cywgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5leHBvcnRBc1ZhcnMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICAvLyBUT0RPOiB0aGVzZSBzZXR0ZXJzIHNob3VsZCBldmVudHVhbGx5IGJlIGNyZWF0ZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgdG8gbWFrZVxyXG4gICAgICAgIC8vIGl0IG1vbm9tb3JwaGljIVxyXG4gICAgICAgIHZhciBzZXR0ZXIgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLnNldHRlcihhc3QuZGlyZWN0aXZlTmFtZSk7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nUmVjb3Jkcy5wdXNoKGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckRpcmVjdGl2ZShhc3QudmFsdWUsIGFzdC5kaXJlY3RpdmVOYW1lLCBzZXR0ZXIsIGRpcmVjdGl2ZVJlY29yZCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm90b1ZpZXdWaXNpdG9yO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBjcmVhdGVDaGFuZ2VEZWZpbml0aW9ucyhwdlZpc2l0b3JzLCBjb21wb25lbnRUeXBlLCBnZW5Db25maWcpIHtcclxuICAgIHZhciBwdlZhcmlhYmxlTmFtZXMgPSBfY29sbGVjdE5lc3RlZFByb3RvVmlld3NWYXJpYWJsZU5hbWVzKHB2VmlzaXRvcnMpO1xyXG4gICAgcmV0dXJuIHB2VmlzaXRvcnMubWFwKGZ1bmN0aW9uIChwdlZpc2l0b3IpIHtcclxuICAgICAgICB2YXIgaWQgPSBjb21wb25lbnRUeXBlLm5hbWUgKyBcIl9cIiArIHB2VmlzaXRvci52aWV3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uKGlkLCBwdlZpc2l0b3Iuc3RyYXRlZ3ksIHB2VmFyaWFibGVOYW1lc1twdlZpc2l0b3Iudmlld0luZGV4XSwgcHZWaXNpdG9yLmJpbmRpbmdSZWNvcmRzLCBwdlZpc2l0b3IuZXZlbnRSZWNvcmRzLCBwdlZpc2l0b3IuZGlyZWN0aXZlUmVjb3JkcywgZ2VuQ29uZmlnKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9jb2xsZWN0TmVzdGVkUHJvdG9WaWV3c1ZhcmlhYmxlTmFtZXMocHZWaXNpdG9ycykge1xyXG4gICAgdmFyIG5lc3RlZFB2VmFyaWFibGVOYW1lcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocHZWaXNpdG9ycy5sZW5ndGgpO1xyXG4gICAgcHZWaXNpdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwdikge1xyXG4gICAgICAgIHZhciBwYXJlbnRWYXJpYWJsZU5hbWVzID0gbGFuZ18xLmlzUHJlc2VudChwdi5wYXJlbnQpID8gbmVzdGVkUHZWYXJpYWJsZU5hbWVzW3B2LnBhcmVudC52aWV3SW5kZXhdIDogW107XHJcbiAgICAgICAgbmVzdGVkUHZWYXJpYWJsZU5hbWVzW3B2LnZpZXdJbmRleF0gPSBwYXJlbnRWYXJpYWJsZU5hbWVzLmNvbmNhdChwdi52YXJpYWJsZU5hbWVzKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5lc3RlZFB2VmFyaWFibGVOYW1lcztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGVmaW5pdGlvbl9mYWN0b3J5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgc291cmNlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9zb3VyY2VfbW9kdWxlJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3JfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yJyk7XHJcbnZhciBjaGFuZ2VfZGVmaW5pdGlvbl9mYWN0b3J5XzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZWZpbml0aW9uX2ZhY3RvcnknKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgY2hhbmdlX2RldGVjdG9yX2NvZGVnZW5fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy90cmFuc2Zvcm0vdGVtcGxhdGVfY29tcGlsZXIvY2hhbmdlX2RldGVjdG9yX2NvZGVnZW4nKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBBQlNUUkFDVF9DSEFOR0VfREVURUNUT1IgPSBcIkFic3RyYWN0Q2hhbmdlRGV0ZWN0b3JcIjtcclxudmFyIFVUSUwgPSBcIkNoYW5nZURldGVjdGlvblV0aWxcIjtcclxudmFyIEFCU1RSQUNUX0NIQU5HRV9ERVRFQ1RPUl9NT0RVTEUgPSBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKFwicGFja2FnZTphbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2Fic3RyYWN0X2NoYW5nZV9kZXRlY3RvclwiICsgdXRpbF8xLk1PRFVMRV9TVUZGSVgpO1xyXG52YXIgVVRJTF9NT0RVTEUgPSBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKFwicGFja2FnZTphbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb25fdXRpbFwiICsgdXRpbF8xLk1PRFVMRV9TVUZGSVgpO1xyXG52YXIgUFJFR0VOX1BST1RPX0NIQU5HRV9ERVRFQ1RPUl9NT0RVTEUgPSBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKFwicGFja2FnZTphbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3ByZWdlbl9wcm90b19jaGFuZ2VfZGV0ZWN0b3JcIiArIHV0aWxfMS5NT0RVTEVfU1VGRklYKTtcclxudmFyIENoYW5nZURldGVjdGlvbkNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdGlvbkNvbXBpbGVyKF9nZW5Db25maWcpIHtcclxuICAgICAgICB0aGlzLl9nZW5Db25maWcgPSBfZ2VuQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnRSdW50aW1lID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIHN0cmF0ZWd5LCBwYXJzZWRUZW1wbGF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMgPSBjaGFuZ2VfZGVmaW5pdGlvbl9mYWN0b3J5XzEuY3JlYXRlQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyhjb21wb25lbnRUeXBlLCBzdHJhdGVneSwgdGhpcy5fZ2VuQ29uZmlnLCBwYXJzZWRUZW1wbGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JlYXRlQ2hhbmdlRGV0ZWN0b3JGYWN0b3J5KGRlZmluaXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvbkNvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRGV0ZWN0b3JGYWN0b3J5ID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAodXRpbF8xLklTX0RBUlQgfHwgIXRoaXMuX2dlbkNvbmZpZy51c2VKaXQpIHtcclxuICAgICAgICAgICAgdmFyIHByb3RvID0gbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5EeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvcihkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7IHJldHVybiBwcm90by5pbnN0YW50aWF0ZShkaXNwYXRjaGVyKTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yXzEuQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IoZGVmaW5pdGlvbiwgVVRJTCwgQUJTVFJBQ1RfQ0hBTkdFX0RFVEVDVE9SKS5nZW5lcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25Db21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudENvZGVHZW4gPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgc3RyYXRlZ3ksIHBhcnNlZFRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMgPSBjaGFuZ2VfZGVmaW5pdGlvbl9mYWN0b3J5XzEuY3JlYXRlQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyhjb21wb25lbnRUeXBlLCBzdHJhdGVneSwgdGhpcy5fZ2VuQ29uZmlnLCBwYXJzZWRUZW1wbGF0ZSk7XHJcbiAgICAgICAgdmFyIGZhY3RvcmllcyA9IFtdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHNvdXJjZVBhcnRzID0gY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGNvZGVnZW47XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQYXJ0O1xyXG4gICAgICAgICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgdGhlIDIgY29kZSBnZW5lcmF0b3JzIHRvIHRoZSBzYW1lIHBsYWNlLCBvbmUgd2l0aCAuZGFydCBhbmQgb25lIHdpdGggLnRzXHJcbiAgICAgICAgICAgIC8vIHN1ZmZpeFxyXG4gICAgICAgICAgICAvLyBhbmQgaGF2ZSB0aGUgc2FtZSBBUEkgZm9yIGNhbGxpbmcgdGhlbSFcclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5JU19EQVJUKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlZ2VuID0gbmV3IGNoYW5nZV9kZXRlY3Rvcl9jb2RlZ2VuXzEuQ29kZWdlbihQUkVHRU5fUFJPVE9fQ0hBTkdFX0RFVEVDVE9SX01PRFVMRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gZGVmaW5pdGlvbi5pZDtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlUmVmID0gKGluZGV4ID09PSAwICYmIGNvbXBvbmVudFR5cGUuaXNIb3N0KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJ2R5bmFtaWMnIDpcclxuICAgICAgICAgICAgICAgICAgICBcIlwiICsgc291cmNlX21vZHVsZV8xLm1vZHVsZVJlZihjb21wb25lbnRUeXBlLm1vZHVsZVVybCkgKyBjb21wb25lbnRUeXBlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBjb2RlZ2VuLmdlbmVyYXRlKHR5cGVSZWYsIGNsYXNzTmFtZSwgZGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JpZXMucHVzaChcIihkaXNwYXRjaGVyKSA9PiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIihkaXNwYXRjaGVyKVwiKTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZVBhcnQgPSBjb2RlZ2VuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlZ2VuID0gbmV3IGNoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvcl8xLkNoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yKGRlZmluaXRpb24sIFwiXCIgKyBVVElMX01PRFVMRSArIFVUSUwsIFwiXCIgKyBBQlNUUkFDVF9DSEFOR0VfREVURUNUT1JfTU9EVUxFICsgQUJTVFJBQ1RfQ0hBTkdFX0RFVEVDVE9SKTtcclxuICAgICAgICAgICAgICAgIGZhY3Rvcmllcy5wdXNoKFwiZnVuY3Rpb24oZGlzcGF0Y2hlcikgeyByZXR1cm4gbmV3IFwiICsgY29kZWdlbi50eXBlTmFtZSArIFwiKGRpc3BhdGNoZXIpOyB9XCIpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlUGFydCA9IGNvZGVnZW4uZ2VuZXJhdGVTb3VyY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlUGFydDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VFeHByZXNzaW9ucyhzb3VyY2VQYXJ0cywgZmFjdG9yaWVzKTtcclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25Db21waWxlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWddKVxyXG4gICAgXSwgQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIpO1xyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdGlvbkNvbXBpbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvbkNvbXBpbGVyID0gQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rvcl9jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgdGVtcGxhdGVfY29tbWFuZHNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci90ZW1wbGF0ZV9jb21tYW5kcycpO1xyXG52YXIgdGVtcGxhdGVfYXN0XzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX2FzdCcpO1xyXG52YXIgc291cmNlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9zb3VyY2VfbW9kdWxlJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciBzdHlsZV9jb21waWxlcl8xID0gcmVxdWlyZSgnLi9zdHlsZV9jb21waWxlcicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuZXhwb3J0cy5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGID0gc291cmNlX21vZHVsZV8xLm1vZHVsZVJlZihcInBhY2thZ2U6YW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3RlbXBsYXRlX2NvbW1hbmRzXCIgKyB1dGlsXzEuTU9EVUxFX1NVRkZJWCk7XHJcbnZhciBJTVBMSUNJVF9URU1QTEFURV9WQVIgPSAnXFwkaW1wbGljaXQnO1xyXG52YXIgQ0xBU1NfQVRUUiA9ICdjbGFzcyc7XHJcbnZhciBTVFlMRV9BVFRSID0gJ3N0eWxlJztcclxudmFyIENvbW1hbmRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21tYW5kQ29tcGlsZXIoKSB7XHJcbiAgICB9XHJcbiAgICBDb21tYW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnRSdW50aW1lID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgYXBwSWQsIHRlbXBsYXRlSWQsIHRlbXBsYXRlLCBjaGFuZ2VEZXRlY3RvckZhY3RvcmllcywgY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yKG5ldyBSdW50aW1lQ29tbWFuZEZhY3RvcnkoY29tcG9uZW50LCBhcHBJZCwgdGVtcGxhdGVJZCwgY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5LCBjaGFuZ2VEZXRlY3RvckZhY3RvcmllcyksIDApO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgdGVtcGxhdGUpO1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnRDb2RlR2VuID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgYXBwSWRFeHByLCB0ZW1wbGF0ZUlkRXhwciwgdGVtcGxhdGUsIGNoYW5nZURldGVjdG9yRmFjdG9yeUV4cHJlc3Npb25zLCBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBDb21tYW5kQnVpbGRlclZpc2l0b3IobmV3IENvZGVnZW5Db21tYW5kRmFjdG9yeShjb21wb25lbnQsIGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIsIGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5RXhwcmVzc2lvbnMpLCAwKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHRlbXBsYXRlKTtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJbXCIgKyB2aXNpdG9yLnJlc3VsdC5qb2luKCcsJykgKyBcIl1cIjtcclxuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VFeHByZXNzaW9uKFtdLCBzb3VyY2UpO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRDb21waWxlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgQ29tbWFuZENvbXBpbGVyKTtcclxuICAgIHJldHVybiBDb21tYW5kQ29tcGlsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tbWFuZENvbXBpbGVyID0gQ29tbWFuZENvbXBpbGVyO1xyXG52YXIgUnVudGltZUNvbW1hbmRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJ1bnRpbWVDb21tYW5kRmFjdG9yeShjb21wb25lbnQsIGFwcElkLCB0ZW1wbGF0ZUlkLCBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnksIGNoYW5nZURldGVjdG9yRmFjdG9yaWVzKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVJZCA9IHRlbXBsYXRlSWQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkgPSBjb21wb25lbnRUZW1wbGF0ZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3RvcmllcyA9IGNoYW5nZURldGVjdG9yRmFjdG9yaWVzO1xyXG4gICAgfVxyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5fbWFwRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS50eXBlLnJ1bnRpbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuX2FkZFN0eWxlU2hpbUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0ck5hbWVBbmRWYWx1ZXMsIGxvY2FsQ29tcG9uZW50LCBsb2NhbFRlbXBsYXRlSWQpIHtcclxuICAgICAgICB2YXIgYWRkaXRpb25hbFN0eWxlcyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGxvY2FsQ29tcG9uZW50KSAmJlxyXG4gICAgICAgICAgICBsb2NhbENvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0eWxlcy5wdXNoKHN0eWxlX2NvbXBpbGVyXzEuc2hpbUhvc3RBdHRyaWJ1dGUodGhpcy5hcHBJZCwgbG9jYWxUZW1wbGF0ZUlkKSk7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdHlsZXMucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0eWxlcy5wdXNoKHN0eWxlX2NvbXBpbGVyXzEuc2hpbUNvbnRlbnRBdHRyaWJ1dGUodGhpcy5hcHBJZCwgdGhpcy50ZW1wbGF0ZUlkKSk7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdHlsZXMucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsU3R5bGVzLmNvbmNhdChhdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLnRleHQodmFsdWUsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU5nQ29udGVudCA9IGZ1bmN0aW9uIChpbmRleCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGVfY29tbWFuZHNfMS5uZ0NvbnRlbnQoaW5kZXgsIG5nQ29udGVudEluZGV4KTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUJlZ2luRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyTmFtZUFuZFZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLmJlZ2luRWxlbWVudChuYW1lLCB0aGlzLl9hZGRTdHlsZVNoaW1BdHRyaWJ1dGVzKGF0dHJOYW1lQW5kVmFsdWVzLCBudWxsLCBudWxsKSwgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCB0aGlzLl9tYXBEaXJlY3RpdmVzKGRpcmVjdGl2ZXMpLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVFbmRFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcGxhdGVfY29tbWFuZHNfMS5lbmRFbGVtZW50KCk7IH07XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUJlZ2luQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIG5hdGl2ZVNoYWRvdywgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgbmVzdGVkVGVtcGxhdGUgPSB0aGlzLmNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeShkaXJlY3RpdmVzWzBdKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGVfY29tbWFuZHNfMS5iZWdpbkNvbXBvbmVudChuYW1lLCB0aGlzLl9hZGRTdHlsZVNoaW1BdHRyaWJ1dGVzKGF0dHJOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzWzBdLCBuZXN0ZWRUZW1wbGF0ZS5pZCksIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgdGhpcy5fbWFwRGlyZWN0aXZlcyhkaXJlY3RpdmVzKSwgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCwgbmVzdGVkVGVtcGxhdGUpO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcGxhdGVfY29tbWFuZHNfMS5lbmRDb21wb25lbnQoKTsgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChlbWJlZGRlZFRlbXBsYXRlSW5kZXgsIGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgY2hpbGRyZW4pIHtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGVfY29tbWFuZHNfMS5lbWJlZGRlZFRlbXBsYXRlKGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIHRoaXMuX21hcERpcmVjdGl2ZXMoZGlyZWN0aXZlcyksIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3Rvcmllc1tlbWJlZGRlZFRlbXBsYXRlSW5kZXhdLCBjaGlsZHJlbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJ1bnRpbWVDb21tYW5kRmFjdG9yeTtcclxufSkoKTtcclxudmFyIENvZGVnZW5Db21tYW5kRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkoY29tcG9uZW50LCBhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByLCBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnksIGNoYW5nZURldGVjdG9yRmFjdG9yeUV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5hcHBJZEV4cHIgPSBhcHBJZEV4cHI7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUlkRXhwciA9IHRlbXBsYXRlSWRFeHByO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5ID0gY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5RXhwcmVzc2lvbnMgPSBjaGFuZ2VEZXRlY3RvckZhY3RvcnlFeHByZXNzaW9ucztcclxuICAgIH1cclxuICAgIENvZGVnZW5Db21tYW5kRmFjdG9yeS5wcm90b3R5cGUuX2FkZFN0eWxlU2hpbUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0ck5hbWVBbmRWYWx1ZXMsIGxvY2FsQ29tcG9uZW50LCBsb2NhbFRlbXBsYXRlSWRFeHByKSB7XHJcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxTdGx5ZXMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChsb2NhbENvbXBvbmVudCkgJiZcclxuICAgICAgICAgICAgbG9jYWxDb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKSB7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdGx5ZXMucHVzaChuZXcgRXhwcmVzc2lvbihzdHlsZV9jb21waWxlcl8xLnNoaW1Ib3N0QXR0cmlidXRlRXhwcih0aGlzLmFwcElkRXhwciwgbG9jYWxUZW1wbGF0ZUlkRXhwcikpKTtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0bHllcy5wdXNoKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsU3RseWVzLnB1c2gobmV3IEV4cHJlc3Npb24oc3R5bGVfY29tcGlsZXJfMS5zaGltQ29udGVudEF0dHJpYnV0ZUV4cHIodGhpcy5hcHBJZEV4cHIsIHRoaXMudGVtcGxhdGVJZEV4cHIpKSk7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdGx5ZXMucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsU3RseWVzLmNvbmNhdChhdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcInRleHQoXCIgKyB1dGlsXzEuZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcodmFsdWUpICsgXCIsIFwiICsgaXNCb3VuZCArIFwiLCBcIiArIG5nQ29udGVudEluZGV4ICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVOZ0NvbnRlbnQgPSBmdW5jdGlvbiAoaW5kZXgsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwibmdDb250ZW50KFwiICsgaW5kZXggKyBcIiwgXCIgKyBuZ0NvbnRlbnRJbmRleCArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5Db21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIGF0dHJzRXhwcmVzc2lvbiA9IGNvZGVHZW5BcnJheSh0aGlzLl9hZGRTdHlsZVNoaW1BdHRyaWJ1dGVzKGF0dHJOYW1lQW5kVmFsdWVzLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiYmVnaW5FbGVtZW50KFwiICsgdXRpbF8xLmVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nKG5hbWUpICsgXCIsIFwiICsgYXR0cnNFeHByZXNzaW9uICsgXCIsIFwiICsgY29kZUdlbkFycmF5KGV2ZW50VGFyZ2V0QW5kTmFtZXMpICsgXCIsIFwiICsgY29kZUdlbkFycmF5KHZhcmlhYmxlTmFtZUFuZFZhbHVlcykgKyBcIiwgXCIgKyBjb2RlR2VuRGlyZWN0aXZlc0FycmF5KGRpcmVjdGl2ZXMpICsgXCIsIFwiICsgaXNCb3VuZCArIFwiLCBcIiArIG5nQ29udGVudEluZGV4ICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVFbmRFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGICsgXCJlbmRFbGVtZW50KClcIjsgfTtcclxuICAgIENvZGVnZW5Db21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQmVnaW5Db21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRDb21wRXhwciA9IHRoaXMuY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5KGRpcmVjdGl2ZXNbMF0pO1xyXG4gICAgICAgIHZhciBhdHRyc0V4cHJlc3Npb24gPSBjb2RlR2VuQXJyYXkodGhpcy5fYWRkU3R5bGVTaGltQXR0cmlidXRlcyhhdHRyTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlc1swXSwgbmVzdGVkQ29tcEV4cHIgKyBcIi5pZFwiKSk7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiYmVnaW5Db21wb25lbnQoXCIgKyB1dGlsXzEuZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcobmFtZSkgKyBcIiwgXCIgKyBhdHRyc0V4cHJlc3Npb24gKyBcIiwgXCIgKyBjb2RlR2VuQXJyYXkoZXZlbnRUYXJnZXRBbmROYW1lcykgKyBcIiwgXCIgKyBjb2RlR2VuQXJyYXkodmFyaWFibGVOYW1lQW5kVmFsdWVzKSArIFwiLCBcIiArIGNvZGVHZW5EaXJlY3RpdmVzQXJyYXkoZGlyZWN0aXZlcykgKyBcIiwgXCIgKyBuYXRpdmVTaGFkb3cgKyBcIiwgXCIgKyBuZ0NvbnRlbnRJbmRleCArIFwiLCBcIiArIG5lc3RlZENvbXBFeHByICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVFbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcImVuZENvbXBvbmVudCgpXCI7IH07XHJcbiAgICBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoZW1iZWRkZWRUZW1wbGF0ZUluZGV4LCBhdHRyTmFtZUFuZFZhbHVlcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc01lcmdlZCwgbmdDb250ZW50SW5kZXgsIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmV0dXJuIChleHBvcnRzLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcImVtYmVkZGVkVGVtcGxhdGUoXCIgKyBjb2RlR2VuQXJyYXkoYXR0ck5hbWVBbmRWYWx1ZXMpICsgXCIsIFwiICsgY29kZUdlbkFycmF5KHZhcmlhYmxlTmFtZUFuZFZhbHVlcykgKyBcIiwgXCIpICtcclxuICAgICAgICAgICAgKGNvZGVHZW5EaXJlY3RpdmVzQXJyYXkoZGlyZWN0aXZlcykgKyBcIiwgXCIgKyBpc01lcmdlZCArIFwiLCBcIiArIG5nQ29udGVudEluZGV4ICsgXCIsIFwiICsgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3RvcnlFeHByZXNzaW9uc1tlbWJlZGRlZFRlbXBsYXRlSW5kZXhdICsgXCIsIFtcIiArIGNoaWxkcmVuLmpvaW4oJywnKSArIFwiXSlcIik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvZGVnZW5Db21tYW5kRmFjdG9yeTtcclxufSkoKTtcclxuZnVuY3Rpb24gdmlzaXRBbmRSZXR1cm5Db250ZXh0KHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcclxuICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCk7XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG52YXIgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbW1hbmRCdWlsZGVyVmlzaXRvcihjb21tYW5kRmFjdG9yeSwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kRmFjdG9yeSA9IGNvbW1hbmRGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuZW1iZWRkZWRUZW1wbGF0ZUluZGV4ID0gZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlTmdDb250ZW50Q291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fcmVhZEF0dHJOYW1lQW5kVmFsdWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGF0dHJBc3RzKSB7XHJcbiAgICAgICAgdmFyIGF0dHJzID0ga2V5VmFsdWVBcnJheVRvTWFwKHZpc2l0QW5kUmV0dXJuQ29udGV4dCh0aGlzLCBhdHRyQXN0cywgW10pKTtcclxuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZU1ldGEpIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChkaXJlY3RpdmVNZXRhLmhvc3RBdHRyaWJ1dGVzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBhdHRyc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGF0dHJzW25hbWVdID0gbGFuZ18xLmlzUHJlc2VudChwcmV2VmFsdWUpID8gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShuYW1lLCBwcmV2VmFsdWUsIHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWFwVG9LZXlWYWx1ZUFycmF5KGF0dHJzKTtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZU5nQ29udGVudENvdW50Kys7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQucHVzaCh0aGlzLmNvbW1hbmRGYWN0b3J5LmNyZWF0ZU5nQ29udGVudChhc3QuaW5kZXgsIGFzdC5uZ0NvbnRlbnRJbmRleCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lbWJlZGRlZFRlbXBsYXRlSW5kZXgrKztcclxuICAgICAgICB2YXIgY2hpbGRWaXNpdG9yID0gbmV3IENvbW1hbmRCdWlsZGVyVmlzaXRvcih0aGlzLmNvbW1hbmRGYWN0b3J5LCB0aGlzLmVtYmVkZGVkVGVtcGxhdGVJbmRleCk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbChjaGlsZFZpc2l0b3IsIGFzdC5jaGlsZHJlbik7XHJcbiAgICAgICAgdmFyIGlzTWVyZ2VkID0gY2hpbGRWaXNpdG9yLnRyYW5zaXRpdmVOZ0NvbnRlbnRDb3VudCA+IDA7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZUFuZFZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGFzdC52YXJzLmZvckVhY2goZnVuY3Rpb24gKHZhckFzdCkge1xyXG4gICAgICAgICAgICB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMucHVzaCh2YXJBc3QubmFtZSk7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZUFuZFZhbHVlcy5wdXNoKHZhckFzdC52YWx1ZS5sZW5ndGggPiAwID8gdmFyQXN0LnZhbHVlIDogSU1QTElDSVRfVEVNUExBVEVfVkFSKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KGFzdC5kaXJlY3RpdmVzLCBmdW5jdGlvbiAoZGlyZWN0aXZlQXN0LCBpbmRleCkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVBc3QudmlzaXQoX3RoaXMsIG5ldyBEaXJlY3RpdmVDb250ZXh0KGluZGV4LCBbXSwgW10sIGRpcmVjdGl2ZXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlRW1iZWRkZWRUZW1wbGF0ZSh0aGlzLmVtYmVkZGVkVGVtcGxhdGVJbmRleCwgdGhpcy5fcmVhZEF0dHJOYW1lQW5kVmFsdWVzKGRpcmVjdGl2ZXMsIGFzdC5hdHRycyksIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgaXNNZXJnZWQsIGFzdC5uZ0NvbnRlbnRJbmRleCwgY2hpbGRWaXNpdG9yLnJlc3VsdCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZU5nQ29udGVudENvdW50ICs9IGNoaWxkVmlzaXRvci50cmFuc2l0aXZlTmdDb250ZW50Q291bnQ7XHJcbiAgICAgICAgdGhpcy5lbWJlZGRlZFRlbXBsYXRlSW5kZXggPSBjaGlsZFZpc2l0b3IuZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGFzdC5nZXRDb21wb25lbnQoKTtcclxuICAgICAgICB2YXIgZXZlbnRUYXJnZXRBbmROYW1lcyA9IHZpc2l0QW5kUmV0dXJuQ29udGV4dCh0aGlzLCBhc3Qub3V0cHV0cywgW10pO1xyXG4gICAgICAgIHZhciB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICBhc3QuZXhwb3J0QXNWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhckFzdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lQW5kVmFsdWVzLnB1c2godmFyQXN0Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lQW5kVmFsdWVzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KGFzdC5kaXJlY3RpdmVzLCBmdW5jdGlvbiAoZGlyZWN0aXZlQXN0LCBpbmRleCkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVBc3QudmlzaXQoX3RoaXMsIG5ldyBEaXJlY3RpdmVDb250ZXh0KGluZGV4LCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudFRhcmdldEFuZE5hbWVzID0gcmVtb3ZlS2V5VmFsdWVBcnJheUR1cGxpY2F0ZXMoZXZlbnRUYXJnZXRBbmROYW1lcyk7XHJcbiAgICAgICAgdmFyIGF0dHJOYW1lQW5kVmFsdWVzID0gdGhpcy5fcmVhZEF0dHJOYW1lQW5kVmFsdWVzKGRpcmVjdGl2ZXMsIGFzdC5hdHRycyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlQmVnaW5Db21wb25lbnQoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGNvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlLCBhc3QubmdDb250ZW50SW5kZXgpKTtcclxuICAgICAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlRW5kQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaCh0aGlzLmNvbW1hbmRGYWN0b3J5LmNyZWF0ZUJlZ2luRWxlbWVudChhc3QubmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgYXN0LmlzQm91bmQoKSwgYXN0Lm5nQ29udGVudEluZGV4KSk7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaCh0aGlzLmNvbW1hbmRGYWN0b3J5LmNyZWF0ZUVuZEVsZW1lbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgYXR0ck5hbWVBbmRWYWx1ZXMpIHtcclxuICAgICAgICBhdHRyTmFtZUFuZFZhbHVlcy5wdXNoKGFzdC5uYW1lKTtcclxuICAgICAgICBhdHRyTmFtZUFuZFZhbHVlcy5wdXNoKGFzdC52YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlVGV4dChudWxsLCB0cnVlLCBhc3QubmdDb250ZW50SW5kZXgpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlVGV4dChhc3QudmFsdWUsIGZhbHNlLCBhc3QubmdDb250ZW50SW5kZXgpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XHJcbiAgICAgICAgY3R4LnRhcmdldERpcmVjdGl2ZXMucHVzaChhc3QuZGlyZWN0aXZlKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5ob3N0RXZlbnRzLCBjdHguZXZlbnRUYXJnZXRBbmROYW1lcyk7XHJcbiAgICAgICAgYXN0LmV4cG9ydEFzVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJBc3QpIHtcclxuICAgICAgICAgICAgY3R4LnRhcmdldFZhcmlhYmxlTmFtZUFuZFZhbHVlcy5wdXNoKHZhckFzdC5uYW1lKTtcclxuICAgICAgICAgICAgY3R4LnRhcmdldFZhcmlhYmxlTmFtZUFuZFZhbHVlcy5wdXNoKGN0eC5pbmRleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnRUYXJnZXRBbmROYW1lcykge1xyXG4gICAgICAgIGV2ZW50VGFyZ2V0QW5kTmFtZXMucHVzaChhc3QudGFyZ2V0KTtcclxuICAgICAgICBldmVudFRhcmdldEFuZE5hbWVzLnB1c2goYXN0Lm5hbWUpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIHJldHVybiBDb21tYW5kQnVpbGRlclZpc2l0b3I7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIHJlbW92ZUtleVZhbHVlQXJyYXlEdXBsaWNhdGVzKGtleVZhbHVlQXJyYXkpIHtcclxuICAgIHZhciBrbm93blBhaXJzID0gbmV3IFNldCgpO1xyXG4gICAgdmFyIHJlc3VsdEtleVZhbHVlQXJyYXkgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVBcnJheS5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlWYWx1ZUFycmF5W2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGtleVZhbHVlQXJyYXlbaSArIDFdO1xyXG4gICAgICAgIHZhciBwYWlySWQgPSBrZXkgKyBcIjpcIiArIHZhbHVlO1xyXG4gICAgICAgIGlmICghY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKGtub3duUGFpcnMsIHBhaXJJZCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0S2V5VmFsdWVBcnJheS5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIHJlc3VsdEtleVZhbHVlQXJyYXkucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGtub3duUGFpcnMuYWRkKHBhaXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdEtleVZhbHVlQXJyYXk7XHJcbn1cclxuZnVuY3Rpb24ga2V5VmFsdWVBcnJheVRvTWFwKGtleVZhbHVlQXJyKSB7XHJcbiAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZUFyci5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIGRhdGFba2V5VmFsdWVBcnJbaV1dID0ga2V5VmFsdWVBcnJbaSArIDFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuZnVuY3Rpb24gbWFwVG9LZXlWYWx1ZUFycmF5KGRhdGEpIHtcclxuICAgIHZhciBlbnRyeUFycmF5ID0gW107XHJcbiAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkgeyBlbnRyeUFycmF5LnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xyXG4gICAgLy8gV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXHJcbiAgICAvLyBmb3IgdGVzdHMgYW5kIGZvciBjYWNoaW5nIGdlbmVyYXRlZCBhcnRpZmFjdHMuLi5cclxuICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5zb3J0KGVudHJ5QXJyYXksIGZ1bmN0aW9uIChlbnRyeTEsIGVudHJ5MikgeyByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuY29tcGFyZShlbnRyeTFbMF0sIGVudHJ5MlswXSk7IH0pO1xyXG4gICAgdmFyIGtleVZhbHVlQXJyYXkgPSBbXTtcclxuICAgIGVudHJ5QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBrZXlWYWx1ZUFycmF5LnB1c2goZW50cnlbMF0pO1xyXG4gICAgICAgIGtleVZhbHVlQXJyYXkucHVzaChlbnRyeVsxXSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBrZXlWYWx1ZUFycmF5O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlVmFsdWUoYXR0ck5hbWUsIGF0dHJWYWx1ZTEsIGF0dHJWYWx1ZTIpIHtcclxuICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSIHx8IGF0dHJOYW1lID09IFNUWUxFX0FUVFIpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xyXG4gICAgfVxyXG59XHJcbnZhciBEaXJlY3RpdmVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZUNvbnRleHQoaW5kZXgsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHRhcmdldFZhcmlhYmxlTmFtZUFuZFZhbHVlcywgdGFyZ2V0RGlyZWN0aXZlcykge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0QW5kTmFtZXMgPSBldmVudFRhcmdldEFuZE5hbWVzO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0VmFyaWFibGVOYW1lQW5kVmFsdWVzID0gdGFyZ2V0VmFyaWFibGVOYW1lQW5kVmFsdWVzO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0RGlyZWN0aXZlcyA9IHRhcmdldERpcmVjdGl2ZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlQ29udGV4dDtcclxufSkoKTtcclxudmFyIEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBFeHByZXNzaW9uO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBlc2NhcGVWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhbmdfMS5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdXRpbF8xLmVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvZGVHZW5BcnJheShkYXRhKSB7XHJcbiAgICByZXR1cm4gXCJbXCIgKyBkYXRhLm1hcChlc2NhcGVWYWx1ZSkuam9pbignLCcpICsgXCJdXCI7XHJcbn1cclxuZnVuY3Rpb24gY29kZUdlbkRpcmVjdGl2ZXNBcnJheShkaXJlY3RpdmVzKSB7XHJcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkgeyByZXR1cm4gKFwiXCIgKyBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKGRpcmVjdGl2ZVR5cGUudHlwZS5tb2R1bGVVcmwpICsgZGlyZWN0aXZlVHlwZS50eXBlLm5hbWUpOyB9KTtcclxuICAgIHJldHVybiBcIltcIiArIGV4cHJlc3Npb25zLmpvaW4oJywnKSArIFwiXVwiO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmRfY29tcGlsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBydW50aW1lX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lX2NvbXBpbGVyXCIpO1xyXG52YXIgdGVtcGxhdGVfY29tcGlsZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfY29tcGlsZXInKTtcclxuZXhwb3J0cy5UZW1wbGF0ZUNvbXBpbGVyID0gdGVtcGxhdGVfY29tcGlsZXJfMS5UZW1wbGF0ZUNvbXBpbGVyO1xyXG52YXIgZGlyZWN0aXZlX21ldGFkYXRhXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9tZXRhZGF0YScpO1xyXG5leHBvcnRzLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IGRpcmVjdGl2ZV9tZXRhZGF0YV8xLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcclxuZXhwb3J0cy5Db21waWxlVHlwZU1ldGFkYXRhID0gZGlyZWN0aXZlX21ldGFkYXRhXzEuQ29tcGlsZVR5cGVNZXRhZGF0YTtcclxuZXhwb3J0cy5Db21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IGRpcmVjdGl2ZV9tZXRhZGF0YV8xLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xyXG52YXIgc291cmNlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9zb3VyY2VfbW9kdWxlJyk7XHJcbmV4cG9ydHMuU291cmNlTW9kdWxlID0gc291cmNlX21vZHVsZV8xLlNvdXJjZU1vZHVsZTtcclxuZXhwb3J0cy5Tb3VyY2VXaXRoSW1wb3J0cyA9IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VXaXRoSW1wb3J0cztcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIHRlbXBsYXRlX3BhcnNlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfcGFyc2VyJyk7XHJcbnZhciBodG1sX3BhcnNlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvaHRtbF9wYXJzZXInKTtcclxudmFyIHRlbXBsYXRlX25vcm1hbGl6ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX25vcm1hbGl6ZXInKTtcclxudmFyIHJ1bnRpbWVfbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3J1bnRpbWVfbWV0YWRhdGEnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rvcl9jb21waWxlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyJyk7XHJcbnZhciBzdHlsZV9jb21waWxlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc3R5bGVfY29tcGlsZXInKTtcclxudmFyIGNvbW1hbmRfY29tcGlsZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL2NvbW1hbmRfY29tcGlsZXInKTtcclxudmFyIHRlbXBsYXRlX2NvbXBpbGVyXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci90ZW1wbGF0ZV9jb21waWxlcicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2NvbXBpbGVyJyk7XHJcbnZhciBydW50aW1lX2NvbXBpbGVyXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9ydW50aW1lX2NvbXBpbGVyJyk7XHJcbnZhciBlbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5Jyk7XHJcbnZhciBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NjaGVtYS9kb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnknKTtcclxudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXJsX3Jlc29sdmVyJyk7XHJcbnZhciBhcHBfcm9vdF91cmxfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL2FwcF9yb290X3VybCcpO1xyXG52YXIgYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybCcpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbmZ1bmN0aW9uIGNvbXBpbGVyUHJvdmlkZXJzKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzIuTGV4ZXIsXHJcbiAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8yLlBhcnNlcixcclxuICAgICAgICBodG1sX3BhcnNlcl8xLkh0bWxQYXJzZXIsXHJcbiAgICAgICAgdGVtcGxhdGVfcGFyc2VyXzEuVGVtcGxhdGVQYXJzZXIsXHJcbiAgICAgICAgdGVtcGxhdGVfbm9ybWFsaXplcl8xLlRlbXBsYXRlTm9ybWFsaXplcixcclxuICAgICAgICBydW50aW1lX21ldGFkYXRhXzEuUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIsXHJcbiAgICAgICAgc3R5bGVfY29tcGlsZXJfMS5TdHlsZUNvbXBpbGVyLFxyXG4gICAgICAgIGNvbW1hbmRfY29tcGlsZXJfMS5Db21tYW5kQ29tcGlsZXIsXHJcbiAgICAgICAgY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyXzEuQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvckdlbkNvbmZpZywge1xyXG4gICAgICAgICAgICB1c2VWYWx1ZTogbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvckdlbkNvbmZpZyhsYW5nXzEuYXNzZXJ0aW9uc0VuYWJsZWQoKSwgbGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCksIGZhbHNlLCB0cnVlKVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHRlbXBsYXRlX2NvbXBpbGVyXzIuVGVtcGxhdGVDb21waWxlcixcclxuICAgICAgICBkaV8xLnByb3ZpZGUocnVudGltZV9jb21waWxlcl8yLlJ1bnRpbWVDb21waWxlciwgeyB1c2VDbGFzczogcnVudGltZV9jb21waWxlcl8xLlJ1bnRpbWVDb21waWxlcl8gfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGNvbXBpbGVyXzEuQ29tcGlsZXIsIHsgdXNlRXhpc3Rpbmc6IHJ1bnRpbWVfY29tcGlsZXJfMi5SdW50aW1lQ29tcGlsZXIgfSksXHJcbiAgICAgICAgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShlbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgeyB1c2VFeGlzdGluZzogZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5IH0pLFxyXG4gICAgICAgIGFuY2hvcl9iYXNlZF9hcHBfcm9vdF91cmxfMS5BbmNob3JCYXNlZEFwcFJvb3RVcmwsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGFwcF9yb290X3VybF8xLkFwcFJvb3RVcmwsIHsgdXNlRXhpc3Rpbmc6IGFuY2hvcl9iYXNlZF9hcHBfcm9vdF91cmxfMS5BbmNob3JCYXNlZEFwcFJvb3RVcmwgfSksXHJcbiAgICAgICAgdXJsX3Jlc29sdmVyXzEuVXJsUmVzb2x2ZXJcclxuICAgIF07XHJcbn1cclxuZXhwb3J0cy5jb21waWxlclByb3ZpZGVycyA9IGNvbXBpbGVyUHJvdmlkZXJzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciBzZWxlY3Rvcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2VsZWN0b3InKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2ludGVyZmFjZXMnKTtcclxuLy8gZ3JvdXAgMTogXCJwcm9wZXJ0eVwiIGZyb20gXCJbcHJvcGVydHldXCJcclxuLy8gZ3JvdXAgMjogXCJldmVudFwiIGZyb20gXCIoZXZlbnQpXCJcclxudmFyIEhPU1RfUkVHX0VYUCA9IC9eKD86KD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpKSQvZztcclxudmFyIENvbXBpbGVUeXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tcGlsZVR5cGVNZXRhZGF0YShfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBydW50aW1lID0gX2IucnVudGltZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgaXNIb3N0ID0gX2IuaXNIb3N0O1xyXG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcclxuICAgICAgICB0aGlzLmlzSG9zdCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGlzSG9zdCk7XHJcbiAgICB9XHJcbiAgICBDb21waWxlVHlwZU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUeXBlTWV0YWRhdGEoeyBuYW1lOiBkYXRhWyduYW1lJ10sIG1vZHVsZVVybDogZGF0YVsnbW9kdWxlVXJsJ10sIGlzSG9zdDogZGF0YVsnaXNIb3N0J10gfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcGlsZVR5cGVNZXRhZGF0YS5wcm90b3R5cGUudG9Kc29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFJ1bnRpbWUgdHlwZSBjYW4ndCBiZSBzZXJpYWxpemVkLi4uXHJcbiAgICAgICAgICAgICduYW1lJzogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAnbW9kdWxlVXJsJzogdGhpcy5tb2R1bGVVcmwsXHJcbiAgICAgICAgICAgICdpc0hvc3QnOiB0aGlzLmlzSG9zdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBpbGVUeXBlTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZVR5cGVNZXRhZGF0YSA9IENvbXBpbGVUeXBlTWV0YWRhdGE7XHJcbnZhciBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YShfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBlbmNhcHN1bGF0aW9uID0gX2IuZW5jYXBzdWxhdGlvbiwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgc3R5bGVzID0gX2Iuc3R5bGVzLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHMsIG5nQ29udGVudFNlbGVjdG9ycyA9IF9iLm5nQ29udGVudFNlbGVjdG9ycztcclxuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBsYW5nXzEuaXNQcmVzZW50KGVuY2Fwc3VsYXRpb24pID8gZW5jYXBzdWxhdGlvbiA6IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gbGFuZ18xLmlzUHJlc2VudChzdHlsZXMpID8gc3R5bGVzIDogW107XHJcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBsYW5nXzEuaXNQcmVzZW50KHN0eWxlVXJscykgPyBzdHlsZVVybHMgOiBbXTtcclxuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IGxhbmdfMS5pc1ByZXNlbnQobmdDb250ZW50U2VsZWN0b3JzKSA/IG5nQ29udGVudFNlbGVjdG9ycyA6IFtdO1xyXG4gICAgfVxyXG4gICAgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEuZnJvbUpzb24gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBsYW5nXzEuaXNQcmVzZW50KGRhdGFbJ2VuY2Fwc3VsYXRpb24nXSkgP1xyXG4gICAgICAgICAgICAgICAgdmlld18xLlZJRVdfRU5DQVBTVUxBVElPTl9WQUxVRVNbZGF0YVsnZW5jYXBzdWxhdGlvbiddXSA6XHJcbiAgICAgICAgICAgICAgICBkYXRhWydlbmNhcHN1bGF0aW9uJ10sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhWyd0ZW1wbGF0ZSddLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGF0YVsndGVtcGxhdGVVcmwnXSxcclxuICAgICAgICAgICAgc3R5bGVzOiBkYXRhWydzdHlsZXMnXSxcclxuICAgICAgICAgICAgc3R5bGVVcmxzOiBkYXRhWydzdHlsZVVybHMnXSxcclxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBkYXRhWyduZ0NvbnRlbnRTZWxlY3RvcnMnXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2VuY2Fwc3VsYXRpb24nOiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZW5jYXBzdWxhdGlvbikgPyBsYW5nXzEuc2VyaWFsaXplRW51bSh0aGlzLmVuY2Fwc3VsYXRpb24pIDogdGhpcy5lbmNhcHN1bGF0aW9uLFxyXG4gICAgICAgICAgICAndGVtcGxhdGUnOiB0aGlzLnRlbXBsYXRlLFxyXG4gICAgICAgICAgICAndGVtcGxhdGVVcmwnOiB0aGlzLnRlbXBsYXRlVXJsLFxyXG4gICAgICAgICAgICAnc3R5bGVzJzogdGhpcy5zdHlsZXMsXHJcbiAgICAgICAgICAgICdzdHlsZVVybHMnOiB0aGlzLnN0eWxlVXJscyxcclxuICAgICAgICAgICAgJ25nQ29udGVudFNlbGVjdG9ycyc6IHRoaXMubmdDb250ZW50U2VsZWN0b3JzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcclxudmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIGR5bmFtaWNMb2FkYWJsZSA9IF9iLmR5bmFtaWNMb2FkYWJsZSwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2IuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYi5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYi5ob3N0QXR0cmlidXRlcywgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuaXNDb21wb25lbnQgPSBpc0NvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNMb2FkYWJsZSA9IGR5bmFtaWNMb2FkYWJsZTtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5leHBvcnRBcyA9IGV4cG9ydEFzO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xyXG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XHJcbiAgICAgICAgdGhpcy5ob3N0TGlzdGVuZXJzID0gaG9zdExpc3RlbmVycztcclxuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XHJcbiAgICAgICAgdGhpcy5ob3N0QXR0cmlidXRlcyA9IGhvc3RBdHRyaWJ1dGVzO1xyXG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBsaWZlY3ljbGVIb29rcztcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBpc0NvbXBvbmVudCA9IF9iLmlzQ29tcG9uZW50LCBkeW5hbWljTG9hZGFibGUgPSBfYi5keW5hbWljTG9hZGFibGUsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgaG9zdCA9IF9iLmhvc3QsIGxpZmVjeWNsZUhvb2tzID0gX2IubGlmZWN5Y2xlSG9va3MsIHRlbXBsYXRlID0gX2IudGVtcGxhdGU7XHJcbiAgICAgICAgdmFyIGhvc3RMaXN0ZW5lcnMgPSB7fTtcclxuICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICB2YXIgaG9zdEF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob3N0KSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGhvc3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goSE9TVF9SRUdfRVhQLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1hdGNoZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaGVzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzW21hdGNoZXNbMV1dID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoZXNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyc1ttYXRjaGVzWzJdXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlucHV0c01hcCA9IHt9O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGlucHV0cykpIHtcclxuICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1dGlsXzEuc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3V0cHV0c01hcCA9IHt9O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG91dHB1dHMpKSB7XHJcbiAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IGVsUHJvcGBcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHV0aWxfMS5zcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiBsYW5nXzEubm9ybWFsaXplQm9vbChpc0NvbXBvbmVudCksXHJcbiAgICAgICAgICAgIGR5bmFtaWNMb2FkYWJsZTogbGFuZ18xLm5vcm1hbGl6ZUJvb2woZHluYW1pY0xvYWRhYmxlKSxcclxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxyXG4gICAgICAgICAgICBleHBvcnRBczogZXhwb3J0QXMsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0c01hcCxcclxuICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0c01hcCxcclxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogaG9zdExpc3RlbmVycyxcclxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IGhvc3RQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogaG9zdEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBsYW5nXzEuaXNQcmVzZW50KGxpZmVjeWNsZUhvb2tzKSA/IGxpZmVjeWNsZUhvb2tzIDogW10sIHRlbXBsYXRlOiB0ZW1wbGF0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogZGF0YVsnaXNDb21wb25lbnQnXSxcclxuICAgICAgICAgICAgZHluYW1pY0xvYWRhYmxlOiBkYXRhWydkeW5hbWljTG9hZGFibGUnXSxcclxuICAgICAgICAgICAgc2VsZWN0b3I6IGRhdGFbJ3NlbGVjdG9yJ10sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiBkYXRhWydleHBvcnRBcyddLFxyXG4gICAgICAgICAgICB0eXBlOiBsYW5nXzEuaXNQcmVzZW50KGRhdGFbJ3R5cGUnXSkgPyBDb21waWxlVHlwZU1ldGFkYXRhLmZyb21Kc29uKGRhdGFbJ3R5cGUnXSkgOiBkYXRhWyd0eXBlJ10sXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogbGFuZ18xLmlzUHJlc2VudChkYXRhWydjaGFuZ2VEZXRlY3Rpb24nXSkgP1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkNIQU5HRV9ERUNUSU9OX1NUUkFURUdZX1ZBTFVFU1tkYXRhWydjaGFuZ2VEZXRlY3Rpb24nXV0gOlxyXG4gICAgICAgICAgICAgICAgZGF0YVsnY2hhbmdlRGV0ZWN0aW9uJ10sXHJcbiAgICAgICAgICAgIGlucHV0czogZGF0YVsnaW5wdXRzJ10sXHJcbiAgICAgICAgICAgIG91dHB1dHM6IGRhdGFbJ291dHB1dHMnXSxcclxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogZGF0YVsnaG9zdExpc3RlbmVycyddLFxyXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogZGF0YVsnaG9zdFByb3BlcnRpZXMnXSxcclxuICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGRhdGFbJ2hvc3RBdHRyaWJ1dGVzJ10sXHJcbiAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBkYXRhWydsaWZlY3ljbGVIb29rcyddLm1hcChmdW5jdGlvbiAoaG9va1ZhbHVlKSB7IHJldHVybiBpbnRlcmZhY2VzXzEuTElGRUNZQ0xFX0hPT0tTX1ZBTFVFU1tob29rVmFsdWVdOyB9KSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IGxhbmdfMS5pc1ByZXNlbnQoZGF0YVsndGVtcGxhdGUnXSkgPyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5mcm9tSnNvbihkYXRhWyd0ZW1wbGF0ZSddKSA6XHJcbiAgICAgICAgICAgICAgICBkYXRhWyd0ZW1wbGF0ZSddXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2lzQ29tcG9uZW50JzogdGhpcy5pc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgJ2R5bmFtaWNMb2FkYWJsZSc6IHRoaXMuZHluYW1pY0xvYWRhYmxlLFxyXG4gICAgICAgICAgICAnc2VsZWN0b3InOiB0aGlzLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICAnZXhwb3J0QXMnOiB0aGlzLmV4cG9ydEFzLFxyXG4gICAgICAgICAgICAndHlwZSc6IGxhbmdfMS5pc1ByZXNlbnQodGhpcy50eXBlKSA/IHRoaXMudHlwZS50b0pzb24oKSA6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgJ2NoYW5nZURldGVjdGlvbic6IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jaGFuZ2VEZXRlY3Rpb24pID8gbGFuZ18xLnNlcmlhbGl6ZUVudW0odGhpcy5jaGFuZ2VEZXRlY3Rpb24pIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICAnaW5wdXRzJzogdGhpcy5pbnB1dHMsXHJcbiAgICAgICAgICAgICdvdXRwdXRzJzogdGhpcy5vdXRwdXRzLFxyXG4gICAgICAgICAgICAnaG9zdExpc3RlbmVycyc6IHRoaXMuaG9zdExpc3RlbmVycyxcclxuICAgICAgICAgICAgJ2hvc3RQcm9wZXJ0aWVzJzogdGhpcy5ob3N0UHJvcGVydGllcyxcclxuICAgICAgICAgICAgJ2hvc3RBdHRyaWJ1dGVzJzogdGhpcy5ob3N0QXR0cmlidXRlcyxcclxuICAgICAgICAgICAgJ2xpZmVjeWNsZUhvb2tzJzogdGhpcy5saWZlY3ljbGVIb29rcy5tYXAoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGxhbmdfMS5zZXJpYWxpemVFbnVtKGhvb2spOyB9KSxcclxuICAgICAgICAgICAgJ3RlbXBsYXRlJzogbGFuZ18xLmlzUHJlc2VudCh0aGlzLnRlbXBsYXRlKSA/IHRoaXMudGVtcGxhdGUudG9Kc29uKCkgOiB0aGlzLnRlbXBsYXRlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcclxuZnVuY3Rpb24gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoY29tcG9uZW50VHlwZSwgY29tcG9uZW50U2VsZWN0b3IpIHtcclxuICAgIHZhciB0ZW1wbGF0ZSA9IHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UoY29tcG9uZW50U2VsZWN0b3IpWzBdLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlKCk7XHJcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XHJcbiAgICAgICAgdHlwZTogbmV3IENvbXBpbGVUeXBlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICBydW50aW1lOiBPYmplY3QsXHJcbiAgICAgICAgICAgIG5hbWU6IFwiSG9zdFwiICsgY29tcG9uZW50VHlwZS5uYW1lLFxyXG4gICAgICAgICAgICBtb2R1bGVVcmw6IGNvbXBvbmVudFR5cGUubW9kdWxlVXJsLFxyXG4gICAgICAgICAgICBpc0hvc3Q6IHRydWVcclxuICAgICAgICB9KSxcclxuICAgICAgICB0ZW1wbGF0ZTogbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHsgdGVtcGxhdGU6IHRlbXBsYXRlLCB0ZW1wbGF0ZVVybDogJycsIHN0eWxlczogW10sIHN0eWxlVXJsczogW10sIG5nQ29udGVudFNlbGVjdG9yczogW10gfSksXHJcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcclxuICAgICAgICBpbnB1dHM6IFtdLFxyXG4gICAgICAgIG91dHB1dHM6IFtdLFxyXG4gICAgICAgIGhvc3Q6IHt9LFxyXG4gICAgICAgIGxpZmVjeWNsZUhvb2tzOiBbXSxcclxuICAgICAgICBpc0NvbXBvbmVudDogdHJ1ZSxcclxuICAgICAgICBkeW5hbWljTG9hZGFibGU6IGZhbHNlLFxyXG4gICAgICAgIHNlbGVjdG9yOiAnKidcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlSG9zdENvbXBvbmVudE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlX21ldGFkYXRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIEh0bWxUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEh0bWxUZXh0QXN0KHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBIdG1sVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XHJcbiAgICByZXR1cm4gSHRtbFRleHRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSHRtbFRleHRBc3QgPSBIdG1sVGV4dEFzdDtcclxudmFyIEh0bWxBdHRyQXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEh0bWxBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEh0bWxBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcclxuICAgIHJldHVybiBIdG1sQXR0ckFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5IdG1sQXR0ckFzdCA9IEh0bWxBdHRyQXN0O1xyXG52YXIgSHRtbEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHRtbEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBIdG1sRWxlbWVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7IH07XHJcbiAgICByZXR1cm4gSHRtbEVsZW1lbnRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSHRtbEVsZW1lbnRBc3QgPSBIdG1sRWxlbWVudEFzdDtcclxuZnVuY3Rpb24gaHRtbFZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcclxuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhc3RSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuaHRtbFZpc2l0QWxsID0gaHRtbFZpc2l0QWxsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sX2FzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBodG1sX2FzdF8xID0gcmVxdWlyZSgnLi9odG1sX2FzdCcpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIE5HX05PTl9CSU5EQUJMRSA9ICduZy1ub24tYmluZGFibGUnO1xyXG52YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xyXG4gICAgfVxyXG4gICAgSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB2YXIgcm9vdCA9IGRvbV9hZGFwdGVyXzEuRE9NLmNyZWF0ZVRlbXBsYXRlKHRlbXBsYXRlKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VDaGlsZE5vZGVzKHJvb3QsIHNvdXJjZUluZm8pO1xyXG4gICAgfTtcclxuICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnVucGFyc2UgPSBmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBVbnBhcnNlVmlzaXRvcigpO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHZpc2l0b3IsIG5vZGVzLCBwYXJ0cyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIEh0bWxQYXJzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEh0bWxQYXJzZXIpO1xyXG4gICAgcmV0dXJuIEh0bWxQYXJzZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSHRtbFBhcnNlciA9IEh0bWxQYXJzZXI7XHJcbmZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0LCBpbmRleEluUGFyZW50LCBwYXJlbnRTb3VyY2VJbmZvKSB7XHJcbiAgICAvLyBUT0RPKHRib3NjaCk6IGFkZCBzb3VyY2Ugcm93L2NvbHVtbiBzb3VyY2UgaW5mbyBmcm9tIHBhcnNlNSAvIHBhY2thZ2U6aHRtbFxyXG4gICAgdmFyIHZhbHVlID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0VGV4dCh0ZXh0KTtcclxuICAgIHJldHVybiBuZXcgaHRtbF9hc3RfMS5IdG1sVGV4dEFzdCh2YWx1ZSwgcGFyZW50U291cmNlSW5mbyArIFwiID4gI3RleHQoXCIgKyB2YWx1ZSArIFwiKTpudGgtY2hpbGQoXCIgKyBpbmRleEluUGFyZW50ICsgXCIpXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cihlbGVtZW50LCBwYXJlbnRTb3VyY2VJbmZvLCBhdHRyTmFtZSwgYXR0clZhbHVlKSB7XHJcbiAgICAvLyBUT0RPKHRib3NjaCk6IGFkZCBzb3VyY2Ugcm93L2NvbHVtbiBzb3VyY2UgaW5mbyBmcm9tIHBhcnNlNSAvIHBhY2thZ2U6aHRtbFxyXG4gICAgcmV0dXJuIG5ldyBodG1sX2FzdF8xLkh0bWxBdHRyQXN0KGF0dHJOYW1lLCBhdHRyVmFsdWUsIHBhcmVudFNvdXJjZUluZm8gKyBcIltcIiArIGF0dHJOYW1lICsgXCI9XCIgKyBhdHRyVmFsdWUgKyBcIl1cIik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFbGVtZW50KGVsZW1lbnQsIGluZGV4SW5QYXJlbnQsIHBhcmVudFNvdXJjZUluZm8pIHtcclxuICAgIC8vIG5vcm1hbGl6ZSBub2RlbmFtZSBhbHdheXMgYXMgbG93ZXIgY2FzZSBzbyB0aGF0IGZvbGxvd2luZyBidWlsZCBzdGVwc1xyXG4gICAgLy8gY2FuIHJlbHkgb24gdGhpc1xyXG4gICAgdmFyIG5vZGVOYW1lID0gZG9tX2FkYXB0ZXJfMS5ET00ubm9kZU5hbWUoZWxlbWVudCkudG9Mb3dlckNhc2UoKTtcclxuICAgIC8vIFRPRE8odGJvc2NoKTogYWRkIHNvdXJjZSByb3cvY29sdW1uIHNvdXJjZSBpbmZvIGZyb20gcGFyc2U1IC8gcGFja2FnZTpodG1sXHJcbiAgICB2YXIgc291cmNlSW5mbyA9IHBhcmVudFNvdXJjZUluZm8gKyBcIiA+IFwiICsgbm9kZU5hbWUgKyBcIjpudGgtY2hpbGQoXCIgKyBpbmRleEluUGFyZW50ICsgXCIpXCI7XHJcbiAgICB2YXIgYXR0cnMgPSBwYXJzZUF0dHJzKGVsZW1lbnQsIHNvdXJjZUluZm8pO1xyXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJzZUNoaWxkTm9kZXMoZWxlbWVudCwgc291cmNlSW5mbyk7XHJcbiAgICByZXR1cm4gbmV3IGh0bWxfYXN0XzEuSHRtbEVsZW1lbnRBc3Qobm9kZU5hbWUsIGF0dHJzLCBjaGlsZE5vZGVzLCBzb3VyY2VJbmZvKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJzKGVsZW1lbnQsIGVsZW1lbnRTb3VyY2VJbmZvKSB7XHJcbiAgICAvLyBOb3RlOiBzb3J0IHRoZSBhdHRyaWJ1dGVzIGVhcmx5IGluIHRoZSBwaXBlbGluZSB0byBnZXRcclxuICAgIC8vIGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0IHRoZSBwaXBlbGluZSwgYXMgYXR0cmlidXRlIG9yZGVyIGlzIG5vdCBkZWZpbmVkXHJcbiAgICAvLyBpbiBET00gcGFyc2VycyFcclxuICAgIHZhciBhdHRyTWFwID0gZG9tX2FkYXB0ZXJfMS5ET00uYXR0cmlidXRlTWFwKGVsZW1lbnQpO1xyXG4gICAgdmFyIGF0dHJMaXN0ID0gW107XHJcbiAgICBhdHRyTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7IHJldHVybiBhdHRyTGlzdC5wdXNoKFtuYW1lLCB2YWx1ZV0pOyB9KTtcclxuICAgIGF0dHJMaXN0LnNvcnQoZnVuY3Rpb24gKGVudHJ5MSwgZW50cnkyKSB7IHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5jb21wYXJlKGVudHJ5MVswXSwgZW50cnkyWzBdKTsgfSk7XHJcbiAgICByZXR1cm4gYXR0ckxpc3QubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gcGFyc2VBdHRyKGVsZW1lbnQsIGVsZW1lbnRTb3VyY2VJbmZvLCBlbnRyeVswXSwgZW50cnlbMV0pOyB9KTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNoaWxkTm9kZXMoZWxlbWVudCwgcGFyZW50U291cmNlSW5mbykge1xyXG4gICAgdmFyIHJvb3QgPSBkb21fYWRhcHRlcl8xLkRPTS50ZW1wbGF0ZUF3YXJlUm9vdChlbGVtZW50KTtcclxuICAgIHZhciBjaGlsZE5vZGVzID0gZG9tX2FkYXB0ZXJfMS5ET00uY2hpbGROb2Rlc0FzTGlzdChyb290KTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xyXG4gICAgICAgIHZhciBjaGlsZFJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzVGV4dE5vZGUoY2hpbGROb2RlKSkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGNoaWxkTm9kZTtcclxuICAgICAgICAgICAgY2hpbGRSZXN1bHQgPSBwYXJzZVRleHQodGV4dCwgaW5kZXgsIHBhcmVudFNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb21fYWRhcHRlcl8xLkRPTS5pc0VsZW1lbnROb2RlKGNoaWxkTm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gY2hpbGROb2RlO1xyXG4gICAgICAgICAgICBjaGlsZFJlc3VsdCA9IHBhcnNlRWxlbWVudChlbCwgaW5kZXgsIHBhcmVudFNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGlsZFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgLy8gV29uJ3QgaGF2ZSBhIGNoaWxkUmVzdWx0IGZvciBlLmcuIGNvbW1lbnQgbm9kZXNcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbnZhciBVbnBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVbnBhcnNlVmlzaXRvcigpIHtcclxuICAgIH1cclxuICAgIFVucGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJ0cykge1xyXG4gICAgICAgIHBhcnRzLnB1c2goXCI8XCIgKyBhc3QubmFtZSk7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gW107XHJcbiAgICAgICAgaHRtbF9hc3RfMS5odG1sVmlzaXRBbGwodGhpcywgYXN0LmF0dHJzLCBhdHRycyk7XHJcbiAgICAgICAgaWYgKGFzdC5hdHRycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJyAnKTtcclxuICAgICAgICAgICAgcGFydHMucHVzaChhdHRycy5qb2luKCcgJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJ0cy5wdXNoKFwiPlwiKTtcclxuICAgICAgICBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIHBhcnRzKTtcclxuICAgICAgICBwYXJ0cy5wdXNoKFwiPC9cIiArIGFzdC5uYW1lICsgXCI+XCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFVucGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBwYXJ0cykge1xyXG4gICAgICAgIHBhcnRzLnB1c2goYXN0Lm5hbWUgKyBcIj1cIiArIHV0aWxfMS5lc2NhcGVEb3VibGVRdW90ZVN0cmluZyhhc3QudmFsdWUpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBVbnBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFydHMpIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKGFzdC52YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVucGFyc2VWaXNpdG9yO1xyXG59KSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sX3BhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvY29tcGlsZXInKTtcclxudmFyIHByb3RvX3ZpZXdfZmFjdG9yeV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3Byb3RvX3ZpZXdfZmFjdG9yeScpO1xyXG52YXIgdGVtcGxhdGVfY29tcGlsZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfY29tcGlsZXInKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgUnVudGltZUNvbXBpbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSdW50aW1lQ29tcGlsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXIoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUnVudGltZUNvbXBpbGVyO1xyXG59KShjb21waWxlcl8xLkNvbXBpbGVyKTtcclxuZXhwb3J0cy5SdW50aW1lQ29tcGlsZXIgPSBSdW50aW1lQ29tcGlsZXI7XHJcbnZhciBSdW50aW1lQ29tcGlsZXJfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSdW50aW1lQ29tcGlsZXJfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUnVudGltZUNvbXBpbGVyXyhfcHJvdG9WaWV3RmFjdG9yeSwgX3RlbXBsYXRlQ29tcGlsZXIpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfcHJvdG9WaWV3RmFjdG9yeSk7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb21waWxlciA9IF90ZW1wbGF0ZUNvbXBpbGVyO1xyXG4gICAgfVxyXG4gICAgUnVudGltZUNvbXBpbGVyXy5wcm90b3R5cGUuY29tcGlsZUluSG9zdCA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVDb21waWxlci5jb21waWxlSG9zdENvbXBvbmVudFJ1bnRpbWUoY29tcG9uZW50VHlwZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXBpbGVkSG9zdFRlbXBsYXRlKSB7IHJldHVybiBjb21waWxlcl8xLmludGVybmFsQ3JlYXRlUHJvdG9WaWV3KF90aGlzLCBjb21waWxlZEhvc3RUZW1wbGF0ZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVDb21waWxlcl8ucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jbGVhckNhY2hlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb21waWxlci5jbGVhckNhY2hlKCk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbXBpbGVyXyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtwcm90b192aWV3X2ZhY3RvcnlfMS5Qcm90b1ZpZXdGYWN0b3J5LCB0ZW1wbGF0ZV9jb21waWxlcl8xLlRlbXBsYXRlQ29tcGlsZXJdKVxyXG4gICAgXSwgUnVudGltZUNvbXBpbGVyXyk7XHJcbiAgICByZXR1cm4gUnVudGltZUNvbXBpbGVyXztcclxufSkoY29tcGlsZXJfMS5Db21waWxlcl8pO1xyXG5leHBvcnRzLlJ1bnRpbWVDb21waWxlcl8gPSBSdW50aW1lQ29tcGlsZXJfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW50aW1lX2NvbXBpbGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBjcGwgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9tZXRhZGF0YScpO1xyXG52YXIgZGlyQW5uID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xyXG52YXIgZGlyZWN0aXZlX3Jlc29sdmVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZGlyZWN0aXZlX3Jlc29sdmVyJyk7XHJcbnZhciB2aWV3X3Jlc29sdmVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19yZXNvbHZlcicpO1xyXG52YXIgZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9kaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3RvcicpO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2ludGVyZmFjZXMnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgZGlfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxuLy8gZ3JvdXAgMTogXCJwcm9wZXJ0eVwiIGZyb20gXCJbcHJvcGVydHldXCJcclxuLy8gZ3JvdXAgMjogXCJldmVudFwiIGZyb20gXCIoZXZlbnQpXCJcclxudmFyIEhPU1RfUkVHX0VYUCA9IC9eKD86KD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpKSQvZztcclxudmFyIFJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyKF9kaXJlY3RpdmVSZXNvbHZlciwgX3ZpZXdSZXNvbHZlcikge1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyID0gX2RpcmVjdGl2ZVJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdSZXNvbHZlciA9IF92aWV3UmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBSdW50aW1lTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xyXG4gICAgICAgIHZhciBtZXRhID0gdGhpcy5fY2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtZXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlQW5ub3RhdGlvbiA9IHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBtb2R1bGVVcmwgPSBjYWxjTW9kdWxlVXJsKGRpcmVjdGl2ZVR5cGUsIGRpcmVjdGl2ZUFubm90YXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVNZXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZUFubm90YXRpb24gaW5zdGFuY2VvZiBkaXJBbm4uQ29tcG9uZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wQW5ub3RhdGlvbiA9IGRpcmVjdGl2ZUFubm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlld0Fubm90YXRpb24gPSB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlKTtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlTWV0YSA9IG5ldyBjcGwuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IHZpZXdBbm5vdGF0aW9uLmVuY2Fwc3VsYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHZpZXdBbm5vdGF0aW9uLnRlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB2aWV3QW5ub3RhdGlvbi50ZW1wbGF0ZVVybCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHZpZXdBbm5vdGF0aW9uLnN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IHZpZXdBbm5vdGF0aW9uLnN0eWxlVXJsc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGNvbXBBbm5vdGF0aW9uLmNoYW5nZURldGVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXRhID0gY3BsLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZUFubm90YXRpb24uc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlQW5ub3RhdGlvbi5leHBvcnRBcyxcclxuICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiBsYW5nXzEuaXNQcmVzZW50KHRlbXBsYXRlTWV0YSksXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljTG9hZGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBuZXcgY3BsLkNvbXBpbGVUeXBlTWV0YWRhdGEoeyBuYW1lOiBsYW5nXzEuc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpLCBtb2R1bGVVcmw6IG1vZHVsZVVybCwgcnVudGltZTogZGlyZWN0aXZlVHlwZSB9KSxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBkaXJlY3RpdmVBbm5vdGF0aW9uLmlucHV0cyxcclxuICAgICAgICAgICAgICAgIG91dHB1dHM6IGRpcmVjdGl2ZUFubm90YXRpb24ub3V0cHV0cyxcclxuICAgICAgICAgICAgICAgIGhvc3Q6IGRpcmVjdGl2ZUFubm90YXRpb24uaG9zdCxcclxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlsdGVyKGludGVyZmFjZXNfMS5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLCBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2ssIGRpcmVjdGl2ZVR5cGUpOyB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0YTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0Vmlld0RpcmVjdGl2ZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlld1Jlc29sdmVyLnJlc29sdmUoY29tcG9uZW50KTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGZsYXR0ZW5EaXJlY3RpdmVzKHZpZXcpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWREaXJlY3RpdmUoZGlyZWN0aXZlc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgZGlyZWN0aXZlIHZhbHVlICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoZGlyZWN0aXZlc1tpXSkgKyBcIicgb24gdGhlIFZpZXcgb2YgY29tcG9uZW50ICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50KSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlRHVwbGljYXRlZERpcmVjdGl2ZXMoZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmdldE1ldGFkYXRhKHR5cGUpOyB9KSk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8yLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbZGlyZWN0aXZlX3Jlc29sdmVyXzEuRGlyZWN0aXZlUmVzb2x2ZXIsIHZpZXdfcmVzb2x2ZXJfMS5WaWV3UmVzb2x2ZXJdKVxyXG4gICAgXSwgUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIpO1xyXG4gICAgcmV0dXJuIFJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyID0gUnVudGltZU1ldGFkYXRhUmVzb2x2ZXI7XHJcbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZWREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpIHtcclxuICAgIHZhciBkaXJlY3RpdmVzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7IGRpcmVjdGl2ZXNNYXAuc2V0KGRpck1ldGEudHlwZS5ydW50aW1lLCBkaXJNZXRhKTsgfSk7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIudmFsdWVzKGRpcmVjdGl2ZXNNYXApO1xyXG59XHJcbmZ1bmN0aW9uIGZsYXR0ZW5EaXJlY3RpdmVzKHZpZXcpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3LmRpcmVjdGl2ZXMpKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIHZhciBkaXJlY3RpdmVzID0gW107XHJcbiAgICBmbGF0dGVuTGlzdCh2aWV3LmRpcmVjdGl2ZXMsIGRpcmVjdGl2ZXMpO1xyXG4gICAgcmV0dXJuIGRpcmVjdGl2ZXM7XHJcbn1cclxuZnVuY3Rpb24gZmxhdHRlbkxpc3QodHJlZSwgb3V0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGRpXzEucmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGZsYXR0ZW5MaXN0KGl0ZW0sIG91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZERpcmVjdGl2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodmFsdWUpICYmICh2YWx1ZSBpbnN0YW5jZW9mIGxhbmdfMS5UeXBlKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjTW9kdWxlVXJsKHR5cGUsIGRpcmVjdGl2ZUFubm90YXRpb24pIHtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZUFubm90YXRpb24ubW9kdWxlSWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicGFja2FnZTpcIiArIGRpcmVjdGl2ZUFubm90YXRpb24ubW9kdWxlSWQgKyB1dGlsXzEuTU9EVUxFX1NVRkZJWDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmltcG9ydFVyaSh0eXBlKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW50aW1lX21ldGFkYXRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5Jyk7XHJcbnZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9wcm90b0VsZW1lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2V0UHJvdG9FbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX3Byb3RvRWxlbWVudHMuZ2V0KHRhZ05hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvdG9FbGVtZW50cy5zZXQodGFnTmFtZSwgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfTtcclxuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUpIHtcclxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XHJcbiAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGVsbSA9IHRoaXMuX2dldFByb3RvRWxlbWVudCh0YWdOYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvbV9hZGFwdGVyXzEuRE9NLmhhc1Byb3BlcnR5KGVsbSwgcHJvcE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldE1hcHBlZFByb3BOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgdmFyIG1hcHBlZFByb3BOYW1lID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KGRvbV9hZGFwdGVyXzEuRE9NLmF0dHJUb1Byb3BNYXAsIHByb3BOYW1lKTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChtYXBwZWRQcm9wTmFtZSkgPyBtYXBwZWRQcm9wTmFtZSA6IHByb3BOYW1lO1xyXG4gICAgfTtcclxuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KTtcclxuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XHJcbn0pKGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KTtcclxuZXhwb3J0cy5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XHJcbiAgICB9XHJcbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gcHJvcE5hbWU7IH07XHJcbiAgICByZXR1cm4gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xyXG59KSgpO1xyXG5leHBvcnRzLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF9zY2hlbWFfcmVnaXN0cnkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBfRU1QVFlfQVRUUl9WQUxVRSA9ICcnO1xyXG4vLyBUT0RPOiBDYW4ndCB1c2UgYGNvbnN0YCBoZXJlIGFzXHJcbi8vIGluIERhcnQgdGhpcyBpcyBub3QgdHJhbnNwaWxlZCBpbnRvIGBmaW5hbGAgeWV0Li4uXHJcbnZhciBfU0VMRUNUT1JfUkVHRVhQID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCcoXFxcXDpub3RcXFxcKCl8JyArXHJcbiAgICAnKFstXFxcXHddKyl8JyArXHJcbiAgICAnKD86XFxcXC4oWy1cXFxcd10rKSl8JyArXHJcbiAgICAnKD86XFxcXFsoWy1cXFxcdypdKykoPzo9KFteXFxcXF1dKikpP1xcXFxdKXwnICtcclxuICAgICcoXFxcXCkpfCcgK1xyXG4gICAgJyhcXFxccyosXFxcXHMqKScpOyAvLyBcIixcIlxyXG4vKipcclxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxyXG4gKiBjc3MgY2xhc3NlcyBhbmQgYXR0cmlidXRlL3ZhbHVlIHBhaXJzIHdpdGggdGhlIHB1cnBvc2VcclxuICogb2Ygc2VsZWN0aW5nIHN1YnNldHMgb3V0IG9mIHRoZW0uXHJcbiAqL1xyXG52YXIgQ3NzU2VsZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ3NzU2VsZWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJzID0gW107XHJcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBbXTtcclxuICAgIH1cclxuICAgIENzc1NlbGVjdG9yLnBhcnNlID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB2YXIgX2FkZFJlc3VsdCA9IGZ1bmN0aW9uIChyZXMsIGNzc1NlbCkge1xyXG4gICAgICAgICAgICBpZiAoY3NzU2VsLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmIGxhbmdfMS5pc0JsYW5rKGNzc1NlbC5lbGVtZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkoY3NzU2VsLmNsYXNzTmFtZXMpICYmIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pc0VtcHR5KGNzc1NlbC5hdHRycykpIHtcclxuICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gXCIqXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xyXG4gICAgICAgIHZhciBtYXRjaGVyID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIubWF0Y2hlcihfU0VMRUNUT1JfUkVHRVhQLCBzZWxlY3Rvcik7XHJcbiAgICAgICAgdmFyIG1hdGNoO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gY3NzU2VsZWN0b3I7XHJcbiAgICAgICAgdmFyIGluTm90ID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2ggPSBsYW5nXzEuUmVnRXhwTWF0Y2hlcldyYXBwZXIubmV4dChtYXRjaGVyKSkpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ05lc3RpbmcgOm5vdCBpcyBub3QgYWxsb3dlZCBpbiBhIHNlbGVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XHJcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3Rvci5ub3RTZWxlY3RvcnMucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFsyXSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0RWxlbWVudChtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hbM10pKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkZENsYXNzTmFtZShtYXRjaFszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hbNF0pKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZShtYXRjaFs0XSwgbWF0Y2hbNV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzZdKSkge1xyXG4gICAgICAgICAgICAgICAgaW5Ob3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFs3XSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignTXVsdGlwbGUgc2VsZWN0b3JzIGluIDpub3QgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3IgPSBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmlzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZWxlbWVudCkgJiYgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkodGhpcy5jbGFzc05hbWVzKSAmJlxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eSh0aGlzLmF0dHJzKSAmJiB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XHJcbiAgICB9O1xyXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgfTtcclxuICAgIC8qKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuICovXHJcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZWxlbWVudCkgPyB0aGlzLmVsZW1lbnQgOiAnZGl2JztcclxuICAgICAgICB2YXIgY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBcIiBjbGFzcz1cXFwiXCIgKyB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIgOiAnJztcclxuICAgICAgICB2YXIgYXR0cnMgPSAnJztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdGhpcy5hdHRyc1tpXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRoaXMuYXR0cnNbaSArIDFdICE9PSAnJyA/IFwiPVxcXCJcIiArIHRoaXMuYXR0cnNbaSArIDFdICsgXCJcXFwiXCIgOiAnJztcclxuICAgICAgICAgICAgYXR0cnMgKz0gXCIgXCIgKyBhdHRyTmFtZSArIGF0dHJWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnTmFtZSArIGNsYXNzQXR0ciArIGF0dHJzICsgXCI+PC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcclxuICAgIH07XHJcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBfRU1QVFlfQVRUUl9WQUxVRTsgfVxyXG4gICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IF9FTVBUWV9BVFRSX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF0dHJzLnB1c2godmFsdWUpO1xyXG4gICAgfTtcclxuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLmNsYXNzTmFtZXMucHVzaChuYW1lLnRvTG93ZXJDYXNlKCkpOyB9O1xyXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXMgPSAnJztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJlcyArPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuY2xhc3NOYW1lcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSAnLicgKyB0aGlzLmNsYXNzTmFtZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5hdHRycykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaSsrXTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2krK107XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJ1snICsgYXR0ck5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0clZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJz0nICsgYXR0clZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzICs9ICddJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub3RTZWxlY3RvcikgeyByZXR1cm4gcmVzICs9IFwiOm5vdChcIiArIG5vdFNlbGVjdG9yICsgXCIpXCI7IH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENzc1NlbGVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLkNzc1NlbGVjdG9yID0gQ3NzU2VsZWN0b3I7XHJcbi8qKlxyXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcclxuICogYXJlIGNvbnRhaW5lZCBpbiBhIGdpdmVuIENzc1NlbGVjdG9yLlxyXG4gKi9cclxudmFyIFNlbGVjdG9yTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XHJcbiAgICB9XHJcbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcclxuICAgICAgICB2YXIgbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcclxuICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5hZGRTZWxlY3RhYmxlcyA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xyXG4gICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBmb3VuZCBsYXRlciBvbiBieSBjYWxsaW5nIGBtYXRjaGAuXHJcbiAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFNlbGVjdGFibGUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcclxuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcclxuICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RvckNvbnRleHQoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fZWxlbWVudE1hcCwgZWxlbWVudCwgc2VsZWN0YWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2xhc3NOYW1lcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGF0dHJzLmxlbmd0aCA9PT0gMCAmJiBpbmRleCA9PT0gY2xhc3NOYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBzZWxlY3RhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdHRycykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJzLmxlbmd0aDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gaW5kZXggPT09IGF0dHJzLmxlbmd0aCAtIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlTWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRlcm1pbmFsVmFsdWVzTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChhdHRyTmFtZSwgdGVybWluYWxWYWx1ZXNNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgYXR0clZhbHVlLCBzZWxlY3RhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0dGlhbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZVBhcnRpYWxNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0dGlhbE1hcC5nZXQoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJ0aWFsVmFsdWVzTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHRpYWxNYXAuc2V0KGF0dHJOYW1lLCBwYXJ0aWFsVmFsdWVzTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgYXR0clZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNlbGVjdGFibGUpIHtcclxuICAgICAgICB2YXIgdGVybWluYWxMaXN0ID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGVybWluYWxMaXN0KSkge1xyXG4gICAgICAgICAgICB0ZXJtaW5hbExpc3QgPSBbXTtcclxuICAgICAgICAgICAgbWFwLnNldChuYW1lLCB0ZXJtaW5hbExpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXJtaW5hbExpc3QucHVzaChzZWxlY3RhYmxlKTtcclxuICAgIH07XHJcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xyXG4gICAgICAgIHZhciBtYXRjaGVyID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWF0Y2hlcikpIHtcclxuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcclxuICAgICAgICAgICAgbWFwLnNldChuYW1lLCBtYXRjaGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcclxuICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cclxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcclxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXHJcbiAgICAqL1xyXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcclxuICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNsYXNzTmFtZXMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjbGFzc05hbWVzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2NsYXNzTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXR0cnMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhdHRycy5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRoaXMuX2F0dHJWYWx1ZU1hcC5nZXQoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoYXR0clZhbHVlLCBfRU1QVFlfQVRUUl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCBfRU1QVFlfQVRUUl9WQUxVRSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgYXR0clZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoYXR0clZhbHVlLCBfRU1QVFlfQVRUUl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgX0VNUFRZX0FUVFJfVkFMVUUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIGF0dHJWYWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWFwKSB8fCBsYW5nXzEuaXNCbGFuayhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSk7XHJcbiAgICAgICAgdmFyIHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoXCIqXCIpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0YXJTZWxlY3RhYmxlcykpIHtcclxuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHNlbGVjdGFibGVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWxlY3RhYmxlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc2VsZWN0YWJsZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGFibGUgPSBzZWxlY3RhYmxlc1tpbmRleF07XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGVjdGFibGUuZmluYWxpemUoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2sgLyo6IChjOiBDc3NTZWxlY3RvciwgYTogYW55KSA9PiB2b2lkKi8pIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWFwKSB8fCBsYW5nXzEuaXNCbGFuayhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXN0ZWRTZWxlY3RvciA9IG1hcC5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG5lc3RlZFNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXHJcbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZG9uJ3QgcGFzcyB0aGUgd2hvbGUgc2VsZWN0b3IgaW50byB0aGUgcmVjdXJzaW9uLFxyXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXHJcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZWN0b3JNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyO1xyXG52YXIgU2VsZWN0b3JMaXN0Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rvckxpc3RDb250ZXh0KHNlbGVjdG9ycykge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xyXG4gICAgICAgIHRoaXMuYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBTZWxlY3Rvckxpc3RDb250ZXh0O1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGVjdG9yTGlzdENvbnRleHQgPSBTZWxlY3Rvckxpc3RDb250ZXh0O1xyXG4vLyBTdG9yZSBjb250ZXh0IHRvIHBhc3MgYmFjayBzZWxlY3RvciBhbmQgY29udGV4dCB3aGVuIGEgc2VsZWN0b3IgaXMgbWF0Y2hlZFxyXG52YXIgU2VsZWN0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdG9yQ29udGV4dChzZWxlY3RvciwgY2JDb250ZXh0LCBsaXN0Q29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcclxuICAgICAgICB0aGlzLmxpc3RDb250ZXh0ID0gbGlzdENvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XHJcbiAgICB9XHJcbiAgICBTZWxlY3RvckNvbnRleHQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgIChsYW5nXzEuaXNCbGFuayh0aGlzLmxpc3RDb250ZXh0KSB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcclxuICAgICAgICAgICAgdmFyIG5vdE1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlcih0aGlzLm5vdFNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBsYW5nXzEuaXNQcmVzZW50KGNhbGxiYWNrKSAmJlxyXG4gICAgICAgICAgICAobGFuZ18xLmlzQmxhbmsodGhpcy5saXN0Q29udGV4dCkgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMubGlzdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNlbGVjdG9yQ29udGV4dDtcclxufSkoKTtcclxuZXhwb3J0cy5TZWxlY3RvckNvbnRleHQgPSBTZWxlY3RvckNvbnRleHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgYSBwb3J0IG9mIHNoYWRvd0NTUyBmcm9tIHdlYmNvbXBvbmVudHMuanMgdG8gVHlwZVNjcmlwdC5cclxuICpcclxuICogUGxlYXNlIG1ha2Ugc3VyZSB0byBrZWVwIHRvIGVkaXRzIGluIHN5bmMgd2l0aCB0aGUgc291cmNlIGZpbGUuXHJcbiAqXHJcbiAqIFNvdXJjZTpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvNGVmZWNkN2UwZS9zcmMvU2hhZG93Q1NTL1NoYWRvd0NTUy5qc1xyXG4gKlxyXG4gKiBUaGUgb3JpZ2luYWwgZmlsZSBsZXZlbCBjb21tZW50IGlzIHJlcHJvZHVjZWQgYmVsb3dcclxuICovXHJcbi8qXHJcbiAgVGhpcyBpcyBhIGxpbWl0ZWQgc2hpbSBmb3IgU2hhZG93RE9NIGNzcyBzdHlsaW5nLlxyXG4gIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvd2ViY29tcG9uZW50cy9yYXctZmlsZS90aXAvc3BlYy9zaGFkb3cvaW5kZXguaHRtbCNzdHlsZXNcclxuXHJcbiAgVGhlIGludGVudGlvbiBoZXJlIGlzIHRvIHN1cHBvcnQgb25seSB0aGUgc3R5bGluZyBmZWF0dXJlcyB3aGljaCBjYW4gYmVcclxuICByZWxhdGl2ZWx5IHNpbXBseSBpbXBsZW1lbnRlZC4gVGhlIGdvYWwgaXMgdG8gYWxsb3cgdXNlcnMgdG8gYXZvaWQgdGhlXHJcbiAgbW9zdCBvYnZpb3VzIHBpdGZhbGxzIGFuZCBkbyBzbyB3aXRob3V0IGNvbXByb21pc2luZyBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxyXG4gIEZvciBTaGFkb3dET00gc3R5bGluZyB0aGF0J3Mgbm90IGNvdmVyZWQgaGVyZSwgYSBzZXQgb2YgYmVzdCBwcmFjdGljZXNcclxuICBjYW4gYmUgcHJvdmlkZWQgdGhhdCBzaG91bGQgYWxsb3cgdXNlcnMgdG8gYWNjb21wbGlzaCBtb3JlIGNvbXBsZXggc3R5bGluZy5cclxuXHJcbiAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcclxuICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXHJcblxyXG4gIFNoaW1tZWQgZmVhdHVyZXM6XHJcblxyXG4gICogOmhvc3QsIDpob3N0LWNvbnRleHQ6IFNoYWRvd0RPTSBhbGxvd3Mgc3R5bGluZyBvZiB0aGUgc2hhZG93Um9vdCdzIGhvc3RcclxuICBlbGVtZW50IHVzaW5nIHRoZSA6aG9zdCBydWxlLiBUbyBzaGltIHRoaXMgZmVhdHVyZSwgdGhlIDpob3N0IHN0eWxlcyBhcmVcclxuICByZWZvcm1hdHRlZCBhbmQgcHJlZml4ZWQgd2l0aCBhIGdpdmVuIHNjb3BlIG5hbWUgYW5kIHByb21vdGVkIHRvIGFcclxuICBkb2N1bWVudCBsZXZlbCBzdHlsZXNoZWV0LlxyXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgLmZvbywgYSBydWxlIGxpa2UgdGhpczpcclxuXHJcbiAgICA6aG9zdCB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIGJlY29tZXM6XHJcblxyXG4gICAgLmZvbyB7XHJcbiAgICAgIGJhY2tncm91bmQ6IHJlZDtcclxuICAgIH1cclxuXHJcbiAgKiBlbmNhcHN1bHRpb246IFN0eWxlcyBkZWZpbmVkIHdpdGhpbiBTaGFkb3dET00sIGFwcGx5IG9ubHkgdG9cclxuICBkb20gaW5zaWRlIHRoZSBTaGFkb3dET00uIFBvbHltZXIgdXNlcyBvbmUgb2YgdHdvIHRlY2huaXF1ZXMgdG8gaW1sZW1lbnRcclxuICB0aGlzIGZlYXR1cmUuXHJcblxyXG4gIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcclxuICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xyXG4gIG9mIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NLiBGb3IgZXhhbXBsZSxcclxuXHJcbiAgZGl2IHtcclxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICB9XHJcblxyXG4gIGJlY29tZXM6XHJcblxyXG4gIHgtZm9vIGRpdiB7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgfVxyXG5cclxuICBiZWNvbWVzOlxyXG5cclxuXHJcbiAgQWx0ZXJuYXRpdmVseSwgaWYgV2ViQ29tcG9uZW50cy5TaGFkb3dDU1Muc3RyaWN0U3R5bGluZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuXHJcbiAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxyXG4gIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxyXG4gIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cclxuICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxyXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XHJcblxyXG4gICAgZGl2IHtcclxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICB9XHJcblxyXG4gIGJlY29tZXM6XHJcblxyXG4gICAgZGl2W3gtZm9vXSB7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgfVxyXG5cclxuICBOb3RlIHRoYXQgZWxlbWVudHMgdGhhdCBhcmUgZHluYW1pY2FsbHkgYWRkZWQgdG8gYSBzY29wZSBtdXN0IGhhdmUgdGhlIHNjb3BlXHJcbiAgc2VsZWN0b3IgYWRkZWQgdG8gdGhlbSBtYW51YWxseS5cclxuXHJcbiAgKiB1cHBlci9sb3dlciBib3VuZCBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgd2hpY2ggYXJlIGRlZmluZWQgb3V0c2lkZSBhXHJcbiAgc2hhZG93Um9vdCBzaG91bGQgbm90IGNyb3NzIHRoZSBTaGFkb3dET00gYm91bmRhcnkgYW5kIHNob3VsZCBub3QgYXBwbHlcclxuICBpbnNpZGUgYSBzaGFkb3dSb290LlxyXG5cclxuICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XHJcbiAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XHJcbiAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XHJcbiAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cclxuXHJcbiAgQXMgYW4gYWx0ZXJuYXRpdmUsIHVzZXJzIHNob3VsZCBtYWtlIHN1cmUgdG8gdXNlIHNlbGVjdG9yc1xyXG4gIHNwZWNpZmljIHRvIHRoZSBzY29wZSBpbiB3aGljaCB0aGV5IGFyZSB3b3JraW5nLlxyXG5cclxuICAqIDo6ZGlzdHJpYnV0ZWQ6IFRoaXMgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBJdCdzIG9mdGVuIG5vdCBuZWNlc3NhcnlcclxuICB0byBzdHlsZSB0aGUgY29udGVudHMgb2YgYSBzcGVjaWZpYyBpbnNlcnRpb24gcG9pbnQgYW5kIGluc3RlYWQsIGRlc2NlbmRhbnRzXHJcbiAgb2YgdGhlIGhvc3QgZWxlbWVudCBjYW4gYmUgc3R5bGVkIHNlbGVjdGl2ZWx5LiBVc2VycyBjYW4gYWxzbyBjcmVhdGUgYW5cclxuICBleHRyYSBub2RlIGFyb3VuZCBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIHN0eWxlIHRoYXQgbm9kZSdzIGNvbnRlbnRzXHJcbiAgdmlhIGRlc2NlbmRlbnQgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgd2l0aCBhIHNoYWRvd1Jvb3QgbGlrZSB0aGlzOlxyXG5cclxuICAgIDxzdHlsZT5cclxuICAgICAgOjpjb250ZW50KGRpdikge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcclxuICAgICAgfVxyXG4gICAgPC9zdHlsZT5cclxuICAgIDxjb250ZW50PjwvY29udGVudD5cclxuXHJcbiAgY291bGQgYmVjb21lOlxyXG5cclxuICAgIDxzdHlsZT5cclxuICAgICAgLyAqQHBvbHlmaWxsIC5jb250ZW50LWNvbnRhaW5lciBkaXYgKiAvXHJcbiAgICAgIDo6Y29udGVudChkaXYpIHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XHJcbiAgICAgIH1cclxuICAgIDwvc3R5bGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudC1jb250YWluZXJcIj5cclxuICAgICAgPGNvbnRlbnQ+PC9jb250ZW50PlxyXG4gICAgPC9kaXY+XHJcblxyXG4gIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcclxuICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcclxuICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cclxuKi9cclxudmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaGFkb3dDc3MoKSB7XHJcbiAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAqIFNoaW0gYSBzdHlsZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cclxuICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXHJcbiAgICAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoaG9zdFNlbGVjdG9yID09PSB2b2lkIDApIHsgaG9zdFNlbGVjdG9yID0gJyc7IH1cclxuICAgICAgICB2YXIgY3NzVGV4dCA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldFRleHQoc3R5bGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoaW1Dc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cclxuICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXHJcbiAgICAqXHJcbiAgICAqIFdoZW4gc3RyaWN0U3R5bGluZyBpcyB0cnVlOlxyXG4gICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcclxuICAgICogLSBob3N0U2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byB0aGUgaG9zdCBpdHNlbGYuXHJcbiAgICAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XHJcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlQ3NzVGV4dChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcclxuICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XHJcbiAgICAgKlxyXG4gICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XHJcbiAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcclxuICAgICAqXHJcbiAgICAgKiB0byB0aGlzOlxyXG4gICAgICpcclxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xyXG4gICAgICpcclxuICAgICoqL1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoY3NzVGV4dCwgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV0gKyAneyc7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcclxuICAgICAqXHJcbiAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcclxuICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB0byB0aGlzOlxyXG4gICAgICpcclxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cclxuICAgICAqXHJcbiAgICAqKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcclxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzQ29udGVudFJ1bGVSZSwgZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBtWzBdO1xyXG4gICAgICAgICAgICBydWxlID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZShydWxlLCBtWzFdLCAnJyk7XHJcbiAgICAgICAgICAgIHJ1bGUgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHJ1bGUsIG1bMl0sICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1bM10gKyBydWxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XHJcbiAgICAgKlxyXG4gICAgICogIC5mb28gey4uLiB9XHJcbiAgICAgKlxyXG4gICAgICogIGFuZCBjb252ZXJ0cyB0aGlzIHRvXHJcbiAgICAgKlxyXG4gICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cclxuICAgICovXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW5zY29wZWQgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xyXG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XHJcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XHJcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpO1xyXG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHNjb3BlU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIF93aXRoQ3NzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGVzKSB7IGNzc1RleHQgPSBfdGhpcy5fc2NvcGVSdWxlcyhydWxlcywgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNzc1RleHQgPSBjc3NUZXh0ICsgJ1xcbicgKyB1bnNjb3BlZDtcclxuICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXHJcbiAgICAgKiBhbmQgZG8gbm90IHByb2Nlc3MgdmlhIENTU09NLiAoQ1NTT00gaXMgZGVzdHJ1Y3RpdmUgdG8gcnVsZXMgb24gcmFyZVxyXG4gICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxyXG4gICAgICpcclxuICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcclxuICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XHJcbiAgICAgKiAuLi4gfVxyXG4gICAgICpcclxuICAgICAqIHRvIHRoaXM6XHJcbiAgICAgKlxyXG4gICAgICogbWVudS1pdGVtIHsuLi59XHJcbiAgICAgKlxyXG4gICAgKiovXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXHJcbiAgICAgICAgdmFyIHIgPSAnJywgbTtcclxuICAgICAgICB2YXIgbWF0Y2hlciA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLm1hdGNoZXIoX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSwgY3NzVGV4dCk7XHJcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQobSA9IGxhbmdfMS5SZWdFeHBNYXRjaGVyV3JhcHBlci5uZXh0KG1hdGNoZXIpKSkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF07XHJcbiAgICAgICAgICAgIHJ1bGUgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHJ1bGUsIG1bMl0sICcnKTtcclxuICAgICAgICAgICAgcnVsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocnVsZSwgbVsxXSwgbVszXSk7XHJcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdCguZm9vKSA+IC5iYXIgeyB9XHJcbiAgICAgKlxyXG4gICAgICogdG9cclxuICAgICAqXHJcbiAgICAgKiBzY29wZU5hbWUuZm9vID4gLmJhclxyXG4gICAgKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3QgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdC1jb250ZXh0KC5mb28pID4gLmJhciB7IH1cclxuICAgICAqXHJcbiAgICAgKiB0b1xyXG4gICAgICpcclxuICAgICAqIHNjb3BlTmFtZS5mb28gPiAuYmFyLCAuZm9vIHNjb3BlTmFtZSA+IC5iYXIgeyB9XHJcbiAgICAgKlxyXG4gICAgICogYW5kXHJcbiAgICAgKlxyXG4gICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxyXG4gICAgICpcclxuICAgICAqIHRvXHJcbiAgICAgKlxyXG4gICAgICogc2NvcGVOYW1lLmZvbyAuYmFyIHsgLi4uIH1cclxuICAgICovXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSwgdGhpcy5fY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlcik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uUnVsZSA9IGZ1bmN0aW9uIChjc3NUZXh0LCByZWdFeHAsIHBhcnRSZXBsYWNlcikge1xyXG4gICAgICAgIC8vIHAxID0gOmhvc3QsIHAyID0gY29udGVudHMgb2YgKCksIHAzIHJlc3Qgb2YgcnVsZVxyXG4gICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGNzc1RleHQsIHJlZ0V4cCwgZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobVsyXSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKSwgciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBwID0gcC50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5jb250YWlucyhwYXJ0LCBfcG9seWZpbGxIb3N0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gaG9zdCArIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocGFydCwgX3BvbHlmaWxsSG9zdCwgJycpICsgc3VmZml4O1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IGNvbWJpbmF0b3JzIGxpa2UgOjpzaGFkb3cgYW5kIHBzZXVkby1lbGVtZW50cyBsaWtlIDo6Y29udGVudFxyXG4gICAgICogYnkgcmVwbGFjaW5nIHdpdGggc3BhY2UuXHJcbiAgICAqL1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2hhZG93RE9NU2VsZWN0b3JzUmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3NzVGV4dCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoY3NzVGV4dCwgX3NoYWRvd0RPTVNlbGVjdG9yc1JlW2ldLCAnICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3NzVGV4dDtcclxuICAgIH07XHJcbiAgICAvLyBjaGFuZ2UgYSBzZWxlY3RvciBsaWtlICdkaXYnIHRvICduYW1lIGRpdidcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlUnVsZXMgPSBmdW5jdGlvbiAoY3NzUnVsZXMsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBjc3NUZXh0ID0gJyc7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY3NzUnVsZXMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBydWxlID0gY3NzUnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNTdHlsZVJ1bGUocnVsZSkgfHwgZG9tX2FkYXB0ZXJfMS5ET00uaXNQYWdlUnVsZShydWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5fc2NvcGVTZWxlY3RvcihydWxlLnNlbGVjdG9yVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCB0aGlzLnN0cmljdFN0eWxpbmcpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyB7XFxuJztcclxuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuX3Byb3BlcnRpZXNGcm9tUnVsZShydWxlKSArICdcXG59XFxuXFxuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzTWVkaWFSdWxlKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSAnQG1lZGlhICcgKyBydWxlLm1lZGlhLm1lZGlhVGV4dCArICcge1xcbic7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSB0aGlzLl9zY29wZVJ1bGVzKHJ1bGUuY3NzUnVsZXMsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSAnXFxufVxcblxcbic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBLRVlGUkFNRVNfUlVMRSBpbiBJRSB0aHJvd3Mgd2hlbiB3ZSBxdWVyeSBjc3NUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBpdCBjb250YWlucyBhIC13ZWJraXQtIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaGFwcGVucywgd2UgZmFsbGJhY2sgdG8gY29uc3RydWN0aW5nIHRoZSBydWxlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgQ1NTUnVsZVNldFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrZGV0YWlsL3ZpZXcvOTU1NzAzL2FjY2Vzc2luZy1jc3N0ZXh0LW9mLWEta2V5ZnJhbWUtcnVsZS10aGF0LWNvbnRhaW5zLWEtd2Via2l0LXByb3BlcnR5LXZpYS1jc3NvbS1nZW5lcmF0ZXMtZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocnVsZS5jc3NUZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSBydWxlLmNzc1RleHQgKyAnXFxuXFxuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNLZXlmcmFtZXNSdWxlKHJ1bGUpICYmIGxhbmdfMS5pc1ByZXNlbnQocnVsZS5jc3NSdWxlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5faWVTYWZlQ3NzVGV4dEZyb21LZXlGcmFtZVJ1bGUocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faWVTYWZlQ3NzVGV4dEZyb21LZXlGcmFtZVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgIHZhciBjc3NUZXh0ID0gJ0BrZXlmcmFtZXMgJyArIHJ1bGUubmFtZSArICcgeyc7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlLmNzc1J1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gcnVsZS5jc3NSdWxlc1tpXTtcclxuICAgICAgICAgICAgY3NzVGV4dCArPSAnICcgKyByLmtleVRleHQgKyAnIHsnICsgci5zdHlsZS5jc3NUZXh0ICsgJ30nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjc3NUZXh0ICs9ICcgfSc7XHJcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcclxuICAgICAgICB2YXIgciA9IFtdLCBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBwID0gcC50cmltKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3Rvck5lZWRzU2NvcGluZyhwLCBzY29wZVNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcCA9IHN0cmljdCAmJiAhbGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnMocCwgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHAsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgci5wdXNoKHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gci5qb2luKCcsICcpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3NlbGVjdG9yTmVlZHNTY29waW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlID0gdGhpcy5fbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKTtcclxuICAgICAgICByZXR1cm4gIWxhbmdfMS5pc1ByZXNlbnQobGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChyZSwgc2VsZWN0b3IpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9tYWtlU2NvcGVNYXRjaGVyID0gZnVuY3Rpb24gKHNjb3BlU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgbHJlID0gL1xcWy9nO1xyXG4gICAgICAgIHZhciBycmUgPSAvXFxdL2c7XHJcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc2NvcGVTZWxlY3RvciwgbHJlLCAnXFxcXFsnKTtcclxuICAgICAgICBzY29wZVNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzY29wZVNlbGVjdG9yLCBycmUsICdcXFxcXScpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xyXG4gICAgICAgIC8vIERpZmZlcmVuY2UgZnJvbSB3ZWJjb21wb25lbnRzanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcclxuICAgIH07XHJcbiAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX3BvbHlmaWxsSG9zdFJlLCBzZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlQnkgPSB0aGlzLnN0cmljdFN0eWxpbmcgPyBcIltcIiArIGhvc3RTZWxlY3RvciArIFwiXVwiIDogc2NvcGVTZWxlY3RvcjtcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHNlbGVjdG9yLCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCByZXBsYWNlQnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzZWxlY3RvciwgX3BvbHlmaWxsSG9zdFJlLCByZXBsYWNlQnkgKyAnICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcmV0dXJuIGEgc2VsZWN0b3Igd2l0aCBbbmFtZV0gc3VmZml4IG9uIGVhY2ggc2ltcGxlIHNlbGVjdG9yXHJcbiAgICAvLyBlLmcuIC5mb28uYmFyID4gLnpvdCBiZWNvbWVzIC5mb29bbmFtZV0uYmFyW25hbWVdID4gLnpvdFtuYW1lXVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIGlzUmUgPSAvXFxbaXM9KFteXFxdXSopXFxdL2c7XHJcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoc2NvcGVTZWxlY3RvciwgaXNSZSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV07IH0pO1xyXG4gICAgICAgIHZhciBzcGxpdHMgPSBbJyAnLCAnPicsICcrJywgJ34nXSwgc2NvcGVkID0gc2VsZWN0b3IsIGF0dHJOYW1lID0gJ1snICsgc2NvcGVTZWxlY3RvciArICddJztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VwID0gc3BsaXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzY29wZWQuc3BsaXQoc2VwKTtcclxuICAgICAgICAgICAgc2NvcGVkID0gcGFydHMubWFwKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgOmhvc3Qgc2luY2UgaXQgc2hvdWxkIGJlIHVubmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwocC50cmltKCksIF9wb2x5ZmlsbEhvc3RSZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCAmJiAhY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKHNwbGl0cywgdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhbGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnModCwgYXR0ck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlID0gLyhbXjpdKikoOiopKC4qKS9nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChyZSwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG1bMV0gKyBhdHRyTmFtZSArIG1bMl0gKyBtWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjb3BlZDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBzZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc2VsZWN0b3IsIF9jb2xvbkhvc3RDb250ZXh0UmUsIF9wb2x5ZmlsbEhvc3RDb250ZXh0KTtcclxuICAgICAgICBzZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc2VsZWN0b3IsIF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Byb3BlcnRpZXNGcm9tUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgdmFyIGNzc1RleHQgPSBydWxlLnN0eWxlLmNzc1RleHQ7XHJcbiAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogU2FmYXJpIGNzc29tIGluY29ycmVjdGx5IHJlbW92ZXMgcXVvdGVzIGZyb20gdGhlIGNvbnRlbnRcclxuICAgICAgICAvLyBwcm9wZXJ0eS4gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTgwNDUpXHJcbiAgICAgICAgLy8gZG9uJ3QgcmVwbGFjZSBhdHRyIHJ1bGVzXHJcbiAgICAgICAgdmFyIGF0dHJSZSA9IC9bJ1wiXSt8YXR0ci9nO1xyXG4gICAgICAgIGlmIChydWxlLnN0eWxlLmNvbnRlbnQubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICAhbGFuZ18xLmlzUHJlc2VudChsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKGF0dHJSZSwgcnVsZS5zdHlsZS5jb250ZW50KSkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRSZSA9IC9jb250ZW50OlteO10qOy9nO1xyXG4gICAgICAgICAgICBjc3NUZXh0ID1cclxuICAgICAgICAgICAgICAgIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoY3NzVGV4dCwgY29udGVudFJlLCAnY29udGVudDogXFwnJyArIHJ1bGUuc3R5bGUuY29udGVudCArICdcXCc7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IHdlIGNhbiB3b3JrYXJvdW5kIHRoaXMgaXNzdWUgaGVyZSwgYnV0IHdlIG5lZWQgYSBsaXN0XHJcbiAgICAgICAgLy8gb2YgdHJvdWJsZXNvbWUgcHJvcGVydGllcyB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcGxhdGZvcm0vaXNzdWVzLzUzXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBpbmhlcml0IHJ1bGVzIGNhbiBiZSBvbWl0dGVkIGZyb20gY3NzVGV4dFxyXG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IHJlbW92ZSB3aGVuIEJsaW5rIGJ1ZyBpcyBmaXhlZDpcclxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU4MjczXHJcbiAgICAgICAgLy8gdmFyIHN0eWxlID0gcnVsZS5zdHlsZTtcclxuICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gIHZhciBuYW1lID0gc3R5bGUuaXRlbShpKTtcclxuICAgICAgICAvLyAgdmFyIHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcclxuICAgICAgICAvLyAgaWYgKHZhbHVlID09ICdpbml0aWFsJykge1xyXG4gICAgICAgIC8vICAgIGNzc1RleHQgKz0gbmFtZSArICc6IGluaXRpYWw7ICc7XHJcbiAgICAgICAgLy8gIH1cclxuICAgICAgICAvL31cclxuICAgICAgICByZXR1cm4gY3NzVGV4dDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2hhZG93Q3NzO1xyXG59KSgpO1xyXG5leHBvcnRzLlNoYWRvd0NzcyA9IFNoYWRvd0NzcztcclxudmFyIF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUgPSAvcG9seWZpbGwtbmV4dC1zZWxlY3RvcltefV0qY29udGVudDpbXFxzXSo/WydcIl0oLio/KVsnXCJdWztcXHNdKn0oW157XSo/KXsvZ2ltO1xyXG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSpbJ1wiXSguKj8pWydcIl0pWztcXHNdKltefV0qfS9naW07XHJcbnZhciBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlID0gLyhwb2x5ZmlsbC11bnNjb3BlZC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qWydcIl0oLio/KVsnXCJdKVs7XFxzXSpbXn1dKn0vZ2ltO1xyXG52YXIgX3BvbHlmaWxsSG9zdCA9ICctc2hhZG93Y3NzaG9zdCc7XHJcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXHJcbnZhciBfcG9seWZpbGxIb3N0Q29udGV4dCA9ICctc2hhZG93Y3NzY29udGV4dCc7XHJcbnZhciBfcGFyZW5TdWZmaXggPSAnKSg/OlxcXFwoKCcgK1xyXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXHJcbiAgICAnKVxcXFwpKT8oW14se10qKSc7XHJcbnZhciBfY3NzQ29sb25Ib3N0UmUgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2ltJyk7XHJcbnZhciBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnaW0nKTtcclxudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgPSBfcG9seWZpbGxIb3N0ICsgJy1uby1jb21iaW5hdG9yJztcclxudmFyIF9zaGFkb3dET01TZWxlY3RvcnNSZSA9IFtcclxuICAgIC8+Pj4vZyxcclxuICAgIC86OnNoYWRvdy9nLFxyXG4gICAgLzo6Y29udGVudC9nLFxyXG4gICAgLy8gRGVwcmVjYXRlZCBzZWxlY3RvcnNcclxuICAgIC8vIFRPRE8odmljYik6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jbGFuZy1mb3JtYXQvaXNzdWVzLzE2XHJcbiAgICAvLyBjbGFuZy1mb3JtYXQgb2ZmXHJcbiAgICAvXFwvZGVlcFxcLy9nLFxyXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXHJcbiAgICAvXFwvc2hhZG93XFwvL2csXHJcbl07XHJcbnZhciBfc2VsZWN0b3JSZVN1ZmZpeCA9ICcoWz5cXFxcc34rXFxbLix7Ol1bXFxcXHNcXFxcU10qKT8kJztcclxudmFyIF9wb2x5ZmlsbEhvc3RSZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZShfcG9seWZpbGxIb3N0LCAnaW0nKTtcclxudmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XHJcbnZhciBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xyXG5mdW5jdGlvbiBfY3NzVG9SdWxlcyhjc3NUZXh0KSB7XHJcbiAgICByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00uY3NzVG9SdWxlcyhjc3NUZXh0KTtcclxufVxyXG5mdW5jdGlvbiBfd2l0aENzc1J1bGVzKGNzc1RleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAvLyBEaWZmZXJlbmNlIGZyb20gd2ViY29tcG9uZW50anM6IHJlbW92ZSB0aGUgd29ya2Fyb3VuZCBmb3IgYW4gb2xkIGJ1ZyBpbiBDaHJvbWVcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhjYWxsYmFjaykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHJ1bGVzID0gX2Nzc1RvUnVsZXMoY3NzVGV4dCk7XHJcbiAgICBjYWxsYmFjayhydWxlcyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93X2Nzcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBNT0RVTEVfUkVHRVhQID0gLyNNT0RVTEVcXFsoW15cXF1dKilcXF0vZztcclxuZnVuY3Rpb24gbW9kdWxlUmVmKG1vZHVsZVVybCkge1xyXG4gICAgcmV0dXJuIFwiI01PRFVMRVtcIiArIG1vZHVsZVVybCArIFwiXVwiO1xyXG59XHJcbmV4cG9ydHMubW9kdWxlUmVmID0gbW9kdWxlUmVmO1xyXG52YXIgU291cmNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZU1vZHVsZShtb2R1bGVVcmwsIHNvdXJjZVdpdGhNb2R1bGVSZWZzKSB7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VXaXRoTW9kdWxlUmVmcyA9IHNvdXJjZVdpdGhNb2R1bGVSZWZzO1xyXG4gICAgfVxyXG4gICAgU291cmNlTW9kdWxlLnByb3RvdHlwZS5nZXRTb3VyY2VXaXRoSW1wb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtb2R1bGVBbGlhc2VzID0ge307XHJcbiAgICAgICAgdmFyIGltcG9ydHMgPSBbXTtcclxuICAgICAgICB2YXIgbmV3U291cmNlID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZCh0aGlzLnNvdXJjZVdpdGhNb2R1bGVSZWZzLCBNT0RVTEVfUkVHRVhQLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZVVybCA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICB2YXIgYWxpYXMgPSBtb2R1bGVBbGlhc2VzW21vZHVsZVVybF07XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhhbGlhcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVVcmwgPT0gX3RoaXMubW9kdWxlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzID0gXCJpbXBvcnRcIiArIGltcG9ydHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHMucHVzaChbbW9kdWxlVXJsLCBhbGlhc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9kdWxlQWxpYXNlc1ttb2R1bGVVcmxdID0gYWxpYXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWFzLmxlbmd0aCA+IDAgPyBhbGlhcyArIFwiLlwiIDogJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VXaXRoSW1wb3J0cyhuZXdTb3VyY2UsIGltcG9ydHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTb3VyY2VNb2R1bGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU291cmNlTW9kdWxlID0gU291cmNlTW9kdWxlO1xyXG52YXIgU291cmNlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTb3VyY2VFeHByZXNzaW9uKGRlY2xhcmF0aW9ucywgZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU291cmNlRXhwcmVzc2lvbjtcclxufSkoKTtcclxuZXhwb3J0cy5Tb3VyY2VFeHByZXNzaW9uID0gU291cmNlRXhwcmVzc2lvbjtcclxudmFyIFNvdXJjZUV4cHJlc3Npb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZUV4cHJlc3Npb25zKGRlY2xhcmF0aW9ucywgZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU291cmNlRXhwcmVzc2lvbnM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU291cmNlRXhwcmVzc2lvbnMgPSBTb3VyY2VFeHByZXNzaW9ucztcclxudmFyIFNvdXJjZVdpdGhJbXBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZVdpdGhJbXBvcnRzKHNvdXJjZSwgaW1wb3J0cykge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMuaW1wb3J0cyA9IGltcG9ydHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU291cmNlV2l0aEltcG9ydHM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU291cmNlV2l0aEltcG9ydHMgPSBTb3VyY2VXaXRoSW1wb3J0cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlX21vZHVsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIHNvdXJjZV9tb2R1bGVfMSA9IHJlcXVpcmUoJy4vc291cmNlX21vZHVsZScpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvdmlldycpO1xyXG52YXIgeGhyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBzaGFkb3dfY3NzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zaGFkb3dfY3NzJyk7XHJcbnZhciB1cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3VybF9yZXNvbHZlcicpO1xyXG52YXIgc3R5bGVfdXJsX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX3VybF9yZXNvbHZlcicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIENPTVBPTkVOVF9WQVJJQUJMRSA9ICclQ09NUCUnO1xyXG52YXIgQ09NUE9ORU5UX1JFR0VYID0gLyVDT01QJS9nO1xyXG52YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xyXG52YXIgSE9TVF9BVFRSX0VYUFIgPSBcIidfbmdob3N0LScrXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XHJcbnZhciBDT05URU5UX0FUVFIgPSBcIl9uZ2NvbnRlbnQtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XHJcbnZhciBDT05URU5UX0FUVFJfRVhQUiA9IFwiJ19uZ2NvbnRlbnQtJytcIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcclxudmFyIFN0eWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3R5bGVDb21waWxlcihfeGhyLCBfdXJsUmVzb2x2ZXIpIHtcclxuICAgICAgICB0aGlzLl94aHIgPSBfeGhyO1xyXG4gICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3N0eWxlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IHNoYWRvd19jc3NfMS5TaGFkb3dDc3MoKTtcclxuICAgIH1cclxuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnRSdW50aW1lID0gZnVuY3Rpb24gKGFwcElkLCB0ZW1wbGF0ZUlkLCB0ZW1wbGF0ZSkge1xyXG4gICAgICAgIHZhciBzdHlsZXMgPSB0ZW1wbGF0ZS5zdHlsZXM7XHJcbiAgICAgICAgdmFyIHN0eWxlQWJzVXJscyA9IHRlbXBsYXRlLnN0eWxlVXJscztcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFN0eWxlcyhzdHlsZXMsIHN0eWxlQWJzVXJscywgdGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3R5bGVzKSB7IHJldHVybiBzdHlsZXMubWFwKGZ1bmN0aW9uIChzdHlsZSkgeyByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzdHlsZSwgQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRJZChhcHBJZCwgdGVtcGxhdGVJZCkpOyB9KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudENvZGVHZW4gPSBmdW5jdGlvbiAoYXBwSWRFeHByZXNzaW9uLCB0ZW1wbGF0ZUlkRXhwcmVzc2lvbiwgdGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgc2hpbSA9IHRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcclxuICAgICAgICB2YXIgc3VmZml4O1xyXG4gICAgICAgIGlmIChzaGltKSB7XHJcbiAgICAgICAgICAgIHN1ZmZpeCA9IHV0aWxfMS5jb2RlR2VuTWFwQXJyYXkoWydzdHlsZSddLCBcInN0eWxlXCIgKyB1dGlsXzEuY29kZUdlblJlcGxhY2VBbGwoQ09NUE9ORU5UX1ZBUklBQkxFLCBjb21wb25lbnRJZEV4cHJlc3Npb24oYXBwSWRFeHByZXNzaW9uLCB0ZW1wbGF0ZUlkRXhwcmVzc2lvbikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1ZmZpeCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVDb2RlR2VuKHRlbXBsYXRlLnN0eWxlcywgdGVtcGxhdGUuc3R5bGVVcmxzLCBzaGltLCBzdWZmaXgpO1xyXG4gICAgfTtcclxuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVTdHlsZXNoZWV0Q29kZUdlbiA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0VXJsLCBjc3NUZXh0KSB7XHJcbiAgICAgICAgdmFyIHN0eWxlV2l0aEltcG9ydHMgPSBzdHlsZV91cmxfcmVzb2x2ZXJfMS5yZXNvbHZlU3R5bGVVcmxzKHRoaXMuX3VybFJlc29sdmVyLCBzdHlsZXNoZWV0VXJsLCBjc3NUZXh0KTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZU1vZHVsZShzdHlsZXNoZWV0VXJsLCBmYWxzZSwgdGhpcy5fc3R5bGVDb2RlR2VuKFtzdHlsZVdpdGhJbXBvcnRzLnN0eWxlXSwgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMsIGZhbHNlLCAnJykpLFxyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZU1vZHVsZShzdHlsZXNoZWV0VXJsLCB0cnVlLCB0aGlzLl9zdHlsZUNvZGVHZW4oW3N0eWxlV2l0aEltcG9ydHMuc3R5bGVdLCBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscywgdHJ1ZSwgJycpKVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fc3R5bGVDYWNoZS5jbGVhcigpOyB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX2xvYWRTdHlsZXMgPSBmdW5jdGlvbiAocGxhaW5TdHlsZXMsIGFic1VybHMsIGVuY2Fwc3VsYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBhYnNVcmxzLm1hcChmdW5jdGlvbiAoYWJzVXJsKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiXCIgKyBhYnNVcmwgKyAoZW5jYXBzdWxhdGUgPyAnLnNoaW0nIDogJycpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuX3N0eWxlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF90aGlzLl94aHIuZ2V0KGFic1VybCkudGhlbihmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IHN0eWxlX3VybF9yZXNvbHZlcl8xLnJlc29sdmVTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCBhYnNVcmwsIHN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2xvYWRTdHlsZXMoW3N0eWxlV2l0aEltcG9ydHMuc3R5bGVdLCBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscywgZW5jYXBzdWxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKG5lc3RlZFN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGxhaW5TdHlsZXMubWFwKGZ1bmN0aW9uIChwbGFpblN0eWxlKSB7IHJldHVybiBfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIGVuY2Fwc3VsYXRlKTsgfSk7XHJcbiAgICAgICAgICAgIG5lc3RlZFN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXMpIHsgcmV0dXJuIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkgeyByZXR1cm4gcmVzdWx0LnB1c2goc3R5bGUpOyB9KTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX3N0eWxlQ29kZUdlbiA9IGZ1bmN0aW9uIChwbGFpblN0eWxlcywgYWJzVXJscywgc2hpbSwgc3VmZml4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZXhwcmVzc2lvblNvdXJjZSA9IFwiKFwiO1xyXG4gICAgICAgIGV4cHJlc3Npb25Tb3VyY2UgKz1cclxuICAgICAgICAgICAgXCJbXCIgKyBwbGFpblN0eWxlcy5tYXAoZnVuY3Rpb24gKHBsYWluU3R5bGUpIHsgcmV0dXJuIHV0aWxfMS5lc2NhcGVTaW5nbGVRdW90ZVN0cmluZyhfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSkuam9pbignLCcpICsgXCJdXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhYnNVcmxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2R1bGVVcmwgPSB0aGlzLl9jcmVhdGVNb2R1bGVVcmwoYWJzVXJsc1tpXSwgc2hpbSk7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25Tb3VyY2UgKz0gdXRpbF8xLmNvZGVHZW5Db25jYXRBcnJheShzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKG1vZHVsZVVybCkgKyBcIlNUWUxFU1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwcmVzc2lvblNvdXJjZSArPSBcIilcIiArIHN1ZmZpeDtcclxuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VFeHByZXNzaW9uKFtdLCBleHByZXNzaW9uU291cmNlKTtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fc3R5bGVNb2R1bGUgPSBmdW5jdGlvbiAoc3R5bGVzaGVldFVybCwgc2hpbSwgZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHZhciBtb2R1bGVTb3VyY2UgPSBcIlxcbiAgICAgIFwiICsgZXhwcmVzc2lvbi5kZWNsYXJhdGlvbnMuam9pbignXFxuJykgKyBcIlxcbiAgICAgIFwiICsgdXRpbF8xLmNvZGVHZW5FeHBvcnRWYXJpYWJsZSgnU1RZTEVTJykgKyBleHByZXNzaW9uLmV4cHJlc3Npb24gKyBcIjtcXG4gICAgXCI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBzb3VyY2VfbW9kdWxlXzEuU291cmNlTW9kdWxlKHRoaXMuX2NyZWF0ZU1vZHVsZVVybChzdHlsZXNoZWV0VXJsLCBzaGltKSwgbW9kdWxlU291cmNlKTtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fc2hpbUlmTmVlZGVkID0gZnVuY3Rpb24gKHN0eWxlLCBzaGltKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoaW0gPyB0aGlzLl9zaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUsIENPTlRFTlRfQVRUUiwgSE9TVF9BVFRSKSA6IHN0eWxlO1xyXG4gICAgfTtcclxuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVNb2R1bGVVcmwgPSBmdW5jdGlvbiAoc3R5bGVzaGVldFVybCwgc2hpbSkge1xyXG4gICAgICAgIHJldHVybiBzaGltID8gc3R5bGVzaGVldFVybCArIFwiLnNoaW1cIiArIHV0aWxfMS5NT0RVTEVfU1VGRklYIDogXCJcIiArIHN0eWxlc2hlZXRVcmwgKyB1dGlsXzEuTU9EVUxFX1NVRkZJWDtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3hocl8xLlhIUiwgdXJsX3Jlc29sdmVyXzEuVXJsUmVzb2x2ZXJdKVxyXG4gICAgXSwgU3R5bGVDb21waWxlcik7XHJcbiAgICByZXR1cm4gU3R5bGVDb21waWxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TdHlsZUNvbXBpbGVyID0gU3R5bGVDb21waWxlcjtcclxuZnVuY3Rpb24gc2hpbUNvbnRlbnRBdHRyaWJ1dGUoYXBwSWQsIHRlbXBsYXRlSWQpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKENPTlRFTlRfQVRUUiwgQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRJZChhcHBJZCwgdGVtcGxhdGVJZCkpO1xyXG59XHJcbmV4cG9ydHMuc2hpbUNvbnRlbnRBdHRyaWJ1dGUgPSBzaGltQ29udGVudEF0dHJpYnV0ZTtcclxuZnVuY3Rpb24gc2hpbUNvbnRlbnRBdHRyaWJ1dGVFeHByKGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKENPTlRFTlRfQVRUUl9FWFBSLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudElkRXhwcmVzc2lvbihhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByKSk7XHJcbn1cclxuZXhwb3J0cy5zaGltQ29udGVudEF0dHJpYnV0ZUV4cHIgPSBzaGltQ29udGVudEF0dHJpYnV0ZUV4cHI7XHJcbmZ1bmN0aW9uIHNoaW1Ib3N0QXR0cmlidXRlKGFwcElkLCB0ZW1wbGF0ZUlkKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChIT1NUX0FUVFIsIENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50SWQoYXBwSWQsIHRlbXBsYXRlSWQpKTtcclxufVxyXG5leHBvcnRzLnNoaW1Ib3N0QXR0cmlidXRlID0gc2hpbUhvc3RBdHRyaWJ1dGU7XHJcbmZ1bmN0aW9uIHNoaW1Ib3N0QXR0cmlidXRlRXhwcihhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChIT1NUX0FUVFJfRVhQUiwgQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRJZEV4cHJlc3Npb24oYXBwSWRFeHByLCB0ZW1wbGF0ZUlkRXhwcikpO1xyXG59XHJcbmV4cG9ydHMuc2hpbUhvc3RBdHRyaWJ1dGVFeHByID0gc2hpbUhvc3RBdHRyaWJ1dGVFeHByO1xyXG5mdW5jdGlvbiBjb21wb25lbnRJZChhcHBJZCwgdGVtcGxhdGVJZCkge1xyXG4gICAgcmV0dXJuIGFwcElkICsgXCItXCIgKyB0ZW1wbGF0ZUlkO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBvbmVudElkRXhwcmVzc2lvbihhcHBJZEV4cHJlc3Npb24sIHRlbXBsYXRlSWRFeHByZXNzaW9uKSB7XHJcbiAgICByZXR1cm4gYXBwSWRFeHByZXNzaW9uICsgXCIrJy0nK1wiICsgdXRpbF8xLmNvZGVHZW5Ub1N0cmluZyh0ZW1wbGF0ZUlkRXhwcmVzc2lvbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVfY29tcGlsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFNvbWUgb2YgdGhlIGNvZGUgY29tZXMgZnJvbSBXZWJDb21wb25lbnRzLkpTXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iL21hc3Rlci9zcmMvSFRNTEltcG9ydHMvcGF0aC5qc1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFJld3JpdGVzIFVSTHMgYnkgcmVzb2x2aW5nICdAaW1wb3J0JyBhbmQgJ3VybCgpJyBVUkxzIGZyb20gdGhlIGdpdmVuIGJhc2UgVVJMLFxyXG4gKiByZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBAaW1wb3J0IHVybHNcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVTdHlsZVVybHMocmVzb2x2ZXIsIGJhc2VVcmwsIGNzc1RleHQpIHtcclxuICAgIHZhciBmb3VuZFVybHMgPSBbXTtcclxuICAgIGNzc1RleHQgPSBleHRyYWN0VXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCwgZm91bmRVcmxzKTtcclxuICAgIGNzc1RleHQgPSByZXBsYWNlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCk7XHJcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMoY3NzVGV4dCwgZm91bmRVcmxzKTtcclxufVxyXG5leHBvcnRzLnJlc29sdmVTdHlsZVVybHMgPSByZXNvbHZlU3R5bGVVcmxzO1xyXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcclxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3R5bGVXaXRoSW1wb3J0cztcclxufSkoKTtcclxuZXhwb3J0cy5TdHlsZVdpdGhJbXBvcnRzID0gU3R5bGVXaXRoSW1wb3J0cztcclxuZnVuY3Rpb24gZXh0cmFjdFVybHMocmVzb2x2ZXIsIGJhc2VVcmwsIGNzc1RleHQsIGZvdW5kVXJscykge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoY3NzVGV4dCwgX2Nzc0ltcG9ydFJlLCBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIHZhciB1cmwgPSBsYW5nXzEuaXNQcmVzZW50KG1bMV0pID8gbVsxXSA6IG1bMl07XHJcbiAgICAgICAgdmFyIHNjaGVtZU1hdGNoID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChfdXJsV2l0aFNjaGVtYVJlLCB1cmwpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHNjaGVtZU1hdGNoKSAmJiBzY2hlbWVNYXRjaFsxXSAhPSAncGFja2FnZScpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxyXG4gICAgICAgICAgICByZXR1cm4gbVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBsYWNlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoY3NzVGV4dCwgX2Nzc1VybFJlLCBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIHZhciBwcmUgPSBtWzFdO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbFVybCA9IG1bMl07XHJcbiAgICAgICAgaWYgKGxhbmdfMS5SZWdFeHBXcmFwcGVyLnRlc3QoX2RhdGFVcmxSZSwgb3JpZ2luYWxVcmwpKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlc29sdmUgZGF0YTogVVJMc1xyXG4gICAgICAgICAgICByZXR1cm4gbVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwob3JpZ2luYWxVcmwsIF9xdW90ZVJlLCAnJyk7XHJcbiAgICAgICAgdmFyIHBvc3QgPSBtWzNdO1xyXG4gICAgICAgIHZhciByZXNvbHZlZFVybCA9IHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKTtcclxuICAgICAgICByZXR1cm4gcHJlICsgXCInXCIgKyByZXNvbHZlZFVybCArIFwiJ1wiICsgcG9zdDtcclxuICAgIH0pO1xyXG59XHJcbnZhciBfY3NzVXJsUmUgPSAvKHVybFxcKCkoW14pXSopKFxcKSkvZztcclxudmFyIF9jc3NJbXBvcnRSZSA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/XFxzKig/Oig/OlsnXCJdKFteJ1wiXSopKXwoW147XFwpXFxzXSopKVteO10qOz8vZztcclxudmFyIF9xdW90ZVJlID0gL1snXCJdL2c7XHJcbnZhciBfZGF0YVVybFJlID0gL15bJ1wiXT9kYXRhOi9nO1xyXG4vLyBUT0RPOiBjYW4ndCB1c2UgL15bXjovPyMuXSs6L2cgZHVlIHRvIGNsYW5nLWZvcm1hdCBidWc6XHJcbi8vICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQ1OTZcclxudmFyIF91cmxXaXRoU2NoZW1hUmUgPSAvXlsnXCJdPyhbYS16QS1aXFwtXFwrXFwuXSspOi9nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZV91cmxfcmVzb2x2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgVGV4dEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xyXG4gICAgcmV0dXJuIFRleHRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGV4dEFzdCA9IFRleHRBc3Q7XHJcbnZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEJvdW5kVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCb3VuZFRleHRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQm91bmRUZXh0QXN0ID0gQm91bmRUZXh0QXN0O1xyXG52YXIgQXR0ckFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpOyB9O1xyXG4gICAgcmV0dXJuIEF0dHJBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXR0ckFzdCA9IEF0dHJBc3Q7XHJcbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChuYW1lLCB0eXBlLCB2YWx1ZSwgdW5pdCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgQm91bmRFbGVtZW50UHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnRQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQm91bmRFbGVtZW50UHJvcGVydHlBc3QgPSBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcclxudmFyIEJvdW5kRXZlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm91bmRFdmVudEFzdChuYW1lLCB0YXJnZXQsIGhhbmRsZXIsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJmdWxsTmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ICsgXCI6XCIgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5Cb3VuZEV2ZW50QXN0ID0gQm91bmRFdmVudEFzdDtcclxudmFyIFZhcmlhYmxlQXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhcmlhYmxlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFyaWFibGVBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVmFyaWFibGVBc3QgPSBWYXJpYWJsZUFzdDtcclxudmFyIEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRWxlbWVudEFzdChuYW1lLCBhdHRycywgaW5wdXRzLCBvdXRwdXRzLCBleHBvcnRBc1ZhcnMsIGRpcmVjdGl2ZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xyXG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xyXG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XHJcbiAgICAgICAgdGhpcy5leHBvcnRBc1ZhcnMgPSBleHBvcnRBc1ZhcnM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLmlzQm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmlucHV0cy5sZW5ndGggPiAwIHx8IHRoaXMub3V0cHV0cy5sZW5ndGggPiAwIHx8IHRoaXMuZXhwb3J0QXNWYXJzLmxlbmd0aCA+IDAgfHxcclxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmxlbmd0aCA+IDApO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RpdmVzLmxlbmd0aCA+IDAgJiYgdGhpcy5kaXJlY3RpdmVzWzBdLmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1swXS5kaXJlY3RpdmUgOlxyXG4gICAgICAgICAgICBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbGVtZW50QXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLkVsZW1lbnRBc3QgPSBFbGVtZW50QXN0O1xyXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCB2YXJzLCBkaXJlY3RpdmVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgdGhpcy52YXJzID0gdmFycztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEVtYmVkZGVkVGVtcGxhdGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtYmVkZGVkVGVtcGxhdGUodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVtYmVkZGVkVGVtcGxhdGVBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IEVtYmVkZGVkVGVtcGxhdGVBc3Q7XHJcbnZhciBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZU5hbWU7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5Cb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcclxudmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBleHBvcnRBc1ZhcnMsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcclxuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XHJcbiAgICAgICAgdGhpcy5ob3N0RXZlbnRzID0gaG9zdEV2ZW50cztcclxuICAgICAgICB0aGlzLmV4cG9ydEFzVmFycyA9IGV4cG9ydEFzVmFycztcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgRGlyZWN0aXZlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmUodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpcmVjdGl2ZUFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVBc3QgPSBEaXJlY3RpdmVBc3Q7XHJcbnZhciBOZ0NvbnRlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdDb250ZW50QXN0KGluZGV4LCBuZ0NvbnRlbnRJbmRleCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdDb250ZW50QXN0ID0gTmdDb250ZW50QXN0O1xyXG4oZnVuY3Rpb24gKFByb3BlcnR5QmluZGluZ1R5cGUpIHtcclxuICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIlByb3BlcnR5XCJdID0gMF0gPSBcIlByb3BlcnR5XCI7XHJcbiAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJBdHRyaWJ1dGVcIl0gPSAxXSA9IFwiQXR0cmlidXRlXCI7XHJcbiAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJDbGFzc1wiXSA9IDJdID0gXCJDbGFzc1wiO1xyXG4gICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiU3R5bGVcIl0gPSAzXSA9IFwiU3R5bGVcIjtcclxufSkoZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlIHx8IChleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgPSB7fSkpO1xyXG52YXIgUHJvcGVydHlCaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZTtcclxuZnVuY3Rpb24gdGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCBhc3RzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBhc3RSZXN1bHQgPSBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXN0UmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnRzLnRlbXBsYXRlVmlzaXRBbGwgPSB0ZW1wbGF0ZVZpc2l0QWxsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9hc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIHRlbXBsYXRlX2NvbW1hbmRzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdGVtcGxhdGVfY29tbWFuZHMnKTtcclxudmFyIGRpcmVjdGl2ZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgc291cmNlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9zb3VyY2VfbW9kdWxlJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXJfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyJyk7XHJcbnZhciBzdHlsZV9jb21waWxlcl8xID0gcmVxdWlyZSgnLi9zdHlsZV9jb21waWxlcicpO1xyXG52YXIgY29tbWFuZF9jb21waWxlcl8xID0gcmVxdWlyZSgnLi9jb21tYW5kX2NvbXBpbGVyJyk7XHJcbnZhciB0ZW1wbGF0ZV9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfcGFyc2VyJyk7XHJcbnZhciB0ZW1wbGF0ZV9ub3JtYWxpemVyXzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX25vcm1hbGl6ZXInKTtcclxudmFyIHJ1bnRpbWVfbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vcnVudGltZV9tZXRhZGF0YScpO1xyXG52YXIgYXBwbGljYXRpb25fdG9rZW5zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9hcHBsaWNhdGlvbl90b2tlbnMnKTtcclxudmFyIGNvbW1hbmRfY29tcGlsZXJfMiA9IHJlcXVpcmUoJy4vY29tbWFuZF9jb21waWxlcicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBkaV8yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIFRlbXBsYXRlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVDb21waWxlcihfcnVudGltZU1ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZU5vcm1hbGl6ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF9jb21tYW5kQ29tcGlsZXIsIF9jZENvbXBpbGVyLCBhcHBJZCkge1xyXG4gICAgICAgIHRoaXMuX3J1bnRpbWVNZXRhZGF0YVJlc29sdmVyID0gX3J1bnRpbWVNZXRhZGF0YVJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplciA9IF90ZW1wbGF0ZU5vcm1hbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVQYXJzZXIgPSBfdGVtcGxhdGVQYXJzZXI7XHJcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xyXG4gICAgICAgIHRoaXMuX2NvbW1hbmRDb21waWxlciA9IF9jb21tYW5kQ29tcGlsZXI7XHJcbiAgICAgICAgdGhpcy5fY2RDb21waWxlciA9IF9jZENvbXBpbGVyO1xyXG4gICAgICAgIHRoaXMuX2hvc3RDYWNoZUtleXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2FwcElkID0gYXBwSWQ7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5ub3JtYWxpemVEaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICBpZiAoIWRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAvLyBGb3Igbm9uIGNvbXBvbmVudHMgdGhlcmUgaXMgbm90aGluZyB0byBiZSBub3JtYWxpemVkIHlldC5cclxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZShkaXJlY3RpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9ybWFsaXplZFRlbXBsYXRlUHJvbWlzZTtcclxuICAgICAgICBpZiAoZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZVByb21pc2UgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVOb3JtYWxpemVyLm5vcm1hbGl6ZVRlbXBsYXRlKGRpcmVjdGl2ZS50eXBlLCBkaXJlY3RpdmUudGVtcGxhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlUHJvbWlzZSA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRUZW1wbGF0ZVByb21pc2UudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZFRlbXBsYXRlKSB7IHJldHVybiBuZXcgZGlyZWN0aXZlX21ldGFkYXRhXzEuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcclxuICAgICAgICAgICAgdHlwZTogZGlyZWN0aXZlLnR5cGUsXHJcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiBkaXJlY3RpdmUuaXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgIGR5bmFtaWNMb2FkYWJsZTogZGlyZWN0aXZlLmR5bmFtaWNMb2FkYWJsZSxcclxuICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcclxuICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICBpbnB1dHM6IGRpcmVjdGl2ZS5pbnB1dHMsXHJcbiAgICAgICAgICAgIG91dHB1dHM6IGRpcmVjdGl2ZS5vdXRwdXRzLFxyXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBkaXJlY3RpdmUuaG9zdExpc3RlbmVycyxcclxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IGRpcmVjdGl2ZS5ob3N0UHJvcGVydGllcyxcclxuICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlcyxcclxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGRpcmVjdGl2ZS5saWZlY3ljbGVIb29rcywgdGVtcGxhdGU6IG5vcm1hbGl6ZWRUZW1wbGF0ZVxyXG4gICAgICAgIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlSG9zdENvbXBvbmVudFJ1bnRpbWUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBob3N0Q2FjaGVLZXkgPSB0aGlzLl9ob3N0Q2FjaGVLZXlzLmdldCh0eXBlKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaG9zdENhY2hlS2V5KSkge1xyXG4gICAgICAgICAgICBob3N0Q2FjaGVLZXkgPSBuZXcgT2JqZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvc3RDYWNoZUtleXMuc2V0KHR5cGUsIGhvc3RDYWNoZUtleSk7XHJcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRoaXMuX3J1bnRpbWVNZXRhZGF0YVJlc29sdmVyLmdldE1ldGFkYXRhKHR5cGUpO1xyXG4gICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xyXG4gICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBkaXJlY3RpdmVfbWV0YWRhdGFfMS5jcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YS50eXBlLCBjb21wTWV0YS5zZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVDb21wb25lbnRSdW50aW1lKGhvc3RDYWNoZUtleSwgaG9zdE1ldGEsIFtjb21wTWV0YV0sIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5nZXQoaG9zdENhY2hlS2V5KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcGlsZWRUZW1wbGF0ZSkgeyByZXR1cm4gbmV3IHRlbXBsYXRlX2NvbW1hbmRzXzEuQ29tcGlsZWRIb3N0VGVtcGxhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTsgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faG9zdENhY2hlS2V5cy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIuY2xlYXJDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lLmNsZWFyKCk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRSdW50aW1lID0gZnVuY3Rpb24gKGNhY2hlS2V5LCBjb21wTWV0YSwgdmlld0RpcmVjdGl2ZXMsIGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgICB2YXIgZG9uZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lLmdldChjYWNoZUtleSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBpbGVkVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZXM7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VEZXRlY3RvckZhY3Rvcnk7XHJcbiAgICAgICAgICAgIHZhciBjb21tYW5kcztcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlSWQgPSB0ZW1wbGF0ZV9jb21tYW5kc18xLm5leHRUZW1wbGF0ZUlkKCk7XHJcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPVxyXG4gICAgICAgICAgICAgICAgbmV3IHRlbXBsYXRlX2NvbW1hbmRzXzEuQ29tcGlsZWRUZW1wbGF0ZSh0ZW1wbGF0ZUlkLCBmdW5jdGlvbiAoX2EsIF9iKSB7IHJldHVybiBbY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBjb21tYW5kcywgc3R5bGVzXTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5zZXQoY2FjaGVLZXksIGNvbXBpbGVkVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICBjb21waWxpbmdDb21wb25lbnRDYWNoZUtleXMuYWRkKGNhY2hlS2V5KTtcclxuICAgICAgICAgICAgZG9uZSA9XHJcbiAgICAgICAgICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50UnVudGltZSh0aGlzLl9hcHBJZCwgdGVtcGxhdGVJZCwgY29tcE1ldGEudGVtcGxhdGUpXHJcbiAgICAgICAgICAgICAgICBdLmNvbmNhdCh2aWV3RGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpck1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9ybWFsaXplRGlyZWN0aXZlTWV0YWRhdGEoZGlyTWV0YSk7XHJcbiAgICAgICAgICAgICAgICB9KSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN0eWxlc0FuZE5vcm1hbGl6ZWRWaWV3RGlyTWV0YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmlld0Rpck1ldGFzID0gc3R5bGVzQW5kTm9ybWFsaXplZFZpZXdEaXJNZXRhcy5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSBfdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIG5vcm1hbGl6ZWRWaWV3RGlyTWV0YXMsIGNvbXBNZXRhLnR5cGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZURldGVjdG9yRmFjdG9yaWVzID0gX3RoaXMuX2NkQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUoY29tcE1ldGEudHlwZSwgY29tcE1ldGEuY2hhbmdlRGV0ZWN0aW9uLCBwYXJzZWRUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5ID0gY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gc3R5bGVzQW5kTm9ybWFsaXplZFZpZXdEaXJNZXRhc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kcyA9IF90aGlzLl9jb21waWxlQ29tbWFuZHNSdW50aW1lKGNvbXBNZXRhLCB0ZW1wbGF0ZUlkLCBwYXJzZWRUZW1wbGF0ZSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXMsIGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cywgY2hpbGRQcm9taXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKGNoaWxkUHJvbWlzZXMpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmRlbGV0ZShjb21waWxpbmdDb21wb25lbnRDYWNoZUtleXMsIGNhY2hlS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5zZXQoY2FjaGVLZXksIGRvbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbW1hbmRzUnVudGltZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgdGVtcGxhdGVJZCwgcGFyc2VkVGVtcGxhdGUsIGNoYW5nZURldGVjdG9yRmFjdG9yaWVzLCBjb21waWxpbmdDb21wb25lbnRDYWNoZUtleXMsIGNoaWxkUHJvbWlzZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUoY29tcE1ldGEsIHRoaXMuX2FwcElkLCB0ZW1wbGF0ZUlkLCBwYXJzZWRUZW1wbGF0ZSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXMsIGZ1bmN0aW9uIChjaGlsZENvbXBvbmVudERpcikge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRDYWNoZUtleSA9IGNoaWxkQ29tcG9uZW50RGlyLnR5cGUucnVudGltZTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkVmlld0RpcmVjdGl2ZXMgPSBfdGhpcy5fcnVudGltZU1ldGFkYXRhUmVzb2x2ZXIuZ2V0Vmlld0RpcmVjdGl2ZXNNZXRhZGF0YShjaGlsZENvbXBvbmVudERpci50eXBlLnJ1bnRpbWUpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRJc1JlY3Vyc2l2ZSA9IGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhjb21waWxpbmdDb21wb25lbnRDYWNoZUtleXMsIGNoaWxkQ2FjaGVLZXkpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRUZW1wbGF0ZSA9IF90aGlzLl9jb21waWxlQ29tcG9uZW50UnVudGltZShjaGlsZENhY2hlS2V5LCBjaGlsZENvbXBvbmVudERpciwgY2hpbGRWaWV3RGlyZWN0aXZlcywgY29tcGlsaW5nQ29tcG9uZW50Q2FjaGVLZXlzKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZElzUmVjdXJzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHdhaXQgZm9yIGEgY2hpbGQgaWYgaXQgaXMgbm90IGEgY3ljbGVcclxuICAgICAgICAgICAgICAgIGNoaWxkUHJvbWlzZXMucHVzaChfdGhpcy5fY29tcGlsZWRUZW1wbGF0ZURvbmUuZ2V0KGNoaWxkQ2FjaGVLZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRUZW1wbGF0ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlVGVtcGxhdGVzQ29kZUdlbiA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdObyBjb21wb25lbnRzIGdpdmVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVBcmd1bWVudHMgPSBbXTtcclxuICAgICAgICB2YXIgY29tcG9uZW50TWV0YXMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVJZFZhcmlhYmxlID0gJ3RlbXBsYXRlSWQnO1xyXG4gICAgICAgIHZhciBhcHBJZFZhcmlhYmxlID0gJ2FwcElkJztcclxuICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudFdpdGhEaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IGNvbXBvbmVudFdpdGhEaXJzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcclxuICAgICAgICAgICAgY29tcG9uZW50TWV0YXMucHVzaChjb21wTWV0YSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzVGVtcGxhdGVDb2RlR2VuKGNvbXBNZXRhLCBhcHBJZFZhcmlhYmxlLCB0ZW1wbGF0ZUlkVmFyaWFibGUsIGNvbXBvbmVudFdpdGhEaXJzLmRpcmVjdGl2ZXMsIGRlY2xhcmF0aW9ucywgdGVtcGxhdGVBcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBpZiAoY29tcE1ldGEuZHluYW1pY0xvYWRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBkaXJlY3RpdmVfbWV0YWRhdGFfMS5jcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YS50eXBlLCBjb21wTWV0YS5zZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNZXRhcy5wdXNoKGhvc3RNZXRhKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzVGVtcGxhdGVDb2RlR2VuKGhvc3RNZXRhLCBhcHBJZFZhcmlhYmxlLCB0ZW1wbGF0ZUlkVmFyaWFibGUsIFtjb21wTWV0YV0sIGRlY2xhcmF0aW9ucywgdGVtcGxhdGVBcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoY29tcG9uZW50TWV0YXMsIGZ1bmN0aW9uIChjb21wTWV0YSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGF0YUZuID0gdXRpbF8xLmNvZGVHZW5WYWx1ZUZuKFthcHBJZFZhcmlhYmxlLCB0ZW1wbGF0ZUlkVmFyaWFibGVdLCBcIltcIiArIHRlbXBsYXRlQXJndW1lbnRzW2luZGV4XS5qb2luKCcsJykgKyBcIl1cIik7XHJcbiAgICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlRXhwciA9IFwibmV3IFwiICsgY29tbWFuZF9jb21waWxlcl8yLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcIkNvbXBpbGVkVGVtcGxhdGUoXCIgKyBjb21tYW5kX2NvbXBpbGVyXzIuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwibmV4dFRlbXBsYXRlSWQoKSxcIiArIHRlbXBsYXRlRGF0YUZuICsgXCIpXCI7XHJcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZVZhbHVlRXhwcjtcclxuICAgICAgICAgICAgaWYgKGNvbXBNZXRhLnR5cGUuaXNIb3N0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yeU5hbWUgPSBcIl9ob3N0VGVtcGxhdGVGYWN0b3J5XCIgKyBpbmRleDtcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHV0aWxfMS5jb2RlR2VuVmFsdWVGbihbXSwgY29tcGlsZWRUZW1wbGF0ZUV4cHIsIGZhY3RvcnlOYW1lKSArIFwiO1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3Rpb25LZXl3b3JkID0gdXRpbF8xLklTX0RBUlQgPyAnY29uc3QnIDogJ25ldyc7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlRXhwciA9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0aW9uS2V5d29yZCArIFwiIFwiICsgY29tbWFuZF9jb21waWxlcl8yLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcIkNvbXBpbGVkSG9zdFRlbXBsYXRlKFwiICsgZmFjdG9yeU5hbWUgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWVFeHByID0gY29tcGlsZWRUZW1wbGF0ZUV4cHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goXCJcIiArIHV0aWxfMS5jb2RlR2VuRXhwb3J0VmFyaWFibGUodGVtcGxhdGVWYXJpYWJsZU5hbWUoY29tcE1ldGEudHlwZSksIGNvbXBNZXRhLnR5cGUuaXNIb3N0KSArIHZhcmlhYmxlVmFsdWVFeHByICsgXCI7XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBtb2R1bGVVcmwgPSBjb21wb25lbnRzWzBdLmNvbXBvbmVudC50eXBlLm1vZHVsZVVybDtcclxuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VNb2R1bGUoXCJcIiArIHRlbXBsYXRlTW9kdWxlVXJsKG1vZHVsZVVybCksIGRlY2xhcmF0aW9ucy5qb2luKCdcXG4nKSk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZVN0eWxlc2hlZXRDb2RlR2VuID0gZnVuY3Rpb24gKHN0eWxlc2hlZXRVcmwsIGNzc1RleHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlU3R5bGVzaGVldENvZGVHZW4oc3R5bGVzaGVldFVybCwgY3NzVGV4dCk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVDb21waWxlci5wcm90b3R5cGUuX3Byb2Nlc3NUZW1wbGF0ZUNvZGVHZW4gPSBmdW5jdGlvbiAoY29tcE1ldGEsIGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIsIGRpcmVjdGl2ZXMsIHRhcmdldERlY2xhcmF0aW9ucywgdGFyZ2V0VGVtcGxhdGVBcmd1bWVudHMpIHtcclxuICAgICAgICB2YXIgc3R5bGVFeHByID0gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50Q29kZUdlbihhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByLCBjb21wTWV0YS50ZW1wbGF0ZSk7XHJcbiAgICAgICAgdmFyIHBhcnNlZFRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIGNvbXBNZXRhLnR5cGUubmFtZSk7XHJcbiAgICAgICAgdmFyIGNoYW5nZURldGVjdG9yc0V4cHJzID0gdGhpcy5fY2RDb21waWxlci5jb21waWxlQ29tcG9uZW50Q29kZUdlbihjb21wTWV0YS50eXBlLCBjb21wTWV0YS5jaGFuZ2VEZXRlY3Rpb24sIHBhcnNlZFRlbXBsYXRlKTtcclxuICAgICAgICB2YXIgY29tbWFuZHNFeHByID0gdGhpcy5fY29tbWFuZENvbXBpbGVyLmNvbXBpbGVDb21wb25lbnRDb2RlR2VuKGNvbXBNZXRhLCBhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByLCBwYXJzZWRUZW1wbGF0ZSwgY2hhbmdlRGV0ZWN0b3JzRXhwcnMuZXhwcmVzc2lvbnMsIGNvZGVHZW5Db21wb25lbnRUZW1wbGF0ZUZhY3RvcnkpO1xyXG4gICAgICAgIGFkZEFsbChzdHlsZUV4cHIuZGVjbGFyYXRpb25zLCB0YXJnZXREZWNsYXJhdGlvbnMpO1xyXG4gICAgICAgIGFkZEFsbChjaGFuZ2VEZXRlY3RvcnNFeHBycy5kZWNsYXJhdGlvbnMsIHRhcmdldERlY2xhcmF0aW9ucyk7XHJcbiAgICAgICAgYWRkQWxsKGNvbW1hbmRzRXhwci5kZWNsYXJhdGlvbnMsIHRhcmdldERlY2xhcmF0aW9ucyk7XHJcbiAgICAgICAgdGFyZ2V0VGVtcGxhdGVBcmd1bWVudHMucHVzaChbY2hhbmdlRGV0ZWN0b3JzRXhwcnMuZXhwcmVzc2lvbnNbMF0sIGNvbW1hbmRzRXhwci5leHByZXNzaW9uLCBzdHlsZUV4cHIuZXhwcmVzc2lvbl0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlQ29tcGlsZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDYsIGRpXzIuSW5qZWN0KGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JRCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtydW50aW1lX21ldGFkYXRhXzEuUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIsIHRlbXBsYXRlX25vcm1hbGl6ZXJfMS5UZW1wbGF0ZU5vcm1hbGl6ZXIsIHRlbXBsYXRlX3BhcnNlcl8xLlRlbXBsYXRlUGFyc2VyLCBzdHlsZV9jb21waWxlcl8xLlN0eWxlQ29tcGlsZXIsIGNvbW1hbmRfY29tcGlsZXJfMS5Db21tYW5kQ29tcGlsZXIsIGNoYW5nZV9kZXRlY3Rvcl9jb21waWxlcl8xLkNoYW5nZURldGVjdGlvbkNvbXBpbGVyLCBTdHJpbmddKVxyXG4gICAgXSwgVGVtcGxhdGVDb21waWxlcik7XHJcbiAgICByZXR1cm4gVGVtcGxhdGVDb21waWxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5UZW1wbGF0ZUNvbXBpbGVyID0gVGVtcGxhdGVDb21waWxlcjtcclxudmFyIE5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcyhjb21wb25lbnQsIGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcyA9IE5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXM7XHJcbmZ1bmN0aW9uIGFzc2VydENvbXBvbmVudChtZXRhKSB7XHJcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBtZXRhLnR5cGUubmFtZSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGVtcGxhdGVWYXJpYWJsZU5hbWUodHlwZSkge1xyXG4gICAgcmV0dXJuIHR5cGUubmFtZSArIFwiVGVtcGxhdGVcIjtcclxufVxyXG5mdW5jdGlvbiB0ZW1wbGF0ZU1vZHVsZVVybChtb2R1bGVVcmwpIHtcclxuICAgIHZhciB1cmxXaXRob3V0U3VmZml4ID0gbW9kdWxlVXJsLnN1YnN0cmluZygwLCBtb2R1bGVVcmwubGVuZ3RoIC0gdXRpbF8xLk1PRFVMRV9TVUZGSVgubGVuZ3RoKTtcclxuICAgIHJldHVybiB1cmxXaXRob3V0U3VmZml4ICsgXCIudGVtcGxhdGVcIiArIHV0aWxfMS5NT0RVTEVfU1VGRklYO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEFsbChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0YXJnZXQucHVzaChzb3VyY2VbaV0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvZGVHZW5Db21wb25lbnRUZW1wbGF0ZUZhY3RvcnkobmVzdGVkQ29tcFR5cGUpIHtcclxuICAgIHJldHVybiBcIlwiICsgc291cmNlX21vZHVsZV8xLm1vZHVsZVJlZih0ZW1wbGF0ZU1vZHVsZVVybChuZXN0ZWRDb21wVHlwZS50eXBlLm1vZHVsZVVybCkpICsgdGVtcGxhdGVWYXJpYWJsZU5hbWUobmVzdGVkQ29tcFR5cGUudHlwZSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVfY29tcGlsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaXJlY3RpdmVfbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX21ldGFkYXRhJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIHhocl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIveGhyJyk7XHJcbnZhciB1cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3VybF9yZXNvbHZlcicpO1xyXG52YXIgc3R5bGVfdXJsX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX3VybF9yZXNvbHZlcicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciBodG1sX2FzdF8xID0gcmVxdWlyZSgnLi9odG1sX2FzdCcpO1xyXG52YXIgaHRtbF9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vaHRtbF9wYXJzZXInKTtcclxudmFyIHRlbXBsYXRlX3ByZXBhcnNlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9wcmVwYXJzZXInKTtcclxudmFyIFRlbXBsYXRlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZU5vcm1hbGl6ZXIoX3hociwgX3VybFJlc29sdmVyLCBfZG9tUGFyc2VyKSB7XHJcbiAgICAgICAgdGhpcy5feGhyID0gX3hocjtcclxuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLl9kb21QYXJzZXIgPSBfZG9tUGFyc2VyO1xyXG4gICAgfVxyXG4gICAgVGVtcGxhdGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGUudGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSwgdGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGUudGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VBYnNVcmwgPSB0aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsLCB0ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94aHIuZ2V0KHNvdXJjZUFic1VybClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZUNvbnRlbnQpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlLCB0ZW1wbGF0ZUNvbnRlbnQsIHNvdXJjZUFic1VybCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gdGVtcGxhdGUgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyBkaXJlY3RpdmVUeXBlLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlTWV0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZG9tTm9kZXMgPSB0aGlzLl9kb21QYXJzZXIucGFyc2UodGVtcGxhdGUsIGRpcmVjdGl2ZVR5cGUubmFtZSk7XHJcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKTtcclxuICAgICAgICBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh2aXNpdG9yLCBkb21Ob2Rlcyk7XHJcbiAgICAgICAgdmFyIGFsbFN0eWxlcyA9IHRlbXBsYXRlTWV0YS5zdHlsZXMuY29uY2F0KHZpc2l0b3Iuc3R5bGVzKTtcclxuICAgICAgICB2YXIgYWxsU3R5bGVBYnNVcmxzID0gdmlzaXRvci5zdHlsZVVybHMubWFwKGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKHRlbXBsYXRlQWJzVXJsLCB1cmwpOyB9KVxyXG4gICAgICAgICAgICAuY29uY2F0KHRlbXBsYXRlTWV0YS5zdHlsZVVybHMubWFwKGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsLCB1cmwpOyB9KSk7XHJcbiAgICAgICAgdmFyIGFsbFJlc29sdmVkU3R5bGVzID0gYWxsU3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlV2l0aEltcG9ydHMgPSBzdHlsZV91cmxfcmVzb2x2ZXJfMS5yZXNvbHZlU3R5bGVVcmxzKF90aGlzLl91cmxSZXNvbHZlciwgdGVtcGxhdGVBYnNVcmwsIHN0eWxlKTtcclxuICAgICAgICAgICAgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIGFsbFN0eWxlQWJzVXJscy5wdXNoKHN0eWxlVXJsKTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb247XHJcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCAmJiBhbGxSZXNvbHZlZFN0eWxlcy5sZW5ndGggPT09IDAgJiZcclxuICAgICAgICAgICAgYWxsU3R5bGVBYnNVcmxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgZGlyZWN0aXZlX21ldGFkYXRhXzEuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBlbmNhcHN1bGF0aW9uLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZUFic1VybCxcclxuICAgICAgICAgICAgc3R5bGVzOiBhbGxSZXNvbHZlZFN0eWxlcyxcclxuICAgICAgICAgICAgc3R5bGVVcmxzOiBhbGxTdHlsZUFic1VybHMsXHJcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdmlzaXRvci5uZ0NvbnRlbnRTZWxlY3RvcnNcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZU5vcm1hbGl6ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbeGhyXzEuWEhSLCB1cmxfcmVzb2x2ZXJfMS5VcmxSZXNvbHZlciwgaHRtbF9wYXJzZXJfMS5IdG1sUGFyc2VyXSlcclxuICAgIF0sIFRlbXBsYXRlTm9ybWFsaXplcik7XHJcbiAgICByZXR1cm4gVGVtcGxhdGVOb3JtYWxpemVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlRlbXBsYXRlTm9ybWFsaXplciA9IFRlbXBsYXRlTm9ybWFsaXplcjtcclxudmFyIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gW107XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHRlbXBsYXRlX3ByZXBhcnNlcl8xLnByZXBhcnNlRWxlbWVudChhc3QpO1xyXG4gICAgICAgIHN3aXRjaCAocHJlcGFyc2VkRWxlbWVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMucHVzaChwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEU6XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICAgICAgICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGh0bWxfYXN0XzEuSHRtbFRleHRBc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gY2hpbGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaHRtbF9hc3RfMS5odG1sVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcclxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICByZXR1cm4gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3I7XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlX25vcm1hbGl6ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgaHRtbF9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vaHRtbF9wYXJzZXInKTtcclxudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9hc3QnKTtcclxudmFyIHNlbGVjdG9yXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zZWxlY3RvcicpO1xyXG52YXIgZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NjaGVtYS9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeScpO1xyXG52YXIgdGVtcGxhdGVfcHJlcGFyc2VyXzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX3ByZXBhcnNlcicpO1xyXG52YXIgaHRtbF9hc3RfMSA9IHJlcXVpcmUoJy4vaHRtbF9hc3QnKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG4vLyBHcm91cCAxID0gXCJiaW5kLVwiXHJcbi8vIEdyb3VwIDIgPSBcInZhci1cIiBvciBcIiNcIlxyXG4vLyBHcm91cCAzID0gXCJvbi1cIlxyXG4vLyBHcm91cCA0ID0gXCJiaW5kb24tXCJcclxuLy8gR3JvdXAgNSA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJ2YXItLyNcIiwgb3IgXCJvbi1cIlxyXG4vLyBHcm91cCA2ID0gaWRlbml0aWZlciBpbnNpZGUgWygpXVxyXG4vLyBHcm91cCA3ID0gaWRlbml0aWZlciBpbnNpZGUgW11cclxuLy8gR3JvdXAgOCA9IGlkZW50aWZpZXIgaW5zaWRlICgpXHJcbnZhciBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooPzooPzooYmluZC0pfCh2YXItfCMpfChvbi0pfChiaW5kb24tKSkoLispKXxcXFtcXCgoW15cXCldKylcXClcXF18XFxbKFteXFxdXSspXFxdfFxcKChbXlxcKV0rKVxcKSkkL2c7XHJcbnZhciBURU1QTEFURV9FTEVNRU5UID0gJ3RlbXBsYXRlJztcclxudmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xyXG52YXIgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XHJcbnZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcclxudmFyIFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUiA9IG5ldyBSZWdFeHAoJ1xcXFwuJyk7XHJcbnZhciBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xyXG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcclxudmFyIFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XHJcbnZhciBURVhUX0NTU19TRUxFQ1RPUiA9IHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcclxudmFyIFRlbXBsYXRlUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VyKF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnksIF9odG1sUGFyc2VyKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xyXG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xyXG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcclxuICAgIH1cclxuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgc291cmNlSW5mbykge1xyXG4gICAgICAgIHZhciBwYXJzZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQYXJzZVZpc2l0b3IoZGlyZWN0aXZlcywgdGhpcy5fZXhwclBhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnkpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbChwYXJzZVZpc2l0b3IsIHRoaXMuX2h0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIHNvdXJjZUluZm8pLCBFTVBUWV9DT01QT05FTlQpO1xyXG4gICAgICAgIGlmIChwYXJzZVZpc2l0b3IuZXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gcGFyc2VWaXNpdG9yLmVycm9ycy5qb2luKCdcXG4nKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NoYW5nZV9kZXRlY3Rpb25fMS5QYXJzZXIsIGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBodG1sX3BhcnNlcl8xLkh0bWxQYXJzZXJdKVxyXG4gICAgXSwgVGVtcGxhdGVQYXJzZXIpO1xyXG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLlRlbXBsYXRlUGFyc2VyID0gVGVtcGxhdGVQYXJzZXI7XHJcbnZhciBUZW1wbGF0ZVBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlVmlzaXRvcihkaXJlY3RpdmVzLCBfZXhwclBhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XHJcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNJbmRleCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yTWF0Y2hlciA9IG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yTWF0Y2hlcigpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KGRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmUsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UoZGlyZWN0aXZlLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgX3RoaXMuc2VsZWN0b3JNYXRjaGVyLmFkZFNlbGVjdGFibGVzKHNlbGVjdG9yLCBkaXJlY3RpdmUpO1xyXG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuZXJyb3JzLnB1c2gobWVzc2FnZSk7IH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlKTsgLy8gc291cmNlSW5mbyBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgQVNUXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSk7IC8vIHNvdXJjZUluZm8gaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIEFTVFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSk7IC8vIHNvdXJjZUluZm8gaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIEFTVFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModmFsdWUsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSk7IC8vIHNvdXJjZUluZm8gaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIEFTVFxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBjb21wb25lbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKTtcclxuICAgICAgICB2YXIgZXhwciA9IHRoaXMuX3BhcnNlSW50ZXJwb2xhdGlvbihhc3QudmFsdWUsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleHByKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRlbXBsYXRlX2FzdF8xLkJvdW5kVGV4dEFzdChleHByLCBuZ0NvbnRlbnRJbmRleCwgYXN0LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5UZXh0QXN0KGFzdC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuQXR0ckFzdChhc3QubmFtZSwgYXN0LnZhbHVlLCBhc3Quc291cmNlSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubmFtZTtcclxuICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHRlbXBsYXRlX3ByZXBhcnNlcl8xLnByZXBhcnNlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcclxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxyXG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQpIHtcclxuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcclxuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoYWJsZUF0dHJzID0gW107XHJcbiAgICAgICAgdmFyIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XHJcbiAgICAgICAgdmFyIHZhcnMgPSBbXTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gW107XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVWYXJzID0gW107XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMgPSBbXTtcclxuICAgICAgICB2YXIgaGFzSW5saW5lVGVtcGxhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gW107XHJcbiAgICAgICAgZWxlbWVudC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XHJcbiAgICAgICAgICAgIG1hdGNoYWJsZUF0dHJzLnB1c2goW2F0dHIubmFtZSwgYXR0ci52YWx1ZV0pO1xyXG4gICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoYXR0ciwgbWF0Y2hhYmxlQXR0cnMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBldmVudHMsIHZhcnMpO1xyXG4gICAgICAgICAgICB2YXIgaGFzVGVtcGxhdGVCaW5kaW5nID0gX3RoaXMuX3BhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKGF0dHIsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlVmFycyk7XHJcbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxyXG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHIoYXR0ciwgbnVsbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGhhc0lubGluZVRlbXBsYXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBub2RlTmFtZSA9PSBURU1QTEFURV9FTEVNRU5UO1xyXG4gICAgICAgIHZhciBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3Iobm9kZU5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoZWxlbWVudC5uYW1lLCB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3RvciksIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBpc1RlbXBsYXRlRWxlbWVudCA/IFtdIDogdmFycywgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBkaXJlY3RpdmVzKTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IgOiB0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBDb21wb25lbnQuY3JlYXRlKGRpcmVjdGl2ZXMpKTtcclxuICAgICAgICB2YXIgZWxlbWVudE5nQ29udGVudEluZGV4ID0gaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IGNvbXBvbmVudC5maW5kTmdDb250ZW50SW5kZXgoZWxlbWVudENzc1NlbGVjdG9yKTtcclxuICAgICAgICB2YXIgcGFyc2VkRWxlbWVudDtcclxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPVxyXG4gICAgICAgICAgICAgICAgbmV3IHRlbXBsYXRlX2FzdF8xLk5nQ29udGVudEFzdCh0aGlzLm5nQ29udGVudENvdW50KyssIGVsZW1lbnROZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZShkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIGV2ZW50cywgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyB0ZW1wbGF0ZV9hc3RfMS5FbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCB2YXJzLCBkaXJlY3RpdmVzLCBjaGlsZHJlbiwgZWxlbWVudE5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0T25seU9uZUNvbXBvbmVudChkaXJlY3RpdmVzLCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudEV4cG9ydEFzVmFycyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWx0ZXIodmFycywgZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0LnZhbHVlLmxlbmd0aCA9PT0gMDsgfSk7XHJcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPVxyXG4gICAgICAgICAgICAgICAgbmV3IHRlbXBsYXRlX2FzdF8xLkVsZW1lbnRBc3Qobm9kZU5hbWUsIGF0dHJzLCBlbGVtZW50UHJvcHMsIGV2ZW50cywgZWxlbWVudEV4cG9ydEFzVmFycywgZGlyZWN0aXZlcywgY2hpbGRyZW4sIGVsZW1lbnROZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihURU1QTEFURV9FTEVNRU5ULCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzKTtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlcyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoZWxlbWVudC5uYW1lLCB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIHRlbXBsYXRlQ3NzU2VsZWN0b3IpLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBbXSwgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUodGVtcGxhdGVEaXJlY3RpdmVzLCB0ZW1wbGF0ZUVsZW1lbnRQcm9wcywgW10sIGVsZW1lbnQuc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgdGVtcGxhdGVfYXN0XzEuRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgdGVtcGxhdGVWYXJzLCB0ZW1wbGF0ZURpcmVjdGl2ZXMsIFtwYXJzZWRFbGVtZW50XSwgY29tcG9uZW50LmZpbmROZ0NvbnRlbnRJbmRleCh0ZW1wbGF0ZUNzc1NlbGVjdG9yKSwgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZEVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGF0dHIubmFtZSA9PSBURU1QTEFURV9BVFRSKSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKGF0dHIubmFtZSwgVEVNUExBVEVfQVRUUl9QUkVGSVgpKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5zdWJzdHJpbmcoYXR0ci5uYW1lLCBURU1QTEFURV9BVFRSX1BSRUZJWC5sZW5ndGgpOyAvLyByZW1vdmUgdGhlIHN0YXJcclxuICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IChhdHRyLnZhbHVlLmxlbmd0aCA9PSAwKSA/IGtleSA6IGtleSArICcgJyArIGF0dHIudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRlbXBsYXRlQmluZGluZ3NTb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhc2hDYXNlS2V5ID0gdXRpbF8xLmNhbWVsQ2FzZVRvRGFzaENhc2UoYmluZGluZy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcua2V5SXNWYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLlZhcmlhYmxlQXN0KHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKGJpbmRpbmcua2V5KSwgYmluZGluZy5uYW1lLCBhdHRyLnNvdXJjZUluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtkYXNoQ2FzZUtleSwgYmluZGluZy5uYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGRhc2hDYXNlS2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2Rhc2hDYXNlS2V5LCAnJ10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUF0dHIgPSBmdW5jdGlvbiAoYXR0ciwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRFdmVudHMsIHRhcmdldFZhcnMpIHtcclxuICAgICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSk7XHJcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XHJcbiAgICAgICAgdmFyIGJpbmRQYXJ0cyA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goQklORF9OQU1FX1JFR0VYUCwgYXR0ck5hbWUpO1xyXG4gICAgICAgIHZhciBoYXNCaW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzKSkge1xyXG4gICAgICAgICAgICBoYXNCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eShiaW5kUGFydHNbNV0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbNV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVZhcmlhYmxlKGlkZW50aWZpZXIsIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0VmFycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbM10pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50KGJpbmRQYXJ0c1s1XSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzRdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eShiaW5kUGFydHNbNV0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzWzVdLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbNl0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5KGJpbmRQYXJ0c1s2XSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbNl0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRQYXJ0c1s3XSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHkoYmluZFBhcnRzWzddLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRQYXJ0c1s4XSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXZlbnQoYmluZFBhcnRzWzhdLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGFzQmluZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJzZUxpdGVyYWxBdHRyKGF0dHJOYW1lLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aChhdHRyTmFtZSwgJ2RhdGEtJykgPyBsYW5nXzEuU3RyaW5nV3JhcHBlci5zdWJzdHJpbmcoYXR0ck5hbWUsIDUpIDpcclxuICAgICAgICAgICAgYXR0ck5hbWU7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0VmFycykge1xyXG4gICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgdGVtcGxhdGVfYXN0XzEuVmFyaWFibGVBc3QodXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UoaWRlbnRpZmllciksIHZhbHVlLCBzb3VyY2VJbmZvKSk7XHJcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbaWRlbnRpZmllciwgdmFsdWVdKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgc291cmNlSW5mbyksIHNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XHJcbiAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4cHIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHlBc3QgPSBmdW5jdGlvbiAobmFtZSwgYXN0LCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcclxuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XHJcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eShuYW1lLCBhc3QsIGZhbHNlLCBzb3VyY2VJbmZvKSk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFzc2lnbm1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lICsgXCItY2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcclxuICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IHV0aWxfMS5zcGxpdEF0Q29sb24obmFtZSwgW251bGwsIG5hbWVdKTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gcGFydHNbMF07XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHBhcnRzWzFdO1xyXG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyB0ZW1wbGF0ZV9hc3RfMS5Cb3VuZEV2ZW50QXN0KHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKGV2ZW50TmFtZSksIHRhcmdldCwgdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlSW5mbyksIHNvdXJjZUluZm8pKTtcclxuICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcclxuICAgICAgICAvLyBzbyBkb24ndCBhZGQgdGhlIGV2ZW50IG5hbWUgdG8gdGhlIG1hdGNoYWJsZUF0dHJzXHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUxpdGVyYWxBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvLCB0YXJnZXRQcm9wcykge1xyXG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHkodXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UobmFtZSksIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsIHNvdXJjZUluZm8pLCB0cnVlLCBzb3VyY2VJbmZvKSk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gW107XHJcbiAgICAgICAgc2VsZWN0b3JNYXRjaGVyLm1hdGNoKGVsZW1lbnRDc3NTZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBkaXJlY3RpdmUpIHsgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7IH0pO1xyXG4gICAgICAgIC8vIE5lZWQgdG8gc29ydCB0aGUgZGlyZWN0aXZlcyBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgdGhyb3VnaG91dCxcclxuICAgICAgICAvLyBhcyBzZWxlY3Rvck1hdGNoZXIgdXNlcyBNYXBzIGluc2lkZS5cclxuICAgICAgICAvLyBBbHNvIG5lZWQgdG8gbWFrZSBjb21wb25lbnRzIHRoZSBmaXJzdCBkaXJlY3RpdmUgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNvcnQoZGlyZWN0aXZlcywgZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHtcclxuICAgICAgICAgICAgdmFyIGRpcjFDb21wID0gZGlyMS5pc0NvbXBvbmVudDtcclxuICAgICAgICAgICAgdmFyIGRpcjJDb21wID0gZGlyMi5pc0NvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGRpcjFDb21wICYmICFkaXIyQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaXIxQ29tcCAmJiBkaXIyQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXIxKSAtIF90aGlzLmRpcmVjdGl2ZXNJbmRleC5nZXQoZGlyMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcztcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGRpcmVjdGl2ZXMsIHByb3BzLCBwb3NzaWJsZUV4cG9ydEFzVmFycywgc291cmNlSW5mbykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG1hdGNoZWRWYXJpYWJsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBob3N0UHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaG9zdEV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlUHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyhlbGVtZW50TmFtZSwgZGlyZWN0aXZlLmhvc3RQcm9wZXJ0aWVzLCBzb3VyY2VJbmZvLCBob3N0UHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzKGRpcmVjdGl2ZS5ob3N0TGlzdGVuZXJzLCBzb3VyY2VJbmZvLCBob3N0RXZlbnRzKTtcclxuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIHZhciBleHBvcnRBc1ZhcnMgPSBbXTtcclxuICAgICAgICAgICAgcG9zc2libGVFeHBvcnRBc1ZhcnMuZm9yRWFjaChmdW5jdGlvbiAodmFyQXN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZhckFzdC52YWx1ZS5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUuZXhwb3J0QXMgPT0gdmFyQXN0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzVmFycy5wdXNoKHZhckFzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZhcmlhYmxlcy5hZGQodmFyQXN0Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5EaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgZXhwb3J0QXNWYXJzLCBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwb3NzaWJsZUV4cG9ydEFzVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJBc3QpIHtcclxuICAgICAgICAgICAgaWYgKHZhckFzdC52YWx1ZS5sZW5ndGggPiAwICYmICFjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMobWF0Y2hlZFZhcmlhYmxlcywgdmFyQXN0Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGVyZSBpcyBubyBkaXJlY3RpdmUgd2l0aCBcXFwiZXhwb3J0QXNcXFwiIHNldCB0byBcXFwiXCIgKyB2YXJBc3QudmFsdWUgKyBcIlxcXCIgYXQgXCIgKyB2YXJBc3Quc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXN0cztcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGhvc3RQcm9wcywgc291cmNlSW5mbywgdGFyZ2V0UHJvcGVydHlBc3RzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob3N0UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goaG9zdFByb3BzLCBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgcHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHByQXN0ID0gX3RoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldFByb3BlcnR5QXN0cy5wdXNoKF90aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudE5hbWUsIHByb3BOYW1lLCBleHByQXN0LCBzb3VyY2VJbmZvKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMgPSBmdW5jdGlvbiAoaG9zdExpc3RlbmVycywgc291cmNlSW5mbywgdGFyZ2V0RXZlbnRBc3RzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob3N0TGlzdGVuZXJzKSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGhvc3RMaXN0ZW5lcnMsIGZ1bmN0aW9uIChleHByZXNzaW9uLCBwcm9wTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BhcnNlRXZlbnQocHJvcE5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZUluZm8sIFtdLCB0YXJnZXRFdmVudEFzdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZVByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZFByb3BzQnlOYW1lID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBib3VuZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKGJvdW5kUHJvcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBib3VuZFByb3BzQnlOYW1lLmdldChib3VuZFByb3AubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocHJldlZhbHVlKSB8fCBwcmV2VmFsdWUuaXNMaXRlcmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSBbYV09XCJiXCIgYSBoaWdoZXIgcHJlY2VkZW5jZSB0aGF0biBhPVwiYlwiIG9uIHRoZSBzYW1lIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFByb3BzQnlOYW1lLnNldChrZXksIGJvdW5kUHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGRpcmVjdGl2ZVByb3BlcnRpZXMsIGZ1bmN0aW9uIChlbFByb3AsIGRpclByb3ApIHtcclxuICAgICAgICAgICAgICAgIGVsUHJvcCA9IHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKGVsUHJvcCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRQcm9wID0gYm91bmRQcm9wc0J5TmFtZS5nZXQoZWxQcm9wKTtcclxuICAgICAgICAgICAgICAgIC8vIEJpbmRpbmdzIGFyZSBvcHRpb25hbCwgc28gdGhpcyBiaW5kaW5nIG9ubHkgbmVlZHMgdG8gYmUgc2V0IHVwIGlmIGFuIGV4cHJlc3Npb24gaXMgZ2l2ZW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChib3VuZFByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcy5wdXNoKG5ldyB0ZW1wbGF0ZV9hc3RfMS5Cb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpclByb3AsIGJvdW5kUHJvcC5uYW1lLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgYm91bmRQcm9wLnNvdXJjZUluZm8pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcHMsIGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRQcm9wcyA9IFtdO1xyXG4gICAgICAgIHZhciBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXggPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguc2V0KHByb3AudGVtcGxhdGVOYW1lLCBwcm9wKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICBpZiAoIXByb3AuaXNMaXRlcmFsICYmIGxhbmdfMS5pc0JsYW5rKGJvdW5kRGlyZWN0aXZlUHJvcHNJbmRleC5nZXQocHJvcC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudFByb3BzLnB1c2goX3RoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcC5uYW1lLCBwcm9wLmV4cHJlc3Npb24sIHByb3Auc291cmNlSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kRWxlbWVudFByb3BzO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0ID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBuYW1lLCBhc3QsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB2YXIgdW5pdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGJpbmRpbmdUeXBlO1xyXG4gICAgICAgIHZhciBib3VuZFByb3BlcnR5TmFtZTtcclxuICAgICAgICB2YXIgcGFydHMgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5zcGxpdChuYW1lLCBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZSh1dGlsXzEuZGFzaENhc2VUb0NhbWVsQ2FzZShwYXJ0c1swXSkpO1xyXG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJDYW4ndCBiaW5kIHRvICdcIiArIGJvdW5kUHJvcGVydHlOYW1lICsgXCInIHNpbmNlIGl0IGlzbid0IGEga25vd24gbmF0aXZlIHByb3BlcnR5IGluIFwiICsgc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xyXG4gICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKHBhcnRzWzFdKTtcclxuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gQ0xBU1NfUFJFRklYKSB7XHJcbiAgICAgICAgICAgIC8vIGtlZXAgb3JpZ2luYWwgY2FzZSFcclxuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBTVFlMRV9QUkVGSVgpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6IG51bGw7XHJcbiAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gdXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UocGFydHNbMV0pO1xyXG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkludmFsaWQgcHJvcGVydHkgbmFtZSBcIiArIG5hbWUgKyBcIiBpbiBcIiArIHNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuQm91bmRFbGVtZW50UHJvcGVydHlBc3QoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBhc3QsIHVuaXQsIHNvdXJjZUluZm8pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gW107XHJcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlTmFtZXMucHVzaCh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50VHlwZU5hbWVzO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0T25seU9uZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcclxuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJNb3JlIHRoYW4gb25lIGNvbXBvbmVudDogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpICsgXCIgaW4gXCIgKyBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkNvbXBvbmVudHMgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGU6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSArIFwiIGluIFwiICsgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlByb3BlcnR5IGJpbmRpbmcgXCIgKyBwcm9wLm5hbWUgKyBcIiBub3QgdXNlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlIGluIFwiICsgcHJvcC5zb3VyY2VJbmZvKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50Lm5hbWUgKyBcIiBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZSBpbiBcIiArIGV2ZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlVmlzaXRvcjtcclxufSkoKTtcclxudmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gdGVtcGxhdGVfcHJlcGFyc2VyXzEucHJlcGFyc2VFbGVtZW50KGFzdCk7XHJcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XHJcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgfHxcclxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XHJcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXHJcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYW5kIHN0eWxlc2hlZXRzIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cclxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIFthdHRyQXN0Lm5hbWUsIGF0dHJBc3QudmFsdWVdOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBjb21wb25lbnQuZmluZE5nQ29udGVudEluZGV4KHNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0NPTVBPTkVOVCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5FbGVtZW50QXN0KGFzdC5uYW1lLCBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuYXR0cnMpLCBbXSwgW10sIFtdLCBbXSwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5BdHRyQXN0KGFzdC5uYW1lLCBhc3QudmFsdWUsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgIH07XHJcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IGNvbXBvbmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xyXG4gICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuVGV4dEFzdChhc3QudmFsdWUsIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vbkJpbmRhYmxlVmlzaXRvcjtcclxufSkoKTtcclxudmFyIEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eShuYW1lLCBleHByZXNzaW9uLCBpc0xpdGVyYWwsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICAgICAgdGhpcy5pc0xpdGVyYWwgPSBpc0xpdGVyYWw7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIHJldHVybiBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5O1xyXG59KSgpO1xyXG52YXIgUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKG1lc3NhZ2UsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGFyc2VFcnJvcjtcclxufSkoKTtcclxuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQoY2xhc3NBdHRyVmFsdWUudHJpbSgpLCAvXFxzKy9nKTtcclxufVxyXG5leHBvcnRzLnNwbGl0Q2xhc3NlcyA9IHNwbGl0Q2xhc3NlcztcclxudmFyIENvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnQobmdDb250ZW50SW5kZXhNYXRjaGVyLCB3aWxkY2FyZE5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBuZ0NvbnRlbnRJbmRleE1hdGNoZXI7XHJcbiAgICAgICAgdGhpcy53aWxkY2FyZE5nQ29udGVudEluZGV4ID0gd2lsZGNhcmROZ0NvbnRlbnRJbmRleDtcclxuICAgIH1cclxuICAgIENvbXBvbmVudC5jcmVhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCB8fCAhZGlyZWN0aXZlc1swXS5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0NPTVBPTkVOVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgc2VsZWN0b3JfMS5TZWxlY3Rvck1hdGNoZXIoKTtcclxuICAgICAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gZGlyZWN0aXZlc1swXS5kaXJlY3RpdmUudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzO1xyXG4gICAgICAgIHZhciB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBuZ0NvbnRlbnRTZWxlY3RvcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoc2VsZWN0b3IsICcqJykpIHtcclxuICAgICAgICAgICAgICAgIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhzZWxlY3Rvcl8xLkNzc1NlbGVjdG9yLnBhcnNlKG5nQ29udGVudFNlbGVjdG9yc1tpXSksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KG1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGljZXMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLndpbGRjYXJkTmdDb250ZW50SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIG5nQ29udGVudEluZGljZXMucHVzaCh0aGlzLndpbGRjYXJkTmdDb250ZW50SW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc29ydChuZ0NvbnRlbnRJbmRpY2VzKTtcclxuICAgICAgICByZXR1cm4gbmdDb250ZW50SW5kaWNlcy5sZW5ndGggPiAwID8gbmdDb250ZW50SW5kaWNlc1swXSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudDtcclxufSkoKTtcclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBtYXRjaGFibGVBdHRycykge1xyXG4gICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IoKTtcclxuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxlbWVudE5hbWUpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGFibGVBdHRycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBhdHRyTmFtZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzBdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzFdO1xyXG4gICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcclxuICAgICAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUikge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xyXG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjc3NTZWxlY3RvcjtcclxufVxyXG52YXIgRU1QVFlfQ09NUE9ORU5UID0gbmV3IENvbXBvbmVudChuZXcgc2VsZWN0b3JfMS5TZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCk7XHJcbnZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVfcGFyc2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0JztcclxudmFyIE5HX0NPTlRFTlRfRUxFTUVOVCA9ICduZy1jb250ZW50JztcclxudmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcclxudmFyIExJTktfU1RZTEVfUkVMX0FUVFIgPSAncmVsJztcclxudmFyIExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xyXG52YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XHJcbnZhciBTVFlMRV9FTEVNRU5UID0gJ3N0eWxlJztcclxudmFyIFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XHJcbnZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZy1ub24tYmluZGFibGUnO1xyXG5mdW5jdGlvbiBwcmVwYXJzZUVsZW1lbnQoYXN0KSB7XHJcbiAgICB2YXIgc2VsZWN0QXR0ciA9IG51bGw7XHJcbiAgICB2YXIgaHJlZkF0dHIgPSBudWxsO1xyXG4gICAgdmFyIHJlbEF0dHIgPSBudWxsO1xyXG4gICAgdmFyIG5vbkJpbmRhYmxlID0gZmFsc2U7XHJcbiAgICBhc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xyXG4gICAgICAgIGlmIChhdHRyLm5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUikge1xyXG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XHJcbiAgICAgICAgICAgIGhyZWZBdHRyID0gYXR0ci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcclxuICAgICAgICAgICAgcmVsQXR0ciA9IGF0dHIudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xyXG4gICAgICAgICAgICBub25CaW5kYWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xyXG4gICAgdmFyIG5vZGVOYW1lID0gYXN0Lm5hbWU7XHJcbiAgICB2YXIgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xyXG4gICAgaWYgKG5vZGVOYW1lID09IE5HX0NPTlRFTlRfRUxFTUVOVCkge1xyXG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU1RZTEVfRUxFTUVOVCkge1xyXG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNDUklQVF9FTEVNRU5UKSB7XHJcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IExJTktfRUxFTUVOVCAmJiByZWxBdHRyID09IExJTktfU1RZTEVfUkVMX1ZBTFVFKSB7XHJcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlKTtcclxufVxyXG5leHBvcnRzLnByZXBhcnNlRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudDtcclxuKGZ1bmN0aW9uIChQcmVwYXJzZWRFbGVtZW50VHlwZSkge1xyXG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJOR19DT05URU5UXCJdID0gMF0gPSBcIk5HX0NPTlRFTlRcIjtcclxuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVcIl0gPSAxXSA9IFwiU1RZTEVcIjtcclxuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVTSEVFVFwiXSA9IDJdID0gXCJTVFlMRVNIRUVUXCI7XHJcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNDUklQVFwiXSA9IDNdID0gXCJTQ1JJUFRcIjtcclxuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiT1RIRVJcIl0gPSA0XSA9IFwiT1RIRVJcIjtcclxufSkoZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50VHlwZSB8fCAoZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XHJcbnZhciBQcmVwYXJzZWRFbGVtZW50VHlwZSA9IGV4cG9ydHMuUHJlcGFyc2VkRWxlbWVudFR5cGU7XHJcbnZhciBQcmVwYXJzZWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xyXG4gICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcclxuICAgICAgICB0aGlzLm5vbkJpbmRhYmxlID0gbm9uQmluZGFibGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJlcGFyc2VkRWxlbWVudDtcclxufSkoKTtcclxuZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50ID0gUHJlcGFyc2VkRWxlbWVudDtcclxuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhzZWxlY3RBdHRyKSB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAnKic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VsZWN0QXR0cjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9wcmVwYXJzZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBVc2VkIGJ5IHRoZSB7QGxpbmsgQ29tcGlsZXJ9IHdoZW4gcmVzb2x2aW5nIEhUTUwgYW5kIENTUyB0ZW1wbGF0ZSBVUkxzLlxyXG4gKlxyXG4gKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XHJcbiAqL1xyXG52YXIgVXJsUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXJsUmVzb2x2ZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxyXG4gICAgICogLSB3aGVuIHRoZSBgdXJsYCBpcyBudWxsLCB0aGUgYGJhc2VVcmxgIGlzIHJldHVybmVkLFxyXG4gICAgICogLSBpZiBgdXJsYCBpcyByZWxhdGl2ZSAoJ3BhdGgvdG8vaGVyZScsICcuL3BhdGgvdG8vaGVyZScpLCB0aGUgcmVzb2x2ZWQgdXJsIGlzIGEgY29tYmluYXRpb24gb2ZcclxuICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXHJcbiAgICAgKiAtIGlmIGB1cmxgIGlzIGFic29sdXRlIChpdCBoYXMgYSBzY2hlbWU6ICdodHRwOi8vJywgJ2h0dHBzOi8vJyBvciBzdGFydCB3aXRoICcvJyksIHRoZSBgdXJsYCBpc1xyXG4gICAgICogcmV0dXJuZWQgYXMgaXMgKGlnbm9yaW5nIHRoZSBgYmFzZVVybGApXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSByZXNvbHZlZCBVUkxcclxuICAgICAqL1xyXG4gICAgVXJsUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7IHJldHVybiBfcmVzb2x2ZVVybChiYXNlVXJsLCB1cmwpOyB9O1xyXG4gICAgVXJsUmVzb2x2ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFVybFJlc29sdmVyKTtcclxuICAgIHJldHVybiBVcmxSZXNvbHZlcjtcclxufSkoKTtcclxuZXhwb3J0cy5VcmxSZXNvbHZlciA9IFVybFJlc29sdmVyO1xyXG4vLyBUaGUgY29kZSBiZWxvdyBpcyBhZGFwdGVkIGZyb20gVHJhY2V1cjpcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90cmFjZXVyLWNvbXBpbGVyL2Jsb2IvOTUxMWMxZGFmYTk3MmJmMGRlMTIwMmE4YTg2M2JhZDAyZjBmOTVhOC9zcmMvcnVudGltZS91cmwuanNcclxuLyoqXHJcbiAqIEJ1aWxkcyBhIFVSSSBzdHJpbmcgZnJvbSBhbHJlYWR5LWVuY29kZWQgcGFydHMuXHJcbiAqXHJcbiAqIE5vIGVuY29kaW5nIGlzIHBlcmZvcm1lZC4gIEFueSBjb21wb25lbnQgbWF5IGJlIG9taXR0ZWQgYXMgZWl0aGVyIG51bGwgb3JcclxuICogdW5kZWZpbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfc2NoZW1lIFRoZSBzY2hlbWUgc3VjaCBhcyAnaHR0cCcuXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ0AnLlxyXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XHJcbiAqICAgICBVUkktZW5jb2RlZC5cclxuICogQHBhcmFtIHsoc3RyaW5nfG51bGwpPX0gb3B0X3BvcnQgVGhlIHBvcnQgbnVtYmVyLlxyXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxyXG4gKiAgICAgZW1wdHksIGl0IG11c3QgYmVnaW4gd2l0aCBhIHNsYXNoLlxyXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfcXVlcnlEYXRhIFRoZSBVUkktZW5jb2RlZCBxdWVyeSBkYXRhLlxyXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZ1bGx5IGNvbWJpbmVkIFVSSS5cclxuICovXHJcbmZ1bmN0aW9uIF9idWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xyXG4gICAgdmFyIG91dCA9IFtdO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X3NjaGVtZSkpIHtcclxuICAgICAgICBvdXQucHVzaChvcHRfc2NoZW1lICsgJzonKTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9kb21haW4pKSB7XHJcbiAgICAgICAgb3V0LnB1c2goJy8vJyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X3VzZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8gKyAnQCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXQucHVzaChvcHRfZG9tYWluKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfcG9ydCkpIHtcclxuICAgICAgICAgICAgb3V0LnB1c2goJzonICsgb3B0X3BvcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9wYXRoKSkge1xyXG4gICAgICAgIG91dC5wdXNoKG9wdF9wYXRoKTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9xdWVyeURhdGEpKSB7XHJcbiAgICAgICAgb3V0LnB1c2goJz8nICsgb3B0X3F1ZXJ5RGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfZnJhZ21lbnQpKSB7XHJcbiAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQuam9pbignJyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXHJcbiAqXHJcbiAqIHtAbGluayBodHRwOi8vd3d3LmdiaXYuY29tL3Byb3RvY29scy91cmkvcmZjL3JmYzM5ODYuaHRtbCNSRkMyMjM0fSBzYXlzXHJcbiAqIEFzIHRoZSBcImZpcnN0LW1hdGNoLXdpbnNcIiBhbGdvcml0aG0gaXMgaWRlbnRpY2FsIHRvIHRoZSBcImdyZWVkeVwiXHJcbiAqIGRpc2FtYmlndWF0aW9uIG1ldGhvZCB1c2VkIGJ5IFBPU0lYIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGl0IGlzIG5hdHVyYWwgYW5kXHJcbiAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcclxuICogY29tcG9uZW50cyBvZiBhIFVSSSByZWZlcmVuY2UuXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcclxuICogd2VsbC1mb3JtZWQgVVJJIHJlZmVyZW5jZSBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/XHJcbiAqICAxMiAgICAgICAgICAgIDMgIDQgICAgICAgICAgNSAgICAgICA2ICA3ICAgICAgICA4IDlcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoZSBudW1iZXJzIGluIHRoZSBzZWNvbmQgbGluZSBhYm92ZSBhcmUgb25seSB0byBhc3Npc3QgcmVhZGFiaWxpdHk7IHRoZXlcclxuICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcclxuICogcGFyZW50aGVzaXMpLiBXZSByZWZlciB0byB0aGUgdmFsdWUgbWF0Y2hlZCBmb3Igc3ViZXhwcmVzc2lvbiA8bj4gYXMgJDxuPi5cclxuICogRm9yIGV4YW1wbGUsIG1hdGNoaW5nIHRoZSBhYm92ZSBleHByZXNzaW9uIHRvXHJcbiAqIDxwcmU+XHJcbiAqICAgICBodHRwOi8vd3d3Lmljcy51Y2kuZWR1L3B1Yi9pZXRmL3VyaS8jUmVsYXRlZFxyXG4gKiA8L3ByZT5cclxuICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcclxuICogPHByZT5cclxuICogICAgJDEgPSBodHRwOlxyXG4gKiAgICAkMiA9IGh0dHBcclxuICogICAgJDMgPSAvL3d3dy5pY3MudWNpLmVkdVxyXG4gKiAgICAkNCA9IHd3dy5pY3MudWNpLmVkdVxyXG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXHJcbiAqICAgICQ2ID0gPHVuZGVmaW5lZD5cclxuICogICAgJDcgPSA8dW5kZWZpbmVkPlxyXG4gKiAgICAkOCA9ICNSZWxhdGVkXHJcbiAqICAgICQ5ID0gUmVsYXRlZFxyXG4gKiA8L3ByZT5cclxuICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXHJcbiAqIGNhc2UgZm9yIHRoZSBxdWVyeSBjb21wb25lbnQgaW4gdGhlIGFib3ZlIGV4YW1wbGUuIFRoZXJlZm9yZSwgd2UgY2FuXHJcbiAqIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGZpdmUgY29tcG9uZW50cyBhc1xyXG4gKiA8cHJlPlxyXG4gKiAgICBzY2hlbWUgICAgPSAkMlxyXG4gKiAgICBhdXRob3JpdHkgPSAkNFxyXG4gKiAgICBwYXRoICAgICAgPSAkNVxyXG4gKiAgICBxdWVyeSAgICAgPSAkN1xyXG4gKiAgICBmcmFnbWVudCAgPSAkOVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgYmVlbiBtb2RpZmllZCBzbGlnaHRseSB0byBleHBvc2UgdGhlXHJcbiAqIHVzZXJJbmZvLCBkb21haW4sIGFuZCBwb3J0IHNlcGFyYXRlbHkgZnJvbSB0aGUgYXV0aG9yaXR5LlxyXG4gKiBUaGUgbW9kaWZpZWQgdmVyc2lvbiB5aWVsZHNcclxuICogPHByZT5cclxuICogICAgJDEgPSBodHRwICAgICAgICAgICAgICBzY2hlbWVcclxuICogICAgJDIgPSA8dW5kZWZpbmVkPiAgICAgICB1c2VySW5mbyAtXFxcclxuICogICAgJDMgPSB3d3cuaWNzLnVjaS5lZHUgICBkb21haW4gICAgIHwgYXV0aG9yaXR5XHJcbiAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgLS9cclxuICogICAgJDUgPSAvcHViL2lldGYvdXJpLyAgICBwYXRoXHJcbiAqICAgICQ2ID0gPHVuZGVmaW5lZD4gICAgICAgcXVlcnkgd2l0aG91dCA/XHJcbiAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXHJcbiAqIDwvcHJlPlxyXG4gKiBAdHlwZSB7IVJlZ0V4cH1cclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgX3NwbGl0UmUgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJ14nICtcclxuICAgICcoPzonICtcclxuICAgICcoW146Lz8jLl0rKScgK1xyXG4gICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxyXG4gICAgLy8gPywgLywgIywgYW5kIC5cclxuICAgICc6KT8nICtcclxuICAgICcoPzovLycgK1xyXG4gICAgJyg/OihbXi8/I10qKUApPycgK1xyXG4gICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArXHJcbiAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxyXG4gICAgLy8gZXNjYXBlcywgYW5kIHVuaWNvZGUgY2hhcmFjdGVycy5cclxuICAgICcoPzo6KFswLTldKykpPycgK1xyXG4gICAgJyk/JyArXHJcbiAgICAnKFtePyNdKyk/JyArXHJcbiAgICAnKD86XFxcXD8oW14jXSopKT8nICtcclxuICAgICcoPzojKC4qKSk/JyArXHJcbiAgICAnJCcpO1xyXG4vKipcclxuICogVGhlIGluZGV4IG9mIGVhY2ggVVJJIGNvbXBvbmVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIG9mIGdvb2cudXJpLnV0aWxzLnNwbGl0LlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxudmFyIF9Db21wb25lbnRJbmRleDtcclxuKGZ1bmN0aW9uIChfQ29tcG9uZW50SW5kZXgpIHtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJTY2hlbWVcIl0gPSAxXSA9IFwiU2NoZW1lXCI7XHJcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiVXNlckluZm9cIl0gPSAyXSA9IFwiVXNlckluZm9cIjtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJEb21haW5cIl0gPSAzXSA9IFwiRG9tYWluXCI7XHJcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUG9ydFwiXSA9IDRdID0gXCJQb3J0XCI7XHJcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUGF0aFwiXSA9IDVdID0gXCJQYXRoXCI7XHJcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUXVlcnlEYXRhXCJdID0gNl0gPSBcIlF1ZXJ5RGF0YVwiO1xyXG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkZyYWdtZW50XCJdID0gN10gPSBcIkZyYWdtZW50XCI7XHJcbn0pKF9Db21wb25lbnRJbmRleCB8fCAoX0NvbXBvbmVudEluZGV4ID0ge30pKTtcclxuLyoqXHJcbiAqIFNwbGl0cyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXHJcbiAqXHJcbiAqIEVhY2ggY29tcG9uZW50IGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIGNvbXBvbmVudCBpbmRpY2VzOyBmb3IgZXhhbXBsZTpcclxuICogPHByZT5cclxuICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSBUaGUgVVJJIHN0cmluZyB0byBleGFtaW5lLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZ3x1bmRlZmluZWQ+fSBFYWNoIGNvbXBvbmVudCBzdGlsbCBVUkktZW5jb2RlZC5cclxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcclxuICogICAgIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHByZXNlbnQgd2lsbCBiZSB1bmRlZmluZWQgb3IgZW1wdHksIGRlcGVuZGluZ1xyXG4gKiAgICAgb24gdGhlIGJyb3dzZXIncyByZWd1bGFyIGV4cHJlc3Npb24gaW1wbGVtZW50YXRpb24uICBOZXZlciBudWxsLCBzaW5jZVxyXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gX3NwbGl0KHVyaSkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX3NwbGl0UmUsIHVyaSk7XHJcbn1cclxuLyoqXHJcbiAgKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXHJcbiAgKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cclxuICAqIEByZXR1cm4ge3N0cmluZ30gUGF0aCBjb21wb25lbnQgd2l0aCByZW1vdmVkIGRvdCBzZWdtZW50cy5cclxuICAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xyXG4gICAgaWYgKHBhdGggPT0gJy8nKVxyXG4gICAgICAgIHJldHVybiAnLyc7XHJcbiAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PSAnLycgPyAnLycgOiAnJztcclxuICAgIHZhciB0cmFpbGluZ1NsYXNoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnLycgOiAnJztcclxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIHZhciB1cCA9IDA7XHJcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBzZWdtZW50cy5sZW5ndGg7IHBvcysrKSB7XHJcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1twb3NdO1xyXG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xyXG4gICAgICAgICAgICBjYXNlICcnOlxyXG4gICAgICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcuLic6XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1cCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChzZWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVhZGluZ1NsYXNoID09ICcnKSB7XHJcbiAgICAgICAgd2hpbGUgKHVwLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIG91dC51bnNoaWZ0KCcuLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgb3V0LnB1c2goJy4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWFkaW5nU2xhc2ggKyBvdXQuam9pbignLycpICsgdHJhaWxpbmdTbGFzaDtcclxufVxyXG4vKipcclxuICogVGFrZXMgYW4gYXJyYXkgb2YgdGhlIHBhcnRzIGZyb20gc3BsaXQgYW5kIGNhbm9uaWNhbGl6ZXMgdGhlIHBhdGggcGFydFxyXG4gKiBhbmQgdGhlbiBqb2lucyBhbGwgdGhlIHBhcnRzLlxyXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc/Pn0gcGFydHNcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XHJcbiAgICB2YXIgcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcclxuICAgIHBhdGggPSBsYW5nXzEuaXNCbGFuayhwYXRoKSA/ICcnIDogX3JlbW92ZURvdFNlZ21lbnRzKHBhdGgpO1xyXG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcclxuICAgIHJldHVybiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguVXNlckluZm9dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRG9tYWluXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlBvcnRdLCBwYXRoLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmVzIGEgVVJMLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0byBUaGUgVVJMIHRvIHJlc29sdmUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIF9yZXNvbHZlVXJsKGJhc2UsIHVybCkge1xyXG4gICAgdmFyIHBhcnRzID0gX3NwbGl0KGVuY29kZVVSSSh1cmwpKTtcclxuICAgIHZhciBiYXNlUGFydHMgPSBfc3BsaXQoYmFzZSk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkpIHtcclxuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IF9Db21wb25lbnRJbmRleC5TY2hlbWU7IGkgPD0gX0NvbXBvbmVudEluZGV4LlBvcnQ7IGkrKykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJ0c1tpXSkpIHtcclxuICAgICAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXVswXSA9PSAnLycpIHtcclxuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcclxuICAgIH1cclxuICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXRoKSlcclxuICAgICAgICBwYXRoID0gJy8nO1xyXG4gICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xyXG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSkgKyBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XHJcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xyXG4gICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsX3Jlc29sdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcclxudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLShbYS16XSkvZztcclxudmFyIFNJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFID0gLyd8XFxcXHxcXG58XFwkL2c7XHJcbnZhciBET1VCTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC9cInxcXFxcfFxcbnxcXCQvZztcclxuZXhwb3J0cy5JU19EQVJUID0gIWxhbmdfMS5pc0pzT2JqZWN0KHt9KTtcclxuZXhwb3J0cy5NT0RVTEVfU1VGRklYID0gZXhwb3J0cy5JU19EQVJUID8gJy5kYXJ0JyA6ICcuanMnO1xyXG5mdW5jdGlvbiBjYW1lbENhc2VUb0Rhc2hDYXNlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgQ0FNRUxfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uIChtKSB7IHJldHVybiAnLScgKyBtWzFdLnRvTG93ZXJDYXNlKCk7IH0pO1xyXG59XHJcbmV4cG9ydHMuY2FtZWxDYXNlVG9EYXNoQ2FzZSA9IGNhbWVsQ2FzZVRvRGFzaENhc2U7XHJcbmZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpOyB9KTtcclxufVxyXG5leHBvcnRzLmRhc2hDYXNlVG9DYW1lbENhc2UgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlO1xyXG5mdW5jdGlvbiBlc2NhcGVTaW5nbGVRdW90ZVN0cmluZyhpbnB1dCkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiJ1wiICsgZXNjYXBlU3RyaW5nKGlucHV0LCBTSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSkgKyBcIidcIjtcclxufVxyXG5leHBvcnRzLmVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nID0gZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmc7XHJcbmZ1bmN0aW9uIGVzY2FwZURvdWJsZVF1b3RlU3RyaW5nKGlucHV0KSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5wdXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJcXFwiXCIgKyBlc2NhcGVTdHJpbmcoaW5wdXQsIERPVUJMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFKSArIFwiXFxcIlwiO1xyXG59XHJcbmV4cG9ydHMuZXNjYXBlRG91YmxlUXVvdGVTdHJpbmcgPSBlc2NhcGVEb3VibGVRdW90ZVN0cmluZztcclxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKGlucHV0LCByZSkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIHJlLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLklTX0RBUlQgPyAnXFxcXCQnIDogJyQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIG1hdGNoWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNvZGVHZW5FeHBvcnRWYXJpYWJsZShuYW1lLCBpc0NvbnN0KSB7XHJcbiAgICBpZiAoaXNDb25zdCA9PT0gdm9pZCAwKSB7IGlzQ29uc3QgPSBmYWxzZTsgfVxyXG4gICAgdmFyIGRlY2xhcmF0aW9uID0gZXhwb3J0cy5JU19EQVJUICYmIGlzQ29uc3QgPyBcImNvbnN0IFwiICsgbmFtZSA6IFwidmFyIFwiICsgbmFtZTtcclxuICAgIHJldHVybiBleHBvcnRzLklTX0RBUlQgPyBkZWNsYXJhdGlvbiArIFwiID0gXCIgOiBkZWNsYXJhdGlvbiArIFwiID0gZXhwb3J0c1snXCIgKyBuYW1lICsgXCInXSA9IFwiO1xyXG59XHJcbmV4cG9ydHMuY29kZUdlbkV4cG9ydFZhcmlhYmxlID0gY29kZUdlbkV4cG9ydFZhcmlhYmxlO1xyXG5mdW5jdGlvbiBjb2RlR2VuQ29uY2F0QXJyYXkoZXhwcmVzc2lvbikge1xyXG4gICAgcmV0dXJuIChleHBvcnRzLklTX0RBUlQgPyAnLi5hZGRBbGwnIDogJy5jb25jYXQnKSArIFwiKFwiICsgZXhwcmVzc2lvbiArIFwiKVwiO1xyXG59XHJcbmV4cG9ydHMuY29kZUdlbkNvbmNhdEFycmF5ID0gY29kZUdlbkNvbmNhdEFycmF5O1xyXG5mdW5jdGlvbiBjb2RlR2VuTWFwQXJyYXkoYXJnTmFtZXMsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZXhwb3J0cy5JU19EQVJUKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiLm1hcCggKFwiICsgYXJnTmFtZXMuam9pbignLCcpICsgXCIpID0+IFwiICsgY2FsbGJhY2sgKyBcIiApLnRvTGlzdCgpXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCIubWFwKGZ1bmN0aW9uKFwiICsgYXJnTmFtZXMuam9pbignLCcpICsgXCIpIHsgcmV0dXJuIFwiICsgY2FsbGJhY2sgKyBcIjsgfSlcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvZGVHZW5NYXBBcnJheSA9IGNvZGVHZW5NYXBBcnJheTtcclxuZnVuY3Rpb24gY29kZUdlblJlcGxhY2VBbGwocGF0dGVybiwgZXhwcmVzc2lvbikge1xyXG4gICAgaWYgKGV4cG9ydHMuSVNfREFSVCkge1xyXG4gICAgICAgIHJldHVybiBcIi5yZXBsYWNlQWxsKCdcIiArIHBhdHRlcm4gKyBcIicsIFwiICsgZXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiLnJlcGxhY2UoL1wiICsgcGF0dGVybiArIFwiL2csIFwiICsgZXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29kZUdlblJlcGxhY2VBbGwgPSBjb2RlR2VuUmVwbGFjZUFsbDtcclxuZnVuY3Rpb24gY29kZUdlblZhbHVlRm4ocGFyYW1zLCB2YWx1ZSwgZm5OYW1lKSB7XHJcbiAgICBpZiAoZm5OYW1lID09PSB2b2lkIDApIHsgZm5OYW1lID0gJyc7IH1cclxuICAgIGlmIChleHBvcnRzLklTX0RBUlQpIHtcclxuICAgICAgICByZXR1cm4gZm5OYW1lICsgXCIoXCIgKyBwYXJhbXMuam9pbignLCcpICsgXCIpID0+IFwiICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJmdW5jdGlvbiBcIiArIGZuTmFtZSArIFwiKFwiICsgcGFyYW1zLmpvaW4oJywnKSArIFwiKSB7IHJldHVybiBcIiArIHZhbHVlICsgXCI7IH1cIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvZGVHZW5WYWx1ZUZuID0gY29kZUdlblZhbHVlRm47XHJcbmZ1bmN0aW9uIGNvZGVHZW5Ub1N0cmluZyhleHByKSB7XHJcbiAgICBpZiAoZXhwb3J0cy5JU19EQVJUKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiJyR7XCIgKyBleHByICsgXCJ9J1wiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSlMgYXV0b21hdGljYWxseSBjb252ZXRzIHRvIHN0cmluZy4uLlxyXG4gICAgICAgIHJldHVybiBleHByO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29kZUdlblRvU3RyaW5nID0gY29kZUdlblRvU3RyaW5nO1xyXG5mdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcclxuICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGlucHV0LnRyaW0oKSwgL1xccyo6XFxzKi9nKTtcclxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zcGxpdEF0Q29sb24gPSBzcGxpdEF0Q29sb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBYSFIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gWEhSKCkge1xyXG4gICAgfVxyXG4gICAgWEhSLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgcmV0dXJuIFhIUjtcclxufSkoKTtcclxuZXhwb3J0cy5YSFIgPSBYSFI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhoci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHhocl8xID0gcmVxdWlyZSgnLi94aHInKTtcclxudmFyIFhIUkltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFhIUkltcGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBYSFJJbXBsKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgWEhSSW1wbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHZhciBjb21wbGV0ZXIgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLmNvbXBsZXRlcigpO1xyXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXHJcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlL3Jlc3BvbnNlVHlwZSBwcm9wZXJ0aWVzIHdlcmUgaW50cm9kdWNlZCBpbiBYSFIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZCBieSBJRTEwKVxyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBsYW5nXzEuaXNQcmVzZW50KHhoci5yZXNwb25zZSkgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xyXG4gICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxyXG4gICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG4gICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlID8gMjAwIDogMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPD0gMzAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgY29tcGxldGVyLnJlamVjdChcIkZhaWxlZCB0byBsb2FkIFwiICsgdXJsLCBudWxsKTsgfTtcclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZXIucHJvbWlzZTtcclxuICAgIH07XHJcbiAgICBYSFJJbXBsID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBYSFJJbXBsKTtcclxuICAgIHJldHVybiBYSFJJbXBsO1xyXG59KSh4aHJfMS5YSFIpO1xyXG5leHBvcnRzLlhIUkltcGwgPSBYSFJJbXBsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD14aHJfaW1wbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGRlYnVnX2VsZW1lbnRfMSA9IHJlcXVpcmUoJy4vZGVidWcvZGVidWdfZWxlbWVudCcpO1xyXG5leHBvcnRzLkRlYnVnRWxlbWVudCA9IGRlYnVnX2VsZW1lbnRfMS5EZWJ1Z0VsZW1lbnQ7XHJcbmV4cG9ydHMuYXNOYXRpdmVFbGVtZW50cyA9IGRlYnVnX2VsZW1lbnRfMS5hc05hdGl2ZUVsZW1lbnRzO1xyXG5leHBvcnRzLkJ5ID0gZGVidWdfZWxlbWVudF8xLkJ5O1xyXG5leHBvcnRzLlNjb3BlID0gZGVidWdfZWxlbWVudF8xLlNjb3BlO1xyXG5leHBvcnRzLmluc3BlY3RFbGVtZW50ID0gZGVidWdfZWxlbWVudF8xLmluc3BlY3RFbGVtZW50O1xyXG52YXIgZGVidWdfZWxlbWVudF92aWV3X2xpc3RlbmVyXzEgPSByZXF1aXJlKCcuL2RlYnVnL2RlYnVnX2VsZW1lbnRfdmlld19saXN0ZW5lcicpO1xyXG5leHBvcnRzLmluc3BlY3ROYXRpdmVFbGVtZW50ID0gZGVidWdfZWxlbWVudF92aWV3X2xpc3RlbmVyXzEuaW5zcGVjdE5hdGl2ZUVsZW1lbnQ7XHJcbmV4cG9ydHMuRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMgPSBkZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXJfMS5FTEVNRU5UX1BST0JFX1BST1ZJREVSUztcclxuZXhwb3J0cy5FTEVNRU5UX1BST0JFX0JJTkRJTkdTID0gZGVidWdfZWxlbWVudF92aWV3X2xpc3RlbmVyXzEuRUxFTUVOVF9QUk9CRV9CSU5ESU5HUztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciB2aWV3X3JlZl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcmVmJyk7XHJcbi8qKlxyXG4gKiBBIERlYnVnRWxlbWVudCBjb250YWlucyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBBbmd1bGFyIGNvbXBpbGVyIGFib3V0IGFuXHJcbiAqIGVsZW1lbnQgYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgY29ycmVzcG9uZGluZyBFbGVtZW50SW5qZWN0b3IgYW5kXHJcbiAqIHVuZGVybHlpbmcgRE9NIEVsZW1lbnQsIGFzIHdlbGwgYXMgYSB3YXkgdG8gcXVlcnkgZm9yIGNoaWxkcmVuLlxyXG4gKi9cclxudmFyIERlYnVnRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZWJ1Z0VsZW1lbnQoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjb21wb25lbnRJbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBjaGlsZCBEZWJ1Z0VsZW1lbnRzIGZyb20gd2l0aGluIHRoZSBMaWdodCBET00uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtEZWJ1Z0VsZW1lbnRbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudC5wcm90b3R5cGUsIFwiY29tcG9uZW50Vmlld0NoaWxkcmVuXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIHJvb3QgRGVidWdFbGVtZW50IGNoaWxkcmVuIG9mIGEgY29tcG9uZW50LiBSZXR1cm5zIGFuIGVtcHR5XHJcbiAgICAgICAgICogbGlzdCBpZiB0aGUgY3VycmVudCBEZWJ1Z0VsZW1lbnQgaXMgbm90IGEgY29tcG9uZW50IHJvb3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtEZWJ1Z0VsZW1lbnRbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGZpcnN0IGRlc2NlbmRhbnQgVGVzdEVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIHByZWRpY2F0ZVxyXG4gICAgICogYW5kIHNjb3BlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb246IGJvb2xlYW59IHByZWRpY2F0ZVxyXG4gICAgICogQHBhcmFtIHtTY29wZX0gc2NvcGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtEZWJ1Z0VsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBzY29wZSkge1xyXG4gICAgICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gU2NvcGUuYWxsOyB9XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnF1ZXJ5QWxsKHByZWRpY2F0ZSwgc2NvcGUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA+IDAgPyByZXN1bHRzWzBdIDogbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBkZXNjZW5kYW50IFRlc3RFbGVtZW10cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcHJlZGljYXRlXHJcbiAgICAgKiBhbmQgc2NvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbjogYm9vbGVhbn0gcHJlZGljYXRlXHJcbiAgICAgKiBAcGFyYW0ge1Njb3BlfSBzY29wZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0RlYnVnRWxlbWVudFtdfVxyXG4gICAgICovXHJcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgc2NvcGUpIHtcclxuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IFNjb3BlLmFsbDsgfVxyXG4gICAgICAgIHZhciBlbGVtZW50c0luU2NvcGUgPSBzY29wZSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbHRlcihlbGVtZW50c0luU2NvcGUsIHByZWRpY2F0ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlYnVnRWxlbWVudDtcclxufSkoKTtcclxuZXhwb3J0cy5EZWJ1Z0VsZW1lbnQgPSBEZWJ1Z0VsZW1lbnQ7XHJcbnZhciBEZWJ1Z0VsZW1lbnRfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWJ1Z0VsZW1lbnRfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVidWdFbGVtZW50XyhfcGFyZW50VmlldywgX2JvdW5kRWxlbWVudEluZGV4KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50VmlldyA9IF9wYXJlbnRWaWV3O1xyXG4gICAgICAgIHRoaXMuX2JvdW5kRWxlbWVudEluZGV4ID0gX2JvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRJbmplY3RvciA9IHRoaXMuX3BhcmVudFZpZXcuZWxlbWVudEluamVjdG9yc1t0aGlzLl9ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50Xy5wcm90b3R5cGUsIFwiY29tcG9uZW50SW5zdGFuY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRJbmplY3Rvci5nZXRDb21wb25lbnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZSwgXCJuYXRpdmVFbGVtZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudFZpZXcuZWxlbWVudFJlZnNbdGhpcy5fYm91bmRFbGVtZW50SW5kZXhdOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERlYnVnRWxlbWVudF8ucHJvdG90eXBlLmdldERpcmVjdGl2ZUluc3RhbmNlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRJbmplY3Rvci5nZXREaXJlY3RpdmVBdEluZGV4KGRpcmVjdGl2ZUluZGV4KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50Xy5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRFbGVtZW50cyh0aGlzLl9wYXJlbnRWaWV3LCB0aGlzLl9ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50Xy5wcm90b3R5cGUsIFwiY29tcG9uZW50Vmlld0NoaWxkcmVuXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNoYWRvd1ZpZXcgPSB0aGlzLl9wYXJlbnRWaWV3LmdldE5lc3RlZFZpZXcodGhpcy5fYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQoc2hhZG93VmlldykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaXMgbm90IGEgY29tcG9uZW50LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZEVsZW1lbnRzKHNoYWRvd1ZpZXcsIG51bGwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUudHJpZ2dlckV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqKSB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Vmlldy50cmlnZ2VyRXZlbnRIYW5kbGVycyhldmVudE5hbWUsIGV2ZW50T2JqLCB0aGlzLl9ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUuaGFzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50SW5qZWN0b3IuaGFzRGlyZWN0aXZlKHR5cGUpO1xyXG4gICAgfTtcclxuICAgIERlYnVnRWxlbWVudF8ucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2VsZW1lbnRJbmplY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50SW5qZWN0b3IuZ2V0KHR5cGUpO1xyXG4gICAgfTtcclxuICAgIERlYnVnRWxlbWVudF8ucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuX3BhcmVudFZpZXcubG9jYWxzLmdldChuYW1lKTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlYnVnRWxlbWVudF8ucHJvdG90eXBlLl9nZXRDaGlsZEVsZW1lbnRzID0gZnVuY3Rpb24gKHZpZXcsIHBhcmVudEJvdW5kRWxlbWVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZWxzID0gW107XHJcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRCaW5kZXIgPSBudWxsO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudEJvdW5kRWxlbWVudEluZGV4KSkge1xyXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50QmluZGVyID0gdmlldy5wcm90by5lbGVtZW50QmluZGVyc1twYXJlbnRCb3VuZEVsZW1lbnRJbmRleCAtIHZpZXcuZWxlbWVudE9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5wcm90by5lbGVtZW50QmluZGVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYmluZGVyID0gdmlldy5wcm90by5lbGVtZW50QmluZGVyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGJpbmRlci5wYXJlbnQgPT0gcGFyZW50RWxlbWVudEJpbmRlcikge1xyXG4gICAgICAgICAgICAgICAgZWxzLnB1c2gobmV3IERlYnVnRWxlbWVudF8odmlldywgdmlldy5lbGVtZW50T2Zmc2V0ICsgaSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZXdzID0gdmlldy52aWV3Q29udGFpbmVyc1t2aWV3LmVsZW1lbnRPZmZzZXQgKyBpXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZpZXdzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdzLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKG5leHRWaWV3KSB7IGVscyA9IGVscy5jb25jYXQoX3RoaXMuX2dldENoaWxkRWxlbWVudHMobmV4dFZpZXcsIG51bGwpKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVscztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVidWdFbGVtZW50XztcclxufSkoRGVidWdFbGVtZW50KTtcclxuZXhwb3J0cy5EZWJ1Z0VsZW1lbnRfID0gRGVidWdFbGVtZW50XztcclxuLyoqXHJcbiAqIFJldHVybnMgYSBEZWJ1Z0VsZW1lbnQgZm9yIGEgRWxlbWVudFJlZi5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50UmVmfTogZWxlbWVudFJlZlxyXG4gKiBAcmV0dXJuIHtEZWJ1Z0VsZW1lbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnNwZWN0RWxlbWVudChlbGVtZW50UmVmKSB7XHJcbiAgICByZXR1cm4gbmV3IERlYnVnRWxlbWVudF8odmlld19yZWZfMS5pbnRlcm5hbFZpZXcoZWxlbWVudFJlZi5wYXJlbnRWaWV3KSwgZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCk7XHJcbn1cclxuZXhwb3J0cy5pbnNwZWN0RWxlbWVudCA9IGluc3BlY3RFbGVtZW50O1xyXG5mdW5jdGlvbiBhc05hdGl2ZUVsZW1lbnRzKGFycikge1xyXG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGRlYnVnRWwpIHsgcmV0dXJuIGRlYnVnRWwubmF0aXZlRWxlbWVudDsgfSk7XHJcbn1cclxuZXhwb3J0cy5hc05hdGl2ZUVsZW1lbnRzID0gYXNOYXRpdmVFbGVtZW50cztcclxudmFyIFNjb3BlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNjb3BlKCkge1xyXG4gICAgfVxyXG4gICAgU2NvcGUuYWxsID0gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IFtdO1xyXG4gICAgICAgIHNjb3BlLnB1c2goZGVidWdFbGVtZW50KTtcclxuICAgICAgICBkZWJ1Z0VsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIHNjb3BlID0gc2NvcGUuY29uY2F0KFNjb3BlLmFsbChjaGlsZCkpOyB9KTtcclxuICAgICAgICBkZWJ1Z0VsZW1lbnQuY29tcG9uZW50Vmlld0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBzY29wZSA9IHNjb3BlLmNvbmNhdChTY29wZS5hbGwoY2hpbGQpKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xyXG4gICAgfTtcclxuICAgIFNjb3BlLmxpZ2h0ID0gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IFtdO1xyXG4gICAgICAgIGRlYnVnRWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzY29wZS5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5jb25jYXQoU2NvcGUubGlnaHQoY2hpbGQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2NvcGU7XHJcbiAgICB9O1xyXG4gICAgU2NvcGUudmlldyA9IGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgc2NvcGUgPSBbXTtcclxuICAgICAgICBkZWJ1Z0VsZW1lbnQuY29tcG9uZW50Vmlld0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICBzY29wZSA9IHNjb3BlLmNvbmNhdChTY29wZS5saWdodChjaGlsZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzY29wZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2NvcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcclxudmFyIEJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ5KCkge1xyXG4gICAgfVxyXG4gICAgQnkuYWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcclxuICAgIEJ5LmNzcyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50KSA/XHJcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5lbGVtZW50TWF0Y2hlcyhkZWJ1Z0VsZW1lbnQubmF0aXZlRWxlbWVudCwgc2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgQnkuZGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gZGVidWdFbGVtZW50Lmhhc0RpcmVjdGl2ZSh0eXBlKTsgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQnkgPSBCeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWdfZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciB2aWV3X2xpc3RlbmVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19saXN0ZW5lcicpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgYXBpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvYXBpJyk7XHJcbnZhciBkZWJ1Z19lbGVtZW50XzEgPSByZXF1aXJlKCcuL2RlYnVnX2VsZW1lbnQnKTtcclxudmFyIE5HX0lEX1BST1BFUlRZID0gJ25naWQnO1xyXG52YXIgSU5TUEVDVF9HTE9CQUxfTkFNRSA9ICduZy5wcm9iZSc7XHJcbnZhciBOR19JRF9TRVBBUkFUT1IgPSAnIyc7XHJcbi8vIE5lZWQgdG8ga2VlcCB0aGUgdmlld3MgaW4gYSBnbG9iYWwgTWFwIHNvIHRoYXQgbXVsdGlwbGUgYW5ndWxhciBhcHBzIGFyZSBzdXBwb3J0ZWRcclxudmFyIF9hbGxJZHNCeVZpZXcgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG52YXIgX2FsbFZpZXdzQnlJZCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbnZhciBfbmV4dElkID0gMDtcclxuZnVuY3Rpb24gX3NldEVsZW1lbnRJZChlbGVtZW50LCBpbmRpY2VzKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50KSkge1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldERhdGEoZWxlbWVudCwgTkdfSURfUFJPUEVSVFksIGluZGljZXMuam9pbihOR19JRF9TRVBBUkFUT1IpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfZ2V0RWxlbWVudElkKGVsZW1lbnQpIHtcclxuICAgIHZhciBlbElkID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0RGF0YShlbGVtZW50LCBOR19JRF9QUk9QRVJUWSk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbElkKSkge1xyXG4gICAgICAgIHJldHVybiBlbElkLnNwbGl0KE5HX0lEX1NFUEFSQVRPUikubWFwKGZ1bmN0aW9uIChwYXJ0U3RyKSB7IHJldHVybiBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludChwYXJ0U3RyLCAxMCk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5zcGVjdE5hdGl2ZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgdmFyIGVsSWQgPSBfZ2V0RWxlbWVudElkKGVsZW1lbnQpO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxJZCkpIHtcclxuICAgICAgICB2YXIgdmlldyA9IF9hbGxWaWV3c0J5SWQuZ2V0KGVsSWRbMF0pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZpZXcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGVidWdfZWxlbWVudF8xLkRlYnVnRWxlbWVudF8odmlldywgZWxJZFsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5pbnNwZWN0TmF0aXZlRWxlbWVudCA9IGluc3BlY3ROYXRpdmVFbGVtZW50O1xyXG52YXIgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lcihfcmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRHbG9iYWxWYXIoSU5TUEVDVF9HTE9CQUxfTkFNRSwgaW5zcGVjdE5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyLnByb3RvdHlwZS52aWV3Q3JlYXRlZCA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmFyIHZpZXdJZCA9IF9uZXh0SWQrKztcclxuICAgICAgICBfYWxsVmlld3NCeUlkLnNldCh2aWV3SWQsIHZpZXcpO1xyXG4gICAgICAgIF9hbGxJZHNCeVZpZXcuc2V0KHZpZXcsIHZpZXdJZCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3LmVsZW1lbnRSZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHZpZXcuZWxlbWVudFJlZnNbaV07XHJcbiAgICAgICAgICAgIF9zZXRFbGVtZW50SWQodGhpcy5fcmVuZGVyZXIuZ2V0TmF0aXZlRWxlbWVudFN5bmMoZWwpLCBbdmlld0lkLCBpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lci5wcm90b3R5cGUudmlld0Rlc3Ryb3llZCA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmFyIHZpZXdJZCA9IF9hbGxJZHNCeVZpZXcuZ2V0KHZpZXcpO1xyXG4gICAgICAgIF9hbGxJZHNCeVZpZXcuZGVsZXRlKHZpZXcpO1xyXG4gICAgICAgIF9hbGxWaWV3c0J5SWQuZGVsZXRlKHZpZXdJZCk7XHJcbiAgICB9O1xyXG4gICAgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2FwaV8xLlJlbmRlcmVyXSlcclxuICAgIF0sIERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lcik7XHJcbiAgICByZXR1cm4gRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkRlYnVnRWxlbWVudFZpZXdMaXN0ZW5lciA9IERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lcjtcclxuZXhwb3J0cy5FTEVNRU5UX1BST0JFX1BST1ZJREVSUyA9IGxhbmdfMS5DT05TVF9FWFBSKFtcclxuICAgIERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lcixcclxuICAgIGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKHZpZXdfbGlzdGVuZXJfMS5BcHBWaWV3TGlzdGVuZXIsIHsgdXNlRXhpc3Rpbmc6IERlYnVnRWxlbWVudFZpZXdMaXN0ZW5lciB9KSksXHJcbl0pO1xyXG5leHBvcnRzLkVMRU1FTlRfUFJPQkVfQklORElOR1MgPSBleHBvcnRzLkVMRU1FTlRfUFJPQkVfUFJPVklERVJTO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYGRpYCBtb2R1bGUgcHJvdmlkZXMgZGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHNlcnZpY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9kaS9tZXRhZGF0YScpO1xyXG5leHBvcnRzLkluamVjdE1ldGFkYXRhID0gbWV0YWRhdGFfMS5JbmplY3RNZXRhZGF0YTtcclxuZXhwb3J0cy5PcHRpb25hbE1ldGFkYXRhID0gbWV0YWRhdGFfMS5PcHRpb25hbE1ldGFkYXRhO1xyXG5leHBvcnRzLkluamVjdGFibGVNZXRhZGF0YSA9IG1ldGFkYXRhXzEuSW5qZWN0YWJsZU1ldGFkYXRhO1xyXG5leHBvcnRzLlNlbGZNZXRhZGF0YSA9IG1ldGFkYXRhXzEuU2VsZk1ldGFkYXRhO1xyXG5leHBvcnRzLkhvc3RNZXRhZGF0YSA9IG1ldGFkYXRhXzEuSG9zdE1ldGFkYXRhO1xyXG5leHBvcnRzLlNraXBTZWxmTWV0YWRhdGEgPSBtZXRhZGF0YV8xLlNraXBTZWxmTWV0YWRhdGE7XHJcbmV4cG9ydHMuRGVwZW5kZW5jeU1ldGFkYXRhID0gbWV0YWRhdGFfMS5EZXBlbmRlbmN5TWV0YWRhdGE7XHJcbi8vIHdlIGhhdmUgdG8gcmVleHBvcnQgKiBiZWNhdXNlIERhcnQgYW5kIFRTIGV4cG9ydCB0d28gZGlmZmVyZW50IHNldHMgb2YgdHlwZXNcclxuX19leHBvcnQocmVxdWlyZSgnLi9kaS9kZWNvcmF0b3JzJykpO1xyXG52YXIgZm9yd2FyZF9yZWZfMSA9IHJlcXVpcmUoJy4vZGkvZm9yd2FyZF9yZWYnKTtcclxuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZF9yZWZfMS5mb3J3YXJkUmVmO1xyXG5leHBvcnRzLnJlc29sdmVGb3J3YXJkUmVmID0gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZjtcclxudmFyIGluamVjdG9yXzEgPSByZXF1aXJlKCcuL2RpL2luamVjdG9yJyk7XHJcbmV4cG9ydHMuSW5qZWN0b3IgPSBpbmplY3Rvcl8xLkluamVjdG9yO1xyXG52YXIgcHJvdmlkZXJfMSA9IHJlcXVpcmUoJy4vZGkvcHJvdmlkZXInKTtcclxuZXhwb3J0cy5CaW5kaW5nID0gcHJvdmlkZXJfMS5CaW5kaW5nO1xyXG5leHBvcnRzLlByb3ZpZGVyQnVpbGRlciA9IHByb3ZpZGVyXzEuUHJvdmlkZXJCdWlsZGVyO1xyXG5leHBvcnRzLlJlc29sdmVkRmFjdG9yeSA9IHByb3ZpZGVyXzEuUmVzb2x2ZWRGYWN0b3J5O1xyXG5leHBvcnRzLkRlcGVuZGVuY3kgPSBwcm92aWRlcl8xLkRlcGVuZGVuY3k7XHJcbmV4cG9ydHMuYmluZCA9IHByb3ZpZGVyXzEuYmluZDtcclxuZXhwb3J0cy5Qcm92aWRlciA9IHByb3ZpZGVyXzEuUHJvdmlkZXI7XHJcbmV4cG9ydHMucHJvdmlkZSA9IHByb3ZpZGVyXzEucHJvdmlkZTtcclxudmFyIGtleV8xID0gcmVxdWlyZSgnLi9kaS9rZXknKTtcclxuZXhwb3J0cy5LZXkgPSBrZXlfMS5LZXk7XHJcbmV4cG9ydHMuVHlwZUxpdGVyYWwgPSBrZXlfMS5UeXBlTGl0ZXJhbDtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vZGkvZXhjZXB0aW9ucycpO1xyXG5leHBvcnRzLk5vUHJvdmlkZXJFcnJvciA9IGV4Y2VwdGlvbnNfMS5Ob1Byb3ZpZGVyRXJyb3I7XHJcbmV4cG9ydHMuQWJzdHJhY3RQcm92aWRlckVycm9yID0gZXhjZXB0aW9uc18xLkFic3RyYWN0UHJvdmlkZXJFcnJvcjtcclxuZXhwb3J0cy5DeWNsaWNEZXBlbmRlbmN5RXJyb3IgPSBleGNlcHRpb25zXzEuQ3ljbGljRGVwZW5kZW5jeUVycm9yO1xyXG5leHBvcnRzLkluc3RhbnRpYXRpb25FcnJvciA9IGV4Y2VwdGlvbnNfMS5JbnN0YW50aWF0aW9uRXJyb3I7XHJcbmV4cG9ydHMuSW52YWxpZFByb3ZpZGVyRXJyb3IgPSBleGNlcHRpb25zXzEuSW52YWxpZFByb3ZpZGVyRXJyb3I7XHJcbmV4cG9ydHMuTm9Bbm5vdGF0aW9uRXJyb3IgPSBleGNlcHRpb25zXzEuTm9Bbm5vdGF0aW9uRXJyb3I7XHJcbmV4cG9ydHMuT3V0T2ZCb3VuZHNFcnJvciA9IGV4Y2VwdGlvbnNfMS5PdXRPZkJvdW5kc0Vycm9yO1xyXG52YXIgb3BhcXVlX3Rva2VuXzEgPSByZXF1aXJlKCcuL2RpL29wYXF1ZV90b2tlbicpO1xyXG5leHBvcnRzLk9wYXF1ZVRva2VuID0gb3BhcXVlX3Rva2VuXzEuT3BhcXVlVG9rZW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEnKTtcclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjb3JhdG9ycycpO1xyXG4vKipcclxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIEluamVjdE1ldGFkYXRhfS5cclxuICovXHJcbmV4cG9ydHMuSW5qZWN0ID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihtZXRhZGF0YV8xLkluamVjdE1ldGFkYXRhKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBPcHRpb25hbE1ldGFkYXRhfS5cclxuICovXHJcbmV4cG9ydHMuT3B0aW9uYWwgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuT3B0aW9uYWxNZXRhZGF0YSk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgSW5qZWN0YWJsZU1ldGFkYXRhfS5cclxuICovXHJcbmV4cG9ydHMuSW5qZWN0YWJsZSA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKG1ldGFkYXRhXzEuSW5qZWN0YWJsZU1ldGFkYXRhKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBTZWxmTWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5TZWxmID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihtZXRhZGF0YV8xLlNlbGZNZXRhZGF0YSk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgSG9zdE1ldGFkYXRhfS5cclxuICovXHJcbmV4cG9ydHMuSG9zdCA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IobWV0YWRhdGFfMS5Ib3N0TWV0YWRhdGEpO1xyXG4vKipcclxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIFNraXBTZWxmTWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5Ta2lwU2VsZiA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IobWV0YWRhdGFfMS5Ta2lwU2VsZk1ldGFkYXRhKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb3JhdG9ycy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuZnVuY3Rpb24gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyhyZXMsIGtleXNbaV0pKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGtleXNbaV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzLnB1c2goa2V5c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpIHtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBmaW5kRmlyc3RDbG9zZWRDeWNsZShjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmV2ZXJzZWQoa2V5cykpO1xyXG4gICAgICAgIHZhciB0b2tlblN0cnMgPSByZXZlcnNlZC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGxhbmdfMS5zdHJpbmdpZnkoay50b2tlbik7IH0pO1xyXG4gICAgICAgIHJldHVybiBcIiAoXCIgKyB0b2tlblN0cnMuam9pbignIC0+ICcpICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGVycm9ycyBhcmlzaW5nIGZyb20gbWlzY29uZmlndXJlZCBwcm92aWRlcnMuXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiREkgRXhjZXB0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UgPSBjb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSh0aGlzLmtleXMpO1xyXG4gICAgfVxyXG4gICAgQWJzdHJhY3RQcm92aWRlckVycm9yLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIGtleSkge1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xyXG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlKHRoaXMua2V5cyk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0UHJvdmlkZXJFcnJvci5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluamVjdG9yc1t0aGlzLmluamVjdG9ycy5sZW5ndGggLSAxXS5kZWJ1Z0NvbnRleHQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQWJzdHJhY3RQcm92aWRlckVycm9yO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuQWJzdHJhY3RQcm92aWRlckVycm9yID0gQWJzdHJhY3RQcm92aWRlckVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gdHJ5aW5nIHRvIHJldHJpZXZlIGEgZGVwZW5kZW5jeSBieSBgS2V5YCBmcm9tIHtAbGluayBJbmplY3Rvcn0sIGJ1dCB0aGVcclxuICoge0BsaW5rIEluamVjdG9yfSBkb2VzIG5vdCBoYXZlIGEge0BsaW5rIFByb3ZpZGVyfSBmb3Ige0BsaW5rIEtleX0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC92cThEM0ZSQjlhR2JuV0pxdEVQRT9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEEge1xyXG4gKiAgIGNvbnN0cnVjdG9yKGI6Qikge31cclxuICogfVxyXG4gKlxyXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTm9Qcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOb1Byb3ZpZGVyRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOb1Byb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IGxhbmdfMS5zdHJpbmdpZnkoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KGtleXMpLnRva2VuKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgZmlyc3QgKyBcIiFcIiArIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgoa2V5cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9Qcm92aWRlckVycm9yO1xyXG59KShBYnN0cmFjdFByb3ZpZGVyRXJyb3IpO1xyXG5leHBvcnRzLk5vUHJvdmlkZXJFcnJvciA9IE5vUHJvdmlkZXJFcnJvcjtcclxuLyoqXHJcbiAqIFRocm93biB3aGVuIGRlcGVuZGVuY2llcyBmb3JtIGEgY3ljbGUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC93WVFkTm9zMFR6cWwzZWkxRVY5aj9wPWluZm8pKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gKiAgIHByb3ZpZGUoXCJvbmVcIiwge3VzZUZhY3Rvcnk6ICh0d28pID0+IFwidHdvXCIsIGRlcHM6IFtbbmV3IEluamVjdChcInR3b1wiKV1dfSksXHJcbiAqICAgcHJvdmlkZShcInR3b1wiLCB7dXNlRmFjdG9yeTogKG9uZSkgPT4gXCJvbmVcIiwgZGVwczogW1tuZXcgSW5qZWN0KFwib25lXCIpXV19KVxyXG4gKiBdKTtcclxuICpcclxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChcIm9uZVwiKSkudG9UaHJvd0Vycm9yKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBSZXRyaWV2aW5nIGBBYCBvciBgQmAgdGhyb3dzIGEgYEN5Y2xpY0RlcGVuZGVuY3lFcnJvcmAgYXMgdGhlIGdyYXBoIGFib3ZlIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZC5cclxuICovXHJcbnZhciBDeWNsaWNEZXBlbmRlbmN5RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEN5Y2xpY0RlcGVuZGVuY3lFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEN5Y2xpY0RlcGVuZGVuY3lFcnJvcihpbmplY3Rvciwga2V5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5IVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XHJcbn0pKEFic3RyYWN0UHJvdmlkZXJFcnJvcik7XHJcbmV4cG9ydHMuQ3ljbGljRGVwZW5kZW5jeUVycm9yID0gQ3ljbGljRGVwZW5kZW5jeUVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gYSBjb25zdHJ1Y3RpbmcgdHlwZSByZXR1cm5zIHdpdGggYW4gRXJyb3IuXHJcbiAqXHJcbiAqIFRoZSBgSW5zdGFudGlhdGlvbkVycm9yYCBjbGFzcyBjb250YWlucyB0aGUgb3JpZ2luYWwgZXJyb3IgcGx1cyB0aGUgZGVwZW5kZW5jeSBncmFwaCB3aGljaCBjYXVzZWRcclxuICogdGhpcyBvYmplY3QgdG8gYmUgaW5zdGFudGlhdGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvN2FXWWRjcVRRc1AwZU5xRWRVQWY/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBBIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZScpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XHJcblxyXG4gKiB0cnkge1xyXG4gKiAgIGluamVjdG9yLmdldChBKTtcclxuICogfSBjYXRjaCAoZSkge1xyXG4gKiAgIGV4cGVjdChlIGluc3RhbmNlb2YgSW5zdGFudGlhdGlvbkVycm9yKS50b0JlKHRydWUpO1xyXG4gKiAgIGV4cGVjdChlLm9yaWdpbmFsRXhjZXB0aW9uLm1lc3NhZ2UpLnRvRXF1YWwoXCJtZXNzYWdlXCIpO1xyXG4gKiAgIGV4cGVjdChlLm9yaWdpbmFsU3RhY2spLnRvQmVEZWZpbmVkKCk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgSW5zdGFudGlhdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0aW9uRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnN0YW50aWF0aW9uRXJyb3IoaW5qZWN0b3IsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBrZXkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkRJIEV4Y2VwdGlvblwiLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5rZXlzID0gW2tleV07XHJcbiAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xyXG4gICAgfVxyXG4gICAgSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIGtleSkge1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xyXG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwid3JhcHBlck1lc3NhZ2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBsYW5nXzEuc3RyaW5naWZ5KGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdCh0aGlzLmtleXMpLnRva2VuKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3IgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aCh0aGlzLmtleXMpICsgXCIuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJjYXVzZUtleVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXNbMF07IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluamVjdG9yc1t0aGlzLmluamVjdG9ycy5sZW5ndGggLSAxXS5kZWJ1Z0NvbnRleHQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gSW5zdGFudGlhdGlvbkVycm9yO1xyXG59KShleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuSW5zdGFudGlhdGlvbkVycm9yID0gSW5zdGFudGlhdGlvbkVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gYW4gb2JqZWN0IG90aGVyIHRoZW4ge0BsaW5rIFByb3ZpZGVyfSAob3IgYFR5cGVgKSBpcyBwYXNzZWQgdG8ge0BsaW5rIEluamVjdG9yfVxyXG4gKiBjcmVhdGlvbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lhdENGYlBBTUNMMEpTU1E0bXZIP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1wibm90IGEgdHlwZVwiXSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBJbnZhbGlkUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW52YWxpZFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnZhbGlkUHJvdmlkZXJFcnJvcihwcm92aWRlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBwcm92aWRlciAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFwiICtcclxuICAgICAgICAgICAgcHJvdmlkZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW52YWxpZFByb3ZpZGVyRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5JbnZhbGlkUHJvdmlkZXJFcnJvciA9IEludmFsaWRQcm92aWRlckVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gdGhlIGNsYXNzIGhhcyBubyBhbm5vdGF0aW9uIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBMYWNrIG9mIGFubm90YXRpb24gaW5mb3JtYXRpb24gcHJldmVudHMgdGhlIHtAbGluayBJbmplY3Rvcn0gZnJvbSBkZXRlcm1pbmluZyB3aGljaCBkZXBlbmRlbmNpZXNcclxuICogbmVlZCB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3JIblp0bE5TN3ZKT1BRNnBjVmttP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgQSB7XHJcbiAqICAgY29uc3RydWN0b3IoYikge31cclxuICogfVxyXG4gKlxyXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZXJyb3IgaXMgYWxzbyB0aHJvd24gd2hlbiB0aGUgY2xhc3Mgbm90IG1hcmtlZCB3aXRoIHtAbGluayBJbmplY3RhYmxlfSBoYXMgcGFyYW1ldGVyIHR5cGVzLlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEIge31cclxuICpcclxuICogY2xhc3MgQSB7XHJcbiAqICAgY29uc3RydWN0b3IoYjpCKSB7fSAvLyBubyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVyIHR5cGVzIG9mIEEgaXMgYXZhaWxhYmxlIGF0IHJ1bnRpbWUuXHJcbiAqIH1cclxuICpcclxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0EsQl0pKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTm9Bbm5vdGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5vQW5ub3RhdGlvbkVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgTm9Bbm5vdGF0aW9uRXJyb3IuX2dlbk1lc3NhZ2UodHlwZU9yRnVuYywgcGFyYW1zKSk7XHJcbiAgICB9XHJcbiAgICBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgc2lnbmF0dXJlID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtZXRlcikgfHwgcGFyYW1ldGVyLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaCgnPycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2gocGFyYW1ldGVyLm1hcChsYW5nXzEuc3RyaW5naWZ5KS5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIkNhbm5vdCByZXNvbHZlIGFsbCBwYXJhbWV0ZXJzIGZvciBcIiArIGxhbmdfMS5zdHJpbmdpZnkodHlwZU9yRnVuYykgKyBcIihcIiArXHJcbiAgICAgICAgICAgIHNpZ25hdHVyZS5qb2luKCcsICcpICsgXCIpLiBcIiArICdNYWtlIHN1cmUgdGhleSBhbGwgaGF2ZSB2YWxpZCB0eXBlIG9yIGFubm90YXRpb25zLic7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vQW5ub3RhdGlvbkVycm9yO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuTm9Bbm5vdGF0aW9uRXJyb3IgPSBOb0Fubm90YXRpb25FcnJvcjtcclxuLyoqXHJcbiAqIFRocm93biB3aGVuIGdldHRpbmcgYW4gb2JqZWN0IGJ5IGluZGV4LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYlJzMFNYMk9UUWlKenF2amdsOFA/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBBIHt9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcclxuICpcclxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldEF0KDEwMCkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBPdXRPZkJvdW5kc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhPdXRPZkJvdW5kc0Vycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT3V0T2ZCb3VuZHNFcnJvcihpbmRleCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW5kZXggXCIgKyBpbmRleCArIFwiIGlzIG91dC1vZi1ib3VuZHMuXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE91dE9mQm91bmRzRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5PdXRPZkJvdW5kc0Vycm9yID0gT3V0T2ZCb3VuZHNFcnJvcjtcclxuLy8gVE9ETzogYWRkIGEgd29ya2luZyBleGFtcGxlIGFmdGVyIGFscGhhMzggaXMgcmVsZWFzZWRcclxuLyoqXHJcbiAqIFRocm93biB3aGVuIGEgbXVsdGkgcHJvdmlkZXIgYW5kIGEgcmVndWxhciBwcm92aWRlciBhcmUgYm91bmQgdG8gdGhlIHNhbWUgdG9rZW4uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwge3VzZVZhbHVlOiBcInN0cmluZzFcIiwgbXVsdGk6IHRydWV9KSxcclxuICogICBuZXcgUHJvdmlkZXIoXCJTdHJpbmdzXCIsIHt1c2VWYWx1ZTogXCJzdHJpbmcyXCIsIG11bHRpOiBmYWxzZX0pXHJcbiAqIF0pKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IocHJvdmlkZXIxLCBwcm92aWRlcjIpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkNhbm5vdCBtaXggbXVsdGkgcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycywgZ290OiBcIiArIHByb3ZpZGVyMS50b1N0cmluZygpICsgXCIgXCIgK1xyXG4gICAgICAgICAgICBwcm92aWRlcjIudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yID0gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNlcHRpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIEFsbG93cyB0byByZWZlciB0byByZWZlcmVuY2VzIHdoaWNoIGFyZSBub3QgeWV0IGRlZmluZWQuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgYGZvcndhcmRSZWZgIGlzIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSBuZWVkIHRvIHJlZmVyIHRvIGZvciB0aGUgcHVycG9zZXMgb2ZcclxuICogREkgaXMgZGVjbGFyZWQsXHJcbiAqIGJ1dCBub3QgeWV0IGRlZmluZWQuIEl0IGlzIGFsc28gdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIHVzZSB3aGVuIGNyZWF0aW5nIGEgcXVlcnkgaXMgbm90XHJcbiAqIHlldCBkZWZpbmVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYlJzMFNYMk9UUWlKenF2amdsOFA/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBEb29yIHtcclxuICogICBsb2NrOiBMb2NrO1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBMb2NrKSkgbG9jazpMb2NrKSB7XHJcbiAqICAgICB0aGlzLmxvY2sgPSBsb2NrO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiAvLyBPbmx5IGF0IHRoaXMgcG9pbnQgTG9jayBpcyBkZWZpbmVkLlxyXG4gKiBjbGFzcyBMb2NrIHtcclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtEb29yLCBMb2NrXSk7XHJcbiAqIHZhciBkb29yID0gaW5qZWN0b3IuZ2V0KERvb3IpO1xyXG4gKiBleHBlY3QoZG9vciBpbnN0YW5jZW9mIERvb3IpLnRvQmUodHJ1ZSk7XHJcbiAqIGV4cGVjdChkb29yLmxvY2sgaW5zdGFuY2VvZiBMb2NrKS50b0JlKHRydWUpO1xyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGZvcndhcmRSZWYoZm9yd2FyZFJlZkZuKSB7XHJcbiAgICBmb3J3YXJkUmVmRm4uX19mb3J3YXJkX3JlZl9fID0gZm9yd2FyZFJlZjtcclxuICAgIGZvcndhcmRSZWZGbi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5zdHJpbmdpZnkodGhpcygpKTsgfTtcclxuICAgIHJldHVybiBmb3J3YXJkUmVmRm47XHJcbn1cclxuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcclxuLyoqXHJcbiAqIExhemlseSByZXRyaWV2ZXMgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGEgZm9yd2FyZFJlZi5cclxuICpcclxuICogQWN0cyBhcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gd2hlbiBnaXZlbiBhIG5vbi1mb3J3YXJkLXJlZiB2YWx1ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0dVNzJtSnJrMWZpb2RDaGNtaURSP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogdmFyIHJlZiA9IGZvcndhcmRSZWYoKCkgPT4gXCJyZWZWYWx1ZVwiKTtcclxuICogZXhwZWN0KHJlc29sdmVGb3J3YXJkUmVmKHJlZikpLnRvRXF1YWwoXCJyZWZWYWx1ZVwiKTtcclxuICogZXhwZWN0KHJlc29sdmVGb3J3YXJkUmVmKFwicmVndWxhclZhbHVlXCIpKS50b0VxdWFsKFwicmVndWxhclZhbHVlXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogU2VlOiB7QGxpbmsgZm9yd2FyZFJlZn1cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpIHtcclxuICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX2ZvcndhcmRfcmVmX18nKSAmJlxyXG4gICAgICAgIHR5cGUuX19mb3J3YXJkX3JlZl9fID09PSBmb3J3YXJkUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGUoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVzb2x2ZUZvcndhcmRSZWYgPSByZXNvbHZlRm9yd2FyZFJlZjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yd2FyZF9yZWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgcHJvdmlkZXJfMSA9IHJlcXVpcmUoJy4vcHJvdmlkZXInKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vZXhjZXB0aW9ucycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGtleV8xID0gcmVxdWlyZSgnLi9rZXknKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCcuL21ldGFkYXRhJyk7XHJcbi8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxyXG52YXIgX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUiA9IDEwO1xyXG5leHBvcnRzLlVOREVGSU5FRCA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBPYmplY3QoKSk7XHJcbi8qKlxyXG4gKiBWaXNpYmlsaXR5IG9mIGEge0BsaW5rIFByb3ZpZGVyfS5cclxuICovXHJcbihmdW5jdGlvbiAoVmlzaWJpbGl0eSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBQdWJsaWNgIHtAbGluayBQcm92aWRlcn0gaXMgb25seSB2aXNpYmxlIHRvIHJlZ3VsYXIgKGFzIG9wcG9zZWQgdG8gaG9zdCkgY2hpbGQgaW5qZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBWaXNpYmlsaXR5W1Zpc2liaWxpdHlbXCJQdWJsaWNcIl0gPSAwXSA9IFwiUHVibGljXCI7XHJcbiAgICAvKipcclxuICAgICAqIEEgYFByaXZhdGVgIHtAbGluayBQcm92aWRlcn0gaXMgb25seSB2aXNpYmxlIHRvIGhvc3QgKGFzIG9wcG9zZWQgdG8gcmVndWxhcikgY2hpbGQgaW5qZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBWaXNpYmlsaXR5W1Zpc2liaWxpdHlbXCJQcml2YXRlXCJdID0gMV0gPSBcIlByaXZhdGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBgUHVibGljQW5kUHJpdmF0ZWAge0BsaW5rIFByb3ZpZGVyfSBpcyB2aXNpYmxlIHRvIGJvdGggaG9zdCBhbmQgcmVndWxhciBjaGlsZCBpbmplY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIFZpc2liaWxpdHlbVmlzaWJpbGl0eVtcIlB1YmxpY0FuZFByaXZhdGVcIl0gPSAyXSA9IFwiUHVibGljQW5kUHJpdmF0ZVwiO1xyXG59KShleHBvcnRzLlZpc2liaWxpdHkgfHwgKGV4cG9ydHMuVmlzaWJpbGl0eSA9IHt9KSk7XHJcbnZhciBWaXNpYmlsaXR5ID0gZXhwb3J0cy5WaXNpYmlsaXR5O1xyXG5mdW5jdGlvbiBjYW5TZWUoc3JjLCBkc3QpIHtcclxuICAgIHJldHVybiAoc3JjID09PSBkc3QpIHx8XHJcbiAgICAgICAgKGRzdCA9PT0gVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlIHx8IHNyYyA9PT0gVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlKTtcclxufVxyXG52YXIgUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneShwcm90b0VJLCBid3YpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXI1ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXI4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQxID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkMiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkNSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQ3ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkOCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTggPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eTkgPSBudWxsO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBid3YubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIwID0gYnd2WzBdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkMCA9IGJ3dlswXS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkwID0gYnd2WzBdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gYnd2WzFdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkMSA9IGJ3dlsxXS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkxID0gYnd2WzFdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gYnd2WzJdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkMiA9IGJ3dlsyXS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkyID0gYnd2WzJdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIzID0gYnd2WzNdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkMyA9IGJ3dlszXS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHkzID0gYnd2WzNdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gYnd2WzRdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkNCA9IGJ3dls0XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk0ID0gYnd2WzRdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gYnd2WzVdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkNSA9IGJ3dls1XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk1ID0gYnd2WzVdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA2KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI2ID0gYnd2WzZdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkNiA9IGJ3dls2XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk2ID0gYnd2WzZdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA3KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gYnd2WzddLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkNyA9IGJ3dls3XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk3ID0gYnd2WzddLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gYnd2WzhdLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkOCA9IGJ3dls4XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk4ID0gYnd2WzhdLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPiA5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI5ID0gYnd2WzldLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkOSA9IGJ3dls5XS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHk5ID0gYnd2WzldLnZpc2liaWxpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRQcm92aWRlckF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjE7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyMjtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMylcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjQ7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA3KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjc7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyODtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5O1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IFByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcclxudmFyIFByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b0luaiwgYnd2KSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IGJ3di5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGxlbik7XHJcbiAgICAgICAgdGhpcy5rZXlJZHMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGxlbik7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXRpZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGxlbik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyc1tpXSA9IGJ3dltpXS5wcm92aWRlcjtcclxuICAgICAgICAgICAgdGhpcy5rZXlJZHNbaV0gPSBid3ZbaV0uZ2V0S2V5SWQoKTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXRpZXNbaV0gPSBid3ZbaV0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRQcm92aWRlckF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMucHJvdmlkZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLk91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNbaW5kZXhdO1xyXG4gICAgfTtcclxuICAgIFByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kgPSBmdW5jdGlvbiAoZWkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIGVpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneTtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneTtcclxudmFyIFByb3RvSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9JbmplY3Rvcihid3YpIHtcclxuICAgICAgICB0aGlzLm51bWJlck9mUHJvdmlkZXJzID0gYnd2Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IGJ3di5sZW5ndGggPiBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID9cclxuICAgICAgICAgICAgbmV3IFByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgYnd2KSA6XHJcbiAgICAgICAgICAgIG5ldyBQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kodGhpcywgYnd2KTtcclxuICAgIH1cclxuICAgIFByb3RvSW5qZWN0b3IucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0UHJvdmlkZXJBdEluZGV4KGluZGV4KTsgfTtcclxuICAgIHJldHVybiBQcm90b0luamVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvSW5qZWN0b3IgPSBQcm90b0luamVjdG9yO1xyXG52YXIgSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yLCBwcm90b1N0cmF0ZWd5KSB7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgICAgIHRoaXMucHJvdG9TdHJhdGVneSA9IHByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5vYmowID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmoxID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmoyID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmozID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo0ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo1ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo2ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo3ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo4ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgdGhpcy5vYmo5ID0gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICB9XHJcbiAgICBJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xyXG4gICAgSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuaW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIsIHZpc2liaWxpdHkpO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwYXJlbnQsIGlzSG9zdCkge1xyXG4gICAgICAgIHZhciBpbmogPSB0aGlzLmluamVjdG9yO1xyXG4gICAgICAgIGluai5fcGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGluai5faXNIb3N0ID0gaXNIb3N0O1xyXG4gICAgfTtcclxuICAgIEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQsIHZpc2liaWxpdHkpIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucHJvdG9TdHJhdGVneTtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcy5pbmplY3RvcjtcclxuICAgICAgICBpZiAocC5rZXlJZDAgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHkwLCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmowID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmowID0gaW5qLl9uZXcocC5wcm92aWRlcjAsIHAudmlzaWJpbGl0eTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkMSA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTEsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajEgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajEgPSBpbmouX25ldyhwLnByb3ZpZGVyMSwgcC52aXNpYmlsaXR5MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQyID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5MiwgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqMiA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqMiA9IGluai5fbmV3KHAucHJvdmlkZXIyLCBwLnZpc2liaWxpdHkyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDMgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHkzLCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmozID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmozID0gaW5qLl9uZXcocC5wcm92aWRlcjMsIHAudmlzaWJpbGl0eTMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkNCA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTQsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajQgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajQgPSBpbmouX25ldyhwLnByb3ZpZGVyNCwgcC52aXNpYmlsaXR5NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQ1ID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5NSwgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqNSA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqNSA9IGluai5fbmV3KHAucHJvdmlkZXI1LCBwLnZpc2liaWxpdHk1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDYgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHk2LCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmo2ID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmo2ID0gaW5qLl9uZXcocC5wcm92aWRlcjYsIHAudmlzaWJpbGl0eTYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkNyA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTcsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajcgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajcgPSBpbmouX25ldyhwLnByb3ZpZGVyNywgcC52aXNpYmlsaXR5Nyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQ4ID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5OCwgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqOCA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqOCA9IGluai5fbmV3KHAucHJvdmlkZXI4LCBwLnZpc2liaWxpdHk4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDkgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHk5LCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmo5ID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmo5ID0gaW5qLl9uZXcocC5wcm92aWRlcjksIHAudmlzaWJpbGl0eTkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgIH07XHJcbiAgICBJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajE7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDMpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajQ7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDcpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajc7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5PdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcclxuICAgIH07XHJcbiAgICBJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSOyB9O1xyXG4gICAgcmV0dXJuIEluamVjdG9ySW5saW5lU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IEluamVjdG9ySW5saW5lU3RyYXRlZ3k7XHJcbnZhciBJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b1N0cmF0ZWd5LCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMucHJvdG9TdHJhdGVneSA9IHByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgICAgIHRoaXMub2JqcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocHJvdG9TdHJhdGVneS5wcm92aWRlcnMubGVuZ3RoKTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlsbCh0aGlzLm9ianMsIGV4cG9ydHMuVU5ERUZJTkVEKTtcclxuICAgIH1cclxuICAgIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xyXG4gICAgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmluc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHZpc2liaWxpdHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyLCB2aXNpYmlsaXR5KTtcclxuICAgIH07XHJcbiAgICBJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhcmVudCwgaXNIb3N0KSB7XHJcbiAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3I7XHJcbiAgICAgICAgaW5qLl9wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgaW5qLl9pc0hvc3QgPSBpc0hvc3Q7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQsIHZpc2liaWxpdHkpIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucHJvdG9TdHJhdGVneTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAua2V5SWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwLmtleUlkc1tpXSA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0aWVzW2ldLCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ianNbaV0gPSB0aGlzLmluamVjdG9yLl9uZXcocC5wcm92aWRlcnNbaV0sIHAudmlzaWJpbGl0aWVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVU5ERUZJTkVEO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm9ianMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm9ianNbaW5kZXhdO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9ianMubGVuZ3RoOyB9O1xyXG4gICAgcmV0dXJuIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xyXG59KSgpO1xyXG5leHBvcnRzLkluamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XHJcbnZhciBQcm92aWRlcldpdGhWaXNpYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyV2l0aFZpc2liaWxpdHkocHJvdmlkZXIsIHZpc2liaWxpdHkpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIFByb3ZpZGVyV2l0aFZpc2liaWxpdHkucHJvdG90eXBlLmdldEtleUlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcm92aWRlci5rZXkuaWQ7IH07XHJcbiAgICByZXR1cm4gUHJvdmlkZXJXaXRoVmlzaWJpbGl0eTtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm92aWRlcldpdGhWaXNpYmlsaXR5ID0gUHJvdmlkZXJXaXRoVmlzaWJpbGl0eTtcclxuLyoqXHJcbiAqIEEgZGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHVzZWQgZm9yIGluc3RhbnRpYXRpbmcgb2JqZWN0cyBhbmQgcmVzb2x2aW5nIGRlcGVuZGVuY2llcy5cclxuICpcclxuICogQW4gYEluamVjdG9yYCBpcyBhIHJlcGxhY2VtZW50IGZvciBhIGBuZXdgIG9wZXJhdG9yLCB3aGljaCBjYW4gYXV0b21hdGljYWxseSByZXNvbHZlIHRoZVxyXG4gKiBjb25zdHJ1Y3RvciBkZXBlbmRlbmNpZXMuXHJcbiAqXHJcbiAqIEluIHR5cGljYWwgdXNlLCBhcHBsaWNhdGlvbiBjb2RlIGFza3MgZm9yIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGV5IGFyZVxyXG4gKiByZXNvbHZlZCBieSB0aGUgYEluamVjdG9yYC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2p6amVjMD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhbiBgSW5qZWN0b3JgIGNvbmZpZ3VyZWQgdG8gY3JlYXRlIGBFbmdpbmVgIGFuZCBgQ2FyYC5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIEVuZ2luZSB7XHJcbiAqIH1cclxuICpcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBDYXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0NhciwgRW5naW5lXSk7XHJcbiAqIHZhciBjYXIgPSBpbmplY3Rvci5nZXQoQ2FyKTtcclxuICogZXhwZWN0KGNhciBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcclxuICogZXhwZWN0KGNhci5lbmdpbmUgaW5zdGFuY2VvZiBFbmdpbmUpLnRvQmUodHJ1ZSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RpY2UsIHdlIGRvbid0IHVzZSB0aGUgYG5ld2Agb3BlcmF0b3IgYmVjYXVzZSB3ZSBleHBsaWNpdGx5IHdhbnQgdG8gaGF2ZSB0aGUgYEluamVjdG9yYFxyXG4gKiByZXNvbHZlIGFsbCBvZiB0aGUgb2JqZWN0J3MgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkuXHJcbiAqL1xyXG52YXIgSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEluamVjdG9yKF9wcm90byAvKiBQcm90b0luamVjdG9yICovLCBfcGFyZW50LCBfZGVwUHJvdmlkZXIsIF9kZWJ1Z0NvbnRleHQpIHtcclxuICAgICAgICBpZiAoX3BhcmVudCA9PT0gdm9pZCAwKSB7IF9wYXJlbnQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKF9kZXBQcm92aWRlciA9PT0gdm9pZCAwKSB7IF9kZXBQcm92aWRlciA9IG51bGw7IH1cclxuICAgICAgICBpZiAoX2RlYnVnQ29udGV4dCA9PT0gdm9pZCAwKSB7IF9kZWJ1Z0NvbnRleHQgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5fZGVwUHJvdmlkZXIgPSBfZGVwUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fZGVidWdDb250ZXh0ID0gX2RlYnVnQ29udGV4dDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5faXNIb3N0ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBfcHJvdG8uX3N0cmF0ZWd5LmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFR1cm5zIGFuIGFycmF5IG9mIHByb3ZpZGVyIGRlZmluaXRpb25zIGludG8gYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqIEEgcmVzb2x1dGlvbiBpcyBhIHByb2Nlc3Mgb2YgZmxhdHRlbmluZyBtdWx0aXBsZSBuZXN0ZWQgYXJyYXlzIGFuZCBjb252ZXJ0aW5nIGluZGl2aWR1YWxcclxuICAgICAqIHByb3ZpZGVycyBpbnRvIGFuIGFycmF5IG9mIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfXMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0FpWFRIaT9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIEVuZ2luZSB7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgQ2FyIHtcclxuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHByb3ZpZGVycyA9IEluamVjdG9yLnJlc29sdmUoW0NhciwgW1tFbmdpbmVdXV0pO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChwcm92aWRlcnMubGVuZ3RoKS50b0VxdWFsKDIpO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0gaW5zdGFuY2VvZiBSZXNvbHZlZFByb3ZpZGVyKS50b0JlKHRydWUpO1xyXG4gICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5rZXkuZGlzcGxheU5hbWUpLnRvQmUoXCJDYXJcIik7XHJcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmRlcGVuZGVuY2llcy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmZhY3RvcnkpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KHByb3ZpZGVyc1sxXS5rZXkuZGlzcGxheU5hbWUpLnRvQmUoXCJFbmdpbmVcIik7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjZnJvbVJlc29sdmVkUHJvdmlkZXJzfSBmb3IgbW9yZSBpbmZvLlxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlcl8xLnJlc29sdmVQcm92aWRlcnMocHJvdmlkZXJzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHRob3NlIHByb3ZpZGVycy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcGFzc2VkLWluIHByb3ZpZGVycyBjYW4gYmUgYW4gYXJyYXkgb2YgYFR5cGVgLCB7QGxpbmsgUHJvdmlkZXJ9LFxyXG4gICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2VQT2NjQT9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIEVuZ2luZSB7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgQ2FyIHtcclxuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGZyb21SZXNvbHZlZFByb3ZpZGVyc2BcclxuICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cclxuICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtAbGluayBJbmplY3RvciNmcm9tUmVzb2x2ZWRQcm92aWRlcnN9LlxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVycyA9IEluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzKTtcclxuICAgICAgICByZXR1cm4gSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHJlc29sdmVkUHJvdmlkZXJzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LclNNY2k/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIENhciB7XHJcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBwcm92aWRlcnMgPSBJbmplY3Rvci5yZXNvbHZlKFtDYXIsIEVuZ2luZV0pO1xyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBiZCA9IHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIG5ldyBQcm92aWRlcldpdGhWaXNpYmlsaXR5KGIsIFZpc2liaWxpdHkuUHVibGljKTsgfSk7XHJcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IFByb3RvSW5qZWN0b3IoYmQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5qZWN0b3IocHJvdG8sIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IuZnJvbVJlc29sdmVkQmluZGluZ3MgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIEluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5kZWJ1Z0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWJ1Z0NvbnRleHQoKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGluamVjdG9yIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0b2tlbi5cclxuICAgICAqIFRocm93cyB7QGxpbmsgTm9Qcm92aWRlckVycm9yfSBpZiBub3QgZm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0hlWFNIZz9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBwcm92aWRlKFwidmFsaWRUb2tlblwiLCB7dXNlVmFsdWU6IFwiVmFsdWVcIn0pXHJcbiAgICAgKiBdKTtcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoXCJ2YWxpZFRva2VuXCIpKS50b0VxdWFsKFwiVmFsdWVcIik7XHJcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KFwiaW52YWxpZFRva2VuXCIpKS50b1Rocm93RXJyb3IoKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIGBJbmplY3RvcmAgcmV0dXJucyBpdHNlbGYgd2hlbiBnaXZlbiBgSW5qZWN0b3JgIGFzIGEgdG9rZW4uXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXSk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KEluamVjdG9yKSkudG9CZShpbmplY3Rvcik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShrZXlfMS5LZXkuZ2V0KHRva2VuKSwgbnVsbCwgbnVsbCwgZmFsc2UsIFZpc2liaWxpdHkuUHVibGljQW5kUHJpdmF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgaW5qZWN0b3IgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRva2VuLlxyXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdHBFYkV5P3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAgICAgKiAgIHByb3ZpZGUoXCJ2YWxpZFRva2VuXCIsIHt1c2VWYWx1ZTogXCJWYWx1ZVwifSlcclxuICAgICAqIF0pO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldE9wdGlvbmFsKFwidmFsaWRUb2tlblwiKSkudG9FcXVhbChcIlZhbHVlXCIpO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldE9wdGlvbmFsKFwiaW52YWxpZFRva2VuXCIpKS50b0JlKG51bGwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogYEluamVjdG9yYCByZXR1cm5zIGl0c2VsZiB3aGVuIGdpdmVuIGBJbmplY3RvcmAgYXMgYSB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtdKTtcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXRPcHRpb25hbChJbmplY3RvcikpLnRvQmUoaW5qZWN0b3IpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5nZXRPcHRpb25hbCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShrZXlfMS5LZXkuZ2V0KHRva2VuKSwgbnVsbCwgbnVsbCwgdHJ1ZSwgVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuZ2V0QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmdldE9iakF0SW5kZXgoaW5kZXgpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluamVjdG9yLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcmVudCBvZiB0aGlzIGluamVjdG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cclxuICAgICAgICAgKiAtLT5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lb3NNR28/cD1wcmV2aWV3KSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAgICAgKiB2YXIgcGFyZW50ID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXSk7XHJcbiAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbXSk7XHJcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLnBhcmVudCkudG9CZShwYXJlbnQpO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmplY3Rvci5wcm90b3R5cGUsIFwiaW50ZXJuYWxTdHJhdGVneVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICogSW50ZXJuYWwuIERvIG5vdCB1c2UuXHJcbiAgICAgICAgICogV2UgcmV0dXJuIGBhbnlgIG5vdCB0byBleHBvcnQgdGhlIEluamVjdG9yU3RyYXRlZ3kgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGEgY2hpbGQgaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cclxuICAgICAqIC0tPlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtAbGluayBQcm92aWRlcn0sXHJcbiAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvb3BCM1Q0P3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cclxuICAgICAqIGNsYXNzIENoaWxkUHJvdmlkZXIge31cclxuICAgICAqXHJcbiAgICAgKiB2YXIgcGFyZW50ID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbUGFyZW50UHJvdmlkZXJdKTtcclxuICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW0NoaWxkUHJvdmlkZXJdKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xyXG4gICAgICogZXhwZWN0KGNoaWxkLmdldChDaGlsZFByb3ZpZGVyKSBpbnN0YW5jZW9mIENoaWxkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNsb3dlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGBjcmVhdGVDaGlsZEZyb21SZXNvbHZlZGBcclxuICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cclxuICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtAbGluayBJbmplY3RvciNjcmVhdGVDaGlsZEZyb21SZXNvbHZlZH0uXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXJzID0gSW5qZWN0b3IucmVzb2x2ZShwcm92aWRlcnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKHJlc29sdmVkUHJvdmlkZXJzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBpbmplY3RvciBmcm9tIHByZXZpb3VzbHkgcmVzb2x2ZWQgcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXHJcbiAgICAgKiAtLT5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9WaHlmak4/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxyXG4gICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxyXG4gICAgICpcclxuICAgICAqIHZhciBwYXJlbnRQcm92aWRlcnMgPSBJbmplY3Rvci5yZXNvbHZlKFtQYXJlbnRQcm92aWRlcl0pO1xyXG4gICAgICogdmFyIGNoaWxkUHJvdmlkZXJzID0gSW5qZWN0b3IucmVzb2x2ZShbQ2hpbGRQcm92aWRlcl0pO1xyXG4gICAgICpcclxuICAgICAqIHZhciBwYXJlbnQgPSBJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocGFyZW50UHJvdmlkZXJzKTtcclxuICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZChjaGlsZFByb3ZpZGVycyk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikgaW5zdGFuY2VvZiBQYXJlbnRQcm92aWRlcikudG9CZSh0cnVlKTtcclxuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xyXG4gICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikpLnRvQmUocGFyZW50LmdldChQYXJlbnRQcm92aWRlcikpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcclxuICAgICAgICB2YXIgYmQgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBuZXcgUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShiLCBWaXNpYmlsaXR5LlB1YmxpYyk7IH0pO1xyXG4gICAgICAgIHZhciBwcm90byA9IG5ldyBQcm90b0luamVjdG9yKGJkKTtcclxuICAgICAgICB2YXIgaW5qID0gbmV3IEluamVjdG9yKHByb3RvLCBudWxsLCBudWxsKTtcclxuICAgICAgICBpbmouX3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGluajtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGEgcHJvdmlkZXIgYW5kIGluc3RhbnRpYXRlcyBhbiBvYmplY3QgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluamVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveXZWWG9CP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgRW5naW5lIHtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBDYXIge1xyXG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmVdKTtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcik7XHJcbiAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSkudG9CZShpbmplY3Rvci5nZXQoRW5naW5lKSk7XHJcbiAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlUmVzb2x2ZWQoSW5qZWN0b3IucmVzb2x2ZShbcHJvdmlkZXJdKVswXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gb2JqZWN0IHVzaW5nIGEgcmVzb2x2ZWQgcHJvdmlkZXIgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluamVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvcHRDSW1RP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgRW5naW5lIHtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBDYXIge1xyXG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmVdKTtcclxuICAgICAqIHZhciBjYXJQcm92aWRlciA9IEluamVjdG9yLnJlc29sdmUoW0Nhcl0pWzBdO1xyXG4gICAgICogdmFyIGNhciA9IGluamVjdG9yLmluc3RhbnRpYXRlUmVzb2x2ZWQoY2FyUHJvdmlkZXIpO1xyXG4gICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xyXG4gICAgICogZXhwZWN0KGNhcikubm90LnRvQmUoaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcikpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIsIFZpc2liaWxpdHkuUHVibGljQW5kUHJpdmF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHZpc2liaWxpdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29uc3RydWN0aW9uQ291bnRlcisrID4gdGhpcy5fc3RyYXRlZ3kuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5DeWNsaWNEZXBlbmRlbmN5RXJyb3IodGhpcywgcHJvdmlkZXIua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIsIHZpc2liaWxpdHkpO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5faW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuX2luc3RhbnRpYXRlKHByb3ZpZGVyLCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllc1tpXSwgdmlzaWJpbGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbMF0sIHZpc2liaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2luc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCByZXNvbHZlZEZhY3RvcnksIHZpc2liaWxpdHkpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHJlc29sdmVkRmFjdG9yeS5mYWN0b3J5O1xyXG4gICAgICAgIHZhciBkZXBzID0gcmVzb2x2ZWRGYWN0b3J5LmRlcGVuZGVuY2llcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gZGVwcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4LCBkMTk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZDAgPSBsZW5ndGggPiAwID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzBdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxID0gbGVuZ3RoID4gMSA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxXSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMiA9IGxlbmd0aCA+IDIgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMl0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDMgPSBsZW5ndGggPiAzID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzNdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQ0ID0gbGVuZ3RoID4gNCA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s0XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkNSA9IGxlbmd0aCA+IDUgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNV0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDYgPSBsZW5ndGggPiA2ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzZdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQ3ID0gbGVuZ3RoID4gNyA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s3XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkOCA9IGxlbmd0aCA+IDggPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOF0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDkgPSBsZW5ndGggPiA5ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzldLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxMCA9IGxlbmd0aCA+IDEwID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEwXSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTEgPSBsZW5ndGggPiAxMSA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMV0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDEyID0gbGVuZ3RoID4gMTIgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTJdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxMyA9IGxlbmd0aCA+IDEzID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEzXSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTQgPSBsZW5ndGggPiAxNCA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNF0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDE1ID0gbGVuZ3RoID4gMTUgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTVdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxNiA9IGxlbmd0aCA+IDE2ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE2XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTcgPSBsZW5ndGggPiAxNyA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxN10sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDE4ID0gbGVuZ3RoID4gMTggPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMThdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxOSA9IGxlbmd0aCA+IDE5ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE5XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5BYnN0cmFjdFByb3ZpZGVyRXJyb3IgfHwgZSBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5JbnN0YW50aWF0aW9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGUuYWRkS2V5KHRoaXMsIHByb3ZpZGVyLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9iajtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3LCBkMTgsIGQxOSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5JbnN0YW50aWF0aW9uRXJyb3IodGhpcywgZSwgZS5zdGFjaywgcHJvdmlkZXIua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2dldEJ5RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChwcm92aWRlciwgZGVwLCBwcm92aWRlclZpc2liaWxpdHkpIHtcclxuICAgICAgICB2YXIgc3BlY2lhbCA9IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZGVwUHJvdmlkZXIpID9cclxuICAgICAgICAgICAgdGhpcy5fZGVwUHJvdmlkZXIuZ2V0RGVwZW5kZW5jeSh0aGlzLCBwcm92aWRlciwgZGVwKSA6XHJcbiAgICAgICAgICAgIGV4cG9ydHMuVU5ERUZJTkVEO1xyXG4gICAgICAgIGlmIChzcGVjaWFsICE9PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3BlY2lhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShkZXAua2V5LCBkZXAubG93ZXJCb3VuZFZpc2liaWxpdHksIGRlcC51cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwLm9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2dldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBvcHRpb25hbCwgcHJvdmlkZXJWaXNpYmlsaXR5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gSU5KRUNUT1JfS0VZKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXBwZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLlNlbGZNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlTZWxmKGtleSwgb3B0aW9uYWwsIHByb3ZpZGVyVmlzaWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHVwcGVyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ib3N0TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5SG9zdChrZXksIG9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHksIGxvd2VyQm91bmRWaXNpYmlsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleURlZmF1bHQoa2V5LCBvcHRpb25hbCwgcHJvdmlkZXJWaXNpYmlsaXR5LCBsb3dlckJvdW5kVmlzaWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5fdGhyb3dPck51bGwgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25hbCkge1xyXG4gICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuTm9Qcm92aWRlckVycm9yKHRoaXMsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5fZ2V0QnlLZXlTZWxmID0gZnVuY3Rpb24gKGtleSwgb3B0aW9uYWwsIHByb3ZpZGVyVmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLl9zdHJhdGVneS5nZXRPYmpCeUtleUlkKGtleS5pZCwgcHJvdmlkZXJWaXNpYmlsaXR5KTtcclxuICAgICAgICByZXR1cm4gKG9iaiAhPT0gZXhwb3J0cy5VTkRFRklORUQpID8gb2JqIDogdGhpcy5fdGhyb3dPck51bGwoa2V5LCBvcHRpb25hbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl9nZXRCeUtleUhvc3QgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25hbCwgcHJvdmlkZXJWaXNpYmlsaXR5LCBsb3dlckJvdW5kVmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBpbmogPSB0aGlzO1xyXG4gICAgICAgIGlmIChsb3dlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuU2tpcFNlbGZNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoaW5qLl9pc0hvc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcml2YXRlRGVwZW5kZW5jeShrZXksIG9wdGlvbmFsLCBpbmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5qID0gaW5qLl9wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGluaiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBpbmouX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkLCBwcm92aWRlclZpc2liaWxpdHkpO1xyXG4gICAgICAgICAgICBpZiAob2JqICE9PSBleHBvcnRzLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGluai5fcGFyZW50KSAmJiBpbmouX2lzSG9zdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByaXZhdGVEZXBlbmRlbmN5KGtleSwgb3B0aW9uYWwsIGluaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmogPSBpbmouX3BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dPck51bGwoa2V5LCBvcHRpb25hbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl9nZXRQcml2YXRlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbmFsLCBpbmopIHtcclxuICAgICAgICB2YXIgb2JqID0gaW5qLl9wYXJlbnQuX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkLCBWaXNpYmlsaXR5LlByaXZhdGUpO1xyXG4gICAgICAgIHJldHVybiAob2JqICE9PSBleHBvcnRzLlVOREVGSU5FRCkgPyBvYmogOiB0aGlzLl90aHJvd09yTnVsbChrZXksIG9wdGlvbmFsKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2dldEJ5S2V5RGVmYXVsdCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHksIGxvd2VyQm91bmRWaXNpYmlsaXR5KSB7XHJcbiAgICAgICAgdmFyIGluaiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxvd2VyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ta2lwU2VsZk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyVmlzaWJpbGl0eSA9IGluai5faXNIb3N0ID8gVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlIDogVmlzaWJpbGl0eS5QdWJsaWM7XHJcbiAgICAgICAgICAgIGluaiA9IGluai5fcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaW5qICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGluai5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQsIHByb3ZpZGVyVmlzaWJpbGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChvYmogIT09IGV4cG9ydHMuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgcHJvdmlkZXJWaXNpYmlsaXR5ID0gaW5qLl9pc0hvc3QgPyBWaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUgOiBWaXNpYmlsaXR5LlB1YmxpYztcclxuICAgICAgICAgICAgaW5qID0gaW5qLl9wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90aHJvd09yTnVsbChrZXksIG9wdGlvbmFsKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5qZWN0b3IucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiSW5qZWN0b3IocHJvdmlkZXJzOiBbXCIgKyBfbWFwUHJvdmlkZXJzKHRoaXMsIGZ1bmN0aW9uIChiKSB7IHJldHVybiAoXCIgXFxcIlwiICsgYi5rZXkuZGlzcGxheU5hbWUgKyBcIlxcXCIgXCIpOyB9KS5qb2luKFwiLCBcIikgKyBcIl0pXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lOyB9O1xyXG4gICAgcmV0dXJuIEluamVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLkluamVjdG9yID0gSW5qZWN0b3I7XHJcbnZhciBJTkpFQ1RPUl9LRVkgPSBrZXlfMS5LZXkuZ2V0KEluamVjdG9yKTtcclxuZnVuY3Rpb24gX21hcFByb3ZpZGVycyhpbmplY3RvciwgZm4pIHtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0b3IuX3Byb3RvLm51bWJlck9mUHJvdmlkZXJzOyArK2kpIHtcclxuICAgICAgICByZXMucHVzaChmbihpbmplY3Rvci5fcHJvdG8uZ2V0UHJvdmlkZXJBdEluZGV4KGkpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciB0eXBlX2xpdGVyYWxfMSA9IHJlcXVpcmUoJy4vdHlwZV9saXRlcmFsJyk7XHJcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi9mb3J3YXJkX3JlZicpO1xyXG52YXIgdHlwZV9saXRlcmFsXzIgPSByZXF1aXJlKCcuL3R5cGVfbGl0ZXJhbCcpO1xyXG5leHBvcnRzLlR5cGVMaXRlcmFsID0gdHlwZV9saXRlcmFsXzIuVHlwZUxpdGVyYWw7XHJcbi8qKlxyXG4gKiBBIHVuaXF1ZSBvYmplY3QgdXNlZCBmb3IgcmV0cmlldmluZyBpdGVtcyBmcm9tIHRoZSB7QGxpbmsgSW5qZWN0b3J9LlxyXG4gKlxyXG4gKiBLZXlzIGhhdmU6XHJcbiAqIC0gYSBzeXN0ZW0td2lkZSB1bmlxdWUgYGlkYC5cclxuICogLSBhIGB0b2tlbmAuXHJcbiAqXHJcbiAqIGBLZXlgIGlzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgSW5qZWN0b3J9IGJlY2F1c2UgaXRzIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgIGFsbG93cyB0aGVcclxuICogaW5qZWN0b3IgdG8gc3RvcmUgY3JlYXRlZCBvYmplY3RzIGluIGEgbW9yZSBlZmZpY2llbnQgd2F5LlxyXG4gKlxyXG4gKiBgS2V5YCBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZGlyZWN0bHkuIHtAbGluayBJbmplY3Rvcn0gY3JlYXRlcyBrZXlzIGF1dG9tYXRpY2FsbHkgd2hlbiByZXNvbHZpbmdcclxuICogcHJvdmlkZXJzLlxyXG4gKi9cclxudmFyIEtleSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gS2V5KHRva2VuLCBpZCkge1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRva2VuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1Rva2VuIG11c3QgYmUgZGVmaW5lZCEnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5LnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZ2lmaWVkIHRva2VuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLnN0cmluZ2lmeSh0aGlzLnRva2VuKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGBLZXlgIGZvciBhIHRva2VuLlxyXG4gICAgICovXHJcbiAgICBLZXkuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkuZ2V0KGZvcndhcmRfcmVmXzEucmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pKTsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXksIFwibnVtYmVyT2ZLZXlzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleXMgcmVnaXN0ZXJlZCBpbiB0aGUgc3lzdGVtLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5Lm51bWJlck9mS2V5czsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gS2V5O1xyXG59KSgpO1xyXG5leHBvcnRzLktleSA9IEtleTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIEtleVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEtleVJlZ2lzdHJ5KCkge1xyXG4gICAgICAgIHRoaXMuX2FsbEtleXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBLZXlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgS2V5KVxyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgLy8gVE9ETzogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTIzXHJcbiAgICAgICAgdmFyIHRoZVRva2VuID0gdG9rZW47XHJcbiAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgdHlwZV9saXRlcmFsXzEuVHlwZUxpdGVyYWwpIHtcclxuICAgICAgICAgICAgdGhlVG9rZW4gPSB0b2tlbi50eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2tlbiA9IHRoZVRva2VuO1xyXG4gICAgICAgIGlmICh0aGlzLl9hbGxLZXlzLmhhcyh0b2tlbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbEtleXMuZ2V0KHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld0tleSA9IG5ldyBLZXkodG9rZW4sIEtleS5udW1iZXJPZktleXMpO1xyXG4gICAgICAgIHRoaXMuX2FsbEtleXMuc2V0KHRva2VuLCBuZXdLZXkpO1xyXG4gICAgICAgIHJldHVybiBuZXdLZXk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleVJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJudW1iZXJPZktleXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWxsS2V5cy5zaXplOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBLZXlSZWdpc3RyeTtcclxufSkoKTtcclxuZXhwb3J0cy5LZXlSZWdpc3RyeSA9IEtleVJlZ2lzdHJ5O1xyXG52YXIgX2dsb2JhbEtleVJlZ2lzdHJ5ID0gbmV3IEtleVJlZ2lzdHJ5KCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZ1wiKTtcclxuLyoqXHJcbiAqIEEgcGFyYW1ldGVyIG1ldGFkYXRhIHRoYXQgc3BlY2lmaWVzIGEgZGVwZW5kZW5jeS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzZ1SFlKSz9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEVuZ2luZSB7fVxyXG4gKlxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIENhciB7XHJcbiAqICAgZW5naW5lO1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBJbmplY3QoXCJNeUVuZ2luZVwiKSBlbmdpbmU6RW5naW5lKSB7XHJcbiAqICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAqICBwcm92aWRlKFwiTXlFbmdpbmVcIiwge3VzZUNsYXNzOiBFbmdpbmV9KSxcclxuICogIENhclxyXG4gKiBdKTtcclxuICpcclxuICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFdoZW4gYEBJbmplY3QoKWAgaXMgbm90IHByZXNlbnQsIHtAbGluayBJbmplY3Rvcn0gd2lsbCB1c2UgdGhlIHR5cGUgYW5ub3RhdGlvbiBvZiB0aGUgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEVuZ2luZSB7fVxyXG4gKlxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIENhciB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTogRW5naW5lKSB7fSAvL3NhbWUgYXMgY29uc3RydWN0b3IoQEluamVjdChFbmdpbmUpIGVuZ2luZTpFbmdpbmUpXHJcbiAqIH1cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRW5naW5lLCBDYXJdKTtcclxuICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSW5qZWN0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5qZWN0TWV0YWRhdGEodG9rZW4pIHtcclxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICB9XHJcbiAgICBJbmplY3RNZXRhZGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkBJbmplY3QoXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHRoaXMudG9rZW4pICsgXCIpXCI7IH07XHJcbiAgICBJbmplY3RNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgSW5qZWN0TWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIEluamVjdE1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkluamVjdE1ldGFkYXRhID0gSW5qZWN0TWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBBIHBhcmFtZXRlciBtZXRhZGF0YSB0aGF0IG1hcmtzIGEgZGVwZW5kZW5jeSBhcyBvcHRpb25hbC4ge0BsaW5rIEluamVjdG9yfSBwcm92aWRlcyBgbnVsbGAgaWZcclxuICogdGhlIGRlcGVuZGVuY3kgaXMgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQXNyeU9tP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgRW5naW5lIHt9XHJcbiAqXHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgQ2FyIHtcclxuICogICBlbmdpbmU7XHJcbiAqICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgZW5naW5lOkVuZ2luZSkge1xyXG4gKiAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0Nhcl0pO1xyXG4gKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikuZW5naW5lKS50b0JlTnVsbCgpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBPcHRpb25hbE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9wdGlvbmFsTWV0YWRhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBPcHRpb25hbE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQE9wdGlvbmFsKClcIjsgfTtcclxuICAgIE9wdGlvbmFsTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIE9wdGlvbmFsTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIE9wdGlvbmFsTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuT3B0aW9uYWxNZXRhZGF0YSA9IE9wdGlvbmFsTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBgRGVwZW5kZW5jeU1ldGFkYXRhYCBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgdG8gZXh0ZW5kIERJLlxyXG4gKiBUaGlzIGlzIGludGVybmFsIHRvIEFuZ3VsYXIgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS5cclxuICovXHJcbnZhciBEZXBlbmRlbmN5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVwZW5kZW5jeU1ldGFkYXRhKCkge1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlcGVuZGVuY3lNZXRhZGF0YS5wcm90b3R5cGUsIFwidG9rZW5cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEZXBlbmRlbmN5TWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIERlcGVuZGVuY3lNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gRGVwZW5kZW5jeU1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkRlcGVuZGVuY3lNZXRhZGF0YSA9IERlcGVuZGVuY3lNZXRhZGF0YTtcclxuLyoqXHJcbiAqIEEgbWFya2VyIG1ldGFkYXRhIHRoYXQgbWFya3MgYSBjbGFzcyBhcyBhdmFpbGFibGUgdG8ge0BsaW5rIEluamVjdG9yfSBmb3IgY3JlYXRpb24uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9XazRETVE/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIFVzZWZ1bFNlcnZpY2Uge31cclxuICpcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBOZWVkc1NlcnZpY2Uge1xyXG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXJ2aWNlOlVzZWZ1bFNlcnZpY2UpIHt9XHJcbiAqIH1cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbTmVlZHNTZXJ2aWNlLCBVc2VmdWxTZXJ2aWNlXSk7XHJcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQoTmVlZHNTZXJ2aWNlKS5zZXJ2aWNlIGluc3RhbmNlb2YgVXNlZnVsU2VydmljZSkudG9CZSh0cnVlKTtcclxuICogYGBgXHJcbiAqIHtAbGluayBJbmplY3Rvcn0gd2lsbCB0aHJvdyB7QGxpbmsgTm9Bbm5vdGF0aW9uRXJyb3J9IHdoZW4gdHJ5aW5nIHRvIGluc3RhbnRpYXRlIGEgY2xhc3MgdGhhdFxyXG4gKiBkb2VzIG5vdCBoYXZlIGBASW5qZWN0YWJsZWAgbWFya2VyLCBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBVc2VmdWxTZXJ2aWNlIHt9XHJcbiAqXHJcbiAqIGNsYXNzIE5lZWRzU2VydmljZSB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIHNlcnZpY2U6VXNlZnVsU2VydmljZSkge31cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtOZWVkc1NlcnZpY2UsIFVzZWZ1bFNlcnZpY2VdKTtcclxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChOZWVkc1NlcnZpY2UpKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSW5qZWN0YWJsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluamVjdGFibGVNZXRhZGF0YSgpIHtcclxuICAgIH1cclxuICAgIEluamVjdGFibGVNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgSW5qZWN0YWJsZU1ldGFkYXRhKTtcclxuICAgIHJldHVybiBJbmplY3RhYmxlTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5qZWN0YWJsZU1ldGFkYXRhID0gSW5qZWN0YWJsZU1ldGFkYXRhO1xyXG4vKipcclxuICogU3BlY2lmaWVzIHRoYXQgYW4ge0BsaW5rIEluamVjdG9yfSBzaG91bGQgcmV0cmlldmUgYSBkZXBlbmRlbmN5IG9ubHkgZnJvbSBpdHNlbGYuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9OZWFnQWc/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBEZXBlbmRlbmN5IHtcclxuICogfVxyXG4gKlxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIE5lZWRzRGVwZW5kZW5jeSB7XHJcbiAqICAgZGVwZW5kZW5jeTtcclxuXHJcbiAqICAgZGVwZW5kZW5jeTtcclxuICogICBjb25zdHJ1Y3RvcihAU2VsZigpIGRlcGVuZGVuY3k6RGVwZW5kZW5jeSkge1xyXG4gKiAgICAgdGhpcy5kZXBlbmRlbmN5ID0gZGVwZW5kZW5jeTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogdmFyIGluaiA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ksIE5lZWRzRGVwZW5kZW5jeV0pO1xyXG4gKiB2YXIgbmQgPSBpbmouZ2V0KE5lZWRzRGVwZW5kZW5jeSk7XHJcbiAqXHJcbiAqIGV4cGVjdChuZC5kZXBlbmRlbmN5IGluc3RhbmNlb2YgRGVwZW5kZW5jeSkudG9CZSh0cnVlKTtcclxuICpcclxuICogdmFyIGluaiA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ldKTtcclxuICogdmFyIGNoaWxkID0gaW5qLnJlc29sdmVBbmRDcmVhdGVDaGlsZChbTmVlZHNEZXBlbmRlbmN5XSk7XHJcbiAqIGV4cGVjdCgoKSA9PiBjaGlsZC5nZXQoTmVlZHNEZXBlbmRlbmN5KSkudG9UaHJvd0Vycm9yKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFNlbGZNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxmTWV0YWRhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBTZWxmTWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAU2VsZigpXCI7IH07XHJcbiAgICBTZWxmTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFNlbGZNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gU2VsZk1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGZNZXRhZGF0YSA9IFNlbGZNZXRhZGF0YTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGF0IHRoZSBkZXBlbmRlbmN5IHJlc29sdXRpb24gc2hvdWxkIHN0YXJ0IGZyb20gdGhlIHBhcmVudCBpbmplY3Rvci5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1djaGR6Yj9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIERlcGVuZGVuY3kge1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgTmVlZHNEZXBlbmRlbmN5IHtcclxuICogICBkZXBlbmRlbmN5O1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBTa2lwU2VsZigpIGRlcGVuZGVuY3k6RGVwZW5kZW5jeSkge1xyXG4gKiAgICAgdGhpcy5kZXBlbmRlbmN5ID0gZGVwZW5kZW5jeTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogdmFyIHBhcmVudCA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ldKTtcclxuICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbTmVlZHNEZXBlbmRlbmN5XSk7XHJcbiAqIGV4cGVjdChjaGlsZC5nZXQoTmVlZHNEZXBlbmRlbmN5KS5kZXBlbmRlbmN5IGluc3RhbmNlb2YgRGVwZWRlbmN5KS50b0JlKHRydWUpO1xyXG4gKlxyXG4gKiB2YXIgaW5qID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRGVwZW5kZW5jeSwgTmVlZHNEZXBlbmRlbmN5XSk7XHJcbiAqIGV4cGVjdCgoKSA9PiBpbmouZ2V0KE5lZWRzRGVwZW5kZW5jeSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBTa2lwU2VsZk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNraXBTZWxmTWV0YWRhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBTa2lwU2VsZk1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQFNraXBTZWxmKClcIjsgfTtcclxuICAgIFNraXBTZWxmTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFNraXBTZWxmTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIFNraXBTZWxmTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2tpcFNlbGZNZXRhZGF0YSA9IFNraXBTZWxmTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgdGhhdCBhbiBpbmplY3RvciBzaG91bGQgcmV0cmlldmUgYSBkZXBlbmRlbmN5IGZyb20gYW55IGluamVjdG9yIHVudGlsIHJlYWNoaW5nIHRoZVxyXG4gKiBjbG9zZXN0IGhvc3QuXHJcbiAqXHJcbiAqIEluIEFuZ3VsYXIsIGEgY29tcG9uZW50IGVsZW1lbnQgaXMgYXV0b21hdGljYWxseSBkZWNsYXJlZCBhcyBhIGhvc3QgZm9yIGFsbCB0aGUgaW5qZWN0b3JzIGluXHJcbiAqIGl0cyB2aWV3LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvR1g3OXBWP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSBgQXBwYCBjb250YWlucyBgUGFyZW50Q21wYCwgd2hpY2ggY29udGFpbnMgYENoaWxkRGlyZWN0aXZlYC5cclxuICogU28gYFBhcmVudENtcGAgaXMgdGhlIGhvc3Qgb2YgYENoaWxkRGlyZWN0aXZlYC5cclxuICpcclxuICogYENoaWxkRGlyZWN0aXZlYCBkZXBlbmRzIG9uIHR3byBzZXJ2aWNlczogYEhvc3RTZXJ2aWNlYCBhbmQgYE90aGVyU2VydmljZWAuXHJcbiAqIGBIb3N0U2VydmljZWAgaXMgZGVmaW5lZCBhdCBgUGFyZW50Q21wYCwgYW5kIGBPdGhlclNlcnZpY2VgIGlzIGRlZmluZWQgYXQgYEFwcGAuXHJcbiAqXHJcbiAqYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBPdGhlclNlcnZpY2Uge31cclxuICogY2xhc3MgSG9zdFNlcnZpY2Uge31cclxuICpcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1kaXJlY3RpdmUnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIENoaWxkRGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASG9zdCgpIG9zOk90aGVyU2VydmljZSwgQE9wdGlvbmFsKCkgQEhvc3QoKSBoczpIb3N0U2VydmljZSl7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9zIGlzIG51bGxcIiwgb3MpO1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJocyBpcyBOT1QgbnVsbFwiLCBocyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAncGFyZW50LWNtcCcsXHJcbiAqICAgcHJvdmlkZXJzOiBbSG9zdFNlcnZpY2VdLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICBEaXI6IDxjaGlsZC1kaXJlY3RpdmU+PC9jaGlsZC1kaXJlY3RpdmU+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbQ2hpbGREaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFBhcmVudENtcCB7XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHByb3ZpZGVyczogW090aGVyU2VydmljZV0sXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIFBhcmVudDogPHBhcmVudC1jbXA+PC9wYXJlbnQtY21wPlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW1BhcmVudENtcF1cclxuICogfSlcclxuICogY2xhc3MgQXBwIHtcclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICpgYGBcclxuICovXHJcbnZhciBIb3N0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSG9zdE1ldGFkYXRhKCkge1xyXG4gICAgfVxyXG4gICAgSG9zdE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEhvc3QoKVwiOyB9O1xyXG4gICAgSG9zdE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBIb3N0TWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIEhvc3RNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5Ib3N0TWV0YWRhdGEgPSBIb3N0TWV0YWRhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgREkgUHJvdmlkZXIuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9ZczllelhwajJNbm95M1VjOEtCcD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIHZhciB0ID0gbmV3IE9wYXF1ZVRva2VuKFwidmFsdWVcIik7XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gKiAgIHByb3ZpZGUodCwge3VzZVZhbHVlOiBcInByb3ZpZGVkVmFsdWVcIn0pXHJcbiAqIF0pO1xyXG4gKlxyXG4gKiBleHBlY3QoaW5qZWN0b3IuZ2V0KHQpKS50b0VxdWFsKFwiYmluZGluZ1ZhbHVlXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIHN0cmluZ3MgYXMgdG9rZW5zIGJlY2F1c2Ugb2YgcG9zc2libGUgY29sbGlzaW9uc1xyXG4gKiBjYXVzZWQgYnkgbXVsdGlwbGUgcHJvdmlkZXJzIHVzaW5nIHRoZSBzYW1lIHN0cmluZyBhcyB0d28gZGlmZmVyZW50IHRva2Vucy5cclxuICpcclxuICogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIGFuIGBPYmplY3RgIGFzIHRva2VucyBiZWNhdXNlIGl0IHByb3ZpZGVzIGJldHRlclxyXG4gKiBlcnJvciBtZXNzYWdlcy5cclxuICovXHJcbnZhciBPcGFxdWVUb2tlbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPcGFxdWVUb2tlbihfZGVzYykge1xyXG4gICAgICAgIHRoaXMuX2Rlc2MgPSBfZGVzYztcclxuICAgIH1cclxuICAgIE9wYXF1ZVRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVG9rZW4gXCIgKyB0aGlzLl9kZXNjOyB9O1xyXG4gICAgT3BhcXVlVG9rZW4gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIE9wYXF1ZVRva2VuKTtcclxuICAgIHJldHVybiBPcGFxdWVUb2tlbjtcclxufSkoKTtcclxuZXhwb3J0cy5PcGFxdWVUb2tlbiA9IE9wYXF1ZVRva2VuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWVfdG9rZW4uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxudmFyIGtleV8xID0gcmVxdWlyZSgnLi9rZXknKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCcuL21ldGFkYXRhJyk7XHJcbnZhciBleGNlcHRpb25zXzIgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbnMnKTtcclxudmFyIGZvcndhcmRfcmVmXzEgPSByZXF1aXJlKCcuL2ZvcndhcmRfcmVmJyk7XHJcbnZhciBEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IG9wdGlvbmFsO1xyXG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFZpc2liaWxpdHkgPSBsb3dlckJvdW5kVmlzaWJpbGl0eTtcclxuICAgICAgICB0aGlzLnVwcGVyQm91bmRWaXNpYmlsaXR5ID0gdXBwZXJCb3VuZFZpc2liaWxpdHk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuICAgIH1cclxuICAgIERlcGVuZGVuY3kuZnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG5ldyBEZXBlbmRlbmN5KGtleSwgZmFsc2UsIG51bGwsIG51bGwsIFtdKTsgfTtcclxuICAgIHJldHVybiBEZXBlbmRlbmN5O1xyXG59KSgpO1xyXG5leHBvcnRzLkRlcGVuZGVuY3kgPSBEZXBlbmRlbmN5O1xyXG52YXIgX0VNUFRZX0xJU1QgPSBsYW5nXzEuQ09OU1RfRVhQUihbXSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgaG93IHRoZSB7QGxpbmsgSW5qZWN0b3J9IHNob3VsZCBpbnN0YW50aWF0ZSBhIGdpdmVuIHRva2VuLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIHByb3ZpZGV9LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvR05BeWo2SzZQZllnMk5Cemd3WjU/cCUzRHByZXZpZXcmcD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICogICBuZXcgUHJvdmlkZXIoXCJtZXNzYWdlXCIsIHsgdXNlVmFsdWU6ICdIZWxsbycgfSlcclxuICogXSk7XHJcbiAqXHJcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQoXCJtZXNzYWdlXCIpKS50b0VxdWFsKCdIZWxsbycpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm92aWRlcih0b2tlbiwgX2EpIHtcclxuICAgICAgICB2YXIgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XHJcbiAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xyXG4gICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcclxuICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcztcclxuICAgICAgICB0aGlzLl9tdWx0aSA9IG11bHRpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyLnByb3RvdHlwZSwgXCJtdWx0aVwiLCB7XHJcbiAgICAgICAgLy8gVE9ETzogUHJvdmlkZSBhIGZ1bGwgd29ya2luZyBleGFtcGxlIGFmdGVyIGFscGhhMzggaXMgcmVsZWFzZWQuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBtdWx0aXBsZSBwcm92aWRlcnMgbWF0Y2hpbmcgdGhlIHNhbWUgdG9rZW4gKGEgbXVsdGktcHJvdmlkZXIpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTXVsdGktcHJvdmlkZXJzIGFyZSB1c2VkIGZvciBjcmVhdGluZyBwbHVnZ2FibGUgc2VydmljZSwgd2hlcmUgdGhlIHN5c3RlbSBjb21lc1xyXG4gICAgICAgICAqIHdpdGggc29tZSBkZWZhdWx0IHByb3ZpZGVycywgYW5kIHRoZSB1c2VyIGNhbiByZWdpc3RlciBhZGRpdG9uYWwgcHJvdmlkZXJzLlxyXG4gICAgICAgICAqIFRoZSBjb21iaW5hdGlvbiBvZiB0aGUgZGVmYXVsdCBwcm92aWRlcnMgYW5kIHRoZSBhZGRpdGlvbmFsIHByb3ZpZGVycyB3aWxsIGJlXHJcbiAgICAgICAgICogdXNlZCB0byBkcml2ZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHN5c3RlbS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICMjIyBFeGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAgICAgICAgICogICBuZXcgUHJvdmlkZXIoXCJTdHJpbmdzXCIsIHsgdXNlVmFsdWU6IFwiU3RyaW5nMVwiLCBtdWx0aTogdHJ1ZX0pLFxyXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzJcIiwgbXVsdGk6IHRydWV9KVxyXG4gICAgICAgICAqIF0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChcIlN0cmluZ3NcIikpLnRvRXF1YWwoW1wiU3RyaW5nMVwiLCBcIlN0cmluZzJcIl0pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTXVsdGktcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycyBjYW5ub3QgYmUgbWl4ZWQuIFRoZSBmb2xsb3dpbmdcclxuICAgICAgICAgKiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbjpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAgICAgKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwgeyB1c2VWYWx1ZTogXCJTdHJpbmcxXCIsIG11bHRpOiB0cnVlIH0pLFxyXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzJcIn0pXHJcbiAgICAgICAgICogXSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEubm9ybWFsaXplQm9vbCh0aGlzLl9tdWx0aSk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUHJvdmlkZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0LCBPYmplY3RdKVxyXG4gICAgXSwgUHJvdmlkZXIpO1xyXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxudmFyIEJpbmRpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJpbmRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCaW5kaW5nKHRva2VuLCBfYSkge1xyXG4gICAgICAgIHZhciB0b0NsYXNzID0gX2EudG9DbGFzcywgdG9WYWx1ZSA9IF9hLnRvVmFsdWUsIHRvQWxpYXMgPSBfYS50b0FsaWFzLCB0b0ZhY3RvcnkgPSBfYS50b0ZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRva2VuLCB7XHJcbiAgICAgICAgICAgIHVzZUNsYXNzOiB0b0NsYXNzLFxyXG4gICAgICAgICAgICB1c2VWYWx1ZTogdG9WYWx1ZSxcclxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRvQWxpYXMsXHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHRvRmFjdG9yeSxcclxuICAgICAgICAgICAgZGVwczogZGVwcyxcclxuICAgICAgICAgICAgbXVsdGk6IG11bHRpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9DbGFzc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXNlQ2xhc3M7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmcucHJvdG90eXBlLCBcInRvQWxpYXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVzZUV4aXN0aW5nOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCaW5kaW5nLnByb3RvdHlwZSwgXCJ0b0ZhY3RvcnlcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVzZUZhY3Rvcnk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmcucHJvdG90eXBlLCBcInRvVmFsdWVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVzZVZhbHVlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEJpbmRpbmcgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0LCBPYmplY3RdKVxyXG4gICAgXSwgQmluZGluZyk7XHJcbiAgICByZXR1cm4gQmluZGluZztcclxufSkoUHJvdmlkZXIpO1xyXG5leHBvcnRzLkJpbmRpbmcgPSBCaW5kaW5nO1xyXG52YXIgUmVzb2x2ZWRQcm92aWRlcl8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVzb2x2ZWRQcm92aWRlcl8oa2V5LCByZXNvbHZlZEZhY3RvcmllcywgbXVsdGlQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZWRGYWN0b3JpZXMgPSByZXNvbHZlZEZhY3RvcmllcztcclxuICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc29sdmVkUHJvdmlkZXJfLnByb3RvdHlwZSwgXCJyZXNvbHZlZEZhY3RvcnlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZXNvbHZlZEZhY3Rvcmllc1swXTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUmVzb2x2ZWRQcm92aWRlcl87XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVzb2x2ZWRQcm92aWRlcl8gPSBSZXNvbHZlZFByb3ZpZGVyXztcclxuLyoqXHJcbiAqIEFuIGludGVybmFsIHJlc29sdmVkIHJlcHJlc2VudGF0aW9uIG9mIGEgZmFjdG9yeSBmdW5jdGlvbiBjcmVhdGVkIGJ5IHJlc29sdmluZyB7QGxpbmsgUHJvdmlkZXJ9LlxyXG4gKi9cclxudmFyIFJlc29sdmVkRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXNvbHZlZEZhY3RvcnkoXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCByZXByZXNlbnRlZCBieSBhIGtleS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmYWN0b3J5LCBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcmd1bWVudHMgKGRlcGVuZGVuY2llcykgdG8gdGhlIGBmYWN0b3J5YCBmdW5jdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc29sdmVkRmFjdG9yeTtcclxufSkoKTtcclxuZXhwb3J0cy5SZXNvbHZlZEZhY3RvcnkgPSBSZXNvbHZlZEZhY3Rvcnk7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFByb3ZpZGVyfS5cclxuICpcclxuICogVG8gY29uc3RydWN0IGEge0BsaW5rIFByb3ZpZGVyfSwgYmluZCBhIGB0b2tlbmAgdG8gZWl0aGVyIGEgY2xhc3MsIGEgdmFsdWUsIGEgZmFjdG9yeSBmdW5jdGlvbixcclxuICogb3JcclxuICogdG8gYW4gZXhpc3RpbmcgYHRva2VuYC5cclxuICogU2VlIHtAbGluayBQcm92aWRlckJ1aWxkZXJ9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFRoZSBgdG9rZW5gIGlzIG1vc3QgY29tbW9ubHkgYSBjbGFzcyBvciB7QGxpbmsgYW5ndWxhcjIvZGkvT3BhcXVlVG9rZW59LlxyXG4gKi9cclxuZnVuY3Rpb24gYmluZCh0b2tlbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckJ1aWxkZXIodG9rZW4pO1xyXG59XHJcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFByb3ZpZGVyfS5cclxuICpcclxuICogU2VlIHtAbGluayBQcm92aWRlcn0gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogPCEtLSBUT0RPOiBpbXByb3ZlIHRoZSBkb2NzIC0tPlxyXG4gKi9cclxuZnVuY3Rpb24gcHJvdmlkZSh0b2tlbiwgX2EpIHtcclxuICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XHJcbiAgICByZXR1cm4gbmV3IFByb3ZpZGVyKHRva2VuLCB7XHJcbiAgICAgICAgdXNlQ2xhc3M6IHVzZUNsYXNzLFxyXG4gICAgICAgIHVzZVZhbHVlOiB1c2VWYWx1ZSxcclxuICAgICAgICB1c2VFeGlzdGluZzogdXNlRXhpc3RpbmcsXHJcbiAgICAgICAgdXNlRmFjdG9yeTogdXNlRmFjdG9yeSxcclxuICAgICAgICBkZXBzOiBkZXBzLFxyXG4gICAgICAgIG11bHRpOiBtdWx0aVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wcm92aWRlID0gcHJvdmlkZTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgdGhlIHtAbGluayBiaW5kfSBmdW5jdGlvbi5cclxuICovXHJcbnZhciBQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJCdWlsZGVyKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBhIERJIHRva2VuIHRvIGEgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1pwQkNTWXF2NmUydWQ1S1hMZHhRP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogQmVjYXVzZSBgdG9BbGlhc2AgYW5kIGB0b0NsYXNzYCBhcmUgb2Z0ZW4gY29uZnVzZWQsIHRoZSBleGFtcGxlIGNvbnRhaW5zIGJvdGggdXNlIGNhc2VzIGZvclxyXG4gICAgICogZWFzeSBjb21wYXJpc29uLlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIFZlaGljbGUge31cclxuICAgICAqXHJcbiAgICAgKiBjbGFzcyBDYXIgZXh0ZW5kcyBWZWhpY2xlIHt9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGluamVjdG9yQ2xhc3MgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgQ2FyLFxyXG4gICAgICogICBwcm92aWRlKFZlaGljbGUsIHt1c2VDbGFzczogQ2FyfSlcclxuICAgICAqIF0pO1xyXG4gICAgICogdmFyIGluamVjdG9yQWxpYXMgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgQ2FyLFxyXG4gICAgICogICBwcm92aWRlKFZlaGljbGUsIHt1c2VFeGlzdGluZzogQ2FyfSlcclxuICAgICAqIF0pO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChpbmplY3RvckNsYXNzLmdldChWZWhpY2xlKSkubm90LnRvQmUoaW5qZWN0b3JDbGFzcy5nZXQoQ2FyKSk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JDbGFzcy5nZXQoVmVoaWNsZSkgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpKS50b0JlKGluamVjdG9yQWxpYXMuZ2V0KENhcikpO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9DbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlRyeWluZyB0byBjcmVhdGUgYSBjbGFzcyBwcm92aWRlciBidXQgXFxcIlwiICsgbGFuZ18xLnN0cmluZ2lmeSh0eXBlKSArIFwiXFxcIiBpcyBub3QgYSBjbGFzcyFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdmlkZXIodGhpcy50b2tlbiwgeyB1c2VDbGFzczogdHlwZSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvRzAyNFBGSG1ETDBjSkZnZlpLOE8/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgcHJvdmlkZSgnbWVzc2FnZScsIHt1c2VWYWx1ZTogJ0hlbGxvJ30pXHJcbiAgICAgKiBdKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KCdtZXNzYWdlJykpLnRvRXF1YWwoJ0hlbGxvJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgUHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS50b1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgUHJvdmlkZXIodGhpcy50b2tlbiwgeyB1c2VWYWx1ZTogdmFsdWUgfSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYW4gZXhpc3RpbmcgdG9rZW4uXHJcbiAgICAgKlxyXG4gICAgICogQW5ndWxhciB3aWxsIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZSBhcyBpZiB0aGUgcHJvdmlkZWQgdG9rZW4gd2FzIHVzZWQuIChUaGlzIGlzXHJcbiAgICAgKiBpbiBjb250cmFzdCB0byBgdXNlQ2xhc3NgIHdoZXJlIGEgc2VwYXJhdGUgaW5zdGFuY2Ugb2YgYHVzZUNsYXNzYCB3aWxsIGJlIHJldHVybmVkLilcclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdUJhb0YycE41Y2ZjNUFmWmFwTnc/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBCZWNhdXNlIGB0b0FsaWFzYCBhbmQgYHRvQ2xhc3NgIGFyZSBvZnRlbiBjb25mdXNlZCwgdGhlIGV4YW1wbGUgY29udGFpbnMgYm90aCB1c2UgY2FzZXMgZm9yXHJcbiAgICAgKiBlYXN5XHJcbiAgICAgKiBjb21wYXJpc29uLlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIFZlaGljbGUge31cclxuICAgICAqXHJcbiAgICAgKiBjbGFzcyBDYXIgZXh0ZW5kcyBWZWhpY2xlIHt9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGluamVjdG9yQWxpYXMgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgQ2FyLFxyXG4gICAgICogICBwcm92aWRlKFZlaGljbGUsIHt1c2VFeGlzdGluZzogQ2FyfSlcclxuICAgICAqIF0pO1xyXG4gICAgICogdmFyIGluamVjdG9yQ2xhc3MgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgQ2FyLFxyXG4gICAgICogICBwcm92aWRlKFZlaGljbGUsIHt1c2VDbGFzczogQ2FyfSlcclxuICAgICAqIF0pO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChpbmplY3RvckFsaWFzLmdldChWZWhpY2xlKSkudG9CZShpbmplY3RvckFsaWFzLmdldChDYXIpKTtcclxuICAgICAqIGV4cGVjdChpbmplY3RvckFsaWFzLmdldChWZWhpY2xlKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JDbGFzcy5nZXQoVmVoaWNsZSkpLm5vdC50b0JlKGluamVjdG9yQ2xhc3MuZ2V0KENhcikpO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yQ2xhc3MuZ2V0KFZlaGljbGUpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9BbGlhcyA9IGZ1bmN0aW9uIChhbGlhc1Rva2VuKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGFsaWFzVG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbiBub3QgYWxpYXMgXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHRoaXMudG9rZW4pICsgXCIgdG8gYSBibGFuayB2YWx1ZSFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdmlkZXIodGhpcy50b2tlbiwgeyB1c2VFeGlzdGluZzogYWxpYXNUb2tlbiB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYSBmdW5jdGlvbiB3aGljaCBjb21wdXRlcyB0aGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L09lak5JZlRUM3piMWlCeGFJWU9iP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAgICAgKiAgIHByb3ZpZGUoTnVtYmVyLCB7dXNlRmFjdG9yeTogKCkgPT4geyByZXR1cm4gMSsyOyB9fSksXHJcbiAgICAgKiAgIHByb3ZpZGUoU3RyaW5nLCB7dXNlRmFjdG9yeTogKHYpID0+IHsgcmV0dXJuIFwiVmFsdWU6IFwiICsgdjsgfSwgZGVwczogW051bWJlcl19KVxyXG4gICAgICogXSk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChOdW1iZXIpKS50b0VxdWFsKDMpO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChTdHJpbmcpKS50b0VxdWFsKCdWYWx1ZTogMycpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9GYWN0b3J5ID0gZnVuY3Rpb24gKGZhY3RvcnksIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgIGlmICghbGFuZ18xLmlzRnVuY3Rpb24oZmFjdG9yeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVHJ5aW5nIHRvIGNyZWF0ZSBhIGZhY3RvcnkgcHJvdmlkZXIgYnV0IFxcXCJcIiArIGxhbmdfMS5zdHJpbmdpZnkoZmFjdG9yeSkgKyBcIlxcXCIgaXMgbm90IGEgZnVuY3Rpb24hXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyKHRoaXMudG9rZW4sIHsgdXNlRmFjdG9yeTogZmFjdG9yeSwgZGVwczogZGVwZW5kZW5jaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm92aWRlckJ1aWxkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdmlkZXJCdWlsZGVyID0gUHJvdmlkZXJCdWlsZGVyO1xyXG4vKipcclxuICogUmVzb2x2ZSBhIHNpbmdsZSBwcm92aWRlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVGYWN0b3J5KHByb3ZpZGVyKSB7XHJcbiAgICB2YXIgZmFjdG9yeUZuO1xyXG4gICAgdmFyIHJlc29sdmVkRGVwcztcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xyXG4gICAgICAgIHZhciB1c2VDbGFzcyA9IGZvcndhcmRfcmVmXzEucmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIudXNlQ2xhc3MpO1xyXG4gICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuZmFjdG9yeSh1c2VDbGFzcyk7XHJcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gX2RlcGVuZGVuY2llc0Zvcih1c2VDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xyXG4gICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uIChhbGlhc0luc3RhbmNlKSB7IHJldHVybiBhbGlhc0luc3RhbmNlOyB9O1xyXG4gICAgICAgIHJlc29sdmVkRGVwcyA9IFtEZXBlbmRlbmN5LmZyb21LZXkoa2V5XzEuS2V5LmdldChwcm92aWRlci51c2VFeGlzdGluZykpXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcclxuICAgICAgICBmYWN0b3J5Rm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xyXG4gICAgICAgIHJlc29sdmVkRGVwcyA9IF9jb25zdHJ1Y3REZXBlbmRlbmNpZXMocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyLnVzZVZhbHVlOyB9O1xyXG4gICAgICAgIHJlc29sdmVkRGVwcyA9IF9FTVBUWV9MSVNUO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlZEZhY3RvcnkoZmFjdG9yeUZuLCByZXNvbHZlZERlcHMpO1xyXG59XHJcbmV4cG9ydHMucmVzb2x2ZUZhY3RvcnkgPSByZXNvbHZlRmFjdG9yeTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSB7QGxpbmsgUHJvdmlkZXJ9IGludG8ge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiB7QGxpbmsgSW5qZWN0b3J9IGludGVybmFsbHkgb25seSB1c2VzIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfSwge0BsaW5rIFByb3ZpZGVyfSBjb250YWluc1xyXG4gKiBjb252ZW5pZW5jZSBwcm92aWRlciBzeW50YXguXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlUHJvdmlkZXIocHJvdmlkZXIpIHtcclxuICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQcm92aWRlcl8oa2V5XzEuS2V5LmdldChwcm92aWRlci50b2tlbiksIFtyZXNvbHZlRmFjdG9yeShwcm92aWRlcildLCBmYWxzZSk7XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZlUHJvdmlkZXIgPSByZXNvbHZlUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBSZXNvbHZlIGEgbGlzdCBvZiBQcm92aWRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlUHJvdmlkZXJzKHByb3ZpZGVycykge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBfY3JlYXRlTGlzdE9mUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCBuZXcgTWFwKCkpKTtcclxuICAgIHJldHVybiBub3JtYWxpemVkLm1hcChmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgX05vcm1hbGl6ZWRQcm92aWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUHJvdmlkZXJfKGIua2V5LCBbYi5yZXNvbHZlZEZhY3RvcnldLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gYjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFByb3ZpZGVyXyhhcnJbMF0ua2V5LCBhcnIubWFwKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfLnJlc29sdmVkRmFjdG9yeTsgfSksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucmVzb2x2ZVByb3ZpZGVycyA9IHJlc29sdmVQcm92aWRlcnM7XHJcbi8qKlxyXG4gKiBUaGUgYWxnb3JpdGhtIHdvcmtzIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIFtQcm92aWRlcl0gLT4gW19Ob3JtYWxpemVkUHJvdmlkZXJ8W19Ob3JtYWxpemVkUHJvdmlkZXJdXSAtPiBbUmVzb2x2ZWRQcm92aWRlcl1cclxuICpcclxuICogX05vcm1hbGl6ZWRQcm92aWRlciBpcyBlc3NlbnRpYWxseSBhIHJlc29sdmVkIHByb3ZpZGVyIGJlZm9yZSBpdCB3YXMgZ3JvdXBlZCBieSBrZXkuXHJcbiAqL1xyXG52YXIgX05vcm1hbGl6ZWRQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfTm9ybWFsaXplZFByb3ZpZGVyKGtleSwgcmVzb2x2ZWRGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZhY3RvcnkgPSByZXNvbHZlZEZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX05vcm1hbGl6ZWRQcm92aWRlcjtcclxufSkoKTtcclxuZnVuY3Rpb24gX2NyZWF0ZUxpc3RPZlByb3ZpZGVycyhmbGF0dGVuZWRQcm92aWRlcnMpIHtcclxuICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci52YWx1ZXMoZmxhdHRlbmVkUHJvdmlkZXJzKTtcclxufVxyXG5mdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgcmVzKSB7XHJcbiAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgbGFuZ18xLlR5cGUpIHtcclxuICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVyKHByb3ZpZGUoYiwgeyB1c2VDbGFzczogYiB9KSwgcmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIFByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIF9ub3JtYWxpemVQcm92aWRlcihiLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhiLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgUHJvdmlkZXJCdWlsZGVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuSW52YWxpZFByb3ZpZGVyRXJyb3IoYi50b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18yLkludmFsaWRQcm92aWRlckVycm9yKGIpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXIoYiwgcmVzKSB7XHJcbiAgICB2YXIga2V5ID0ga2V5XzEuS2V5LmdldChiLnRva2VuKTtcclxuICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZUZhY3RvcnkoYik7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IG5ldyBfTm9ybWFsaXplZFByb3ZpZGVyKGtleSwgZmFjdG9yeSk7XHJcbiAgICBpZiAoYi5tdWx0aSkge1xyXG4gICAgICAgIHZhciBleGlzdGluZ1Byb3ZpZGVyID0gcmVzLmdldChrZXkuaWQpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ1Byb3ZpZGVyIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgZXhpc3RpbmdQcm92aWRlci5wdXNoKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNCbGFuayhleGlzdGluZ1Byb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICByZXMuc2V0KGtleS5pZCwgW25vcm1hbGl6ZWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yKGV4aXN0aW5nUHJvdmlkZXIsIGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBleGlzdGluZ1Byb3ZpZGVyID0gcmVzLmdldChrZXkuaWQpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ1Byb3ZpZGVyIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5NaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IoZXhpc3RpbmdQcm92aWRlciwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcy5zZXQoa2V5LmlkLCBub3JtYWxpemVkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfY29uc3RydWN0RGVwZW5kZW5jaWVzKGZhY3RvcnlGdW5jdGlvbiwgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoZGVwZW5kZW5jaWVzKSkge1xyXG4gICAgICAgIHJldHVybiBfZGVwZW5kZW5jaWVzRm9yKGZhY3RvcnlGdW5jdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gW3RdOyB9KTtcclxuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbihmYWN0b3J5RnVuY3Rpb24sIHQsIHBhcmFtcyk7IH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xyXG4gICAgdmFyIHBhcmFtcyA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJhbXMpKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIGlmIChjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuYW55KHBhcmFtcywgZnVuY3Rpb24gKHApIHsgcmV0dXJuIGxhbmdfMS5pc0JsYW5rKHApOyB9KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHAsIHBhcmFtcyk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgbWV0YWRhdGEgLyphbnlbXSB8IGFueSovLCBwYXJhbXMpIHtcclxuICAgIHZhciBkZXBQcm9wcyA9IFtdO1xyXG4gICAgdmFyIHRva2VuID0gbnVsbDtcclxuICAgIHZhciBvcHRpb25hbCA9IGZhbHNlO1xyXG4gICAgaWYgKCFsYW5nXzEuaXNBcnJheShtZXRhZGF0YSkpIHtcclxuICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kobWV0YWRhdGEsIG9wdGlvbmFsLCBudWxsLCBudWxsLCBkZXBQcm9wcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xyXG4gICAgdmFyIHVwcGVyQm91bmRWaXNpYmlsaXR5ID0gbnVsbDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgcGFyYW1NZXRhZGF0YSA9IG1ldGFkYXRhW2ldO1xyXG4gICAgICAgIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbGFuZ18xLlR5cGUpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5JbmplY3RNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGEudG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk9wdGlvbmFsTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5TZWxmTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ib3N0TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ta2lwU2VsZk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGxvd2VyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuRGVwZW5kZW5jeU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmFtTWV0YWRhdGEudG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGEudG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVwUHJvcHMucHVzaChwYXJhbU1ldGFkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b2tlbiA9IGZvcndhcmRfcmVmXzEucmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodG9rZW4pKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KHRva2VuLCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXBQcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18yLk5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4sIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKSB7XHJcbiAgICByZXR1cm4gbmV3IERlcGVuZGVuY3koa2V5XzEuS2V5LmdldCh0b2tlbiksIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIFR5cGUgbGl0ZXJhbHMgaXMgYSBEYXJ0LW9ubHkgZmVhdHVyZS4gVGhpcyBpcyBoZXJlIG9ubHkgc28gd2UgY2FuIHgtY29tcGlsZVxyXG4gKiB0byBtdWx0aXBsZSBsYW5ndWFnZXMuXHJcbiAqL1xyXG52YXIgVHlwZUxpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHlwZUxpdGVyYWwoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHlwZUxpdGVyYWwucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIGxpdGVyYWxzIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBEYXJ0XCIpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBUeXBlTGl0ZXJhbDtcclxufSkoKTtcclxuZXhwb3J0cy5UeXBlTGl0ZXJhbCA9IFR5cGVMaXRlcmFsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlX2xpdGVyYWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb21tb24gZGlyZWN0aXZlcyBzaGlwcGVkIHdpdGggQW5ndWxhci5cclxuICovXHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi9mYWNhZGUvbGFuZycpO1xyXG52YXIgbmdfY2xhc3NfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jbGFzcycpO1xyXG52YXIgbmdfZm9yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9yJyk7XHJcbnZhciBuZ19pZl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2lmJyk7XHJcbnZhciBuZ19zdHlsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX3N0eWxlJyk7XHJcbnZhciBuZ19zd2l0Y2hfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19zd2l0Y2gnKTtcclxudmFyIG5nX2NsYXNzXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY2xhc3MnKTtcclxuZXhwb3J0cy5OZ0NsYXNzID0gbmdfY2xhc3NfMi5OZ0NsYXNzO1xyXG52YXIgbmdfZm9yXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9yJyk7XHJcbmV4cG9ydHMuTmdGb3IgPSBuZ19mb3JfMi5OZ0ZvcjtcclxudmFyIG5nX2lmXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfaWYnKTtcclxuZXhwb3J0cy5OZ0lmID0gbmdfaWZfMi5OZ0lmO1xyXG52YXIgbmdfc3R5bGVfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19zdHlsZScpO1xyXG5leHBvcnRzLk5nU3R5bGUgPSBuZ19zdHlsZV8yLk5nU3R5bGU7XHJcbnZhciBuZ19zd2l0Y2hfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19zd2l0Y2gnKTtcclxuZXhwb3J0cy5OZ1N3aXRjaCA9IG5nX3N3aXRjaF8yLk5nU3dpdGNoO1xyXG5leHBvcnRzLk5nU3dpdGNoV2hlbiA9IG5nX3N3aXRjaF8yLk5nU3dpdGNoV2hlbjtcclxuZXhwb3J0cy5OZ1N3aXRjaERlZmF1bHQgPSBuZ19zd2l0Y2hfMi5OZ1N3aXRjaERlZmF1bHQ7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9vYnNlcnZhYmxlX2xpc3RfZGlmZicpKTtcclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBBbmd1bGFyIGNvcmUgZGlyZWN0aXZlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBBbmd1bGFyXHJcbiAqIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBUaGlzIGNvbGxlY3Rpb24gY2FuIGJlIHVzZWQgdG8gcXVpY2tseSBlbnVtZXJhdGUgYWxsIHRoZSBidWlsdC1pbiBkaXJlY3RpdmVzIGluIHRoZSBgZGlyZWN0aXZlc2BcclxuICogcHJvcGVydHkgb2YgdGhlIGBAVmlld2AgYW5ub3RhdGlvbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3lha0d3cENkVWtnMHFmelg1bThnP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEluc3RlYWQgb2Ygd3JpdGluZzpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge05nQ2xhc3MsIE5nSWYsIE5nRm9yLCBOZ1N3aXRjaCwgTmdTd2l0Y2hXaGVuLCBOZ1N3aXRjaERlZmF1bHR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtPdGhlckRpcmVjdGl2ZX0gZnJvbSAnLi9teURpcmVjdGl2ZXMnO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ215LWNvbXBvbmVudCcsXHJcbiAqICAgdGVtcGxhdGVVcmw6ICdteUNvbXBvbmVudC5odG1sJyxcclxuICogICBkaXJlY3RpdmVzOiBbTmdDbGFzcywgTmdJZiwgTmdGb3IsIE5nU3dpdGNoLCBOZ1N3aXRjaFdoZW4sIE5nU3dpdGNoRGVmYXVsdCwgT3RoZXJEaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCB7XHJcbiAqICAgLi4uXHJcbiAqIH1cclxuICogYGBgXHJcbiAqIG9uZSBjb3VsZCBpbXBvcnQgYWxsIHRoZSBjb3JlIGRpcmVjdGl2ZXMgYXQgb25jZTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NPUkVfRElSRUNUSVZFU30gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge090aGVyRGlyZWN0aXZlfSBmcm9tICcuL215RGlyZWN0aXZlcyc7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcclxuICogICB0ZW1wbGF0ZVVybDogJ215Q29tcG9uZW50Lmh0bWwnLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDT1JFX0RJUkVDVElWRVMsIE90aGVyRGlyZWN0aXZlXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xyXG4gKiAgIC4uLlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5DT1JFX0RJUkVDVElWRVMgPSBsYW5nXzEuQ09OU1RfRVhQUihbbmdfY2xhc3NfMS5OZ0NsYXNzLCBuZ19mb3JfMS5OZ0ZvciwgbmdfaWZfMS5OZ0lmLCBuZ19zdHlsZV8xLk5nU3R5bGUsIG5nX3N3aXRjaF8xLk5nU3dpdGNoLCBuZ19zd2l0Y2hfMS5OZ1N3aXRjaFdoZW4sIG5nX3N3aXRjaF8xLk5nU3dpdGNoRGVmYXVsdF0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIHJlbmRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG4vKipcclxuICogVGhlIGBOZ0NsYXNzYCBkaXJlY3RpdmUgY29uZGl0aW9uYWxseSBhZGRzIGFuZCByZW1vdmVzIENTUyBjbGFzc2VzIG9uIGFuIEhUTUwgZWxlbWVudCBiYXNlZCBvblxyXG4gKiBhbiBleHByZXNzaW9uJ3MgZXZhbHVhdGlvbiByZXN1bHQuXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgb2YgYW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uIGlzIGludGVycHJldGVkIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0eXBlIG9mXHJcbiAqIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb24gcmVzdWx0OlxyXG4gKiAtIGBzdHJpbmdgIC0gYWxsIHRoZSBDU1MgY2xhc3NlcyBsaXN0ZWQgaW4gYSBzdHJpbmcgKHNwYWNlIGRlbGltaXRlZCkgYXJlIGFkZGVkXHJcbiAqIC0gYEFycmF5YCAtIGFsbCB0aGUgQ1NTIGNsYXNzZXMgKEFycmF5IGVsZW1lbnRzKSBhcmUgYWRkZWRcclxuICogLSBgT2JqZWN0YCAtIGVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGEgQ1NTIGNsYXNzIG5hbWUgd2hpbGUgdmFsdWVzIGFyZSBpbnRlcnByZXRlZCBhcyBleHByZXNzaW9uc1xyXG4gKiBldmFsdWF0aW5nIHRvIGBCb29sZWFuYC4gSWYgYSBnaXZlbiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBgdHJ1ZWAgYSBjb3JyZXNwb25kaW5nIENTUyBjbGFzc1xyXG4gKiBpcyBhZGRlZCAtIG90aGVyd2lzZSBpdCBpcyByZW1vdmVkLlxyXG4gKlxyXG4gKiBXaGlsZSB0aGUgYE5nQ2xhc3NgIGRpcmVjdGl2ZSBjYW4gaW50ZXJwcmV0IGV4cHJlc3Npb25zIGV2YWx1YXRpbmcgdG8gYHN0cmluZ2AsIGBBcnJheWBcclxuICogb3IgYE9iamVjdGAsIHRoZSBgT2JqZWN0YC1iYXNlZCB2ZXJzaW9uIGlzIHRoZSBtb3N0IG9mdGVuIHVzZWQgYW5kIGhhcyBhbiBhZHZhbnRhZ2Ugb2Yga2VlcGluZ1xyXG4gKiBhbGwgdGhlIENTUyBjbGFzcyBuYW1lcyBpbiBhIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYTRZZHRtV3l3aEozM3VxZnBQUG4/cD1wcmV2aWV3KSk6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgTmdDbGFzc30gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3RvZ2dsZS1idXR0b24nLFxyXG4gKiAgIGlucHV0czogWydpc0Rpc2FibGVkJ10sXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uXCIgW25nLWNsYXNzXT1cInthY3RpdmU6IGlzT24sIGRpc2FibGVkOiBpc0Rpc2FibGVkfVwiXHJcbiAqICAgICAgICAgIChjbGljayk9XCJ0b2dnbGUoIWlzT24pXCI+XHJcbiAqICAgICAgICAgIENsaWNrIG1lIVxyXG4gKiAgICAgIDwvZGl2PmAsXHJcbiAqICAgc3R5bGVzOiBbYFxyXG4gKiAgICAgLmJ1dHRvbiB7XHJcbiAqICAgICAgIHdpZHRoOiAxMjBweDtcclxuICogICAgICAgYm9yZGVyOiBtZWRpdW0gc29saWQgYmxhY2s7XHJcbiAqICAgICB9XHJcbiAqXHJcbiAqICAgICAuYWN0aXZlIHtcclxuICogICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xyXG4gKiAgICB9XHJcbiAqXHJcbiAqICAgICAuZGlzYWJsZWQge1xyXG4gKiAgICAgICBjb2xvcjogZ3JheTtcclxuICogICAgICAgYm9yZGVyOiBtZWRpdW0gc29saWQgZ3JheTtcclxuICogICAgIH1cclxuICogICBgXVxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtOZ0NsYXNzXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBUb2dnbGVCdXR0b24ge1xyXG4gKiAgIGlzT24gPSBmYWxzZTtcclxuICogICBpc0Rpc2FibGVkID0gZmFsc2U7XHJcbiAqXHJcbiAqICAgdG9nZ2xlKG5ld1N0YXRlKSB7XHJcbiAqICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCkge1xyXG4gKiAgICAgICB0aGlzLmlzT24gPSBuZXdTdGF0ZTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgTmdDbGFzcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ0NsYXNzKF9pdGVyYWJsZURpZmZlcnMsIF9rZXlWYWx1ZURpZmZlcnMsIF9uZ0VsLCBfcmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlcnMgPSBfaXRlcmFibGVEaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVycyA9IF9rZXlWYWx1ZURpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDbGFzcy5wcm90b3R5cGUsIFwiaW5pdGlhbENsYXNzZXNcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3Nlcyh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBsYW5nXzEuaXNQcmVzZW50KHYpICYmIGxhbmdfMS5pc1N0cmluZyh2KSA/IHYuc3BsaXQoJyAnKSA6IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzLCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDbGFzcy5wcm90b3R5cGUsIFwicmF3Q2xhc3NcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsYXNzZXModGhpcy5fcmF3Q2xhc3MpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzU3RyaW5nKHYpKSB7XHJcbiAgICAgICAgICAgICAgICB2ID0gdi5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd0NsYXNzID0gdjtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodikuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSAnaXRlcmFibGUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fa2V5VmFsdWVEaWZmZXJzLmZpbmQodikuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSAna2V5VmFsdWUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUuZG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9kaWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGFuZ2VzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gJ2l0ZXJhYmxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5SXRlcmFibGVDaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlLZXlWYWx1ZUNoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jbGVhbnVwQ2xhc3Nlcyh0aGlzLl9yYXdDbGFzcyk7IH07XHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fY2xlYW51cENsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwpIHtcclxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMocmF3Q2xhc3NWYWwsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUtleVZhbHVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUl0ZXJhYmxlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIHRydWUpOyB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgZmFsc2UpOyB9KTtcclxuICAgIH07XHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJbml0aWFsQ2xhc3NlcyA9IGZ1bmN0aW9uIChpc0NsZWFudXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGNsYXNzTmFtZSwgIWlzQ2xlYW51cCk7IH0pO1xyXG4gICAgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUNsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwsIGlzQ2xlYW51cCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmF3Q2xhc3NWYWwpKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKHJhd0NsYXNzVmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcmF3Q2xhc3NWYWwuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHJhd0NsYXNzVmFsLCBmdW5jdGlvbiAoZXhwVmFsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl90b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVuYWJsZWQpIHtcclxuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUudHJpbSgpO1xyXG4gICAgICAgIGlmIChjbGFzc05hbWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fbmdFbCwgY2xhc3NOYW1lLCBlbmFibGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctY2xhc3NdJywgaW5wdXRzOiBbJ3Jhd0NsYXNzOiBuZy1jbGFzcycsICdpbml0aWFsQ2xhc3NlczogY2xhc3MnXSB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY2hhbmdlX2RldGVjdGlvbl8xLkl0ZXJhYmxlRGlmZmVycywgY2hhbmdlX2RldGVjdGlvbl8xLktleVZhbHVlRGlmZmVycywgbGlua2VyXzEuRWxlbWVudFJlZiwgcmVuZGVyXzEuUmVuZGVyZXJdKVxyXG4gICAgXSwgTmdDbGFzcyk7XHJcbiAgICByZXR1cm4gTmdDbGFzcztcclxufSkoKTtcclxuZXhwb3J0cy5OZ0NsYXNzID0gTmdDbGFzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfY2xhc3MuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIGxpbmtlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogVGhlIGBOZ0ZvcmAgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyBhIHRlbXBsYXRlIG9uY2UgcGVyIGl0ZW0gZnJvbSBhbiBpdGVyYWJsZS4gVGhlIGNvbnRleHQgZm9yXHJcbiAqIGVhY2ggaW5zdGFudGlhdGVkIHRlbXBsYXRlIGluaGVyaXRzIGZyb20gdGhlIG91dGVyIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gbG9vcCB2YXJpYWJsZSBzZXRcclxuICogdG8gdGhlIGN1cnJlbnQgaXRlbSBmcm9tIHRoZSBpdGVyYWJsZS5cclxuICpcclxuICogSXQgaXMgcG9zc2libGUgdG8gYWxpYXMgdGhlIGBpbmRleGAgdG8gYSBsb2NhbCB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGxvb3BcclxuICogaXRlcmF0aW9uIGluIHRoZSB0ZW1wbGF0ZSBjb250ZXh0LCBhbmQgYWxzbyB0byBhbGlhcyB0aGUgJ2xhc3QnIHRvIGEgbG9jYWwgdmFyaWFibGUgdGhhdCB3aWxsXHJcbiAqIGJlIHNldCB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaXRlbSBpcyB0aGUgbGFzdCBvbmUgaW4gdGhlIGl0ZXJhdGlvblxyXG4gKlxyXG4gKiBXaGVuIHRoZSBjb250ZW50cyBvZiB0aGUgaXRlcmF0b3IgY2hhbmdlcywgYE5nRm9yYCBtYWtlcyB0aGUgY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRvIHRoZSBET006XHJcbiAqXHJcbiAqICogV2hlbiBhbiBpdGVtIGlzIGFkZGVkLCBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgaXMgYWRkZWQgdG8gdGhlIERPTS5cclxuICogKiBXaGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCwgaXRzIHRlbXBsYXRlIGluc3RhbmNlIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxyXG4gKiAqIFdoZW4gaXRlbXMgYXJlIHJlb3JkZXJlZCwgdGhlaXIgcmVzcGVjdGl2ZSB0ZW1wbGF0ZXMgYXJlIHJlb3JkZXJlZCBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIDx1bD5cclxuICogICA8bGkgKm5nLWZvcj1cIiNlcnJvciBvZiBlcnJvcnM7ICNpID0gaW5kZXhcIj5cclxuICogICAgIEVycm9yIHt7aX19IG9mIHt7ZXJyb3JzLmxlbmd0aH19OiB7e2Vycm9yLm1lc3NhZ2V9fVxyXG4gKiAgIDwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIFN5bnRheFxyXG4gKlxyXG4gKiAtIGA8bGkgKm5nLWZvcj1cIiNpdGVtIG9mIGl0ZW1zOyAjaSA9IGluZGV4XCI+Li4uPC9saT5gXHJcbiAqIC0gYDxsaSB0ZW1wbGF0ZT1cIm5nLWZvciAjaXRlbSBvZiBpdGVtczsgI2kgPSBpbmRleFwiPi4uLjwvbGk+YFxyXG4gKiAtIGA8dGVtcGxhdGUgbmctZm9yICNpdGVtIFtuZy1mb3Itb2ZdPVwiaXRlbXNcIiAjaT1cImluZGV4XCI+PGxpPi4uLjwvbGk+PC90ZW1wbGF0ZT5gXHJcbiAqL1xyXG52YXIgTmdGb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdGb3IoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZVJlZiwgX2l0ZXJhYmxlRGlmZmVycywgX2Nkcikge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZVJlZiA9IF90ZW1wbGF0ZVJlZjtcclxuICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlcnMgPSBfaXRlcmFibGVEaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX2NkciA9IF9jZHI7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3IucHJvdG90eXBlLCBcIm5nRm9yT2ZcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25nRm9yT2YgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2RpZmZlcikgJiYgbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5fY2RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yLnByb3RvdHlwZSwgXCJuZ0ZvclRlbXBsYXRlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl90ZW1wbGF0ZVJlZiA9IHZhbHVlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nRm9yLnByb3RvdHlwZS5kb0NoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RpZmZlcikpIHtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9uZ0Zvck9mKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlcykpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5nRm9yLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAvLyBUT0RPKHJhZG8pOiBjaGVjayBpZiBjaGFuZ2UgZGV0ZWN0aW9uIGNhbiBwcm9kdWNlIGEgY2hhbmdlIHJlY29yZCB0aGF0IGlzXHJcbiAgICAgICAgLy8gZWFzaWVyIHRvIGNvbnN1bWUgdGhhbiBjdXJyZW50LlxyXG4gICAgICAgIHZhciByZWNvcmRWaWV3VHVwbGVzID0gW107XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlbW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZFZpZXdUdXBsZXMucHVzaChuZXcgUmVjb3JkVmlld1R1cGxlKHJlbW92ZWRSZWNvcmQsIG51bGwpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hNb3ZlZEl0ZW0oZnVuY3Rpb24gKG1vdmVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRWaWV3VHVwbGVzLnB1c2gobmV3IFJlY29yZFZpZXdUdXBsZShtb3ZlZFJlY29yZCwgbnVsbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpbnNlcnRUdXBsZXMgPSB0aGlzLl9idWxrUmVtb3ZlKHJlY29yZFZpZXdUdXBsZXMpO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAoYWRkZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc2VydFR1cGxlcy5wdXNoKG5ldyBSZWNvcmRWaWV3VHVwbGUoYWRkZWRSZWNvcmQsIG51bGwpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9idWxrSW5zZXJ0KGluc2VydFR1cGxlcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRUdXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVyVmlld0NoYW5nZShpbnNlcnRUdXBsZXNbaV0udmlldywgaW5zZXJ0VHVwbGVzW2ldLnJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5fdmlld0NvbnRhaW5lci5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoaSkuc2V0TG9jYWwoJ2xhc3QnLCBpID09PSBpbGVuIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5nRm9yLnByb3RvdHlwZS5fcGVyVmlld0NoYW5nZSA9IGZ1bmN0aW9uICh2aWV3LCByZWNvcmQpIHtcclxuICAgICAgICB2aWV3LnNldExvY2FsKCdcXCRpbXBsaWNpdCcsIHJlY29yZC5pdGVtKTtcclxuICAgICAgICB2aWV3LnNldExvY2FsKCdpbmRleCcsIHJlY29yZC5jdXJyZW50SW5kZXgpO1xyXG4gICAgICAgIHZpZXcuc2V0TG9jYWwoJ2V2ZW4nLCAocmVjb3JkLmN1cnJlbnRJbmRleCAlIDIgPT0gMCkpO1xyXG4gICAgICAgIHZpZXcuc2V0TG9jYWwoJ29kZCcsIChyZWNvcmQuY3VycmVudEluZGV4ICUgMiA9PSAxKSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3IucHJvdG90eXBlLl9idWxrUmVtb3ZlID0gZnVuY3Rpb24gKHR1cGxlcykge1xyXG4gICAgICAgIHR1cGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJlY29yZC5wcmV2aW91c0luZGV4IC0gYi5yZWNvcmQucHJldmlvdXNJbmRleDsgfSk7XHJcbiAgICAgICAgdmFyIG1vdmVkVHVwbGVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHR1cGxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgdHVwbGUgPSB0dXBsZXNbaV07XHJcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIG1vdmVkIHZpZXdzIGZyb20gcmVtb3ZlZCB2aWV3cy5cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHVwbGUucmVjb3JkLmN1cnJlbnRJbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIHR1cGxlLnZpZXcgPSB0aGlzLl92aWV3Q29udGFpbmVyLmRldGFjaCh0dXBsZS5yZWNvcmQucHJldmlvdXNJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBtb3ZlZFR1cGxlcy5wdXNoKHR1cGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHR1cGxlLnJlY29yZC5wcmV2aW91c0luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW92ZWRUdXBsZXM7XHJcbiAgICB9O1xyXG4gICAgTmdGb3IucHJvdG90eXBlLl9idWxrSW5zZXJ0ID0gZnVuY3Rpb24gKHR1cGxlcykge1xyXG4gICAgICAgIHR1cGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJlY29yZC5jdXJyZW50SW5kZXggLSBiLnJlY29yZC5jdXJyZW50SW5kZXg7IH0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHVwbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0dXBsZSA9IHR1cGxlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHVwbGUudmlldykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuaW5zZXJ0KHR1cGxlLnZpZXcsIHR1cGxlLnJlY29yZC5jdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHVwbGUudmlldyA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYsIHR1cGxlLnJlY29yZC5jdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0dXBsZXM7XHJcbiAgICB9O1xyXG4gICAgTmdGb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nLWZvcl1bbmctZm9yLW9mXScsIGlucHV0czogWyduZ0Zvck9mJywgJ25nRm9yVGVtcGxhdGUnXSB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbGlua2VyXzEuVmlld0NvbnRhaW5lclJlZiwgbGlua2VyXzEuVGVtcGxhdGVSZWYsIGNoYW5nZV9kZXRlY3Rpb25fMS5JdGVyYWJsZURpZmZlcnMsIGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclJlZl0pXHJcbiAgICBdLCBOZ0Zvcik7XHJcbiAgICByZXR1cm4gTmdGb3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdGb3IgPSBOZ0ZvcjtcclxudmFyIFJlY29yZFZpZXdUdXBsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWNvcmRWaWV3VHVwbGUocmVjb3JkLCB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5yZWNvcmQgPSByZWNvcmQ7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgIH1cclxuICAgIHJldHVybiBSZWNvcmRWaWV3VHVwbGU7XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2Zvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBSZW1vdmVzIG9yIHJlY3JlYXRlcyBhIHBvcnRpb24gb2YgdGhlIERPTSB0cmVlIGJhc2VkIG9uIGFuIHtleHByZXNzaW9ufS5cclxuICpcclxuICogSWYgdGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gYG5nLWlmYCBldmFsdWF0ZXMgdG8gYSBmYWxzZSB2YWx1ZSB0aGVuIHRoZSBlbGVtZW50XHJcbiAqIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBvdGhlcndpc2UgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBpcyByZWluc2VydGVkIGludG8gdGhlIERPTS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2ZlMGtnZW1GQnRtUU9ZMzFiNHR3P3A9cHJldmlldykpOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGRpdiAqbmctaWY9XCJlcnJvckNvdW50ID4gMFwiIGNsYXNzPVwiZXJyb3JcIj5cclxuICogICA8IS0tIEVycm9yIG1lc3NhZ2UgZGlzcGxheWVkIHdoZW4gdGhlIGVycm9yQ291bnQgcHJvcGVydHkgb24gdGhlIGN1cnJlbnQgY29udGV4dCBpcyBncmVhdGVyXHJcbiAqIHRoYW4gMC4gLS0+XHJcbiAqICAge3tlcnJvckNvdW50fX0gZXJyb3JzIGRldGVjdGVkXHJcbiAqIDwvZGl2PlxyXG4gKiBgYGBcclxuICpcclxuICogIyBTeW50YXhcclxuICpcclxuICogLSBgPGRpdiAqbmctaWY9XCJjb25kaXRpb25cIj4uLi48L2Rpdj5gXHJcbiAqIC0gYDxkaXYgdGVtcGxhdGU9XCJuZy1pZiBjb25kaXRpb25cIj4uLi48L2Rpdj5gXHJcbiAqIC0gYDx0ZW1wbGF0ZSBbbmctaWZdPVwiY29uZGl0aW9uXCI+PGRpdj4uLi48L2Rpdj48L3RlbXBsYXRlPmBcclxuICovXHJcbnZhciBOZ0lmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nSWYoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZVJlZiA9IF90ZW1wbGF0ZVJlZjtcclxuICAgICAgICB0aGlzLl9wcmV2Q29uZGl0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0lmLnByb3RvdHlwZSwgXCJuZ0lmXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdDb25kaXRpb24gLyogYm9vbGVhbiAqLykge1xyXG4gICAgICAgICAgICBpZiAobmV3Q29uZGl0aW9uICYmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9wcmV2Q29uZGl0aW9uKSB8fCAhdGhpcy5fcHJldkNvbmRpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFuZXdDb25kaXRpb24gJiYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX3ByZXZDb25kaXRpb24pIHx8IHRoaXMuX3ByZXZDb25kaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2Q29uZGl0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nSWYgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nLWlmXScsIGlucHV0czogWyduZ0lmJ10gfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2xpbmtlcl8xLlZpZXdDb250YWluZXJSZWYsIGxpbmtlcl8xLlRlbXBsYXRlUmVmXSlcclxuICAgIF0sIE5nSWYpO1xyXG4gICAgcmV0dXJuIE5nSWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdJZiA9IE5nSWY7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2lmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgcmVuZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBUaGUgYE5nU3R5bGVgIGRpcmVjdGl2ZSBjaGFuZ2VzIHN0eWxlcyBiYXNlZCBvbiBhIHJlc3VsdCBvZiBleHByZXNzaW9uIGV2YWx1YXRpb24uXHJcbiAqXHJcbiAqIEFuIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gdGhlIGBuZy1zdHlsZWAgcHJvcGVydHkgbXVzdCBldmFsdWF0ZSB0byBhbiBvYmplY3QgYW5kIHRoZVxyXG4gKiBjb3JyZXNwb25kaW5nIGVsZW1lbnQgc3R5bGVzIGFyZSB1cGRhdGVkIGJhc2VkIG9uIGNoYW5nZXMgdG8gdGhpcyBvYmplY3QuIFN0eWxlIG5hbWVzIHRvIHVwZGF0ZVxyXG4gKiBhcmUgdGFrZW4gZnJvbSB0aGUgb2JqZWN0J3Mga2V5cywgYW5kIHZhbHVlcyAtIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgb2JqZWN0J3MgdmFsdWVzLlxyXG4gKlxyXG4gKiAjIFN5bnRheFxyXG4gKlxyXG4gKiAtIGA8ZGl2IFtuZy1zdHlsZV09XCJ7J2ZvbnQtc3R5bGUnOiBzdHlsZX1cIj48L2Rpdj5gXHJcbiAqIC0gYDxkaXYgW25nLXN0eWxlXT1cInN0eWxlRXhwXCI+PC9kaXY+YCAtIGhlcmUgdGhlIGBzdHlsZUV4cGAgbXVzdCBldmFsdWF0ZSB0byBhbiBvYmplY3RcclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lhbUdTNkdrVWg5R3FXTlFoQ3lNP3A9cHJldmlldykpOlxyXG4gKlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnQsIE5nU3R5bGV9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ25nLXN0eWxlLWV4YW1wbGUnLFxyXG4gKiAgdGVtcGxhdGU6IGBcclxuICogICAgPGgxIFtuZy1zdHlsZV09XCJ7J2ZvbnQtc3R5bGUnOiBzdHlsZSwgJ2ZvbnQtc2l6ZSc6IHNpemUsICdmb250LXdlaWdodCc6IHdlaWdodH1cIj5cclxuICogICAgICBDaGFuZ2Ugc3R5bGUgb2YgdGhpcyB0ZXh0IVxyXG4gKiAgICA8L2gxPlxyXG4gKlxyXG4gKiAgICA8aHI+XHJcbiAqXHJcbiAqICAgIDxsYWJlbD5JdGFsaWM6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiAoY2hhbmdlKT1cImNoYW5nZVN0eWxlKCRldmVudClcIj48L2xhYmVsPlxyXG4gKiAgICA8bGFiZWw+Qm9sZDogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIChjaGFuZ2UpPVwiY2hhbmdlV2VpZ2h0KCRldmVudClcIj48L2xhYmVsPlxyXG4gKiAgICA8bGFiZWw+U2l6ZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgW3ZhbHVlXT1cInNpemVcIiAoY2hhbmdlKT1cInNpemUgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXCI+PC9sYWJlbD5cclxuICogIGAsXHJcbiAqICBkaXJlY3RpdmVzOiBbTmdTdHlsZV1cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIE5nU3R5bGVFeGFtcGxlIHtcclxuICogICAgc3R5bGUgPSAnbm9ybWFsJztcclxuICogICAgd2VpZ2h0ID0gJ25vcm1hbCc7XHJcbiAqICAgIHNpemUgPSAnMjBweCc7XHJcbiAqXHJcbiAqICAgIGNoYW5nZVN0eWxlKCRldmVudDogYW55KSB7XHJcbiAqICAgICAgdGhpcy5zdHlsZSA9ICRldmVudC50YXJnZXQuY2hlY2tlZCA/ICdpdGFsaWMnIDogJ25vcm1hbCc7XHJcbiAqICAgIH1cclxuICpcclxuICogICAgY2hhbmdlV2VpZ2h0KCRldmVudDogYW55KSB7XHJcbiAqICAgICAgdGhpcy53ZWlnaHQgPSAkZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyAnYm9sZCcgOiAnbm9ybWFsJztcclxuICogICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbiB0aGlzIGV4YW1wbGUgdGhlIGBmb250LXN0eWxlYCwgYGZvbnQtc2l6ZWAgYW5kIGBmb250LXdlaWdodGAgc3R5bGVzIHdpbGwgYmUgdXBkYXRlZFxyXG4gKiBiYXNlZCBvbiB0aGUgYHN0eWxlYCBwcm9wZXJ0eSdzIHZhbHVlIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgTmdTdHlsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ1N0eWxlKF9kaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1N0eWxlLnByb3RvdHlwZSwgXCJyYXdTdHlsZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdTdHlsZSA9IHY7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9kaWZmZXIpICYmIGxhbmdfMS5pc1ByZXNlbnQodikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh0aGlzLl9yYXdTdHlsZSkuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ1N0eWxlLnByb3RvdHlwZS5kb0NoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RpZmZlcikpIHtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9yYXdTdHlsZSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoYW5nZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdTdHlsZS5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCBudWxsKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdTdHlsZS5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9uZ0VsLCBuYW1lLCB2YWwpO1xyXG4gICAgfTtcclxuICAgIE5nU3R5bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nLXN0eWxlXScsIGlucHV0czogWydyYXdTdHlsZTogbmctc3R5bGUnXSB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY2hhbmdlX2RldGVjdGlvbl8xLktleVZhbHVlRGlmZmVycywgbGlua2VyXzEuRWxlbWVudFJlZiwgcmVuZGVyXzEuUmVuZGVyZXJdKVxyXG4gICAgXSwgTmdTdHlsZSk7XHJcbiAgICByZXR1cm4gTmdTdHlsZTtcclxufSkoKTtcclxuZXhwb3J0cy5OZ1N0eWxlID0gTmdTdHlsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfc3R5bGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBfV0hFTl9ERUZBVUxUID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IE9iamVjdCgpKTtcclxudmFyIFN3aXRjaFZpZXcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3dpdGNoVmlldyhfdmlld0NvbnRhaW5lclJlZiwgX3RlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xyXG4gICAgfVxyXG4gICAgU3dpdGNoVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7IH07XHJcbiAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH07XHJcbiAgICByZXR1cm4gU3dpdGNoVmlldztcclxufSkoKTtcclxuZXhwb3J0cy5Td2l0Y2hWaWV3ID0gU3dpdGNoVmlldztcclxuLyoqXHJcbiAqIFRoZSBgTmdTd2l0Y2hgIGRpcmVjdGl2ZSBpcyB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgc3dhcCBET00gc3RydWN0dXJlIG9uIHlvdXIgdGVtcGxhdGUgYmFzZWQgb24gYVxyXG4gKiBzY29wZSBleHByZXNzaW9uLlxyXG4gKiBFbGVtZW50cyB3aXRoaW4gYE5nU3dpdGNoYCBidXQgd2l0aG91dCBgTmdTd2l0Y2hXaGVuYCBvciBgTmdTd2l0Y2hEZWZhdWx0YCBkaXJlY3RpdmVzIHdpbGwgYmVcclxuICogcHJlc2VydmVkIGF0IHRoZSBsb2NhdGlvbiBhcyBzcGVjaWZpZWQgaW4gdGhlIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiBgTmdTd2l0Y2hgIHNpbXBseSBjaG9vc2VzIG5lc3RlZCBlbGVtZW50cyBhbmQgbWFrZXMgdGhlbSB2aXNpYmxlIGJhc2VkIG9uIHdoaWNoIGVsZW1lbnQgbWF0Y2hlc1xyXG4gKiB0aGUgdmFsdWUgb2J0YWluZWQgZnJvbSB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uIEluIG90aGVyIHdvcmRzLCB5b3UgZGVmaW5lIGEgY29udGFpbmVyIGVsZW1lbnRcclxuICogKHdoZXJlIHlvdSBwbGFjZSB0aGUgZGlyZWN0aXZlKSwgcGxhY2UgYW4gZXhwcmVzc2lvbiBvbiB0aGUgKipgW25nLXN3aXRjaF09XCIuLi5cImAgYXR0cmlidXRlKiopLFxyXG4gKiBkZWZpbmUgYW55IGlubmVyIGVsZW1lbnRzIGluc2lkZSBvZiB0aGUgZGlyZWN0aXZlIGFuZCBwbGFjZSBhIGBbbmctc3dpdGNoLXdoZW5dYCBhdHRyaWJ1dGUgcGVyXHJcbiAqIGVsZW1lbnQuXHJcbiAqIFRoZSB3aGVuIGF0dHJpYnV0ZSBpcyB1c2VkIHRvIGluZm9ybSBOZ1N3aXRjaCB3aGljaCBlbGVtZW50IHRvIGRpc3BsYXkgd2hlbiB0aGUgZXhwcmVzc2lvbiBpc1xyXG4gKiBldmFsdWF0ZWQuIElmIGEgbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBub3QgZm91bmQgdmlhIGEgd2hlbiBhdHRyaWJ1dGUgdGhlbiBhbiBlbGVtZW50IHdpdGggdGhlXHJcbiAqIGRlZmF1bHQgYXR0cmlidXRlIGlzIGRpc3BsYXllZC5cclxuICpcclxuICogIyBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPEFOWSBbbmctc3dpdGNoXT1cImV4cHJlc3Npb25cIj5cclxuICogICA8dGVtcGxhdGUgW25nLXN3aXRjaC13aGVuXT1cIndoZW5FeHByZXNzaW9uMVwiPi4uLjwvdGVtcGxhdGU+XHJcbiAqICAgPHRlbXBsYXRlIFtuZy1zd2l0Y2gtd2hlbl09XCJ3aGVuRXhwcmVzc2lvbjFcIj4uLi48L3RlbXBsYXRlPlxyXG4gKiAgIDx0ZW1wbGF0ZSBuZy1zd2l0Y2gtZGVmYXVsdD4uLi48L3RlbXBsYXRlPlxyXG4gKiA8L0FOWT5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgTmdTd2l0Y2ggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlVmlld3MgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2gucHJvdG90eXBlLCBcIm5nU3dpdGNoXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBFbXB0eSB0aGUgY3VycmVudGx5IGFjdGl2ZSBWaWV3Q29udGFpbmVyc1xyXG4gICAgICAgICAgICB0aGlzLl9lbXB0eUFsbEFjdGl2ZVZpZXdzKCk7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgVmlld0NvbnRhaW5lcnMgbWF0Y2hpbmcgdGhlIHZhbHVlICh3aXRoIGEgZmFsbGJhY2sgdG8gZGVmYXVsdClcclxuICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3cykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmlld3MgPSBsYW5nXzEubm9ybWFsaXplQmxhbmsodGhpcy5fdmFsdWVWaWV3cy5nZXQoX1dIRU5fREVGQVVMVCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3Modmlld3MpO1xyXG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9vbldoZW5WYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkV2hlbiwgbmV3V2hlbiwgdmlldykge1xyXG4gICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJWaWV3KG9sZFdoZW4sIHZpZXcpO1xyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyVmlldyhuZXdXaGVuLCB2aWV3KTtcclxuICAgICAgICBpZiAob2xkV2hlbiA9PT0gdGhpcy5fc3dpdGNoVmFsdWUpIHtcclxuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fYWN0aXZlVmlld3MsIHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdXaGVuID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlBbGxBY3RpdmVWaWV3cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpZXcuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzLnB1c2godmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN3aXRjaCB0byBkZWZhdWx0IHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBhY3RpdmUgVmlld0NvbnRhaW5lcnNcclxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmlld3MubGVuZ3RoID09PSAwICYmICF0aGlzLl91c2VEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZVZpZXdzKHRoaXMuX3ZhbHVlVmlld3MuZ2V0KF9XSEVOX0RFRkFVTFQpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9lbXB0eUFsbEFjdGl2ZVZpZXdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhY3RpdmVDb250YWluZXJzID0gdGhpcy5fYWN0aXZlVmlld3M7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUNvbnRhaW5lcnNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IFtdO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fYWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh2aWV3cykge1xyXG4gICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCh0aGlzLl9hY3RpdmVWaWV3cy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZpZXdzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3c1tpXS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IHZpZXdzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX3JlZ2lzdGVyVmlldyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmlldykge1xyXG4gICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlld3MpKSB7XHJcbiAgICAgICAgICAgIHZpZXdzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlVmlld3Muc2V0KHZhbHVlLCB2aWV3cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXdzLnB1c2godmlldyk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9kZXJlZ2lzdGVyVmlldyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmlldykge1xyXG4gICAgICAgIC8vIGBfV0hFTl9ERUZBVUxUYCBpcyB1c2VkIGEgbWFya2VyIGZvciBub24tcmVnaXN0ZXJlZCB3aGVuc1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gX1dIRU5fREVGQVVMVClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcclxuICAgICAgICBpZiAodmlld3MubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVWaWV3cy5kZWxldGUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh2aWV3cywgdmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5nU3dpdGNoID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuZy1zd2l0Y2hdJywgaW5wdXRzOiBbJ25nU3dpdGNoJ10gfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBOZ1N3aXRjaCk7XHJcbiAgICByZXR1cm4gTmdTd2l0Y2g7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdTd2l0Y2ggPSBOZ1N3aXRjaDtcclxuLyoqXHJcbiAqIERlZmluZXMgYSBjYXNlIHN0YXRlbWVudCBhcyBhbiBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBJZiBtdWx0aXBsZSBgTmdTd2l0Y2hXaGVuYCBtYXRjaCB0aGUgYE5nU3dpdGNoYCB2YWx1ZSwgYWxsIG9mIHRoZW0gYXJlIGRpc3BsYXllZC5cclxuICpcclxuICogRXhhbXBsZTpcclxuICpcclxuICogYGBgXHJcbiAqIC8vIG1hdGNoIGFnYWluc3QgYSBjb250ZXh0IHZhcmlhYmxlXHJcbiAqIDx0ZW1wbGF0ZSBbbmctc3dpdGNoLXdoZW5dPVwiY29udGV4dFZhcmlhYmxlXCI+Li4uPC90ZW1wbGF0ZT5cclxuICpcclxuICogLy8gbWF0Y2ggYWdhaW5zdCBhIGNvbnN0YW50IHN0cmluZ1xyXG4gKiA8dGVtcGxhdGUgbmctc3dpdGNoLXdoZW49XCJzdHJpbmdWYWx1ZVwiPi4uLjwvdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE5nU3dpdGNoV2hlbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ1N3aXRjaFdoZW4odmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIF9zd2l0Y2gpIHtcclxuICAgICAgICB0aGlzLl9zd2l0Y2ggPSBfc3dpdGNoO1xyXG4gICAgICAgIC8vIGBfV0hFTl9ERUZBVUxUYCBpcyB1c2VkIGFzIGEgbWFya2VyIGZvciBhIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgdmFsdWVcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfV0hFTl9ERUZBVUxUO1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZik7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2hXaGVuLnByb3RvdHlwZSwgXCJuZ1N3aXRjaFdoZW5cIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaC5fb25XaGVuVmFsdWVDaGFuZ2VkKHRoaXMuX3ZhbHVlLCB2YWx1ZSwgdGhpcy5fdmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ1N3aXRjaFdoZW4gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nLXN3aXRjaC13aGVuXScsIGlucHV0czogWyduZ1N3aXRjaFdoZW4nXSB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIGRpXzEuSG9zdCgpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbGlua2VyXzEuVmlld0NvbnRhaW5lclJlZiwgbGlua2VyXzEuVGVtcGxhdGVSZWYsIE5nU3dpdGNoXSlcclxuICAgIF0sIE5nU3dpdGNoV2hlbik7XHJcbiAgICByZXR1cm4gTmdTd2l0Y2hXaGVuO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nU3dpdGNoV2hlbiA9IE5nU3dpdGNoV2hlbjtcclxuLyoqXHJcbiAqIERlZmluZXMgYSBkZWZhdWx0IGNhc2Ugc3RhdGVtZW50LlxyXG4gKlxyXG4gKiBEZWZhdWx0IGNhc2Ugc3RhdGVtZW50cyBhcmUgZGlzcGxheWVkIHdoZW4gbm8gYE5nU3dpdGNoV2hlbmAgbWF0Y2ggdGhlIGBuZy1zd2l0Y2hgIHZhbHVlLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHRlbXBsYXRlIG5nLXN3aXRjaC1kZWZhdWx0Pi4uLjwvdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE5nU3dpdGNoRGVmYXVsdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ1N3aXRjaERlZmF1bHQodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIHNzd2l0Y2gpIHtcclxuICAgICAgICBzc3dpdGNoLl9yZWdpc3RlclZpZXcoX1dIRU5fREVGQVVMVCwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYpKTtcclxuICAgIH1cclxuICAgIE5nU3dpdGNoRGVmYXVsdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctc3dpdGNoLWRlZmF1bHRdJyB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIGRpXzEuSG9zdCgpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbGlua2VyXzEuVmlld0NvbnRhaW5lclJlZiwgbGlua2VyXzEuVGVtcGxhdGVSZWYsIE5nU3dpdGNoXSlcclxuICAgIF0sIE5nU3dpdGNoRGVmYXVsdCk7XHJcbiAgICByZXR1cm4gTmdTd2l0Y2hEZWZhdWx0O1xyXG59KSgpO1xyXG5leHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IE5nU3dpdGNoRGVmYXVsdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfc3dpdGNoLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBUUyBkb2VzIG5vdCBoYXZlIE9ic2VydmFibGVzXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGVfbGlzdF9kaWZmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9kb21fYWRhcHRlcicpO1xyXG52YXIgZ2VuZXJpY19icm93c2VyX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4vZ2VuZXJpY19icm93c2VyX2FkYXB0ZXInKTtcclxudmFyIF9hdHRyVG9Qcm9wTWFwID0ge1xyXG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXHJcbiAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXHJcbiAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxyXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4J1xyXG59O1xyXG52YXIgRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgPSAzO1xyXG4vLyBNYXAgdG8gY29udmVydCBzb21lIGtleSBvciBrZXlJZGVudGlmaWVyIHZhbHVlcyB0byB3aGF0IHdpbGwgYmUgcmV0dXJuZWQgYnkgZ2V0RXZlbnRLZXlcclxudmFyIF9rZXlNYXAgPSB7XHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgaGVyZSBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGFuZCB0byBtYXRjaCB0aGUgVzNDIHN0YW5kYXJkXHJcbiAgICAvLyBjZiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMta2V5L1xyXG4gICAgJ1xcYic6ICdCYWNrc3BhY2UnLFxyXG4gICAgJ1xcdCc6ICdUYWInLFxyXG4gICAgJ1xceDdGJzogJ0RlbGV0ZScsXHJcbiAgICAnXFx4MUInOiAnRXNjYXBlJyxcclxuICAgICdEZWwnOiAnRGVsZXRlJyxcclxuICAgICdFc2MnOiAnRXNjYXBlJyxcclxuICAgICdMZWZ0JzogJ0Fycm93TGVmdCcsXHJcbiAgICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXHJcbiAgICAnVXAnOiAnQXJyb3dVcCcsXHJcbiAgICAnRG93bic6ICdBcnJvd0Rvd24nLFxyXG4gICAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxyXG4gICAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcclxuICAgICdXaW4nOiAnT1MnXHJcbn07XHJcbi8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcclxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE1NTY1NFxyXG4vLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cclxudmFyIF9jaHJvbWVOdW1LZXlQYWRNYXAgPSB7XHJcbiAgICAnQSc6ICcxJyxcclxuICAgICdCJzogJzInLFxyXG4gICAgJ0MnOiAnMycsXHJcbiAgICAnRCc6ICc0JyxcclxuICAgICdFJzogJzUnLFxyXG4gICAgJ0YnOiAnNicsXHJcbiAgICAnRyc6ICc3JyxcclxuICAgICdIJzogJzgnLFxyXG4gICAgJ0knOiAnOScsXHJcbiAgICAnSic6ICcqJyxcclxuICAgICdLJzogJysnLFxyXG4gICAgJ00nOiAnLScsXHJcbiAgICAnTic6ICcuJyxcclxuICAgICdPJzogJy8nLFxyXG4gICAgJ1xceDYwJzogJzAnLFxyXG4gICAgJ1xceDkwJzogJ051bUxvY2snXHJcbn07XHJcbi8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXHJcbnZhciBCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnJvd3NlckRvbUFkYXB0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCcm93c2VyRG9tQWRhcHRlcigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUh0bWwpIHsgdGhyb3cgbmV3IEVycm9yKFwicGFyc2Ugbm90IGltcGxlbWVudGVkXCIpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIubWFrZUN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7IGRvbV9hZGFwdGVyXzEuc2V0Um9vdERvbUFkYXB0ZXIobmV3IEJyb3dzZXJEb21BZGFwdGVyKCkpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsgcmV0dXJuIG5hbWUgaW4gZWxlbWVudDsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHsgZWxbbmFtZV0gPSB2YWx1ZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSkgeyByZXR1cm4gZWxbbmFtZV07IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGVsLCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgZWxbbWV0aG9kTmFtZV0uYXBwbHkoZWwsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGlzIGludG8gYSBzZXBhcmF0ZSBlbnZpcm9ubWVudCBjbGFzcyBvbmNlIHdlIGhhdmUgaXRcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZS5lcnJvcikge1xyXG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGVycm9yKSB7IHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUuZ3JvdXApIHtcclxuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXAoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0Vycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUuZ3JvdXBFbmQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZSwgXCJhdHRyVG9Qcm9wTWFwXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hdHRyVG9Qcm9wTWFwOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHsgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7IHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikgeyBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5vbkFuZENhbmNlbCA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgIC8vIE5lZWRlZCB0byBmb2xsb3cgRGFydCdzIHN1YnNjcmlwdGlvbiBzZW1hbnRpYywgdW50aWwgZml4IG9mXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXJ0L2lzc3Vlcy9kZXRhaWw/aWQ9MTc0MDZcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChlbCwgZXZ0KSB7IGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xyXG4gICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBldnQ7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1ByZXZlbnRlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICByZXR1cm4gZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgbGFuZ18xLmlzUHJlc2VudChldnQucmV0dXJuVmFsdWUpICYmICFldnQucmV0dXJuVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldElubmVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaW5uZXJIVE1MOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldE91dGVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwub3V0ZXJIVE1MOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5vZGVOYW1lID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZU5hbWU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubm9kZVZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1Byb3BlcnR5KG5vZGUsIFwiY29udGVudFwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5maXJzdENoaWxkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5maXJzdENoaWxkOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uZXh0U2libGluZzsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5wYXJlbnROb2RlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoaWxkTm9kZXM7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2Rlc0FzTGlzdCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gZWwuY2hpbGROb2RlcztcclxuICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShjaGlsZE5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc1tpXSA9IGNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsZWFyTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLmFwcGVuZENoaWxkKG5vZGUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnJlbW92ZUNoaWxkKG5vZGUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbmV3Q2hpbGQsIG9sZENoaWxkKSB7IGVsLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgZWwpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFsbEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZXMpIHsgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgZWwpOyB9KTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbC5uZXh0U2libGluZyk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC5pbm5lckhUTUwgPSB2YWx1ZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC50ZXh0Q29udGVudDsgfTtcclxuICAgIC8vIFRPRE8odmljYik6IHJlbW92ZWQgRWxlbWVudCB0eXBlIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3VwcG9ydCBTdHlsZUVsZW1lbnRcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC50ZXh0Q29udGVudCA9IHZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC52YWx1ZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwudmFsdWUgPSB2YWx1ZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmNoZWNrZWQgPSB2YWx1ZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcclxuICAgICAgICB0LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgZG9jKSB7XHJcbiAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XHJcbiAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0LCBkb2MpIHtcclxuICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cclxuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTY3JpcHRUYWcgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIGF0dHJWYWx1ZSwgZG9jKSB7XHJcbiAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XHJcbiAgICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChjc3MsIGRvYykge1xyXG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3R5bGUsIHRoaXMuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jcmVhdGVTaGFkb3dSb290KCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZG93Um9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuc2hhZG93Um9vdDsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIb3N0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ob3N0OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2xhc3NMaXN0LCAwKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc25hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzbmFtZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NuYW1lKSB7IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc25hbWUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzbmFtZSkgeyByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NuYW1lKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZW5hbWUsIHN0eWxldmFsdWUpIHtcclxuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlbmFtZV0gPSBzdHlsZXZhbHVlO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZW5hbWUpIHsgZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdID0gbnVsbDsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZW5hbWUpIHsgcmV0dXJuIGVsZW1lbnQuc3R5bGVbc3R5bGVuYW1lXTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS50YWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQudGFnTmFtZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVNYXAgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIGVsQXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbEF0dHJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBlbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICByZXMuc2V0KGF0dHJpYi5uYW1lLCBhdHRyaWIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7IHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHsgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7IGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGVtcGxhdGVBd2FyZVJvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQoZWwpID8gdGhpcy5jb250ZW50KGVsKSA6IGVsOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUh0bWxEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdmYWtlVGl0bGUnKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZGVmYXVsdERvYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnRpdGxlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5ld1RpdGxlKSB7IGRvY3VtZW50LnRpdGxlID0gbmV3VGl0bGUgfHwgJyc7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZWxlbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAobiwgc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKG4ubWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG4ubWF0Y2hlcyhzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobi5tc01hdGNoZXNTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG4ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gbi53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsLm5vZGVOYW1lID09IFwiVEVNUExBVEVcIjtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc0NvbW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbGFuZ18xLmlzUHJlc2VudChub2RlLnNoYWRvd1Jvb3QpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbXBvcnRJbnRvRG9jID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgdG9JbXBvcnQgPSBub2RlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzVGVtcGxhdGVFbGVtZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHRvSW1wb3J0ID0gdGhpcy5jb250ZW50KG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0b0ltcG9ydCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkb3B0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkb2N1bWVudC5hZG9wdE5vZGUobm9kZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNQYWdlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiBydWxlLnR5cGUgPT09IENTU1J1bGUuUEFHRV9SVUxFOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzU3R5bGVSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudHlwZSA9PT0gQ1NTUnVsZS5TVFlMRV9SVUxFOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzTWVkaWFSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudHlwZSA9PT0gQ1NTUnVsZS5NRURJQV9SVUxFOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzS2V5ZnJhbWVzUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiBydWxlLnR5cGUgPT09IENTU1J1bGUuS0VZRlJBTUVTX1JVTEU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SHJlZiA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaHJlZjsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFdmVudEtleSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGtleSkpIHtcclxuICAgICAgICAgICAga2V5ID0gZXZlbnQua2V5SWRlbnRpZmllcjtcclxuICAgICAgICAgICAgLy8ga2V5SWRlbnRpZmllciBpcyBkZWZpbmVkIGluIHRoZSBvbGQgZHJhZnQgb2YgRE9NIExldmVsIDMgRXZlbnRzIGltcGxlbWVudGVkIGJ5IENocm9tZSBhbmRcclxuICAgICAgICAgICAgLy8gU2FmYXJpXHJcbiAgICAgICAgICAgIC8vIGNmXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2V2ZW50cy5odG1sI0V2ZW50cy1LZXlib2FyZEV2ZW50cy1JbnRlcmZhY2VzXHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VuaWRlbnRpZmllZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdVKycpKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtleS5zdWJzdHJpbmcoMiksIDE2KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubG9jYXRpb24gPT09IERPTV9LRVlfTE9DQVRJT05fTlVNUEFEICYmIF9jaHJvbWVOdW1LZXlQYWRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMSwgMiwgMyAuLi4gYXJlIHJlcG9ydGVkIGFzIEEsIEIsIEMgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gX2Nocm9tZU51bUtleVBhZE1hcFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfa2V5TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAga2V5ID0gX2tleU1hcFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRHbG9iYWxFdmVudFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09IFwid2luZG93XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09IFwiZG9jdW1lbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PSBcImJvZHlcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuaGlzdG9yeTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHJlZiA9IGdldEJhc2VFbGVtZW50SHJlZigpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhocmVmKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aChocmVmKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgYmFzZUVsZW1lbnQgPSBudWxsOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFVzZXJBZ2VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS0nICsgbmFtZSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLScgKyBuYW1lKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IH07XHJcbiAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgdGhpcyBpbnRvIGEgc2VwYXJhdGUgZW52aXJvbm1lbnQgY2xhc3Mgb25jZSB3ZSBoYXZlIGl0XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0R2xvYmFsVmFyID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7IGxhbmdfMS5zZXRWYWx1ZU9uUGF0aChsYW5nXzEuZ2xvYmFsLCBwYXRoLCB2YWx1ZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlLm5vdygpIGlzIG5vdCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzLCBzZWVcclxuICAgICAgICAvLyBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wZXJmb3JtYW5jZS5ub3dcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh3aW5kb3cucGVyZm9ybWFuY2UpICYmIGxhbmdfMS5pc1ByZXNlbnQod2luZG93LnBlcmZvcm1hbmNlLm5vdykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuRGF0ZVdyYXBwZXIudG9NaWxsaXMobGFuZ18xLkRhdGVXcmFwcGVyLm5vdygpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJyb3dzZXJEb21BZGFwdGVyO1xyXG59KShnZW5lcmljX2Jyb3dzZXJfYWRhcHRlcl8xLkdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcik7XHJcbmV4cG9ydHMuQnJvd3NlckRvbUFkYXB0ZXIgPSBCcm93c2VyRG9tQWRhcHRlcjtcclxudmFyIGJhc2VFbGVtZW50ID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0QmFzZUVsZW1lbnRIcmVmKCkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGJhc2VFbGVtZW50KSkge1xyXG4gICAgICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhiYXNlRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhc2VFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xyXG59XHJcbi8vIGJhc2VkIG9uIHVybFV0aWxzLmpzIGluIEFuZ3VsYXJKUyAxXHJcbnZhciB1cmxQYXJzaW5nTm9kZSA9IG51bGw7XHJcbmZ1bmN0aW9uIHJlbGF0aXZlUGF0aCh1cmwpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayh1cmxQYXJzaW5nTm9kZSkpIHtcclxuICAgICAgICB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgfVxyXG4gICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcclxuICAgIHJldHVybiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID8gdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxyXG4gICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfYWRhcHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmZ1bmN0aW9uIHNldFJvb3REb21BZGFwdGVyKGFkYXB0ZXIpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhleHBvcnRzLkRPTSkpIHtcclxuICAgICAgICBleHBvcnRzLkRPTSA9IGFkYXB0ZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zZXRSb290RG9tQWRhcHRlciA9IHNldFJvb3REb21BZGFwdGVyO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSAqL1xyXG4vKipcclxuICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW4gZW52aXJvbm1lbnQtYWdub3N0aWMgd2F5LlxyXG4gKi9cclxudmFyIERvbUFkYXB0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRG9tQWRhcHRlcigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBEb21BZGFwdGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkRvbUFkYXB0ZXIgPSBEb21BZGFwdGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21fYWRhcHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4vZG9tX2FkYXB0ZXInKTtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIERPTSBvcGVyYXRpb25zIGluIGFueSBicm93c2VyIGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5kID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5kZWZhdWx0RG9jKCkpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnQsICdhbmltYXRpb25OYW1lJykpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb21QcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5nZXRTdHlsZShlbGVtZW50LCBkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICctJyArIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnRvTG93ZXJDYXNlKGRvbVByZWZpeGVzW2ldKSArICctJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXHJcbiAgICAgICAgICAgICAgICBNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXHJcbiAgICAgICAgICAgICAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHRyYW5zRW5kRXZlbnROYW1lcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF90aGlzLmdldFN0eWxlKGVsZW1lbnQsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zaXRpb25FbmQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGlzdHJpYnV0ZWROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZ2V0RGlzdHJpYnV0ZWROb2RlcygpOyB9O1xyXG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXNvbHZlQW5kU2V0SHJlZiA9IGZ1bmN0aW9uIChlbCwgYmFzZVVybCwgaHJlZikge1xyXG4gICAgICAgIGVsLmhyZWYgPSBocmVmID09IG51bGwgPyBiYXNlVXJsIDogYmFzZVVybCArICcvLi4vJyArIGhyZWY7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jc3NUb1J1bGVzID0gZnVuY3Rpb24gKGNzcykge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGNzcyk7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLmRlZmF1bHREb2MoKS5oZWFkLCBzdHlsZSk7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gW107XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3R5bGUuc2hlZXQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IEZpcmVmb3ggdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHRoZSBydWxlcyBvZiBhIHN0eWxlc2hlZXRcclxuICAgICAgICAgICAgLy8gd2l0aCBhbiBAaW1wb3J0XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYyNTAxM1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhd1J1bGVzID0gc3R5bGUuc2hlZXQuY3NzUnVsZXM7XHJcbiAgICAgICAgICAgICAgICBydWxlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocmF3UnVsZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3UnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXSA9IHJhd1J1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlKHN0eWxlKTtcclxuICAgICAgICByZXR1cm4gcnVsZXM7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0RPTUV2ZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzTmF0aXZlU2hhZG93RE9NID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNGdW5jdGlvbih0aGlzLmRlZmF1bHREb2MoKS5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNVbnByZWZpeGVkQ3NzQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZGVmYXVsdERvYygpLmJvZHkuc3R5bGUpICYmXHJcbiAgICAgICAgICAgIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5kZWZhdWx0RG9jKCkuYm9keS5zdHlsZS5hbmltYXRpb25OYW1lKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblByZWZpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9hbmltYXRpb25QcmVmaXgpID8gdGhpcy5fYW5pbWF0aW9uUHJlZml4IDogXCJcIjtcclxuICAgIH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3RyYW5zaXRpb25FbmQpID8gdGhpcy5fdHJhbnNpdGlvbkVuZCA6IFwiXCI7IH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl90cmFuc2l0aW9uRW5kKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyO1xyXG59KShkb21fYWRhcHRlcl8xLkRvbUFkYXB0ZXIpO1xyXG5leHBvcnRzLkdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciA9IEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJpY19icm93c2VyX2FkYXB0ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFB1YmxpYyBBUEkgZm9yIEZhY2FkZVxyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi9mYWNhZGUvbGFuZycpO1xyXG5leHBvcnRzLlR5cGUgPSBsYW5nXzEuVHlwZTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9hc3luYycpO1xyXG5leHBvcnRzLk9ic2VydmFibGUgPSBhc3luY18xLk9ic2VydmFibGU7XHJcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gYXN5bmNfMS5FdmVudEVtaXR0ZXI7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbmV4cG9ydHMuV3JhcHBlZEV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWNhZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vLyBUT0RPKGplZmZiY3Jvc3MpOiB1c2UgRVM2IGltcG9ydCBvbmNlIHR5cGluZ3MgYXJlIGF2YWlsYWJsZVxyXG52YXIgU3ViamVjdCA9IHJlcXVpcmUoJ0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy9TdWJqZWN0Jyk7XHJcbnZhciBQcm9taXNlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9taXNlV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFByb21pc2VXcmFwcGVyLnJlc29sdmUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUob2JqKTsgfTtcclxuICAgIFByb21pc2VXcmFwcGVyLnJlamVjdCA9IGZ1bmN0aW9uIChvYmosIF8pIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KG9iaik7IH07XHJcbiAgICAvLyBOb3RlOiBXZSBjYW4ndCByZW5hbWUgdGhpcyBtZXRob2QgaW50byBgY2F0Y2hgLCBhcyB0aGlzIGlzIG5vdCBhIHZhbGlkXHJcbiAgICAvLyBtZXRob2QgbmFtZSBpbiBEYXJ0LlxyXG4gICAgUHJvbWlzZVdyYXBwZXIuY2F0Y2hFcnJvciA9IGZ1bmN0aW9uIChwcm9taXNlLCBvbkVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2gob25FcnJvcik7XHJcbiAgICB9O1xyXG4gICAgUHJvbWlzZVdyYXBwZXIuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XHJcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgfTtcclxuICAgIFByb21pc2VXcmFwcGVyLnRoZW4gPSBmdW5jdGlvbiAocHJvbWlzZSwgc3VjY2VzcywgcmVqZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihzdWNjZXNzLCByZWplY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIFByb21pc2VXcmFwcGVyLndyYXAgPSBmdW5jdGlvbiAoY29tcHV0YXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXMoY29tcHV0YXRpb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlaihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb21pc2VXcmFwcGVyLmNvbXBsZXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzb2x2ZTtcclxuICAgICAgICB2YXIgcmVqZWN0O1xyXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XHJcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBwcm9taXNlOiBwLCByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm9taXNlV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm9taXNlV3JhcHBlciA9IFByb21pc2VXcmFwcGVyO1xyXG52YXIgVGltZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRpbWVyV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFRpbWVyV3JhcHBlci5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGZuLCBtaWxsaXMpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmdsb2JhbC5zZXRUaW1lb3V0KGZuLCBtaWxsaXMpO1xyXG4gICAgfTtcclxuICAgIFRpbWVyV3JhcHBlci5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoaWQpIHsgbGFuZ18xLmdsb2JhbC5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG4gICAgVGltZXJXcmFwcGVyLnNldEludGVydmFsID0gZnVuY3Rpb24gKGZuLCBtaWxsaXMpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmdsb2JhbC5zZXRJbnRlcnZhbChmbiwgbWlsbGlzKTtcclxuICAgIH07XHJcbiAgICBUaW1lcldyYXBwZXIuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIChpZCkgeyBsYW5nXzEuZ2xvYmFsLmNsZWFySW50ZXJ2YWwoaWQpOyB9O1xyXG4gICAgcmV0dXJuIFRpbWVyV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5UaW1lcldyYXBwZXIgPSBUaW1lcldyYXBwZXI7XHJcbnZhciBPYnNlcnZhYmxlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIC8vIFRPRE8odnNhdmtpbik6IHdoZW4gd2UgdXNlIHJ4bmV4dCwgdHJ5IGluZmVycmluZyB0aGUgZ2VuZXJpYyB0eXBlIGZyb20gdGhlIGZpcnN0IGFyZ1xyXG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGVtaXR0ZXIsIG9uTmV4dCwgb25UaHJvdywgb25SZXR1cm4pIHtcclxuICAgICAgICBpZiAob25UaHJvdyA9PT0gdm9pZCAwKSB7IG9uVGhyb3cgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG9uUmV0dXJuID09PSB2b2lkIDApIHsgb25SZXR1cm4gPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIub2JzZXJ2ZXIoeyBuZXh0OiBvbk5leHQsIHRocm93OiBvblRocm93LCByZXR1cm46IG9uUmV0dXJuIH0pO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVXcmFwcGVyLmlzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icyBpbnN0YW5jZW9mIE9ic2VydmFibGU7IH07XHJcbiAgICBPYnNlcnZhYmxlV3JhcHBlci5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcclxuICAgIE9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHZhbHVlKSB7IGVtaXR0ZXIubmV4dCh2YWx1ZSk7IH07XHJcbiAgICBPYnNlcnZhYmxlV3JhcHBlci5jYWxsVGhyb3cgPSBmdW5jdGlvbiAoZW1pdHRlciwgZXJyb3IpIHsgZW1pdHRlci50aHJvdyhlcnJvcik7IH07XHJcbiAgICBPYnNlcnZhYmxlV3JhcHBlci5jYWxsUmV0dXJuID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHsgZW1pdHRlci5yZXR1cm4obnVsbCk7IH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVdyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZVdyYXBwZXIgPSBPYnNlcnZhYmxlV3JhcHBlcjtcclxuLy8gVE9ETzogdnNhdmtpbiBjaGFuZ2UgdG8gaW50ZXJmYWNlXHJcbnZhciBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XHJcbiAgICB9XHJcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5vYnNlcnZlciA9IGZ1bmN0aW9uIChnZW5lcmF0b3IpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcclxufSkoKTtcclxuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcclxuLyoqXHJcbiAqIFVzZSBieSBkaXJlY3RpdmVzIGFuZCBjb21wb25lbnRzIHRvIGVtaXQgY3VzdG9tIEV2ZW50cy5cclxuICpcclxuICogIyMgRXhhbXBsZXNcclxuICpcclxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBgWmlwcHlgIGFsdGVybmF0aXZlbHkgZW1pdHMgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aGVuIGl0c1xyXG4gKiB0aXRsZSBnZXRzIGNsaWNrZWQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3ppcHB5JyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxyXG4gKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cclxuICogICAgIDxkaXYgW2hpZGRlbl09XCIhdmlzaWJsZVwiPlxyXG4gKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAqICAgICA8L2Rpdj5cclxuICogIDwvZGl2PmB9KVxyXG4gKiBleHBvcnQgY2xhc3MgWmlwcHkge1xyXG4gKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG4gKiAgIEBPdXRwdXQoKSBvcGVuOiBFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqXHJcbiAqICAgdG9nZ2xlKCkge1xyXG4gKiAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcclxuICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICogICAgICAgdGhpcy5vcGVuLm5leHQobnVsbCk7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICB0aGlzLmNsb3NlLm5leHQobnVsbCk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBVc2UgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qaHVzYWluL29ic2VydmFibGUtc3BlY1xyXG4gKlxyXG4gKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxyXG4gKi9cclxudmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcclxuICAgIH1cclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2JzZXJ2ZXIgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Quc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvci5uZXh0KHZhbHVlKTsgfSk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZ2VuZXJhdG9yLnRocm93ID8gZ2VuZXJhdG9yLnRocm93KGVycm9yKSA6IG51bGw7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvci5yZXR1cm4gPyBnZW5lcmF0b3IucmV0dXJuKCkgOiBudWxsOyB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRvUnggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJqZWN0OyB9O1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3N1YmplY3QubmV4dCh2YWx1ZSk7IH07XHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHRoaXMuX3N1YmplY3QuZXJyb3IoZXJyb3IpOyB9O1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fc3ViamVjdC5jb21wbGV0ZSgpOyB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcclxufSkoT2JzZXJ2YWJsZSk7XHJcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmV4cG9ydHMuTWFwID0gbGFuZ18xLmdsb2JhbC5NYXA7XHJcbmV4cG9ydHMuU2V0ID0gbGFuZ18xLmdsb2JhbC5TZXQ7XHJcbi8vIFNhZmFyaSBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgZG8gbm90IHN1cHBvcnQgdGhlIGl0ZXJhYmxlIHBhcmFtZXRlciB0byB0aGVcclxuLy8gTWFwIGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxyXG52YXIgY3JlYXRlTWFwRnJvbVBhaXJzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKG5ldyBleHBvcnRzLk1hcChbWzEsIDJdXSkuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwRnJvbVBhaXJzKHBhaXJzKSB7IHJldHVybiBuZXcgZXhwb3J0cy5NYXAocGFpcnMpOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwQW5kUG9wdWxhdGVGcm9tUGFpcnMocGFpcnMpIHtcclxuICAgICAgICB2YXIgbWFwID0gbmV3IGV4cG9ydHMuTWFwKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIGNyZWF0ZU1hcEZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAobmV3IGV4cG9ydHMuTWFwKG5ldyBleHBvcnRzLk1hcCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwRnJvbU1hcChtKSB7IHJldHVybiBuZXcgZXhwb3J0cy5NYXAobSk7IH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBBbmRQb3B1bGF0ZUZyb21NYXAobSkge1xyXG4gICAgICAgIHZhciBtYXAgPSBuZXcgZXhwb3J0cy5NYXAoKTtcclxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgbWFwLnNldChrLCB2KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfY2xlYXJWYWx1ZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKChuZXcgZXhwb3J0cy5NYXAoKSkua2V5cygpLm5leHQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NsZWFyVmFsdWVzKG0pIHtcclxuICAgICAgICAgICAgdmFyIGtleUl0ZXJhdG9yID0gbS5rZXlzKCk7XHJcbiAgICAgICAgICAgIHZhciBrO1xyXG4gICAgICAgICAgICB3aGlsZSAoISgoayA9IGtleUl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcclxuICAgICAgICAgICAgICAgIG0uc2V0KGsudmFsdWUsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXNXaXRoRm9yZUVhY2gobSkge1xyXG4gICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgbS5zZXQoaywgbnVsbCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0pKCk7XHJcbi8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cclxuLy8gVE9ETyhtbGF2YWwpOiByZW1vdmUgdGhlIHdvcmsgYXJvdW5kIG9uY2Ugd2UgaGF2ZSBhIHdvcmtpbmcgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxyXG52YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgobmV3IGV4cG9ydHMuTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcChtLCBnZXRWYWx1ZXMpIHsgcmV0dXJuIGdldFZhbHVlcyA/IEFycmF5LmZyb20obS52YWx1ZXMoKSkgOiBBcnJheS5mcm9tKG0ua2V5cygpKTsgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcFdpdGhGb3JlYWNoKG0sIGdldFZhbHVlcykge1xyXG4gICAgICAgIHZhciByZXMgPSBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobS5zaXplKSwgaSA9IDA7XHJcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XHJcbiAgICAgICAgICAgIHJlc1tpXSA9IGdldFZhbHVlcyA/IHYgOiBrO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1hcFdyYXBwZXIoKSB7XHJcbiAgICB9XHJcbiAgICBNYXBXcmFwcGVyLmNsb25lID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGNyZWF0ZU1hcEZyb21NYXAobSk7IH07XHJcbiAgICBNYXBXcmFwcGVyLmNyZWF0ZUZyb21TdHJpbmdNYXAgPSBmdW5jdGlvbiAoc3RyaW5nTWFwKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBleHBvcnRzLk1hcCgpO1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RyaW5nTWFwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBNYXBXcmFwcGVyLnRvU3RyaW5nTWFwID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICB2YXIgciA9IHt9O1xyXG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcltrXSA9IHY7IH0pO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVBhaXJzID0gZnVuY3Rpb24gKHBhaXJzKSB7IHJldHVybiBjcmVhdGVNYXBGcm9tUGFpcnMocGFpcnMpOyB9O1xyXG4gICAgTWFwV3JhcHBlci5jbGVhclZhbHVlcyA9IGZ1bmN0aW9uIChtKSB7IF9jbGVhclZhbHVlcyhtKTsgfTtcclxuICAgIE1hcFdyYXBwZXIuaXRlcmFibGUgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gbTsgfTtcclxuICAgIE1hcFdyYXBwZXIua2V5cyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIGZhbHNlKTsgfTtcclxuICAgIE1hcFdyYXBwZXIudmFsdWVzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgdHJ1ZSk7IH07XHJcbiAgICByZXR1cm4gTWFwV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5NYXBXcmFwcGVyID0gTWFwV3JhcHBlcjtcclxuLyoqXHJcbiAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xyXG4gKi9cclxudmFyIFN0cmluZ01hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFN0cmluZ01hcFdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGFyZSBub3QgdXNpbmcgT2JqZWN0LmNyZWF0ZShudWxsKSBoZXJlIGR1ZSB0b1xyXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIVxyXG4gICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL25nMi1vYmplY3QtY3JlYXRlLW51bGxcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChtYXAsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBtYXAuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmdldCA9IGZ1bmN0aW9uIChtYXAsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBtYXAuaGFzT3duUHJvcGVydHkoa2V5KSA/IG1hcFtrZXldIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuc2V0ID0gZnVuY3Rpb24gKG1hcCwga2V5LCB2YWx1ZSkgeyBtYXBba2V5XSA9IHZhbHVlOyB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gT2JqZWN0LmtleXMobWFwKTsgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuZGVsZXRlID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7IGRlbGV0ZSBtYXBba2V5XTsgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCA9IGZ1bmN0aW9uIChtYXAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtYXApIHtcclxuICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobWFwW3Byb3BdLCBwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xyXG4gICAgICAgIHZhciBtID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBtMSkge1xyXG4gICAgICAgICAgICBpZiAobTEuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcclxuICAgICAgICAgICAgICAgIG1bYXR0cl0gPSBtMVthdHRyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIG0yKSB7XHJcbiAgICAgICAgICAgIGlmIChtMi5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgbVthdHRyXSA9IG0yW2F0dHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xyXG4gICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcclxuICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XHJcbiAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAga2V5ID0gazFbaV07XHJcbiAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU3RyaW5nTWFwV3JhcHBlciA9IFN0cmluZ01hcFdyYXBwZXI7XHJcbnZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIC8vIEpTIGhhcyBubyB3YXkgdG8gZXhwcmVzcyBhIHN0YXRpY2FsbHkgZml4ZWQgc2l6ZSBsaXN0LCBidXQgZGFydCBkb2VzIHNvIHdlXHJcbiAgICAvLyBrZWVwIGJvdGggbWV0aG9kcy5cclxuICAgIExpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuY2xvbmUgPSBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDApOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uIChhcnJheSwgZm4pIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZuKGFycmF5W2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuZmlyc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICBpZiAoIWFycmF5KVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gYXJyYXlbMF07XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIubGFzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5maW5kID0gZnVuY3Rpb24gKGxpc3QsIHByZWQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHByZWQobGlzdFtpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUsIHN0YXJ0SW5kZXgpO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLnJlZHVjZSA9IGZ1bmN0aW9uIChsaXN0LCBmbiwgaW5pdCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0LnJlZHVjZShmbiwgaW5pdCk7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuZmlsdGVyID0gZnVuY3Rpb24gKGFycmF5LCBwcmVkKSB7IHJldHVybiBhcnJheS5maWx0ZXIocHJlZCk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5hbnkgPSBmdW5jdGlvbiAobGlzdCwgcHJlZCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZChsaXN0W2ldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHsgcmV0dXJuIGxpc3QuaW5kZXhPZihlbCkgIT09IC0xOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIucmV2ZXJzZWQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICB2YXIgYSA9IExpc3RXcmFwcGVyLmNsb25lKGFycmF5KTtcclxuICAgICAgICByZXR1cm4gYS5yZXZlcnNlKCk7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4LCB2YWx1ZSkgeyBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIucmVtb3ZlQXQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgcmVzID0gbGlzdFtpbmRleF07XHJcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLmNsZWFyID0gZnVuY3Rpb24gKGxpc3QpIHsgbGlzdC5sZW5ndGggPSAwOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0Lmxlbmd0aCA9PSAwOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuZmlsbCA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XHJcbiAgICAgICAgbGlzdC5maWxsKHZhbHVlLCBzdGFydCwgZW5kID09PSBudWxsID8gbGlzdC5sZW5ndGggOiBlbmQpO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCB0bykge1xyXG4gICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cclxuICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gbC5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5zcGxpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgbGVuZ3RoKSB7IHJldHVybiBsLnNwbGljZShmcm9tLCBsZW5ndGgpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIuc29ydCA9IGZ1bmN0aW9uIChsLCBjb21wYXJlRm4pIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wYXJlRm4pKSB7XHJcbiAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbC5zb3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcclxuICAgIExpc3RXcmFwcGVyLnRvSlNPTiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfTtcclxuICAgIExpc3RXcmFwcGVyLm1heGltdW0gPSBmdW5jdGlvbiAobGlzdCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjYW5kaWRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlVmFsdWUgPSBwcmVkaWNhdGUoY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjYW5kaWRhdGVWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc29sdXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkxpc3RXcmFwcGVyID0gTGlzdFdyYXBwZXI7XHJcbmZ1bmN0aW9uIGlzTGlzdExpa2VJdGVyYWJsZShvYmopIHtcclxuICAgIGlmICghbGFuZ18xLmlzSnNPYmplY3Qob2JqKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gbGFuZ18xLmlzQXJyYXkob2JqKSB8fFxyXG4gICAgICAgICghKG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuTWFwKSAmJlxyXG4gICAgICAgICAgICBsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKSBpbiBvYmopOyAvLyBKUyBJdGVyYWJsZSBoYXZlIGEgU3ltYm9sLml0ZXJhdG9yIHByb3BcclxufVxyXG5leHBvcnRzLmlzTGlzdExpa2VJdGVyYWJsZSA9IGlzTGlzdExpa2VJdGVyYWJsZTtcclxuZnVuY3Rpb24gaXRlcmF0ZUxpc3RMaWtlKG9iaiwgZm4pIHtcclxuICAgIGlmIChsYW5nXzEuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm4ob2JqW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBvYmpbbGFuZ18xLmdldFN5bWJvbEl0ZXJhdG9yKCldKCk7XHJcbiAgICAgICAgdmFyIGl0ZW07XHJcbiAgICAgICAgd2hpbGUgKCEoKGl0ZW0gPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpKSB7XHJcbiAgICAgICAgICAgIGZuKGl0ZW0udmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLml0ZXJhdGVMaXN0TGlrZSA9IGl0ZXJhdGVMaXN0TGlrZTtcclxuLy8gU2FmYXJpIGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkbyBub3Qgc3VwcG9ydCB0aGUgaXRlcmFibGUgcGFyYW1ldGVyIHRvIHRoZVxyXG4vLyBTZXQgY29uc3RydWN0b3IuICBXZSB3b3JrIGFyb3VuZCB0aGF0IGJ5IG1hbnVhbGx5IGFkZGluZyB0aGUgaXRlbXMuXHJcbnZhciBjcmVhdGVTZXRGcm9tTGlzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdGVzdCA9IG5ldyBleHBvcnRzLlNldChbMSwgMiwgM10pO1xyXG4gICAgaWYgKHRlc3Quc2l6ZSA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTZXRGcm9tTGlzdChsc3QpIHsgcmV0dXJuIG5ldyBleHBvcnRzLlNldChsc3QpOyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNldEFuZFBvcHVsYXRlRnJvbUxpc3QobHN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgZXhwb3J0cy5TZXQobHN0KTtcclxuICAgICAgICAgICAgaWYgKHJlcy5zaXplICE9PSBsc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5hZGQobHN0W2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0pKCk7XHJcbnZhciBTZXRXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNldFdyYXBwZXIoKSB7XHJcbiAgICB9XHJcbiAgICBTZXRXcmFwcGVyLmNyZWF0ZUZyb21MaXN0ID0gZnVuY3Rpb24gKGxzdCkgeyByZXR1cm4gY3JlYXRlU2V0RnJvbUxpc3QobHN0KTsgfTtcclxuICAgIFNldFdyYXBwZXIuaGFzID0gZnVuY3Rpb24gKHMsIGtleSkgeyByZXR1cm4gcy5oYXMoa2V5KTsgfTtcclxuICAgIFNldFdyYXBwZXIuZGVsZXRlID0gZnVuY3Rpb24gKG0sIGspIHsgbS5kZWxldGUoayk7IH07XHJcbiAgICByZXR1cm4gU2V0V3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TZXRXcmFwcGVyID0gU2V0V3JhcHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIF9BcnJheUxvZ2dlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfQXJyYXlMb2dnZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yZXMgPSBbXTtcclxuICAgIH1cclxuICAgIF9BcnJheUxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHMpIHsgdGhpcy5yZXMucHVzaChzKTsgfTtcclxuICAgIF9BcnJheUxvZ2dlci5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAocykgeyB0aGlzLnJlcy5wdXNoKHMpOyB9O1xyXG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2dHcm91cCA9IGZ1bmN0aW9uIChzKSB7IHRoaXMucmVzLnB1c2gocyk7IH07XHJcbiAgICBfQXJyYXlMb2dnZXIucHJvdG90eXBlLmxvZ0dyb3VwRW5kID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIF9BcnJheUxvZ2dlcjtcclxufSkoKTtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY2VudHJhbGl6ZWQgZXhjZXB0aW9uIGhhbmRsaW5nLlxyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgRXhjZXB0aW9uSGFuZGxlcmAgcHJpbnRzIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSBgQ29uc29sZWAuIFRvXHJcbiAqIGludGVyY2VwdCBlcnJvciBoYW5kbGluZyxcclxuICogd3JpdGUgYSBjdXN0b20gZXhjZXB0aW9uIGhhbmRsZXIgdGhhdCByZXBsYWNlcyB0aGlzIGRlZmF1bHQgYXMgYXBwcm9wcmlhdGUgZm9yIHlvdXIgYXBwLlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKlxyXG4gKiBjbGFzcyBNeUV4Y2VwdGlvbkhhbmRsZXIgaW1wbGVtZW50cyBFeGNlcHRpb25IYW5kbGVyIHtcclxuICogICBjYWxsKGVycm9yLCBzdGFja1RyYWNlID0gbnVsbCwgcmVhc29uID0gbnVsbCkge1xyXG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGV4Y2VwdGlvblxyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoTXlBcHAsIFtwcm92aWRlKEV4Y2VwdGlvbkhhbmRsZXIsIHt1c2VDbGFzczogTXlFeGNlcHRpb25IYW5kbGVyfSldKVxyXG4gKlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBFeGNlcHRpb25IYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4Y2VwdGlvbkhhbmRsZXIoX2xvZ2dlciwgX3JldGhyb3dFeGNlcHRpb24pIHtcclxuICAgICAgICBpZiAoX3JldGhyb3dFeGNlcHRpb24gPT09IHZvaWQgMCkgeyBfcmV0aHJvd0V4Y2VwdGlvbiA9IHRydWU7IH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBfbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMuX3JldGhyb3dFeGNlcHRpb24gPSBfcmV0aHJvd0V4Y2VwdGlvbjtcclxuICAgIH1cclxuICAgIEV4Y2VwdGlvbkhhbmRsZXIuZXhjZXB0aW9uVG9TdHJpbmcgPSBmdW5jdGlvbiAoZXhjZXB0aW9uLCBzdGFja1RyYWNlLCByZWFzb24pIHtcclxuICAgICAgICBpZiAoc3RhY2tUcmFjZSA9PT0gdm9pZCAwKSB7IHN0YWNrVHJhY2UgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7IHJlYXNvbiA9IG51bGw7IH1cclxuICAgICAgICB2YXIgbCA9IG5ldyBfQXJyYXlMb2dnZXIoKTtcclxuICAgICAgICB2YXIgZSA9IG5ldyBFeGNlcHRpb25IYW5kbGVyKGwsIGZhbHNlKTtcclxuICAgICAgICBlLmNhbGwoZXhjZXB0aW9uLCBzdGFja1RyYWNlLCByZWFzb24pO1xyXG4gICAgICAgIHJldHVybiBsLnJlcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfTtcclxuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoZXhjZXB0aW9uLCBzdGFja1RyYWNlLCByZWFzb24pIHtcclxuICAgICAgICBpZiAoc3RhY2tUcmFjZSA9PT0gdm9pZCAwKSB7IHN0YWNrVHJhY2UgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7IHJlYXNvbiA9IG51bGw7IH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxFeGNlcHRpb24gPSB0aGlzLl9maW5kT3JpZ2luYWxFeGNlcHRpb24oZXhjZXB0aW9uKTtcclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGFjayA9IHRoaXMuX2ZpbmRPcmlnaW5hbFN0YWNrKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9maW5kQ29udGV4dChleGNlcHRpb24pO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5sb2dHcm91cChcIkVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShleGNlcHRpb24pKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdGFja1RyYWNlKSAmJiBsYW5nXzEuaXNCbGFuayhvcmlnaW5hbFN0YWNrKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJTVEFDS1RSQUNFOlwiKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKHRoaXMuX2xvbmdTdGFja1RyYWNlKHN0YWNrVHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVhc29uKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJSRUFTT046IFwiICsgcmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3JpZ2luYWxFeGNlcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIk9SSUdJTkFMIEVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShvcmlnaW5hbEV4Y2VwdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcmlnaW5hbFN0YWNrKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJPUklHSU5BTCBTVEFDS1RSQUNFOlwiKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKHRoaXMuX2xvbmdTdGFja1RyYWNlKG9yaWdpbmFsU3RhY2spKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKFwiRVJST1IgQ09OVEVYVDpcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0dyb3VwRW5kKCk7XHJcbiAgICAgICAgLy8gV2UgcmV0aHJvdyBleGNlcHRpb25zLCBzbyBvcGVyYXRpb25zIGxpa2UgJ2Jvb3RzdHJhcCcgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcclxuICAgICAgICAvLyB3aGVuIGFuIGV4Y2VwdGlvbiBoYXBwZW5zLiBJZiB3ZSBkbyBub3QgcmV0aHJvdywgYm9vdHN0cmFwIHdpbGwgYWx3YXlzIHN1Y2NlZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JldGhyb3dFeGNlcHRpb24pXHJcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZXh0cmFjdE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uID8gZXhjZXB0aW9uLndyYXBwZXJNZXNzYWdlIDogZXhjZXB0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRXhjZXB0aW9uSGFuZGxlci5wcm90b3R5cGUuX2xvbmdTdGFja1RyYWNlID0gZnVuY3Rpb24gKHN0YWNrVHJhY2UpIHtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShzdGFja1RyYWNlKSA/IHN0YWNrVHJhY2Uuam9pbihcIlxcblxcbi0tLS0tYXN5bmMgZ2FwLS0tLS1cXG5cIikgOlxyXG4gICAgICAgICAgICBzdGFja1RyYWNlLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRXhjZXB0aW9uSGFuZGxlci5wcm90b3R5cGUuX2ZpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChleGNlcHRpb24uY29udGV4dCkgPyBleGNlcHRpb24uY29udGV4dCA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5kQ29udGV4dChleGNlcHRpb24ub3JpZ2luYWxFeGNlcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBleGNlcHRpb24uY29udGV4dCBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uLiBpZiBpdCBoYXBwZW5zLCB3ZSBpZ25vcmUgdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsRXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIGlmICghKGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGUgPSBleGNlcHRpb24ub3JpZ2luYWxFeGNlcHRpb247XHJcbiAgICAgICAgd2hpbGUgKGUgaW5zdGFuY2VvZiBleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbiAmJiBsYW5nXzEuaXNQcmVzZW50KGUub3JpZ2luYWxFeGNlcHRpb24pKSB7XHJcbiAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXhjZXB0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsU3RhY2sgPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgaWYgKCEoZXhjZXB0aW9uIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24pKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB2YXIgZSA9IGV4Y2VwdGlvbjtcclxuICAgICAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24ub3JpZ2luYWxTdGFjaztcclxuICAgICAgICB3aGlsZSAoZSBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uICYmIGxhbmdfMS5pc1ByZXNlbnQoZS5vcmlnaW5hbEV4Y2VwdGlvbikpIHtcclxuICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFeGNlcHRpb247XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24gJiYgbGFuZ18xLmlzUHJlc2VudChlLm9yaWdpbmFsRXhjZXB0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBlLm9yaWdpbmFsU3RhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFeGNlcHRpb25IYW5kbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkV4Y2VwdGlvbkhhbmRsZXIgPSBFeGNlcHRpb25IYW5kbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNlcHRpb25faGFuZGxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGV4Y2VwdGlvbl9oYW5kbGVyXzEgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbl9oYW5kbGVyJyk7XHJcbnZhciBleGNlcHRpb25faGFuZGxlcl8yID0gcmVxdWlyZSgnLi9leGNlcHRpb25faGFuZGxlcicpO1xyXG5leHBvcnRzLkV4Y2VwdGlvbkhhbmRsZXIgPSBleGNlcHRpb25faGFuZGxlcl8yLkV4Y2VwdGlvbkhhbmRsZXI7XHJcbnZhciBCYXNlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXNlRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gXCItLVwiOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcihtZXNzYWdlKSkuc3RhY2s7XHJcbiAgICB9XHJcbiAgICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcclxuICAgIHJldHVybiBCYXNlRXhjZXB0aW9uO1xyXG59KShFcnJvcik7XHJcbmV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IEJhc2VFeGNlcHRpb247XHJcbnZhciBXcmFwcGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXcmFwcGVkRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV3JhcHBlZEV4Y2VwdGlvbihfd3JhcHBlck1lc3NhZ2UsIF9vcmlnaW5hbEV4Y2VwdGlvbiwgX29yaWdpbmFsU3RhY2ssIF9jb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX3dyYXBwZXJNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl93cmFwcGVyTWVzc2FnZSA9IF93cmFwcGVyTWVzc2FnZTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbEV4Y2VwdGlvbiA9IF9vcmlnaW5hbEV4Y2VwdGlvbjtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFN0YWNrID0gX29yaWdpbmFsU3RhY2s7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IF9jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGFjayA9IChuZXcgRXJyb3IoX3dyYXBwZXJNZXNzYWdlKSkuc3RhY2s7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwid3JhcHBlck1lc3NhZ2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fd3JhcHBlck1lc3NhZ2U7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIndyYXBwZXJTdGFja1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl93cmFwcGVyU3RhY2s7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsRXhjZXB0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29yaWdpbmFsRXhjZXB0aW9uOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJvcmlnaW5hbFN0YWNrXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29yaWdpbmFsU3RhY2s7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGV4dDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25faGFuZGxlcl8xLkV4Y2VwdGlvbkhhbmRsZXIuZXhjZXB0aW9uVG9TdHJpbmcodGhpcyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lc3NhZ2U7IH07XHJcbiAgICByZXR1cm4gV3JhcHBlZEV4Y2VwdGlvbjtcclxufSkoRXJyb3IpO1xyXG5leHBvcnRzLldyYXBwZWRFeGNlcHRpb24gPSBXcmFwcGVkRXhjZXB0aW9uO1xyXG5mdW5jdGlvbiBtYWtlVHlwZUVycm9yKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xyXG59XHJcbmV4cG9ydHMubWFrZVR5cGVFcnJvciA9IG1ha2VUeXBlRXJyb3I7XHJcbmZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XHJcbiAgICB0aHJvdyBuZXcgQmFzZUV4Y2VwdGlvbigndW5pbXBsZW1lbnRlZCcpO1xyXG59XHJcbmV4cG9ydHMudW5pbXBsZW1lbnRlZCA9IHVuaW1wbGVtZW50ZWQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnOyhmdW5jdGlvbiAoTnVtYmVyRm9ybWF0U3R5bGUpIHtcclxuICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiRGVjaW1hbFwiXSA9IDBdID0gXCJEZWNpbWFsXCI7XHJcbiAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIlBlcmNlbnRcIl0gPSAxXSA9IFwiUGVyY2VudFwiO1xyXG4gICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJDdXJyZW5jeVwiXSA9IDJdID0gXCJDdXJyZW5jeVwiO1xyXG59KShleHBvcnRzLk51bWJlckZvcm1hdFN0eWxlIHx8IChleHBvcnRzLk51bWJlckZvcm1hdFN0eWxlID0ge30pKTtcclxudmFyIE51bWJlckZvcm1hdFN0eWxlID0gZXhwb3J0cy5OdW1iZXJGb3JtYXRTdHlsZTtcclxudmFyIE51bWJlckZvcm1hdHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOdW1iZXJGb3JtYXR0ZXIoKSB7XHJcbiAgICB9XHJcbiAgICBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKG51bWJlciwgbG9jYWxlLCBzdHlsZSwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5taW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUludGVnZXJEaWdpdHMgPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLCBfZCA9IF9iLm1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBfYi5tYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IF9lID09PSB2b2lkIDAgPyAzIDogX2UsIGN1cnJlbmN5ID0gX2IuY3VycmVuY3ksIF9mID0gX2IuY3VycmVuY3lBc1N5bWJvbCwgY3VycmVuY3lBc1N5bWJvbCA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mO1xyXG4gICAgICAgIHZhciBpbnRsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxyXG4gICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcclxuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGludGxPcHRpb25zLnN0eWxlID0gTnVtYmVyRm9ybWF0U3R5bGVbc3R5bGVdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHN0eWxlID09IE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5KSB7XHJcbiAgICAgICAgICAgIGludGxPcHRpb25zLmN1cnJlbmN5ID0gY3VycmVuY3k7XHJcbiAgICAgICAgICAgIGludGxPcHRpb25zLmN1cnJlbmN5RGlzcGxheSA9IGN1cnJlbmN5QXNTeW1ib2wgPyAnc3ltYm9sJyA6ICdjb2RlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGludGxPcHRpb25zKS5mb3JtYXQobnVtYmVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLk51bWJlckZvcm1hdHRlciA9IE51bWJlckZvcm1hdHRlcjtcclxuZnVuY3Rpb24gZGlnaXRDb25kaXRpb24obGVuKSB7XHJcbiAgICByZXR1cm4gbGVuID09IDIgPyAnMi1kaWdpdCcgOiAnbnVtZXJpYyc7XHJcbn1cclxuZnVuY3Rpb24gbmFtZUNvbmRpdGlvbihsZW4pIHtcclxuICAgIHJldHVybiBsZW4gPCA0ID8gJ3Nob3J0JyA6ICdsb25nJztcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50cyhwYXR0ZXJuKSB7XHJcbiAgICB2YXIgcmV0ID0ge307XHJcbiAgICB2YXIgaSA9IDAsIGo7XHJcbiAgICB3aGlsZSAoaSA8IHBhdHRlcm4ubGVuZ3RoKSB7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgd2hpbGUgKGogPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuW2pdID09IHBhdHRlcm5baV0pXHJcbiAgICAgICAgICAgIGorKztcclxuICAgICAgICB2YXIgbGVuID0gaiAtIGk7XHJcbiAgICAgICAgc3dpdGNoIChwYXR0ZXJuW2ldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0cnOlxyXG4gICAgICAgICAgICAgICAgcmV0LmVyYSA9IG5hbWVDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd5JzpcclxuICAgICAgICAgICAgICAgIHJldC55ZWFyID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgICAgIGlmIChsZW4gPj0gMylcclxuICAgICAgICAgICAgICAgICAgICByZXQubW9udGggPSBuYW1lQ29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Lm1vbnRoID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgIHJldC5kYXkgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxyXG4gICAgICAgICAgICAgICAgcmV0LndlZWtkYXkgPSBuYW1lQ29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaic6XHJcbiAgICAgICAgICAgICAgICByZXQuaG91ciA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICByZXQuaG91ciA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICByZXQuaG91cjEyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdIJzpcclxuICAgICAgICAgICAgICAgIHJldC5ob3VyID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIHJldC5ob3VyMTIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgIHJldC5taW51dGUgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgcmV0LnNlY29uZCA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgICAgICByZXQudGltZVpvbmVOYW1lID0gJ2xvbmcnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1onOlxyXG4gICAgICAgICAgICAgICAgcmV0LnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IGo7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbnZhciBkYXRlRm9ybWF0dGVyQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbnZhciBEYXRlRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGVGb3JtYXR0ZXIoKSB7XHJcbiAgICB9XHJcbiAgICBEYXRlRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIHBhdHRlcm4pIHtcclxuICAgICAgICB2YXIga2V5ID0gbG9jYWxlICsgcGF0dGVybjtcclxuICAgICAgICBpZiAoZGF0ZUZvcm1hdHRlckNhY2hlLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRm9ybWF0dGVyQ2FjaGUuZ2V0KGtleSkuZm9ybWF0KGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBleHRyYWN0Q29tcG9uZW50cyhwYXR0ZXJuKSk7XHJcbiAgICAgICAgZGF0ZUZvcm1hdHRlckNhY2hlLnNldChrZXksIGZvcm1hdHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoZGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVGb3JtYXR0ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGF0ZUZvcm1hdHRlciA9IERhdGVGb3JtYXR0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBnbG9iYWxTY29wZTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcclxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXHJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XHJcbiAgICB9XHJcbn1cclxuZWxzZSB7XHJcbiAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcclxufVxyXG47XHJcbi8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxyXG4vLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxyXG52YXIgX2dsb2JhbCA9IGdsb2JhbFNjb3BlO1xyXG5leHBvcnRzLmdsb2JhbCA9IF9nbG9iYWw7XHJcbmV4cG9ydHMuVHlwZSA9IEZ1bmN0aW9uO1xyXG5mdW5jdGlvbiBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh0eXBlKSB7XHJcbiAgICByZXR1cm4gdHlwZVsnbmFtZSddO1xyXG59XHJcbmV4cG9ydHMuZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcgPSBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZztcclxuZXhwb3J0cy5NYXRoID0gX2dsb2JhbC5NYXRoO1xyXG5leHBvcnRzLkRhdGUgPSBfZ2xvYmFsLkRhdGU7XHJcbnZhciBhc3NlcnRpb25zRW5hYmxlZF8gPSB0eXBlb2YgX2dsb2JhbFsnYXNzZXJ0J10gIT09ICd1bmRlZmluZWQnO1xyXG5mdW5jdGlvbiBhc3NlcnRpb25zRW5hYmxlZCgpIHtcclxuICAgIHJldHVybiBhc3NlcnRpb25zRW5hYmxlZF87XHJcbn1cclxuZXhwb3J0cy5hc3NlcnRpb25zRW5hYmxlZCA9IGFzc2VydGlvbnNFbmFibGVkO1xyXG4vLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcclxuLy8gTm90ZTogQ2FuJ3QganVzdCBleHBvcnQgdGhpcyBhbmQgaW1wb3J0IGluIGluIG90aGVyIGZpbGVzXHJcbi8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XHJcbl9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xyXG4gICAgaWYgKGFzc2VydGlvbnNFbmFibGVkXykge1xyXG4gICAgICAgIF9nbG9iYWxbJ2Fzc2VydCddLmNhbGwoY29uZGl0aW9uKTtcclxuICAgIH1cclxufTtcclxuLy8gVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgb25seSB0byBwcm9wZXJseSBzdXBwb3J0IERhcnQncyBjb25zdCBleHByZXNzaW9uc1xyXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvdHMyZGFydC9wdWxsLzE1MSBmb3IgbW9yZSBpbmZvXHJcbmZ1bmN0aW9uIENPTlNUX0VYUFIoZXhwcikge1xyXG4gICAgcmV0dXJuIGV4cHI7XHJcbn1cclxuZXhwb3J0cy5DT05TVF9FWFBSID0gQ09OU1RfRVhQUjtcclxuZnVuY3Rpb24gQ09OU1QoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0OyB9O1xyXG59XHJcbmV4cG9ydHMuQ09OU1QgPSBDT05TVDtcclxuZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcclxuZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XHJcbn1cclxuZXhwb3J0cy5pc0JsYW5rID0gaXNCbGFuaztcclxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcclxufVxyXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcbmZ1bmN0aW9uIGlzVHlwZShvYmopIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iaik7XHJcbn1cclxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XHJcbmZ1bmN0aW9uIGlzU3RyaW5nTWFwKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzU3RyaW5nTWFwID0gaXNTdHJpbmdNYXA7XHJcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsLlByb21pc2U7XHJcbn1cclxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XHJcbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInO1xyXG59XHJcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcclxuZnVuY3Rpb24gaXNEYXRlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XHJcbn1cclxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xyXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCB8fCB0b2tlbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHRva2VuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRva2VuLm5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcclxuICAgIH1cclxuICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xyXG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKFwiXFxuXCIpO1xyXG4gICAgcmV0dXJuIChuZXdMaW5lSW5kZXggPT09IC0xKSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcclxufVxyXG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcclxuLy8gc2VyaWFsaXplIC8gZGVzZXJpYWxpemUgZW51bSBleGlzdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIGRhcnQgQVBJXHJcbi8vIGVudW1zIGluIHR5cGVzY3JpcHQgZG9uJ3QgbmVlZCB0byBiZSBzZXJpYWxpemVkXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVudW0odmFsKSB7XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbmV4cG9ydHMuc2VyaWFsaXplRW51bSA9IHNlcmlhbGl6ZUVudW07XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRW51bSh2YWwsIHZhbHVlcykge1xyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5leHBvcnRzLmRlc2VyaWFsaXplRW51bSA9IGRlc2VyaWFsaXplRW51bTtcclxudmFyIFN0cmluZ1dyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQgPSBmdW5jdGlvbiAocywgaW5kZXgpIHsgcmV0dXJuIHMuY2hhckNvZGVBdChpbmRleCk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnNwbGl0ID0gZnVuY3Rpb24gKHMsIHJlZ0V4cCkgeyByZXR1cm4gcy5zcGxpdChyZWdFeHApOyB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAocywgczIpIHsgcmV0dXJuIHMgPT09IHMyOyB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcclxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxyXG4gICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBzLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIudG9VcHBlckNhc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci50b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocywgc3RhcnQpIHsgcmV0dXJuIHMuc3RhcnRzV2l0aChzdGFydCk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnN1YnN0cmluZyA9IGZ1bmN0aW9uIChzLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVuZCk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XHJcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XHJcbiAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcclxuICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHJlY2VpdmVzIG1hdGNoLCBwMSwgLi4uLCBwblxyXG4gICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhID4gYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TdHJpbmdXcmFwcGVyID0gU3RyaW5nV3JhcHBlcjtcclxudmFyIFN0cmluZ0pvaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdKb2luZXIocGFydHMpIHtcclxuICAgICAgICBpZiAocGFydHMgPT09IHZvaWQgMCkgeyBwYXJ0cyA9IFtdOyB9XHJcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xyXG4gICAgfVxyXG4gICAgU3RyaW5nSm9pbmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocGFydCkgeyB0aGlzLnBhcnRzLnB1c2gocGFydCk7IH07XHJcbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJ0cy5qb2luKFwiXCIpOyB9O1xyXG4gICAgcmV0dXJuIFN0cmluZ0pvaW5lcjtcclxufSkoKTtcclxuZXhwb3J0cy5TdHJpbmdKb2luZXIgPSBTdHJpbmdKb2luZXI7XHJcbnZhciBOdW1iZXJQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOdW1iZXJQYXJzZUVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTnVtYmVyUGFyc2VFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIE51bWJlclBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9O1xyXG4gICAgcmV0dXJuIE51bWJlclBhcnNlRXJyb3I7XHJcbn0pKEVycm9yKTtcclxuZXhwb3J0cy5OdW1iZXJQYXJzZUVycm9yID0gTnVtYmVyUGFyc2VFcnJvcjtcclxudmFyIE51bWJlcldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIE51bWJlcldyYXBwZXIudG9GaXhlZCA9IGZ1bmN0aW9uIChuLCBmcmFjdGlvbkRpZ2l0cykgeyByZXR1cm4gbi50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKTsgfTtcclxuICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcclxuICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcclxuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcclxuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcclxuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQgKyBcIiBpbiBiYXNlIFwiICtcclxuICAgICAgICAgICAgcmFkaXgpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IE5hTiBpcyBhIHZhbGlkIGxpdGVyYWwgYnV0IGlzIHJldHVybmVkIGJ5IHBhcnNlRmxvYXQgdG8gaW5kaWNhdGUgYW4gZXJyb3IuXHJcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlRmxvYXQgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KTsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTnVtYmVyV3JhcHBlci5pc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXNOYU4odmFsdWUpOyB9O1xyXG4gICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xyXG4gICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTnVtYmVyV3JhcHBlciA9IE51bWJlcldyYXBwZXI7XHJcbmV4cG9ydHMuUmVnRXhwID0gX2dsb2JhbC5SZWdFeHA7XHJcbnZhciBSZWdFeHBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZ0V4cFdyYXBwZXIoKSB7XHJcbiAgICB9XHJcbiAgICBSZWdFeHBXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChyZWdFeHBTdHIsIGZsYWdzKSB7XHJcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAnJzsgfVxyXG4gICAgICAgIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgvZy9nLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBfZ2xvYmFsLlJlZ0V4cChyZWdFeHBTdHIsIGZsYWdzICsgJ2cnKTtcclxuICAgIH07XHJcbiAgICBSZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2ggPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xyXG4gICAgICAgIC8vIFJlc2V0IG11bHRpbWF0Y2ggcmVnZXggc3RhdGVcclxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4gcmVnRXhwLmV4ZWMoaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFJlZ0V4cFdyYXBwZXIudGVzdCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XHJcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHJlZ0V4cC50ZXN0KGlucHV0KTtcclxuICAgIH07XHJcbiAgICBSZWdFeHBXcmFwcGVyLm1hdGNoZXIgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xyXG4gICAgICAgIC8vIFJlc2V0IHJlZ2V4IHN0YXRlIGZvciB0aGUgY2FzZVxyXG4gICAgICAgIC8vIHNvbWVvbmUgZGlkIG5vdCBsb29wIG92ZXIgYWxsIG1hdGNoZXNcclxuICAgICAgICAvLyBsYXN0IHRpbWUuXHJcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHsgcmU6IHJlZ0V4cCwgaW5wdXQ6IGlucHV0IH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlZ0V4cFdyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVnRXhwV3JhcHBlciA9IFJlZ0V4cFdyYXBwZXI7XHJcbnZhciBSZWdFeHBNYXRjaGVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWdFeHBNYXRjaGVyV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyLnJlLmV4ZWMobWF0Y2hlci5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlZ0V4cE1hdGNoZXJXcmFwcGVyID0gUmVnRXhwTWF0Y2hlcldyYXBwZXI7XHJcbnZhciBGdW5jdGlvbldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25XcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgRnVuY3Rpb25XcmFwcGVyLmFwcGx5ID0gZnVuY3Rpb24gKGZuLCBwb3NBcmdzKSB7IHJldHVybiBmbi5hcHBseShudWxsLCBwb3NBcmdzKTsgfTtcclxuICAgIHJldHVybiBGdW5jdGlvbldyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRnVuY3Rpb25XcmFwcGVyID0gRnVuY3Rpb25XcmFwcGVyO1xyXG4vLyBKUyBoYXMgTmFOICE9PSBOYU5cclxuZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XHJcbn1cclxuZXhwb3J0cy5sb29zZUlkZW50aWNhbCA9IGxvb3NlSWRlbnRpY2FsO1xyXG4vLyBKUyBjb25zaWRlcnMgTmFOIGlzIHRoZSBzYW1lIGFzIE5hTiBmb3IgbWFwIEtleSAod2hpbGUgTmFOICE9PSBOYU4gb3RoZXJ3aXNlKVxyXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwXHJcbmZ1bmN0aW9uIGdldE1hcEtleSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmV4cG9ydHMuZ2V0TWFwS2V5ID0gZ2V0TWFwS2V5O1xyXG5mdW5jdGlvbiBub3JtYWxpemVCbGFuayhvYmopIHtcclxuICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBudWxsIDogb2JqO1xyXG59XHJcbmV4cG9ydHMubm9ybWFsaXplQmxhbmsgPSBub3JtYWxpemVCbGFuaztcclxuZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcclxuICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBmYWxzZSA6IG9iajtcclxufVxyXG5leHBvcnRzLm5vcm1hbGl6ZUJvb2wgPSBub3JtYWxpemVCb29sO1xyXG5mdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcclxuICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvID09PSBcIm9iamVjdFwiKTtcclxufVxyXG5leHBvcnRzLmlzSnNPYmplY3QgPSBpc0pzT2JqZWN0O1xyXG5mdW5jdGlvbiBwcmludChvYmopIHtcclxuICAgIGNvbnNvbGUubG9nKG9iaik7XHJcbn1cclxuZXhwb3J0cy5wcmludCA9IHByaW50O1xyXG4vLyBDYW4ndCBiZSBhbGwgdXBwZXJjYXNlIGFzIG91ciB0cmFuc3BpbGVyIHdvdWxkIHRoaW5rIGl0IGlzIGEgc3BlY2lhbCBkaXJlY3RpdmUuLi5cclxudmFyIEpzb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSnNvbigpIHtcclxuICAgIH1cclxuICAgIEpzb24ucGFyc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gX2dsb2JhbC5KU09OLnBhcnNlKHMpOyB9O1xyXG4gICAgSnNvbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIC8vIERhcnQgZG9lc24ndCB0YWtlIDMgYXJndW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIF9nbG9iYWwuSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpzb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuSnNvbiA9IEpzb247XHJcbnZhciBEYXRlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIERhdGVXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IDE7IH1cclxuICAgICAgICBpZiAoZGF5ID09PSB2b2lkIDApIHsgZGF5ID0gMTsgfVxyXG4gICAgICAgIGlmIChob3VyID09PSB2b2lkIDApIHsgaG91ciA9IDA7IH1cclxuICAgICAgICBpZiAobWludXRlcyA9PT0gdm9pZCAwKSB7IG1pbnV0ZXMgPSAwOyB9XHJcbiAgICAgICAgaWYgKHNlY29uZHMgPT09IHZvaWQgMCkgeyBzZWNvbmRzID0gMDsgfVxyXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMgPT09IHZvaWQgMCkgeyBtaWxsaXNlY29uZHMgPSAwOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVdyYXBwZXIuZnJvbUlTT1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoc3RyKTsgfTtcclxuICAgIERhdGVXcmFwcGVyLmZyb21NaWxsaXMgPSBmdW5jdGlvbiAobXMpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUobXMpOyB9O1xyXG4gICAgRGF0ZVdyYXBwZXIudG9NaWxsaXMgPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7IH07XHJcbiAgICBEYXRlV3JhcHBlci5ub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKCk7IH07XHJcbiAgICBEYXRlV3JhcHBlci50b0pzb24gPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0pTT04oKTsgfTtcclxuICAgIHJldHVybiBEYXRlV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRlV3JhcHBlciA9IERhdGVXcmFwcGVyO1xyXG5mdW5jdGlvbiBzZXRWYWx1ZU9uUGF0aChnbG9iYWwsIHBhdGgsIHZhbHVlKSB7XHJcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICB2YXIgb2JqID0gZ2xvYmFsO1xyXG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICBvYmogPSBvYmpbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYmogPSBvYmpbbmFtZV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgb2JqID0ge307XHJcbiAgICB9XHJcbiAgICBvYmpbcGFydHMuc2hpZnQoKV0gPSB2YWx1ZTtcclxufVxyXG5leHBvcnRzLnNldFZhbHVlT25QYXRoID0gc2V0VmFsdWVPblBhdGg7XHJcbnZhciBfc3ltYm9sSXRlcmF0b3IgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcclxuICAgIGlmIChpc0JsYW5rKF9zeW1ib2xJdGVyYXRvcikpIHtcclxuICAgICAgICBpZiAoaXNQcmVzZW50KFN5bWJvbCkgJiYgaXNQcmVzZW50KFN5bWJvbC5pdGVyYXRvcikpIHtcclxuICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcclxufVxyXG5leHBvcnRzLmdldFN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG5leHBvcnRzLk1hdGggPSBsYW5nXzEuZ2xvYmFsLk1hdGg7XHJcbmV4cG9ydHMuTmFOID0gdHlwZW9mIGV4cG9ydHMuTmFOO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogQG1vZHVsZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhpcyBtb2R1bGUgaXMgdXNlZCBmb3IgaGFuZGxpbmcgdXNlciBpbnB1dCwgYnkgZGVmaW5pbmcgYW5kIGJ1aWxkaW5nIGEge0BsaW5rIENvbnRyb2xHcm91cH0gdGhhdFxyXG4gKiBjb25zaXN0cyBvZlxyXG4gKiB7QGxpbmsgQ29udHJvbH0gb2JqZWN0cywgYW5kIG1hcHBpbmcgdGhlbSBvbnRvIHRoZSBET00uIHtAbGluayBDb250cm9sfSBvYmplY3RzIGNhbiB0aGVuIGJlIHVzZWRcclxuICogdG8gcmVhZCBpbmZvcm1hdGlvblxyXG4gKiBmcm9tIHRoZSBmb3JtIERPTSBlbGVtZW50cy5cclxuICpcclxuICogVGhpcyBtb2R1bGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBgYW5ndWxhcjJgIG1vZHVsZTsgeW91IG11c3QgaW1wb3J0IHRoZSBmb3JtcyBtb2R1bGVcclxuICogZXhwbGljaXRseS5cclxuICpcclxuICovXHJcbnZhciBtb2RlbF8xID0gcmVxdWlyZSgnLi9mb3Jtcy9tb2RlbCcpO1xyXG5leHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IG1vZGVsXzEuQWJzdHJhY3RDb250cm9sO1xyXG5leHBvcnRzLkNvbnRyb2wgPSBtb2RlbF8xLkNvbnRyb2w7XHJcbmV4cG9ydHMuQ29udHJvbEdyb3VwID0gbW9kZWxfMS5Db250cm9sR3JvdXA7XHJcbmV4cG9ydHMuQ29udHJvbEFycmF5ID0gbW9kZWxfMS5Db250cm9sQXJyYXk7XHJcbnZhciBhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlJyk7XHJcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMS5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XHJcbnZhciBjb250cm9sX2NvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2NvbnRyb2xfY29udGFpbmVyJyk7XHJcbmV4cG9ydHMuQ29udHJvbENvbnRhaW5lciA9IGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lcjtcclxudmFyIG5nX2NvbnRyb2xfbmFtZV8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfbmFtZScpO1xyXG5leHBvcnRzLk5nQ29udHJvbE5hbWUgPSBuZ19jb250cm9sX25hbWVfMS5OZ0NvbnRyb2xOYW1lO1xyXG52YXIgbmdfZm9ybV9jb250cm9sXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfZm9ybV9jb250cm9sJyk7XHJcbmV4cG9ydHMuTmdGb3JtQ29udHJvbCA9IG5nX2Zvcm1fY29udHJvbF8xLk5nRm9ybUNvbnRyb2w7XHJcbnZhciBuZ19tb2RlbF8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL25nX21vZGVsJyk7XHJcbmV4cG9ydHMuTmdNb2RlbCA9IG5nX21vZGVsXzEuTmdNb2RlbDtcclxudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sID0gbmdfY29udHJvbF8xLk5nQ29udHJvbDtcclxudmFyIG5nX2NvbnRyb2xfZ3JvdXBfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX2dyb3VwJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sR3JvdXAgPSBuZ19jb250cm9sX2dyb3VwXzEuTmdDb250cm9sR3JvdXA7XHJcbnZhciBuZ19mb3JtX21vZGVsXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfZm9ybV9tb2RlbCcpO1xyXG5leHBvcnRzLk5nRm9ybU1vZGVsID0gbmdfZm9ybV9tb2RlbF8xLk5nRm9ybU1vZGVsO1xyXG52YXIgbmdfZm9ybV8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL25nX2Zvcm0nKTtcclxuZXhwb3J0cy5OZ0Zvcm0gPSBuZ19mb3JtXzEuTmdGb3JtO1xyXG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcclxuZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMS5EZWZhdWx0VmFsdWVBY2Nlc3NvcjtcclxudmFyIG5nX2NvbnRyb2xfc3RhdHVzXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9zdGF0dXMnKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBuZ19jb250cm9sX3N0YXR1c18xLk5nQ29udHJvbFN0YXR1cztcclxudmFyIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvY2hlY2tib3hfdmFsdWVfYWNjZXNzb3InKTtcclxuZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMS5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xyXG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG5leHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OZ1NlbGVjdE9wdGlvbjtcclxuZXhwb3J0cy5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbnZhciBkaXJlY3RpdmVzXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMnKTtcclxuZXhwb3J0cy5GT1JNX0RJUkVDVElWRVMgPSBkaXJlY3RpdmVzXzEuRk9STV9ESVJFQ1RJVkVTO1xyXG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi9mb3Jtcy92YWxpZGF0b3JzJyk7XHJcbmV4cG9ydHMuTkdfVkFMSURBVE9SUyA9IHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTO1xyXG5leHBvcnRzLlZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycztcclxudmFyIHZhbGlkYXRvcnNfMiA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy92YWxpZGF0b3JzJyk7XHJcbmV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuUmVxdWlyZWRWYWxpZGF0b3I7XHJcbmV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLk1pbkxlbmd0aFZhbGlkYXRvcjtcclxuZXhwb3J0cy5NYXhMZW5ndGhWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuTWF4TGVuZ3RoVmFsaWRhdG9yO1xyXG52YXIgZm9ybV9idWlsZGVyXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2Zvcm1fYnVpbGRlcicpO1xyXG5leHBvcnRzLkZvcm1CdWlsZGVyID0gZm9ybV9idWlsZGVyXzEuRm9ybUJ1aWxkZXI7XHJcbnZhciBmb3JtX2J1aWxkZXJfMiA9IHJlcXVpcmUoJy4vZm9ybXMvZm9ybV9idWlsZGVyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBTaG9ydGhhbmQgc2V0IG9mIHByb3ZpZGVycyB1c2VkIGZvciBidWlsZGluZyBBbmd1bGFyIGZvcm1zLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBib290c3RyYXAoTXlBcHAsIFtGT1JNX1BST1ZJREVSU10pO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuRk9STV9QUk9WSURFUlMgPSBsYW5nXzEuQ09OU1RfRVhQUihbZm9ybV9idWlsZGVyXzIuRm9ybUJ1aWxkZXJdKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5leHBvcnRzLkZPUk1fQklORElOR1MgPSBleHBvcnRzLkZPUk1fUFJPVklERVJTO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3Jtcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBuZ19jb250cm9sX25hbWVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUnKTtcclxudmFyIG5nX2Zvcm1fY29udHJvbF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fY29udHJvbCcpO1xyXG52YXIgbmdfbW9kZWxfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19tb2RlbCcpO1xyXG52YXIgbmdfY29udHJvbF9ncm91cF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAnKTtcclxudmFyIG5nX2Zvcm1fbW9kZWxfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3JtX21vZGVsJyk7XHJcbnZhciBuZ19mb3JtXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9ybScpO1xyXG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvY2hlY2tib3hfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIG5nX2NvbnRyb2xfc3RhdHVzXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9zdGF0dXMnKTtcclxudmFyIHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy92YWxpZGF0b3JzJyk7XHJcbnZhciBuZ19jb250cm9sX25hbWVfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUnKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xOYW1lID0gbmdfY29udHJvbF9uYW1lXzIuTmdDb250cm9sTmFtZTtcclxudmFyIG5nX2Zvcm1fY29udHJvbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fY29udHJvbCcpO1xyXG5leHBvcnRzLk5nRm9ybUNvbnRyb2wgPSBuZ19mb3JtX2NvbnRyb2xfMi5OZ0Zvcm1Db250cm9sO1xyXG52YXIgbmdfbW9kZWxfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19tb2RlbCcpO1xyXG5leHBvcnRzLk5nTW9kZWwgPSBuZ19tb2RlbF8yLk5nTW9kZWw7XHJcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbCcpO1xyXG5leHBvcnRzLk5nQ29udHJvbCA9IG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2w7XHJcbnZhciBuZ19jb250cm9sX2dyb3VwXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9ncm91cCcpO1xyXG5leHBvcnRzLk5nQ29udHJvbEdyb3VwID0gbmdfY29udHJvbF9ncm91cF8yLk5nQ29udHJvbEdyb3VwO1xyXG52YXIgbmdfZm9ybV9tb2RlbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fbW9kZWwnKTtcclxuZXhwb3J0cy5OZ0Zvcm1Nb2RlbCA9IG5nX2Zvcm1fbW9kZWxfMi5OZ0Zvcm1Nb2RlbDtcclxudmFyIG5nX2Zvcm1fMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3JtJyk7XHJcbmV4cG9ydHMuTmdGb3JtID0gbmdfZm9ybV8yLk5nRm9ybTtcclxudmFyIGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yJyk7XHJcbmV4cG9ydHMuRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzIuRGVmYXVsdFZhbHVlQWNjZXNzb3I7XHJcbnZhciBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XHJcbmV4cG9ydHMuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzIuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcclxudmFyIHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcclxuZXhwb3J0cy5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzIuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbmV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8yLk5nU2VsZWN0T3B0aW9uO1xyXG52YXIgdmFsaWRhdG9yc18yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMnKTtcclxuZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5SZXF1aXJlZFZhbGlkYXRvcjtcclxuZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuTWluTGVuZ3RoVmFsaWRhdG9yO1xyXG5leHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5NYXhMZW5ndGhWYWxpZGF0b3I7XHJcbnZhciBuZ19jb250cm9sX3N0YXR1c18yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfc3RhdHVzJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sU3RhdHVzID0gbmdfY29udHJvbF9zdGF0dXNfMi5OZ0NvbnRyb2xTdGF0dXM7XHJcbi8qKlxyXG4gKlxyXG4gKiBBIGxpc3Qgb2YgYWxsIHRoZSBmb3JtIGRpcmVjdGl2ZXMgdXNlZCBhcyBwYXJ0IG9mIGEgYEBWaWV3YCBhbm5vdGF0aW9uLlxyXG4gKlxyXG4gKiAgVGhpcyBpcyBhIHNob3J0aGFuZCBmb3IgaW1wb3J0aW5nIHRoZW0gZWFjaCBpbmRpdmlkdWFsbHkuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcclxuICogICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBNeUFwcCB7fVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuRk9STV9ESVJFQ1RJVkVTID0gbGFuZ18xLkNPTlNUX0VYUFIoW1xyXG4gICAgbmdfY29udHJvbF9uYW1lXzEuTmdDb250cm9sTmFtZSxcclxuICAgIG5nX2NvbnRyb2xfZ3JvdXBfMS5OZ0NvbnRyb2xHcm91cCxcclxuICAgIG5nX2Zvcm1fY29udHJvbF8xLk5nRm9ybUNvbnRyb2wsXHJcbiAgICBuZ19tb2RlbF8xLk5nTW9kZWwsXHJcbiAgICBuZ19mb3JtX21vZGVsXzEuTmdGb3JtTW9kZWwsXHJcbiAgICBuZ19mb3JtXzEuTmdGb3JtLFxyXG4gICAgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OZ1NlbGVjdE9wdGlvbixcclxuICAgIGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMS5EZWZhdWx0VmFsdWVBY2Nlc3NvcixcclxuICAgIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcclxuICAgIHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXHJcbiAgICBuZ19jb250cm9sX3N0YXR1c18xLk5nQ29udHJvbFN0YXR1cyxcclxuICAgIHZhbGlkYXRvcnNfMS5SZXF1aXJlZFZhbGlkYXRvcixcclxuICAgIHZhbGlkYXRvcnNfMS5NaW5MZW5ndGhWYWxpZGF0b3IsXHJcbiAgICB2YWxpZGF0b3JzXzEuTWF4TGVuZ3RoVmFsaWRhdG9yXHJcbl0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsaWQgOiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wuZXJyb3JzIDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC50b3VjaGVkIDogbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcclxufSkoKTtcclxuZXhwb3J0cy5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlcicpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSwgbXVsdGk6IHRydWUgfSkpO1xyXG4vKipcclxuICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgY2hlY2tib3ggaW5wdXQgZWxlbWVudC5cclxuICpcclxuICogICMgRXhhbXBsZVxyXG4gKiAgYGBgXHJcbiAqICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW25nLWNvbnRyb2xdPVwicmVtZW1iZXJMb2dpblwiPlxyXG4gKiAgYGBgXHJcbiAqL1xyXG52YXIgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XHJcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9XHJcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHNoYXJlZF8xLnNldFByb3BlcnR5KHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9lbGVtZW50UmVmLCBcImNoZWNrZWRcIiwgdmFsdWUpOyB9O1xyXG4gICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XHJcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xyXG4gICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPWNoZWNrYm94XVtuZy1jb250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtuZy1mb3JtLWNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nLW1vZGVsXScsXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQuY2hlY2tlZCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxyXG4gICAgICAgIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtyZW5kZXJfMS5SZW5kZXJlciwgbGlua2VyXzEuRWxlbWVudFJlZl0pXHJcbiAgICBdLCBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKTtcclxuICAgIHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja2JveF92YWx1ZV9hY2Nlc3Nvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlJyk7XHJcbi8qKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnRhaW5zIG11bHRpcGxlIHtAbGluayBOZ0NvbnRyb2x9LlxyXG4gKlxyXG4gKiBPbmx5IHVzZWQgYnkgdGhlIGZvcm1zIG1vZHVsZS5cclxuICovXHJcbnZhciBDb250cm9sQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250cm9sQ29udGFpbmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udHJvbENvbnRhaW5lcigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29udHJvbENvbnRhaW5lcjtcclxufSkoYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMS5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUpO1xyXG5leHBvcnRzLkNvbnRyb2xDb250YWluZXIgPSBDb250cm9sQ29udGFpbmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sX2NvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuZXhwb3J0cy5OR19WQUxVRV9BQ0NFU1NPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLk9wYXF1ZVRva2VuKFwiTmdWYWx1ZUFjY2Vzc29yXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbF92YWx1ZV9hY2Nlc3Nvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIHJlbmRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIERFRkFVTFRfVkFMVUVfQUNDRVNTT1IgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjsgfSksIG11bHRpOiB0cnVlIH0pKTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcclxuICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgTmdGb3JtQ29udHJvbH0sIGFuZCB7QGxpbmsgTmdDb250cm9sTmFtZX0gZGlyZWN0aXZlcy5cclxuICpcclxuICogICMgRXhhbXBsZVxyXG4gKiAgYGBgXHJcbiAqICA8aW5wdXQgdHlwZT1cInRleHRcIiBbKG5nLW1vZGVsKV09XCJzZWFyY2hRdWVyeVwiPlxyXG4gKiAgYGBgXHJcbiAqL1xyXG52YXIgRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcclxuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH1cclxuICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IGxhbmdfMS5pc0JsYW5rKHZhbHVlKSA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgc2hhcmVkXzEuc2V0UHJvcGVydHkodGhpcy5fcmVuZGVyZXIsIHRoaXMuX2VsZW1lbnRSZWYsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xyXG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XHJcbiAgICBEZWZhdWx0VmFsdWVBY2Nlc3NvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctY29udHJvbF0sW25nLW1vZGVsXSxbbmctZm9ybS1jb250cm9sXScsXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXHJcbiAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXHJcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW0RFRkFVTFRfVkFMVUVfQUNDRVNTT1JdXHJcbiAgICAgICAgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JlbmRlcl8xLlJlbmRlcmVyLCBsaW5rZXJfMS5FbGVtZW50UmVmXSlcclxuICAgIF0sIERlZmF1bHRWYWx1ZUFjY2Vzc29yKTtcclxuICAgIHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjtcclxufSkoKTtcclxuZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoJy4vYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUnKTtcclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyB0aGF0IGFsbCBjb250cm9sIGRpcmVjdGl2ZSBleHRlbmQuXHJcbiAqIEl0IGJpbmRzIGEge0BsaW5rIENvbnRyb2x9IG9iamVjdCB0byBhIERPTSBlbGVtZW50LlxyXG4gKi9cclxuLy8gQ2Fubm90IGN1cnJlbnRseSBiZSBhYnN0cmFjdCBiZWNhdXNlIGl0IHdvdWxkIGNvbnRhaW5cclxuLy8gYW4gYWJzdHJhY3QgbWV0aG9kIGluIHRoZSBwdWJsaWMgQVBJLCBhbmQgd2UgY2Fubm90IHJlZmxlY3RcclxuLy8gb24gdGhhdCBpbiBEYXJ0IGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vZGFydC1sYW5nL3Nkay9pc3N1ZXMvMTg3MjFcclxuLy8gQWxzbyB3ZSBkb24ndCBoYXZlIGFic3RyYWN0IHNldHRlcnMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2NjlcclxudmFyIE5nQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmdDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmdDb250cm9sKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0NvbnRyb2wucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7IH07XHJcbiAgICByZXR1cm4gTmdDb250cm9sO1xyXG59KShhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSk7XHJcbmV4cG9ydHMuTmdDb250cm9sID0gTmdDb250cm9sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19jb250cm9sLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbnRyb2xfY29udGFpbmVyXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfY29udGFpbmVyJyk7XHJcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XHJcbnZhciBjb250cm9sR3JvdXBCaW5kaW5nID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyLCB7IHVzZUV4aXN0aW5nOiBkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdDb250cm9sR3JvdXA7IH0pIH0pKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIGJpbmRzIGEgY29udHJvbCBncm91cCB0byBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge0BsaW5rIE5nRm9ybX0gb3Ige0BsaW5rIE5nRm9ybU1vZGVsfS5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIHRoZSBjcmVkZW50aWFscyBhbmQgcGVyc29uYWwgY29udHJvbCBncm91cHMuXHJcbiAqIFdlIGNhbiB3b3JrIHdpdGggZWFjaCBncm91cCBzZXBhcmF0ZWx5OiBjaGVjayBpdHMgdmFsaWRpdHksIGdldCBpdHMgdmFsdWUsIGxpc3RlbiB0byBpdHMgY2hhbmdlcy5cclxuICpcclxuICogIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICAgICBzZWxlY3RvcjogXCJzaWdudXAtY29tcFwiLFxyXG4gKiAgICAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdLFxyXG4gKiAgICAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICAgICAgICAgICA8Zm9ybSAjZj1cImZvcm1cIiAoc3VibWl0KT0nb25TaWduVXAoZi52YWx1ZSknPlxyXG4gKiAgICAgICAgICAgICAgICA8ZGl2IG5nLWNvbnRyb2wtZ3JvdXA9J2NyZWRlbnRpYWxzJyAjY3JlZGVudGlhbHM9XCJmb3JtXCI+XHJcbiAqICAgICAgICAgICAgICAgICAgTG9naW4gPGlucHV0IHR5cGU9J3RleHQnIG5nLWNvbnRyb2w9J2xvZ2luJz5cclxuICogICAgICAgICAgICAgICAgICBQYXNzd29yZCA8aW5wdXQgdHlwZT0ncGFzc3dvcmQnIG5nLWNvbnRyb2w9J3Bhc3N3b3JkJz5cclxuICogICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAqICAgICAgICAgICAgICAgIDxkaXYgKm5nLWlmPVwiIWNyZWRlbnRpYWxzLnZhbGlkXCI+Q3JlZGVudGlhbHMgYXJlIGludmFsaWQ8L2Rpdj5cclxuICpcclxuICogICAgICAgICAgICAgICAgPGRpdiBuZy1jb250cm9sLWdyb3VwPSdwZXJzb25hbCc+XHJcbiAqICAgICAgICAgICAgICAgICAgTmFtZSA8aW5wdXQgdHlwZT0ndGV4dCcgbmctY29udHJvbD0nbmFtZSc+XHJcbiAqICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gKiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J3N1Ym1pdCc+U2lnbiBVcCE8L2J1dHRvbj5cclxuICogICAgICAgICAgICAgIDwvZm9ybT5cclxuICogICAgICBgfSlcclxuICogY2xhc3MgU2lnbnVwQ29tcCB7XHJcbiAqICBvblNpZ25VcCh2YWx1ZSkge1xyXG4gKiAgICAvLyB2YWx1ZSA9PT0ge1xyXG4gKiAgICAvLyAgcGVyc29uYWw6IHtuYW1lOiAnc29tZSBuYW1lJ30sXHJcbiAqICAgIC8vICBjcmVkZW50aWFsczoge2xvZ2luOiAnc29tZSBsb2dpbicsIHBhc3N3b3JkOiAnc29tZSBwYXNzd29yZCd9fVxyXG4gKiAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ0NvbnRyb2xHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmdDb250cm9sR3JvdXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ0NvbnRyb2xHcm91cChfcGFyZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcclxuICAgIH1cclxuICAgIE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZS5vbkluaXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sR3JvdXAodGhpcyk7IH07XHJcbiAgICBOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbEdyb3VwKHRoaXMpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRDb250cm9sR3JvdXAodGhpcyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8xLmNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sR3JvdXAucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdDb250cm9sR3JvdXAgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nLWNvbnRyb2wtZ3JvdXBdJyxcclxuICAgICAgICAgICAgYmluZGluZ3M6IFtjb250cm9sR3JvdXBCaW5kaW5nXSxcclxuICAgICAgICAgICAgaW5wdXRzOiBbJ25hbWU6IG5nLWNvbnRyb2wtZ3JvdXAnXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdmb3JtJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5Ib3N0KCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5Ta2lwU2VsZigpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyXSlcclxuICAgIF0sIE5nQ29udHJvbEdyb3VwKTtcclxuICAgIHJldHVybiBOZ0NvbnRyb2xHcm91cDtcclxufSkoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xHcm91cCA9IE5nQ29udHJvbEdyb3VwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19jb250cm9sX2dyb3VwLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbnRyb2xfY29udGFpbmVyXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfY29udGFpbmVyJyk7XHJcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL25nX2NvbnRyb2wnKTtcclxudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xyXG52YXIgY29udHJvbE5hbWVCaW5kaW5nID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIobmdfY29udHJvbF8xLk5nQ29udHJvbCwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nQ29udHJvbE5hbWU7IH0pIH0pKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIGJpbmRzIGEgY29udHJvbCB3aXRoIGEgc3BlY2lmaWVkIG5hbWUgdG8gYSBET00gZWxlbWVudC5cclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGNoaWxkIG9mIHtAbGluayBOZ0Zvcm19IG9yIHtAbGluayBOZ0Zvcm1Nb2RlbH0uXHJcblxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgdGhlIGxvZ2luIGFuZCBwYXNzd29yZCBjb250cm9scy5cclxuICogV2UgY2FuIHdvcmsgd2l0aCBlYWNoIGNvbnRyb2wgc2VwYXJhdGVseTogY2hlY2sgaXRzIHZhbGlkaXR5LCBnZXQgaXRzIHZhbHVlLCBsaXN0ZW4gdG8gaXRzXHJcbiAqIGNoYW5nZXMuXHJcbiAqXHJcbiAqICBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgICAgc2VsZWN0b3I6IFwibG9naW4tY29tcFwiLFxyXG4gKiAgICAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdLFxyXG4gKiAgICAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICAgICA8Zm9ybSAjZj1cImZvcm1cIiAoc3VibWl0KT0nb25Mb2dJbihmLnZhbHVlKSc+XHJcbiAqICAgICAgICAgIExvZ2luIDxpbnB1dCB0eXBlPSd0ZXh0JyBuZy1jb250cm9sPSdsb2dpbicgI2w9XCJmb3JtXCI+XHJcbiAqICAgICAgICAgIDxkaXYgKm5nLWlmPVwiIWwudmFsaWRcIj5Mb2dpbiBpcyBpbnZhbGlkPC9kaXY+XHJcbiAqXHJcbiAqICAgICAgICAgIFBhc3N3b3JkIDxpbnB1dCB0eXBlPSdwYXNzd29yZCcgbmctY29udHJvbD0ncGFzc3dvcmQnPlxyXG4gKiAgICAgICAgICA8YnV0dG9uIHR5cGU9J3N1Ym1pdCc+TG9nIGluITwvYnV0dG9uPlxyXG4gKiAgICAgICAgPC9mb3JtPlxyXG4gKiAgICAgIGB9KVxyXG4gKiBjbGFzcyBMb2dpbkNvbXAge1xyXG4gKiAgb25Mb2dJbih2YWx1ZSk6IHZvaWQge1xyXG4gKiAgICAvLyB2YWx1ZSA9PT0ge2xvZ2luOiAnc29tZSBsb2dpbicsIHBhc3N3b3JkOiAnc29tZSBwYXNzd29yZCd9XHJcbiAqICB9XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKlxyXG4gKiBXZSBjYW4gYWxzbyB1c2UgbmctbW9kZWwgdG8gYmluZCBhIGRvbWFpbiBtb2RlbCB0byB0aGUgZm9ybS5cclxuICpcclxuICogIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICAgICBzZWxlY3RvcjogXCJsb2dpbi1jb21wXCIsXHJcbiAqICAgICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU10sXHJcbiAqICAgICAgdGVtcGxhdGU6IGBcclxuICogICAgICAgIDxmb3JtIChzdWJtaXQpPSdvbkxvZ0luKCknPlxyXG4gKiAgICAgICAgICBMb2dpbiA8aW5wdXQgdHlwZT0ndGV4dCcgbmctY29udHJvbD0nbG9naW4nIFsobmctbW9kZWwpXT1cImNyZWRlbnRpYWxzLmxvZ2luXCI+XHJcbiAqICAgICAgICAgIFBhc3N3b3JkIDxpbnB1dCB0eXBlPSdwYXNzd29yZCcgbmctY29udHJvbD0ncGFzc3dvcmQnXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nLW1vZGVsKV09XCJjcmVkZW50aWFscy5wYXNzd29yZFwiPlxyXG4gKiAgICAgICAgICA8YnV0dG9uIHR5cGU9J3N1Ym1pdCc+TG9nIGluITwvYnV0dG9uPlxyXG4gKiAgICAgICAgPC9mb3JtPlxyXG4gKiAgICAgIGB9KVxyXG4gKiBjbGFzcyBMb2dpbkNvbXAge1xyXG4gKiAgY3JlZGVudGlhbHM6IHtsb2dpbjpzdHJpbmcsIHBhc3N3b3JkOnN0cmluZ307XHJcbiAqXHJcbiAqICBvbkxvZ0luKCk6IHZvaWQge1xyXG4gKiAgICAvLyB0aGlzLmNyZWRlbnRpYWxzLmxvZ2luID09PSBcInNvbWUgbG9naW5cIlxyXG4gKiAgICAvLyB0aGlzLmNyZWRlbnRpYWxzLnBhc3N3b3JkID09PSBcInNvbWUgcGFzc3dvcmRcIlxyXG4gKiAgfVxyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ0NvbnRyb2xOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0NvbnRyb2xOYW1lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmdDb250cm9sTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcclxuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzaGFyZWRfMS5zZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcclxuICAgIH1cclxuICAgIE5nQ29udHJvbE5hbWUucHJvdG90eXBlLm9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcmVkXzEuaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnVwZGF0ZU1vZGVsKHRoaXMsIHRoaXMubW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpOyB9O1xyXG4gICAgTmdDb250cm9sTmFtZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQodGhpcy51cGRhdGUsIG5ld1ZhbHVlKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sTmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMS5jb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldENvbnRyb2wodGhpcyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbE5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlKHRoaXMudmFsaWRhdG9ycyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdDb250cm9sTmFtZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctY29udHJvbF0nLFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW2NvbnRyb2xOYW1lQmluZGluZ10sXHJcbiAgICAgICAgICAgIGlucHV0czogWyduYW1lOiBuZ0NvbnRyb2wnLCAnbW9kZWw6IG5nTW9kZWwnXSxcclxuICAgICAgICAgICAgb3V0cHV0czogWyd1cGRhdGU6IG5nTW9kZWxDaGFuZ2UnXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdmb3JtJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5Ib3N0KCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5Ta2lwU2VsZigpKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGRpXzEuT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLkluamVjdCh2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUykpLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgZGlfMS5PcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDIsIGRpXzEuSW5qZWN0KGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUikpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIsIEFycmF5LCBBcnJheV0pXHJcbiAgICBdLCBOZ0NvbnRyb2xOYW1lKTtcclxuICAgIHJldHVybiBOZ0NvbnRyb2xOYW1lO1xyXG59KShuZ19jb250cm9sXzEuTmdDb250cm9sKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xOYW1lID0gTmdDb250cm9sTmFtZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfY29udHJvbF9uYW1lLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9uZ19jb250cm9sJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgTmdDb250cm9sU3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nQ29udHJvbFN0YXR1cyhjZCkge1xyXG4gICAgICAgIHRoaXMuX2NkID0gY2Q7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVW50b3VjaGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnVudG91Y2hlZCA6IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1RvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wudG91Y2hlZCA6IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ByaXN0aW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnByaXN0aW5lIDogZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzRGlydHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wuZGlydHkgOiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NWYWxpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC52YWxpZCA6IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0ludmFsaWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/ICF0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0NvbnRyb2xTdGF0dXMgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nLWNvbnRyb2xdLFtuZy1tb2RlbF0sW25nLWZvcm0tY29udHJvbF0nLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXVudG91Y2hlZF0nOiAnbmdDbGFzc1VudG91Y2hlZCcsXHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ25nQ2xhc3NUb3VjaGVkJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctcHJpc3RpbmVdJzogJ25nQ2xhc3NQcmlzdGluZScsXHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLWRpcnR5XSc6ICduZ0NsYXNzRGlydHknLFxyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnbmdDbGFzc1ZhbGlkJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctaW52YWxpZF0nOiAnbmdDbGFzc0ludmFsaWQnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDAsIGRpXzEuU2VsZigpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbmdfY29udHJvbF8xLk5nQ29udHJvbF0pXHJcbiAgICBdLCBOZ0NvbnRyb2xTdGF0dXMpO1xyXG4gICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1cztcclxufSkoKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBOZ0NvbnRyb2xTdGF0dXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2NvbnRyb2xfc3RhdHVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcclxudmFyIG1vZGVsXzEgPSByZXF1aXJlKCcuLi9tb2RlbCcpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyLCB7IHVzZUV4aXN0aW5nOiBkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdGb3JtOyB9KSB9KSk7XHJcbi8qKlxyXG4gKiBJZiBgTmdGb3JtYCBpcyBib3VuZCBpbiBhIGNvbXBvbmVudCwgYDxmb3JtPmAgZWxlbWVudHMgaW4gdGhhdCBjb21wb25lbnQgd2lsbCBiZVxyXG4gKiB1cGdyYWRlZCB0byB1c2UgdGhlIEFuZ3VsYXIgZm9ybSBzeXN0ZW0uXHJcbiAqXHJcbiAqICMgVHlwaWNhbCBVc2VcclxuICpcclxuICogSW5jbHVkZSBgRk9STV9ESVJFQ1RJVkVTYCBpbiB0aGUgYGRpcmVjdGl2ZXNgIHNlY3Rpb24gb2YgYSB7QGxpbmsgVmlld30gYW5ub3RhdGlvblxyXG4gKiB0byB1c2UgYE5nRm9ybWAgYW5kIGl0cyBhc3NvY2lhdGVkIGNvbnRyb2xzLlxyXG4gKlxyXG4gKiAjIFN0cnVjdHVyZVxyXG4gKlxyXG4gKiBBbiBBbmd1bGFyIGZvcm0gaXMgYSBjb2xsZWN0aW9uIG9mIGBDb250cm9sYHMgaW4gc29tZSBoaWVyYXJjaHkuXHJcbiAqIGBDb250cm9sYHMgY2FuIGJlIGF0IHRoZSB0b3AgbGV2ZWwgb3IgY2FuIGJlIG9yZ2FuaXplZCBpbiBgQ29udHJvbEdyb3VwYHNcclxuICogb3IgYENvbnRyb2xBcnJheWBzLiBUaGlzIGhpZXJhcmNoeSBpcyByZWZsZWN0ZWQgaW4gdGhlIGZvcm0ncyBgdmFsdWVgLCBhXHJcbiAqIEpTT04gb2JqZWN0IHRoYXQgbWlycm9ycyB0aGUgZm9ybSBzdHJ1Y3R1cmUuXHJcbiAqXHJcbiAqICMgU3VibWlzc2lvblxyXG4gKlxyXG4gKiBUaGUgYG5nLXN1Ym1pdGAgZXZlbnQgc2lnbmFscyB3aGVuIHRoZSB1c2VyIHRyaWdnZXJzIGEgZm9ybSBzdWJtaXNzaW9uLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvbHRkZ1lqNFAwaVk2NEFSNzFFcEw/cD1wcmV2aWV3KSlcclxuICpcclxuICogIGBgYHR5cGVzY3JpcHRcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8ZGl2PlxyXG4gKiAgICAgICA8cD5TdWJtaXQgdGhlIGZvcm0gdG8gc2VlIHRoZSBkYXRhIG9iamVjdCBBbmd1bGFyIGJ1aWxkczwvcD5cclxuICogICAgICAgPGgyPk5nRm9ybSBkZW1vPC9oMj5cclxuICogICAgICAgPGZvcm0gI2Y9XCJmb3JtXCIgKG5nLXN1Ym1pdCk9XCJvblN1Ym1pdChmLnZhbHVlKVwiPlxyXG4gKiAgICAgICAgIDxoMz5Db250cm9sIGdyb3VwOiBjcmVkZW50aWFsczwvaDM+XHJcbiAqICAgICAgICAgPGRpdiBuZy1jb250cm9sLWdyb3VwPVwiY3JlZGVudGlhbHNcIj5cclxuICogICAgICAgICAgIDxwPkxvZ2luOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1jb250cm9sPVwibG9naW5cIj48L3A+XHJcbiAqICAgICAgICAgICA8cD5QYXNzd29yZDogPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5nLWNvbnRyb2w9XCJwYXNzd29yZFwiPjwvcD5cclxuICogICAgICAgICA8L2Rpdj5cclxuICogICAgICAgICA8aDM+Q29udHJvbCBncm91cDogcGVyc29uPC9oMz5cclxuICogICAgICAgICA8ZGl2IG5nLWNvbnRyb2wtZ3JvdXA9XCJwZXJzb25cIj5cclxuICogICAgICAgICAgIDxwPkZpcnN0IG5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLWNvbnRyb2w9XCJmaXJzdE5hbWVcIj48L3A+XHJcbiAqICAgICAgICAgICA8cD5MYXN0IG5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLWNvbnRyb2w9XCJsYXN0TmFtZVwiPjwvcD5cclxuICogICAgICAgICA8L2Rpdj5cclxuICogICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIj5TdWJtaXQgRm9ybTwvYnV0dG9uPlxyXG4gKiAgICAgICA8cD5Gb3JtIGRhdGEgc3VibWl0dGVkOjwvcD5cclxuICogICAgICAgPC9mb3JtPlxyXG4gKiAgICAgICA8cHJlPnt7ZGF0YX19PC9wcmU+XHJcbiAqICAgICA8L2Rpdj5cclxuICogYCxcclxuICogICBkaXJlY3RpdmVzOiBbQ09SRV9ESVJFQ1RJVkVTLCBGT1JNX0RJUkVDVElWRVNdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBBcHAge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge31cclxuICpcclxuICogICBkYXRhOiBzdHJpbmc7XHJcbiAqXHJcbiAqICAgb25TdWJtaXQoZGF0YSkge1xyXG4gKiAgICAgdGhpcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ0Zvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5nRm9ybSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE5nRm9ybSgpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgbW9kZWxfMS5Db250cm9sR3JvdXAoe30pO1xyXG4gICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybS5jb250cm9sczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sYXRlcihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xyXG4gICAgICAgICAgICB2YXIgY3RybCA9IG5ldyBtb2RlbF8xLkNvbnRyb2woKTtcclxuICAgICAgICAgICAgc2hhcmVkXzEuc2V0VXBDb250cm9sKGN0cmwsIGRpcik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDb250cm9sKGRpci5uYW1lLCBjdHJsKTtcclxuICAgICAgICAgICAgY3RybC51cGRhdGVWYWxpZGl0eSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5maW5kKGRpci5wYXRoKTsgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2xhdGVyKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDb250cm9sKGRpci5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci51cGRhdGVWYWxpZGl0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5hZGRDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sYXRlcihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgbW9kZWxfMS5Db250cm9sR3JvdXAoe30pO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xyXG4gICAgICAgICAgICBncm91cC51cGRhdGVWYWxpZGl0eSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXIoZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLmdldENvbnRyb2xHcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXIoZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgdmFyIGN0cmwgPSBfdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xyXG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQodGhpcy5uZ1N1Ym1pdCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nRm9ybS5wcm90b3R5cGUuX2ZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIHBhdGgucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pc0VtcHR5KHBhdGgpID8gdGhpcy5mb3JtIDogdGhpcy5mb3JtLmZpbmQocGF0aCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5fbGF0ZXIgPSBmdW5jdGlvbiAoZm4pIHsgYXN5bmNfMS5Qcm9taXNlV3JhcHBlci50aGVuKGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZShudWxsKSwgZm4sIGZ1bmN0aW9uIChfKSB7IH0pOyB9O1xyXG4gICAgTmdGb3JtID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2Zvcm06bm90KFtuZy1uby1mb3JtXSk6bm90KFtuZy1mb3JtLW1vZGVsXSksbmctZm9ybSxbbmctZm9ybV0nLFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlcl0sXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICcoc3VibWl0KSc6ICdvblN1Ym1pdCgpJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb3V0cHV0czogWyduZ1N1Ym1pdCddLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ2Zvcm0nXHJcbiAgICAgICAgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBOZ0Zvcm0pO1xyXG4gICAgcmV0dXJuIE5nRm9ybTtcclxufSkoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyKTtcclxuZXhwb3J0cy5OZ0Zvcm0gPSBOZ0Zvcm07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2Zvcm0uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9uZ19jb250cm9sJyk7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XHJcbnZhciBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIGZvcm1Db250cm9sQmluZGluZyA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm1Db250cm9sOyB9KSB9KSk7XHJcbi8qKlxyXG4gKiBCaW5kcyBhbiBleGlzdGluZyB7QGxpbmsgQ29udHJvbH0gdG8gYSBET00gZWxlbWVudC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2pjUWxaMnRUaDIyQlpaMnVjTkFUP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSwgd2UgYmluZCB0aGUgY29udHJvbCB0byBhbiBpbnB1dCBlbGVtZW50LiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZWxlbWVudFxyXG4gKiBjaGFuZ2VzLCB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgd2lsbCByZWZsZWN0IHRoYXQgY2hhbmdlLiBMaWtld2lzZSwgaWYgdGhlIHZhbHVlIG9mIHRoZVxyXG4gKiBjb250cm9sIGNoYW5nZXMsIHRoZSBpbnB1dCBlbGVtZW50IHJlZmxlY3RzIHRoYXQgY2hhbmdlLlxyXG4gKlxyXG4gKiAgYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxkaXY+XHJcbiAqICAgICAgIDxoMj5OZ0Zvcm1Db250cm9sIEV4YW1wbGU8L2gyPlxyXG4gKiAgICAgICA8Zm9ybT5cclxuICogICAgICAgICA8cD5FbGVtZW50IHdpdGggZXhpc3RpbmcgY29udHJvbDogPGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuICogW25nLWZvcm0tY29udHJvbF09XCJsb2dpbkNvbnRyb2xcIj48L3A+XHJcbiAqICAgICAgICAgPHA+VmFsdWUgb2YgZXhpc3RpbmcgY29udHJvbDoge3tsb2dpbkNvbnRyb2wudmFsdWV9fTwvcD5cclxuICogICAgICAgPC9mb3JtPlxyXG4gKiAgICAgPC9kaXY+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbQ09SRV9ESVJFQ1RJVkVTLCBGT1JNX0RJUkVDVElWRVNdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBBcHAge1xyXG4gKiAgIGxvZ2luQ29udHJvbDogQ29udHJvbCA9IG5ldyBDb250cm9sKCcnKTtcclxuICogfVxyXG4gKiAgYGBgXHJcbiAqXHJcbiAqICMgbmctbW9kZWxcclxuICpcclxuICogV2UgY2FuIGFsc28gdXNlIGBuZy1tb2RlbGAgdG8gYmluZCBhIGRvbWFpbiBtb2RlbCB0byB0aGUgZm9ybS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3lITUx1SE83RE5nVDhYdnRqVERIP3A9cHJldmlldykpXHJcbiAqXHJcbiAqICBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICAgIHNlbGVjdG9yOiBcImxvZ2luLWNvbXBcIixcclxuICogICAgICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXSxcclxuICogICAgICB0ZW1wbGF0ZTogXCI8aW5wdXQgdHlwZT0ndGV4dCcgW25nLWZvcm0tY29udHJvbF09J2xvZ2luQ29udHJvbCcgWyhuZy1tb2RlbCldPSdsb2dpbic+XCJcclxuICogICAgICB9KVxyXG4gKiBjbGFzcyBMb2dpbkNvbXAge1xyXG4gKiAgbG9naW5Db250cm9sOiBDb250cm9sID0gbmV3IENvbnRyb2woJycpO1xyXG4gKiAgbG9naW46c3RyaW5nO1xyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ0Zvcm1Db250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0Zvcm1Db250cm9sLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmdGb3JtQ29udHJvbCh2YWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcclxuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzaGFyZWRfMS5zZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcclxuICAgIH1cclxuICAgIE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLm9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZCkge1xyXG4gICAgICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2wodGhpcy5mb3JtLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5mb3JtLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXJlZF8xLmlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm1Db250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZSh0aGlzLnZhbGlkYXRvcnMpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcclxuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0KHRoaXMudXBkYXRlLCBuZXdWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtQ29udHJvbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctZm9ybS1jb250cm9sXScsXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbZm9ybUNvbnRyb2xCaW5kaW5nXSxcclxuICAgICAgICAgICAgaW5wdXRzOiBbJ2Zvcm06IG5nRm9ybUNvbnRyb2wnLCAnbW9kZWw6IG5nTW9kZWwnXSxcclxuICAgICAgICAgICAgb3V0cHV0czogWyd1cGRhdGU6IG5nTW9kZWxDaGFuZ2UnXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdmb3JtJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5PcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDAsIGRpXzEuSW5qZWN0KHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLk9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgZGlfMS5JbmplY3QoY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0FycmF5LCBBcnJheV0pXHJcbiAgICBdLCBOZ0Zvcm1Db250cm9sKTtcclxuICAgIHJldHVybiBOZ0Zvcm1Db250cm9sO1xyXG59KShuZ19jb250cm9sXzEuTmdDb250cm9sKTtcclxuZXhwb3J0cy5OZ0Zvcm1Db250cm9sID0gTmdGb3JtQ29udHJvbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfZm9ybV9jb250cm9sLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lciwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybU1vZGVsOyB9KSB9KSk7XHJcbi8qKlxyXG4gKiBCaW5kcyBhbiBleGlzdGluZyBjb250cm9sIGdyb3VwIHRvIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9qcXJWaXJ1ZFk4YW5KeFRNVWpUUD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGJpbmQgdGhlIGNvbnRyb2wgZ3JvdXAgdG8gdGhlIGZvcm0gZWxlbWVudCwgYW5kIHdlIGJpbmQgdGhlIGxvZ2luIGFuZFxyXG4gKiBwYXNzd29yZCBjb250cm9scyB0byB0aGUgbG9naW4gYW5kIHBhc3N3b3JkIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiAgYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxkaXY+XHJcbiAqICAgICAgIDxoMj5OZ0Zvcm1Nb2RlbCBFeGFtcGxlPC9oMj5cclxuICogICAgICAgPGZvcm0gW25nLWZvcm0tbW9kZWxdPVwibG9naW5Gb3JtXCI+XHJcbiAqICAgICAgICAgPHA+TG9naW46IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLWNvbnRyb2w9XCJsb2dpblwiPjwvcD5cclxuICogICAgICAgICA8cD5QYXNzd29yZDogPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5nLWNvbnRyb2w9XCJwYXNzd29yZFwiPjwvcD5cclxuICogICAgICAgPC9mb3JtPlxyXG4gKiAgICAgICA8cD5WYWx1ZTo8L3A+XHJcbiAqICAgICAgIDxwcmU+e3t2YWx1ZX19PC9wcmU+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBBcHAge1xyXG4gKiAgIGxvZ2luRm9ybTogQ29udHJvbEdyb3VwO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5sb2dpbkZvcm0gPSBuZXcgQ29udHJvbEdyb3VwKHtcclxuICogICAgICAgbG9naW46IG5ldyBDb250cm9sKFwiXCIpLFxyXG4gKiAgICAgICBwYXNzd29yZDogbmV3IENvbnRyb2woXCJcIilcclxuICogICAgIH0pO1xyXG4gKiAgIH1cclxuICpcclxuICogICBnZXQgdmFsdWUoKTogc3RyaW5nIHtcclxuICogICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmxvZ2luRm9ybS52YWx1ZSwgbnVsbCwgMik7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqICBgYGBcclxuICpcclxuICogV2UgY2FuIGFsc28gdXNlIG5nLW1vZGVsIHRvIGJpbmQgYSBkb21haW4gbW9kZWwgdG8gdGhlIGZvcm0uXHJcbiAqXHJcbiAqICBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICAgIHNlbGVjdG9yOiBcImxvZ2luLWNvbXBcIixcclxuICogICAgICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXSxcclxuICogICAgICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgICAgPGZvcm0gW25nLWZvcm0tbW9kZWxdPSdsb2dpbkZvcm0nPlxyXG4gKiAgICAgICAgICBMb2dpbiA8aW5wdXQgdHlwZT0ndGV4dCcgbmctY29udHJvbD0nbG9naW4nIFsobmctbW9kZWwpXT0nY3JlZGVudGlhbHMubG9naW4nPlxyXG4gKiAgICAgICAgICBQYXNzd29yZCA8aW5wdXQgdHlwZT0ncGFzc3dvcmQnIG5nLWNvbnRyb2w9J3Bhc3N3b3JkJ1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZy1tb2RlbCldPSdjcmVkZW50aWFscy5wYXNzd29yZCc+XHJcbiAqICAgICAgICAgIDxidXR0b24gKGNsaWNrKT1cIm9uTG9naW4oKVwiPkxvZ2luPC9idXR0b24+XHJcbiAqICAgICAgICA8L2Zvcm0+YFxyXG4gKiAgICAgIH0pXHJcbiAqIGNsYXNzIExvZ2luQ29tcCB7XHJcbiAqICBjcmVkZW50aWFsczoge2xvZ2luOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmd9O1xyXG4gKiAgbG9naW5Gb3JtOiBDb250cm9sR3JvdXA7XHJcbiAqXHJcbiAqICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgdGhpcy5sb2dpbkZvcm0gPSBuZXcgQ29udHJvbEdyb3VwKHtcclxuICogICAgICBsb2dpbjogbmV3IENvbnRyb2woXCJcIiksXHJcbiAqICAgICAgcGFzc3dvcmQ6IG5ldyBDb250cm9sKFwiXCIpXHJcbiAqICAgIH0pO1xyXG4gKiAgfVxyXG4gKlxyXG4gKiAgb25Mb2dpbigpOiB2b2lkIHtcclxuICogICAgLy8gdGhpcy5jcmVkZW50aWFscy5sb2dpbiA9PT0gJ3NvbWUgbG9naW4nXHJcbiAqICAgIC8vIHRoaXMuY3JlZGVudGlhbHMucGFzc3dvcmQgPT09ICdzb21lIHBhc3N3b3JkJ1xyXG4gKiAgfVxyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ0Zvcm1Nb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmdGb3JtTW9kZWwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ0Zvcm1Nb2RlbCgpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5vbkNoYW5nZXMgPSBmdW5jdGlvbiAoXykgeyB0aGlzLl91cGRhdGVEb21WYWx1ZSgpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybU1vZGVsLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybU1vZGVsLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtTW9kZWwucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XHJcbiAgICAgICAgc2hhcmVkXzEuc2V0VXBDb250cm9sKGN0cmwsIGRpcik7XHJcbiAgICAgICAgY3RybC51cGRhdGVWYWxpZGl0eSgpO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGRpcik7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7IH07XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLmRpcmVjdGl2ZXMsIGRpcik7IH07XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuYWRkQ29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyB9O1xyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLnJlbW92ZUNvbnRyb2xHcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgfTtcclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5nZXRDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5maW5kKGRpci5wYXRoKTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xyXG4gICAgICAgIGN0cmwudXBkYXRlVmFsdWUodmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0KHRoaXMubmdTdWJtaXQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuX3VwZGF0ZURvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgICAgICB2YXIgY3RybCA9IF90aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XHJcbiAgICAgICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY3RybC52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtTW9kZWwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nLWZvcm0tbW9kZWxdJyxcclxuICAgICAgICAgICAgYmluZGluZ3M6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxyXG4gICAgICAgICAgICBpbnB1dHM6IFsnZm9ybTogbmctZm9ybS1tb2RlbCddLFxyXG4gICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgpJyB9LFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnZm9ybSdcclxuICAgICAgICB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIE5nRm9ybU1vZGVsKTtcclxuICAgIHJldHVybiBOZ0Zvcm1Nb2RlbDtcclxufSkoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyKTtcclxuZXhwb3J0cy5OZ0Zvcm1Nb2RlbCA9IE5nRm9ybU1vZGVsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19mb3JtX21vZGVsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9uZ19jb250cm9sJyk7XHJcbnZhciBtb2RlbF8xID0gcmVxdWlyZSgnLi4vbW9kZWwnKTtcclxudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIGZvcm1Db250cm9sQmluZGluZyA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ01vZGVsOyB9KSB9KSk7XHJcbi8qKlxyXG4gKiBCaW5kcyBhIGRvbWFpbiBtb2RlbCB0byBhIGZvcm0gY29udHJvbC5cclxuICpcclxuICogIyBVc2FnZVxyXG4gKlxyXG4gKiBgbmctbW9kZWxgIGJpbmRzIGFuIGV4aXN0aW5nIGRvbWFpbiBtb2RlbCB0byBhIGZvcm0gY29udHJvbC4gRm9yIGFcclxuICogdHdvLXdheSBiaW5kaW5nLCB1c2UgYFsobmctbW9kZWwpXWAgdG8gZW5zdXJlIHRoZSBtb2RlbCB1cGRhdGVzIGluXHJcbiAqIGJvdGggZGlyZWN0aW9ucy5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1IzVVg1cURhVXFGTzJWWVIwVXpIP3A9cHJldmlldykpXHJcbiAqICBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICAgIHNlbGVjdG9yOiBcInNlYXJjaC1jb21wXCIsXHJcbiAqICAgICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU10sXHJcbiAqICAgICAgdGVtcGxhdGU6IGA8aW5wdXQgdHlwZT0ndGV4dCcgWyhuZy1tb2RlbCldPVwic2VhcmNoUXVlcnlcIj5gXHJcbiAqICAgICAgfSlcclxuICogY2xhc3MgU2VhcmNoQ29tcCB7XHJcbiAqICBzZWFyY2hRdWVyeTogc3RyaW5nO1xyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBOZ01vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ01vZGVsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmdNb2RlbCh2YWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9jb250cm9sID0gbmV3IG1vZGVsXzEuQ29udHJvbCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcclxuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzaGFyZWRfMS5zZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcclxuICAgIH1cclxuICAgIE5nTW9kZWwucHJvdG90eXBlLm9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZCkge1xyXG4gICAgICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2wodGhpcy5fY29udHJvbCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcmVkXzEuaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udHJvbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLmNvbXBvc2UodGhpcy52YWxpZGF0b3JzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ01vZGVsLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XHJcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dCh0aGlzLnVwZGF0ZSwgbmV3VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE5nTW9kZWwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nLW1vZGVsXTpub3QoW25nLWNvbnRyb2xdKTpub3QoW25nLWZvcm0tY29udHJvbF0pJyxcclxuICAgICAgICAgICAgYmluZGluZ3M6IFtmb3JtQ29udHJvbEJpbmRpbmddLFxyXG4gICAgICAgICAgICBpbnB1dHM6IFsnbW9kZWw6IG5nTW9kZWwnXSxcclxuICAgICAgICAgICAgb3V0cHV0czogWyd1cGRhdGU6IG5nTW9kZWxDaGFuZ2UnXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdmb3JtJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5PcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDAsIGRpXzEuSW5qZWN0KHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLk9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgZGlfMS5JbmplY3QoY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0FycmF5LCBBcnJheV0pXHJcbiAgICBdLCBOZ01vZGVsKTtcclxuICAgIHJldHVybiBOZ01vZGVsO1xyXG59KShuZ19jb250cm9sXzEuTmdDb250cm9sKTtcclxuZXhwb3J0cy5OZ01vZGVsID0gTmdNb2RlbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfbW9kZWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgcmVuZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXInKTtcclxudmFyIGxpbmtlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIFNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUiwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSwgbXVsdGk6IHRydWUgfSkpO1xyXG4vKipcclxuICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxyXG4gKlxyXG4gKiAjRXhhbXBsZTpcclxuICpcclxuICogYGBgXHJcbiAqIDxzZWxlY3QgbmctY29udHJvbD1cImNpdHlcIj5cclxuICogICA8b3B0aW9uICpuZy1mb3I9XCIjYyBvZiBjaXRpZXNcIiBbdmFsdWVdPVwiY1wiPjwvb3B0aW9uPlxyXG4gKiA8L3NlbGVjdD5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgTmdTZWxlY3RPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdTZWxlY3RPcHRpb24oKSB7XHJcbiAgICB9XHJcbiAgICBOZ1NlbGVjdE9wdGlvbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdvcHRpb24nIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgTmdTZWxlY3RPcHRpb24pO1xyXG4gICAgcmV0dXJuIE5nU2VsZWN0T3B0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gTmdTZWxlY3RPcHRpb247XHJcbi8qKlxyXG4gKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cclxuICovXHJcbnZhciBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBxdWVyeSkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcclxuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZVdoZW5MaXN0T2ZPcHRpb25zQ2hhbmdlcyhxdWVyeSk7XHJcbiAgICB9XHJcbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBzaGFyZWRfMS5zZXRQcm9wZXJ0eSh0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudFJlZiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xyXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XHJcbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlV2hlbkxpc3RPZk9wdGlvbnNDaGFuZ2VzID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZShxdWVyeS5jaGFuZ2VzLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMud3JpdGVWYWx1ZShfdGhpcy52YWx1ZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdFtuZy1jb250cm9sXSxzZWxlY3RbbmctZm9ybS1jb250cm9sXSxzZWxlY3RbbmctbW9kZWxdJyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcclxuICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcclxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgbWV0YWRhdGFfMS5RdWVyeShOZ1NlbGVjdE9wdGlvbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JlbmRlcl8xLlJlbmRlcmVyLCBsaW5rZXJfMS5FbGVtZW50UmVmLCBsaW5rZXJfMS5RdWVyeUxpc3RdKVxyXG4gICAgXSwgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IpO1xyXG4gICAgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xyXG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jaGVja2JveF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcclxuZnVuY3Rpb24gY29udHJvbFBhdGgobmFtZSwgcGFyZW50KSB7XHJcbiAgICB2YXIgcCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbG9uZShwYXJlbnQucGF0aCk7XHJcbiAgICBwLnB1c2gobmFtZSk7XHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5leHBvcnRzLmNvbnRyb2xQYXRoID0gY29udHJvbFBhdGg7XHJcbmZ1bmN0aW9uIHNldFVwQ29udHJvbChjb250cm9sLCBkaXIpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb250cm9sKSlcclxuICAgICAgICBfdGhyb3dFcnJvcihkaXIsIFwiQ2Fubm90IGZpbmQgY29udHJvbFwiKTtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhkaXIudmFsdWVBY2Nlc3NvcikpXHJcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIk5vIHZhbHVlIGFjY2Vzc29yIGZvclwiKTtcclxuICAgIGNvbnRyb2wudmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcclxuICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY29udHJvbC52YWx1ZSk7XHJcbiAgICAvLyB2aWV3IC0+IG1vZGVsXHJcbiAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgY29udHJvbC51cGRhdGVWYWx1ZShuZXdWYWx1ZSwgeyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gbW9kZWwgLT4gdmlld1xyXG4gICAgY29udHJvbC5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkgeyByZXR1cm4gZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShuZXdWYWx1ZSk7IH0pO1xyXG4gICAgLy8gdG91Y2hlZFxyXG4gICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7IH0pO1xyXG59XHJcbmV4cG9ydHMuc2V0VXBDb250cm9sID0gc2V0VXBDb250cm9sO1xyXG5mdW5jdGlvbiBfdGhyb3dFcnJvcihkaXIsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBwYXRoID0gZGlyLnBhdGguam9pbihcIiAtPiBcIik7XHJcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24obWVzc2FnZSArIFwiICdcIiArIHBhdGggKyBcIidcIik7XHJcbn1cclxuZnVuY3Rpb24gc2V0UHJvcGVydHkocmVuZGVyZXIsIGVsZW1lbnRSZWYsIHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcclxuICAgIHJlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eShlbGVtZW50UmVmLCBwcm9wTmFtZSwgcHJvcFZhbHVlKTtcclxufVxyXG5leHBvcnRzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XHJcbmZ1bmN0aW9uIGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHZpZXdNb2RlbCkge1xyXG4gICAgaWYgKCFjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCBcIm1vZGVsXCIpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW1wibW9kZWxcIl07XHJcbiAgICBpZiAoY2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pc1Byb3BlcnR5VXBkYXRlZCA9IGlzUHJvcGVydHlVcGRhdGVkO1xyXG4vLyBUT0RPOiB2c2F2a2luIHJlbW92ZSBpdCBvbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcclxuZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWVBY2Nlc3NvcnMpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGRlZmF1bHRBY2Nlc3NvcjtcclxuICAgIHZhciBidWlsdGluQWNjZXNzb3I7XHJcbiAgICB2YXIgY3VzdG9tQWNjZXNzb3I7XHJcbiAgICB2YWx1ZUFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzEuRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgZGVmYXVsdEFjY2Vzc29yID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciB8fFxyXG4gICAgICAgICAgICB2IGluc3RhbmNlb2Ygc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcikge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChidWlsdGluQWNjZXNzb3IpKVxyXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIk1vcmUgdGhhbiBvbmUgYnVpbHQtaW4gdmFsdWUgYWNjZXNzb3IgbWF0Y2hlc1wiKTtcclxuICAgICAgICAgICAgYnVpbHRpbkFjY2Vzc29yID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGN1c3RvbUFjY2Vzc29yKSlcclxuICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgXCJNb3JlIHRoYW4gb25lIGN1c3RvbSB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzXCIpO1xyXG4gICAgICAgICAgICBjdXN0b21BY2Nlc3NvciA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjdXN0b21BY2Nlc3NvcikpXHJcbiAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYnVpbHRpbkFjY2Vzc29yKSlcclxuICAgICAgICByZXR1cm4gYnVpbHRpbkFjY2Vzc29yO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGVmYXVsdEFjY2Vzc29yKSlcclxuICAgICAgICByZXR1cm4gZGVmYXVsdEFjY2Vzc29yO1xyXG4gICAgX3Rocm93RXJyb3IoZGlyLCBcIk5vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvclwiKTtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0VmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XHJcbnZhciBsYW5nXzIgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmdcIik7XHJcbnZhciBSRVFVSVJFRF9WQUxJREFUT1IgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcih2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUywgeyB1c2VWYWx1ZTogdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMucmVxdWlyZWQsIG11bHRpOiB0cnVlIH0pKTtcclxudmFyIFJlcXVpcmVkVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlcXVpcmVkVmFsaWRhdG9yKCkge1xyXG4gICAgfVxyXG4gICAgUmVxdWlyZWRWYWxpZGF0b3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JlcXVpcmVkXVtuZy1jb250cm9sXSxbcmVxdWlyZWRdW25nLWZvcm0tY29udHJvbF0sW3JlcXVpcmVkXVtuZy1tb2RlbF0nLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtSRVFVSVJFRF9WQUxJREFUT1JdXHJcbiAgICAgICAgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBSZXF1aXJlZFZhbGlkYXRvcik7XHJcbiAgICByZXR1cm4gUmVxdWlyZWRWYWxpZGF0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSBSZXF1aXJlZFZhbGlkYXRvcjtcclxuZnVuY3Rpb24gY3JlYXRlTWluTGVuZ3RoVmFsaWRhdG9yKGRpcikge1xyXG4gICAgcmV0dXJuIHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLm1pbkxlbmd0aChkaXIubWluTGVuZ3RoKTtcclxufVxyXG52YXIgTUlOX0xFTkdUSF9WQUxJREFUT1IgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcih2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUywge1xyXG4gICAgdXNlRmFjdG9yeTogY3JlYXRlTWluTGVuZ3RoVmFsaWRhdG9yLFxyXG4gICAgZGVwczogW2RpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7IH0pXSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn0pKTtcclxudmFyIE1pbkxlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNaW5MZW5ndGhWYWxpZGF0b3IobWluTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBsYW5nXzIuTnVtYmVyV3JhcHBlci5wYXJzZUludChtaW5MZW5ndGgsIDEwKTtcclxuICAgIH1cclxuICAgIE1pbkxlbmd0aFZhbGlkYXRvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWlubGVuZ3RoXVtuZy1jb250cm9sXSxbbWlubGVuZ3RoXVtuZy1mb3JtLWNvbnRyb2xdLFttaW5sZW5ndGhdW25nLW1vZGVsXScsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01JTl9MRU5HVEhfVkFMSURBVE9SXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgbWV0YWRhdGFfMS5BdHRyaWJ1dGUoXCJtaW5sZW5ndGhcIikpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgTWluTGVuZ3RoVmFsaWRhdG9yKTtcclxuICAgIHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gTWluTGVuZ3RoVmFsaWRhdG9yO1xyXG5mdW5jdGlvbiBjcmVhdGVNYXhMZW5ndGhWYWxpZGF0b3IoZGlyKSB7XHJcbiAgICByZXR1cm4gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMubWF4TGVuZ3RoKGRpci5tYXhMZW5ndGgpO1xyXG59XHJcbnZhciBNQVhfTEVOR1RIX1ZBTElEQVRPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLCB7XHJcbiAgICB1c2VGYWN0b3J5OiBjcmVhdGVNYXhMZW5ndGhWYWxpZGF0b3IsXHJcbiAgICBkZXBzOiBbZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjsgfSldLFxyXG4gICAgbXVsdGk6IHRydWVcclxufSkpO1xyXG52YXIgTWF4TGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1heExlbmd0aFZhbGlkYXRvcihtYXhMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLm1heExlbmd0aCA9IGxhbmdfMi5OdW1iZXJXcmFwcGVyLnBhcnNlSW50KG1heExlbmd0aCwgMTApO1xyXG4gICAgfVxyXG4gICAgTWF4TGVuZ3RoVmFsaWRhdG9yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXhsZW5ndGhdW25nLWNvbnRyb2xdLFttYXhsZW5ndGhdW25nLWZvcm0tY29udHJvbF0sW21heGxlbmd0aF1bbmctbW9kZWxdJyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUFYX0xFTkdUSF9WQUxJREFUT1JdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBtZXRhZGF0YV8xLkF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXHJcbiAgICBdLCBNYXhMZW5ndGhWYWxpZGF0b3IpO1xyXG4gICAgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjtcclxufSkoKTtcclxuZXhwb3J0cy5NYXhMZW5ndGhWYWxpZGF0b3IgPSBNYXhMZW5ndGhWYWxpZGF0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRvcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbW9kZWxNb2R1bGUgPSByZXF1aXJlKCcuL21vZGVsJyk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZm9ybSBvYmplY3QgZnJvbSBhIHVzZXItc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnQsIGJvb3RzdHJhcH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge0Zvcm1CdWlsZGVyLCBWYWxpZGF0b3JzLCBGT1JNX0RJUkVDVElWRVMsIENvbnRyb2xHcm91cH0gZnJvbSAnYW5ndWxhcjIvY29yZSc7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbG9naW4tY29tcCcsXHJcbiAqICAgdmlld1Byb3ZpZGVyczogW0Zvcm1CdWlsZGVyXSxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGZvcm0gW2NvbnRyb2wtZ3JvdXBdPVwibG9naW5Gb3JtXCI+XHJcbiAqICAgICAgIExvZ2luIDxpbnB1dCBjb250cm9sPVwibG9naW5cIj5cclxuICpcclxuICogICAgICAgPGRpdiBjb250cm9sLWdyb3VwPVwicGFzc3dvcmRSZXRyeVwiPlxyXG4gKiAgICAgICAgIFBhc3N3b3JkIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBjb250cm9sPVwicGFzc3dvcmRcIj5cclxuICogICAgICAgICBDb25maXJtIHBhc3N3b3JkIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBjb250cm9sPVwicGFzc3dvcmRDb25maXJtYXRpb25cIj5cclxuICogICAgICAgPC9kaXY+XHJcbiAqICAgICA8L2Zvcm0+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBMb2dpbkNvbXAge1xyXG4gKiAgIGxvZ2luRm9ybTogQ29udHJvbEdyb3VwO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IEZvcm1CdWlsZGVyKSB7XHJcbiAqICAgICB0aGlzLmxvZ2luRm9ybSA9IGJ1aWxkZXIuZ3JvdXAoe1xyXG4gKiAgICAgICBsb2dpbjogW1wiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWRdLFxyXG4gKlxyXG4gKiAgICAgICBwYXNzd29yZFJldHJ5OiBidWlsZGVyLmdyb3VwKHtcclxuICogICAgICAgICBwYXNzd29yZDogW1wiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWRdLFxyXG4gKiAgICAgICAgIHBhc3N3b3JkQ29uZmlybWF0aW9uOiBbXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZF1cclxuICogICAgICAgfSlcclxuICogICAgIH0pO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoTG9naW5Db21wKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEge0BsaW5rIENvbnRyb2xHcm91cH0gdGhhdCBjb25zaXN0cyBvZiBhIGBsb2dpbmAge0BsaW5rIENvbnRyb2x9LCBhbmQgYVxyXG4gKiBuZXN0ZWQge0BsaW5rIENvbnRyb2xHcm91cH0gdGhhdCBkZWZpbmVzIGEgYHBhc3N3b3JkYCBhbmQgYSBgcGFzc3dvcmRDb25maXJtYXRpb25gXHJcbiAqIHtAbGluayBDb250cm9sfTpcclxuICpcclxuICogYGBgXHJcbiAqICB2YXIgbG9naW5Gb3JtID0gYnVpbGRlci5ncm91cCh7XHJcbiAqICAgIGxvZ2luOiBbXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXHJcbiAqXHJcbiAqICAgIHBhc3N3b3JkUmV0cnk6IGJ1aWxkZXIuZ3JvdXAoe1xyXG4gKiAgICAgIHBhc3N3b3JkOiBbXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXHJcbiAqICAgICAgcGFzc3dvcmRDb25maXJtYXRpb246IFtcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkXVxyXG4gKiAgICB9KVxyXG4gKiAgfSk7XHJcbiAqXHJcbiAqICBgYGBcclxuICovXHJcbnZhciBGb3JtQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGb3JtQnVpbGRlcigpIHtcclxuICAgIH1cclxuICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgZXh0cmEpIHtcclxuICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IG51bGw7IH1cclxuICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9sc0NvbmZpZyk7XHJcbiAgICAgICAgdmFyIG9wdGlvbmFscyA9IGxhbmdfMS5pc1ByZXNlbnQoZXh0cmEpID8gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KGV4dHJhLCBcIm9wdGlvbmFsc1wiKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IGxhbmdfMS5pc1ByZXNlbnQoZXh0cmEpID8gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KGV4dHJhLCBcInZhbGlkYXRvclwiKSA6IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2xHcm91cChjb250cm9scywgb3B0aW9uYWxzLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbE1vZHVsZS5Db250cm9sR3JvdXAoY29udHJvbHMsIG9wdGlvbmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24gKHZhbHVlLCB2YWxpZGF0b3IpIHtcclxuICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbE1vZHVsZS5Db250cm9sKHZhbHVlLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbE1vZHVsZS5Db250cm9sKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0gY29udHJvbHNDb25maWcubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5fY3JlYXRlQ29udHJvbChjKTsgfSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2xBcnJheShjb250cm9scywgdmFsaWRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbW9kZWxNb2R1bGUuQ29udHJvbEFycmF5KGNvbnRyb2xzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9yZWR1Y2VDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0ge307XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChjb250cm9sc0NvbmZpZywgZnVuY3Rpb24gKGNvbnRyb2xDb25maWcsIGNvbnRyb2xOYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2xOYW1lXSA9IF90aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xDb25maWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbENvbmZpZykge1xyXG4gICAgICAgIGlmIChjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgbW9kZWxNb2R1bGUuQ29udHJvbCB8fFxyXG4gICAgICAgICAgICBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgbW9kZWxNb2R1bGUuQ29udHJvbEdyb3VwIHx8XHJcbiAgICAgICAgICAgIGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBtb2RlbE1vZHVsZS5Db250cm9sQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xDb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0FycmF5KGNvbnRyb2xDb25maWcpKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2xDb25maWdbMF07XHJcbiAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDEgPyBjb250cm9sQ29uZmlnWzFdIDogbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2woY29udHJvbENvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZvcm1CdWlsZGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBGb3JtQnVpbGRlcik7XHJcbiAgICByZXR1cm4gRm9ybUJ1aWxkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRm9ybUJ1aWxkZXIgPSBGb3JtQnVpbGRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybV9idWlsZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcnMnKTtcclxuLyoqXHJcbiAqIEluZGljYXRlcyB0aGF0IGEgQ29udHJvbCBpcyB2YWxpZCwgaS5lLiB0aGF0IG5vIGVycm9ycyBleGlzdCBpbiB0aGUgaW5wdXQgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnRzLlZBTElEID0gXCJWQUxJRFwiO1xyXG4vKipcclxuICogSW5kaWNhdGVzIHRoYXQgYSBDb250cm9sIGlzIGludmFsaWQsIGkuZS4gdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0cy5JTlZBTElEID0gXCJJTlZBTElEXCI7XHJcbmZ1bmN0aW9uIGlzQ29udHJvbChjb250cm9sKSB7XHJcbiAgICByZXR1cm4gY29udHJvbCBpbnN0YW5jZW9mIEFic3RyYWN0Q29udHJvbDtcclxufVxyXG5leHBvcnRzLmlzQ29udHJvbCA9IGlzQ29udHJvbDtcclxuZnVuY3Rpb24gX2ZpbmQoY29udHJvbCwgcGF0aCkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGgpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiL1wiKTtcclxuICAgIH1cclxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgQXJyYXkgJiYgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlZHVjZShwYXRoLCBmdW5jdGlvbiAodiwgbmFtZSkge1xyXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQ29udHJvbEdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHYuY29udHJvbHNbbmFtZV0pID8gdi5jb250cm9sc1tuYW1lXSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBDb250cm9sQXJyYXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodi5hdChpbmRleCkpID8gdi5hdChpbmRleCkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgY29udHJvbCk7XHJcbn1cclxuLyoqXHJcbiAqIE9taXR0aW5nIGZyb20gZXh0ZXJuYWwgQVBJIGRvYyBhcyB0aGlzIGlzIHJlYWxseSBhbiBhYnN0cmFjdCBpbnRlcm5hbCBjb25jZXB0LlxyXG4gKi9cclxudmFyIEFic3RyYWN0Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2wodmFsaWRhdG9yKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3ByaXN0aW5lID0gdHJ1ZTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1czsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IGV4cG9ydHMuVkFMSUQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Vycm9yczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwcmlzdGluZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmlzdGluZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5wcmlzdGluZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RvdWNoZWQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidW50b3VjaGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLl90b3VjaGVkOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZUNoYW5nZXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl90b3VjaGVkID0gdHJ1ZTsgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzRGlydHkgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xyXG4gICAgICAgIG9ubHlTZWxmID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2wob25seVNlbGYpO1xyXG4gICAgICAgIHRoaXMuX3ByaXN0aW5lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc0RpcnR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgdGhpcy5fcGFyZW50ID0gcGFyZW50OyB9O1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XHJcbiAgICAgICAgb25seVNlbGYgPSBsYW5nXzEubm9ybWFsaXplQm9vbChvbmx5U2VsZik7XHJcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy52YWxpZGF0b3IodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9lcnJvcnMpID8gZXhwb3J0cy5JTlZBTElEIDogZXhwb3J0cy5WQUxJRDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XHJcbiAgICAgICAgb25seVNlbGYgPSBsYW5nXzEubm9ybWFsaXplQm9vbChvbmx5U2VsZik7XHJcbiAgICAgICAgZW1pdEV2ZW50ID0gbGFuZ18xLmlzUHJlc2VudChlbWl0RXZlbnQpID8gZW1pdEV2ZW50IDogdHJ1ZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xyXG4gICAgICAgIGlmIChlbWl0RXZlbnQpIHtcclxuICAgICAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dCh0aGlzLl92YWx1ZUNoYW5nZXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy52YWxpZGF0b3IodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9lcnJvcnMpID8gZXhwb3J0cy5JTlZBTElEIDogZXhwb3J0cy5WQUxJRDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBfZmluZCh0aGlzLCBwYXRoKTsgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBjb250cm9sID0gbGFuZ18xLmlzUHJlc2VudChwYXRoKSAmJiAhY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkgPyB0aGlzLmZpbmQocGF0aCkgOiB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRyb2wpICYmIGxhbmdfMS5pc1ByZXNlbnQoY29udHJvbC5fZXJyb3JzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KGNvbnRyb2wuX2Vycm9ycywgZXJyb3JDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmhhc0Vycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbDtcclxufSkoKTtcclxuZXhwb3J0cy5BYnN0cmFjdENvbnRyb2wgPSBBYnN0cmFjdENvbnRyb2w7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGFydCBvZiBhIGZvcm0gdGhhdCBjYW5ub3QgYmUgZGl2aWRlZCBpbnRvIG90aGVyIGNvbnRyb2xzLiBgQ29udHJvbGBzIGhhdmUgdmFsdWVzIGFuZFxyXG4gKiB2YWxpZGF0aW9uIHN0YXRlLCB3aGljaCBpcyBkZXRlcm1pbmVkIGJ5IGFuIG9wdGlvbmFsIHZhbGlkYXRpb24gZnVuY3Rpb24uXHJcbiAqXHJcbiAqIGBDb250cm9sYCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLCBhbG9uZ1xyXG4gKiB3aXRoIHtAbGluayBDb250cm9sR3JvdXB9IGFuZCB7QGxpbmsgQ29udHJvbEFycmF5fS5cclxuICpcclxuICogIyBVc2FnZVxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBhIGBDb250cm9sYCBpcyBjcmVhdGVkIGZvciBldmVyeSBgPGlucHV0PmAgb3Igb3RoZXIgZm9ybSBjb21wb25lbnQuXHJcbiAqIFdpdGgge0BsaW5rIE5nRm9ybUNvbnRyb2x9IG9yIHtAbGluayBOZ0Zvcm1Nb2RlbH0gYW4gZXhpc3Rpbmcge0BsaW5rIENvbnRyb2x9IGNhbiBiZVxyXG4gKiBib3VuZCB0byBhIERPTSBlbGVtZW50IGluc3RlYWQuIFRoaXMgYENvbnRyb2xgIGNhbiBiZSBjb25maWd1cmVkIHdpdGggYSBjdXN0b21cclxuICogdmFsaWRhdGlvbiBmdW5jdGlvbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzIzREVTT3BiTm5CcEJIWnQxQlI0P3A9cHJldmlldykpXHJcbiAqL1xyXG52YXIgQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udHJvbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRyb2wodmFsdWUsIHZhbGlkYXRvcikge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5udWxsVmFsaWRhdG9yOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCB0byBgdmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIElmIGBvbmx5U2VsZmAgaXMgYHRydWVgLCB0aGlzIGNoYW5nZSB3aWxsIG9ubHkgYWZmZWN0IHRoZSB2YWxpZGF0aW9uIG9mIHRoaXMgYENvbnRyb2xgXHJcbiAgICAgKiBhbmQgbm90IGl0cyBwYXJlbnQgY29tcG9uZW50LiBJZiBgZW1pdEV2ZW50YCBpcyBgdHJ1ZWAsIHRoaXMgY2hhbmdlIHdpbGwgY2F1c2UgYVxyXG4gICAgICogYHZhbHVlQ2hhbmdlc2AgZXZlbnQgb24gdGhlIGBDb250cm9sYCB0byBiZSBlbWl0dGVkLiBCb3RoIG9mIHRoZXNlIG9wdGlvbnMgZGVmYXVsdCB0b1xyXG4gICAgICogYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBgdHJ1ZWAsIHRoZSB2aWV3IHdpbGwgYmUgbm90aWZpZWQgYWJvdXQgdGhlIG5ldyB2YWx1ZVxyXG4gICAgICogdmlhIGFuIGBvbkNoYW5nZWAgZXZlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGVtaXRNb2RlbFRvVmlld0NoYW5nZWAgaXMgbm90XHJcbiAgICAgKiBzcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIENvbnRyb2wucHJvdG90eXBlLnVwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQsIGVtaXRNb2RlbFRvVmlld0NoYW5nZSA9IF9iLmVtaXRNb2RlbFRvVmlld0NoYW5nZTtcclxuICAgICAgICBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgPSBsYW5nXzEuaXNQcmVzZW50KGVtaXRNb2RlbFRvVmlld0NoYW5nZSkgPyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fb25DaGFuZ2UpICYmIGVtaXRNb2RlbFRvVmlld0NoYW5nZSlcclxuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjaGFuZ2UgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBDb250cm9sLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XHJcbiAgICByZXR1cm4gQ29udHJvbDtcclxufSkoQWJzdHJhY3RDb250cm9sKTtcclxuZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcclxuLyoqXHJcbiAqIERlZmluZXMgYSBwYXJ0IG9mIGEgZm9ybSwgb2YgZml4ZWQgbGVuZ3RoLCB0aGF0IGNhbiBjb250YWluIG90aGVyIGNvbnRyb2xzLlxyXG4gKlxyXG4gKiBBIGBDb250cm9sR3JvdXBgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBhbmQgZXJyb3JzIG9mIGVhY2gge0BsaW5rIENvbnRyb2x9IGluIHRoZSBncm91cC4gVGh1cywgaWZcclxuICogb25lIG9mIHRoZSBjb250cm9scyBpbiBhIGdyb3VwIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgZ3JvdXAgaXMgaW52YWxpZC4gU2ltaWxhcmx5LCBpZiBhIGNvbnRyb2xcclxuICogY2hhbmdlcyBpdHMgdmFsdWUsIHRoZSBlbnRpcmUgZ3JvdXAgY2hhbmdlcyBhcyB3ZWxsLlxyXG4gKlxyXG4gKiBgQ29udHJvbEdyb3VwYCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxyXG4gKiBhbG9uZyB3aXRoIHtAbGluayBDb250cm9sfSBhbmQge0BsaW5rIENvbnRyb2xBcnJheX0uIHtAbGluayBDb250cm9sQXJyYXl9IGNhbiBhbHNvIGNvbnRhaW4gb3RoZXJcclxuICogY29udHJvbHMsIGJ1dCBpcyBvZiB2YXJpYWJsZSBsZW5ndGguXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC8yM0RFU09wYk5uQnBCSFp0MUJSND9wPXByZXZpZXcpKVxyXG4gKi9cclxudmFyIENvbnRyb2xHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udHJvbEdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udHJvbEdyb3VwKGNvbnRyb2xzLCBvcHRpb25hbHMsIHZhbGlkYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRpb25hbHMgPT09IHZvaWQgMCkgeyBvcHRpb25hbHMgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLmdyb3VwOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9uYWxzID0gbGFuZ18xLmlzUHJlc2VudChvcHRpb25hbHMpID8gb3B0aW9uYWxzIDoge307XHJcbiAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50Rm9yQ29udHJvbHMoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlZHVjZVZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcclxuICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSkgeyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5kZWxldGUodGhpcy5jb250cm9scywgbmFtZSk7IH07XHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLmluY2x1ZGUgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQodGhpcy5fb3B0aW9uYWxzLCBjb250cm9sTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XHJcbiAgICB9O1xyXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHRoaXMuX29wdGlvbmFscywgY29udHJvbE5hbWUsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcclxuICAgIH07XHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyh0aGlzLmNvbnRyb2xzLCBjb250cm9sTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGMgJiYgdGhpcy5faW5jbHVkZWQoY29udHJvbE5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3NldFBhcmVudEZvckNvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0aGlzLmNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkgeyBjb250cm9sLnNldFBhcmVudChfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlZHVjZVZhbHVlKCk7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oe30sIGZ1bmN0aW9uIChhY2MsIGNvbnRyb2wsIG5hbWUpIHtcclxuICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VDaGlsZHJlbiA9IGZ1bmN0aW9uIChpbml0VmFsdWUsIGZuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzID0gaW5pdFZhbHVlO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godGhpcy5jb250cm9scywgZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9pbmNsdWRlZChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gZm4ocmVzLCBjb250cm9sLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5faW5jbHVkZWQgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcclxuICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKHRoaXMuX29wdGlvbmFscywgY29udHJvbE5hbWUpO1xyXG4gICAgICAgIHJldHVybiAhaXNPcHRpb25hbCB8fCBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQodGhpcy5fb3B0aW9uYWxzLCBjb250cm9sTmFtZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnRyb2xHcm91cDtcclxufSkoQWJzdHJhY3RDb250cm9sKTtcclxuZXhwb3J0cy5Db250cm9sR3JvdXAgPSBDb250cm9sR3JvdXA7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGFydCBvZiBhIGZvcm0sIG9mIHZhcmlhYmxlIGxlbmd0aCwgdGhhdCBjYW4gY29udGFpbiBvdGhlciBjb250cm9scy5cclxuICpcclxuICogQSBgQ29udHJvbEFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgYW5kIGVycm9ycyBvZiBlYWNoIHtAbGluayBDb250cm9sfSBpbiB0aGUgZ3JvdXAuIFRodXMsIGlmXHJcbiAqIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlIGdyb3VwIGlzIGludmFsaWQuIFNpbWlsYXJseSwgaWYgYSBjb250cm9sXHJcbiAqIGNoYW5nZXMgaXRzIHZhbHVlLCB0aGUgZW50aXJlIGdyb3VwIGNoYW5nZXMgYXMgd2VsbC5cclxuICpcclxuICogYENvbnRyb2xBcnJheWAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcclxuICogYWxvbmcgd2l0aCB7QGxpbmsgQ29udHJvbH0gYW5kIHtAbGluayBDb250cm9sR3JvdXB9LiB7QGxpbmsgQ29udHJvbEdyb3VwfSBjYW4gYWxzbyBjb250YWluXHJcbiAqIG90aGVyIGNvbnRyb2xzLCBidXQgaXMgb2YgZml4ZWQgbGVuZ3RoLlxyXG4gKlxyXG4gKiAjIEFkZGluZyBvciByZW1vdmluZyBjb250cm9sc1xyXG4gKlxyXG4gKiBUbyBjaGFuZ2UgdGhlIGNvbnRyb2xzIGluIHRoZSBhcnJheSwgdXNlIHRoZSBgcHVzaGAsIGBpbnNlcnRgLCBvciBgcmVtb3ZlQXRgIG1ldGhvZHNcclxuICogaW4gYENvbnRyb2xBcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXHJcbiAqIGZvcm0ncyBoaWVyYXJjaHkuIERvIG5vdCBtb2RpZnkgdGhlIGFycmF5IG9mIGBBYnN0cmFjdENvbnRyb2xgcyB1c2VkIHRvIGluc3RhbnRpYXRlXHJcbiAqIHRoZSBgQ29udHJvbEFycmF5YCBkaXJlY3RseSwgYXMgdGhhdCB3aWxsIHJlc3VsdCBpbiBzdHJhbmdlIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIHN1Y2hcclxuICogYXMgYnJva2VuIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC8yM0RFU09wYk5uQnBCSFp0MUJSND9wPXByZXZpZXcpKVxyXG4gKi9cclxudmFyIENvbnRyb2xBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udHJvbEFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udHJvbEFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IpIHtcclxuICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuYXJyYXk7IH1cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcclxuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9zZXRQYXJlbnRGb3JDb250cm9scygpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250cm9sc1tpbmRleF07IH07XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgYSBuZXcge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgY29udHJvbCkge1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pbnNlcnQodGhpcy5jb250cm9scywgaW5kZXgsIGNvbnRyb2wpO1xyXG4gICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSBjb250cm9sIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLmNvbnRyb2xzLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xBcnJheS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xBcnJheS5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWx1ZSA9IHRoaXMuY29udHJvbHMubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xBcnJheS5wcm90b3R5cGUuX3NldFBhcmVudEZvckNvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wuc2V0UGFyZW50KF90aGlzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnRyb2xBcnJheTtcclxufSkoQWJzdHJhY3RDb250cm9sKTtcclxuZXhwb3J0cy5Db250cm9sQXJyYXkgPSBDb250cm9sQXJyYXk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGxhbmdfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbmV4cG9ydHMuTkdfVkFMSURBVE9SUyA9IGxhbmdfMi5DT05TVF9FWFBSKG5ldyBkaV8xLk9wYXF1ZVRva2VuKFwiTmdWYWxpZGF0b3JzXCIpKTtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIHZhbGlkYXRvcnMgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsb2dpbkNvbnRyb2wgPSBuZXcgQ29udHJvbChcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBWYWxpZGF0b3JzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcnMoKSB7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0b3JzLnJlcXVpcmVkID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsoY29udHJvbC52YWx1ZSkgfHwgY29udHJvbC52YWx1ZSA9PSBcIlwiID8geyBcInJlcXVpcmVkXCI6IHRydWUgfSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdG9ycy5taW5MZW5ndGggPSBmdW5jdGlvbiAobWluTGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KFZhbGlkYXRvcnMucmVxdWlyZWQoY29udHJvbCkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHZhciB2ID0gY29udHJvbC52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHYubGVuZ3RoIDwgbWluTGVuZ3RoID9cclxuICAgICAgICAgICAgICAgIHsgXCJtaW5sZW5ndGhcIjogeyBcInJlcXVpcmVkTGVuZ3RoXCI6IG1pbkxlbmd0aCwgXCJhY3R1YWxMZW5ndGhcIjogdi5sZW5ndGggfSB9IDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0b3JzLm1heExlbmd0aCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHYgPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPiBtYXhMZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgeyBcIm1heGxlbmd0aFwiOiB7IFwicmVxdWlyZWRMZW5ndGhcIjogbWF4TGVuZ3RoLCBcImFjdHVhbExlbmd0aFwiOiB2Lmxlbmd0aCB9IH0gOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgVmFsaWRhdG9ycy5jb21wb3NlID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsaWRhdG9ycykpXHJcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLm51bGxWYWxpZGF0b3I7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVkdWNlKHZhbGlkYXRvcnMsIGZ1bmN0aW9uIChyZXMsIHZhbGlkYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IHZhbGlkYXRvcihjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGVycm9ycykgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5tZXJnZShyZXMsIGVycm9ycykgOiByZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmlzRW1wdHkocmVzKSA/IG51bGwgOiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0b3JzLmdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goZ3JvdXAuY29udHJvbHMsIGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChncm91cC5jb250YWlucyhuYW1lKSAmJiBsYW5nXzEuaXNQcmVzZW50KGNvbnRyb2wuZXJyb3JzKSkge1xyXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5fbWVyZ2VFcnJvcnMoY29udHJvbCwgcmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5pc0VtcHR5KHJlcykgPyBudWxsIDogcmVzO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRvcnMuYXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICB2YXIgcmVzID0ge307XHJcbiAgICAgICAgYXJyYXkuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb250cm9sLmVycm9ycykpIHtcclxuICAgICAgICAgICAgICAgIFZhbGlkYXRvcnMuX21lcmdlRXJyb3JzKGNvbnRyb2wsIHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuaXNFbXB0eShyZXMpID8gbnVsbCA6IHJlcztcclxuICAgIH07XHJcbiAgICBWYWxpZGF0b3JzLl9tZXJnZUVycm9ycyA9IGZ1bmN0aW9uIChjb250cm9sLCByZXMpIHtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGNvbnRyb2wuZXJyb3JzLCBmdW5jdGlvbiAodmFsdWUsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMocmVzLCBlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgIHJlc1tlcnJvcl0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHJlc1tlcnJvcl07XHJcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaChjb250cm9sKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFsaWRhdG9ycztcclxufSkoKTtcclxuZXhwb3J0cy5WYWxpZGF0b3JzID0gVmFsaWRhdG9ycztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9ycy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBwcm9maWxlXzEgPSByZXF1aXJlKCcuLi9wcm9maWxlL3Byb2ZpbGUnKTtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBleHBsaWNpdGx5IHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBpbiBhbiBhcHBsaWNhdGlvbi5cclxuICpcclxuICogQnkgZGVmYXVsdCwgYFpvbmVgIHRyaWdnZXJzIGNoYW5nZSBkZXRlY3Rpb24gaW4gQW5ndWxhciBvbiBlYWNoIHZpcnR1YWwgbWFjaGluZSAoVk0pIHR1cm4uIFdoZW5cclxuICogdGVzdGluZywgb3IgaW4gc29tZVxyXG4gKiBsaW1pdGVkIGFwcGxpY2F0aW9uIHVzZSBjYXNlcywgYSBkZXZlbG9wZXIgY2FuIGFsc28gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIHdpdGggdGhlXHJcbiAqIGBsaWZlY3ljbGUudGljaygpYCBtZXRob2QuXHJcbiAqXHJcbiAqIEVhY2ggQW5ndWxhciBhcHBsaWNhdGlvbiBoYXMgYSBzaW5nbGUgYExpZmVDeWNsZWAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgY29udHJpdmVkIGV4YW1wbGUsIHNpbmNlIHRoZSBib290c3RyYXAgYXV0b21hdGljYWxseSBydW5zIGluc2lkZSBvZiB0aGUgYFpvbmVgLCB3aGljaFxyXG4gKiBpbnZva2VzXHJcbiAqIGBsaWZlY3ljbGUudGljaygpYCBvbiB5b3VyIGJlaGFsZi5cclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBib290c3RyYXAoTXlBcHApLnRoZW4oKHJlZjpDb21wb25lbnRSZWYpID0+IHtcclxuICogICB2YXIgbGlmZUN5Y2xlID0gcmVmLmluamVjdG9yLmdldChMaWZlQ3ljbGUpO1xyXG4gKiAgIHZhciBteUFwcCA9IHJlZi5pbnN0YW5jZTtcclxuICpcclxuICogICByZWYuZG9Tb21ldGhpbmcoKTtcclxuICogICBsaWZlY3ljbGUudGljaygpO1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTGlmZUN5Y2xlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpZmVDeWNsZSgpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBMaWZlQ3ljbGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTGlmZUN5Y2xlID0gTGlmZUN5Y2xlO1xyXG52YXIgTGlmZUN5Y2xlXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGlmZUN5Y2xlXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpZmVDeWNsZV8oY2hhbmdlRGV0ZWN0b3IsIGVuZm9yY2VOb05ld0NoYW5nZXMpIHtcclxuICAgICAgICBpZiAoY2hhbmdlRGV0ZWN0b3IgPT09IHZvaWQgMCkgeyBjaGFuZ2VEZXRlY3RvciA9IG51bGw7IH1cclxuICAgICAgICBpZiAoZW5mb3JjZU5vTmV3Q2hhbmdlcyA9PT0gdm9pZCAwKSB7IGVuZm9yY2VOb05ld0NoYW5nZXMgPSBmYWxzZTsgfVxyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9ycyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoYW5nZURldGVjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvcnMucHVzaChjaGFuZ2VEZXRlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBlbmZvcmNlTm9OZXdDaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgTGlmZUN5Y2xlXy5wcm90b3R5cGUucmVnaXN0ZXJXaXRoID0gZnVuY3Rpb24gKHpvbmUsIGNoYW5nZURldGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoY2hhbmdlRGV0ZWN0b3IgPT09IHZvaWQgMCkgeyBjaGFuZ2VEZXRlY3RvciA9IG51bGw7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGFuZ2VEZXRlY3RvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JzLnB1c2goY2hhbmdlRGV0ZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6b25lLm92ZXJyaWRlT25UdXJuRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aWNrKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIExpZmVDeWNsZV8ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkxpZmVDeWNsZS50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHMgPSBMaWZlQ3ljbGVfLl90aWNrU2NvcGUoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuY2hlY2tOb0NoYW5nZXMoKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlmZUN5Y2xlXy5fdGlja1Njb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdMaWZlQ3ljbGUjdGljaygpJyk7XHJcbiAgICBMaWZlQ3ljbGVfID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdCwgQm9vbGVhbl0pXHJcbiAgICBdLCBMaWZlQ3ljbGVfKTtcclxuICAgIHJldHVybiBMaWZlQ3ljbGVfO1xyXG59KShMaWZlQ3ljbGUpO1xyXG5leHBvcnRzLkxpZmVDeWNsZV8gPSBMaWZlQ3ljbGVfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlX2N5Y2xlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBQdWJsaWMgQVBJIGZvciBMaWZlQ3ljbGVcclxudmFyIGxpZmVfY3ljbGVfMSA9IHJlcXVpcmUoJy4vbGlmZV9jeWNsZS9saWZlX2N5Y2xlJyk7XHJcbmV4cG9ydHMuTGlmZUN5Y2xlID0gbGlmZV9jeWNsZV8xLkxpZmVDeWNsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmZWN5Y2xlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBQdWJsaWMgQVBJIGZvciBjb21waWxlclxyXG52YXIgZGlyZWN0aXZlX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL2xpbmtlci9kaXJlY3RpdmVfcmVzb2x2ZXInKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVSZXNvbHZlciA9IGRpcmVjdGl2ZV9yZXNvbHZlcl8xLkRpcmVjdGl2ZVJlc29sdmVyO1xyXG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2NvbXBpbGVyJyk7XHJcbmV4cG9ydHMuQ29tcGlsZXIgPSBjb21waWxlcl8xLkNvbXBpbGVyO1xyXG52YXIgdmlld19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL2xpbmtlci92aWV3X21hbmFnZXInKTtcclxuZXhwb3J0cy5BcHBWaWV3TWFuYWdlciA9IHZpZXdfbWFuYWdlcl8xLkFwcFZpZXdNYW5hZ2VyO1xyXG52YXIgcXVlcnlfbGlzdF8xID0gcmVxdWlyZSgnLi9saW5rZXIvcXVlcnlfbGlzdCcpO1xyXG5leHBvcnRzLlF1ZXJ5TGlzdCA9IHF1ZXJ5X2xpc3RfMS5RdWVyeUxpc3Q7XHJcbnZhciBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2R5bmFtaWNfY29tcG9uZW50X2xvYWRlcicpO1xyXG5leHBvcnRzLkR5bmFtaWNDb21wb25lbnRMb2FkZXIgPSBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMS5EeW5hbWljQ29tcG9uZW50TG9hZGVyO1xyXG52YXIgZWxlbWVudF9yZWZfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2VsZW1lbnRfcmVmJyk7XHJcbmV4cG9ydHMuRWxlbWVudFJlZiA9IGVsZW1lbnRfcmVmXzEuRWxlbWVudFJlZjtcclxudmFyIHRlbXBsYXRlX3JlZl8xID0gcmVxdWlyZSgnLi9saW5rZXIvdGVtcGxhdGVfcmVmJyk7XHJcbmV4cG9ydHMuVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZV9yZWZfMS5UZW1wbGF0ZVJlZjtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL2xpbmtlci92aWV3X3JlZicpO1xyXG5leHBvcnRzLlZpZXdSZWYgPSB2aWV3X3JlZl8xLlZpZXdSZWY7XHJcbmV4cG9ydHMuUHJvdG9WaWV3UmVmID0gdmlld19yZWZfMS5Qcm90b1ZpZXdSZWY7XHJcbnZhciB2aWV3X2NvbnRhaW5lcl9yZWZfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZicpO1xyXG5leHBvcnRzLlZpZXdDb250YWluZXJSZWYgPSB2aWV3X2NvbnRhaW5lcl9yZWZfMS5WaWV3Q29udGFpbmVyUmVmO1xyXG52YXIgZHluYW1pY19jb21wb25lbnRfbG9hZGVyXzIgPSByZXF1aXJlKCcuL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXInKTtcclxuZXhwb3J0cy5Db21wb25lbnRSZWYgPSBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMi5Db21wb25lbnRSZWY7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIHByb3RvX3ZpZXdfZmFjdG9yeV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3Byb3RvX3ZpZXdfZmFjdG9yeScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgdGVtcGxhdGVfY29tbWFuZHNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci90ZW1wbGF0ZV9jb21tYW5kcycpO1xyXG4vKipcclxuICogTG93LWxldmVsIHNlcnZpY2UgZm9yIGNvbXBpbGluZyB7QGxpbmsgQ29tcG9uZW50fXMgaW50byB7QGxpbmsgUHJvdG9WaWV3UmVmIFByb3RvVmlld3N9cywgd2hpY2hcclxuICogY2FuIGxhdGVyIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCByZW5kZXIgYSBDb21wb25lbnQgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIE1vc3QgYXBwbGljYXRpb25zIHNob3VsZCBpbnN0ZWFkIHVzZSBoaWdoZXItbGV2ZWwge0BsaW5rIER5bmFtaWNDb21wb25lbnRMb2FkZXJ9IHNlcnZpY2UsIHdoaWNoXHJcbiAqIGJvdGggY29tcGlsZXMgYW5kIGluc3RhbnRpYXRlcyBhIENvbXBvbmVudC5cclxuICovXHJcbnZhciBDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlcigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBDb21waWxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Db21waWxlciA9IENvbXBpbGVyO1xyXG52YXIgQ29tcGlsZXJfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21waWxlcl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlcl8oX3Byb3RvVmlld0ZhY3RvcnkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5ID0gX3Byb3RvVmlld0ZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgICBDb21waWxlcl8ucHJvdG90eXBlLmNvbXBpbGVJbkhvc3QgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgIHZhciBtZXRhZGF0YXMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgIHZhciBjb21waWxlZEhvc3RUZW1wbGF0ZSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gbWV0YWRhdGFzW2ldO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgaW5zdGFuY2VvZiB0ZW1wbGF0ZV9jb21tYW5kc18xLkNvbXBpbGVkSG9zdFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21waWxlZEhvc3RUZW1wbGF0ZSA9IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBpbGVkSG9zdFRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBwcmVjb21waWxlZCB0ZW1wbGF0ZSBmb3IgY29tcG9uZW50IFwiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnRUeXBlKSArIFwiIGZvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKHRoaXMuX2NyZWF0ZVByb3RvVmlldyhjb21waWxlZEhvc3RUZW1wbGF0ZSkpO1xyXG4gICAgfTtcclxuICAgIENvbXBpbGVyXy5wcm90b3R5cGUuX2NyZWF0ZVByb3RvVmlldyA9IGZ1bmN0aW9uIChjb21waWxlZEhvc3RUZW1wbGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5LmNyZWF0ZUhvc3QoY29tcGlsZWRIb3N0VGVtcGxhdGUpLnJlZjtcclxuICAgIH07XHJcbiAgICBDb21waWxlcl8ucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkuY2xlYXJDYWNoZSgpOyB9O1xyXG4gICAgQ29tcGlsZXJfID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3Byb3RvX3ZpZXdfZmFjdG9yeV8xLlByb3RvVmlld0ZhY3RvcnldKVxyXG4gICAgXSwgQ29tcGlsZXJfKTtcclxuICAgIHJldHVybiBDb21waWxlcl87XHJcbn0pKENvbXBpbGVyKTtcclxuZXhwb3J0cy5Db21waWxlcl8gPSBDb21waWxlcl87XHJcbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlUHJvdG9WaWV3KGNvbXBpbGVyLCBjb21waWxlZEhvc3RUZW1wbGF0ZSkge1xyXG4gICAgcmV0dXJuIGNvbXBpbGVyLl9jcmVhdGVQcm90b1ZpZXcoY29tcGlsZWRIb3N0VGVtcGxhdGUpO1xyXG59XHJcbmV4cG9ydHMuaW50ZXJuYWxDcmVhdGVQcm90b1ZpZXcgPSBpbnRlcm5hbENyZWF0ZVByb3RvVmlldztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XHJcbmZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2sobGNJbnRlcmZhY2UsIHRva2VuKSB7XHJcbiAgICBpZiAoISh0b2tlbiBpbnN0YW5jZW9mIGxhbmdfMS5UeXBlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcHJvdG8gPSB0b2tlbi5wcm90b3R5cGU7XHJcbiAgICBzd2l0Y2ggKGxjSW50ZXJmYWNlKSB7XHJcbiAgICAgICAgY2FzZSBpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8uYWZ0ZXJDb250ZW50SW5pdDtcclxuICAgICAgICBjYXNlIGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5hZnRlckNvbnRlbnRDaGVja2VkO1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XHJcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLmFmdGVyVmlld0luaXQ7XHJcbiAgICAgICAgY2FzZSBpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8uYWZ0ZXJWaWV3Q2hlY2tlZDtcclxuICAgICAgICBjYXNlIGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XHJcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLm9uQ2hhbmdlcztcclxuICAgICAgICBjYXNlIGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5Eb0NoZWNrOlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5kb0NoZWNrO1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8ub25EZXN0cm95O1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uSW5pdDpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8ub25Jbml0O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmhhc0xpZmVjeWNsZUhvb2sgPSBoYXNMaWZlY3ljbGVIb29rO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxuLypcclxuICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige0BsaW5rIERpcmVjdGl2ZU1ldGFkYXRhfS5cclxuICpcclxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIENvbXBpbGVyfVxyXG4gKi9cclxudmFyIERpcmVjdGl2ZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVJlc29sdmVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4ge0BsaW5rIERpcmVjdGl2ZU1ldGFkYXRhfSBmb3IgYSBnaXZlbiBgVHlwZWAuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5hbm5vdGF0aW9ucyhkaV8xLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0eXBlTWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZU1ldGFkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0eXBlTWV0YWRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkRpcmVjdGl2ZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TWV0YWRhdGEgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gRGlyZWN0aXZlIGFubm90YXRpb24gZm91bmQgb24gXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpKTtcclxuICAgIH07XHJcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZG0sIHByb3BlcnR5TWV0YWRhdGEpIHtcclxuICAgICAgICB2YXIgaW5wdXRzID0gW107XHJcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcclxuICAgICAgICB2YXIgaG9zdCA9IHt9O1xyXG4gICAgICAgIHZhciBxdWVyaWVzID0ge307XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChwcm9wZXJ0eU1ldGFkYXRhLCBmdW5jdGlvbiAobWV0YWRhdGEsIHByb3BOYW1lKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5JbnB1dE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYS5iaW5kaW5nUHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIGEuYmluZGluZ1Byb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk91dHB1dE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYS5iaW5kaW5nUHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuSG9zdEJpbmRpbmdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGEuaG9zdFByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCJbXCIgKyBhLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIHByb3BOYW1lICsgXCJdXCIpXSA9IHByb3BOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ib3N0TGlzdGVuZXJNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbGFuZ18xLmlzUHJlc2VudChhLmFyZ3MpID8gYS5hcmdzLmpvaW4oJywgJykgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBob3N0WyhcIihcIiArIGEuZXZlbnROYW1lICsgXCIpXCIpXSA9IHByb3BOYW1lICsgXCIoXCIgKyBhcmdzICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuQ29udGVudENoaWxkcmVuTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuVmlld0NoaWxkcmVuTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuQ29udGVudENoaWxkTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuVmlld0NoaWxkTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShkbSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzKTtcclxuICAgIH07XHJcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMpIHtcclxuICAgICAgICB2YXIgbWVyZ2VkSW5wdXRzID0gbGFuZ18xLmlzUHJlc2VudChkbS5pbnB1dHMpID8gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChkbS5pbnB1dHMsIGlucHV0cykgOiBpbnB1dHM7XHJcbiAgICAgICAgdmFyIG1lcmdlZE91dHB1dHMgPSBsYW5nXzEuaXNQcmVzZW50KGRtLm91dHB1dHMpID8gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChkbS5vdXRwdXRzLCBvdXRwdXRzKSA6IG91dHB1dHM7XHJcbiAgICAgICAgdmFyIG1lcmdlZEhvc3QgPSBsYW5nXzEuaXNQcmVzZW50KGRtLmhvc3QpID8gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIubWVyZ2UoZG0uaG9zdCwgaG9zdCkgOiBob3N0O1xyXG4gICAgICAgIHZhciBtZXJnZWRRdWVyaWVzID0gbGFuZ18xLmlzUHJlc2VudChkbS5xdWVyaWVzKSA/IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGRtLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcclxuICAgICAgICBpZiAoZG0gaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkNvbXBvbmVudE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWV0YWRhdGFfMS5Db21wb25lbnRNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZG0uc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcclxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXHJcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRtLmV4cG9ydEFzLFxyXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGRtLm1vZHVsZUlkLFxyXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcclxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogZG0uY2hhbmdlRGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkbS5wcm92aWRlcnMsXHJcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBkbS52aWV3UHJvdmlkZXJzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZXRhZGF0YV8xLkRpcmVjdGl2ZU1ldGFkYXRhKHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkbS5zZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcclxuICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZG0uZXhwb3J0QXMsXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogZG0ubW9kdWxlSWQsXHJcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkbS5wcm92aWRlcnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpcmVjdGl2ZVJlc29sdmVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEaXJlY3RpdmVSZXNvbHZlcik7XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlUmVzb2x2ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGlyZWN0aXZlUmVzb2x2ZXIgPSBEaXJlY3RpdmVSZXNvbHZlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlX3Jlc29sdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZSgnLi9jb21waWxlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHZpZXdfbWFuYWdlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfbWFuYWdlcicpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIENvbXBvbmVudCBjcmVhdGVkIHZpYSB7QGxpbmsgRHluYW1pY0NvbXBvbmVudExvYWRlcn0uXHJcbiAqXHJcbiAqIGBDb21wb25lbnRSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgQ29tcG9uZW50IEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcclxuICogQ29tcG9uZW50IEluc3RhbmNlIGFuZCBhbGxvd3MgeW91IHRvIGRlc3Ryb3kgdGhlIENvbXBvbmVudCBJbnN0YW5jZSB2aWEgdGhlIHtAbGluayAjZGlzcG9zZX1cclxuICogbWV0aG9kLlxyXG4gKi9cclxudmFyIENvbXBvbmVudFJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnRSZWYoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJob3N0Vmlld1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHtAbGluayBWaWV3UmVmfSBvZiB0aGUgSG9zdCBWaWV3IG9mIHRoaXMgQ29tcG9uZW50IGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXJlbnRWaWV3OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RDb21wb25lbnRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUT0RPKGkpOiB0aGlzIGFwaSBzaG91bGQgYmUgcmVtb3ZlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbnN0YW5jZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29tcG9uZW50UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBvbmVudFJlZiA9IENvbXBvbmVudFJlZjtcclxudmFyIENvbXBvbmVudFJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbXBvbmVudFJlZl8sIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIFRPRE8oaSk6IHJlZmFjdG9yIGludG8gcHVibGljL3ByaXZhdGUgZmllbGRzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZl8obG9jYXRpb24sIGluc3RhbmNlLCBjb21wb25lbnRUeXBlLCBpbmplY3RvciwgX2Rpc3Bvc2UpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlID0gX2Rpc3Bvc2U7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJob3N0Q29tcG9uZW50VHlwZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoaXMgQ29tcG9uZW50IGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVE9ETyhpKTogdGhpcyBhcGkgc2hvdWxkIGJlIHJlbW92ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29tcG9uZW50VHlwZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb21wb25lbnRSZWZfLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kaXNwb3NlKCk7IH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50UmVmXztcclxufSkoQ29tcG9uZW50UmVmKTtcclxuZXhwb3J0cy5Db21wb25lbnRSZWZfID0gQ29tcG9uZW50UmVmXztcclxuLyoqXHJcbiAqIFNlcnZpY2UgZm9yIGluc3RhbnRpYXRpbmcgYSBDb21wb25lbnQgYW5kIGF0dGFjaGluZyBpdCB0byBhIFZpZXcgYXQgYSBzcGVjaWZpZWQgbG9jYXRpb24uXHJcbiAqL1xyXG52YXIgRHluYW1pY0NvbXBvbmVudExvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEeW5hbWljQ29tcG9uZW50TG9hZGVyKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIER5bmFtaWNDb21wb25lbnRMb2FkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRHluYW1pY0NvbXBvbmVudExvYWRlciA9IER5bmFtaWNDb21wb25lbnRMb2FkZXI7XHJcbnZhciBEeW5hbWljQ29tcG9uZW50TG9hZGVyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRHluYW1pY0NvbXBvbmVudExvYWRlcl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEeW5hbWljQ29tcG9uZW50TG9hZGVyXyhfY29tcGlsZXIsIF92aWV3TWFuYWdlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBpbGVyID0gX2NvbXBpbGVyO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdNYW5hZ2VyID0gX3ZpZXdNYW5hZ2VyO1xyXG4gICAgfVxyXG4gICAgRHluYW1pY0NvbXBvbmVudExvYWRlcl8ucHJvdG90eXBlLmxvYWRBc1Jvb3QgPSBmdW5jdGlvbiAodHlwZSwgb3ZlcnJpZGVTZWxlY3RvciwgaW5qZWN0b3IsIG9uRGlzcG9zZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVyLmNvbXBpbGVJbkhvc3QodHlwZSkudGhlbihmdW5jdGlvbiAoaG9zdFByb3RvVmlld1JlZikge1xyXG4gICAgICAgICAgICB2YXIgaG9zdFZpZXdSZWYgPSBfdGhpcy5fdmlld01hbmFnZXIuY3JlYXRlUm9vdEhvc3RWaWV3KGhvc3RQcm90b1ZpZXdSZWYsIG92ZXJyaWRlU2VsZWN0b3IsIGluamVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIG5ld0xvY2F0aW9uID0gX3RoaXMuX3ZpZXdNYW5hZ2VyLmdldEhvc3RFbGVtZW50KGhvc3RWaWV3UmVmKTtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLl92aWV3TWFuYWdlci5nZXRDb21wb25lbnQobmV3TG9jYXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl92aWV3TWFuYWdlci5kZXN0cm95Um9vdEhvc3RWaWV3KGhvc3RWaWV3UmVmKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9uRGlzcG9zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbkRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRSZWZfKG5ld0xvY2F0aW9uLCBjb21wb25lbnQsIHR5cGUsIGluamVjdG9yLCBkaXNwb3NlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEeW5hbWljQ29tcG9uZW50TG9hZGVyXy5wcm90b3R5cGUubG9hZEludG9Mb2NhdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBob3N0TG9jYXRpb24sIGFuY2hvck5hbWUsIHByb3ZpZGVycykge1xyXG4gICAgICAgIGlmIChwcm92aWRlcnMgPT09IHZvaWQgMCkgeyBwcm92aWRlcnMgPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE5leHRUb0xvY2F0aW9uKHR5cGUsIHRoaXMuX3ZpZXdNYW5hZ2VyLmdldE5hbWVkRWxlbWVudEluQ29tcG9uZW50Vmlldyhob3N0TG9jYXRpb24sIGFuY2hvck5hbWUpLCBwcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfLnByb3RvdHlwZS5sb2FkTmV4dFRvTG9jYXRpb24gPSBmdW5jdGlvbiAodHlwZSwgbG9jYXRpb24sIHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHByb3ZpZGVycyA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZXIuY29tcGlsZUluSG9zdCh0eXBlKS50aGVuKGZ1bmN0aW9uIChob3N0UHJvdG9WaWV3UmVmKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gX3RoaXMuX3ZpZXdNYW5hZ2VyLmdldFZpZXdDb250YWluZXIobG9jYXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgaG9zdFZpZXdSZWYgPSB2aWV3Q29udGFpbmVyLmNyZWF0ZUhvc3RWaWV3KGhvc3RQcm90b1ZpZXdSZWYsIHZpZXdDb250YWluZXIubGVuZ3RoLCBwcm92aWRlcnMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3TG9jYXRpb24gPSBfdGhpcy5fdmlld01hbmFnZXIuZ2V0SG9zdEVsZW1lbnQoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuX3ZpZXdNYW5hZ2VyLmdldENvbXBvbmVudChuZXdMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBkaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdmlld0NvbnRhaW5lci5pbmRleE9mKGhvc3RWaWV3UmVmKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyLnJlbW92ZShpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50UmVmXyhuZXdMb2NhdGlvbiwgY29tcG9uZW50LCB0eXBlLCBudWxsLCBkaXNwb3NlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEeW5hbWljQ29tcG9uZW50TG9hZGVyXyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb21waWxlcl8xLkNvbXBpbGVyLCB2aWV3X21hbmFnZXJfMS5BcHBWaWV3TWFuYWdlcl0pXHJcbiAgICBdLCBEeW5hbWljQ29tcG9uZW50TG9hZGVyXyk7XHJcbiAgICByZXR1cm4gRHluYW1pY0NvbXBvbmVudExvYWRlcl87XHJcbn0pKER5bmFtaWNDb21wb25lbnRMb2FkZXIpO1xyXG5leHBvcnRzLkR5bmFtaWNDb21wb25lbnRMb2FkZXJfID0gRHluYW1pY0NvbXBvbmVudExvYWRlcl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWNfY29tcG9uZW50X2xvYWRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgRWxlbWVudEJpbmRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50QmluZGVyKGluZGV4LCBwYXJlbnQsIGRpc3RhbmNlVG9QYXJlbnQsIHByb3RvRWxlbWVudEluamVjdG9yLCBjb21wb25lbnREaXJlY3RpdmUsIG5lc3RlZFByb3RvVmlldykge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnQgPSBkaXN0YW5jZVRvUGFyZW50O1xyXG4gICAgICAgIHRoaXMucHJvdG9FbGVtZW50SW5qZWN0b3IgPSBwcm90b0VsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudERpcmVjdGl2ZSA9IGNvbXBvbmVudERpcmVjdGl2ZTtcclxuICAgICAgICB0aGlzLm5lc3RlZFByb3RvVmlldyA9IG5lc3RlZFByb3RvVmlldztcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignbnVsbCBpbmRleCBub3QgYWxsb3dlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRWxlbWVudEJpbmRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5FbGVtZW50QmluZGVyID0gRWxlbWVudEJpbmRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF9iaW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGluamVjdG9yXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9pbmplY3RvcicpO1xyXG52YXIgcHJvdmlkZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpL3Byb3ZpZGVyJyk7XHJcbnZhciBkaV8yID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEvZGknKTtcclxudmFyIGF2bU1vZHVsZSA9IHJlcXVpcmUoJy4vdmlld19tYW5hZ2VyJyk7XHJcbnZhciB2aWV3X2NvbnRhaW5lcl9yZWZfMSA9IHJlcXVpcmUoJy4vdmlld19jb250YWluZXJfcmVmJyk7XHJcbnZhciBlbGVtZW50X3JlZl8xID0gcmVxdWlyZSgnLi9lbGVtZW50X3JlZicpO1xyXG52YXIgdGVtcGxhdGVfcmVmXzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX3JlZicpO1xyXG52YXIgZGlyZWN0aXZlc18xID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xyXG52YXIgZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3InKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgcXVlcnlfbGlzdF8xID0gcmVxdWlyZSgnLi9xdWVyeV9saXN0Jyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxudmFyIGV2ZW50X2NvbmZpZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2V2ZW50X2NvbmZpZycpO1xyXG52YXIgcGlwZV9wcm92aWRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvcGlwZV9wcm92aWRlcicpO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XHJcbnZhciB2aWV3X2NvbnRhaW5lcl9yZWZfMiA9IHJlcXVpcmUoXCIuL3ZpZXdfY29udGFpbmVyX3JlZlwiKTtcclxudmFyIF9zdGF0aWNLZXlzO1xyXG52YXIgU3RhdGljS2V5cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdGF0aWNLZXlzKCkge1xyXG4gICAgICAgIHRoaXMudmlld01hbmFnZXJJZCA9IGRpXzEuS2V5LmdldChhdm1Nb2R1bGUuQXBwVmlld01hbmFnZXIpLmlkO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWZJZCA9IGRpXzEuS2V5LmdldCh0ZW1wbGF0ZV9yZWZfMS5UZW1wbGF0ZVJlZikuaWQ7XHJcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVySWQgPSBkaV8xLktleS5nZXQodmlld19jb250YWluZXJfcmVmXzEuVmlld0NvbnRhaW5lclJlZikuaWQ7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZklkID0gZGlfMS5LZXkuZ2V0KGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclJlZikuaWQ7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmSWQgPSBkaV8xLktleS5nZXQoZWxlbWVudF9yZWZfMS5FbGVtZW50UmVmKS5pZDtcclxuICAgIH1cclxuICAgIFN0YXRpY0tleXMuaW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKF9zdGF0aWNLZXlzKSlcclxuICAgICAgICAgICAgX3N0YXRpY0tleXMgPSBuZXcgU3RhdGljS2V5cygpO1xyXG4gICAgICAgIHJldHVybiBfc3RhdGljS2V5cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhdGljS2V5cztcclxufSkoKTtcclxuZXhwb3J0cy5TdGF0aWNLZXlzID0gU3RhdGljS2V5cztcclxudmFyIFRyZWVOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyZWVOb2RlKHBhcmVudCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgcGFyZW50LmFkZENoaWxkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHsgY2hpbGQuX3BhcmVudCA9IHRoaXM7IH07XHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wYXJlbnQgPSBudWxsOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVOb2RlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBUcmVlTm9kZTtcclxufSkoKTtcclxuZXhwb3J0cy5UcmVlTm9kZSA9IFRyZWVOb2RlO1xyXG52YXIgRGlyZWN0aXZlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGlyZWN0aXZlRGVwZW5kZW5jeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZURlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVOYW1lLCBxdWVyeURlY29yYXRvcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGtleSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcclxuICAgICAgICB0aGlzLnF1ZXJ5RGVjb3JhdG9yID0gcXVlcnlEZWNvcmF0b3I7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEaXJlY3RpdmVEZXBlbmRlbmN5LnByb3RvdHlwZS5fdmVyaWZ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeURlY29yYXRvcikpXHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5hdHRyaWJ1dGVOYW1lKSlcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICBpZiAoY291bnQgPiAxKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0EgZGlyZWN0aXZlIGluamVjdGFibGUgY2FuIGNvbnRhaW4gb25seSBvbmUgb2YgdGhlIGZvbGxvd2luZyBAQXR0cmlidXRlIG9yIEBRdWVyeS4nKTtcclxuICAgIH07XHJcbiAgICBEaXJlY3RpdmVEZXBlbmRlbmN5LmNyZWF0ZUZyb20gPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlRGVwZW5kZW5jeShkLmtleSwgZC5vcHRpb25hbCwgZC5sb3dlckJvdW5kVmlzaWJpbGl0eSwgZC51cHBlckJvdW5kVmlzaWJpbGl0eSwgZC5wcm9wZXJ0aWVzLCBEaXJlY3RpdmVEZXBlbmRlbmN5Ll9hdHRyaWJ1dGVOYW1lKGQucHJvcGVydGllcyksIERpcmVjdGl2ZURlcGVuZGVuY3kuX3F1ZXJ5KGQucHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIERpcmVjdGl2ZURlcGVuZGVuY3kuX2F0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgIHZhciBwID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbmQocHJvcGVydGllcywgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAgaW5zdGFuY2VvZiBkaV8yLkF0dHJpYnV0ZU1ldGFkYXRhOyB9KTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChwKSA/IHAuYXR0cmlidXRlTmFtZSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRGlyZWN0aXZlRGVwZW5kZW5jeS5fcXVlcnkgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmluZChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcCBpbnN0YW5jZW9mIGRpXzIuUXVlcnlNZXRhZGF0YTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpcmVjdGl2ZURlcGVuZGVuY3k7XHJcbn0pKGRpXzEuRGVwZW5kZW5jeSk7XHJcbmV4cG9ydHMuRGlyZWN0aXZlRGVwZW5kZW5jeSA9IERpcmVjdGl2ZURlcGVuZGVuY3k7XHJcbnZhciBEaXJlY3RpdmVQcm92aWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGlyZWN0aXZlUHJvdmlkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVQcm92aWRlcihrZXksIGZhY3RvcnksIGRlcHMsIG1ldGFkYXRhLCBwcm92aWRlcnMsIHZpZXdQcm92aWRlcnMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBrZXksIFtuZXcgcHJvdmlkZXJfMS5SZXNvbHZlZEZhY3RvcnkoZmFjdG9yeSwgZGVwcyldLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xyXG4gICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IHZpZXdQcm92aWRlcnM7XHJcbiAgICAgICAgdGhpcy5jYWxsT25EZXN0cm95ID0gZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksIGtleS50b2tlbik7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlUHJvdmlkZXIucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5LmRpc3BsYXlOYW1lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVQcm92aWRlci5wcm90b3R5cGUsIFwicXVlcmllc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLm1ldGFkYXRhLnF1ZXJpZXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godGhpcy5tZXRhZGF0YS5xdWVyaWVzLCBmdW5jdGlvbiAobWV0YSwgZmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5zZXR0ZXIoZmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5ldyBRdWVyeU1ldGFkYXRhV2l0aFNldHRlcihzZXR0ZXIsIG1ldGEpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlUHJvdmlkZXIucHJvdG90eXBlLCBcImV2ZW50RW1pdHRlcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLm1ldGFkYXRhKSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMubWV0YWRhdGEub3V0cHV0cykgPyB0aGlzLm1ldGFkYXRhLm91dHB1dHMgOlxyXG4gICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEaXJlY3RpdmVQcm92aWRlci5jcmVhdGVGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIG1ldGEpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWV0YSkpIHtcclxuICAgICAgICAgICAgbWV0YSA9IG5ldyBkaXJlY3RpdmVzXzEuRGlyZWN0aXZlTWV0YWRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJiID0gcHJvdmlkZXJfMS5yZXNvbHZlUHJvdmlkZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHZhciByZiA9IHJiLnJlc29sdmVkRmFjdG9yaWVzWzBdO1xyXG4gICAgICAgIHZhciBkZXBzID0gcmYuZGVwZW5kZW5jaWVzLm1hcChEaXJlY3RpdmVEZXBlbmRlbmN5LmNyZWF0ZUZyb20pO1xyXG4gICAgICAgIHZhciBwcm92aWRlcnMgPSBsYW5nXzEuaXNQcmVzZW50KG1ldGEucHJvdmlkZXJzKSA/IG1ldGEucHJvdmlkZXJzIDogW107XHJcbiAgICAgICAgdmFyIHZpZXdCaW5kaWdzID0gbWV0YSBpbnN0YW5jZW9mIGRpcmVjdGl2ZXNfMS5Db21wb25lbnRNZXRhZGF0YSAmJiBsYW5nXzEuaXNQcmVzZW50KG1ldGEudmlld1Byb3ZpZGVycykgP1xyXG4gICAgICAgICAgICBtZXRhLnZpZXdQcm92aWRlcnMgOlxyXG4gICAgICAgICAgICBbXTtcclxuICAgICAgICByZXR1cm4gbmV3IERpcmVjdGl2ZVByb3ZpZGVyKHJiLmtleSwgcmYuZmFjdG9yeSwgZGVwcywgbWV0YSwgcHJvdmlkZXJzLCB2aWV3QmluZGlncyk7XHJcbiAgICB9O1xyXG4gICAgRGlyZWN0aXZlUHJvdmlkZXIuY3JlYXRlRnJvbVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgYW5ub3RhdGlvbikge1xyXG4gICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBkaV8xLlByb3ZpZGVyKHR5cGUsIHsgdXNlQ2xhc3M6IHR5cGUgfSk7XHJcbiAgICAgICAgcmV0dXJuIERpcmVjdGl2ZVByb3ZpZGVyLmNyZWF0ZUZyb21Qcm92aWRlcihwcm92aWRlciwgYW5ub3RhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpcmVjdGl2ZVByb3ZpZGVyO1xyXG59KShwcm92aWRlcl8xLlJlc29sdmVkUHJvdmlkZXJfKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVQcm92aWRlciA9IERpcmVjdGl2ZVByb3ZpZGVyO1xyXG4vLyBUT0RPKHJhZG8pOiBiZW5jaG1hcmsgYW5kIGNvbnNpZGVyIHJvbGxpbmcgaW4gYXMgRWxlbWVudEluamVjdG9yIGZpZWxkcy5cclxudmFyIFByZUJ1aWx0T2JqZWN0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVCdWlsdE9iamVjdHModmlld01hbmFnZXIsIHZpZXcsIGVsZW1lbnRSZWYsIHRlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TWFuYWdlciA9IHZpZXdNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XHJcbiAgICAgICAgdGhpcy5uZXN0ZWRWaWV3ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBQcmVCdWlsdE9iamVjdHM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJlQnVpbHRPYmplY3RzID0gUHJlQnVpbHRPYmplY3RzO1xyXG52YXIgUXVlcnlNZXRhZGF0YVdpdGhTZXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVlcnlNZXRhZGF0YVdpdGhTZXR0ZXIoc2V0dGVyLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2V0dGVyID0gc2V0dGVyO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBRdWVyeU1ldGFkYXRhV2l0aFNldHRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5RdWVyeU1ldGFkYXRhV2l0aFNldHRlciA9IFF1ZXJ5TWV0YWRhdGFXaXRoU2V0dGVyO1xyXG52YXIgRXZlbnRFbWl0dGVyQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyQWNjZXNzb3IoZXZlbnROYW1lLCBnZXR0ZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcclxuICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcclxuICAgIH1cclxuICAgIEV2ZW50RW1pdHRlckFjY2Vzc29yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmlldywgYm91bmRFbGVtZW50SW5kZXgsIGRpcmVjdGl2ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IHRoaXMuZ2V0dGVyKGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlKGV2ZW50RW1pdHRlciwgZnVuY3Rpb24gKGV2ZW50T2JqKSB7IHJldHVybiB2aWV3LnRyaWdnZXJFdmVudEhhbmRsZXJzKF90aGlzLmV2ZW50TmFtZSwgZXZlbnRPYmosIGJvdW5kRWxlbWVudEluZGV4KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlckFjY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLkV2ZW50RW1pdHRlckFjY2Vzc29yID0gRXZlbnRFbWl0dGVyQWNjZXNzb3I7XHJcbmZ1bmN0aW9uIF9jcmVhdGVFdmVudEVtaXR0ZXJBY2Nlc3NvcnMoYnd2KSB7XHJcbiAgICB2YXIgcHJvdmlkZXIgPSBid3YucHJvdmlkZXI7XHJcbiAgICBpZiAoIShwcm92aWRlciBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyKSlcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB2YXIgZGIgPSBwcm92aWRlcjtcclxuICAgIHJldHVybiBkYi5ldmVudEVtaXR0ZXJzLm1hcChmdW5jdGlvbiAoZXZlbnRDb25maWcpIHtcclxuICAgICAgICB2YXIgcGFyc2VkRXZlbnQgPSBldmVudF9jb25maWdfMS5FdmVudENvbmZpZy5wYXJzZShldmVudENvbmZpZyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEVtaXR0ZXJBY2Nlc3NvcihwYXJzZWRFdmVudC5ldmVudE5hbWUsIHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuZ2V0dGVyKHBhcnNlZEV2ZW50LmZpZWxkTmFtZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZVByb3RvUXVlcnlSZWZzKHByb3ZpZGVycykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgocHJvdmlkZXJzLCBmdW5jdGlvbiAoYiwgaSkge1xyXG4gICAgICAgIGlmIChiLnByb3ZpZGVyIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVByb3ZpZGVyID0gYi5wcm92aWRlcjtcclxuICAgICAgICAgICAgLy8gZmllbGQgcXVlcmllc1xyXG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IGRpcmVjdGl2ZVByb3ZpZGVyLnF1ZXJpZXM7XHJcbiAgICAgICAgICAgIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocSkgeyByZXR1cm4gcmVzLnB1c2gobmV3IFByb3RvUXVlcnlSZWYoaSwgcS5zZXR0ZXIsIHEubWV0YWRhdGEpKTsgfSk7XHJcbiAgICAgICAgICAgIC8vIHF1ZXJpZXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBhZnRlciBjb25zdHJ1Y3RvciBxdWVyaWVzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIHZhciBkZXBzID0gZGlyZWN0aXZlUHJvdmlkZXIucmVzb2x2ZWRGYWN0b3J5LmRlcGVuZGVuY2llcztcclxuICAgICAgICAgICAgZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkLnF1ZXJ5RGVjb3JhdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChuZXcgUHJvdG9RdWVyeVJlZihpLCBudWxsLCBkLnF1ZXJ5RGVjb3JhdG9yKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG52YXIgUHJvdG9FbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9FbGVtZW50SW5qZWN0b3IocGFyZW50LCBpbmRleCwgYnd2LCBkaXN0YW5jZVRvUGFyZW50LCBfZmlyc3RQcm92aWRlcklzQ29tcG9uZW50LCBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudCA9IGRpc3RhbmNlVG9QYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzID0gZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncztcclxuICAgICAgICB0aGlzLl9maXJzdFByb3ZpZGVySXNDb21wb25lbnQgPSBfZmlyc3RQcm92aWRlcklzQ29tcG9uZW50O1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBid3YubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMucHJvdG9JbmplY3RvciA9IG5ldyBpbmplY3Rvcl8xLlByb3RvSW5qZWN0b3IoYnd2KTtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlckFjY2Vzc29ycyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyQWNjZXNzb3JzW2ldID0gX2NyZWF0ZUV2ZW50RW1pdHRlckFjY2Vzc29ycyhid3ZbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3RvUXVlcnlSZWZzID0gX2NyZWF0ZVByb3RvUXVlcnlSZWZzKGJ3dik7XHJcbiAgICB9XHJcbiAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50LCBpbmRleCwgcHJvdmlkZXJzLCBmaXJzdFByb3ZpZGVySXNDb21wb25lbnQsIGRpc3RhbmNlVG9QYXJlbnQsIGRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MpIHtcclxuICAgICAgICB2YXIgYmQgPSBbXTtcclxuICAgICAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlRGlyZWN0aXZlUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShwcm92aWRlcnMsIGJkLCBmaXJzdFByb3ZpZGVySXNDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChmaXJzdFByb3ZpZGVySXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgUHJvdG9FbGVtZW50SW5qZWN0b3IuX2NyZWF0ZVZpZXdQcm92aWRlcnNXaXRoVmlzaWJpbGl0eShwcm92aWRlcnMsIGJkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHJvdG9FbGVtZW50SW5qZWN0b3IuX2NyZWF0ZVByb3ZpZGVyc1dpdGhWaXNpYmlsaXR5KHByb3ZpZGVycywgYmQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdG9FbGVtZW50SW5qZWN0b3IocGFyZW50LCBpbmRleCwgYmQsIGRpc3RhbmNlVG9QYXJlbnQsIGZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCwgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9FbGVtZW50SW5qZWN0b3IuX2NyZWF0ZURpcmVjdGl2ZVByb3ZpZGVyV2l0aFZpc2liaWxpdHkgPSBmdW5jdGlvbiAoZGlyUHJvdmlkZXJzLCBiZCwgZmlyc3RQcm92aWRlcklzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgZGlyUHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKGRpclByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGJkLnB1c2goUHJvdG9FbGVtZW50SW5qZWN0b3IuX2NyZWF0ZVByb3ZpZGVyV2l0aFZpc2liaWxpdHkoZmlyc3RQcm92aWRlcklzQ29tcG9uZW50LCBkaXJQcm92aWRlciwgZGlyUHJvdmlkZXJzLCBkaXJQcm92aWRlcikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLl9jcmVhdGVQcm92aWRlcnNXaXRoVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChkaXJQcm92aWRlcnMsIGJkKSB7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyc0Zyb21BbGxEaXJlY3RpdmVzID0gW107XHJcbiAgICAgICAgZGlyUHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKGRpclByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyc0Zyb21BbGxEaXJlY3RpdmVzID1cclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb25jYXQocHJvdmlkZXJzRnJvbUFsbERpcmVjdGl2ZXMsIGRpclByb3ZpZGVyLnByb3ZpZGVycyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZGlfMS5JbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVyc0Zyb21BbGxEaXJlY3RpdmVzKTtcclxuICAgICAgICByZXNvbHZlZC5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiZC5wdXNoKG5ldyBpbmplY3Rvcl8xLlByb3ZpZGVyV2l0aFZpc2liaWxpdHkoYiwgaW5qZWN0b3JfMS5WaXNpYmlsaXR5LlB1YmxpYykpOyB9KTtcclxuICAgIH07XHJcbiAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlUHJvdmlkZXJXaXRoVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChmaXJzdFByb3ZpZGVySXNDb21wb25lbnQsIGRpclByb3ZpZGVyLCBkaXJQcm92aWRlcnMsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdmFyIGlzQ29tcG9uZW50ID0gZmlyc3RQcm92aWRlcklzQ29tcG9uZW50ICYmIGRpclByb3ZpZGVyc1swXSA9PT0gZGlyUHJvdmlkZXI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBpbmplY3Rvcl8xLlByb3ZpZGVyV2l0aFZpc2liaWxpdHkocHJvdmlkZXIsIGlzQ29tcG9uZW50ID8gaW5qZWN0b3JfMS5WaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUgOiBpbmplY3Rvcl8xLlZpc2liaWxpdHkuUHVibGljKTtcclxuICAgIH07XHJcbiAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlVmlld1Byb3ZpZGVyc1dpdGhWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKGRpclByb3ZpZGVycywgYmQpIHtcclxuICAgICAgICB2YXIgcmVzb2x2ZWRWaWV3UHJvdmlkZXJzID0gZGlfMS5JbmplY3Rvci5yZXNvbHZlKGRpclByb3ZpZGVyc1swXS52aWV3UHJvdmlkZXJzKTtcclxuICAgICAgICByZXNvbHZlZFZpZXdQcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYikgeyByZXR1cm4gYmQucHVzaChuZXcgaW5qZWN0b3JfMS5Qcm92aWRlcldpdGhWaXNpYmlsaXR5KGIsIGluamVjdG9yXzEuVmlzaWJpbGl0eS5Qcml2YXRlKSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRJbmplY3Rvcih0aGlzLCBwYXJlbnQpO1xyXG4gICAgfTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5kaXJlY3RQYXJlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc3RhbmNlVG9QYXJlbnQgPCAyID8gdGhpcy5wYXJlbnQgOiBudWxsOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3RvRWxlbWVudEluamVjdG9yLnByb3RvdHlwZSwgXCJoYXNCaW5kaW5nc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmV2ZW50RW1pdHRlckFjY2Vzc29ycy5sZW5ndGggPiAwOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRQcm92aWRlckF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMucHJvdG9JbmplY3Rvci5nZXRQcm92aWRlckF0SW5kZXgoaW5kZXgpOyB9O1xyXG4gICAgcmV0dXJuIFByb3RvRWxlbWVudEluamVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvRWxlbWVudEluamVjdG9yID0gUHJvdG9FbGVtZW50SW5qZWN0b3I7XHJcbnZhciBfQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfQ29udGV4dChlbGVtZW50LCBjb21wb25lbnRFbGVtZW50LCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRFbGVtZW50ID0gY29tcG9uZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX0NvbnRleHQ7XHJcbn0pKCk7XHJcbnZhciBFbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVsZW1lbnRJbmplY3RvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRJbmplY3RvcihfcHJvdG8sIHBhcmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGFyZW50KTtcclxuICAgICAgICB0aGlzLl9wcmVCdWlsdE9iamVjdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xyXG4gICAgICAgIHRoaXMuX2luamVjdG9yID1cclxuICAgICAgICAgICAgbmV3IGRpXzEuSW5qZWN0b3IodGhpcy5fcHJvdG8ucHJvdG9JbmplY3RvciwgbnVsbCwgdGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RlYnVnQ29udGV4dCgpOyB9KTtcclxuICAgICAgICAvLyB3ZSBjb3VwbGUgb3Vyc2VsdmVzIHRvIHRoZSBpbmplY3RvciBzdHJhdGVneSB0byBhdm9pZCBwb2x5bW9wcmhpYyBjYWxsc1xyXG4gICAgICAgIHZhciBpbmplY3RvclN0cmF0ZWd5ID0gdGhpcy5faW5qZWN0b3IuaW50ZXJuYWxTdHJhdGVneTtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IGluamVjdG9yU3RyYXRlZ3kgaW5zdGFuY2VvZiBpbmplY3Rvcl8xLkluamVjdG9ySW5saW5lU3RyYXRlZ3kgP1xyXG4gICAgICAgICAgICBuZXcgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3JTdHJhdGVneSwgdGhpcykgOlxyXG4gICAgICAgICAgICBuZXcgRWxlbWVudEluamVjdG9yRHluYW1pY1N0cmF0ZWd5KGluamVjdG9yU3RyYXRlZ3ksIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9xdWVyeVN0cmF0ZWd5ID0gdGhpcy5fYnVpbGRRdWVyeVN0cmF0ZWd5KCk7XHJcbiAgICB9XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmh5ZHJhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJlQnVpbHRPYmplY3RzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5jYWxsT25EZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kuZGVoeWRyYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlTdHJhdGVneS5kZWh5ZHJhdGUoKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCBob3N0LCBwcmVCdWlsdE9iamVjdHMpIHtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLl9wcmVCdWlsdE9iamVjdHMgPSBwcmVCdWlsdE9iamVjdHM7XHJcbiAgICAgICAgdGhpcy5fcmVhdHRhY2hJbmplY3RvcnMoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKTtcclxuICAgICAgICB0aGlzLl9xdWVyeVN0cmF0ZWd5Lmh5ZHJhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5oeWRyYXRlKCk7XHJcbiAgICAgICAgdGhpcy5oeWRyYXRlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fZGVidWdDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5fcHJlQnVpbHRPYmplY3RzO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHAuZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCAtIHAudmlldy5lbGVtZW50T2Zmc2V0O1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXcuZ2V0RGVidWdDb250ZXh0KGluZGV4LCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChjKSA/IG5ldyBfQ29udGV4dChjLmVsZW1lbnQsIGMuY29tcG9uZW50RWxlbWVudCwgYy5pbmplY3RvcikgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuX3JlYXR0YWNoSW5qZWN0b3JzID0gZnVuY3Rpb24gKGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3Rvcikge1xyXG4gICAgICAgIC8vIER5bmFtaWNhbGx5LWxvYWRlZCBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBOb3QgYSByb290IEVsZW1lbnRJbmplY3Rvci5cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBpbXBlcmF0aXZlIGluamVjdG9yIGlzIHNpbWlsYXIgdG8gaGF2aW5nIGFuIGVsZW1lbnQgYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGR5bmFtaWMtbG9hZGVkIGNvbXBvbmVudCBhbmQgaXRzIHBhcmVudCA9PiBubyBib3VuZGFyaWVzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhdHRhY2hJbmplY3Rvcih0aGlzLl9pbmplY3RvciwgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvciwgdGhpcy5fcGFyZW50Ll9pbmplY3RvciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhdHRhY2hJbmplY3Rvcih0aGlzLl9pbmplY3RvciwgdGhpcy5fcGFyZW50Ll9pbmplY3RvciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5faG9zdCkpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGltcGVyYXRpdmUgaW5qZWN0b3IgaXMgc2ltaWxhciB0byBoYXZpbmcgYW4gZWxlbWVudCBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vIHRoZSBkeW5hbWljLWxvYWRlZCBjb21wb25lbnQgYW5kIGl0cyBwYXJlbnQgPT4gbm8gYm91bmRhcnkgYmV0d2VlblxyXG4gICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGFuZCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IuXHJcbiAgICAgICAgICAgIC8vIEJ1dCBzaW5jZSBpdCBpcyBhIHJvb3QgRWxlbWVudEluamVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIC8vIGJldHdlZW4gaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yIGFuZCBfaG9zdC5cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhdHRhY2hJbmplY3Rvcih0aGlzLl9pbmplY3RvciwgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvciwgdGhpcy5faG9zdC5faW5qZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhdHRhY2hJbmplY3Rvcih0aGlzLl9pbmplY3RvciwgdGhpcy5faG9zdC5faW5qZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKHRoaXMuX2luamVjdG9yLCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuX3JlYXR0YWNoSW5qZWN0b3IgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIHBhcmVudEluamVjdG9yLCBpc0JvdW5kYXJ5KSB7XHJcbiAgICAgICAgaW5qZWN0b3IuaW50ZXJuYWxTdHJhdGVneS5hdHRhY2gocGFyZW50SW5qZWN0b3IsIGlzQm91bmRhcnkpO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuaGFzVmFyaWFibGVCaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgdmIgPSB0aGlzLl9wcm90by5kaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHZiKSAmJiB2Yi5oYXMobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRWYXJpYWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3Byb3RvLmRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MuZ2V0KG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGluZGV4KSA/IHRoaXMuZ2V0RGlyZWN0aXZlQXRJbmRleChpbmRleCkgOiB0aGlzLmdldEVsZW1lbnRSZWYoKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdGhpcy5faW5qZWN0b3IuZ2V0KHRva2VuKTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuaGFzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5faW5qZWN0b3IuZ2V0T3B0aW9uYWwodHlwZSkpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRFdmVudEVtaXR0ZXJBY2Nlc3NvcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm90by5ldmVudEVtaXR0ZXJBY2Nlc3NvcnM7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldERpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvLmRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3M7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRDb21wb25lbnQoKTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0SW5qZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0RWxlbWVudFJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy5lbGVtZW50UmVmOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRWaWV3Q29udGFpbmVyUmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgdmlld19jb250YWluZXJfcmVmXzIuVmlld0NvbnRhaW5lclJlZl8odGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXdNYW5hZ2VyLCB0aGlzLmdldEVsZW1lbnRSZWYoKSk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXROZXN0ZWRWaWV3ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJlQnVpbHRPYmplY3RzLm5lc3RlZFZpZXc7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmVCdWlsdE9iamVjdHMudmlldzsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZGlyZWN0UGFyZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvdG8uZGlzdGFuY2VUb1BhcmVudCA8IDIgPyB0aGlzLnBhcmVudCA6IG51bGw7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmlzQ29tcG9uZW50S2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuaXNDb21wb25lbnRLZXkoa2V5KTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChpbmplY3RvciwgcHJvdmlkZXIsIGRlcCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBkZXAua2V5O1xyXG4gICAgICAgIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJEZXAgPSBkZXA7XHJcbiAgICAgICAgICAgIHZhciBkaXJQcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGljS2V5cyA9IFN0YXRpY0tleXMuaW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgaWYgKGtleS5pZCA9PT0gc3RhdGljS2V5cy52aWV3TWFuYWdlcklkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy52aWV3TWFuYWdlcjtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyRGVwLmF0dHJpYnV0ZU5hbWUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkQXR0cmlidXRlKGRpckRlcCk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpckRlcC5xdWVyeURlY29yYXRvcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlTdHJhdGVneS5maW5kUXVlcnkoZGlyRGVwLnF1ZXJ5RGVjb3JhdG9yKS5saXN0O1xyXG4gICAgICAgICAgICBpZiAoZGlyRGVwLmtleS5pZCA9PT0gU3RhdGljS2V5cy5pbnN0YW5jZSgpLmNoYW5nZURldGVjdG9yUmVmSWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHByb3ZpZGUgdGhlIGNvbXBvbmVudCdzIHZpZXcgY2hhbmdlIGRldGVjdG9yIHRvIGNvbXBvbmVudHMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3Vycm91bmRpbmcgY29tcG9uZW50J3MgY2hhbmdlIGRldGVjdG9yIHRvIGRpcmVjdGl2ZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyUHJvdmlkZXIubWV0YWRhdGEgaW5zdGFuY2VvZiBkaXJlY3RpdmVzXzEuQ29tcG9uZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy52aWV3LmdldE5lc3RlZFZpZXcodGhpcy5fcHJlQnVpbHRPYmplY3RzLmVsZW1lbnRSZWYuYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRWaWV3LmNoYW5nZURldGVjdG9yLnJlZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVCdWlsdE9iamVjdHMudmlldy5jaGFuZ2VEZXRlY3Rvci5yZWY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpckRlcC5rZXkuaWQgPT09IFN0YXRpY0tleXMuaW5zdGFuY2UoKS5lbGVtZW50UmVmSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRSZWYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyRGVwLmtleS5pZCA9PT0gU3RhdGljS2V5cy5pbnN0YW5jZSgpLnZpZXdDb250YWluZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Vmlld0NvbnRhaW5lclJlZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJEZXAua2V5LmlkID09PSBTdGF0aWNLZXlzLmluc3RhbmNlKCkudGVtcGxhdGVSZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy50ZW1wbGF0ZVJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyRGVwLm9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZGlfMS5Ob1Byb3ZpZGVyRXJyb3IobnVsbCwgZGlyRGVwLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnRlbXBsYXRlUmVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgcGlwZV9wcm92aWRlcl8xLlBpcGVQcm92aWRlcikge1xyXG4gICAgICAgICAgICBpZiAoZGVwLmtleS5pZCA9PT0gU3RhdGljS2V5cy5pbnN0YW5jZSgpLmNoYW5nZURldGVjdG9yUmVmSWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRWaWV3ID0gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXcuZ2V0TmVzdGVkVmlldyh0aGlzLl9wcmVCdWlsdE9iamVjdHMuZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Vmlldy5jaGFuZ2VEZXRlY3Rvci5yZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuX2J1aWxkQXR0cmlidXRlID0gZnVuY3Rpb24gKGRlcCkge1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5fcHJvdG8uYXR0cmlidXRlcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdHRyaWJ1dGVzKSAmJiBhdHRyaWJ1dGVzLmhhcyhkZXAuYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuZ2V0KGRlcC5hdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmFkZERpcmVjdGl2ZXNNYXRjaGluZ1F1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlUmVmID0gbGFuZ18xLmlzQmxhbmsodGhpcy5fcHJlQnVpbHRPYmplY3RzKSA/IG51bGwgOiB0aGlzLl9wcmVCdWlsdE9iamVjdHMudGVtcGxhdGVSZWY7XHJcbiAgICAgICAgaWYgKHF1ZXJ5LnNlbGVjdG9yID09PSB0ZW1wbGF0ZV9yZWZfMS5UZW1wbGF0ZVJlZiAmJiBsYW5nXzEuaXNQcmVzZW50KHRlbXBsYXRlUmVmKSkge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2godGVtcGxhdGVSZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5hZGREaXJlY3RpdmVzTWF0Y2hpbmdRdWVyeShxdWVyeSwgbGlzdCk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fYnVpbGRRdWVyeVN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm90by5wcm90b1F1ZXJ5UmVmcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9lbXB0eVF1ZXJ5U3RyYXRlZ3k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Byb3RvLnByb3RvUXVlcnlSZWZzLmxlbmd0aCA8PVxyXG4gICAgICAgICAgICBJbmxpbmVRdWVyeVN0cmF0ZWd5Lk5VTUJFUl9PRl9TVVBQT1JURURfUVVFUklFUykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElubGluZVF1ZXJ5U3RyYXRlZ3kodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IER5bmFtaWNRdWVyeVN0cmF0ZWd5KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbiAocGFyZW50KSB7IHBhcmVudC5hZGRDaGlsZCh0aGlzKTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZSgpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXREaXJlY3RpdmVBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9pbmplY3Rvci5nZXRBdChpbmRleCk7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmhhc0luc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3RvLmhhc0JpbmRpbmdzICYmIHRoaXMuaHlkcmF0ZWQ7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldEhvc3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0OyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRCb3VuZEVsZW1lbnRJbmRleCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3RvLmluZGV4OyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRSb290Vmlld0luamVjdG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaHlkcmF0ZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy52aWV3O1xyXG4gICAgICAgIHZhciBuZXN0ZWRWaWV3ID0gdmlldy5nZXROZXN0ZWRWaWV3KHZpZXcuZWxlbWVudE9mZnNldCArIHRoaXMuZ2V0Qm91bmRFbGVtZW50SW5kZXgoKSk7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQobmVzdGVkVmlldykgPyBuZXN0ZWRWaWV3LnJvb3RFbGVtZW50SW5qZWN0b3JzIDogW107XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5hZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9xdWVyeVN0cmF0ZWd5LnVwZGF0ZVZpZXdRdWVyaWVzKCk7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmFmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3F1ZXJ5U3RyYXRlZ3kudXBkYXRlQ29udGVudFF1ZXJpZXMoKTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUudHJhdmVyc2VBbmRTZXRRdWVyaWVzQXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcztcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChpbmopKSB7XHJcbiAgICAgICAgICAgIGluai5fc2V0UXVlcmllc0FzRGlydHkoKTtcclxuICAgICAgICAgICAgaW5qID0gaW5qLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fc2V0UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlTdHJhdGVneS5zZXRDb250ZW50UXVlcmllc0FzRGlydHkoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9ob3N0KSlcclxuICAgICAgICAgICAgdGhpcy5faG9zdC5fcXVlcnlTdHJhdGVneS5zZXRWaWV3UXVlcmllc0FzRGlydHkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRWxlbWVudEluamVjdG9yO1xyXG59KShUcmVlTm9kZSk7XHJcbmV4cG9ydHMuRWxlbWVudEluamVjdG9yID0gRWxlbWVudEluamVjdG9yO1xyXG52YXIgX0VtcHR5UXVlcnlTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfRW1wdHlRdWVyeVN0cmF0ZWd5KCkge1xyXG4gICAgfVxyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUuc2V0Q29udGVudFF1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUuc2V0Vmlld1F1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIF9FbXB0eVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIF9FbXB0eVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnRRdWVyaWVzID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlVmlld1F1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBfRW1wdHlRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5maW5kUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgZmluZCBxdWVyeSBmb3IgZGlyZWN0aXZlIFwiICsgcXVlcnkgKyBcIi5cIik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9FbXB0eVF1ZXJ5U3RyYXRlZ3k7XHJcbn0pKCk7XHJcbnZhciBfZW1wdHlRdWVyeVN0cmF0ZWd5ID0gbmV3IF9FbXB0eVF1ZXJ5U3RyYXRlZ3koKTtcclxudmFyIElubGluZVF1ZXJ5U3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5saW5lUXVlcnlTdHJhdGVneShlaSkge1xyXG4gICAgICAgIHZhciBwcm90b1JlZnMgPSBlaS5fcHJvdG8ucHJvdG9RdWVyeVJlZnM7XHJcbiAgICAgICAgaWYgKHByb3RvUmVmcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MCA9IG5ldyBRdWVyeVJlZihwcm90b1JlZnNbMF0sIGVpKTtcclxuICAgICAgICBpZiAocHJvdG9SZWZzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkxID0gbmV3IFF1ZXJ5UmVmKHByb3RvUmVmc1sxXSwgZWkpO1xyXG4gICAgICAgIGlmIChwcm90b1JlZnMubGVuZ3RoID4gMilcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTIgPSBuZXcgUXVlcnlSZWYocHJvdG9SZWZzWzJdLCBlaSk7XHJcbiAgICB9XHJcbiAgICBJbmxpbmVRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5zZXRDb250ZW50UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApICYmICF0aGlzLnF1ZXJ5MC5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTAuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkxKSAmJiAhdGhpcy5xdWVyeTEuaXNWaWV3UXVlcnkpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkxLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MikgJiYgIXRoaXMucXVlcnkyLmlzVmlld1F1ZXJ5KVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Mi5kaXJ0eSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuc2V0Vmlld1F1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkwKSAmJiB0aGlzLnF1ZXJ5MC5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTAuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkxKSAmJiB0aGlzLnF1ZXJ5MS5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTEuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSAmJiB0aGlzLnF1ZXJ5Mi5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTIuZGlydHkgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC5oeWRyYXRlKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MS5oeWRyYXRlKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTIpKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Mi5oeWRyYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkwKSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTAuZGVoeWRyYXRlKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MS5kZWh5ZHJhdGUoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MikpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkyLmRlaHlkcmF0ZSgpO1xyXG4gICAgfTtcclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnRRdWVyaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkwKSAmJiAhdGhpcy5xdWVyeTAuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTAudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkxKSAmJiAhdGhpcy5xdWVyeTEuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTEudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSAmJiAhdGhpcy5xdWVyeTIuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTIudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLnVwZGF0ZVZpZXdRdWVyaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkwKSAmJiB0aGlzLnF1ZXJ5MC5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpICYmIHRoaXMucXVlcnkxLmlzVmlld1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkxLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MikgJiYgdGhpcy5xdWVyeTIuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTIudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmZpbmRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkwKSAmJiB0aGlzLnF1ZXJ5MC5wcm90b1F1ZXJ5UmVmLnF1ZXJ5ID09PSBxdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkxKSAmJiB0aGlzLnF1ZXJ5MS5wcm90b1F1ZXJ5UmVmLnF1ZXJ5ID09PSBxdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSAmJiB0aGlzLnF1ZXJ5Mi5wcm90b1F1ZXJ5UmVmLnF1ZXJ5ID09PSBxdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIHF1ZXJ5IGZvciBkaXJlY3RpdmUgXCIgKyBxdWVyeSArIFwiLlwiKTtcclxuICAgIH07XHJcbiAgICBJbmxpbmVRdWVyeVN0cmF0ZWd5Lk5VTUJFUl9PRl9TVVBQT1JURURfUVVFUklFUyA9IDM7XHJcbiAgICByZXR1cm4gSW5saW5lUXVlcnlTdHJhdGVneTtcclxufSkoKTtcclxudmFyIER5bmFtaWNRdWVyeVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIER5bmFtaWNRdWVyeVN0cmF0ZWd5KGVpKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gZWkuX3Byb3RvLnByb3RvUXVlcnlSZWZzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IFF1ZXJ5UmVmKHAsIGVpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuc2V0Q29udGVudFF1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xdWVyaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXEuaXNWaWV3UXVlcnkpXHJcbiAgICAgICAgICAgICAgICBxLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY1F1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLnNldFZpZXdRdWVyaWVzQXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucXVlcmllc1tpXTtcclxuICAgICAgICAgICAgaWYgKHEuaXNWaWV3UXVlcnkpXHJcbiAgICAgICAgICAgICAgICBxLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY1F1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnF1ZXJpZXNbaV07XHJcbiAgICAgICAgICAgIHEuaHlkcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xdWVyaWVzW2ldO1xyXG4gICAgICAgICAgICBxLmRlaHlkcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlQ29udGVudFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnF1ZXJpZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghcS5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlVmlld1F1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnF1ZXJpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChxLmlzVmlld1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBxLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIER5bmFtaWNRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5maW5kUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucXVlcmllc1tpXTtcclxuICAgICAgICAgICAgaWYgKHEucHJvdG9RdWVyeVJlZi5xdWVyeSA9PT0gcXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIHF1ZXJ5IGZvciBkaXJlY3RpdmUgXCIgKyBxdWVyeSArIFwiLlwiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHluYW1pY1F1ZXJ5U3RyYXRlZ3k7XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBTdHJhdGVneSB1c2VkIGJ5IHRoZSBgRWxlbWVudEluamVjdG9yYCB3aGVuIHRoZSBudW1iZXIgb2YgcHJvdmlkZXJzIGlzIDEwIG9yIGxlc3MuXHJcbiAqIEluIHN1Y2ggYSBjYXNlLCBpbmxpbmluZyBmaWVsZHMgaXMgYmVuZWZpY2lhbCBmb3IgcGVyZm9ybWFuY2VzLlxyXG4gKi9cclxudmFyIEVsZW1lbnRJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yU3RyYXRlZ3ksIF9laSkge1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3JTdHJhdGVneSA9IGluamVjdG9yU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5fZWkgPSBfZWk7XHJcbiAgICB9XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGkucHJvdG9TdHJhdGVneTtcclxuICAgICAgICBpLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlcigpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMCBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDApICYmIGkub2JqMCA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqMCA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMCwgcC52aXNpYmlsaXR5MCk7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXIxIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkMSkgJiYgaS5vYmoxID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmoxID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXIxLCBwLnZpc2liaWxpdHkxKTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjIgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQyKSAmJiBpLm9iajIgPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajIgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjIsIHAudmlzaWJpbGl0eTIpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMyBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDMpICYmIGkub2JqMyA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqMyA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMywgcC52aXNpYmlsaXR5Myk7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI0IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkNCkgJiYgaS5vYmo0ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmo0ID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXI0LCBwLnZpc2liaWxpdHk0KTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjUgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQ1KSAmJiBpLm9iajUgPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajUgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjUsIHAudmlzaWJpbGl0eTUpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyNiBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDYpICYmIGkub2JqNiA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqNiA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNiwgcC52aXNpYmlsaXR5Nik7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI3IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkNykgJiYgaS5vYmo3ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmo3ID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXI3LCBwLnZpc2liaWxpdHk3KTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjggaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQ4KSAmJiBpLm9iajggPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajggPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjgsIHAudmlzaWJpbGl0eTgpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyOSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDkpICYmIGkub2JqOSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqOSA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyOSwgcC52aXNpYmlsaXR5OSk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICBpLm9iajAgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajEgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajIgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajMgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajQgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajUgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajYgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajcgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajggPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgICAgICBpLm9iajkgPSBpbmplY3Rvcl8xLlVOREVGSU5FRDtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuY2FsbE9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGkucHJvdG9TdHJhdGVneTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjAgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyMC5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqMC5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXIxIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjEuY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajEub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMiBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXIyLmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmoyLm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjMgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyMy5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqMy5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI0IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjQuY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajQub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyNSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXI1LmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmo1Lm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjYgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyNi5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqNi5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI3IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjcuY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajcub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyOCBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXI4LmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmo4Lm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjkgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyOS5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqOS5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3JTdHJhdGVneS5vYmowOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmlzQ29tcG9uZW50S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9laS5fcHJvdG8uX2ZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCAmJiBsYW5nXzEuaXNQcmVzZW50KGtleSkgJiZcclxuICAgICAgICAgICAga2V5LmlkID09PSB0aGlzLmluamVjdG9yU3RyYXRlZ3kucHJvdG9TdHJhdGVneS5rZXlJZDA7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmFkZERpcmVjdGl2ZXNNYXRjaGluZ1F1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluamVjdG9yU3RyYXRlZ3k7XHJcbiAgICAgICAgdmFyIHAgPSBpLnByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjApICYmIHAucHJvdmlkZXIwLmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqMCA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajAgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjAsIHAudmlzaWJpbGl0eTApO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmowKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjEpICYmIHAucHJvdmlkZXIxLmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqMSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajEgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjEsIHAudmlzaWJpbGl0eTEpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmoxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjIpICYmIHAucHJvdmlkZXIyLmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqMiA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajIgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjIsIHAudmlzaWJpbGl0eTIpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmoyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjMpICYmIHAucHJvdmlkZXIzLmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqMyA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajMgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjMsIHAudmlzaWJpbGl0eTMpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmozKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjQpICYmIHAucHJvdmlkZXI0LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqNCA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajQgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjQsIHAudmlzaWJpbGl0eTQpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjUpICYmIHAucHJvdmlkZXI1LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqNSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajUgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjUsIHAudmlzaWJpbGl0eTUpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo1KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjYpICYmIHAucHJvdmlkZXI2LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqNiA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajYgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjYsIHAudmlzaWJpbGl0eTYpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjcpICYmIHAucHJvdmlkZXI3LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqNyA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajcgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjcsIHAudmlzaWJpbGl0eTcpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjgpICYmIHAucHJvdmlkZXI4LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqOCA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajggPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjgsIHAudmlzaWJpbGl0eTgpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocC5wcm92aWRlcjkpICYmIHAucHJvdmlkZXI5LmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGkub2JqOSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICBpLm9iajkgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjksIHAudmlzaWJpbGl0eTkpO1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goaS5vYmo5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVsZW1lbnRJbmplY3RvcklubGluZVN0cmF0ZWd5O1xyXG59KSgpO1xyXG4vKipcclxuICogU3RyYXRlZ3kgdXNlZCBieSB0aGUgYEVsZW1lbnRJbmplY3RvcmAgd2hlbiB0aGUgbnVtYmVyIG9mIHByb3ZpZGVycyBpcyAxMCBvciBsZXNzLlxyXG4gKiBJbiBzdWNoIGEgY2FzZSwgaW5saW5pbmcgZmllbGRzIGlzIGJlbmVmaWNpYWwgZm9yIHBlcmZvcm1hbmNlcy5cclxuICovXHJcbnZhciBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9yRHluYW1pY1N0cmF0ZWd5KGluamVjdG9yU3RyYXRlZ3ksIF9laSkge1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3JTdHJhdGVneSA9IGluamVjdG9yU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5fZWkgPSBfZWk7XHJcbiAgICB9XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGluai5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGluai5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAua2V5SWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnByb3ZpZGVyc1tpXSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZHNbaV0pICYmXHJcbiAgICAgICAgICAgICAgICBpbmoub2Jqc1tpXSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIGluai5vYmpzW2ldID0gaW5qLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcnNbaV0sIHAudmlzaWJpbGl0aWVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKGluai5vYmpzLCBpbmplY3Rvcl8xLlVOREVGSU5FRCk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5jYWxsT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc3QgPSB0aGlzLmluamVjdG9yU3RyYXRlZ3k7XHJcbiAgICAgICAgdmFyIHAgPSBpc3QucHJvdG9TdHJhdGVneTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAucHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnByb3ZpZGVyc1tpXSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgICAgICBwLnByb3ZpZGVyc1tpXS5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICBpc3Qub2Jqc1tpXS5vbkRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3JTdHJhdGVneS5vYmpzWzBdOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5pc0NvbXBvbmVudEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneS5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9laS5fcHJvdG8uX2ZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCAmJiBsYW5nXzEuaXNQcmVzZW50KGtleSkgJiYga2V5LmlkID09PSBwLmtleUlkc1swXTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmFkZERpcmVjdGl2ZXNNYXRjaGluZ1F1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIGlzdCA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGlzdC5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHAucHJvdmlkZXJzW2ldLmtleS50b2tlbiA9PT0gcXVlcnkuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc3Qub2Jqc1tpXSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc3Qub2Jqc1tpXSA9IGlzdC5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXJzW2ldLCBwLnZpc2liaWxpdGllc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXN0Lm9ianNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbnZhciBQcm90b1F1ZXJ5UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvUXVlcnlSZWYoZGlySW5kZXgsIHNldHRlciwgcXVlcnkpIHtcclxuICAgICAgICB0aGlzLmRpckluZGV4ID0gZGlySW5kZXg7XHJcbiAgICAgICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3RvUXVlcnlSZWYucHJvdG90eXBlLCBcInVzZXNQcm9wZXJ0eVN5bnRheFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuc2V0dGVyKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUHJvdG9RdWVyeVJlZjtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm90b1F1ZXJ5UmVmID0gUHJvdG9RdWVyeVJlZjtcclxudmFyIFF1ZXJ5UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFF1ZXJ5UmVmKHByb3RvUXVlcnlSZWYsIG9yaWdpbmF0b3IpIHtcclxuICAgICAgICB0aGlzLnByb3RvUXVlcnlSZWYgPSBwcm90b1F1ZXJ5UmVmO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYXRvciA9IG9yaWdpbmF0b3I7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlSZWYucHJvdG90eXBlLCBcImlzVmlld1F1ZXJ5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJvdG9RdWVyeVJlZi5xdWVyeS5pc1ZpZXdRdWVyeTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAvLyBUT0RPIGRlbGV0ZSB0aGUgY2hlY2sgb25jZSBvbmx5IGZpZWxkIHF1ZXJpZXMgYXJlIHN1cHBvcnRlZFxyXG4gICAgICAgIGlmICh0aGlzLnByb3RvUXVlcnlSZWYudXNlc1Byb3BlcnR5U3ludGF4KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSB0aGlzLm9yaWdpbmF0b3IuZ2V0RGlyZWN0aXZlQXRJbmRleCh0aGlzLnByb3RvUXVlcnlSZWYuZGlySW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm90b1F1ZXJ5UmVmLnF1ZXJ5LmZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvUXVlcnlSZWYuc2V0dGVyKGRpciwgdGhpcy5saXN0Lmxlbmd0aCA+IDAgPyB0aGlzLmxpc3QuZmlyc3QgOiBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9RdWVyeVJlZi5zZXR0ZXIoZGlyLCB0aGlzLmxpc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdC5ub3RpZnlPbkNoYW5nZXMoKTtcclxuICAgIH07XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWdncmVnYXRvciA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3RvUXVlcnlSZWYucXVlcnkuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLm9yaWdpbmF0b3IuZ2V0VmlldygpO1xyXG4gICAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IHNraXBwaW5nIG9yaWdpbmF0b3IgZm9yIHZpZXcgcXVlcmllcy5cclxuICAgICAgICAgICAgdmFyIG5lc3RlZFZpZXcgPSB2aWV3LmdldE5lc3RlZFZpZXcodmlldy5lbGVtZW50T2Zmc2V0ICsgdGhpcy5vcmlnaW5hdG9yLmdldEJvdW5kRWxlbWVudEluZGV4KCkpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChuZXN0ZWRWaWV3KSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0VmlldyhuZXN0ZWRWaWV3LCBhZ2dyZWdhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0KHRoaXMub3JpZ2luYXRvciwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdC5yZXNldChhZ2dyZWdhdG9yKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuX3Zpc2l0ID0gZnVuY3Rpb24gKGluaiwgYWdncmVnYXRvcikge1xyXG4gICAgICAgIHZhciB2aWV3ID0gaW5qLmdldFZpZXcoKTtcclxuICAgICAgICB2YXIgc3RhcnRJZHggPSB2aWV3LmVsZW1lbnRPZmZzZXQgKyBpbmouX3Byb3RvLmluZGV4O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydElkeDsgaSA8IHZpZXcuZWxlbWVudE9mZnNldCArIHZpZXcub3duQmluZGVyc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGN1ckluaiA9IHZpZXcuZWxlbWVudEluamVjdG9yc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGN1ckluaikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGluamVjdG9yIGFmdGVyIGluaiwgdGhhdCBpcyBvdXRzaWRlIHRoZSBzdWJ0cmVlIHJvb3RlZCBhdFxyXG4gICAgICAgICAgICAvLyBpbmogaGFzIHRvIGhhdmUgYSBudWxsIHBhcmVudCBvciBhIHBhcmVudCB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIGluai5cclxuICAgICAgICAgICAgaWYgKGkgPiBzdGFydElkeCAmJiAobGFuZ18xLmlzQmxhbmsoY3VySW5qKSB8fCBsYW5nXzEuaXNCbGFuayhjdXJJbmoucGFyZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgdmlldy5lbGVtZW50T2Zmc2V0ICsgY3VySW5qLnBhcmVudC5fcHJvdG8uaW5kZXggPCBzdGFydElkeCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm90b1F1ZXJ5UmVmLnF1ZXJ5LmRlc2NlbmRhbnRzICYmXHJcbiAgICAgICAgICAgICAgICAhKGN1ckluai5wYXJlbnQgPT0gdGhpcy5vcmlnaW5hdG9yIHx8IGN1ckluaiA9PSB0aGlzLm9yaWdpbmF0b3IpKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIC8vIFdlIHZpc2l0IHRoZSB2aWV3IGNvbnRhaW5lcihWQykgdmlld3MgcmlnaHQgYWZ0ZXIgdGhlIGluamVjdG9yIHRoYXQgY29udGFpbnNcclxuICAgICAgICAgICAgLy8gdGhlIFZDLiBUaGVvcmV0aWNhbGx5LCB0aGF0IG1pZ2h0IG5vdCBiZSB0aGUgcmlnaHQgb3JkZXIgaWYgdGhlcmUgYXJlXHJcbiAgICAgICAgICAgIC8vIGNoaWxkIGluamVjdG9ycyBvZiBzYWlkIGluamVjdG9yLiBOb3QgY2xlYXIgd2hldGhlciBpZiBzdWNoIGNhc2UgY2FuXHJcbiAgICAgICAgICAgIC8vIGV2ZW4gYmUgY29uc3RydWN0ZWQgd2l0aCB0aGUgY3VycmVudCBhcGlzLlxyXG4gICAgICAgICAgICB0aGlzLl92aXNpdEluamVjdG9yKGN1ckluaiwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgICAgIHZhciB2YyA9IHZpZXcudmlld0NvbnRhaW5lcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZjKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0Vmlld0NvbnRhaW5lcih2YywgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fdmlzaXRJbmplY3RvciA9IGZ1bmN0aW9uIChpbmosIGFnZ3JlZ2F0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm90b1F1ZXJ5UmVmLnF1ZXJ5LmlzVmFyQmluZGluZ1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FnZ3JlZ2F0ZVZhcmlhYmxlQmluZGluZyhpbmosIGFnZ3JlZ2F0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYWdncmVnYXRlRGlyZWN0aXZlKGluaiwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fdmlzaXRWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24gKHZjLCBhZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2Yy52aWV3cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdFZpZXcodmMudmlld3Nbal0sIGFnZ3JlZ2F0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuX3Zpc2l0VmlldyA9IGZ1bmN0aW9uICh2aWV3LCBhZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHZpZXcuZWxlbWVudE9mZnNldDsgaSA8IHZpZXcuZWxlbWVudE9mZnNldCArIHZpZXcub3duQmluZGVyc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGluaiA9IHZpZXcuZWxlbWVudEluamVjdG9yc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGluaikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRJbmplY3RvcihpbmosIGFnZ3JlZ2F0b3IpO1xyXG4gICAgICAgICAgICB2YXIgdmMgPSB2aWV3LnZpZXdDb250YWluZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2YykpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpdFZpZXdDb250YWluZXIodmMsIGFnZ3JlZ2F0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuX2FnZ3JlZ2F0ZVZhcmlhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChpbmosIGFnZ3JlZ2F0b3IpIHtcclxuICAgICAgICB2YXIgdmIgPSB0aGlzLnByb3RvUXVlcnlSZWYucXVlcnkudmFyQmluZGluZ3M7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Yi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaW5qLmhhc1ZhcmlhYmxlQmluZGluZyh2YltpXSkpIHtcclxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0b3IucHVzaChpbmouZ2V0VmFyaWFibGVCaW5kaW5nKHZiW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUXVlcnlSZWYucHJvdG90eXBlLl9hZ2dyZWdhdGVEaXJlY3RpdmUgPSBmdW5jdGlvbiAoaW5qLCBhZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgaW5qLmFkZERpcmVjdGl2ZXNNYXRjaGluZ1F1ZXJ5KHRoaXMucHJvdG9RdWVyeVJlZi5xdWVyeSwgYWdncmVnYXRvcik7XHJcbiAgICB9O1xyXG4gICAgUXVlcnlSZWYucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5saXN0ID0gbnVsbDsgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5oeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBxdWVyeV9saXN0XzEuUXVlcnlMaXN0KCk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFF1ZXJ5UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlF1ZXJ5UmVmID0gUXVlcnlSZWY7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfaW5qZWN0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgVmlldyB0aGF0IGhhcyBhbiBpbmplY3Rpb24sIGNoYW5nZS1kZXRlY3Rpb24gYW5kIHJlbmRlciBjb250ZXh0XHJcbiAqIGFzc29jaWF0ZWQgd2l0aCBpdC5cclxuICpcclxuICogQW4gYEVsZW1lbnRSZWZgIGlzIGNyZWF0ZWQgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgVGVtcGxhdGUgdGhhdCBjb250YWlucyBhIERpcmVjdGl2ZSwgQ29tcG9uZW50XHJcbiAqIG9yIGRhdGEtYmluZGluZy5cclxuICpcclxuICogQW4gYEVsZW1lbnRSZWZgIGlzIGJhY2tlZCBieSBhIHJlbmRlci1zcGVjaWZpYyBlbGVtZW50LiBJbiB0aGUgYnJvd3NlciwgdGhpcyBpcyB1c3VhbGx5IGEgRE9NXHJcbiAqIGVsZW1lbnQuXHJcbiAqL1xyXG52YXIgRWxlbWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50UmVmKCkge1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnRSZWYucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBlbGVtZW50IG9yIGBudWxsYCBpZiBkaXJlY3QgYWNjZXNzIHRvIG5hdGl2ZSBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICogKGUuZy4gd2hlbiB0aGUgYXBwbGljYXRpb24gcnVucyBpbiBhIHdlYiB3b3JrZXIpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogPGRpdiBjbGFzcz1cImNhbGxvdXQgaXMtY3JpdGljYWxcIj5cclxuICAgICAgICAgKiAgIDxoZWFkZXI+VXNlIHdpdGggY2F1dGlvbjwvaGVhZGVyPlxyXG4gICAgICAgICAqICAgPHA+XHJcbiAgICAgICAgICogICAgVXNlIHRoaXMgQVBJIGFzIHRoZSBsYXN0IHJlc29ydCB3aGVuIGRpcmVjdCBhY2Nlc3MgdG8gRE9NIGlzIG5lZWRlZC4gVXNlIHRlbXBsYXRpbmcgYW5kXHJcbiAgICAgICAgICogICAgZGF0YS1iaW5kaW5nIHByb3ZpZGVkIGJ5IEFuZ3VsYXIgaW5zdGVhZC4gQWx0ZXJuYXRpdmVseSB5b3UgdGFrZSBhIGxvb2sgYXQge0BsaW5rIFJlbmRlcmVyfVxyXG4gICAgICAgICAqICAgIHdoaWNoIHByb3ZpZGVzIEFQSSB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBldmVuIHdoZW4gZGlyZWN0IGFjY2VzcyB0byBuYXRpdmUgZWxlbWVudHMgaXMgbm90XHJcbiAgICAgICAgICogICAgc3VwcG9ydGVkLlxyXG4gICAgICAgICAqICAgPC9wPlxyXG4gICAgICAgICAqICAgPHA+XHJcbiAgICAgICAgICogICAgUmVseWluZyBvbiBkaXJlY3QgRE9NIGFjY2VzcyBjcmVhdGVzIHRpZ2h0IGNvdXBsaW5nIGJldHdlZW4geW91ciBhcHBsaWNhdGlvbiBhbmQgcmVuZGVyaW5nXHJcbiAgICAgICAgICogICAgbGF5ZXJzIHdoaWNoIHdpbGwgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIHNlcGFyYXRlIHRoZSB0d28gYW5kIGRlcGxveSB5b3VyIGFwcGxpY2F0aW9uIGludG8gYVxyXG4gICAgICAgICAqICAgIHdlYiB3b3JrZXIuXHJcbiAgICAgICAgICogICA8L3A+XHJcbiAgICAgICAgICogPC9kaXY+XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50UmVmLnByb3RvdHlwZSwgXCJyZW5kZXJWaWV3XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEVsZW1lbnRSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRWxlbWVudFJlZiA9IEVsZW1lbnRSZWY7XHJcbnZhciBFbGVtZW50UmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRWxlbWVudFJlZl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50UmVmXyhwYXJlbnRWaWV3LCBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIHtAbGluayBWaWV3UmVmfS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBBbmd1bGFyIGZyYW1ld29yayB0byBsb2NhdGUgZWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYm91bmRFbGVtZW50SW5kZXgsIF9yZW5kZXJlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucGFyZW50VmlldyA9IHBhcmVudFZpZXc7XHJcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRJbmRleCA9IGJvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnRSZWZfLnByb3RvdHlwZSwgXCJyZW5kZXJWaWV3XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5yZW5kZXI7IH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudFJlZl8ucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0TmF0aXZlRWxlbWVudFN5bmModGhpcyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEVsZW1lbnRSZWZfO1xyXG59KShFbGVtZW50UmVmKTtcclxuZXhwb3J0cy5FbGVtZW50UmVmXyA9IEVsZW1lbnRSZWZfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmV4cG9ydHMuRVZFTlRfVEFSR0VUX1NFUEFSQVRPUiA9ICc6JztcclxudmFyIEV2ZW50Q29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50Q29uZmlnKGZpZWxkTmFtZSwgZXZlbnROYW1lLCBpc0xvbmdGb3JtKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZE5hbWUgPSBmaWVsZE5hbWU7XHJcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XHJcbiAgICAgICAgdGhpcy5pc0xvbmdGb3JtID0gaXNMb25nRm9ybTtcclxuICAgIH1cclxuICAgIEV2ZW50Q29uZmlnLnBhcnNlID0gZnVuY3Rpb24gKGV2ZW50Q29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGV2ZW50Q29uZmlnLCBldmVudE5hbWUgPSBldmVudENvbmZpZywgaXNMb25nRm9ybSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzZXBhcmF0b3JJZHggPSBldmVudENvbmZpZy5pbmRleE9mKGV4cG9ydHMuRVZFTlRfVEFSR0VUX1NFUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKHNlcGFyYXRvcklkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGxvbmcgZm9ybWF0OiAnZmllbGROYW1lOiBldmVudE5hbWUnXHJcbiAgICAgICAgICAgIGZpZWxkTmFtZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN1YnN0cmluZyhldmVudENvbmZpZywgMCwgc2VwYXJhdG9ySWR4KS50cmltKCk7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN1YnN0cmluZyhldmVudENvbmZpZywgc2VwYXJhdG9ySWR4ICsgMSkudHJpbSgpO1xyXG4gICAgICAgICAgICBpc0xvbmdGb3JtID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudENvbmZpZyhmaWVsZE5hbWUsIGV2ZW50TmFtZSwgaXNMb25nRm9ybSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRDb25maWcucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTG9uZ0Zvcm0gPyBcIlwiICsgdGhpcy5maWVsZE5hbWUgKyBleHBvcnRzLkVWRU5UX1RBUkdFVF9TRVBBUkFUT1IgKyB0aGlzLmV2ZW50TmFtZSA6XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnROYW1lO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudENvbmZpZztcclxufSkoKTtcclxuZXhwb3J0cy5FdmVudENvbmZpZyA9IEV2ZW50Q29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9jb25maWcuanMubWFwIiwiJ3VzZSBzdHJpY3QnOyhmdW5jdGlvbiAoTGlmZWN5Y2xlSG9va3MpIHtcclxuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25Jbml0XCJdID0gMF0gPSBcIk9uSW5pdFwiO1xyXG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkRlc3Ryb3lcIl0gPSAxXSA9IFwiT25EZXN0cm95XCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkRvQ2hlY2tcIl0gPSAyXSA9IFwiRG9DaGVja1wiO1xyXG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkNoYW5nZXNcIl0gPSAzXSA9IFwiT25DaGFuZ2VzXCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudEluaXRcIl0gPSA0XSA9IFwiQWZ0ZXJDb250ZW50SW5pdFwiO1xyXG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRDaGVja2VkXCJdID0gNV0gPSBcIkFmdGVyQ29udGVudENoZWNrZWRcIjtcclxuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3SW5pdFwiXSA9IDZdID0gXCJBZnRlclZpZXdJbml0XCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0NoZWNrZWRcIl0gPSA3XSA9IFwiQWZ0ZXJWaWV3Q2hlY2tlZFwiO1xyXG59KShleHBvcnRzLkxpZmVjeWNsZUhvb2tzIHx8IChleHBvcnRzLkxpZmVjeWNsZUhvb2tzID0ge30pKTtcclxudmFyIExpZmVjeWNsZUhvb2tzID0gZXhwb3J0cy5MaWZlY3ljbGVIb29rcztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0cy5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gW1xyXG4gICAgTGlmZWN5Y2xlSG9va3MuT25Jbml0LFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95LFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuRG9DaGVjayxcclxuICAgIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcyxcclxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQsXHJcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCxcclxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWRcclxuXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG4vKipcclxuICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige0BsaW5rIFBpcGVNZXRhZGF0YX0uXHJcbiAqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cclxuICpcclxuICogU2VlIHtAbGluayBDb21waWxlcn1cclxuICovXHJcbnZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4ge0BsaW5rIFBpcGVNZXRhZGF0YX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxyXG4gICAgICovXHJcbiAgICBQaXBlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBtZXRhcyA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuYW5ub3RhdGlvbnMoZGlfMS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWV0YXMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gbWV0YXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuUGlwZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gUGlwZSBkZWNvcmF0b3IgZm91bmQgb24gXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpKTtcclxuICAgIH07XHJcbiAgICBQaXBlUmVzb2x2ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFBpcGVSZXNvbHZlcik7XHJcbiAgICByZXR1cm4gUGlwZVJlc29sdmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlBpcGVSZXNvbHZlciA9IFBpcGVSZXNvbHZlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZV9yZXNvbHZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIHBpcGVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoJy4uL3BpcGVzL3BpcGVfcHJvdmlkZXInKTtcclxudmFyIHBpcGVzXzEgPSByZXF1aXJlKCcuLi9waXBlcy9waXBlcycpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZSgnLi92aWV3Jyk7XHJcbnZhciBlbGVtZW50X2JpbmRlcl8xID0gcmVxdWlyZSgnLi9lbGVtZW50X2JpbmRlcicpO1xyXG52YXIgZWxlbWVudF9pbmplY3Rvcl8xID0gcmVxdWlyZSgnLi9lbGVtZW50X2luamVjdG9yJyk7XHJcbnZhciBkaXJlY3RpdmVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX3Jlc29sdmVyJyk7XHJcbnZhciB2aWV3X3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVzb2x2ZXInKTtcclxudmFyIHBpcGVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vcGlwZV9yZXNvbHZlcicpO1xyXG52YXIgcGlwZXNfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzJyk7XHJcbnZhciB0ZW1wbGF0ZV9jb21tYW5kc18xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9jb21tYW5kcycpO1xyXG52YXIgcmVuZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9yZW5kZXInKTtcclxudmFyIGFwcGxpY2F0aW9uX3Rva2Vuc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvYXBwbGljYXRpb25fdG9rZW5zJyk7XHJcbnZhciBQcm90b1ZpZXdGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvVmlld0ZhY3RvcnkoX3JlbmRlcmVyLCBkZWZhdWx0UGlwZXMsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3ZpZXdSZXNvbHZlciwgX3BpcGVSZXNvbHZlciwgYXBwSWQpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLl92aWV3UmVzb2x2ZXIgPSBfdmlld1Jlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFBpcGVzID0gZGVmYXVsdFBpcGVzO1xyXG4gICAgICAgIHRoaXMuX2FwcElkID0gYXBwSWQ7XHJcbiAgICB9XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jYWNoZS5jbGVhcigpOyB9O1xyXG4gICAgUHJvdG9WaWV3RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlSG9zdCA9IGZ1bmN0aW9uIChjb21waWxlZEhvc3RUZW1wbGF0ZSkge1xyXG4gICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gY29tcGlsZWRIb3N0VGVtcGxhdGUuZ2V0VGVtcGxhdGUoKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY2FjaGUuZ2V0KGNvbXBpbGVkVGVtcGxhdGUuaWQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURhdGEgPSBjb21waWxlZFRlbXBsYXRlLmdldERhdGEodGhpcy5fYXBwSWQpO1xyXG4gICAgICAgICAgICB2YXIgZW1wdHlNYXAgPSB7fTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHZpZXdfMS5BcHBQcm90b1ZpZXcodGVtcGxhdGVEYXRhLmNvbW1hbmRzLCB2aWV3XzEuVmlld1R5cGUuSE9TVCwgdHJ1ZSwgdGVtcGxhdGVEYXRhLmNoYW5nZURldGVjdG9yRmFjdG9yeSwgbnVsbCwgbmV3IHBpcGVzXzEuUHJvdG9QaXBlcyhlbXB0eU1hcCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoY29tcGlsZWRUZW1wbGF0ZS5pZCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5fY3JlYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNtZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5lc3RlZFByb3RvVmlldyA9IHRoaXMuX2NhY2hlLmdldChjbWQudGVtcGxhdGVJZCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG5lc3RlZFByb3RvVmlldykpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNtZC5kaXJlY3RpdmVzWzBdO1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlRGF0YSA9IGNtZC50ZW1wbGF0ZS5nZXREYXRhKHRoaXMuX2FwcElkKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVnaXN0ZXJDb21wb25lbnRUZW1wbGF0ZShjbWQudGVtcGxhdGVJZCwgY29tcGlsZWRUZW1wbGF0ZURhdGEuY29tbWFuZHMsIGNvbXBpbGVkVGVtcGxhdGVEYXRhLnN0eWxlcywgY21kLm5hdGl2ZVNoYWRvdyk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZFBpcGVzID0gdGhpcy5fZmxhdHRlblBpcGVzKHZpZXcpLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX2JpbmRQaXBlKHBpcGUpOyB9KTtcclxuICAgICAgICAgICAgbmVzdGVkUHJvdG9WaWV3ID0gbmV3IHZpZXdfMS5BcHBQcm90b1ZpZXcoY29tcGlsZWRUZW1wbGF0ZURhdGEuY29tbWFuZHMsIHZpZXdfMS5WaWV3VHlwZS5DT01QT05FTlQsIHRydWUsIGNvbXBpbGVkVGVtcGxhdGVEYXRhLmNoYW5nZURldGVjdG9yRmFjdG9yeSwgbnVsbCwgcGlwZXNfMS5Qcm90b1BpcGVzLmZyb21Qcm92aWRlcnMoYm91bmRQaXBlcykpO1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgY2FjaGUgaXMgdXBkYXRlZCBiZWZvcmUgcmVjdXJzaW5nXHJcbiAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gcmVzb2x2ZSBjeWNsZXNcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGNtZC50ZW1wbGF0ZS5pZCwgbmVzdGVkUHJvdG9WaWV3KTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvVmlldyhuZXN0ZWRQcm90b1ZpZXcsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmVzdGVkUHJvdG9WaWV3O1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLl9jcmVhdGVFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNtZCwgcGFyZW50KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFByb3RvVmlldyA9IG5ldyB2aWV3XzEuQXBwUHJvdG9WaWV3KGNtZC5jaGlsZHJlbiwgdmlld18xLlZpZXdUeXBlLkVNQkVEREVELCBjbWQuaXNNZXJnZWQsIGNtZC5jaGFuZ2VEZXRlY3RvckZhY3RvcnksIGFycmF5VG9NYXAoY21kLnZhcmlhYmxlTmFtZUFuZFZhbHVlcywgdHJ1ZSksIG5ldyBwaXBlc18xLlByb3RvUGlwZXMocGFyZW50LnBpcGVzLmNvbmZpZykpO1xyXG4gICAgICAgIGlmIChjbWQuaXNNZXJnZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplUHJvdG9WaWV3SWZOZWVkZWQobmVzdGVkUHJvdG9WaWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5lc3RlZFByb3RvVmlldztcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5pbml0aWFsaXplUHJvdG9WaWV3SWZOZWVkZWQgPSBmdW5jdGlvbiAocHJvdG9WaWV3KSB7XHJcbiAgICAgICAgaWYgKCFwcm90b1ZpZXcuaXNJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSB0aGlzLl9yZW5kZXJlci5jcmVhdGVQcm90b1ZpZXcocHJvdG9WaWV3LnRlbXBsYXRlQ21kcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm90b1ZpZXcocHJvdG9WaWV3LCByZW5kZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5faW5pdGlhbGl6ZVByb3RvVmlldyA9IGZ1bmN0aW9uIChwcm90b1ZpZXcsIHJlbmRlcikge1xyXG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIocHJvdG9WaWV3LCB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciwgdGhpcyk7XHJcbiAgICAgICAgdGVtcGxhdGVfY29tbWFuZHNfMS52aXNpdEFsbENvbW1hbmRzKGluaXRpYWxpemVyLCBwcm90b1ZpZXcudGVtcGxhdGVDbWRzKTtcclxuICAgICAgICB2YXIgbWVyZ2VJbmZvID0gbmV3IHZpZXdfMS5BcHBQcm90b1ZpZXdNZXJnZUluZm8oaW5pdGlhbGl6ZXIubWVyZ2VFbWJlZGRlZFZpZXdDb3VudCwgaW5pdGlhbGl6ZXIubWVyZ2VFbGVtZW50Q291bnQsIGluaXRpYWxpemVyLm1lcmdlVmlld0NvdW50KTtcclxuICAgICAgICBwcm90b1ZpZXcuaW5pdChyZW5kZXIsIGluaXRpYWxpemVyLmVsZW1lbnRCaW5kZXJzLCBpbml0aWFsaXplci5ib3VuZFRleHRDb3VudCwgbWVyZ2VJbmZvLCBpbml0aWFsaXplci52YXJpYWJsZUxvY2F0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3RmFjdG9yeS5wcm90b3R5cGUuX2JpbmRQaXBlID0gZnVuY3Rpb24gKHR5cGVPclByb3ZpZGVyKSB7XHJcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9waXBlUmVzb2x2ZXIucmVzb2x2ZSh0eXBlT3JQcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHBpcGVfcHJvdmlkZXJfMS5QaXBlUHJvdmlkZXIuY3JlYXRlRnJvbVR5cGUodHlwZU9yUHJvdmlkZXIsIG1ldGEpO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLl9mbGF0dGVuUGlwZXMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3LnBpcGVzKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQaXBlcztcclxuICAgICAgICB2YXIgcGlwZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY2xvbmUodGhpcy5fZGVmYXVsdFBpcGVzKTtcclxuICAgICAgICBfZmxhdHRlbkxpc3Qodmlldy5waXBlcywgcGlwZXMpO1xyXG4gICAgICAgIHJldHVybiBwaXBlcztcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLkluamVjdChwaXBlc18yLkRFRkFVTFRfUElQRVNfVE9LRU4pKSxcclxuICAgICAgICBfX3BhcmFtKDUsIGRpXzEuSW5qZWN0KGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JRCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtyZW5kZXJfMS5SZW5kZXJlciwgQXJyYXksIGRpcmVjdGl2ZV9yZXNvbHZlcl8xLkRpcmVjdGl2ZVJlc29sdmVyLCB2aWV3X3Jlc29sdmVyXzEuVmlld1Jlc29sdmVyLCBwaXBlX3Jlc29sdmVyXzEuUGlwZVJlc29sdmVyLCBTdHJpbmddKVxyXG4gICAgXSwgUHJvdG9WaWV3RmFjdG9yeSk7XHJcbiAgICByZXR1cm4gUHJvdG9WaWV3RmFjdG9yeTtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm90b1ZpZXdGYWN0b3J5ID0gUHJvdG9WaWV3RmFjdG9yeTtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHByb3RvVmlld0ZhY3RvcnksIGNtZCkge1xyXG4gICAgcmV0dXJuIHByb3RvVmlld0ZhY3RvcnkuX2NyZWF0ZUNvbXBvbmVudChjbWQpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGVkVGVtcGxhdGUocHJvdG9WaWV3RmFjdG9yeSwgY21kLCBwYXJlbnQpIHtcclxuICAgIHJldHVybiBwcm90b1ZpZXdGYWN0b3J5Ll9jcmVhdGVFbWJlZGRlZFRlbXBsYXRlKGNtZCwgcGFyZW50KTtcclxufVxyXG52YXIgX1Byb3RvVmlld0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9Qcm90b1ZpZXdJbml0aWFsaXplcihfcHJvdG9WaWV3LCBfZGlyZWN0aXZlUmVzb2x2ZXIsIF9wcm90b1ZpZXdGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9WaWV3ID0gX3Byb3RvVmlldztcclxuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5ID0gX3Byb3RvVmlld0ZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZUxvY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmJvdW5kVGV4dENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJTdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudEVsZW1lbnRCaW5kZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudFByb3RvRWxlbWVudEluamVjdG9yID0gMDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5tZXJnZUVtYmVkZGVkVmlld0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1lcmdlRWxlbWVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1lcmdlVmlld0NvdW50ID0gMTtcclxuICAgIH1cclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChjbWQuaXNCb3VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kVGV4dENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgX1Byb3RvVmlld0luaXRpYWxpemVyLnByb3RvdHlwZS52aXNpdEJlZ2luRWxlbWVudCA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoY21kLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRCZWdpbkJvdW5kRWxlbWVudChjbWQsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRCZWdpbkVsZW1lbnQoY21kLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgX1Byb3RvVmlld0luaXRpYWxpemVyLnByb3RvdHlwZS52aXNpdEVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gdGhpcy5fdmlzaXRFbmRFbGVtZW50KCk7IH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLnZpc2l0QmVnaW5Db21wb25lbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFByb3RvVmlldyA9IGNyZWF0ZUNvbXBvbmVudCh0aGlzLl9wcm90b1ZpZXdGYWN0b3J5LCBjbWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEJlZ2luQm91bmRFbGVtZW50KGNtZCwgbmVzdGVkUHJvdG9WaWV3KTtcclxuICAgIH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLnZpc2l0RW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHRoaXMuX3Zpc2l0RW5kRWxlbWVudCgpOyB9O1xyXG4gICAgX1Byb3RvVmlld0luaXRpYWxpemVyLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFByb3RvVmlldyA9IGNyZWF0ZUVtYmVkZGVkVGVtcGxhdGUodGhpcy5fcHJvdG9WaWV3RmFjdG9yeSwgY21kLCB0aGlzLl9wcm90b1ZpZXcpO1xyXG4gICAgICAgIGlmIChjbWQuaXNNZXJnZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tZXJnZUVtYmVkZGVkVmlld0NvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Zpc2l0QmVnaW5Cb3VuZEVsZW1lbnQoY21kLCBuZXN0ZWRQcm90b1ZpZXcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEVuZEVsZW1lbnQoKTtcclxuICAgIH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLl92aXNpdEJlZ2luQm91bmRFbGVtZW50ID0gZnVuY3Rpb24gKGNtZCwgbmVzdGVkUHJvdG9WaWV3KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobmVzdGVkUHJvdG9WaWV3KSAmJiBuZXN0ZWRQcm90b1ZpZXcuaXNNZXJnYWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlRWxlbWVudENvdW50ICs9IG5lc3RlZFByb3RvVmlldy5tZXJnZUluZm8uZWxlbWVudENvdW50O1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlVmlld0NvdW50ICs9IG5lc3RlZFByb3RvVmlldy5tZXJnZUluZm8udmlld0NvdW50O1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlRW1iZWRkZWRWaWV3Q291bnQgKz0gbmVzdGVkUHJvdG9WaWV3Lm1lcmdlSW5mby5lbWJlZGRlZFZpZXdDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsZW1lbnRCaW5kZXIgPSBfY3JlYXRlRWxlbWVudEJpbmRlcih0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciwgbmVzdGVkUHJvdG9WaWV3LCB0aGlzLmVsZW1lbnRCaW5kZXJTdGFjaywgdGhpcy5ib3VuZEVsZW1lbnRJbmRleCwgdGhpcy5kaXN0YW5jZVRvUGFyZW50RWxlbWVudEJpbmRlciwgdGhpcy5kaXN0YW5jZVRvUGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IsIGNtZCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50QmluZGVycy5wdXNoKGVsZW1lbnRCaW5kZXIpO1xyXG4gICAgICAgIHZhciBwcm90b0VsZW1lbnRJbmplY3RvciA9IGVsZW1lbnRCaW5kZXIucHJvdG9FbGVtZW50SW5qZWN0b3I7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbWQudmFyaWFibGVOYW1lQW5kVmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVMb2NhdGlvbnMuc2V0KGNtZC52YXJpYWJsZU5hbWVBbmRWYWx1ZXNbaV0sIHRoaXMuYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudEluZGV4Kys7XHJcbiAgICAgICAgdGhpcy5tZXJnZUVsZW1lbnRDb3VudCsrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEJlZ2luRWxlbWVudChjbWQsIGVsZW1lbnRCaW5kZXIsIHByb3RvRWxlbWVudEluamVjdG9yKTtcclxuICAgIH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLl92aXNpdEJlZ2luRWxlbWVudCA9IGZ1bmN0aW9uIChjbWQsIGVsZW1lbnRCaW5kZXIsIHByb3RvRWxlbWVudEluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50RWxlbWVudEJpbmRlciA9XHJcbiAgICAgICAgICAgIGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudEJpbmRlcikgPyAxIDogdGhpcy5kaXN0YW5jZVRvUGFyZW50RWxlbWVudEJpbmRlciArIDE7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IgPVxyXG4gICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KHByb3RvRWxlbWVudEluamVjdG9yKSA/IDEgOiB0aGlzLmRpc3RhbmNlVG9QYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciArIDE7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50QmluZGVyU3RhY2sucHVzaChlbGVtZW50QmluZGVyKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLl92aXNpdEVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRCaW5kZXIgPSB0aGlzLmVsZW1lbnRCaW5kZXJTdGFjay5wb3AoKTtcclxuICAgICAgICB2YXIgcGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IgPSBsYW5nXzEuaXNQcmVzZW50KHBhcmVudEVsZW1lbnRCaW5kZXIpID8gcGFyZW50RWxlbWVudEJpbmRlci5wcm90b0VsZW1lbnRJbmplY3RvciA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50RWxlbWVudEJpbmRlciA9IGxhbmdfMS5pc1ByZXNlbnQocGFyZW50RWxlbWVudEJpbmRlcikgP1xyXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50QmluZGVyLmRpc3RhbmNlVG9QYXJlbnQgOlxyXG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnRFbGVtZW50QmluZGVyIC0gMTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQocGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IpID9cclxuICAgICAgICAgICAgcGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IuZGlzdGFuY2VUb1BhcmVudCA6XHJcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudFByb3RvRWxlbWVudEluamVjdG9yIC0gMTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX1Byb3RvVmlld0luaXRpYWxpemVyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudEJpbmRlcihkaXJlY3RpdmVSZXNvbHZlciwgbmVzdGVkUHJvdG9WaWV3LCBlbGVtZW50QmluZGVyU3RhY2ssIGJvdW5kRWxlbWVudEluZGV4LCBkaXN0YW5jZVRvUGFyZW50QmluZGVyLCBkaXN0YW5jZVRvUGFyZW50UGVpLCBiZWdpbkVsZW1lbnRDbWQpIHtcclxuICAgIHZhciBwYXJlbnRFbGVtZW50QmluZGVyID0gbnVsbDtcclxuICAgIHZhciBwYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciA9IG51bGw7XHJcbiAgICBpZiAoZGlzdGFuY2VUb1BhcmVudEJpbmRlciA+IDApIHtcclxuICAgICAgICBwYXJlbnRFbGVtZW50QmluZGVyID0gZWxlbWVudEJpbmRlclN0YWNrW2VsZW1lbnRCaW5kZXJTdGFjay5sZW5ndGggLSBkaXN0YW5jZVRvUGFyZW50QmluZGVyXTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJlbnRFbGVtZW50QmluZGVyKSkge1xyXG4gICAgICAgIGRpc3RhbmNlVG9QYXJlbnRCaW5kZXIgPSAtMTtcclxuICAgIH1cclxuICAgIGlmIChkaXN0YW5jZVRvUGFyZW50UGVpID4gMCkge1xyXG4gICAgICAgIHZhciBwZWlCaW5kZXIgPSBlbGVtZW50QmluZGVyU3RhY2tbZWxlbWVudEJpbmRlclN0YWNrLmxlbmd0aCAtIGRpc3RhbmNlVG9QYXJlbnRQZWldO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBlaUJpbmRlcikpIHtcclxuICAgICAgICAgICAgcGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IgPSBwZWlCaW5kZXIucHJvdG9FbGVtZW50SW5qZWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmVudFByb3RvRWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgIGRpc3RhbmNlVG9QYXJlbnRQZWkgPSAtMTtcclxuICAgIH1cclxuICAgIHZhciBjb21wb25lbnREaXJlY3RpdmVQcm92aWRlciA9IG51bGw7XHJcbiAgICB2YXIgaXNFbWJlZGRlZFRlbXBsYXRlID0gZmFsc2U7XHJcbiAgICB2YXIgZGlyZWN0aXZlUHJvdmlkZXJzID0gYmVnaW5FbGVtZW50Q21kLmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBwcm92aWRlRGlyZWN0aXZlKGRpcmVjdGl2ZVJlc29sdmVyLCB0eXBlKTsgfSk7XHJcbiAgICBpZiAoYmVnaW5FbGVtZW50Q21kIGluc3RhbmNlb2YgdGVtcGxhdGVfY29tbWFuZHNfMS5CZWdpbkNvbXBvbmVudENtZCkge1xyXG4gICAgICAgIGNvbXBvbmVudERpcmVjdGl2ZVByb3ZpZGVyID0gZGlyZWN0aXZlUHJvdmlkZXJzWzBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmVnaW5FbGVtZW50Q21kIGluc3RhbmNlb2YgdGVtcGxhdGVfY29tbWFuZHNfMS5FbWJlZGRlZFRlbXBsYXRlQ21kKSB7XHJcbiAgICAgICAgaXNFbWJlZGRlZFRlbXBsYXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHZhciBwcm90b0VsZW1lbnRJbmplY3RvciA9IG51bGw7XHJcbiAgICAvLyBDcmVhdGUgYSBwcm90b0VsZW1lbnRJbmplY3RvciBmb3IgYW55IGVsZW1lbnQgdGhhdCBlaXRoZXIgaGFzIGJpbmRpbmdzICpvciogaGFzIG9uZVxyXG4gICAgLy8gb3IgbW9yZSB2YXItIGRlZmluZWQgKm9yKiBmb3IgPHRlbXBsYXRlPiBlbGVtZW50czpcclxuICAgIC8vIC0gRWxlbWVudHMgd2l0aCBhIHZhci0gZGVmaW5lZCBuZWVkIGEgdGhlaXIgb3duIGVsZW1lbnQgaW5qZWN0b3JcclxuICAgIC8vICAgc28gdGhhdCwgd2hlbiBoeWRyYXRpbmcsICRpbXBsaWNpdCBjYW4gYmUgc2V0IHRvIHRoZSBlbGVtZW50LlxyXG4gICAgLy8gLSA8dGVtcGxhdGU+IGVsZW1lbnRzIG5lZWQgdGhlaXIgb3duIEVsZW1lbnRJbmplY3RvciBzbyB0aGF0IHdlIGNhbiBxdWVyeSB0aGVpciBUZW1wbGF0ZVJlZlxyXG4gICAgdmFyIGhhc1ZhcmlhYmxlcyA9IGJlZ2luRWxlbWVudENtZC52YXJpYWJsZU5hbWVBbmRWYWx1ZXMubGVuZ3RoID4gMDtcclxuICAgIGlmIChkaXJlY3RpdmVQcm92aWRlcnMubGVuZ3RoID4gMCB8fCBoYXNWYXJpYWJsZXMgfHwgaXNFbWJlZGRlZFRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKCFpc0VtYmVkZGVkVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyA9IGNyZWF0ZURpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MoYmVnaW5FbGVtZW50Q21kLnZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlUHJvdmlkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdG9FbGVtZW50SW5qZWN0b3IgPSBlbGVtZW50X2luamVjdG9yXzEuUHJvdG9FbGVtZW50SW5qZWN0b3IuY3JlYXRlKHBhcmVudFByb3RvRWxlbWVudEluamVjdG9yLCBib3VuZEVsZW1lbnRJbmRleCwgZGlyZWN0aXZlUHJvdmlkZXJzLCBsYW5nXzEuaXNQcmVzZW50KGNvbXBvbmVudERpcmVjdGl2ZVByb3ZpZGVyKSwgZGlzdGFuY2VUb1BhcmVudFBlaSwgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyk7XHJcbiAgICAgICAgcHJvdG9FbGVtZW50SW5qZWN0b3IuYXR0cmlidXRlcyA9IGFycmF5VG9NYXAoYmVnaW5FbGVtZW50Q21kLmF0dHJOYW1lQW5kVmFsdWVzLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IGVsZW1lbnRfYmluZGVyXzEuRWxlbWVudEJpbmRlcihib3VuZEVsZW1lbnRJbmRleCwgcGFyZW50RWxlbWVudEJpbmRlciwgZGlzdGFuY2VUb1BhcmVudEJpbmRlciwgcHJvdG9FbGVtZW50SW5qZWN0b3IsIGNvbXBvbmVudERpcmVjdGl2ZVByb3ZpZGVyLCBuZXN0ZWRQcm90b1ZpZXcpO1xyXG59XHJcbmZ1bmN0aW9uIHByb3ZpZGVEaXJlY3RpdmUoZGlyZWN0aXZlUmVzb2x2ZXIsIHR5cGUpIHtcclxuICAgIHZhciBhbm5vdGF0aW9uID0gZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZSh0eXBlKTtcclxuICAgIHJldHVybiBlbGVtZW50X2luamVjdG9yXzEuRGlyZWN0aXZlUHJvdmlkZXIuY3JlYXRlRnJvbVR5cGUodHlwZSwgYW5ub3RhdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyh2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZVByb3ZpZGVycykge1xyXG4gICAgdmFyIGRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlTmFtZUFuZFZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSB2YXJpYWJsZU5hbWVBbmRWYWx1ZXNbaV07XHJcbiAgICAgICAgdmFyIGRpckluZGV4ID0gdmFyaWFibGVOYW1lQW5kVmFsdWVzW2kgKyAxXTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzTnVtYmVyKGRpckluZGV4KSkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzLnNldCh0ZW1wbGF0ZU5hbWUsIGRpckluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGEgdmFyaWFibGUgd2l0aG91dCBhIGRpcmVjdGl2ZSBpbmRleCAtPiByZWZlcmVuY2UgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncy5zZXQodGVtcGxhdGVOYW1lLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncztcclxufVxyXG5leHBvcnRzLmNyZWF0ZURpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MgPSBjcmVhdGVEaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzO1xyXG5mdW5jdGlvbiBhcnJheVRvTWFwKGFyciwgaW52ZXJzZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgaWYgKGludmVyc2UpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChhcnJbaSArIDFdLCBhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChhcnJbaV0sIGFycltpICsgMV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gX2ZsYXR0ZW5MaXN0KHRyZWUsIG91dCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBkaV8xLnJlc29sdmVGb3J3YXJkUmVmKHRyZWVbaV0pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNBcnJheShpdGVtKSkge1xyXG4gICAgICAgICAgICBfZmxhdHRlbkxpc3QoaXRlbSwgb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm90b192aWV3X2ZhY3RvcnkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxuLyoqXHJcbiAqIEFuIHVubW9kaWZpYWJsZSBsaXN0IG9mIGl0ZW1zIHRoYXQgQW5ndWxhciBrZWVwcyB1cCB0byBkYXRlIHdoZW4gdGhlIHN0YXRlXHJcbiAqIG9mIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB7QGxpbmsgUXVlcnlNZXRhZGF0YX0gYW5kIHtAbGluayBWaWV3UXVlcnlNZXRhZGF0YX0gcHJvdmlkZS5cclxuICpcclxuICogSW1wbGVtZW50cyBhbiBpdGVyYWJsZSBpbnRlcmZhY2UsIHRoZXJlZm9yZSBpdCBjYW4gYmUgdXNlZCBpbiBib3RoIEVTNlxyXG4gKiBqYXZhc2NyaXB0IGBmb3IgKHZhciBpIG9mIGl0ZW1zKWAgbG9vcHMgYXMgd2VsbCBhcyBpbiBBbmd1bGFyIHRlbXBsYXRlcyB3aXRoXHJcbiAqIGAqbmctZm9yPVwiI2kgb2YgbXlMaXN0XCJgLlxyXG4gKlxyXG4gKiBDaGFuZ2VzIGNhbiBiZSBvYnNlcnZlZCBieSBzdWJzY3JpYmluZyB0byB0aGUgY2hhbmdlcyBgT2JzZXJ2YWJsZWAuXHJcbiAqXHJcbiAqIE5PVEU6IEluIHRoZSBmdXR1cmUgdGhpcyBjbGFzcyB3aWxsIGltcGxlbWVudCBhbiBgT2JzZXJ2YWJsZWAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHsuLi59KVxyXG4gKiBjbGFzcyBDb250YWluZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShJdGVtKSBpdGVtczogUXVlcnlMaXN0PEl0ZW0+KSB7XHJcbiAqICAgICBpdGVtcy5jaGFuZ2VzLnN1YnNjcmliZShfID0+IGNvbnNvbGUubG9nKGl0ZW1zLmxlbmd0aCkpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBRdWVyeUxpc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVlcnlMaXN0KCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJjaGFuZ2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VtaXR0ZXI7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubGVuZ3RoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdCh0aGlzLl9yZXN1bHRzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJsYXN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5sYXN0KHRoaXMuX3Jlc3VsdHMpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyBhIG5ldyBsaXN0IHdpdGggdGhlIHBhc3NzZWQgaW4gZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLm1hcChmbik7IH07XHJcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlW2xhbmdfMS5nZXRTeW1ib2xJdGVyYXRvcigpXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbbGFuZ18xLmdldFN5bWJvbEl0ZXJhdG9yKCldKCk7IH07XHJcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChyZXMpIHsgdGhpcy5fcmVzdWx0cyA9IHJlczsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9lbWl0dGVyLm5leHQodGhpcyk7IH07XHJcbiAgICByZXR1cm4gUXVlcnlMaXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLlF1ZXJ5TGlzdCA9IFF1ZXJ5TGlzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlfbGlzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBfbmV4dFRlbXBsYXRlSWQgPSAwO1xyXG5mdW5jdGlvbiBuZXh0VGVtcGxhdGVJZCgpIHtcclxuICAgIHJldHVybiBfbmV4dFRlbXBsYXRlSWQrKztcclxufVxyXG5leHBvcnRzLm5leHRUZW1wbGF0ZUlkID0gbmV4dFRlbXBsYXRlSWQ7XHJcbi8qKlxyXG4gKiBBIGNvbXBpbGVkIGhvc3QgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgY29uc3QgYXMgd2UgYXJlIHN0b3JpbmcgaXQgYXMgYW5ub3RhdGlvblxyXG4gKiBmb3IgdGhlIGNvbXBpbGVkIGNvbXBvbmVudCB0eXBlLlxyXG4gKi9cclxudmFyIENvbXBpbGVkSG9zdFRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIE5vdGU6IF90ZW1wbGF0ZUdldHRlciBpcyBhIGZ1bmN0aW9uIHNvIHRoYXQgQ29tcGlsZWRIb3N0VGVtcGxhdGUgY2FuIGJlXHJcbiAgICAvLyBhIGNvbnN0IVxyXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRIb3N0VGVtcGxhdGUoX3RlbXBsYXRlR2V0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVHZXR0ZXIgPSBfdGVtcGxhdGVHZXR0ZXI7XHJcbiAgICB9XHJcbiAgICBDb21waWxlZEhvc3RUZW1wbGF0ZS5wcm90b3R5cGUuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90ZW1wbGF0ZUdldHRlcigpOyB9O1xyXG4gICAgQ29tcGlsZWRIb3N0VGVtcGxhdGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbRnVuY3Rpb25dKVxyXG4gICAgXSwgQ29tcGlsZWRIb3N0VGVtcGxhdGUpO1xyXG4gICAgcmV0dXJuIENvbXBpbGVkSG9zdFRlbXBsYXRlO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBpbGVkSG9zdFRlbXBsYXRlID0gQ29tcGlsZWRIb3N0VGVtcGxhdGU7XHJcbi8qKlxyXG4gKiBBIGNvbXBpbGVkIHRlbXBsYXRlLlxyXG4gKi9cclxudmFyIENvbXBpbGVkVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gTm90ZTogcGFyYW1HZXR0ZXIgaXMgYSBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBoYXZlIGN5Y2xlcyBiZXR3ZWVuIHRlbXBsYXRlcyFcclxuICAgIC8vIHBhcmFtR2V0dGVyIHJldHVybnMgYSB0dXBsZSB3aXRoOlxyXG4gICAgLy8gLSBDaGFuZ2VEZXRlY3RvciBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICAvLyAtIFRlbXBsYXRlQ21kW11cclxuICAgIC8vIC0gc3R5bGVzXHJcbiAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKGlkLCBfZGF0YUdldHRlcikge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLl9kYXRhR2V0dGVyID0gX2RhdGFHZXR0ZXI7XHJcbiAgICB9XHJcbiAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGFwcElkKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhR2V0dGVyKGFwcElkLCB0aGlzLmlkKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVkVGVtcGxhdGVEYXRhKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21waWxlZFRlbXBsYXRlO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBpbGVkVGVtcGxhdGUgPSBDb21waWxlZFRlbXBsYXRlO1xyXG52YXIgQ29tcGlsZWRUZW1wbGF0ZURhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRUZW1wbGF0ZURhdGEoY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBjb21tYW5kcywgc3R5bGVzKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3RvcnkgPSBjaGFuZ2VEZXRlY3RvckZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IGNvbW1hbmRzO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGVEYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBpbGVkVGVtcGxhdGVEYXRhID0gQ29tcGlsZWRUZW1wbGF0ZURhdGE7XHJcbnZhciBFTVBUWV9BUlIgPSBsYW5nXzEuQ09OU1RfRVhQUihbXSk7XHJcbnZhciBUZXh0Q21kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRleHRDbWQodmFsdWUsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGlzQm91bmQ7XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xyXG4gICAgfVxyXG4gICAgVGV4dENtZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGV4dENtZDtcclxufSkoKTtcclxuZXhwb3J0cy5UZXh0Q21kID0gVGV4dENtZDtcclxuZnVuY3Rpb24gdGV4dCh2YWx1ZSwgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgIHJldHVybiBuZXcgVGV4dENtZCh2YWx1ZSwgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpO1xyXG59XHJcbmV4cG9ydHMudGV4dCA9IHRleHQ7XHJcbnZhciBOZ0NvbnRlbnRDbWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdDb250ZW50Q21kKGluZGV4LCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBOZ0NvbnRlbnRDbWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTmdDb250ZW50Q21kO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nQ29udGVudENtZCA9IE5nQ29udGVudENtZDtcclxuZnVuY3Rpb24gbmdDb250ZW50KGluZGV4LCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgcmV0dXJuIG5ldyBOZ0NvbnRlbnRDbWQoaW5kZXgsIG5nQ29udGVudEluZGV4KTtcclxufVxyXG5leHBvcnRzLm5nQ29udGVudCA9IG5nQ29udGVudDtcclxudmFyIEJlZ2luRWxlbWVudENtZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCZWdpbkVsZW1lbnRDbWQobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYXR0ck5hbWVBbmRWYWx1ZXMgPSBhdHRyTmFtZUFuZFZhbHVlcztcclxuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0QW5kTmFtZXMgPSBldmVudFRhcmdldEFuZE5hbWVzO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lQW5kVmFsdWVzID0gdmFyaWFibGVOYW1lQW5kVmFsdWVzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gaXNCb3VuZDtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICB9XHJcbiAgICBCZWdpbkVsZW1lbnRDbWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJlZ2luRWxlbWVudCh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmVnaW5FbGVtZW50Q21kO1xyXG59KSgpO1xyXG5leHBvcnRzLkJlZ2luRWxlbWVudENtZCA9IEJlZ2luRWxlbWVudENtZDtcclxuZnVuY3Rpb24gYmVnaW5FbGVtZW50KG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICByZXR1cm4gbmV3IEJlZ2luRWxlbWVudENtZChuYW1lLCBhdHRyTmFtZUFuZFZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCk7XHJcbn1cclxuZXhwb3J0cy5iZWdpbkVsZW1lbnQgPSBiZWdpbkVsZW1lbnQ7XHJcbnZhciBFbmRFbGVtZW50Q21kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVuZEVsZW1lbnRDbWQoKSB7XHJcbiAgICB9XHJcbiAgICBFbmRFbGVtZW50Q21kLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbmRFbGVtZW50KGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbmRFbGVtZW50Q21kO1xyXG59KSgpO1xyXG5leHBvcnRzLkVuZEVsZW1lbnRDbWQgPSBFbmRFbGVtZW50Q21kO1xyXG5mdW5jdGlvbiBlbmRFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIG5ldyBFbmRFbGVtZW50Q21kKCk7XHJcbn1cclxuZXhwb3J0cy5lbmRFbGVtZW50ID0gZW5kRWxlbWVudDtcclxudmFyIEJlZ2luQ29tcG9uZW50Q21kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJlZ2luQ29tcG9uZW50Q21kKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIG5hdGl2ZVNoYWRvdywgbmdDb250ZW50SW5kZXgsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmF0dHJOYW1lQW5kVmFsdWVzID0gYXR0ck5hbWVBbmRWYWx1ZXM7XHJcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldEFuZE5hbWVzID0gZXZlbnRUYXJnZXRBbmROYW1lcztcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZUFuZFZhbHVlcyA9IHZhcmlhYmxlTmFtZUFuZFZhbHVlcztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgICAgIHRoaXMubmF0aXZlU2hhZG93ID0gbmF0aXZlU2hhZG93O1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlSWQgPSB0ZW1wbGF0ZS5pZDtcclxuICAgIH1cclxuICAgIEJlZ2luQ29tcG9uZW50Q21kLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCZWdpbkNvbXBvbmVudCh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmVnaW5Db21wb25lbnRDbWQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQmVnaW5Db21wb25lbnRDbWQgPSBCZWdpbkNvbXBvbmVudENtZDtcclxuZnVuY3Rpb24gYmVnaW5Db21wb25lbnQobmFtZSwgYXR0ck5hbWVBbnNWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCwgdGVtcGxhdGUpIHtcclxuICAgIHJldHVybiBuZXcgQmVnaW5Db21wb25lbnRDbWQobmFtZSwgYXR0ck5hbWVBbnNWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCwgdGVtcGxhdGUpO1xyXG59XHJcbmV4cG9ydHMuYmVnaW5Db21wb25lbnQgPSBiZWdpbkNvbXBvbmVudDtcclxudmFyIEVuZENvbXBvbmVudENtZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbmRDb21wb25lbnRDbWQoKSB7XHJcbiAgICB9XHJcbiAgICBFbmRDb21wb25lbnRDbWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVuZENvbXBvbmVudChjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5kQ29tcG9uZW50Q21kO1xyXG59KSgpO1xyXG5leHBvcnRzLkVuZENvbXBvbmVudENtZCA9IEVuZENvbXBvbmVudENtZDtcclxuZnVuY3Rpb24gZW5kQ29tcG9uZW50KCkge1xyXG4gICAgcmV0dXJuIG5ldyBFbmRDb21wb25lbnRDbWQoKTtcclxufVxyXG5leHBvcnRzLmVuZENvbXBvbmVudCA9IGVuZENvbXBvbmVudDtcclxudmFyIEVtYmVkZGVkVGVtcGxhdGVDbWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW1iZWRkZWRUZW1wbGF0ZUNtZChhdHRyTmFtZUFuZFZhbHVlcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc01lcmdlZCwgbmdDb250ZW50SW5kZXgsIGNoYW5nZURldGVjdG9yRmFjdG9yeSwgY2hpbGRyZW4pIHtcclxuICAgICAgICB0aGlzLmF0dHJOYW1lQW5kVmFsdWVzID0gYXR0ck5hbWVBbmRWYWx1ZXM7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVBbmRWYWx1ZXMgPSB2YXJpYWJsZU5hbWVBbmRWYWx1ZXM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgICAgICB0aGlzLmlzTWVyZ2VkID0gaXNNZXJnZWQ7XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5ID0gY2hhbmdlRGV0ZWN0b3JGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldEFuZE5hbWVzID0gRU1QVFlfQVJSO1xyXG4gICAgfVxyXG4gICAgRW1iZWRkZWRUZW1wbGF0ZUNtZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUNtZDtcclxufSkoKTtcclxuZXhwb3J0cy5FbWJlZGRlZFRlbXBsYXRlQ21kID0gRW1iZWRkZWRUZW1wbGF0ZUNtZDtcclxuZnVuY3Rpb24gZW1iZWRkZWRUZW1wbGF0ZShhdHRyTmFtZUFuZFZhbHVlcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc01lcmdlZCwgbmdDb250ZW50SW5kZXgsIGNoYW5nZURldGVjdG9yRmFjdG9yeSwgY2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBuZXcgRW1iZWRkZWRUZW1wbGF0ZUNtZChhdHRyTmFtZUFuZFZhbHVlcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc01lcmdlZCwgbmdDb250ZW50SW5kZXgsIGNoYW5nZURldGVjdG9yRmFjdG9yeSwgY2hpbGRyZW4pO1xyXG59XHJcbmV4cG9ydHMuZW1iZWRkZWRUZW1wbGF0ZSA9IGVtYmVkZGVkVGVtcGxhdGU7XHJcbmZ1bmN0aW9uIHZpc2l0QWxsQ29tbWFuZHModmlzaXRvciwgY21kcywgY29udGV4dCkge1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY21kc1tpXS52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZpc2l0QWxsQ29tbWFuZHMgPSB2aXNpdEFsbENvbW1hbmRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9jb21tYW5kcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVmJyk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIEVtYmVkZGVkIFRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MuXHJcbiAqXHJcbiAqIFlvdSBjYW4gYWNjZXNzIGEgYFRlbXBsYXRlUmVmYCwgaW4gdHdvIHdheXMuIFZpYSBhIGRpcmVjdGl2ZSBwbGFjZWQgb24gYSBgPHRlbXBsYXRlPmAgZWxlbWVudCAob3JcclxuICogZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKSBhbmQgaGF2ZSB0aGUgYFRlbXBsYXRlUmVmYCBmb3IgdGhpcyBFbWJlZGRlZCBWaWV3IGluamVjdGVkIGludG8gdGhlXHJcbiAqIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXJlY3RpdmUgdXNpbmcgdGhlIGBUZW1wbGF0ZVJlZmAgVG9rZW4uIEFsdGVybmF0aXZlbHkgeW91IGNhbiBxdWVyeSBmb3IgdGhlXHJcbiAqIGBUZW1wbGF0ZVJlZmAgZnJvbSBhIENvbXBvbmVudCBvciBhIERpcmVjdGl2ZSB2aWEge0BsaW5rIFF1ZXJ5fS5cclxuICpcclxuICogVG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MgYmFzZWQgb24gYSBUZW1wbGF0ZSwgdXNlXHJcbiAqIHtAbGluayBWaWV3Q29udGFpbmVyUmVmI2NyZWF0ZUVtYmVkZGVkVmlld30sIHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBWaWV3IGFuZCBhdHRhY2ggaXQgdG8gdGhlXHJcbiAqIFZpZXcgQ29udGFpbmVyLlxyXG4gKi9cclxudmFyIFRlbXBsYXRlUmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRlbXBsYXRlUmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlRlbXBsYXRlUmVmID0gVGVtcGxhdGVSZWY7XHJcbnZhciBUZW1wbGF0ZVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRlbXBsYXRlUmVmXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmXyhlbGVtZW50UmVmKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcclxuICAgIH1cclxuICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuX2dldFByb3RvVmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudFJlZiA9IHRoaXMuZWxlbWVudFJlZjtcclxuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGVsZW1lbnRSZWYucGFyZW50Vmlldyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFZpZXcucHJvdG8uZWxlbWVudEJpbmRlcnNbZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCAtIHBhcmVudFZpZXcuZWxlbWVudE9mZnNldF1cclxuICAgICAgICAgICAgLm5lc3RlZFByb3RvVmlldztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWZfLnByb3RvdHlwZSwgXCJwcm90b1ZpZXdSZWZcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgUHJvdG9WaWV3IHVzZWQgZm9yIGNyZWF0aW5nIEVtYmVkZGVkIFZpZXdzIHRoYXQgYXJlIGJhc2VkIG9uIHRoZSBjb21waWxlZFxyXG4gICAgICAgICAqIEVtYmVkZGVkIFRlbXBsYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZ2V0UHJvdG9WaWV3KCkucmVmOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuaGFzTG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm90b1ZpZXcoKS50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuaGFzKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUZW1wbGF0ZVJlZl87XHJcbn0pKFRlbXBsYXRlUmVmKTtcclxuZXhwb3J0cy5UZW1wbGF0ZVJlZl8gPSBUZW1wbGF0ZVJlZl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlX3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIGludGVyZmFjZXNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vaW50ZXJmYWNlcycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciB2aWV3X3JlZl8xID0gcmVxdWlyZSgnLi92aWV3X3JlZicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS91dGlsJyk7XHJcbnZhciB2aWV3X3JlZl8yID0gcmVxdWlyZShcIi4vdmlld19yZWZcIik7XHJcbnZhciBpbnRlcmZhY2VzXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2ludGVyZmFjZXMnKTtcclxuZXhwb3J0cy5EZWJ1Z0NvbnRleHQgPSBpbnRlcmZhY2VzXzIuRGVidWdDb250ZXh0O1xyXG52YXIgUkVGTEVDVF9QUkVGSVggPSAnbmctcmVmbGVjdC0nO1xyXG4oZnVuY3Rpb24gKFZpZXdUeXBlKSB7XHJcbiAgICAvLyBBIHZpZXcgdGhhdCBjb250YWlucyB0aGUgaG9zdCBlbGVtZW50IHdpdGggYm91bmQgY29tcG9uZW50IGRpcmVjdGl2ZS5cclxuICAgIC8vIENvbnRhaW5zIGEgQ09NUE9ORU5UIHZpZXdcclxuICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiSE9TVFwiXSA9IDBdID0gXCJIT1NUXCI7XHJcbiAgICAvLyBUaGUgdmlldyBvZiB0aGUgY29tcG9uZW50XHJcbiAgICAvLyBDYW4gY29udGFpbiAwIHRvIG4gRU1CRURERUQgdmlld3NcclxuICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiQ09NUE9ORU5UXCJdID0gMV0gPSBcIkNPTVBPTkVOVFwiO1xyXG4gICAgLy8gQSB2aWV3IHRoYXQgaXMgZW1iZWRkZWQgaW50byBhbm90aGVyIFZpZXcgdmlhIGEgPHRlbXBsYXRlPiBlbGVtZW50XHJcbiAgICAvLyBpbnNpZGUgb2YgYSBDT01QT05FTlQgdmlld1xyXG4gICAgVmlld1R5cGVbVmlld1R5cGVbXCJFTUJFRERFRFwiXSA9IDJdID0gXCJFTUJFRERFRFwiO1xyXG59KShleHBvcnRzLlZpZXdUeXBlIHx8IChleHBvcnRzLlZpZXdUeXBlID0ge30pKTtcclxudmFyIFZpZXdUeXBlID0gZXhwb3J0cy5WaWV3VHlwZTtcclxudmFyIEFwcFZpZXdDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwVmlld0NvbnRhaW5lcigpIHtcclxuICAgICAgICAvLyBUaGUgb3JkZXIgaW4gdGhpcyBsaXN0IG1hdGNoZXMgdGhlIERPTSBvcmRlci5cclxuICAgICAgICB0aGlzLnZpZXdzID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQXBwVmlld0NvbnRhaW5lcjtcclxufSkoKTtcclxuZXhwb3J0cy5BcHBWaWV3Q29udGFpbmVyID0gQXBwVmlld0NvbnRhaW5lcjtcclxuLyoqXHJcbiAqIENvc3Qgb2YgbWFraW5nIG9iamVjdHM6IGh0dHA6Ly9qc3BlcmYuY29tL2luc3RhbnRpYXRlLXNpemUtb2Ytb2JqZWN0XHJcbiAqXHJcbiAqL1xyXG52YXIgQXBwVmlldyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBWaWV3KHJlbmRlcmVyLCBwcm90bywgdmlld09mZnNldCwgZWxlbWVudE9mZnNldCwgdGV4dE9mZnNldCwgcHJvdG9Mb2NhbHMsIHJlbmRlciwgcmVuZGVyRnJhZ21lbnQsIGNvbnRhaW5lckVsZW1lbnRJbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICB0aGlzLnByb3RvID0gcHJvdG87XHJcbiAgICAgICAgdGhpcy52aWV3T2Zmc2V0ID0gdmlld09mZnNldDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRPZmZzZXQgPSBlbGVtZW50T2Zmc2V0O1xyXG4gICAgICAgIHRoaXMudGV4dE9mZnNldCA9IHRleHRPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGcmFnbWVudCA9IHJlbmRlckZyYWdtZW50O1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudEluamVjdG9yID0gY29udGFpbmVyRWxlbWVudEluamVjdG9yO1xyXG4gICAgICAgIC8vIEFwcFZpZXdzIHRoYXQgaGF2ZSBiZWVuIG1lcmdlZCBpbiBkZXB0aCBmaXJzdCBvcmRlci5cclxuICAgICAgICAvLyBUaGlzIGxpc3QgaXMgc2hhcmVkIGJldHdlZW4gYWxsIG1lcmdlZCB2aWV3cy4gVXNlIHRoaXMuZWxlbWVudE9mZnNldCB0byBnZXQgdGhlIGxvY2FsXHJcbiAgICAgICAgLy8gZW50cmllcy5cclxuICAgICAgICB0aGlzLnZpZXdzID0gbnVsbDtcclxuICAgICAgICAvLyBFbGVtZW50SW5qZWN0b3JzIG9mIGFsbCBBcHBWaWV3cyBpbiB2aWV3cyBncm91cGVkIGJ5IHZpZXcuXHJcbiAgICAgICAgLy8gVGhpcyBsaXN0IGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBtZXJnZWQgdmlld3MuIFVzZSB0aGlzLmVsZW1lbnRPZmZzZXQgdG8gZ2V0IHRoZSBsb2NhbFxyXG4gICAgICAgIC8vIGVudHJpZXMuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50SW5qZWN0b3JzID0gbnVsbDtcclxuICAgICAgICAvLyBWaWV3Q29udGFpbmVycyBvZiBhbGwgQXBwVmlld3MgaW4gdmlld3MgZ3JvdXBlZCBieSB2aWV3LlxyXG4gICAgICAgIC8vIFRoaXMgbGlzdCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgbWVyZ2VkIHZpZXdzLiBVc2UgdGhpcy5lbGVtZW50T2Zmc2V0IHRvIGdldCB0aGUgbG9jYWxcclxuICAgICAgICAvLyBlbnRyaWVzLlxyXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lcnMgPSBudWxsO1xyXG4gICAgICAgIC8vIFByZUJ1aWx0T2JqZWN0cyBvZiBhbGwgQXBwVmlld3MgaW4gdmlld3MgZ3JvdXBlZCBieSB2aWV3LlxyXG4gICAgICAgIC8vIFRoaXMgbGlzdCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgbWVyZ2VkIHZpZXdzLiBVc2UgdGhpcy5lbGVtZW50T2Zmc2V0IHRvIGdldCB0aGUgbG9jYWxcclxuICAgICAgICAvLyBlbnRyaWVzLlxyXG4gICAgICAgIHRoaXMucHJlQnVpbHRPYmplY3RzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29udGV4dCBhZ2FpbnN0IHdoaWNoIGRhdGEtYmluZGluZyBleHByZXNzaW9ucyBpbiB0aGlzIHZpZXcgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0LlxyXG4gICAgICAgICAqIFRoaXMgaXMgYWx3YXlzIGEgY29tcG9uZW50IGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWYgPSBuZXcgdmlld19yZWZfMi5WaWV3UmVmXyh0aGlzKTtcclxuICAgICAgICB0aGlzLmxvY2FscyA9IG5ldyBjaGFuZ2VfZGV0ZWN0aW9uXzEuTG9jYWxzKG51bGwsIGNvbGxlY3Rpb25fMS5NYXBXcmFwcGVyLmNsb25lKHByb3RvTG9jYWxzKSk7IC8vIFRPRE8gb3B0aW1pemUgdGhpc1xyXG4gICAgfVxyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChjaGFuZ2VEZXRlY3RvciwgZWxlbWVudEluamVjdG9ycywgcm9vdEVsZW1lbnRJbmplY3RvcnMsIHByZUJ1aWx0T2JqZWN0cywgdmlld3MsIGVsZW1lbnRSZWZzLCB2aWV3Q29udGFpbmVycykge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnRJbmplY3RvcnMgPSBlbGVtZW50SW5qZWN0b3JzO1xyXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnRJbmplY3RvcnMgPSByb290RWxlbWVudEluamVjdG9ycztcclxuICAgICAgICB0aGlzLnByZUJ1aWx0T2JqZWN0cyA9IHByZUJ1aWx0T2JqZWN0cztcclxuICAgICAgICB0aGlzLnZpZXdzID0gdmlld3M7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmcyA9IGVsZW1lbnRSZWZzO1xyXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lcnMgPSB2aWV3Q29udGFpbmVycztcclxuICAgIH07XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5zZXRMb2NhbCA9IGZ1bmN0aW9uIChjb250ZXh0TmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaHlkcmF0ZWQoKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdDYW5ub3Qgc2V0IGxvY2FscyBvbiBkZWh5ZHJhdGVkIHZpZXcuJyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncy5oYXMoY29udGV4dE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHRoaXMucHJvdG8udGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzLmdldChjb250ZXh0TmFtZSk7XHJcbiAgICAgICAgdGhpcy5sb2NhbHMuc2V0KHRlbXBsYXRlTmFtZSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmh5ZHJhdGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRleHQpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0aGUgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBlbGVtZW50IGFuZCB0aGUgZGlyZWN0aXZlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSBkaXJlY3RpdmUgRXZlbnRFbWl0dGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50T2JqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm91bmRFbGVtZW50SW5kZXhcclxuICAgICAqL1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUudHJpZ2dlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudE9iaiwgYm91bmRFbGVtZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgbG9jYWxzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICBsb2NhbHMuc2V0KCckZXZlbnQnLCBldmVudE9iaik7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGxvY2Fscyk7XHJcbiAgICB9O1xyXG4gICAgLy8gZGlzcGF0Y2ggdG8gZWxlbWVudCBpbmplY3RvciBvciB0ZXh0IG5vZGVzIGJhc2VkIG9uIGNvbnRleHRcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLm5vdGlmeU9uQmluZGluZyA9IGZ1bmN0aW9uIChiLCBjdXJyZW50VmFsdWUpIHtcclxuICAgICAgICBpZiAoYi5pc1RleHROb2RlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRUZXh0KHRoaXMucmVuZGVyLCBiLmVsZW1lbnRJbmRleCArIHRoaXMudGV4dE9mZnNldCwgY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50UmVmID0gdGhpcy5lbGVtZW50UmVmc1t0aGlzLmVsZW1lbnRPZmZzZXQgKyBiLmVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChiLmlzRWxlbWVudFByb3BlcnR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KGVsZW1lbnRSZWYsIGIubmFtZSwgY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChiLmlzRWxlbWVudEF0dHJpYnV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRBdHRyaWJ1dGUoZWxlbWVudFJlZiwgYi5uYW1lLCBsYW5nXzEuaXNQcmVzZW50KGN1cnJlbnRWYWx1ZSkgPyBcIlwiICsgY3VycmVudFZhbHVlIDogbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pc0VsZW1lbnRDbGFzcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtZW50UmVmLCBiLm5hbWUsIGN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pc0VsZW1lbnRTdHlsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IGxhbmdfMS5pc1ByZXNlbnQoYi51bml0KSA/IGIudW5pdCA6ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUoZWxlbWVudFJlZiwgYi5uYW1lLCBcIlwiICsgY3VycmVudFZhbHVlICsgdW5pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGRpcmVjdGl2ZSByZWNvcmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5sb2dCaW5kaW5nVXBkYXRlID0gZnVuY3Rpb24gKGIsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGIuaXNEaXJlY3RpdmUoKSB8fCBiLmlzRWxlbWVudFByb3BlcnR5KCkpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRSZWYgPSB0aGlzLmVsZW1lbnRSZWZzW3RoaXMuZWxlbWVudE9mZnNldCArIGIuZWxlbWVudEluZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKGVsZW1lbnRSZWYsIFwiXCIgKyBSRUZMRUNUX1BSRUZJWCArIHV0aWxfMS5jYW1lbENhc2VUb0Rhc2hDYXNlKGIubmFtZSksIFwiXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLm5vdGlmeUFmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVpQ291bnQgPSB0aGlzLnByb3RvLmVsZW1lbnRCaW5kZXJzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZWkgPSB0aGlzLmVsZW1lbnRJbmplY3RvcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGVpQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlaVtpICsgdGhpcy5lbGVtZW50T2Zmc2V0XSkpXHJcbiAgICAgICAgICAgICAgICBlaVtpICsgdGhpcy5lbGVtZW50T2Zmc2V0XS5hZnRlckNvbnRlbnRDaGVja2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLm5vdGlmeUFmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVpQ291bnQgPSB0aGlzLnByb3RvLmVsZW1lbnRCaW5kZXJzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZWkgPSB0aGlzLmVsZW1lbnRJbmplY3RvcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGVpQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlaVtpICsgdGhpcy5lbGVtZW50T2Zmc2V0XSkpXHJcbiAgICAgICAgICAgICAgICBlaVtpICsgdGhpcy5lbGVtZW50T2Zmc2V0XS5hZnRlclZpZXdDaGVja2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmdldERpcmVjdGl2ZUZvciA9IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICB2YXIgZWxlbWVudEluamVjdG9yID0gdGhpcy5lbGVtZW50SW5qZWN0b3JzW3RoaXMuZWxlbWVudE9mZnNldCArIGRpcmVjdGl2ZS5lbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50SW5qZWN0b3IuZ2V0RGlyZWN0aXZlQXRJbmRleChkaXJlY3RpdmUuZGlyZWN0aXZlSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmdldE5lc3RlZFZpZXcgPSBmdW5jdGlvbiAoYm91bmRFbGVtZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgZWxpID0gdGhpcy5lbGVtZW50SW5qZWN0b3JzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChlbGkpID8gZWxpLmdldE5lc3RlZFZpZXcoKSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZ2V0Q29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRhaW5lckVsZW1lbnRJbmplY3RvcikgP1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnRJbmplY3Rvci5nZXRFbGVtZW50UmVmKCkgOlxyXG4gICAgICAgICAgICBudWxsO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmdldERlYnVnQ29udGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50SW5kZXgsIGRpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldHRlZEluZGV4ID0gdGhpcy5lbGVtZW50T2Zmc2V0ICsgZWxlbWVudEluZGV4O1xyXG4gICAgICAgICAgICB2YXIgaGFzUmVmRm9ySW5kZXggPSBvZmZzZXR0ZWRJbmRleCA8IHRoaXMuZWxlbWVudFJlZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFJlZiA9IGhhc1JlZkZvckluZGV4ID8gdGhpcy5lbGVtZW50UmVmc1t0aGlzLmVsZW1lbnRPZmZzZXQgKyBlbGVtZW50SW5kZXhdIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xyXG4gICAgICAgICAgICB2YXIgZWkgPSBoYXNSZWZGb3JJbmRleCA/IHRoaXMuZWxlbWVudEluamVjdG9yc1t0aGlzLmVsZW1lbnRPZmZzZXQgKyBlbGVtZW50SW5kZXhdIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnRSZWYpID8gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50IDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEVsZW1lbnQgPSBsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lcikgPyBjb250YWluZXIubmF0aXZlRWxlbWVudCA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZUluZGV4KSA/IHRoaXMuZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZUluZGV4KSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBpbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQoZWkpID8gZWkuZ2V0SW5qZWN0b3IoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW50ZXJmYWNlc18xLkRlYnVnQ29udGV4dChlbGVtZW50LCBjb21wb25lbnRFbGVtZW50LCBkaXJlY3RpdmUsIHRoaXMuY29udGV4dCwgX2xvY2Fsc1RvU3RyaW5nTWFwKHRoaXMubG9jYWxzKSwgaW5qZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB2c2F2a2luIGxvZyB0aGUgZXhjZXB0aW9uIG9uY2Ugd2UgaGF2ZSBhIGdvb2Qgd2F5IHRvIGxvZyBlcnJvcnMgYW5kIHdhcm5pbmdzXHJcbiAgICAgICAgICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbnMgZHVyaW5nIGdldHRpbmcgdGhlIGRlYnVnIGNvbnRleHQsIHdlIHJldHVybiBudWxsLlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZ2V0RGV0ZWN0b3JGb3IgPSBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkVmlldyA9IHRoaXMuZ2V0TmVzdGVkVmlldyh0aGlzLmVsZW1lbnRPZmZzZXQgKyBkaXJlY3RpdmUuZWxlbWVudEluZGV4KTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChjaGlsZFZpZXcpID8gY2hpbGRWaWV3LmNoYW5nZURldGVjdG9yIDogbnVsbDtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5pbnZva2VFbGVtZW50TWV0aG9kID0gZnVuY3Rpb24gKGVsZW1lbnRJbmRleCwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLmVsZW1lbnRSZWZzW2VsZW1lbnRJbmRleF0sIG1ldGhvZE5hbWUsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIFJlbmRlckV2ZW50RGlzcGF0Y2hlciNkaXNwYXRjaFJlbmRlckV2ZW50XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckV2ZW50ID0gZnVuY3Rpb24gKGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGxvY2Fscykge1xyXG4gICAgICAgIHZhciBlbGVtZW50UmVmID0gdGhpcy5lbGVtZW50UmVmc1tib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyhlbGVtZW50UmVmLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHJldHVybiB2aWV3LmRpc3BhdGNoRXZlbnQoZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBsb2NhbHMpO1xyXG4gICAgfTtcclxuICAgIC8vIHJldHVybnMgZmFsc2UgaWYgcHJldmVudERlZmF1bHQgbXVzdCBiZSBhcHBsaWVkIHRvIHRoZSBET00gZXZlbnRcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgbG9jYWxzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaHlkcmF0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmNoYW5nZURldGVjdG9yLmhhbmRsZUV2ZW50KGV2ZW50TmFtZSwgYm91bmRFbGVtZW50SW5kZXggLSB0aGlzLmVsZW1lbnRPZmZzZXQsIG5ldyBjaGFuZ2VfZGV0ZWN0aW9uXzEuTG9jYWxzKHRoaXMubG9jYWxzLCBsb2NhbHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5nZXREZWJ1Z0NvbnRleHQoYm91bmRFbGVtZW50SW5kZXggLSB0aGlzLmVsZW1lbnRPZmZzZXQsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGxhbmdfMS5pc1ByZXNlbnQoYykgPyBuZXcgX0NvbnRleHQoYy5lbGVtZW50LCBjLmNvbXBvbmVudEVsZW1lbnQsIGMuY29udGV4dCwgYy5sb2NhbHMsIGMuaW5qZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVudEV2YWx1YXRpb25FcnJvcihldmVudE5hbWUsIGUsIGUuc3RhY2ssIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwib3duQmluZGVyc0NvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJvdG8uZWxlbWVudEJpbmRlcnMubGVuZ3RoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBBcHBWaWV3O1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFZpZXcgPSBBcHBWaWV3O1xyXG5mdW5jdGlvbiBfbG9jYWxzVG9TdHJpbmdNYXAobG9jYWxzKSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgYyA9IGxvY2FscztcclxuICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KGMpKSB7XHJcbiAgICAgICAgcmVzID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIubWVyZ2UocmVzLCBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci50b1N0cmluZ01hcChjLmN1cnJlbnQpKTtcclxuICAgICAgICBjID0gYy5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBFcnJvciBjb250ZXh0IGluY2x1ZGVkIHdoZW4gYW4gZXZlbnQgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIF9Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9Db250ZXh0KGVsZW1lbnQsIGNvbXBvbmVudEVsZW1lbnQsIGNvbnRleHQsIGxvY2FscywgaW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50RWxlbWVudCA9IGNvbXBvbmVudEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLmxvY2FscyA9IGxvY2FscztcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX0NvbnRleHQ7XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBXcmFwcyBhbiBleGNlcHRpb24gdGhyb3duIGJ5IGFuIGV2ZW50IGhhbmRsZXIuXHJcbiAqL1xyXG52YXIgRXZlbnRFdmFsdWF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEV2ZW50RXZhbHVhdGlvbkVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXZlbnRFdmFsdWF0aW9uRXJyb3IoZXZlbnROYW1lLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3IgZHVyaW5nIGV2YWx1YXRpb24gb2YgXFxcIlwiICsgZXZlbnROYW1lICsgXCJcXFwiXCIsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudEV2YWx1YXRpb25FcnJvcjtcclxufSkoZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24pO1xyXG52YXIgQXBwUHJvdG9WaWV3TWVyZ2VJbmZvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFByb3RvVmlld01lcmdlSW5mbyhlbWJlZGRlZFZpZXdDb3VudCwgZWxlbWVudENvdW50LCB2aWV3Q291bnQpIHtcclxuICAgICAgICB0aGlzLmVtYmVkZGVkVmlld0NvdW50ID0gZW1iZWRkZWRWaWV3Q291bnQ7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSBlbGVtZW50Q291bnQ7XHJcbiAgICAgICAgdGhpcy52aWV3Q291bnQgPSB2aWV3Q291bnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQXBwUHJvdG9WaWV3TWVyZ2VJbmZvO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFByb3RvVmlld01lcmdlSW5mbyA9IEFwcFByb3RvVmlld01lcmdlSW5mbztcclxuLyoqXHJcbiAqXHJcbiAqL1xyXG52YXIgQXBwUHJvdG9WaWV3ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFByb3RvVmlldyh0ZW1wbGF0ZUNtZHMsIHR5cGUsIGlzTWVyZ2FibGUsIGNoYW5nZURldGVjdG9yRmFjdG9yeSwgdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzLCBwaXBlcykge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVDbWRzID0gdGVtcGxhdGVDbWRzO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5pc01lcmdhYmxlID0gaXNNZXJnYWJsZTtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yRmFjdG9yeSA9IGNoYW5nZURldGVjdG9yRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyA9IHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncztcclxuICAgICAgICB0aGlzLnBpcGVzID0gcGlwZXM7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50QmluZGVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tZXJnZUluZm8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVMb2NhdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGV4dEJpbmRpbmdDb3VudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVmID0gbmV3IHZpZXdfcmVmXzIuUHJvdG9WaWV3UmVmXyh0aGlzKTtcclxuICAgIH1cclxuICAgIEFwcFByb3RvVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyZW5kZXIsIGVsZW1lbnRCaW5kZXJzLCB0ZXh0QmluZGluZ0NvdW50LCBtZXJnZUluZm8sIHZhcmlhYmxlTG9jYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJzID0gZWxlbWVudEJpbmRlcnM7XHJcbiAgICAgICAgdGhpcy50ZXh0QmluZGluZ0NvdW50ID0gdGV4dEJpbmRpbmdDb3VudDtcclxuICAgICAgICB0aGlzLm1lcmdlSW5mbyA9IG1lcmdlSW5mbztcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTG9jYXRpb25zID0gdmFyaWFibGVMb2NhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5wcm90b0xvY2FscyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlTmFtZSwgXykgeyBfdGhpcy5wcm90b0xvY2Fscy5zZXQodGVtcGxhdGVOYW1lLCBudWxsKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhcmlhYmxlTG9jYXRpb25zKSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgdmlldydzIGxvY2FscyBuZWVkcyB0byBoYXZlIGEgZnVsbCBzZXQgb2YgdmFyaWFibGUgbmFtZXMgYXQgY29uc3RydWN0aW9uIHRpbWVcclxuICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBuZXcgdmFyaWFibGVzIGZyb20gYmVpbmcgc2V0IGxhdGVyIGluIHRoZSBsaWZlY3ljbGUuIFNpbmNlIHdlIGRvbid0XHJcbiAgICAgICAgICAgIC8vIHdhbnRcclxuICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgY3JlYXRlIHZhcmlhYmxlIGJpbmRpbmdzIGZvciB0aGUgJGltcGxpY2l0IGJpbmRpbmdzLCBhZGQgdG8gdGhlXHJcbiAgICAgICAgICAgIC8vIHByb3RvTG9jYWxzIG1hbnVhbGx5LlxyXG4gICAgICAgICAgICB2YXJpYWJsZUxvY2F0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfLCB0ZW1wbGF0ZU5hbWUpIHsgX3RoaXMucHJvdG9Mb2NhbHMuc2V0KHRlbXBsYXRlTmFtZSwgbnVsbCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBQcm90b1ZpZXcucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZWxlbWVudEJpbmRlcnMpOyB9O1xyXG4gICAgcmV0dXJuIEFwcFByb3RvVmlldztcclxufSkoKTtcclxuZXhwb3J0cy5BcHBQcm90b1ZpZXcgPSBBcHBQcm90b1ZpZXc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciB2aWV3X3JlZl8xID0gcmVxdWlyZSgnLi92aWV3X3JlZicpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXHJcbiAqXHJcbiAqIFRoZSBjb250YWluZXIgY2FuIGNvbnRhaW4gdHdvIGtpbmRzIG9mIFZpZXdzLiBIb3N0IFZpZXdzLCBjcmVhdGVkIGJ5IGluc3RhbnRpYXRpbmcgYVxyXG4gKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVIb3N0Vmlld30sIGFuZCBFbWJlZGRlZCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFuXHJcbiAqIHtAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtAbGluayAjY3JlYXRlRW1iZWRkZWRWaWV3fS5cclxuICpcclxuICogVGhlIGxvY2F0aW9uIG9mIHRoZSBWaWV3IENvbnRhaW5lciB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgVmlldyBpcyBzcGVjaWZpZWQgYnkgdGhlIEFuY2hvclxyXG4gKiBgZWxlbWVudGAuIEVhY2ggVmlldyBDb250YWluZXIgY2FuIGhhdmUgb25seSBvbmUgQW5jaG9yIEVsZW1lbnQgYW5kIGVhY2ggQW5jaG9yIEVsZW1lbnQgY2FuIG9ubHlcclxuICogaGF2ZSBhIHNpbmdsZSBWaWV3IENvbnRhaW5lci5cclxuICpcclxuICogUm9vdCBlbGVtZW50cyBvZiBWaWV3cyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lciBiZWNvbWUgc2libGluZ3Mgb2YgdGhlIEFuY2hvciBFbGVtZW50IGluXHJcbiAqIHRoZSBSZW5kZXJlZCBWaWV3LlxyXG4gKlxyXG4gKiBUbyBhY2Nlc3MgYSBgVmlld0NvbnRhaW5lclJlZmAgb2YgYW4gRWxlbWVudCwgeW91IGNhbiBlaXRoZXIgcGxhY2UgYSB7QGxpbmsgRGlyZWN0aXZlfSBpbmplY3RlZFxyXG4gKiB3aXRoIGBWaWV3Q29udGFpbmVyUmVmYCBvbiB0aGUgRWxlbWVudCwgb3IgeW91IG9idGFpbiBpdCB2aWFcclxuICoge0BsaW5rIEFwcFZpZXdNYW5hZ2VyI2dldFZpZXdDb250YWluZXJ9LlxyXG4gKlxyXG4gKiA8IS0tIFRPRE8oaSk6IHdlIGFyZSBhbHNvIGNvbnNpZGVyaW5nIEVsZW1lbnRSZWYjdmlld0NvbnRhaW5lciBhcGkgLS0+XHJcbiAqL1xyXG52YXIgVmlld0NvbnRhaW5lclJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3Q29udGFpbmVyUmVmKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyBhbGwgVmlld3MgaW4gdGhpcyBjb250YWluZXIuXHJcbiAgICAgKi9cclxuICAgIFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgVmlld3MgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZjtcclxufSkoKTtcclxuZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmID0gVmlld0NvbnRhaW5lclJlZjtcclxudmFyIFZpZXdDb250YWluZXJSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWaWV3Q29udGFpbmVyUmVmXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWZfKHZpZXdNYW5hZ2VyLCBlbGVtZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy52aWV3TWFuYWdlciA9IHZpZXdNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuX2dldFZpZXdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgIHZhciB2YyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGVsZW1lbnQucGFyZW50Vmlldykudmlld0NvbnRhaW5lcnNbZWxlbWVudC5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodmMpID8gdmMudmlld3MgOiBbXTtcclxuICAgIH07XHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9nZXRWaWV3cygpW2luZGV4XS5yZWY7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9nZXRWaWV3cygpLmxlbmd0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPKHJhZG8pOiBwcm9maWxlIGFuZCBkZWNpZGUgd2hldGhlciBib3VuZHMgY2hlY2tzIHNob3VsZCBiZSBhZGRlZFxyXG4gICAgLy8gdG8gdGhlIG1ldGhvZHMgYmVsb3cuXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKHRlbXBsYXRlUmVmLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cclxuICAgICAgICBpZiAoaW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01hbmFnZXIuY3JlYXRlRW1iZWRkZWRWaWV3SW5Db250YWluZXIodGhpcy5lbGVtZW50LCBpbmRleCwgdGVtcGxhdGVSZWYpO1xyXG4gICAgfTtcclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVIb3N0VmlldyA9IGZ1bmN0aW9uIChwcm90b1ZpZXdSZWYsIGluZGV4LCBkeW5hbWljYWxseUNyZWF0ZWRQcm92aWRlcnMpIHtcclxuICAgICAgICBpZiAocHJvdG9WaWV3UmVmID09PSB2b2lkIDApIHsgcHJvdG9WaWV3UmVmID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cclxuICAgICAgICBpZiAoZHluYW1pY2FsbHlDcmVhdGVkUHJvdmlkZXJzID09PSB2b2lkIDApIHsgZHluYW1pY2FsbHlDcmVhdGVkUHJvdmlkZXJzID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFuYWdlci5jcmVhdGVIb3N0Vmlld0luQ29udGFpbmVyKHRoaXMuZWxlbWVudCwgaW5kZXgsIHByb3RvVmlld1JlZiwgZHluYW1pY2FsbHlDcmVhdGVkUHJvdmlkZXJzKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPKGkpOiByZWZhY3RvciBpbnNlcnQrcmVtb3ZlIGludG8gbW92ZVxyXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh2aWV3UmVmLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cclxuICAgICAgICBpZiAoaW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01hbmFnZXIuYXR0YWNoVmlld0luQ29udGFpbmVyKHRoaXMuZWxlbWVudCwgaW5kZXgsIHZpZXdSZWYpO1xyXG4gICAgfTtcclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmluZGV4T2YodGhpcy5fZ2V0Vmlld3MoKSwgdmlld19yZWZfMS5pbnRlcm5hbFZpZXcodmlld1JlZikpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE8oaSk6IHJlbmFtZSB0byBkZXN0cm95XHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdGhpcy52aWV3TWFuYWdlci5kZXN0cm95Vmlld0luQ29udGFpbmVyKHRoaXMuZWxlbWVudCwgaW5kZXgpO1xyXG4gICAgICAgIC8vIHZpZXcgaXMgaW50ZW50aW9uYWxseSBub3QgcmV0dXJuZWQgdG8gdGhlIGNsaWVudC5cclxuICAgIH07XHJcbiAgICAvLyBUT0RPKGkpOiByZWZhY3RvciBpbnNlcnQrcmVtb3ZlIGludG8gbW92ZVxyXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cclxuICAgICAgICBpZiAoaW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdNYW5hZ2VyLmRldGFjaFZpZXdJbkNvbnRhaW5lcih0aGlzLmVsZW1lbnQsIGluZGV4KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZl87XHJcbn0pKFZpZXdDb250YWluZXJSZWYpO1xyXG5leHBvcnRzLlZpZXdDb250YWluZXJSZWZfID0gVmlld0NvbnRhaW5lclJlZl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfY29udGFpbmVyX3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG4vKipcclxuICogTGlzdGVuZXIgZm9yIHZpZXcgY3JlYXRpb24gLyBkZXN0cnVjdGlvbi5cclxuICovXHJcbnZhciBBcHBWaWV3TGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwVmlld0xpc3RlbmVyKCkge1xyXG4gICAgfVxyXG4gICAgQXBwVmlld0xpc3RlbmVyLnByb3RvdHlwZS52aWV3Q3JlYXRlZCA9IGZ1bmN0aW9uICh2aWV3KSB7IH07XHJcbiAgICBBcHBWaWV3TGlzdGVuZXIucHJvdG90eXBlLnZpZXdEZXN0cm95ZWQgPSBmdW5jdGlvbiAodmlldykgeyB9O1xyXG4gICAgQXBwVmlld0xpc3RlbmVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBBcHBWaWV3TGlzdGVuZXIpO1xyXG4gICAgcmV0dXJuIEFwcFZpZXdMaXN0ZW5lcjtcclxufSkoKTtcclxuZXhwb3J0cy5BcHBWaWV3TGlzdGVuZXIgPSBBcHBWaWV3TGlzdGVuZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfbGlzdGVuZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciB2aWV3TW9kdWxlID0gcmVxdWlyZSgnLi92aWV3Jyk7XHJcbnZhciB2aWV3X3JlZl8xID0gcmVxdWlyZSgnLi92aWV3X3JlZicpO1xyXG52YXIgYXBpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvYXBpJyk7XHJcbnZhciB2aWV3X21hbmFnZXJfdXRpbHNfMSA9IHJlcXVpcmUoJy4vdmlld19tYW5hZ2VyX3V0aWxzJyk7XHJcbnZhciB2aWV3X3Bvb2xfMSA9IHJlcXVpcmUoJy4vdmlld19wb29sJyk7XHJcbnZhciB2aWV3X2xpc3RlbmVyXzEgPSByZXF1aXJlKCcuL3ZpZXdfbGlzdGVuZXInKTtcclxudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4uL3Byb2ZpbGUvcHJvZmlsZScpO1xyXG52YXIgcHJvdG9fdmlld19mYWN0b3J5XzEgPSByZXF1aXJlKCcuL3Byb3RvX3ZpZXdfZmFjdG9yeScpO1xyXG4vKipcclxuICogU2VydmljZSBleHBvc2luZyBsb3cgbGV2ZWwgQVBJIGZvciBjcmVhdGluZywgbW92aW5nIGFuZCBkZXN0cm95aW5nIFZpZXdzLlxyXG4gKlxyXG4gKiBNb3N0IGFwcGxpY2F0aW9ucyBzaG91bGQgdXNlIGhpZ2hlci1sZXZlbCBhYnN0cmFjdGlvbnMgbGlrZSB7QGxpbmsgRHluYW1pY0NvbXBvbmVudExvYWRlcn0gYW5kXHJcbiAqIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSBpbnN0ZWFkLlxyXG4gKi9cclxudmFyIEFwcFZpZXdNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFZpZXdNYW5hZ2VyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgRWxlbWVudFJlZn0gdGhhdCBtYWtlcyB1cCB0aGUgc3BlY2lmaWVkIEhvc3QgVmlldy5cclxuICAgICAqL1xyXG4gICAgQXBwVmlld01hbmFnZXIucHJvdG90eXBlLmdldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKGhvc3RWaWV3UmVmKSB7XHJcbiAgICAgICAgdmFyIGhvc3RWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgIGlmIChob3N0Vmlldy5wcm90by50eXBlICE9PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkhPU1QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdUaGlzIG9wZXJhdGlvbiBpcyBvbmx5IGFsbG93ZWQgb24gaG9zdCB2aWV3cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG9zdFZpZXcuZWxlbWVudFJlZnNbaG9zdFZpZXcuZWxlbWVudE9mZnNldF07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFwcFZpZXdNYW5hZ2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFZpZXdNYW5hZ2VyID0gQXBwVmlld01hbmFnZXI7XHJcbnZhciBBcHBWaWV3TWFuYWdlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFwcFZpZXdNYW5hZ2VyXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFwcFZpZXdNYW5hZ2VyXyhfdmlld1Bvb2wsIF92aWV3TGlzdGVuZXIsIF91dGlscywgX3JlbmRlcmVyLCBfcHJvdG9WaWV3RmFjdG9yeSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdQb29sID0gX3ZpZXdQb29sO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdMaXN0ZW5lciA9IF92aWV3TGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5fdXRpbHMgPSBfdXRpbHM7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVJvb3RIb3N0Vmlld1Njb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYWdlciNjcmVhdGVSb290SG9zdFZpZXcoKScpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9kZXN0cm95Um9vdEhvc3RWaWV3U2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0FwcFZpZXdNYW5hZ2VyI2Rlc3Ryb3lSb290SG9zdFZpZXcoKScpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9jcmVhdGVFbWJlZGRlZFZpZXdJbkNvbnRhaW5lclNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYWdlciNjcmVhdGVFbWJlZGRlZFZpZXdJbkNvbnRhaW5lcigpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUhvc3RWaWV3SW5Db250YWluZXJTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnQXBwVmlld01hbmFnZXIjY3JlYXRlSG9zdFZpZXdJbkNvbnRhaW5lcigpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lWaWV3SW5Db250YWluZXJTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnQXBwVmlld01hbmFuZ2VyI2Rlc3Ryb3lWaWV3SW5Db250YWluZXIoKScpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9hdHRhY2hWaWV3SW5Db250YWluZXJTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnQXBwVmlld01hbmFuZ2VyI2F0dGFjaFZpZXdJbkNvbnRhaW5lcigpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2RldGFjaFZpZXdJbkNvbnRhaW5lclNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYW5nZXIjZGV0YWNoVmlld0luQ29udGFpbmVyKCknKTtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5ID0gX3Byb3RvVmlld0ZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmdldFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgaG9zdFZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyhsb2NhdGlvbi5wYXJlbnRWaWV3KTtcclxuICAgICAgICByZXR1cm4gaG9zdFZpZXcuZWxlbWVudEluamVjdG9yc1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF1cclxuICAgICAgICAgICAgLmdldFZpZXdDb250YWluZXJSZWYoKTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmdldE5hbWVkRWxlbWVudEluQ29tcG9uZW50VmlldyA9IGZ1bmN0aW9uIChob3N0TG9jYXRpb24sIHZhcmlhYmxlTmFtZSkge1xyXG4gICAgICAgIHZhciBob3N0VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGhvc3RMb2NhdGlvbi5wYXJlbnRWaWV3KTtcclxuICAgICAgICB2YXIgYm91bmRFbGVtZW50SW5kZXggPSBob3N0TG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSBob3N0Vmlldy5nZXROZXN0ZWRWaWV3KGJvdW5kRWxlbWVudEluZGV4KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcG9uZW50VmlldykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVGhlcmUgaXMgbm8gY29tcG9uZW50IGRpcmVjdGl2ZSBhdCBlbGVtZW50IFwiICsgYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmluZGVySWR4ID0gY29tcG9uZW50Vmlldy5wcm90by52YXJpYWJsZUxvY2F0aW9ucy5nZXQodmFyaWFibGVOYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoYmluZGVySWR4KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb3VsZCBub3QgZmluZCB2YXJpYWJsZSBcIiArIHZhcmlhYmxlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wb25lbnRWaWV3LmVsZW1lbnRSZWZzW2NvbXBvbmVudFZpZXcuZWxlbWVudE9mZnNldCArIGJpbmRlcklkeF07XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoaG9zdExvY2F0aW9uKSB7XHJcbiAgICAgICAgdmFyIGhvc3RWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoaG9zdExvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IGhvc3RMb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXRpbHMuZ2V0Q29tcG9uZW50SW5zdGFuY2UoaG9zdFZpZXcsIGJvdW5kRWxlbWVudEluZGV4KTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmNyZWF0ZVJvb3RIb3N0VmlldyA9IGZ1bmN0aW9uIChob3N0UHJvdG9WaWV3UmVmLCBvdmVycmlkZVNlbGVjdG9yLCBpbmplY3Rvcikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlUm9vdEhvc3RWaWV3U2NvcGUoKTtcclxuICAgICAgICB2YXIgaG9zdFByb3RvVmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxQcm90b1ZpZXcoaG9zdFByb3RvVmlld1JlZik7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9WaWV3RmFjdG9yeS5pbml0aWFsaXplUHJvdG9WaWV3SWZOZWVkZWQoaG9zdFByb3RvVmlldyk7XHJcbiAgICAgICAgdmFyIGhvc3RFbGVtZW50U2VsZWN0b3IgPSBvdmVycmlkZVNlbGVjdG9yO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhob3N0RWxlbWVudFNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICBob3N0RWxlbWVudFNlbGVjdG9yID0gaG9zdFByb3RvVmlldy5lbGVtZW50QmluZGVyc1swXS5jb21wb25lbnREaXJlY3RpdmUubWV0YWRhdGEuc2VsZWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW5kZXJWaWV3V2l0aEZyYWdtZW50cyA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZVJvb3RIb3N0Vmlldyhob3N0UHJvdG9WaWV3LnJlbmRlciwgaG9zdFByb3RvVmlldy5tZXJnZUluZm8uZW1iZWRkZWRWaWV3Q291bnQgKyAxLCBob3N0RWxlbWVudFNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgaG9zdFZpZXcgPSB0aGlzLl9jcmVhdGVNYWluVmlldyhob3N0UHJvdG9WaWV3LCByZW5kZXJWaWV3V2l0aEZyYWdtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaHlkcmF0ZVZpZXcoaG9zdFZpZXcucmVuZGVyKTtcclxuICAgICAgICB0aGlzLl91dGlscy5oeWRyYXRlUm9vdEhvc3RWaWV3KGhvc3RWaWV3LCBpbmplY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVfMS53dGZMZWF2ZShzLCBob3N0Vmlldy5yZWYpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuZGVzdHJveVJvb3RIb3N0VmlldyA9IGZ1bmN0aW9uIChob3N0Vmlld1JlZikge1xyXG4gICAgICAgIC8vIE5vdGU6IERvbid0IHB1dCB0aGUgaG9zdFZpZXcgaW50byB0aGUgdmlldyBwb29sXHJcbiAgICAgICAgLy8gYXMgaXQgaXMgZGVwZW5kaW5nIG9uIHRoZSBlbGVtZW50IGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZC5cclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2Rlc3Ryb3lSb290SG9zdFZpZXdTY29wZSgpO1xyXG4gICAgICAgIHZhciBob3N0VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGhvc3RWaWV3UmVmKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXRhY2hGcmFnbWVudChob3N0Vmlldy5yZW5kZXJGcmFnbWVudCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGVoeWRyYXRlVmlldyhob3N0Vmlldy5yZW5kZXIpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdEZWh5ZHJhdGVSZWN1cnNlKGhvc3RWaWV3KTtcclxuICAgICAgICB0aGlzLl92aWV3TGlzdGVuZXIudmlld0Rlc3Ryb3llZChob3N0Vmlldyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGVzdHJveVZpZXcoaG9zdFZpZXcucmVuZGVyKTtcclxuICAgICAgICBwcm9maWxlXzEud3RmTGVhdmUocyk7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uICh2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4LCB0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlRW1iZWRkZWRWaWV3SW5Db250YWluZXJTY29wZSgpO1xyXG4gICAgICAgIHZhciBwcm90b1ZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsUHJvdG9WaWV3KHRlbXBsYXRlUmVmLnByb3RvVmlld1JlZik7XHJcbiAgICAgICAgaWYgKHByb3RvVmlldy50eXBlICE9PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkVNQkVEREVEKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggZW1iZWRkZWQgUHJvdG9WaWV3cyEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvdG9WaWV3RmFjdG9yeS5pbml0aWFsaXplUHJvdG9WaWV3SWZOZWVkZWQocHJvdG9WaWV3KTtcclxuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHRoaXMuX2NyZWF0ZVZpZXdJbkNvbnRhaW5lcih2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4LCBwcm90b1ZpZXcsIHRlbXBsYXRlUmVmLmVsZW1lbnRSZWYsIG51bGwpKTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmNyZWF0ZUhvc3RWaWV3SW5Db250YWluZXIgPSBmdW5jdGlvbiAodmlld0NvbnRhaW5lckxvY2F0aW9uLCBpbmRleCwgcHJvdG9WaWV3UmVmLCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2NyZWF0ZUhvc3RWaWV3SW5Db250YWluZXJTY29wZSgpO1xyXG4gICAgICAgIHZhciBwcm90b1ZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsUHJvdG9WaWV3KHByb3RvVmlld1JlZik7XHJcbiAgICAgICAgaWYgKHByb3RvVmlldy50eXBlICE9PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkhPU1QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdUaGlzIG1ldGhvZCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBob3N0IFByb3RvVmlld3MhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkuaW5pdGlhbGl6ZVByb3RvVmlld0lmTmVlZGVkKHByb3RvVmlldyk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVfMS53dGZMZWF2ZShzLCB0aGlzLl9jcmVhdGVWaWV3SW5Db250YWluZXIodmlld0NvbnRhaW5lckxvY2F0aW9uLCBpbmRleCwgcHJvdG9WaWV3LCB2aWV3Q29udGFpbmVyTG9jYXRpb24sIGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvcikpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIFNlZSB7QGxpbmsgQXBwVmlld01hbmFnZXIjZGVzdHJveVZpZXdJbkNvbnRhaW5lcn0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fY3JlYXRlVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgsIHByb3RvVmlldywgY29udGV4dCwgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyh2aWV3Q29udGFpbmVyTG9jYXRpb24ucGFyZW50Vmlldyk7XHJcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gdmlld0NvbnRhaW5lckxvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgIHZhciBjb250ZXh0VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGNvbnRleHQucGFyZW50Vmlldyk7XHJcbiAgICAgICAgdmFyIGNvbnRleHRCb3VuZEVsZW1lbnRJbmRleCA9IGNvbnRleHQuYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdmFyIGVtYmVkZGVkRnJhZ21lbnRWaWV3ID0gY29udGV4dFZpZXcuZ2V0TmVzdGVkVmlldyhjb250ZXh0Qm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgIHZhciB2aWV3O1xyXG4gICAgICAgIGlmIChwcm90b1ZpZXcudHlwZSA9PT0gdmlld01vZHVsZS5WaWV3VHlwZS5FTUJFRERFRCAmJiBsYW5nXzEuaXNQcmVzZW50KGVtYmVkZGVkRnJhZ21lbnRWaWV3KSAmJlxyXG4gICAgICAgICAgICAhZW1iZWRkZWRGcmFnbWVudFZpZXcuaHlkcmF0ZWQoKSkge1xyXG4gICAgICAgICAgICAvLyBDYXNlIDE6IGluc3RhbnRpYXRlIHRoZSBmaXJzdCB2aWV3IG9mIGEgdGVtcGxhdGUgdGhhdCBoYXMgYmVlbiBtZXJnZWQgaW50byBhIHBhcmVudFxyXG4gICAgICAgICAgICB2aWV3ID0gZW1iZWRkZWRGcmFnbWVudFZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaFJlbmRlclZpZXcocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGluZGV4LCB2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENhc2UgMjogaW5zdGFudGlhdGUgYW5vdGhlciBjb3B5IG9mIHRoZSB0ZW1wbGF0ZSBvciBhIGhvc3QgUHJvdG9WaWV3LlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2VwYXJhdGUgY2FzZVxyXG4gICAgICAgICAgICAvLyBhcyB3ZSBvbmx5IGlubGluZSBvbmUgY29weSBvZiB0aGUgdGVtcGxhdGUgaW50byB0aGUgcGFyZW50IHZpZXcuXHJcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLl9jcmVhdGVQb29sZWRWaWV3KHByb3RvVmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaFJlbmRlclZpZXcocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGluZGV4LCB2aWV3KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuaHlkcmF0ZVZpZXcodmlldy5yZW5kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91dGlscy5hdHRhY2hWaWV3SW5Db250YWluZXIocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGNvbnRleHRWaWV3LCBjb250ZXh0Qm91bmRFbGVtZW50SW5kZXgsIGluZGV4LCB2aWV3KTtcclxuICAgICAgICB0aGlzLl91dGlscy5oeWRyYXRlVmlld0luQ29udGFpbmVyKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBjb250ZXh0VmlldywgY29udGV4dEJvdW5kRWxlbWVudEluZGV4LCBpbmRleCwgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKTtcclxuICAgICAgICByZXR1cm4gdmlldy5yZWY7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fYXR0YWNoUmVuZGVyVmlldyA9IGZ1bmN0aW9uIChwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpIHtcclxuICAgICAgICB2YXIgZWxlbWVudFJlZiA9IHBhcmVudFZpZXcuZWxlbWVudFJlZnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hdHRhY2hGcmFnbWVudEFmdGVyRWxlbWVudChlbGVtZW50UmVmLCB2aWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IHBhcmVudFZpZXcudmlld0NvbnRhaW5lcnNbYm91bmRFbGVtZW50SW5kZXhdLnZpZXdzW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmF0dGFjaEZyYWdtZW50QWZ0ZXJGcmFnbWVudChwcmV2Vmlldy5yZW5kZXJGcmFnbWVudCwgdmlldy5yZW5kZXJGcmFnbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuZGVzdHJveVZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uICh2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9kZXN0cm95Vmlld0luQ29udGFpbmVyU2NvcGUoKTtcclxuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KHZpZXdDb250YWluZXJMb2NhdGlvbi5wYXJlbnRWaWV3KTtcclxuICAgICAgICB2YXIgYm91bmRFbGVtZW50SW5kZXggPSB2aWV3Q29udGFpbmVyTG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveVZpZXdJbkNvbnRhaW5lcihwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPKGkpOiByZWZhY3RvciBkZXRhY2hWaWV3SW5Db250YWluZXIrYXR0YWNoVmlld0luQ29udGFpbmVyIHRvIG1vdmVWaWV3SW5Db250YWluZXJcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuYXR0YWNoVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgsIHZpZXdSZWYpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2F0dGFjaFZpZXdJbkNvbnRhaW5lclNjb3BlKCk7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyh2aWV3UmVmKTtcclxuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KHZpZXdDb250YWluZXJMb2NhdGlvbi5wYXJlbnRWaWV3KTtcclxuICAgICAgICB2YXIgYm91bmRFbGVtZW50SW5kZXggPSB2aWV3Q29udGFpbmVyTG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiB0aGUgcHVibGljIG1ldGhvZHMgYXR0YWNoVmlld0luQ29udGFpbmVyL2RldGFjaFZpZXdJbkNvbnRhaW5lclxyXG4gICAgICAgIC8vIGFyZSB1c2VkIGZvciBtb3ZpbmcgZWxlbWVudHMgd2l0aG91dCB0aGUgc2FtZSBjb250YWluZXIuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCBjaGFuZ2UgdGhpcyBpbnRvIGFuIGF0b21pYyBgbW92ZWAgb3BlcmF0aW9uLCB3aGljaCBzaG91bGQgcHJlc2VydmUgdGhlXHJcbiAgICAgICAgLy8gcHJldmlvdXMgcGFyZW50IGluamVjdG9yIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTM3NykuXHJcbiAgICAgICAgLy8gUmlnaHQgbm93IHdlIGFyZSBkZXN0cm95aW5nIGFueSBzcGVjaWFsXHJcbiAgICAgICAgLy8gY29udGV4dCB2aWV3IHRoYXQgbWlnaHQgaGF2ZSBiZWVuIHVzZWQuXHJcbiAgICAgICAgdGhpcy5fdXRpbHMuYXR0YWNoVmlld0luQ29udGFpbmVyKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBudWxsLCBudWxsLCBpbmRleCwgdmlldyk7XHJcbiAgICAgICAgdGhpcy5fYXR0YWNoUmVuZGVyVmlldyhwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpO1xyXG4gICAgICAgIHJldHVybiBwcm9maWxlXzEud3RmTGVhdmUocywgdmlld1JlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETyhpKTogcmVmYWN0b3IgZGV0YWNoVmlld0luQ29udGFpbmVyK2F0dGFjaFZpZXdJbkNvbnRhaW5lciB0byBtb3ZlVmlld0luQ29udGFpbmVyXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmRldGFjaFZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uICh2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9kZXRhY2hWaWV3SW5Db250YWluZXJTY29wZSgpO1xyXG4gICAgICAgIHZhciBwYXJlbnRWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcodmlld0NvbnRhaW5lckxvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IHZpZXdDb250YWluZXJMb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHBhcmVudFZpZXcudmlld0NvbnRhaW5lcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdmlld0NvbnRhaW5lci52aWV3c1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5fdXRpbHMuZGV0YWNoVmlld0luQ29udGFpbmVyKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGV0YWNoRnJhZ21lbnQodmlldy5yZW5kZXJGcmFnbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVfMS53dGZMZWF2ZShzLCB2aWV3LnJlZik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fY3JlYXRlTWFpblZpZXcgPSBmdW5jdGlvbiAocHJvdG9WaWV3LCByZW5kZXJWaWV3V2l0aEZyYWdtZW50cykge1xyXG4gICAgICAgIHZhciBtZXJnZWRQYXJlbnRWaWV3ID0gdGhpcy5fdXRpbHMuY3JlYXRlVmlldyhwcm90b1ZpZXcsIHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzLCB0aGlzLCB0aGlzLl9yZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RXZlbnREaXNwYXRjaGVyKG1lcmdlZFBhcmVudFZpZXcucmVuZGVyLCBtZXJnZWRQYXJlbnRWaWV3KTtcclxuICAgICAgICB0aGlzLl92aWV3TGlzdGVuZXIudmlld0NyZWF0ZWQobWVyZ2VkUGFyZW50Vmlldyk7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlZFBhcmVudFZpZXc7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fY3JlYXRlUG9vbGVkVmlldyA9IGZ1bmN0aW9uIChwcm90b1ZpZXcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX3ZpZXdQb29sLmdldFZpZXcocHJvdG9WaWV3KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlldykpIHtcclxuICAgICAgICAgICAgdmlldyA9IHRoaXMuX2NyZWF0ZU1haW5WaWV3KHByb3RvVmlldywgdGhpcy5fcmVuZGVyZXIuY3JlYXRlVmlldyhwcm90b1ZpZXcucmVuZGVyLCBwcm90b1ZpZXcubWVyZ2VJbmZvLmVtYmVkZGVkVmlld0NvdW50ICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlldztcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLl9kZXN0cm95UG9vbGVkVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmFyIHdhc1JldHVybmVkID0gdGhpcy5fdmlld1Bvb2wucmV0dXJuVmlldyh2aWV3KTtcclxuICAgICAgICBpZiAoIXdhc1JldHVybmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdMaXN0ZW5lci52aWV3RGVzdHJveWVkKHZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXN0cm95Vmlldyh2aWV3LnJlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuX2Rlc3Ryb3lWaWV3SW5Db250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBwYXJlbnRWaWV3LnZpZXdDb250YWluZXJzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdDb250YWluZXIudmlld3NbaW5kZXhdO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdEZWh5ZHJhdGVSZWN1cnNlKHZpZXcpO1xyXG4gICAgICAgIHRoaXMuX3V0aWxzLmRldGFjaFZpZXdJbkNvbnRhaW5lcihwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIGlmICh2aWV3LnZpZXdPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENhc2UgMTogYSB2aWV3IHRoYXQgaXMgcGFydCBvZiBhbm90aGVyIHZpZXcuXHJcbiAgICAgICAgICAgIC8vIEp1c3QgZGV0YWNoIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXRhY2hGcmFnbWVudCh2aWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENhc2UgMjogYSB2aWV3IHRoYXQgaXMgbm90IHBhcnQgb2YgYW5vdGhlciB2aWV3LlxyXG4gICAgICAgICAgICAvLyBkZWh5ZHJhdGUgYW5kIGRlc3Ryb3kgaXQuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmRlaHlkcmF0ZVZpZXcodmlldy5yZW5kZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXRhY2hGcmFnbWVudCh2aWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBvb2xlZFZpZXcodmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuX3ZpZXdEZWh5ZHJhdGVSZWN1cnNlID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICBpZiAodmlldy5oeWRyYXRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3V0aWxzLmRlaHlkcmF0ZVZpZXcodmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVycyA9IHZpZXcudmlld0NvbnRhaW5lcnM7XHJcbiAgICAgICAgdmFyIHN0YXJ0Vmlld09mZnNldCA9IHZpZXcudmlld09mZnNldDtcclxuICAgICAgICB2YXIgZW5kVmlld09mZnNldCA9IHZpZXcudmlld09mZnNldCArIHZpZXcucHJvdG8ubWVyZ2VJbmZvLnZpZXdDb3VudCAtIDE7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQgPSB2aWV3LmVsZW1lbnRPZmZzZXQ7XHJcbiAgICAgICAgZm9yICh2YXIgdmlld0lkeCA9IHN0YXJ0Vmlld09mZnNldDsgdmlld0lkeCA8PSBlbmRWaWV3T2Zmc2V0OyB2aWV3SWR4KyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJWaWV3ID0gdmlldy52aWV3c1t2aWV3SWR4XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYmluZGVySWR4ID0gMDsgYmluZGVySWR4IDwgY3VyclZpZXcucHJvdG8uZWxlbWVudEJpbmRlcnMubGVuZ3RoOyBiaW5kZXJJZHgrKywgZWxlbWVudE9mZnNldCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmMgPSB2aWV3Q29udGFpbmVyc1tlbGVtZW50T2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZjKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSB2Yy52aWV3cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95Vmlld0luQ29udGFpbmVyKGN1cnJWaWV3LCBlbGVtZW50T2Zmc2V0LCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJfID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19wYXJhbSg0LCBkaV8xLkluamVjdChkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9fdmlld19mYWN0b3J5XzEuUHJvdG9WaWV3RmFjdG9yeTsgfSkpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbdmlld19wb29sXzEuQXBwVmlld1Bvb2wsIHZpZXdfbGlzdGVuZXJfMS5BcHBWaWV3TGlzdGVuZXIsIHZpZXdfbWFuYWdlcl91dGlsc18xLkFwcFZpZXdNYW5hZ2VyVXRpbHMsIGFwaV8xLlJlbmRlcmVyLCBPYmplY3RdKVxyXG4gICAgXSwgQXBwVmlld01hbmFnZXJfKTtcclxuICAgIHJldHVybiBBcHBWaWV3TWFuYWdlcl87XHJcbn0pKEFwcFZpZXdNYW5hZ2VyKTtcclxuZXhwb3J0cy5BcHBWaWV3TWFuYWdlcl8gPSBBcHBWaWV3TWFuYWdlcl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfbWFuYWdlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGVsaSA9IHJlcXVpcmUoJy4vZWxlbWVudF9pbmplY3RvcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHZpZXdNb2R1bGUgPSByZXF1aXJlKCcuL3ZpZXcnKTtcclxudmFyIGVsZW1lbnRfcmVmXzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfcmVmJyk7XHJcbnZhciB0ZW1wbGF0ZV9yZWZfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfcmVmJyk7XHJcbnZhciBwaXBlc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvcGlwZXMnKTtcclxudmFyIEFwcFZpZXdNYW5hZ2VyVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwVmlld01hbmFnZXJVdGlscygpIHtcclxuICAgIH1cclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLmdldENvbXBvbmVudEluc3RhbmNlID0gZnVuY3Rpb24gKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIGVsaSA9IHBhcmVudFZpZXcuZWxlbWVudEluamVjdG9yc1tib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGVsaS5nZXRDb21wb25lbnQoKTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKG1lcmdlZFBhcmVudFZpZXdQcm90bywgcmVuZGVyVmlld1dpdGhGcmFnbWVudHMsIHZpZXdNYW5hZ2VyLCByZW5kZXJlcikge1xyXG4gICAgICAgIHZhciByZW5kZXJGcmFnbWVudHMgPSByZW5kZXJWaWV3V2l0aEZyYWdtZW50cy5mcmFnbWVudFJlZnM7XHJcbiAgICAgICAgdmFyIHJlbmRlclZpZXcgPSByZW5kZXJWaWV3V2l0aEZyYWdtZW50cy52aWV3UmVmO1xyXG4gICAgICAgIHZhciBlbGVtZW50Q291bnQgPSBtZXJnZWRQYXJlbnRWaWV3UHJvdG8ubWVyZ2VJbmZvLmVsZW1lbnRDb3VudDtcclxuICAgICAgICB2YXIgdmlld0NvdW50ID0gbWVyZ2VkUGFyZW50Vmlld1Byb3RvLm1lcmdlSW5mby52aWV3Q291bnQ7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRSZWZzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShlbGVtZW50Q291bnQpO1xyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVycyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUoZWxlbWVudENvdW50KTtcclxuICAgICAgICB2YXIgcHJlQnVpbHRPYmplY3RzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShlbGVtZW50Q291bnQpO1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3JzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShlbGVtZW50Q291bnQpO1xyXG4gICAgICAgIHZhciB2aWV3cyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodmlld0NvdW50KTtcclxuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHRleHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciBmcmFnbWVudElkeCA9IDA7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsZW1lbnRJbmRpY2VzQnlWaWV3SW5kZXggPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHZpZXdDb3VudCk7XHJcbiAgICAgICAgZm9yICh2YXIgdmlld09mZnNldCA9IDA7IHZpZXdPZmZzZXQgPCB2aWV3Q291bnQ7IHZpZXdPZmZzZXQrKykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudEluZGV4ID0gY29udGFpbmVyRWxlbWVudEluZGljZXNCeVZpZXdJbmRleFt2aWV3T2Zmc2V0XTtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckVsZW1lbnRJbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyRWxlbWVudEluZGV4KSA/IGVsZW1lbnRJbmplY3RvcnNbY29udGFpbmVyRWxlbWVudEluZGV4XSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRWaWV3ID0gbGFuZ18xLmlzUHJlc2VudChjb250YWluZXJFbGVtZW50SW5qZWN0b3IpID8gcHJlQnVpbHRPYmplY3RzW2NvbnRhaW5lckVsZW1lbnRJbmRleF0udmlldyA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBwcm90b1ZpZXcgPSBsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lckVsZW1lbnRJbmRleCkgP1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Vmlldy5wcm90by5lbGVtZW50QmluZGVyc1tjb250YWluZXJFbGVtZW50SW5kZXggLSBwYXJlbnRWaWV3LmVsZW1lbnRPZmZzZXRdXHJcbiAgICAgICAgICAgICAgICAgICAgLm5lc3RlZFByb3RvVmlldyA6XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRQYXJlbnRWaWV3UHJvdG87XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJGcmFnbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh2aWV3T2Zmc2V0ID09PSAwIHx8IHByb3RvVmlldy50eXBlID09PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkVNQkVEREVEKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJGcmFnbWVudCA9IHJlbmRlckZyYWdtZW50c1tmcmFnbWVudElkeCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VycmVudFZpZXcgPSBuZXcgdmlld01vZHVsZS5BcHBWaWV3KHJlbmRlcmVyLCBwcm90b1ZpZXcsIHZpZXdPZmZzZXQsIGVsZW1lbnRPZmZzZXQsIHRleHRPZmZzZXQsIHByb3RvVmlldy5wcm90b0xvY2FscywgcmVuZGVyVmlldywgcmVuZGVyRnJhZ21lbnQsIGNvbnRhaW5lckVsZW1lbnRJbmplY3Rvcik7XHJcbiAgICAgICAgICAgIHZpZXdzW3ZpZXdPZmZzZXRdID0gY3VycmVudFZpZXc7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lckVsZW1lbnRJbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIHByZUJ1aWx0T2JqZWN0c1tjb250YWluZXJFbGVtZW50SW5kZXhdLm5lc3RlZFZpZXcgPSBjdXJyZW50VmlldztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnRJbmplY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG5lc3RlZFZpZXdPZmZzZXQgPSB2aWV3T2Zmc2V0ICsgMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYmluZGVySWR4ID0gMDsgYmluZGVySWR4IDwgcHJvdG9WaWV3LmVsZW1lbnRCaW5kZXJzLmxlbmd0aDsgYmluZGVySWR4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kZXIgPSBwcm90b1ZpZXcuZWxlbWVudEJpbmRlcnNbYmluZGVySWR4XTtcclxuICAgICAgICAgICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IGVsZW1lbnRPZmZzZXQgKyBiaW5kZXJJZHg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEluamVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRlci5uZXN0ZWRQcm90b1ZpZXcpICYmIGJpbmRlci5uZXN0ZWRQcm90b1ZpZXcuaXNNZXJnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnRJbmRpY2VzQnlWaWV3SW5kZXhbbmVzdGVkVmlld09mZnNldF0gPSBib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3T2Zmc2V0ICs9IGJpbmRlci5uZXN0ZWRQcm90b1ZpZXcubWVyZ2VJbmZvLnZpZXdDb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRJbmplY3RvcnMgYW5kIHJvb3RFbGVtZW50SW5qZWN0b3JzXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG9FbGVtZW50SW5qZWN0b3IgPSBiaW5kZXIucHJvdG9FbGVtZW50SW5qZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm90b0VsZW1lbnRJbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm90b0VsZW1lbnRJbmplY3Rvci5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50SW5qZWN0b3IgPSBlbGVtZW50SW5qZWN0b3JzW2VsZW1lbnRPZmZzZXQgKyBwcm90b0VsZW1lbnRJbmplY3Rvci5wYXJlbnQuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5qZWN0b3IgPSBwcm90b0VsZW1lbnRJbmplY3Rvci5pbnN0YW50aWF0ZShwYXJlbnRFbGVtZW50SW5qZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluamVjdG9yID0gcHJvdG9FbGVtZW50SW5qZWN0b3IuaW5zdGFudGlhdGUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50SW5qZWN0b3JzLnB1c2goZWxlbWVudEluamVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50SW5qZWN0b3JzW2JvdW5kRWxlbWVudEluZGV4XSA9IGVsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRSZWZzXHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBuZXcgZWxlbWVudF9yZWZfMS5FbGVtZW50UmVmXyhjdXJyZW50Vmlldy5yZWYsIGJvdW5kRWxlbWVudEluZGV4LCByZW5kZXJlcik7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVmc1tlbC5ib3VuZEVsZW1lbnRJbmRleF0gPSBlbDtcclxuICAgICAgICAgICAgICAgIC8vIHByZUJ1aWx0T2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVJlZiA9IGxhbmdfMS5pc1ByZXNlbnQoYmluZGVyLm5lc3RlZFByb3RvVmlldykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGVyLm5lc3RlZFByb3RvVmlldy50eXBlID09PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkVNQkVEREVEID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHRlbXBsYXRlX3JlZl8xLlRlbXBsYXRlUmVmXyhlbCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZUJ1aWx0T2JqZWN0c1tib3VuZEVsZW1lbnRJbmRleF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgZWxpLlByZUJ1aWx0T2JqZWN0cyh2aWV3TWFuYWdlciwgY3VycmVudFZpZXcsIGVsLCB0ZW1wbGF0ZVJlZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudFZpZXcuaW5pdChwcm90b1ZpZXcuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5KGN1cnJlbnRWaWV3KSwgZWxlbWVudEluamVjdG9ycywgcm9vdEVsZW1lbnRJbmplY3RvcnMsIHByZUJ1aWx0T2JqZWN0cywgdmlld3MsIGVsZW1lbnRSZWZzLCB2aWV3Q29udGFpbmVycyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudFZpZXcpICYmIHByb3RvVmlldy50eXBlID09PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkNPTVBPTkVOVCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Vmlldy5jaGFuZ2VEZXRlY3Rvci5hZGRTaGFkb3dEb21DaGlsZChjdXJyZW50Vmlldy5jaGFuZ2VEZXRlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudE9mZnNldCArPSBwcm90b1ZpZXcuZWxlbWVudEJpbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ICs9IHByb3RvVmlldy50ZXh0QmluZGluZ0NvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld3NbMF07XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuaHlkcmF0ZVJvb3RIb3N0VmlldyA9IGZ1bmN0aW9uIChob3N0VmlldywgaW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9oeWRyYXRlVmlldyhob3N0VmlldywgaW5qZWN0b3IsIG51bGwsIG5ldyBPYmplY3QoKSwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gTWlzbm9tZXI6IHRoaXMgbWV0aG9kIGlzIGF0dGFjaGluZyBuZXh0IHRvIHRoZSB2aWV3IGNvbnRhaW5lci5cclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLmF0dGFjaFZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgY29udGV4dFZpZXcsIGNvbnRleHRCb3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29udGV4dFZpZXcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHRWaWV3ID0gcGFyZW50VmlldztcclxuICAgICAgICAgICAgY29udGV4dEJvdW5kRWxlbWVudEluZGV4ID0gYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudFZpZXcuY2hhbmdlRGV0ZWN0b3IuYWRkQ2hpbGQodmlldy5jaGFuZ2VEZXRlY3Rvcik7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBwYXJlbnRWaWV3LnZpZXdDb250YWluZXJzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlld0NvbnRhaW5lcikpIHtcclxuICAgICAgICAgICAgdmlld0NvbnRhaW5lciA9IG5ldyB2aWV3TW9kdWxlLkFwcFZpZXdDb250YWluZXIoKTtcclxuICAgICAgICAgICAgcGFyZW50Vmlldy52aWV3Q29udGFpbmVyc1tib3VuZEVsZW1lbnRJbmRleF0gPSB2aWV3Q29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaW5zZXJ0KHZpZXdDb250YWluZXIudmlld3MsIGluZGV4LCB2aWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudEluamVjdG9yID0gY29udGV4dFZpZXcuZWxlbWVudEluamVjdG9yc1tjb250ZXh0Qm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB2aWV3LnJvb3RFbGVtZW50SW5qZWN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnRJbmplY3Rvci5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnJvb3RFbGVtZW50SW5qZWN0b3JzW2ldLmxpbmsoZWxlbWVudEluamVjdG9yLnBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudEluamVjdG9yLnRyYXZlcnNlQW5kU2V0UXVlcmllc0FzRGlydHkoKTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5kZXRhY2hWaWV3SW5Db250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBwYXJlbnRWaWV3LnZpZXdDb250YWluZXJzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdDb250YWluZXIudmlld3NbaW5kZXhdO1xyXG4gICAgICAgIHBhcmVudFZpZXcuZWxlbWVudEluamVjdG9yc1tib3VuZEVsZW1lbnRJbmRleF0udHJhdmVyc2VBbmRTZXRRdWVyaWVzQXNEaXJ0eSgpO1xyXG4gICAgICAgIHZpZXcuY2hhbmdlRGV0ZWN0b3IucmVtb3ZlKCk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZUF0KHZpZXdDb250YWluZXIudmlld3MsIGluZGV4KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcucm9vdEVsZW1lbnRJbmplY3RvcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGluaiA9IHZpZXcucm9vdEVsZW1lbnRJbmplY3RvcnNbaV07XHJcbiAgICAgICAgICAgIGluai51bmxpbmsoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuaHlkcmF0ZVZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgY29udGV4dFZpZXcsIGNvbnRleHRCb3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIGltcGVyYXRpdmVseUNyZWF0ZWRQcm92aWRlcnMpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29udGV4dFZpZXcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHRWaWV3ID0gcGFyZW50VmlldztcclxuICAgICAgICAgICAgY29udGV4dEJvdW5kRWxlbWVudEluZGV4ID0gYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gcGFyZW50Vmlldy52aWV3Q29udGFpbmVyc1tib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3Q29udGFpbmVyLnZpZXdzW2luZGV4XTtcclxuICAgICAgICB2YXIgZWxlbWVudEluamVjdG9yID0gY29udGV4dFZpZXcuZWxlbWVudEluamVjdG9yc1tjb250ZXh0Qm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHZhciBpbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQoaW1wZXJhdGl2ZWx5Q3JlYXRlZFByb3ZpZGVycykgP1xyXG4gICAgICAgICAgICBkaV8xLkluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhpbXBlcmF0aXZlbHlDcmVhdGVkUHJvdmlkZXJzKSA6XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgdGhpcy5faHlkcmF0ZVZpZXcodmlldywgaW5qZWN0b3IsIGVsZW1lbnRJbmplY3Rvci5nZXRIb3N0KCksIGNvbnRleHRWaWV3LmNvbnRleHQsIGNvbnRleHRWaWV3LmxvY2Fscyk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuX2h5ZHJhdGVWaWV3ID0gZnVuY3Rpb24gKGluaXRWaWV3LCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IsIGhvc3RFbGVtZW50SW5qZWN0b3IsIGNvbnRleHQsIHBhcmVudExvY2Fscykge1xyXG4gICAgICAgIHZhciB2aWV3SWR4ID0gaW5pdFZpZXcudmlld09mZnNldDtcclxuICAgICAgICB2YXIgZW5kVmlld09mZnNldCA9IHZpZXdJZHggKyBpbml0Vmlldy5wcm90by5tZXJnZUluZm8udmlld0NvdW50IC0gMTtcclxuICAgICAgICB3aGlsZSAodmlld0lkeCA8PSBlbmRWaWV3T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyVmlldyA9IGluaXRWaWV3LnZpZXdzW3ZpZXdJZHhdO1xyXG4gICAgICAgICAgICB2YXIgY3VyclByb3RvVmlldyA9IGN1cnJWaWV3LnByb3RvO1xyXG4gICAgICAgICAgICBpZiAoY3VyclZpZXcgIT09IGluaXRWaWV3ICYmIGN1cnJWaWV3LnByb3RvLnR5cGUgPT09IHZpZXdNb2R1bGUuVmlld1R5cGUuRU1CRURERUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGh5ZHJhdGUgY29tcG9uZW50cyBvZiBlbWJlZGRlZCBmcmFnbWVudCB2aWV3cy5cclxuICAgICAgICAgICAgICAgIHZpZXdJZHggKz0gY3VyclZpZXcucHJvdG8ubWVyZ2VJbmZvLnZpZXdDb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyVmlldyAhPT0gaW5pdFZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoeWRyYXRlIGEgbmVzdGVkIGNvbXBvbmVudCB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRMb2NhbHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50SW5qZWN0b3IgPSBjdXJyVmlldy5jb250YWluZXJFbGVtZW50SW5qZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGhvc3RFbGVtZW50SW5qZWN0b3IuZ2V0Q29tcG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyVmlldy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGN1cnJWaWV3LmxvY2Fscy5wYXJlbnQgPSBwYXJlbnRMb2NhbHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluZGVycyA9IGN1cnJQcm90b1ZpZXcuZWxlbWVudEJpbmRlcnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaW5kZXJJZHggPSAwOyBiaW5kZXJJZHggPCBiaW5kZXJzLmxlbmd0aDsgYmluZGVySWR4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRFbGVtZW50SW5kZXggPSBiaW5kZXJJZHggKyBjdXJyVmlldy5lbGVtZW50T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3IgPSBpbml0Vmlldy5lbGVtZW50SW5qZWN0b3JzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50SW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJbmplY3Rvci5oeWRyYXRlKGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvciwgaG9zdEVsZW1lbnRJbmplY3RvciwgY3VyclZpZXcucHJlQnVpbHRPYmplY3RzW2JvdW5kRWxlbWVudEluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlVmlld0xvY2FscyhjdXJyVmlldywgZWxlbWVudEluamVjdG9yLCBib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwRXZlbnRFbWl0dGVycyhjdXJyVmlldywgZWxlbWVudEluamVjdG9yLCBib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBpcGVzID0gbGFuZ18xLmlzUHJlc2VudChob3N0RWxlbWVudEluamVjdG9yKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IHBpcGVzXzEuUGlwZXMoY3VyclZpZXcucHJvdG8ucGlwZXMsIGhvc3RFbGVtZW50SW5qZWN0b3IuZ2V0SW5qZWN0b3IoKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICBjdXJyVmlldy5jaGFuZ2VEZXRlY3Rvci5oeWRyYXRlKGN1cnJWaWV3LmNvbnRleHQsIGN1cnJWaWV3LmxvY2FscywgY3VyclZpZXcsIHBpcGVzKTtcclxuICAgICAgICAgICAgICAgIHZpZXdJZHgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5fcG9wdWxhdGVWaWV3TG9jYWxzID0gZnVuY3Rpb24gKHZpZXcsIGVsZW1lbnRJbmplY3RvciwgYm91bmRFbGVtZW50SWR4KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudEluamVjdG9yLmdldERpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MoKSkpIHtcclxuICAgICAgICAgICAgZWxlbWVudEluamVjdG9yLmdldERpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVJbmRleCwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGRpcmVjdGl2ZUluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcubG9jYWxzLnNldChuYW1lLCB2aWV3LmVsZW1lbnRSZWZzW2JvdW5kRWxlbWVudElkeF0ubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmxvY2Fscy5zZXQobmFtZSwgZWxlbWVudEluamVjdG9yLmdldERpcmVjdGl2ZUF0SW5kZXgoZGlyZWN0aXZlSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLl9zZXRVcEV2ZW50RW1pdHRlcnMgPSBmdW5jdGlvbiAodmlldywgZWxlbWVudEluamVjdG9yLCBib3VuZEVsZW1lbnRJbmRleCkge1xyXG4gICAgICAgIHZhciBlbWl0dGVycyA9IGVsZW1lbnRJbmplY3Rvci5nZXRFdmVudEVtaXR0ZXJBY2Nlc3NvcnMoKTtcclxuICAgICAgICBmb3IgKHZhciBkaXJlY3RpdmVJbmRleCA9IDA7IGRpcmVjdGl2ZUluZGV4IDwgZW1pdHRlcnMubGVuZ3RoOyArK2RpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVFbWl0dGVycyA9IGVtaXR0ZXJzW2RpcmVjdGl2ZUluZGV4XTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IGVsZW1lbnRJbmplY3Rvci5nZXREaXJlY3RpdmVBdEluZGV4KGRpcmVjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRJbmRleCA9IDA7IGV2ZW50SW5kZXggPCBkaXJlY3RpdmVFbWl0dGVycy5sZW5ndGg7ICsrZXZlbnRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RW1pdHRlckFjY2Vzc29yID0gZGlyZWN0aXZlRW1pdHRlcnNbZXZlbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXJBY2Nlc3Nvci5zdWJzY3JpYmUodmlldywgYm91bmRFbGVtZW50SW5kZXgsIGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuZGVoeWRyYXRlVmlldyA9IGZ1bmN0aW9uIChpbml0Vmlldykge1xyXG4gICAgICAgIHZhciBlbmRWaWV3T2Zmc2V0ID0gaW5pdFZpZXcudmlld09mZnNldCArIGluaXRWaWV3LnByb3RvLm1lcmdlSW5mby52aWV3Q291bnQgLSAxO1xyXG4gICAgICAgIGZvciAodmFyIHZpZXdJZHggPSBpbml0Vmlldy52aWV3T2Zmc2V0OyB2aWV3SWR4IDw9IGVuZFZpZXdPZmZzZXQ7IHZpZXdJZHgrKykge1xyXG4gICAgICAgICAgICB2YXIgY3VyclZpZXcgPSBpbml0Vmlldy52aWV3c1t2aWV3SWR4XTtcclxuICAgICAgICAgICAgaWYgKGN1cnJWaWV3Lmh5ZHJhdGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGN1cnJWaWV3LmxvY2FscykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyVmlldy5sb2NhbHMuY2xlYXJWYWx1ZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJWaWV3LmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY3VyclZpZXcuY2hhbmdlRGV0ZWN0b3IuZGVoeWRyYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluZGVycyA9IGN1cnJWaWV3LnByb3RvLmVsZW1lbnRCaW5kZXJzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmluZGVySWR4ID0gMDsgYmluZGVySWR4IDwgYmluZGVycy5sZW5ndGg7IGJpbmRlcklkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsaSA9IGluaXRWaWV3LmVsZW1lbnRJbmplY3RvcnNbY3VyclZpZXcuZWxlbWVudE9mZnNldCArIGJpbmRlcklkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGkuZGVoeWRyYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEFwcFZpZXdNYW5hZ2VyVXRpbHMpO1xyXG4gICAgcmV0dXJuIEFwcFZpZXdNYW5hZ2VyVXRpbHM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwVmlld01hbmFnZXJVdGlscyA9IEFwcFZpZXdNYW5hZ2VyVXRpbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfbWFuYWdlcl91dGlscy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZXhwb3J0cy5BUFBfVklFV19QT09MX0NBUEFDSVRZID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oJ0FwcFZpZXdQb29sLnZpZXdQb29sQ2FwYWNpdHknKSk7XHJcbnZhciBBcHBWaWV3UG9vbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBWaWV3UG9vbChwb29sQ2FwYWNpdHlQZXJQcm90b1ZpZXcpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcG9vbGVkVmlld3NQZXJQcm90b1ZpZXcgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Bvb2xDYXBhY2l0eVBlclByb3RvVmlldyA9IHBvb2xDYXBhY2l0eVBlclByb3RvVmlldztcclxuICAgIH1cclxuICAgIEFwcFZpZXdQb29sLnByb3RvdHlwZS5nZXRWaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlldykge1xyXG4gICAgICAgIHZhciBwb29sZWRWaWV3cyA9IHRoaXMuX3Bvb2xlZFZpZXdzUGVyUHJvdG9WaWV3LmdldChwcm90b1ZpZXcpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBvb2xlZFZpZXdzKSAmJiBwb29sZWRWaWV3cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb29sZWRWaWV3cy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld1Bvb2wucHJvdG90eXBlLnJldHVyblZpZXcgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZhciBwcm90b1ZpZXcgPSB2aWV3LnByb3RvO1xyXG4gICAgICAgIHZhciBwb29sZWRWaWV3cyA9IHRoaXMuX3Bvb2xlZFZpZXdzUGVyUHJvdG9WaWV3LmdldChwcm90b1ZpZXcpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwb29sZWRWaWV3cykpIHtcclxuICAgICAgICAgICAgcG9vbGVkVmlld3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fcG9vbGVkVmlld3NQZXJQcm90b1ZpZXcuc2V0KHByb3RvVmlldywgcG9vbGVkVmlld3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGF2ZVJlbWFpbmluZ0NhcGFjaXR5ID0gcG9vbGVkVmlld3MubGVuZ3RoIDwgdGhpcy5fcG9vbENhcGFjaXR5UGVyUHJvdG9WaWV3O1xyXG4gICAgICAgIGlmIChoYXZlUmVtYWluaW5nQ2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgcG9vbGVkVmlld3MucHVzaCh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhdmVSZW1haW5pbmdDYXBhY2l0eTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3UG9vbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5JbmplY3QoZXhwb3J0cy5BUFBfVklFV19QT09MX0NBUEFDSVRZKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBBcHBWaWV3UG9vbCk7XHJcbiAgICByZXR1cm4gQXBwVmlld1Bvb2w7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwVmlld1Bvb2wgPSBBcHBWaWV3UG9vbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19wb29sLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbi8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBwcml2YWN5IGluIERhcnQgYXMgd2UgZG9uJ3QgaGF2ZSBsaWJyYXJ5IHBhcnRzXHJcbmZ1bmN0aW9uIGludGVybmFsVmlldyh2aWV3UmVmKSB7XHJcbiAgICByZXR1cm4gdmlld1JlZi5fdmlldztcclxufVxyXG5leHBvcnRzLmludGVybmFsVmlldyA9IGludGVybmFsVmlldztcclxuLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHByaXZhY3kgaW4gRGFydCBhcyB3ZSBkb24ndCBoYXZlIGxpYnJhcnkgcGFydHNcclxuZnVuY3Rpb24gaW50ZXJuYWxQcm90b1ZpZXcocHJvdG9WaWV3UmVmKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChwcm90b1ZpZXdSZWYpID8gcHJvdG9WaWV3UmVmLl9wcm90b1ZpZXcgOiBudWxsO1xyXG59XHJcbmV4cG9ydHMuaW50ZXJuYWxQcm90b1ZpZXcgPSBpbnRlcm5hbFByb3RvVmlldztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBWaWV3LlxyXG4gKlxyXG4gKiA8IS0tIFRPRE86IG1vdmUgdGhlIG5leHQgdHdvIHBhcmFncmFwaHMgdG8gdGhlIGRldiBndWlkZSAtLT5cclxuICogQSBWaWV3IGlzIGEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIGFwcGxpY2F0aW9uIFVJLiBJdCBpcyB0aGUgc21hbGxlc3QgZ3JvdXBpbmcgb2ZcclxuICogRWxlbWVudHMgd2hpY2ggYXJlIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCB0b2dldGhlci5cclxuICpcclxuICogUHJvcGVydGllcyBvZiBlbGVtZW50cyBpbiBhIFZpZXcgY2FuIGNoYW5nZSwgYnV0IHRoZSBzdHJ1Y3R1cmUgKG51bWJlciBhbmQgb3JkZXIpIG9mIGVsZW1lbnRzIGluXHJcbiAqIGEgVmlldyBjYW5ub3QuIENoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb2YgRWxlbWVudHMgY2FuIG9ubHkgYmUgZG9uZSBieSBpbnNlcnRpbmcsIG1vdmluZyBvclxyXG4gKiByZW1vdmluZyBuZXN0ZWQgVmlld3MgdmlhIGEge0BsaW5rIFZpZXdDb250YWluZXJ9LiBFYWNoIFZpZXcgY2FuIGNvbnRhaW4gbWFueSBWaWV3IENvbnRhaW5lcnMuXHJcbiAqIDwhLS0gL1RPRE8gLS0+XHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogR2l2ZW4gdGhpcyB0ZW1wbGF0ZS4uLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cclxuICogPHVsPlxyXG4gKiAgIDxsaSAqbmctZm9yPVwidmFyIGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fTwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAuLi4gd2UgaGF2ZSB0d28ge0BsaW5rIFByb3RvVmlld1JlZn1zOlxyXG4gKlxyXG4gKiBPdXRlciB7QGxpbmsgUHJvdG9WaWV3UmVmfTpcclxuICogYGBgXHJcbiAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XHJcbiAqIDx1bD5cclxuICogICA8dGVtcGxhdGUgbmctZm9yIHZhci1pdGVtIFtuZy1mb3Itb2ZdPVwiaXRlbXNcIj48L3RlbXBsYXRlPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogSW5uZXIge0BsaW5rIFByb3RvVmlld1JlZn06XHJcbiAqIGBgYFxyXG4gKiAgIDxsaT57e2l0ZW19fTwvbGk+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RpY2UgdGhhdCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgaXMgYnJva2VuIGRvd24gaW50byB0d28gc2VwYXJhdGUge0BsaW5rIFByb3RvVmlld1JlZn1zLlxyXG4gKlxyXG4gKiBUaGUgb3V0ZXIvaW5uZXIge0BsaW5rIFByb3RvVmlld1JlZn1zIGFyZSB0aGVuIGFzc2VtYmxlZCBpbnRvIHZpZXdzIGxpa2Ugc286XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8IS0tIFZpZXdSZWY6IG91dGVyLTAgLS0+XHJcbiAqIENvdW50OiAyXHJcbiAqIDx1bD5cclxuICogICA8dGVtcGxhdGUgdmlldy1jb250YWluZXItcmVmPjwvdGVtcGxhdGU+XHJcbiAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0xIC0tPjxsaT5maXJzdDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMSAtLT5cclxuICogICA8IS0tIFZpZXdSZWY6IGlubmVyLTIgLS0+PGxpPnNlY29uZDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMiAtLT5cclxuICogPC91bD5cclxuICogPCEtLSAvVmlld1JlZjogb3V0ZXItMCAtLT5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgVmlld1JlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3UmVmKCkge1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWYucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFZpZXdSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVmlld1JlZiA9IFZpZXdSZWY7XHJcbnZhciBWaWV3UmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlld1JlZl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3UmVmXyhfdmlldykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcInJlbmRlclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGBSZW5kZXJWaWV3UmVmYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5yZW5kZXI7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJyZW5kZXJGcmFnbWVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGBSZW5kZXJGcmFnbWVudFJlZmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcucmVuZGVyRnJhZ21lbnQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGBDaGFuZ2VEZXRlY3RvclJlZmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IHRoaXMuX3ZpZXcuY2hhbmdlRGV0ZWN0b3IucmVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5zZXRMb2NhbCA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUsIHZhbHVlKSB7IHRoaXMuX3ZpZXcuc2V0TG9jYWwodmFyaWFibGVOYW1lLCB2YWx1ZSk7IH07XHJcbiAgICByZXR1cm4gVmlld1JlZl87XHJcbn0pKFZpZXdSZWYpO1xyXG5leHBvcnRzLlZpZXdSZWZfID0gVmlld1JlZl87XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIEFuZ3VsYXIgUHJvdG9WaWV3LlxyXG4gKlxyXG4gKiBBIFByb3RvVmlldyBpcyBhIHByb3RvdHlwaWNhbCB7QGxpbmsgVmlld1JlZiBWaWV3fSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgVGVtcGxhdGUgY29tcGlsYXRpb24gYW5kXHJcbiAqIGlzIHVzZWQgYnkgQW5ndWxhciB0byBlZmZpY2llbnRseSBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBWaWV3IGJhc2VkIG9uIHRoZSBjb21waWxlZCBUZW1wbGF0ZS5cclxuICpcclxuICogTW9zdCBQcm90b1ZpZXdzIGFyZSBjcmVhdGVkIGFuZCB1c2VkIGludGVybmFsbHkgYnkgQW5ndWxhciBhbmQgeW91IGRvbid0IG5lZWQgdG8ga25vdyBhYm91dCB0aGVtLFxyXG4gKiBleGNlcHQgaW4gYWR2YW5jZWQgdXNlLWNhc2VzIHdoZXJlIHlvdSBjb21waWxlIGNvbXBvbmVudHMgeW91cnNlbGYgdmlhIHRoZSBsb3ctbGV2ZWxcclxuICoge0BsaW5rIENvbXBpbGVyI2NvbXBpbGVJbkhvc3R9IEFQSS5cclxuICpcclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBHaXZlbiB0aGlzIHRlbXBsYXRlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cclxuICogPHVsPlxyXG4gKiAgIDxsaSAqbmctZm9yPVwidmFyIGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fTwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbmd1bGFyIGRlc3VnYXJzIGFuZCBjb21waWxlcyB0aGUgdGVtcGxhdGUgaW50byB0d28gUHJvdG9WaWV3czpcclxuICpcclxuICogT3V0ZXIgUHJvdG9WaWV3OlxyXG4gKiBgYGBcclxuICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBuZy1mb3IgdmFyLWl0ZW0gW25nLWZvci1vZl09XCJpdGVtc1wiPjwvdGVtcGxhdGU+XHJcbiAqIDwvdWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbm5lciBQcm90b1ZpZXc6XHJcbiAqIGBgYFxyXG4gKiAgIDxsaT57e2l0ZW19fTwvbGk+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RpY2UgdGhhdCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgaXMgYnJva2VuIGRvd24gaW50byB0d28gc2VwYXJhdGUgUHJvdG9WaWV3cy5cclxuICovXHJcbnZhciBQcm90b1ZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9WaWV3UmVmKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb3RvVmlld1JlZjtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm90b1ZpZXdSZWYgPSBQcm90b1ZpZXdSZWY7XHJcbnZhciBQcm90b1ZpZXdSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcm90b1ZpZXdSZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJvdG9WaWV3UmVmXyhfcHJvdG9WaWV3KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9WaWV3ID0gX3Byb3RvVmlldztcclxuICAgIH1cclxuICAgIHJldHVybiBQcm90b1ZpZXdSZWZfO1xyXG59KShQcm90b1ZpZXdSZWYpO1xyXG5leHBvcnRzLlByb3RvVmlld1JlZl8gPSBQcm90b1ZpZXdSZWZfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3X3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEvdmlldycpO1xyXG52YXIgZGlyZWN0aXZlc18xID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciBWaWV3UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlld1Jlc29sdmVyKCkge1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICB9XHJcbiAgICBWaWV3UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jYWNoZS5nZXQoY29tcG9uZW50KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlldykpIHtcclxuICAgICAgICAgICAgdmlldyA9IHRoaXMuX3Jlc29sdmUoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGNvbXBvbmVudCwgdmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3O1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFZpZXdSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIGNvbXBNZXRhO1xyXG4gICAgICAgIHZhciB2aWV3TWV0YTtcclxuICAgICAgICByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGNvbXBvbmVudCkuZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZiAobSBpbnN0YW5jZW9mIHZpZXdfMS5WaWV3TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdNZXRhID0gbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobSBpbnN0YW5jZW9mIGRpcmVjdGl2ZXNfMS5Db21wb25lbnRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29tcE1ldGEgPSBtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wTWV0YS50ZW1wbGF0ZSkgJiYgbGFuZ18xLmlzQmxhbmsoY29tcE1ldGEudGVtcGxhdGVVcmwpICYmIGxhbmdfMS5pc0JsYW5rKHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50ICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50KSArIFwiJyBtdXN0IGhhdmUgZWl0aGVyICd0ZW1wbGF0ZScsICd0ZW1wbGF0ZVVybCcsIG9yICdAVmlldycgc2V0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLnRlbXBsYXRlKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwidGVtcGxhdGVcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLnRlbXBsYXRlVXJsKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwidGVtcGxhdGVVcmxcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLmRpcmVjdGl2ZXMpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJkaXJlY3RpdmVzXCIsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS5waXBlcykgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudChcInBpcGVzXCIsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS5lbmNhcHN1bGF0aW9uKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwiZW5jYXBzdWxhdGlvblwiLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEuc3R5bGVzKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwic3R5bGVzXCIsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS5zdHlsZVVybHMpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJzdHlsZVVybHNcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdNZXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2aWV3XzEuVmlld01ldGFkYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogY29tcE1ldGEudGVtcGxhdGVVcmwsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGNvbXBNZXRhLnRlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGNvbXBNZXRhLmRpcmVjdGl2ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGlwZXM6IGNvbXBNZXRhLnBpcGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGNvbXBNZXRhLmVuY2Fwc3VsYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBjb21wTWV0YS5zdHlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBjb21wTWV0YS5zdHlsZVVybHNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBWaWV3IGRlY29yYXRvciBmb3VuZCBvbiBjb21wb25lbnQgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnQpICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdNZXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFZpZXdSZXNvbHZlci5wcm90b3R5cGUuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNvbXBvbmVudCAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGNvbXBvbmVudCkgKyBcIicgY2Fubm90IGhhdmUgYm90aCAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgYW5kICdAVmlldycgc2V0IGF0IHRoZSBzYW1lIHRpbWVcXFwiXCIpO1xyXG4gICAgfTtcclxuICAgIFZpZXdSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgVmlld1Jlc29sdmVyKTtcclxuICAgIHJldHVybiBWaWV3UmVzb2x2ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVmlld1Jlc29sdmVyID0gVmlld1Jlc29sdmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3X3Jlc29sdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogVGhpcyBpbmRpcmVjdGlvbiBpcyBuZWVkZWQgdG8gZnJlZSB1cCBDb21wb25lbnQsIGV0YyBzeW1ib2xzIGluIHRoZSBwdWJsaWMgQVBJXHJcbiAqIHRvIGJlIHVzZWQgYnkgdGhlIGRlY29yYXRvciB2ZXJzaW9ucyBvZiB0aGVzZSBhbm5vdGF0aW9ucy5cclxuICovXHJcbnZhciBkaV8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YS9kaScpO1xyXG5leHBvcnRzLlF1ZXJ5TWV0YWRhdGEgPSBkaV8xLlF1ZXJ5TWV0YWRhdGE7XHJcbmV4cG9ydHMuQ29udGVudENoaWxkcmVuTWV0YWRhdGEgPSBkaV8xLkNvbnRlbnRDaGlsZHJlbk1ldGFkYXRhO1xyXG5leHBvcnRzLkNvbnRlbnRDaGlsZE1ldGFkYXRhID0gZGlfMS5Db250ZW50Q2hpbGRNZXRhZGF0YTtcclxuZXhwb3J0cy5WaWV3Q2hpbGRyZW5NZXRhZGF0YSA9IGRpXzEuVmlld0NoaWxkcmVuTWV0YWRhdGE7XHJcbmV4cG9ydHMuVmlld1F1ZXJ5TWV0YWRhdGEgPSBkaV8xLlZpZXdRdWVyeU1ldGFkYXRhO1xyXG5leHBvcnRzLlZpZXdDaGlsZE1ldGFkYXRhID0gZGlfMS5WaWV3Q2hpbGRNZXRhZGF0YTtcclxuZXhwb3J0cy5BdHRyaWJ1dGVNZXRhZGF0YSA9IGRpXzEuQXR0cmlidXRlTWV0YWRhdGE7XHJcbnZhciBkaXJlY3RpdmVzXzEgPSByZXF1aXJlKCcuL21ldGFkYXRhL2RpcmVjdGl2ZXMnKTtcclxuZXhwb3J0cy5Db21wb25lbnRNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5Db21wb25lbnRNZXRhZGF0YTtcclxuZXhwb3J0cy5EaXJlY3RpdmVNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5EaXJlY3RpdmVNZXRhZGF0YTtcclxuZXhwb3J0cy5QaXBlTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuUGlwZU1ldGFkYXRhO1xyXG5leHBvcnRzLklucHV0TWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSW5wdXRNZXRhZGF0YTtcclxuZXhwb3J0cy5PdXRwdXRNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5PdXRwdXRNZXRhZGF0YTtcclxuZXhwb3J0cy5Ib3N0QmluZGluZ01ldGFkYXRhID0gZGlyZWN0aXZlc18xLkhvc3RCaW5kaW5nTWV0YWRhdGE7XHJcbmV4cG9ydHMuSG9zdExpc3RlbmVyTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSG9zdExpc3RlbmVyTWV0YWRhdGE7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCcuL21ldGFkYXRhL3ZpZXcnKTtcclxuZXhwb3J0cy5WaWV3TWV0YWRhdGEgPSB2aWV3XzEuVmlld01ldGFkYXRhO1xyXG5leHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uID0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uO1xyXG52YXIgZGlfMiA9IHJlcXVpcmUoJy4vbWV0YWRhdGEvZGknKTtcclxudmFyIGRpcmVjdGl2ZXNfMiA9IHJlcXVpcmUoJy4vbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xyXG52YXIgdmlld18yID0gcmVxdWlyZSgnLi9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCcuL3V0aWwvZGVjb3JhdG9ycycpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIENvbXBvbmVudE1ldGFkYXRhLlxyXG4vKipcclxuICogRGVjbGFyZSByZXVzYWJsZSBVSSBidWlsZGluZyBibG9ja3MgZm9yIGFuIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBFYWNoIEFuZ3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGEgc2luZ2xlIGBAQ29tcG9uZW50YCBhbmQgYXQgbGVhc3Qgb25lIGBAVmlld2AgYW5ub3RhdGlvbi4gVGhlXHJcbiAqIGBAQ29tcG9uZW50YFxyXG4gKiBhbm5vdGF0aW9uIHNwZWNpZmllcyB3aGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgYW5kIHdoaWNoIHByb3BlcnRpZXMgYW5kIGhvc3RMaXN0ZW5lcnMgaXRcclxuICogYmluZHMgdG8uXHJcbiAqXHJcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCBBbmd1bGFyXHJcbiAqIC0gY3JlYXRlcyBhIHNoYWRvdyBET00gZm9yIHRoZSBjb21wb25lbnQuXHJcbiAqIC0gbG9hZHMgdGhlIHNlbGVjdGVkIHRlbXBsYXRlIGludG8gdGhlIHNoYWRvdyBET00uXHJcbiAqIC0gY3JlYXRlcyBhbGwgdGhlIGluamVjdGFibGUgb2JqZWN0cyBjb25maWd1cmVkIHdpdGggYHByb3ZpZGVyc2AgYW5kIGB2aWV3UHJvdmlkZXJzYC5cclxuICpcclxuICogQWxsIHRlbXBsYXRlIGV4cHJlc3Npb25zIGFuZCBzdGF0ZW1lbnRzIGFyZSB0aGVuIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQFZpZXdgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgVmlld01ldGFkYXRhfS5cclxuICpcclxuICogIyMgTGlmZWN5Y2xlIGhvb2tzXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGNvbXBvbmVudCBjbGFzcyBpbXBsZW1lbnRzIHNvbWUge0BsaW5rIGFuZ3VsYXIyL2xpZmVjeWNsZV9ob29rc30gdGhlIGNhbGxiYWNrcyBhcmVcclxuICogY2FsbGVkIGJ5IHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGF0IGRlZmluZWQgcG9pbnRzIGluIHRpbWUgZHVyaW5nIHRoZSBsaWZlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBHcmVldCB7XHJcbiAqICAgbmFtZTogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5leHBvcnRzLkNvbXBvbmVudCA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5Db21wb25lbnRNZXRhZGF0YSwgZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5WaWV3ID0gZXhwb3J0cy5WaWV3OyB9KTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBEaXJlY3RpdmVNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERpcmVjdGl2ZXMgYWxsb3cgeW91IHRvIGF0dGFjaCBiZWhhdmlvciB0byBlbGVtZW50cyBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9cyB3aXRoIGFuIGVtYmVkZGVkIHZpZXcgYXJlIGNhbGxlZCB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9cy5cclxuICpcclxuICogQSBkaXJlY3RpdmUgY29uc2lzdHMgb2YgYSBzaW5nbGUgZGlyZWN0aXZlIGFubm90YXRpb24gYW5kIGEgY29udHJvbGxlciBjbGFzcy4gV2hlbiB0aGVcclxuICogZGlyZWN0aXZlJ3MgYHNlbGVjdG9yYCBtYXRjaGVzXHJcbiAqIGVsZW1lbnRzIGluIHRoZSBET00sIHRoZSBmb2xsb3dpbmcgc3RlcHMgb2NjdXI6XHJcbiAqXHJcbiAqIDEuIEZvciBlYWNoIGRpcmVjdGl2ZSwgdGhlIGBFbGVtZW50SW5qZWN0b3JgIGF0dGVtcHRzIHRvIHJlc29sdmUgdGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXHJcbiAqIGFyZ3VtZW50cy5cclxuICogMi4gQW5ndWxhciBpbnN0YW50aWF0ZXMgZGlyZWN0aXZlcyBmb3IgZWFjaCBtYXRjaGVkIGVsZW1lbnQgdXNpbmcgYEVsZW1lbnRJbmplY3RvcmAgaW4gYVxyXG4gKiBkZXB0aC1maXJzdCBvcmRlcixcclxuICogICAgYXMgZGVjbGFyZWQgaW4gdGhlIEhUTUwuXHJcbiAqXHJcbiAqICMjIFVuZGVyc3RhbmRpbmcgSG93IEluamVjdGlvbiBXb3Jrc1xyXG4gKlxyXG4gKiBUaGVyZSBhcmUgdGhyZWUgc3RhZ2VzIG9mIGluamVjdGlvbiByZXNvbHV0aW9uLlxyXG4gKiAtICpQcmUtZXhpc3RpbmcgSW5qZWN0b3JzKjpcclxuICogICAtIFRoZSB0ZXJtaW5hbCB7QGxpbmsgSW5qZWN0b3J9IGNhbm5vdCByZXNvbHZlIGRlcGVuZGVuY2llcy4gSXQgZWl0aGVyIHRocm93cyBhbiBlcnJvciBvciwgaWZcclxuICogdGhlIGRlcGVuZGVuY3kgd2FzXHJcbiAqICAgICBzcGVjaWZpZWQgYXMgYEBPcHRpb25hbGAsIHJldHVybnMgYG51bGxgLlxyXG4gKiAgIC0gVGhlIHBsYXRmb3JtIGluamVjdG9yIHJlc29sdmVzIGJyb3dzZXIgc2luZ2xldG9uIHJlc291cmNlcywgc3VjaCBhczogY29va2llcywgdGl0bGUsXHJcbiAqIGxvY2F0aW9uLCBhbmQgb3RoZXJzLlxyXG4gKiAtICpDb21wb25lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGl0cyBvd24ge0BsaW5rIEluamVjdG9yfSwgYW5kIHRoZXkgZm9sbG93XHJcbiAqIHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHlcclxuICogICAgIGFzIHRoZSBjb21wb25lbnQgaW5zdGFuY2VzIGluIHRoZSBET00uXHJcbiAqIC0gKkVsZW1lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGEgU2hhZG93IERPTS4gV2l0aGluIHRoZSBTaGFkb3cgRE9NIGVhY2hcclxuICogZWxlbWVudCBoYXMgYW4gYEVsZW1lbnRJbmplY3RvcmBcclxuICogICAgIHdoaWNoIGZvbGxvdyB0aGUgc2FtZSBwYXJlbnQtY2hpbGQgaGllcmFyY2h5IGFzIHRoZSBET00gZWxlbWVudHMgdGhlbXNlbHZlcy5cclxuICpcclxuICogV2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZCwgaXQgYWxzbyBtdXN0IGluc3RhbnRpYXRlIHRoZSBjb3JyZXNwb25kaW5nIGRpcmVjdGl2ZXMgaW4gYVxyXG4gKiBkZXB0aC1maXJzdCBvcmRlci4gVGhlXHJcbiAqIGN1cnJlbnQgYEVsZW1lbnRJbmplY3RvcmAgcmVzb2x2ZXMgdGhlIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcyBmb3IgZWFjaCBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqIEFuZ3VsYXIgdGhlbiByZXNvbHZlcyBkZXBlbmRlbmNpZXMgYXMgZm9sbG93cywgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhciBpbiB0aGVcclxuICoge0BsaW5rIFZpZXdNZXRhZGF0YX06XHJcbiAqXHJcbiAqIDEuIERlcGVuZGVuY2llcyBvbiB0aGUgY3VycmVudCBlbGVtZW50XHJcbiAqIDIuIERlcGVuZGVuY2llcyBvbiBlbGVtZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgU2hhZG93IERPTSBib3VuZGFyeVxyXG4gKiAzLiBEZXBlbmRlbmNpZXMgb24gY29tcG9uZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIHRoZSByb290IGNvbXBvbmVudFxyXG4gKiA0LiBEZXBlbmRlbmNpZXMgb24gcHJlLWV4aXN0aW5nIGluamVjdG9yc1xyXG4gKlxyXG4gKlxyXG4gKiBUaGUgYEVsZW1lbnRJbmplY3RvcmAgY2FuIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBlbGVtZW50LXNwZWNpZmljIHNwZWNpYWwgb2JqZWN0cywgb3IgaXQgY2FuXHJcbiAqIGRlbGVnYXRlIHRvIHRoZSBwYXJlbnRcclxuICogaW5qZWN0b3IuXHJcbiAqXHJcbiAqIFRvIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XHJcbiAqIC0gYGRpcmVjdGl2ZTpEaXJlY3RpdmVUeXBlYDogYSBkaXJlY3RpdmUgb24gdGhlIGN1cnJlbnQgZWxlbWVudCBvbmx5XHJcbiAqIC0gYEBIb3N0KCkgZGlyZWN0aXZlOkRpcmVjdGl2ZVR5cGVgOiBhbnkgZGlyZWN0aXZlIHRoYXQgbWF0Y2hlcyB0aGUgdHlwZSBiZXR3ZWVuIHRoZSBjdXJyZW50XHJcbiAqIGVsZW1lbnQgYW5kIHRoZVxyXG4gKiAgICBTaGFkb3cgRE9NIHJvb3QuXHJcbiAqIC0gYEBRdWVyeShEaXJlY3RpdmVUeXBlKSBxdWVyeTpRdWVyeUxpc3Q8RGlyZWN0aXZlVHlwZT5gOiBBIGxpdmUgY29sbGVjdGlvbiBvZiBkaXJlY3QgY2hpbGRcclxuICogZGlyZWN0aXZlcy5cclxuICogLSBgQFF1ZXJ5RGVzY2VuZGFudHMoRGlyZWN0aXZlVHlwZSkgcXVlcnk6UXVlcnlMaXN0PERpcmVjdGl2ZVR5cGU+YDogQSBsaXZlIGNvbGxlY3Rpb24gb2YgYW55XHJcbiAqIGNoaWxkIGRpcmVjdGl2ZXMuXHJcbiAqXHJcbiAqIFRvIGluamVjdCBlbGVtZW50LXNwZWNpZmljIHNwZWNpYWwgb2JqZWN0cywgZGVjbGFyZSB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVyIGFzOlxyXG4gKiAtIGBlbGVtZW50OiBFbGVtZW50UmVmYCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gbG9naWNhbCBlbGVtZW50IGluIHRoZSB2aWV3LlxyXG4gKiAtIGB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmYCB0byBjb250cm9sIGNoaWxkIHRlbXBsYXRlIGluc3RhbnRpYXRpb24sIGZvclxyXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9IGRpcmVjdGl2ZXMgb25seVxyXG4gKiAtIGBiaW5kaW5nUHJvcGFnYXRpb246IEJpbmRpbmdQcm9wYWdhdGlvbmAgdG8gY29udHJvbCBjaGFuZ2UgZGV0ZWN0aW9uIGluIGEgbW9yZSBncmFudWxhciB3YXkuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlbW9uc3RyYXRlcyBob3cgZGVwZW5kZW5jeSBpbmplY3Rpb24gcmVzb2x2ZXMgY29uc3RydWN0b3IgYXJndW1lbnRzIGluXHJcbiAqIHByYWN0aWNlLlxyXG4gKlxyXG4gKlxyXG4gKiBBc3N1bWUgdGhpcyBIVE1MIHRlbXBsYXRlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGRpdiBkZXBlbmRlbmN5PVwiMVwiPlxyXG4gKiAgIDxkaXYgZGVwZW5kZW5jeT1cIjJcIj5cclxuICogICAgIDxkaXYgZGVwZW5kZW5jeT1cIjNcIiBteS1kaXJlY3RpdmU+XHJcbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjRcIj5cclxuICogICAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI1XCI+PC9kaXY+XHJcbiAqICAgICAgIDwvZGl2PlxyXG4gKiAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI2XCI+PC9kaXY+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICA8L2Rpdj5cclxuICogPC9kaXY+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBXaXRoIHRoZSBmb2xsb3dpbmcgYGRlcGVuZGVuY3lgIGRlY29yYXRvciBhbmQgYFNvbWVTZXJ2aWNlYCBpbmplY3RhYmxlIGNsYXNzLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBTb21lU2VydmljZSB7XHJcbiAqIH1cclxuICpcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdbZGVwZW5kZW5jeV0nLFxyXG4gKiAgIGlucHV0czogW1xyXG4gKiAgICAgJ2lkOiBkZXBlbmRlbmN5J1xyXG4gKiAgIF1cclxuICogfSlcclxuICogY2xhc3MgRGVwZW5kZW5jeSB7XHJcbiAqICAgaWQ6c3RyaW5nO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZXQncyBzdGVwIHRocm91Z2ggdGhlIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIGBNeURpcmVjdGl2ZWAgY291bGQgYmUgZGVjbGFyZWQuLi5cclxuICpcclxuICpcclxuICogIyMjIE5vIGluamVjdGlvblxyXG4gKlxyXG4gKiBIZXJlIHRoZSBjb25zdHJ1Y3RvciBpcyBkZWNsYXJlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlcmVmb3JlIG5vdGhpbmcgaXMgaW5qZWN0ZWQgaW50b1xyXG4gKiBgTXlEaXJlY3RpdmVgLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIG5vIGRlcGVuZGVuY2llcy5cclxuICpcclxuICpcclxuICogIyMjIENvbXBvbmVudC1sZXZlbCBpbmplY3Rpb25cclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IGFueSBpbmplY3RhYmxlIGluc3RhbmNlIGZyb20gdGhlIGNsb3Nlc3QgY29tcG9uZW50IGluamVjdG9yIG9yIGFueSBvZiBpdHNcclxuICogcGFyZW50cy5cclxuICpcclxuICogSGVyZSwgdGhlIGNvbnN0cnVjdG9yIGRlY2xhcmVzIGEgcGFyYW1ldGVyLCBgc29tZVNlcnZpY2VgLCBhbmQgaW5qZWN0cyB0aGUgYFNvbWVTZXJ2aWNlYCB0eXBlXHJcbiAqIGZyb20gdGhlIHBhcmVudFxyXG4gKiBjb21wb25lbnQncyBpbmplY3Rvci5cclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3Ioc29tZVNlcnZpY2U6IFNvbWVTZXJ2aWNlKSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGRlcGVuZGVuY3kgb24gYFNvbWVTZXJ2aWNlYC5cclxuICpcclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGRpcmVjdGl2ZSBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRcclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMgZGVjbGFyZWQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoZGVwZW5kZW5jeTogRGVwZW5kZW5jeSkge1xyXG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBgRGVwZW5kZW5jeWAgZGVjbGFyZWQgYXQgdGhlIHNhbWUgZWxlbWVudCwgaW4gdGhpcyBjYXNlXHJcbiAqIGBkZXBlbmRlbmN5PVwiM1wiYC5cclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGRpcmVjdGl2ZSBmcm9tIGFueSBhbmNlc3RvciBlbGVtZW50c1xyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiBhbnkgYW5jZXN0b3IgZWxlbWVudCAoaW4gdGhlIGN1cnJlbnQgU2hhZG93XHJcbiAqIERPTSksIGkuZS4gb24gdGhlIGN1cnJlbnQgZWxlbWVudCwgdGhlXHJcbiAqIHBhcmVudCBlbGVtZW50LCBvciBpdHMgcGFyZW50cy5cclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoQEhvc3QoKSBkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XHJcbiAqICAgICBleHBlY3QoZGVwZW5kZW5jeS5pZCkudG9FcXVhbCgyKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIGBASG9zdGAgY2hlY2tzIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZSBwYXJlbnQsIGFzIHdlbGwgYXMgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkuIElmXHJcbiAqIGBkZXBlbmRlbmN5PVwiMlwiYCBkaWRuJ3RcclxuICogZXhpc3Qgb24gdGhlIGRpcmVjdCBwYXJlbnQsIHRoaXMgaW5qZWN0aW9uIHdvdWxkXHJcbiAqIGhhdmUgcmV0dXJuZWRcclxuICogYGRlcGVuZGVuY3k9XCIxXCJgLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZCBkaXJlY3RpdmVzXHJcbiAqXHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIGNhbiBhbHNvIHF1ZXJ5IGZvciBvdGhlciBjaGlsZCBkaXJlY3RpdmVzLiBTaW5jZSBwYXJlbnQgZGlyZWN0aXZlcyBhcmUgaW5zdGFudGlhdGVkXHJcbiAqIGJlZm9yZSBjaGlsZCBkaXJlY3RpdmVzLCBhIGRpcmVjdGl2ZSBjYW4ndCBzaW1wbHkgaW5qZWN0IHRoZSBsaXN0IG9mIGNoaWxkIGRpcmVjdGl2ZXMuIEluc3RlYWQsXHJcbiAqIHRoZSBkaXJlY3RpdmUgaW5qZWN0cyBhIHtAbGluayBRdWVyeUxpc3R9LCB3aGljaCB1cGRhdGVzIGl0cyBjb250ZW50cyBhcyBjaGlsZHJlbiBhcmUgYWRkZWQsXHJcbiAqIHJlbW92ZWQsIG9yIG1vdmVkIGJ5IGEgZGlyZWN0aXZlIHRoYXQgdXNlcyBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSBzdWNoIGFzIGEgYG5nLWZvcmAsIGFuXHJcbiAqIGBuZy1pZmAsIG9yIGFuIGBuZy1zd2l0Y2hgLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoRGVwZW5kZW5jeSkgZGVwZW5kZW5jaWVzOlF1ZXJ5TGlzdDxEZXBlbmRlbmN5Pikge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSB7QGxpbmsgUXVlcnlMaXN0fSB3aGljaCBjb250YWlucyBgRGVwZW5kZW5jeWAgNCBhbmRcclxuICogNi4gSGVyZSwgYERlcGVuZGVuY3lgIDUgd291bGQgbm90IGJlIGluY2x1ZGVkLCBiZWNhdXNlIGl0IGlzIG5vdCBhIGRpcmVjdCBjaGlsZC5cclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGxpdmUgY29sbGVjdGlvbiBvZiBkZXNjZW5kYW50IGRpcmVjdGl2ZXNcclxuICpcclxuICogQnkgcGFzc2luZyB0aGUgZGVzY2VuZGFudCBmbGFnIHRvIGBAUXVlcnlgIGFib3ZlLCB3ZSBjYW4gaW5jbHVkZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGNoaWxkXHJcbiAqIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoRGVwZW5kZW5jeSwge2Rlc2NlbmRhbnRzOiB0cnVlfSkgZGVwZW5kZW5jaWVzOlF1ZXJ5TGlzdDxEZXBlbmRlbmN5Pikge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBRdWVyeSB3aGljaCB3b3VsZCBjb250YWluIGBEZXBlbmRlbmN5YCA0LCA1IGFuZCA2LlxyXG4gKlxyXG4gKiAjIyMgT3B0aW9uYWwgaW5qZWN0aW9uXHJcbiAqXHJcbiAqIFRoZSBub3JtYWwgYmVoYXZpb3Igb2YgZGlyZWN0aXZlcyBpcyB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBhIHNwZWNpZmllZCBkZXBlbmRlbmN5IGNhbm5vdCBiZVxyXG4gKiByZXNvbHZlZC4gSWYgeW91XHJcbiAqIHdvdWxkIGxpa2UgdG8gaW5qZWN0IGBudWxsYCBvbiB1bnJlc29sdmVkIGRlcGVuZGVuY3kgaW5zdGVhZCwgeW91IGNhbiBhbm5vdGF0ZSB0aGF0IGRlcGVuZGVuY3lcclxuICogd2l0aCBgQE9wdGlvbmFsKClgLlxyXG4gKiBUaGlzIGV4cGxpY2l0bHkgcGVybWl0cyB0aGUgYXV0aG9yIG9mIGEgdGVtcGxhdGUgdG8gdHJlYXQgc29tZSBvZiB0aGUgc3Vycm91bmRpbmcgZGlyZWN0aXZlcyBhc1xyXG4gKiBvcHRpb25hbC5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGBEZXBlbmRlbmN5YCBkaXJlY3RpdmUgZm91bmQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICogSWYgbm9uZSBjYW4gYmVcclxuICogZm91bmQsIHRoZSBpbmplY3RvciBzdXBwbGllcyBgbnVsbGAgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvci5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBIZXJlIHdlIHVzZSBhIGRlY29yYXRvciBkaXJlY3RpdmUgdG8gc2ltcGx5IGRlZmluZSBiYXNpYyB0b29sLXRpcCBiZWhhdmlvci5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnW3Rvb2x0aXBdJyxcclxuICogICBpbnB1dHM6IFtcclxuICogICAgICd0ZXh0OiB0b29sdGlwJ1xyXG4gKiAgIF0sXHJcbiAqICAgaG9zdDoge1xyXG4gKiAgICAgJyhtb3VzZWVudGVyKSc6ICdvbk1vdXNlRW50ZXIoKScsXHJcbiAqICAgICAnKG1vdXNlbGVhdmUpJzogJ29uTW91c2VMZWF2ZSgpJ1xyXG4gKiAgIH1cclxuICogfSlcclxuICogY2xhc3MgVG9vbHRpcHtcclxuICogICB0ZXh0OnN0cmluZztcclxuICogICBvdmVybGF5Ok92ZXJsYXk7IC8vIE5PVCBZRVQgSU1QTEVNRU5URURcclxuICogICBvdmVybGF5TWFuYWdlcjpPdmVybGF5TWFuYWdlcjsgLy8gTk9UIFlFVCBJTVBMRU1FTlRFRFxyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyKSB7XHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xyXG4gKiAgIH1cclxuICpcclxuICogICBvbk1vdXNlRW50ZXIoKSB7XHJcbiAqICAgICAvLyBleGFjdCBzaWduYXR1cmUgdG8gYmUgZGV0ZXJtaW5lZFxyXG4gKiAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5vdmVybGF5TWFuYWdlci5vcGVuKHRleHQsIC4uLik7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIG9uTW91c2VMZWF2ZSgpIHtcclxuICogICAgIHRoaXMub3ZlcmxheS5jbG9zZSgpO1xyXG4gKiAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqIEluIG91ciBIVE1MIHRlbXBsYXRlLCB3ZSBjYW4gdGhlbiBhZGQgdGhpcyBiZWhhdmlvciB0byBhIGA8ZGl2PmAgb3IgYW55IG90aGVyIGVsZW1lbnQgd2l0aCB0aGVcclxuICogYHRvb2x0aXBgIHNlbGVjdG9yLFxyXG4gKiBsaWtlIHNvOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGRpdiB0b29sdGlwPVwic29tZSB0ZXh0IGhlcmVcIj48L2Rpdj5cclxuICogYGBgXHJcbiAqXHJcbiAqIERpcmVjdGl2ZXMgY2FuIGFsc28gY29udHJvbCB0aGUgaW5zdGFudGlhdGlvbiwgZGVzdHJ1Y3Rpb24sIGFuZCBwb3NpdGlvbmluZyBvZiBpbmxpbmUgdGVtcGxhdGVcclxuICogZWxlbWVudHM6XHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIHVzZXMgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gdG8gaW5zdGFudGlhdGUsIGluc2VydCwgbW92ZSwgYW5kIGRlc3Ryb3kgdmlld3MgYXRcclxuICogcnVudGltZS5cclxuICogVGhlIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSBpcyBjcmVhdGVkIGFzIGEgcmVzdWx0IG9mIGA8dGVtcGxhdGU+YCBlbGVtZW50LCBhbmQgcmVwcmVzZW50cyBhXHJcbiAqIGxvY2F0aW9uIGluIHRoZSBjdXJyZW50IHZpZXdcclxuICogd2hlcmUgdGhlc2UgYWN0aW9ucyBhcmUgcGVyZm9ybWVkLlxyXG4gKlxyXG4gKiBWaWV3cyBhcmUgYWx3YXlzIGNyZWF0ZWQgYXMgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQge0BsaW5rIFZpZXdNZXRhZGF0YX0sIGFuZCBhcyBzaWJsaW5ncyBvZiB0aGVcclxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuIFRodXMgYVxyXG4gKiBkaXJlY3RpdmUgaW4gYSBjaGlsZCB2aWV3IGNhbm5vdCBpbmplY3QgdGhlIGRpcmVjdGl2ZSB0aGF0IGNyZWF0ZWQgaXQuXHJcbiAqXHJcbiAqIFNpbmNlIGRpcmVjdGl2ZXMgdGhhdCBjcmVhdGUgdmlld3MgdmlhIFZpZXdDb250YWluZXJzIGFyZSBjb21tb24gaW4gQW5ndWxhciwgYW5kIHVzaW5nIHRoZSBmdWxsXHJcbiAqIGA8dGVtcGxhdGU+YCBlbGVtZW50IHN5bnRheCBpcyB3b3JkeSwgQW5ndWxhclxyXG4gKiBhbHNvIHN1cHBvcnRzIGEgc2hvcnRoYW5kIG5vdGF0aW9uOiBgPGxpICpmb289XCJiYXJcIj5gIGFuZCBgPGxpIHRlbXBsYXRlPVwiZm9vOiBiYXJcIj5gIGFyZVxyXG4gKiBlcXVpdmFsZW50LlxyXG4gKlxyXG4gKiBUaHVzLFxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDxsaSAqZm9vPVwiYmFyXCIgdGl0bGU9XCJ0ZXh0XCI+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEV4cGFuZHMgaW4gdXNlIHRvOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBbZm9vXT1cImJhclwiPlxyXG4gKiAgICAgPGxpIHRpdGxlPVwidGV4dFwiPjwvbGk+XHJcbiAqICAgPC90ZW1wbGF0ZT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IGFsdGhvdWdoIHRoZSBzaG9ydGhhbmQgcGxhY2VzIGAqZm9vPVwiYmFyXCJgIHdpdGhpbiB0aGUgYDxsaT5gIGVsZW1lbnQsIHRoZSBiaW5kaW5nIGZvclxyXG4gKiB0aGUgZGlyZWN0aXZlXHJcbiAqIGNvbnRyb2xsZXIgaXMgY29ycmVjdGx5IGluc3RhbnRpYXRlZCBvbiB0aGUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgcmF0aGVyIHRoYW4gdGhlIGA8bGk+YCBlbGVtZW50LlxyXG4gKlxyXG4gKiAjIyBMaWZlY3ljbGUgaG9va3NcclxuICpcclxuICogV2hlbiB0aGUgZGlyZWN0aXZlIGNsYXNzIGltcGxlbWVudHMgc29tZSB7QGxpbmsgYW5ndWxhcjIvbGlmZWN5Y2xlX2hvb2tzfSB0aGUgY2FsbGJhY2tzIGFyZVxyXG4gKiBjYWxsZWQgYnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gYXQgZGVmaW5lZCBwb2ludHMgaW4gdGltZSBkdXJpbmcgdGhlIGxpZmUgb2YgdGhlIGRpcmVjdGl2ZS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBMZXQncyBzdXBwb3NlIHdlIHdhbnQgdG8gaW1wbGVtZW50IHRoZSBgdW5sZXNzYCBiZWhhdmlvciwgdG8gY29uZGl0aW9uYWxseSBpbmNsdWRlIGEgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIEhlcmUgaXMgYSBzaW1wbGUgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcnMgb24gYW4gYHVubGVzc2Agc2VsZWN0b3I6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ1t1bmxlc3NdJyxcclxuICogICBpbnB1dHM6IFsndW5sZXNzJ11cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIFVubGVzcyB7XHJcbiAqICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcclxuICogICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY7XHJcbiAqICAgcHJldkNvbmRpdGlvbjogYm9vbGVhbjtcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWYpIHtcclxuICogICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XHJcbiAqICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XHJcbiAqICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBudWxsO1xyXG4gKiAgIH1cclxuICpcclxuICogICBzZXQgdW5sZXNzKG5ld0NvbmRpdGlvbikge1xyXG4gKiAgICAgaWYgKG5ld0NvbmRpdGlvbiAmJiAoaXNCbGFuayh0aGlzLnByZXZDb25kaXRpb24pIHx8ICF0aGlzLnByZXZDb25kaXRpb24pKSB7XHJcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IHRydWU7XHJcbiAqICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xyXG4gKiAgICAgfSBlbHNlIGlmICghbmV3Q29uZGl0aW9uICYmIChpc0JsYW5rKHRoaXMucHJldkNvbmRpdGlvbikgfHwgdGhpcy5wcmV2Q29uZGl0aW9uKSkge1xyXG4gKiAgICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBmYWxzZTtcclxuICogICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZSh0aGlzLnRlbXBsYXRlUmVmKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFdlIGNhbiB0aGVuIHVzZSB0aGlzIGB1bmxlc3NgIHNlbGVjdG9yIGluIGEgdGVtcGxhdGU6XHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICp1bmxlc3M9XCJleHByXCI+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE9uY2UgdGhlIGRpcmVjdGl2ZSBpbnN0YW50aWF0ZXMgdGhlIGNoaWxkIHZpZXcsIHRoZSBzaG9ydGhhbmQgbm90YXRpb24gZm9yIHRoZSB0ZW1wbGF0ZSBleHBhbmRzXHJcbiAqIGFuZCB0aGUgcmVzdWx0IGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBbdW5sZXNzXT1cImV4cFwiPlxyXG4gKiAgICAgPGxpPjwvbGk+XHJcbiAqICAgPC90ZW1wbGF0ZT5cclxuICogICA8bGk+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgYWxzbyB0aGF0IGFsdGhvdWdoIHRoZSBgPGxpPjwvbGk+YCB0ZW1wbGF0ZSBzdGlsbCBleGlzdHMgaW5zaWRlIHRoZSBgPHRlbXBsYXRlPjwvdGVtcGxhdGU+YCxcclxuICogdGhlIGluc3RhbnRpYXRlZFxyXG4gKiB2aWV3IG9jY3VycyBvbiB0aGUgc2Vjb25kIGA8bGk+PC9saT5gIHdoaWNoIGlzIGEgc2libGluZyB0byB0aGUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnRzLkRpcmVjdGl2ZSA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5EaXJlY3RpdmVNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld01ldGFkYXRhLlxyXG4vKipcclxuICogTWV0YWRhdGEgcHJvcGVydGllcyBhdmFpbGFibGUgZm9yIGNvbmZpZ3VyaW5nIFZpZXdzLlxyXG4gKlxyXG4gKiBFYWNoIEFuZ3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGEgc2luZ2xlIGBAQ29tcG9uZW50YCBhbmQgYXQgbGVhc3Qgb25lIGBAVmlld2AgYW5ub3RhdGlvbi4gVGhlXHJcbiAqIGBAVmlld2AgYW5ub3RhdGlvbiBzcGVjaWZpZXMgdGhlIEhUTUwgdGVtcGxhdGUgdG8gdXNlLCBhbmQgbGlzdHMgdGhlIGRpcmVjdGl2ZXMgdGhhdCBhcmUgYWN0aXZlXHJcbiAqIHdpdGhpbiB0aGUgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCB0aGUgdGVtcGxhdGUgaXMgbG9hZGVkIGludG8gdGhlIGNvbXBvbmVudCdzIHNoYWRvdyByb290LCBhbmRcclxuICogdGhlIGV4cHJlc3Npb25zIGFuZCBzdGF0ZW1lbnRzIGluIHRoZSB0ZW1wbGF0ZSBhcmUgZXZhbHVhdGVkIGFnYWluc3QgdGhlIGNvbXBvbmVudC5cclxuICpcclxuICogRm9yIGRldGFpbHMgb24gdGhlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLCBzZWUge0BsaW5rIENvbXBvbmVudE1ldGFkYXRhfS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdncmVldCcsXHJcbiAqICAgdGVtcGxhdGU6ICdIZWxsbyB7e25hbWV9fSEnLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtHcmVldFVzZXIsIEJvbGRdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEdyZWV0IHtcclxuICogICBuYW1lOiBzdHJpbmc7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoKSB7XHJcbiAqICAgICB0aGlzLm5hbWUgPSAnV29ybGQnO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuVmlldyA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKHZpZXdfMi5WaWV3TWV0YWRhdGEsIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4uVmlldyA9IGV4cG9ydHMuVmlldzsgfSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gQXR0cmlidXRlTWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXHJcbiAqXHJcbiAqIEVhY2ggQW5ndWxhciBjb21wb25lbnQgcmVxdWlyZXMgYSBzaW5nbGUgYEBDb21wb25lbnRgIGFuZCBhdCBsZWFzdCBvbmUgYEBWaWV3YCBhbm5vdGF0aW9uLiBUaGVcclxuICogYEBWaWV3YCBhbm5vdGF0aW9uIHNwZWNpZmllcyB0aGUgSFRNTCB0ZW1wbGF0ZSB0byB1c2UsIGFuZCBsaXN0cyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBhY3RpdmVcclxuICogd2l0aGluIHRoZSB0ZW1wbGF0ZS5cclxuICpcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgaW50byB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QsIGFuZFxyXG4gKiB0aGUgZXhwcmVzc2lvbnMgYW5kIHN0YXRlbWVudHMgaW4gdGhlIHRlbXBsYXRlIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBDb21wb25lbnRgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXHJcbiAqICAgZGlyZWN0aXZlczogW0dyZWV0VXNlciwgQm9sZF1cclxuICogfSlcclxuICogY2xhc3MgR3JlZXQge1xyXG4gKiAgIG5hbWU6IHN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5BdHRyaWJ1dGUgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKGRpXzIuQXR0cmlidXRlTWV0YWRhdGEpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFF1ZXJ5TWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhbiBpbmplY3RhYmxlIHBhcmFtZXRlciB0byBiZSBhIGxpdmUgbGlzdCBvZiBkaXJlY3RpdmVzIG9yIHZhcmlhYmxlXHJcbiAqIGJpbmRpbmdzIGZyb20gdGhlIGNvbnRlbnQgY2hpbGRyZW4gb2YgYSBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9sWTltOEhMeTd6MDZ2RG9VYVNOMj9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBBc3N1bWUgdGhhdCBgPHRhYnM+YCBjb21wb25lbnQgd291bGQgbGlrZSB0byBnZXQgYSBsaXN0IGl0cyBjaGlsZHJlbiBgPHBhbmU+YFxyXG4gKiBjb21wb25lbnRzIGFzIHNob3duIGluIHRoaXMgZXhhbXBsZTpcclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8dGFicz5cclxuICogICA8cGFuZSB0aXRsZT1cIk92ZXJ2aWV3XCI+Li4uPC9wYW5lPlxyXG4gKiAgIDxwYW5lICpuZy1mb3I9XCIjbyBvZiBvYmplY3RzXCIgW3RpdGxlXT1cIm8udGl0bGVcIj57e28udGV4dH19PC9wYW5lPlxyXG4gKiA8L3RhYnM+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgcHJlZmVycmVkIHNvbHV0aW9uIGlzIHRvIHF1ZXJ5IGZvciBgUGFuZWAgZGlyZWN0aXZlcyB1c2luZyB0aGlzIGRlY29yYXRvci5cclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3BhbmUnLFxyXG4gKiAgIGlucHV0czogWyd0aXRsZSddXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFBhbmUge1xyXG4gKiAgIHRpdGxlOnN0cmluZztcclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAndGFicycsXHJcbiAqICB0ZW1wbGF0ZTogYFxyXG4gKiAgICA8dWw+XHJcbiAqICAgICAgPGxpICpuZy1mb3I9XCIjcGFuZSBvZiBwYW5lc1wiPnt7cGFuZS50aXRsZX19PC9saT5cclxuICogICAgPC91bD5cclxuICogICAgPGNvbnRlbnQ+PC9jb250ZW50PlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBjbGFzcyBUYWJzIHtcclxuICogICBwYW5lczogUXVlcnlMaXN0PFBhbmU+O1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShQYW5lKSBwYW5lczpRdWVyeUxpc3Q8UGFuZT4pIHtcclxuICogICAgIHRoaXMucGFuZXMgPSBwYW5lcztcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEEgcXVlcnkgY2FuIGxvb2sgZm9yIHZhcmlhYmxlIGJpbmRpbmdzIGJ5IHBhc3NpbmcgaW4gYSBzdHJpbmcgd2l0aCBkZXNpcmVkIGJpbmRpbmcgc3ltYm9sLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvc1QyajI1Y0gxZFVSQXlCUkNLeDE/cD1wcmV2aWV3KSlcclxuICogYGBgaHRtbFxyXG4gKiA8c2Vla2VyPlxyXG4gKiAgIDxkaXYgI2ZpbmRtZT4uLi48L2Rpdj5cclxuICogPC9zZWVrZXI+XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoeyBzZWxlY3RvcjogJ2ZvbycgfSlcclxuICogY2xhc3Mgc2Vla2VyIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoJ2ZpbmRtZScpIGVsTGlzdDogUXVlcnlMaXN0PEVsZW1lbnRSZWY+KSB7Li4ufVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbiB0aGlzIGNhc2UgdGhlIG9iamVjdCB0aGF0IGlzIGluamVjdGVkIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFyaWFibGVcclxuICogYmluZGluZy4gSXQgY2FuIGJlIGFuIEVsZW1lbnRSZWYsIGEgZGlyZWN0aXZlIG9yIGEgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBQYXNzaW5nIGluIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgdmFyaWFibGUgYmluZGluZ3Mgd2lsbCBxdWVyeSBmb3IgYWxsIG9mIHRoZW0uXHJcbiAqXHJcbiAqIGBgYGh0bWxcclxuICogPHNlZWtlcj5cclxuICogICA8ZGl2ICNmaW5kLW1lPi4uLjwvZGl2PlxyXG4gKiAgIDxkaXYgI2ZpbmQtbWUtdG9vPi4uLjwvZGl2PlxyXG4gKiA8L3NlZWtlcj5cclxuICpcclxuICogIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZm9vJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBTZWVrZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZE1lLCBmaW5kTWVUb28nKSBlbExpc3Q6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPikgey4uLn1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQ29uZmlndXJlIHdoZXRoZXIgcXVlcnkgbG9va3MgZm9yIGRpcmVjdCBjaGlsZHJlbiBvciBhbGwgZGVzY2VuZGFudHNcclxuICogb2YgdGhlIHF1ZXJ5aW5nIGVsZW1lbnQsIGJ5IHVzaW5nIHRoZSBgZGVzY2VuZGFudHNgIHBhcmFtZXRlci5cclxuICogSXQgaXMgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3d0R2VCOTc3YnY3cXZBNUZUWWw5P3A9cHJldmlldykpXHJcbiAqIGBgYGh0bWxcclxuICogPGNvbnRhaW5lciAjZmlyc3Q+XHJcbiAqICAgPGl0ZW0+YTwvaXRlbT5cclxuICogICA8aXRlbT5iPC9pdGVtPlxyXG4gKiAgIDxjb250YWluZXIgI3NlY29uZD5cclxuICogICAgIDxpdGVtPmM8L2l0ZW0+XHJcbiAqICAgPC9jb250YWluZXI+XHJcbiAqIDwvY29udGFpbmVyPlxyXG4gKiBgYGBcclxuICpcclxuICogV2hlbiBxdWVyeWluZyBmb3IgaXRlbXMsIHRoZSBmaXJzdCBjb250YWluZXIgd2lsbCBzZWUgb25seSBgYWAgYW5kIGBiYCBieSBkZWZhdWx0LFxyXG4gKiBidXQgd2l0aCBgUXVlcnkoVGV4dERpcmVjdGl2ZSwge2Rlc2NlbmRhbnRzOiB0cnVlfSlgIGl0IHdpbGwgc2VlIGBjYCB0b28uXHJcbiAqXHJcbiAqIFRoZSBxdWVyaWVkIGRpcmVjdGl2ZXMgYXJlIGtlcHQgaW4gYSBkZXB0aC1maXJzdCBwcmUtb3JkZXIgd2l0aCByZXNwZWN0IHRvIHRoZWlyXHJcbiAqIHBvc2l0aW9ucyBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiBRdWVyeSBkb2VzIG5vdCBsb29rIGRlZXAgaW50byBhbnkgc3ViY29tcG9uZW50IHZpZXdzLlxyXG4gKlxyXG4gKiBRdWVyeSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgdGhlIGNoYW5nZS1kZXRlY3Rpb24gY3ljbGUuIFNpbmNlIGNoYW5nZSBkZXRlY3Rpb25cclxuICogaGFwcGVucyBhZnRlciBjb25zdHJ1Y3Rpb24gb2YgYSBkaXJlY3RpdmUsIFF1ZXJ5TGlzdCB3aWxsIGFsd2F5cyBiZSBlbXB0eSB3aGVuIG9ic2VydmVkIGluIHRoZVxyXG4gKiBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiB1bm1vZGlmaWFibGUgbGl2ZSBsaXN0LlxyXG4gKiBTZWUge0BsaW5rIFF1ZXJ5TGlzdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmV4cG9ydHMuUXVlcnkgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKGRpXzIuUXVlcnlNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gQ29udGVudENoaWxkcmVuTWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgY29udGVudCBxdWVyeS5cclxuICpcclxuICogQ29udGVudCBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJDb250ZW50SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBTb21lRGlyIHtcclxuICogICBAQ29udGVudENoaWxkcmVuKENoaWxkRGlyZWN0aXZlKSBjb250ZW50Q2hpbGRyZW46IFF1ZXJ5TGlzdDxDaGlsZERpcmVjdGl2ZT47XHJcbiAqXHJcbiAqICAgYWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICogICAgIC8vIGNvbnRlbnRDaGlsZHJlbiBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkNvbnRlbnRDaGlsZHJlbiA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLkNvbnRlbnRDaGlsZHJlbk1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBDb250ZW50Q2hpbGRNZXRhZGF0YS5cclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxyXG4gKlxyXG4gKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBDb250ZW50Q2hpbGQoQ2hpbGREaXJlY3RpdmUpIGNvbnRlbnRDaGlsZDtcclxuICpcclxuICogICBhZnRlckNvbnRlbnRJbml0KCkge1xyXG4gKiAgICAgLy8gY29udGVudENoaWxkIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuQ29udGVudENoaWxkID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpXzIuQ29udGVudENoaWxkTWV0YWRhdGEpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFZpZXdDaGlsZHJlbk1ldGFkYXRhLlxyXG4vKipcclxuICogQ29uZmlndXJlcyBhIHZpZXcgcXVlcnkuXHJcbiAqXHJcbiAqIFZpZXcgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYGFmdGVyVmlld0luaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnc29tZURpcicsXHJcbiAqICAgdGVtcGxhdGVVcmw6ICdzb21lVGVtcGxhdGUnLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtJdGVtRGlyZWN0aXZlXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBTb21lRGlyIHtcclxuICogICBAVmlld0NoaWxkcmVuKEl0ZW1EaXJlY3RpdmUpIHZpZXdDaGlsZHJlbjogUXVlcnlMaXN0PEl0ZW1EaXJlY3RpdmU+O1xyXG4gKlxyXG4gKiAgIGFmdGVyVmlld0luaXQoKSB7XHJcbiAqICAgICAvLyB2aWV3Q2hpbGRyZW4gaXMgc2V0XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5WaWV3Q2hpbGRyZW4gPSBkZWNvcmF0b3JzXzEubWFrZVByb3BEZWNvcmF0b3IoZGlfMi5WaWV3Q2hpbGRyZW5NZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld0NoaWxkTWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgdmlldyBxdWVyeS5cclxuICpcclxuICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJWaWV3SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJyxcclxuICogICB0ZW1wbGF0ZVVybDogJ3NvbWVUZW1wbGF0ZScsXHJcbiAqICAgZGlyZWN0aXZlczogW0l0ZW1EaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBWaWV3Q2hpbGQoSXRlbURpcmVjdGl2ZSkgdmlld0NoaWxkOkl0ZW1EaXJlY3RpdmU7XHJcbiAqXHJcbiAqICAgYWZ0ZXJWaWV3SW5pdCgpIHtcclxuICogICAgIC8vIHZpZXdDaGlsZCBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLlZpZXdDaGlsZCA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLlZpZXdDaGlsZE1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBWaWV3UXVlcnlNZXRhZGF0YS5cclxuLyoqXHJcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LCBidXQgcXVlcnlpbmcgdGhlIGNvbXBvbmVudCB2aWV3LCBpbnN0ZWFkIG9mXHJcbiAqIHRoZSBjb250ZW50IGNoaWxkcmVuLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZU5zRkhEZjdZanlNNkl6S3hNMWo/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHsuLi59KVxyXG4gKiBAVmlldyh7XHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxpdGVtPiBhIDwvaXRlbT5cclxuICogICAgIDxpdGVtPiBiIDwvaXRlbT5cclxuICogICAgIDxpdGVtPiBjIDwvaXRlbT5cclxuICogICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcclxuICogICBzaG93bjogYm9vbGVhbjtcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIEBRdWVyeShJdGVtKSBpdGVtczpRdWVyeUxpc3Q8SXRlbT4pIHtcclxuICogICAgIGl0ZW1zLm9uQ2hhbmdlKCgpID0+IGNvbnNvbGUubG9nKGl0ZW1zLmxlbmd0aCkpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogU3VwcG9ydHMgdGhlIHNhbWUgcXVlcnlpbmcgcGFyYW1ldGVycyBhcyB7QGxpbmsgUXVlcnlNZXRhZGF0YX0sIGV4Y2VwdFxyXG4gKiBgZGVzY2VuZGFudHNgLiBUaGlzIGFsd2F5cyBxdWVyaWVzIHRoZSB3aG9sZSB2aWV3LlxyXG4gKlxyXG4gKiBBcyBgc2hvd25gIGlzIGZsaXBwZWQgYmV0d2VlbiB0cnVlIGFuZCBmYWxzZSwgaXRlbXMgd2lsbCBjb250YWluIHplcm8gb2Ygb25lXHJcbiAqIGl0ZW1zLlxyXG4gKlxyXG4gKiBTcGVjaWZpZXMgdGhhdCBhIHtAbGluayBRdWVyeUxpc3R9IHNob3VsZCBiZSBpbmplY3RlZC5cclxuICpcclxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiBpdGVyYWJsZSBhbmQgb2JzZXJ2YWJsZSBsaXZlIGxpc3QuXHJcbiAqIFNlZSB7QGxpbmsgUXVlcnlMaXN0fSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0cy5WaWV3UXVlcnkgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKGRpXzIuVmlld1F1ZXJ5TWV0YWRhdGEpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFBpcGVNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmUgcmV1c2FibGUgcGlwZSBmdW5jdGlvbi5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQFBpcGUoe1xyXG4gKiAgIG5hbWU6ICdsb3dlcmNhc2UnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIExvd2VyY2FzZSB7XHJcbiAqICAgdHJhbnNmb3JtKHYsIGFyZ3MpIHsgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTsgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5QaXBlID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3IoZGlyZWN0aXZlc18yLlBpcGVNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gSW5wdXRNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgZGF0YS1ib3VuZCBpbnB1dCBwcm9wZXJ0eS5cclxuICpcclxuICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLlxyXG4gKlxyXG4gKiBgSW5wdXRNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lXHJcbiAqIHVzZWQgd2hlbiBpbnN0YW50aWF0aW5nIGEgY29tcG9uZW50IGluIHRoZSB0ZW1wbGF0ZS4gV2hlbiBub3QgcHJvdmlkZWQsXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBkZWNvcmF0ZWQgcHJvcGVydHkgaXMgdXNlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgd2l0aCB0d28gaW5wdXQgcHJvcGVydGllcy5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2JhbmstYWNjb3VudCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIEJhbmsgTmFtZToge3tiYW5rTmFtZX19XHJcbiAqICAgICBBY2NvdW50IElkOiB7e2lkfX1cclxuICogICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEJhbmtBY2NvdW50IHtcclxuICogICBASW5wdXQoKSBiYW5rTmFtZTogc3RyaW5nO1xyXG4gKiAgIEBJbnB1dCgnYWNjb3VudC1pZCcpIGlkOiBzdHJpbmc7XHJcbiAqXHJcbiAqICAgLy8gdGhpcyBwcm9wZXJ0eSBpcyBub3QgYm91bmQsIGFuZCB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYnkgQW5ndWxhclxyXG4gKiAgIG5vcm1hbGl6ZWRCYW5rTmFtZTogc3RyaW5nO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGJhbmstYWNjb3VudCBiYW5rLW5hbWU9XCJSQkNcIiBhY2NvdW50LWlkPVwiNDc0N1wiPjwvYmFuay1hY2NvdW50PlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW0JhbmtBY2NvdW50XVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge31cclxuICpcclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5JbnB1dCA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuSW5wdXRNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gT3V0cHV0TWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhbiBldmVudC1ib3VuZCBvdXRwdXQgcHJvcGVydHkuXHJcbiAqXHJcbiAqIFdoZW4gYW4gb3V0cHV0IHByb3BlcnR5IGVtaXRzIGFuIGV2ZW50LCBhbiBldmVudCBoYW5kbGVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnRcclxuICogdGhlIHRlbXBsYXRlIGlzIGludm9rZWQuXHJcbiAqXHJcbiAqIGBPdXRwdXRNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lXHJcbiAqIHVzZWQgd2hlbiBpbnN0YW50aWF0aW5nIGEgY29tcG9uZW50IGluIHRoZSB0ZW1wbGF0ZS4gV2hlbiBub3QgcHJvdmlkZWQsXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBkZWNvcmF0ZWQgcHJvcGVydHkgaXMgdXNlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ2ludGVydmFsLWRpcicsXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEludGVydmFsRGlyIHtcclxuICogICBAT3V0cHV0KCkgZXZlcnlTZWNvbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqICAgQE91dHB1dCgnZXZlcnlGaXZlU2Vjb25kcycpIGZpdmU1U2VjcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHNldEludGVydmFsKCgpID0+IHRoaXMuZXZlcnlTZWNvbmQubmV4dChcImV2ZW50XCIpLCAxMDAwKTtcclxuICogICAgIHNldEludGVydmFsKCgpID0+IHRoaXMuZml2ZTVTZWNzLm5leHQoXCJldmVudFwiKSwgNTAwMCk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGludGVydmFsLWRpciAoZXZlcnktc2Vjb25kKT1cImV2ZXJ5U2Vjb25kKClcIiAoZXZlcnktZml2ZS1zZWNvbmRzKT1cImV2ZXJ5Rml2ZVNlY29uZHMoKVwiPlxyXG4gKiAgICAgPC9pbnRlcnZhbC1kaXI+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbSW50ZXJ2YWxEaXJdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7XHJcbiAqICAgZXZlcnlTZWNvbmQoKSB7IGNvbnNvbGUubG9nKCdzZWNvbmQnKTsgfVxyXG4gKiAgIGV2ZXJ5Rml2ZVNlY29uZHMoKSB7IGNvbnNvbGUubG9nKCdmaXZlIHNlY29uZHMnKTsgfVxyXG4gKiB9XHJcbiAqIGJvb3RzdHJhcChBcHApO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuT3V0cHV0ID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5PdXRwdXRNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gSG9zdEJpbmRpbmdNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nLlxyXG4gKlxyXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGhvc3QgcHJvcGVydHkgYmluZGluZ3MgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAqIElmIGEgYmluZGluZyBjaGFuZ2VzLCBpdCB3aWxsIHVwZGF0ZSB0aGUgaG9zdCBlbGVtZW50IG9mIHRoZSBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqIGBIb3N0QmluZGluZ01ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIHByb3BlcnR5XHJcbiAqIG5hbWUgb2YgdGhlIGhvc3QgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXBkYXRlZC4gV2hlbiBub3QgcHJvdmlkZWQsXHJcbiAqIHRoZSBjbGFzcyBwcm9wZXJ0eSBuYW1lIGlzIHVzZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGEgZGlyZWN0aXZlIHRoYXQgc2V0cyB0aGUgYHZhbGlkYCBhbmQgYGludmFsaWRgIGNsYXNzZXNcclxuICogb24gdGhlIERPTSBlbGVtZW50IHRoYXQgaGFzIG5nLW1vZGVsIGRpcmVjdGl2ZSBvbiBpdC5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tuZy1tb2RlbF0nfSlcclxuICogY2xhc3MgTmdNb2RlbFN0YXR1cyB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIGNvbnRyb2w6TmdNb2RlbCkge31cclxuICogICBASG9zdEJpbmRpbmcoJ1tjbGFzcy52YWxpZF0nKSBnZXQgdmFsaWQgeyByZXR1cm4gdGhpcy5jb250cm9sLnZhbGlkOyB9XHJcbiAqICAgQEhvc3RCaW5kaW5nKCdbY2xhc3MuaW52YWxpZF0nKSBnZXQgaW52YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wuaW52YWxpZDsgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYDxpbnB1dCBbKG5nLW1vZGVsKV09XCJwcm9wXCI+YCxcclxuICogICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTLCBOZ01vZGVsU3RhdHVzXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge1xyXG4gKiAgIHByb3A7XHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5Ib3N0QmluZGluZyA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuSG9zdEJpbmRpbmdNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gSG9zdExpc3RlbmVyTWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhIGhvc3QgbGlzdGVuZXIuXHJcbiAqXHJcbiAqIEFuZ3VsYXIgd2lsbCBpbnZva2UgdGhlIGRlY29yYXRlZCBtZXRob2Qgd2hlbiB0aGUgaG9zdCBlbGVtZW50IGVtaXRzIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcbiAqXHJcbiAqIElmIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHJldHVybnMgYGZhbHNlYCwgdGhlbiBgcHJldmVudERlZmF1bHRgIGlzIGFwcGxpZWQgb24gdGhlIERPTVxyXG4gKiBldmVudC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlY2xhcmVzIGEgZGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgYnV0dG9uIGFuZFxyXG4gKiBjb3VudHMgY2xpY2tzLlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnYnV0dG9uW2NvdW50aW5nXSd9KVxyXG4gKiBjbGFzcyBDb3VudENsaWNrcyB7XHJcbiAqICAgbnVtYmVyT2ZDbGlja3MgPSAwO1xyXG4gKlxyXG4gKiAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXHJcbiAqICAgb25DbGljayhidG4pIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiYnV0dG9uXCIsIGJ0biwgXCJudW1iZXIgb2YgY2xpY2tzOlwiLCB0aGlzLm51bWJlck9mQ2xpY2tzKyspO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGA8YnV0dG9uIGNvdW50aW5nPkluY3JlbWVudDwvYnV0dG9uPmAsXHJcbiAqICAgZGlyZWN0aXZlczogW0NvdW50Q2xpY2tzXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge31cclxuICpcclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5Ib3N0TGlzdGVuZXIgPSBkZWNvcmF0b3JzXzEubWFrZVByb3BEZWNvcmF0b3IoZGlyZWN0aXZlc18yLkhvc3RMaXN0ZW5lck1ldGFkYXRhKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGkvbWV0YWRhdGEnKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGF0IGEgY29uc3RhbnQgYXR0cmlidXRlIHZhbHVlIHNob3VsZCBiZSBpbmplY3RlZC5cclxuICpcclxuICogVGhlIGRpcmVjdGl2ZSBjYW4gaW5qZWN0IGNvbnN0YW50IHN0cmluZyBsaXRlcmFscyBvZiBob3N0IGVsZW1lbnQgYXR0cmlidXRlcy5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBTdXBwb3NlIHdlIGhhdmUgYW4gYDxpbnB1dD5gIGVsZW1lbnQgYW5kIHdhbnQgdG8ga25vdyBpdHMgYHR5cGVgLlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiPlxyXG4gKiBgYGBcclxuICpcclxuICogQSBkZWNvcmF0b3IgY2FuIGluamVjdCBzdHJpbmcgbGl0ZXJhbCBgdGV4dGAgbGlrZSBzbzpcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogYGlucHV0J1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBJbnB1dERpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoQEF0dHJpYnV0ZSgndHlwZScpIHR5cGUpIHtcclxuICogICAgIC8vIHR5cGUgd291bGQgYmUgYHRleHRgIGluIHRoaXMgZXhhbXBsZVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBBdHRyaWJ1dGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXR0cmlidXRlTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVNZXRhZGF0YShhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdHRyaWJ1dGVNZXRhZGF0YS5wcm90b3R5cGUsIFwidG9rZW5cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxseSBvbmUgd291bGQgZGVmYXVsdCBhIHRva2VuIHRvIGEgdHlwZSBvZiBhbiBpbmplY3RlZCB2YWx1ZSBidXQgaGVyZVxyXG4gICAgICAgICAgICAvLyB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlIGlzIFwic3RyaW5nXCIgYW5kIHdlIGNhbid0IHVzZSBwcmltaXRpdmUgdHlwZSBhcyBhIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgaW5zdGFuY2Ugb2YgQXR0cmlidXRlIGluc3RlYWQuIFRoaXMgZG9lc24ndCBtYXR0ZXIgbXVjaCBpbiBwcmFjdGljZSBhcyBhcmd1bWVudHNcclxuICAgICAgICAgICAgLy8gd2l0aCBAQXR0cmlidXRlIGFubm90YXRpb24gYXJlIGluamVjdGVkIGJ5IEVsZW1lbnRJbmplY3RvciB0aGF0IGRvZXNuJ3QgdGFrZSB0b2tlbnMgaW50b1xyXG4gICAgICAgICAgICAvLyBhY2NvdW50LlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEF0dHJpYnV0ZU1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEF0dHJpYnV0ZShcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5hdHRyaWJ1dGVOYW1lKSArIFwiKVwiOyB9O1xyXG4gICAgQXR0cmlidXRlTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIEF0dHJpYnV0ZU1ldGFkYXRhKTtcclxuICAgIHJldHVybiBBdHRyaWJ1dGVNZXRhZGF0YTtcclxufSkobWV0YWRhdGFfMS5EZXBlbmRlbmN5TWV0YWRhdGEpO1xyXG5leHBvcnRzLkF0dHJpYnV0ZU1ldGFkYXRhID0gQXR0cmlidXRlTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhbiBpbmplY3RhYmxlIHBhcmFtZXRlciB0byBiZSBhIGxpdmUgbGlzdCBvZiBkaXJlY3RpdmVzIG9yIHZhcmlhYmxlXHJcbiAqIGJpbmRpbmdzIGZyb20gdGhlIGNvbnRlbnQgY2hpbGRyZW4gb2YgYSBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9sWTltOEhMeTd6MDZ2RG9VYVNOMj9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBBc3N1bWUgdGhhdCBgPHRhYnM+YCBjb21wb25lbnQgd291bGQgbGlrZSB0byBnZXQgYSBsaXN0IGl0cyBjaGlsZHJlbiBgPHBhbmU+YFxyXG4gKiBjb21wb25lbnRzIGFzIHNob3duIGluIHRoaXMgZXhhbXBsZTpcclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8dGFicz5cclxuICogICA8cGFuZSB0aXRsZT1cIk92ZXJ2aWV3XCI+Li4uPC9wYW5lPlxyXG4gKiAgIDxwYW5lICpuZy1mb3I9XCIjbyBvZiBvYmplY3RzXCIgW3RpdGxlXT1cIm8udGl0bGVcIj57e28udGV4dH19PC9wYW5lPlxyXG4gKiA8L3RhYnM+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgcHJlZmVycmVkIHNvbHV0aW9uIGlzIHRvIHF1ZXJ5IGZvciBgUGFuZWAgZGlyZWN0aXZlcyB1c2luZyB0aGlzIGRlY29yYXRvci5cclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3BhbmUnLFxyXG4gKiAgIGlucHV0czogWyd0aXRsZSddXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFBhbmUge1xyXG4gKiAgIHRpdGxlOnN0cmluZztcclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAndGFicycsXHJcbiAqICB0ZW1wbGF0ZTogYFxyXG4gKiAgICA8dWw+XHJcbiAqICAgICAgPGxpICpuZy1mb3I9XCIjcGFuZSBvZiBwYW5lc1wiPnt7cGFuZS50aXRsZX19PC9saT5cclxuICogICAgPC91bD5cclxuICogICAgPGNvbnRlbnQ+PC9jb250ZW50PlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBjbGFzcyBUYWJzIHtcclxuICogICBwYW5lczogUXVlcnlMaXN0PFBhbmU+O1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShQYW5lKSBwYW5lczpRdWVyeUxpc3Q8UGFuZT4pIHtcclxuICAqICAgIHRoaXMucGFuZXMgPSBwYW5lcztcclxuICAqICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEEgcXVlcnkgY2FuIGxvb2sgZm9yIHZhcmlhYmxlIGJpbmRpbmdzIGJ5IHBhc3NpbmcgaW4gYSBzdHJpbmcgd2l0aCBkZXNpcmVkIGJpbmRpbmcgc3ltYm9sLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvc1QyajI1Y0gxZFVSQXlCUkNLeDE/cD1wcmV2aWV3KSlcclxuICogYGBgaHRtbFxyXG4gKiA8c2Vla2VyPlxyXG4gKiAgIDxkaXYgI2ZpbmRtZT4uLi48L2Rpdj5cclxuICogPC9zZWVrZXI+XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoeyBzZWxlY3RvcjogJ2ZvbycgfSlcclxuICogY2xhc3Mgc2Vla2VyIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoJ2ZpbmRtZScpIGVsTGlzdDogUXVlcnlMaXN0PEVsZW1lbnRSZWY+KSB7Li4ufVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbiB0aGlzIGNhc2UgdGhlIG9iamVjdCB0aGF0IGlzIGluamVjdGVkIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFyaWFibGVcclxuICogYmluZGluZy4gSXQgY2FuIGJlIGFuIEVsZW1lbnRSZWYsIGEgZGlyZWN0aXZlIG9yIGEgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBQYXNzaW5nIGluIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgdmFyaWFibGUgYmluZGluZ3Mgd2lsbCBxdWVyeSBmb3IgYWxsIG9mIHRoZW0uXHJcbiAqXHJcbiAqIGBgYGh0bWxcclxuICogPHNlZWtlcj5cclxuICogICA8ZGl2ICNmaW5kLW1lPi4uLjwvZGl2PlxyXG4gKiAgIDxkaXYgI2ZpbmQtbWUtdG9vPi4uLjwvZGl2PlxyXG4gKiA8L3NlZWtlcj5cclxuICpcclxuICogIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZm9vJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBTZWVrZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZE1lLCBmaW5kTWVUb28nKSBlbExpc3Q6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPikgey4uLn1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQ29uZmlndXJlIHdoZXRoZXIgcXVlcnkgbG9va3MgZm9yIGRpcmVjdCBjaGlsZHJlbiBvciBhbGwgZGVzY2VuZGFudHNcclxuICogb2YgdGhlIHF1ZXJ5aW5nIGVsZW1lbnQsIGJ5IHVzaW5nIHRoZSBgZGVzY2VuZGFudHNgIHBhcmFtZXRlci5cclxuICogSXQgaXMgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3d0R2VCOTc3YnY3cXZBNUZUWWw5P3A9cHJldmlldykpXHJcbiAqIGBgYGh0bWxcclxuICogPGNvbnRhaW5lciAjZmlyc3Q+XHJcbiAqICAgPGl0ZW0+YTwvaXRlbT5cclxuICogICA8aXRlbT5iPC9pdGVtPlxyXG4gKiAgIDxjb250YWluZXIgI3NlY29uZD5cclxuICogICAgIDxpdGVtPmM8L2l0ZW0+XHJcbiAqICAgPC9jb250YWluZXI+XHJcbiAqIDwvY29udGFpbmVyPlxyXG4gKiBgYGBcclxuICpcclxuICogV2hlbiBxdWVyeWluZyBmb3IgaXRlbXMsIHRoZSBmaXJzdCBjb250YWluZXIgd2lsbCBzZWUgb25seSBgYWAgYW5kIGBiYCBieSBkZWZhdWx0LFxyXG4gKiBidXQgd2l0aCBgUXVlcnkoVGV4dERpcmVjdGl2ZSwge2Rlc2NlbmRhbnRzOiB0cnVlfSlgIGl0IHdpbGwgc2VlIGBjYCB0b28uXHJcbiAqXHJcbiAqIFRoZSBxdWVyaWVkIGRpcmVjdGl2ZXMgYXJlIGtlcHQgaW4gYSBkZXB0aC1maXJzdCBwcmUtb3JkZXIgd2l0aCByZXNwZWN0IHRvIHRoZWlyXHJcbiAqIHBvc2l0aW9ucyBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiBRdWVyeSBkb2VzIG5vdCBsb29rIGRlZXAgaW50byBhbnkgc3ViY29tcG9uZW50IHZpZXdzLlxyXG4gKlxyXG4gKiBRdWVyeSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgdGhlIGNoYW5nZS1kZXRlY3Rpb24gY3ljbGUuIFNpbmNlIGNoYW5nZSBkZXRlY3Rpb25cclxuICogaGFwcGVucyBhZnRlciBjb25zdHJ1Y3Rpb24gb2YgYSBkaXJlY3RpdmUsIFF1ZXJ5TGlzdCB3aWxsIGFsd2F5cyBiZSBlbXB0eSB3aGVuIG9ic2VydmVkIGluIHRoZVxyXG4gKiBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiB1bm1vZGlmaWFibGUgbGl2ZSBsaXN0LlxyXG4gKiBTZWUge0BsaW5rIFF1ZXJ5TGlzdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbnZhciBRdWVyeU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhRdWVyeU1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUXVlcnlNZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2IuZmlyc3QsIGZpcnN0ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Q7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBfc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5kZXNjZW5kYW50cyA9IGRlc2NlbmRhbnRzO1xyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBmaXJzdDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpc1ZpZXdRdWVyeVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYWx3YXlzIGBmYWxzZWAgdG8gZGlmZmVyZW50aWF0ZSBpdCB3aXRoIHtAbGluayBWaWV3UXVlcnlNZXRhZGF0YX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwic2VsZWN0b3JcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHdoYXQgdGhpcyBpcyBxdWVyeWluZyBmb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaV8xLnJlc29sdmVGb3J3YXJkUmVmKHRoaXMuX3NlbGVjdG9yKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwiaXNWYXJCaW5kaW5nUXVlcnlcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHdoZXRoZXIgdGhpcyBpcyBxdWVyeWluZyBmb3IgYSB2YXJpYWJsZSBiaW5kaW5nIG9yIGEgZGlyZWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzU3RyaW5nKHRoaXMuc2VsZWN0b3IpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJ2YXJCaW5kaW5nc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJucyBhIGxpc3Qgb2YgdmFyaWFibGUgYmluZGluZ3MgdGhpcyBpcyBxdWVyeWluZyBmb3IuXHJcbiAgICAgICAgICogT25seSBhcHBsaWNhYmxlIGlmIHRoaXMgaXMgYSB2YXJpYWJsZSBiaW5kaW5ncyBxdWVyeS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KHRoaXMuc2VsZWN0b3IsIG5ldyBSZWdFeHAoXCIsXCIpKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBRdWVyeU1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQFF1ZXJ5KFwiICsgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLnNlbGVjdG9yKSArIFwiKVwiOyB9O1xyXG4gICAgUXVlcnlNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3QsIE9iamVjdF0pXHJcbiAgICBdLCBRdWVyeU1ldGFkYXRhKTtcclxuICAgIHJldHVybiBRdWVyeU1ldGFkYXRhO1xyXG59KShtZXRhZGF0YV8xLkRlcGVuZGVuY3lNZXRhZGF0YSk7XHJcbmV4cG9ydHMuUXVlcnlNZXRhZGF0YSA9IFF1ZXJ5TWV0YWRhdGE7XHJcbi8vIFRPRE86IGFkZCBhbiBleGFtcGxlIGFmdGVyIENvbnRlbnRDaGlsZHJlbiBhbmQgVmlld0NoaWxkcmVuIGFyZSBpbiBtYXN0ZXJcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxyXG4gKlxyXG4gKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBDb250ZW50Q2hpbGRyZW4oQ2hpbGREaXJlY3RpdmUpIGNvbnRlbnRDaGlsZHJlbjogUXVlcnlMaXN0PENoaWxkRGlyZWN0aXZlPjtcclxuICpcclxuICogICBhZnRlckNvbnRlbnRJbml0KCkge1xyXG4gKiAgICAgLy8gY29udGVudENoaWxkcmVuIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udGVudENoaWxkcmVuTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5kZXNjZW5kYW50cywgZGVzY2VuZGFudHMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IGRlc2NlbmRhbnRzIH0pO1xyXG4gICAgfVxyXG4gICAgQ29udGVudENoaWxkcmVuTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0LCBPYmplY3RdKVxyXG4gICAgXSwgQ29udGVudENoaWxkcmVuTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhO1xyXG59KShRdWVyeU1ldGFkYXRhKTtcclxuZXhwb3J0cy5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhO1xyXG4vLyBUT0RPOiBhZGQgYW4gZXhhbXBsZSBhZnRlciBDb250ZW50Q2hpbGQgYW5kIFZpZXdDaGlsZCBhcmUgaW4gbWFzdGVyXHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgY29udGVudCBxdWVyeS5cclxuICpcclxuICogQ29udGVudCBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJDb250ZW50SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBTb21lRGlyIHtcclxuICogICBAQ29udGVudENoaWxkKENoaWxkRGlyZWN0aXZlKSBjb250ZW50Q2hpbGQ7XHJcbiAqXHJcbiAqICAgYWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICogICAgIC8vIGNvbnRlbnRDaGlsZCBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgQ29udGVudENoaWxkTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRlbnRDaGlsZE1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udGVudENoaWxkTWV0YWRhdGEoX3NlbGVjdG9yKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX3NlbGVjdG9yLCB7IGRlc2NlbmRhbnRzOiB0cnVlLCBmaXJzdDogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIENvbnRlbnRDaGlsZE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBDb250ZW50Q2hpbGRNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gQ29udGVudENoaWxkTWV0YWRhdGE7XHJcbn0pKFF1ZXJ5TWV0YWRhdGEpO1xyXG5leHBvcnRzLkNvbnRlbnRDaGlsZE1ldGFkYXRhID0gQ29udGVudENoaWxkTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIHtAbGluayBRdWVyeU1ldGFkYXRhfSwgYnV0IHF1ZXJ5aW5nIHRoZSBjb21wb25lbnQgdmlldywgaW5zdGVhZCBvZlxyXG4gKiB0aGUgY29udGVudCBjaGlsZHJlbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2VOc0ZIRGY3WWp5TTZJekt4TTFqP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogQENvbXBvbmVudCh7Li4ufSlcclxuICogQFZpZXcoe1xyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8aXRlbT4gYSA8L2l0ZW0+XHJcbiAqICAgICA8aXRlbT4gYiA8L2l0ZW0+XHJcbiAqICAgICA8aXRlbT4gYyA8L2l0ZW0+XHJcbiAqICAgYFxyXG4gKiB9KVxyXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XHJcbiAqICAgc2hvd246IGJvb2xlYW47XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBAUXVlcnkoSXRlbSkgaXRlbXM6UXVlcnlMaXN0PEl0ZW0+KSB7XHJcbiAqICAgICBpdGVtcy5vbkNoYW5nZSgoKSA9PiBjb25zb2xlLmxvZyhpdGVtcy5sZW5ndGgpKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFN1cHBvcnRzIHRoZSBzYW1lIHF1ZXJ5aW5nIHBhcmFtZXRlcnMgYXMge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LCBleGNlcHRcclxuICogYGRlc2NlbmRhbnRzYC4gVGhpcyBhbHdheXMgcXVlcmllcyB0aGUgd2hvbGUgdmlldy5cclxuICpcclxuICogQXMgYHNob3duYCBpcyBmbGlwcGVkIGJldHdlZW4gdHJ1ZSBhbmQgZmFsc2UsIGl0ZW1zIHdpbGwgY29udGFpbiB6ZXJvIG9mIG9uZVxyXG4gKiBpdGVtcy5cclxuICpcclxuICogU3BlY2lmaWVzIHRoYXQgYSB7QGxpbmsgUXVlcnlMaXN0fSBzaG91bGQgYmUgaW5qZWN0ZWQuXHJcbiAqXHJcbiAqIFRoZSBpbmplY3RlZCBvYmplY3QgaXMgYW4gaXRlcmFibGUgYW5kIG9ic2VydmFibGUgbGl2ZSBsaXN0LlxyXG4gKiBTZWUge0BsaW5rIFF1ZXJ5TGlzdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbnZhciBWaWV3UXVlcnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlld1F1ZXJ5TWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3UXVlcnlNZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2IuZmlyc3QsIGZpcnN0ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Q7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX3NlbGVjdG9yLCB7IGRlc2NlbmRhbnRzOiBkZXNjZW5kYW50cywgZmlyc3Q6IGZpcnN0IH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpc1ZpZXdRdWVyeVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYWx3YXlzIGB0cnVlYCB0byBkaWZmZXJlbnRpYXRlIGl0IHdpdGgge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBWaWV3UXVlcnlNZXRhZGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkBWaWV3UXVlcnkoXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHRoaXMuc2VsZWN0b3IpICsgXCIpXCI7IH07XHJcbiAgICBWaWV3UXVlcnlNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3QsIE9iamVjdF0pXHJcbiAgICBdLCBWaWV3UXVlcnlNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gVmlld1F1ZXJ5TWV0YWRhdGE7XHJcbn0pKFF1ZXJ5TWV0YWRhdGEpO1xyXG5leHBvcnRzLlZpZXdRdWVyeU1ldGFkYXRhID0gVmlld1F1ZXJ5TWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgdmlldyBxdWVyeS5cclxuICpcclxuICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJWaWV3SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJyxcclxuICogICB0ZW1wbGF0ZVVybDogJ3NvbWVUZW1wbGF0ZScsXHJcbiAqICAgZGlyZWN0aXZlczogW0l0ZW1EaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBWaWV3Q2hpbGRyZW4oSXRlbURpcmVjdGl2ZSkgdmlld0NoaWxkcmVuOiBRdWVyeUxpc3Q8SXRlbURpcmVjdGl2ZT47XHJcbiAqXHJcbiAqICAgYWZ0ZXJWaWV3SW5pdCgpIHtcclxuICogICAgIC8vIHZpZXdDaGlsZHJlbiBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgVmlld0NoaWxkcmVuTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZpZXdDaGlsZHJlbk1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlld0NoaWxkcmVuTWV0YWRhdGEoX3NlbGVjdG9yKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX3NlbGVjdG9yLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgVmlld0NoaWxkcmVuTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIFZpZXdDaGlsZHJlbk1ldGFkYXRhKTtcclxuICAgIHJldHVybiBWaWV3Q2hpbGRyZW5NZXRhZGF0YTtcclxufSkoVmlld1F1ZXJ5TWV0YWRhdGEpO1xyXG5leHBvcnRzLlZpZXdDaGlsZHJlbk1ldGFkYXRhID0gVmlld0NoaWxkcmVuTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgdmlldyBxdWVyeS5cclxuICpcclxuICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJWaWV3SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJyxcclxuICogICB0ZW1wbGF0ZVVybDogJ3NvbWVUZW1wbGF0ZScsXHJcbiAqICAgZGlyZWN0aXZlczogW0l0ZW1EaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBWaWV3Q2hpbGQoSXRlbURpcmVjdGl2ZSkgdmlld0NoaWxkOkl0ZW1EaXJlY3RpdmU7XHJcbiAqXHJcbiAqICAgYWZ0ZXJWaWV3SW5pdCgpIHtcclxuICogICAgIC8vIHZpZXdDaGlsZCBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgVmlld0NoaWxkTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZpZXdDaGlsZE1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlld0NoaWxkTWV0YWRhdGEoX3NlbGVjdG9yKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX3NlbGVjdG9yLCB7IGRlc2NlbmRhbnRzOiB0cnVlLCBmaXJzdDogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIFZpZXdDaGlsZE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBWaWV3Q2hpbGRNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gVmlld0NoaWxkTWV0YWRhdGE7XHJcbn0pKFZpZXdRdWVyeU1ldGFkYXRhKTtcclxuZXhwb3J0cy5WaWV3Q2hpbGRNZXRhZGF0YSA9IFZpZXdDaGlsZE1ldGFkYXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGkvbWV0YWRhdGEnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxuLyoqXHJcbiAqIERpcmVjdGl2ZXMgYWxsb3cgeW91IHRvIGF0dGFjaCBiZWhhdmlvciB0byBlbGVtZW50cyBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9cyB3aXRoIGFuIGVtYmVkZGVkIHZpZXcgYXJlIGNhbGxlZCB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9cy5cclxuICpcclxuICogQSBkaXJlY3RpdmUgY29uc2lzdHMgb2YgYSBzaW5nbGUgZGlyZWN0aXZlIGFubm90YXRpb24gYW5kIGEgY29udHJvbGxlciBjbGFzcy4gV2hlbiB0aGVcclxuICogZGlyZWN0aXZlJ3MgYHNlbGVjdG9yYCBtYXRjaGVzXHJcbiAqIGVsZW1lbnRzIGluIHRoZSBET00sIHRoZSBmb2xsb3dpbmcgc3RlcHMgb2NjdXI6XHJcbiAqXHJcbiAqIDEuIEZvciBlYWNoIGRpcmVjdGl2ZSwgdGhlIGBFbGVtZW50SW5qZWN0b3JgIGF0dGVtcHRzIHRvIHJlc29sdmUgdGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXHJcbiAqIGFyZ3VtZW50cy5cclxuICogMi4gQW5ndWxhciBpbnN0YW50aWF0ZXMgZGlyZWN0aXZlcyBmb3IgZWFjaCBtYXRjaGVkIGVsZW1lbnQgdXNpbmcgYEVsZW1lbnRJbmplY3RvcmAgaW4gYVxyXG4gKiBkZXB0aC1maXJzdCBvcmRlcixcclxuICogICAgYXMgZGVjbGFyZWQgaW4gdGhlIEhUTUwuXHJcbiAqXHJcbiAqICMjIFVuZGVyc3RhbmRpbmcgSG93IEluamVjdGlvbiBXb3Jrc1xyXG4gKlxyXG4gKiBUaGVyZSBhcmUgdGhyZWUgc3RhZ2VzIG9mIGluamVjdGlvbiByZXNvbHV0aW9uLlxyXG4gKiAtICpQcmUtZXhpc3RpbmcgSW5qZWN0b3JzKjpcclxuICogICAtIFRoZSB0ZXJtaW5hbCB7QGxpbmsgSW5qZWN0b3J9IGNhbm5vdCByZXNvbHZlIGRlcGVuZGVuY2llcy4gSXQgZWl0aGVyIHRocm93cyBhbiBlcnJvciBvciwgaWZcclxuICogdGhlIGRlcGVuZGVuY3kgd2FzXHJcbiAqICAgICBzcGVjaWZpZWQgYXMgYEBPcHRpb25hbGAsIHJldHVybnMgYG51bGxgLlxyXG4gKiAgIC0gVGhlIHBsYXRmb3JtIGluamVjdG9yIHJlc29sdmVzIGJyb3dzZXIgc2luZ2xldG9uIHJlc291cmNlcywgc3VjaCBhczogY29va2llcywgdGl0bGUsXHJcbiAqIGxvY2F0aW9uLCBhbmQgb3RoZXJzLlxyXG4gKiAtICpDb21wb25lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGl0cyBvd24ge0BsaW5rIEluamVjdG9yfSwgYW5kIHRoZXkgZm9sbG93XHJcbiAqIHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHlcclxuICogICAgIGFzIHRoZSBjb21wb25lbnQgaW5zdGFuY2VzIGluIHRoZSBET00uXHJcbiAqIC0gKkVsZW1lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGEgU2hhZG93IERPTS4gV2l0aGluIHRoZSBTaGFkb3cgRE9NIGVhY2hcclxuICogZWxlbWVudCBoYXMgYW4gYEVsZW1lbnRJbmplY3RvcmBcclxuICogICAgIHdoaWNoIGZvbGxvdyB0aGUgc2FtZSBwYXJlbnQtY2hpbGQgaGllcmFyY2h5IGFzIHRoZSBET00gZWxlbWVudHMgdGhlbXNlbHZlcy5cclxuICpcclxuICogV2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZCwgaXQgYWxzbyBtdXN0IGluc3RhbnRpYXRlIHRoZSBjb3JyZXNwb25kaW5nIGRpcmVjdGl2ZXMgaW4gYVxyXG4gKiBkZXB0aC1maXJzdCBvcmRlci4gVGhlXHJcbiAqIGN1cnJlbnQgYEVsZW1lbnRJbmplY3RvcmAgcmVzb2x2ZXMgdGhlIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcyBmb3IgZWFjaCBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqIEFuZ3VsYXIgdGhlbiByZXNvbHZlcyBkZXBlbmRlbmNpZXMgYXMgZm9sbG93cywgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhciBpbiB0aGVcclxuICoge0BsaW5rIFZpZXdNZXRhZGF0YX06XHJcbiAqXHJcbiAqIDEuIERlcGVuZGVuY2llcyBvbiB0aGUgY3VycmVudCBlbGVtZW50XHJcbiAqIDIuIERlcGVuZGVuY2llcyBvbiBlbGVtZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgU2hhZG93IERPTSBib3VuZGFyeVxyXG4gKiAzLiBEZXBlbmRlbmNpZXMgb24gY29tcG9uZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIHRoZSByb290IGNvbXBvbmVudFxyXG4gKiA0LiBEZXBlbmRlbmNpZXMgb24gcHJlLWV4aXN0aW5nIGluamVjdG9yc1xyXG4gKlxyXG4gKlxyXG4gKiBUaGUgYEVsZW1lbnRJbmplY3RvcmAgY2FuIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBlbGVtZW50LXNwZWNpZmljIHNwZWNpYWwgb2JqZWN0cywgb3IgaXQgY2FuXHJcbiAqIGRlbGVnYXRlIHRvIHRoZSBwYXJlbnRcclxuICogaW5qZWN0b3IuXHJcbiAqXHJcbiAqIFRvIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XHJcbiAqIC0gYGRpcmVjdGl2ZTpEaXJlY3RpdmVUeXBlYDogYSBkaXJlY3RpdmUgb24gdGhlIGN1cnJlbnQgZWxlbWVudCBvbmx5XHJcbiAqIC0gYEBIb3N0KCkgZGlyZWN0aXZlOkRpcmVjdGl2ZVR5cGVgOiBhbnkgZGlyZWN0aXZlIHRoYXQgbWF0Y2hlcyB0aGUgdHlwZSBiZXR3ZWVuIHRoZSBjdXJyZW50XHJcbiAqIGVsZW1lbnQgYW5kIHRoZVxyXG4gKiAgICBTaGFkb3cgRE9NIHJvb3QuXHJcbiAqIC0gYEBRdWVyeShEaXJlY3RpdmVUeXBlKSBxdWVyeTpRdWVyeUxpc3Q8RGlyZWN0aXZlVHlwZT5gOiBBIGxpdmUgY29sbGVjdGlvbiBvZiBkaXJlY3QgY2hpbGRcclxuICogZGlyZWN0aXZlcy5cclxuICogLSBgQFF1ZXJ5RGVzY2VuZGFudHMoRGlyZWN0aXZlVHlwZSkgcXVlcnk6UXVlcnlMaXN0PERpcmVjdGl2ZVR5cGU+YDogQSBsaXZlIGNvbGxlY3Rpb24gb2YgYW55XHJcbiAqIGNoaWxkIGRpcmVjdGl2ZXMuXHJcbiAqXHJcbiAqIFRvIGluamVjdCBlbGVtZW50LXNwZWNpZmljIHNwZWNpYWwgb2JqZWN0cywgZGVjbGFyZSB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVyIGFzOlxyXG4gKiAtIGBlbGVtZW50OiBFbGVtZW50UmVmYCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gbG9naWNhbCBlbGVtZW50IGluIHRoZSB2aWV3LlxyXG4gKiAtIGB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmYCB0byBjb250cm9sIGNoaWxkIHRlbXBsYXRlIGluc3RhbnRpYXRpb24sIGZvclxyXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9IGRpcmVjdGl2ZXMgb25seVxyXG4gKiAtIGBiaW5kaW5nUHJvcGFnYXRpb246IEJpbmRpbmdQcm9wYWdhdGlvbmAgdG8gY29udHJvbCBjaGFuZ2UgZGV0ZWN0aW9uIGluIGEgbW9yZSBncmFudWxhciB3YXkuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlbW9uc3RyYXRlcyBob3cgZGVwZW5kZW5jeSBpbmplY3Rpb24gcmVzb2x2ZXMgY29uc3RydWN0b3IgYXJndW1lbnRzIGluXHJcbiAqIHByYWN0aWNlLlxyXG4gKlxyXG4gKlxyXG4gKiBBc3N1bWUgdGhpcyBIVE1MIHRlbXBsYXRlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGRpdiBkZXBlbmRlbmN5PVwiMVwiPlxyXG4gKiAgIDxkaXYgZGVwZW5kZW5jeT1cIjJcIj5cclxuICogICAgIDxkaXYgZGVwZW5kZW5jeT1cIjNcIiBteS1kaXJlY3RpdmU+XHJcbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjRcIj5cclxuICogICAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI1XCI+PC9kaXY+XHJcbiAqICAgICAgIDwvZGl2PlxyXG4gKiAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI2XCI+PC9kaXY+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICA8L2Rpdj5cclxuICogPC9kaXY+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBXaXRoIHRoZSBmb2xsb3dpbmcgYGRlcGVuZGVuY3lgIGRlY29yYXRvciBhbmQgYFNvbWVTZXJ2aWNlYCBpbmplY3RhYmxlIGNsYXNzLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBTb21lU2VydmljZSB7XHJcbiAqIH1cclxuICpcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdbZGVwZW5kZW5jeV0nLFxyXG4gKiAgIGlucHV0czogW1xyXG4gKiAgICAgJ2lkOiBkZXBlbmRlbmN5J1xyXG4gKiAgIF1cclxuICogfSlcclxuICogY2xhc3MgRGVwZW5kZW5jeSB7XHJcbiAqICAgaWQ6c3RyaW5nO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZXQncyBzdGVwIHRocm91Z2ggdGhlIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIGBNeURpcmVjdGl2ZWAgY291bGQgYmUgZGVjbGFyZWQuLi5cclxuICpcclxuICpcclxuICogIyMjIE5vIGluamVjdGlvblxyXG4gKlxyXG4gKiBIZXJlIHRoZSBjb25zdHJ1Y3RvciBpcyBkZWNsYXJlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlcmVmb3JlIG5vdGhpbmcgaXMgaW5qZWN0ZWQgaW50b1xyXG4gKiBgTXlEaXJlY3RpdmVgLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIG5vIGRlcGVuZGVuY2llcy5cclxuICpcclxuICpcclxuICogIyMjIENvbXBvbmVudC1sZXZlbCBpbmplY3Rpb25cclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IGFueSBpbmplY3RhYmxlIGluc3RhbmNlIGZyb20gdGhlIGNsb3Nlc3QgY29tcG9uZW50IGluamVjdG9yIG9yIGFueSBvZiBpdHNcclxuICogcGFyZW50cy5cclxuICpcclxuICogSGVyZSwgdGhlIGNvbnN0cnVjdG9yIGRlY2xhcmVzIGEgcGFyYW1ldGVyLCBgc29tZVNlcnZpY2VgLCBhbmQgaW5qZWN0cyB0aGUgYFNvbWVTZXJ2aWNlYCB0eXBlXHJcbiAqIGZyb20gdGhlIHBhcmVudFxyXG4gKiBjb21wb25lbnQncyBpbmplY3Rvci5cclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3Ioc29tZVNlcnZpY2U6IFNvbWVTZXJ2aWNlKSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGRlcGVuZGVuY3kgb24gYFNvbWVTZXJ2aWNlYC5cclxuICpcclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGRpcmVjdGl2ZSBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRcclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMgZGVjbGFyZWQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoZGVwZW5kZW5jeTogRGVwZW5kZW5jeSkge1xyXG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBgRGVwZW5kZW5jeWAgZGVjbGFyZWQgYXQgdGhlIHNhbWUgZWxlbWVudCwgaW4gdGhpcyBjYXNlXHJcbiAqIGBkZXBlbmRlbmN5PVwiM1wiYC5cclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGRpcmVjdGl2ZSBmcm9tIGFueSBhbmNlc3RvciBlbGVtZW50c1xyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiBhbnkgYW5jZXN0b3IgZWxlbWVudCAoaW4gdGhlIGN1cnJlbnQgU2hhZG93XHJcbiAqIERPTSksIGkuZS4gb24gdGhlIGN1cnJlbnQgZWxlbWVudCwgdGhlXHJcbiAqIHBhcmVudCBlbGVtZW50LCBvciBpdHMgcGFyZW50cy5cclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoQEhvc3QoKSBkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XHJcbiAqICAgICBleHBlY3QoZGVwZW5kZW5jeS5pZCkudG9FcXVhbCgyKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIGBASG9zdGAgY2hlY2tzIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZSBwYXJlbnQsIGFzIHdlbGwgYXMgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkuIElmXHJcbiAqIGBkZXBlbmRlbmN5PVwiMlwiYCBkaWRuJ3RcclxuICogZXhpc3Qgb24gdGhlIGRpcmVjdCBwYXJlbnQsIHRoaXMgaW5qZWN0aW9uIHdvdWxkXHJcbiAqIGhhdmUgcmV0dXJuZWRcclxuICogYGRlcGVuZGVuY3k9XCIxXCJgLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZCBkaXJlY3RpdmVzXHJcbiAqXHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIGNhbiBhbHNvIHF1ZXJ5IGZvciBvdGhlciBjaGlsZCBkaXJlY3RpdmVzLiBTaW5jZSBwYXJlbnQgZGlyZWN0aXZlcyBhcmUgaW5zdGFudGlhdGVkXHJcbiAqIGJlZm9yZSBjaGlsZCBkaXJlY3RpdmVzLCBhIGRpcmVjdGl2ZSBjYW4ndCBzaW1wbHkgaW5qZWN0IHRoZSBsaXN0IG9mIGNoaWxkIGRpcmVjdGl2ZXMuIEluc3RlYWQsXHJcbiAqIHRoZSBkaXJlY3RpdmUgaW5qZWN0cyBhIHtAbGluayBRdWVyeUxpc3R9LCB3aGljaCB1cGRhdGVzIGl0cyBjb250ZW50cyBhcyBjaGlsZHJlbiBhcmUgYWRkZWQsXHJcbiAqIHJlbW92ZWQsIG9yIG1vdmVkIGJ5IGEgZGlyZWN0aXZlIHRoYXQgdXNlcyBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSBzdWNoIGFzIGEgYG5nLWZvcmAsIGFuXHJcbiAqIGBuZy1pZmAsIG9yIGFuIGBuZy1zd2l0Y2hgLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoRGVwZW5kZW5jeSkgZGVwZW5kZW5jaWVzOlF1ZXJ5TGlzdDxEZXBlbmRlbmN5Pikge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSB7QGxpbmsgUXVlcnlMaXN0fSB3aGljaCBjb250YWlucyBgRGVwZW5kZW5jeWAgNCBhbmRcclxuICogNi4gSGVyZSwgYERlcGVuZGVuY3lgIDUgd291bGQgbm90IGJlIGluY2x1ZGVkLCBiZWNhdXNlIGl0IGlzIG5vdCBhIGRpcmVjdCBjaGlsZC5cclxuICpcclxuICogIyMjIEluamVjdGluZyBhIGxpdmUgY29sbGVjdGlvbiBvZiBkZXNjZW5kYW50IGRpcmVjdGl2ZXNcclxuICpcclxuICogQnkgcGFzc2luZyB0aGUgZGVzY2VuZGFudCBmbGFnIHRvIGBAUXVlcnlgIGFib3ZlLCB3ZSBjYW4gaW5jbHVkZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGNoaWxkXHJcbiAqIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoRGVwZW5kZW5jeSwge2Rlc2NlbmRhbnRzOiB0cnVlfSkgZGVwZW5kZW5jaWVzOlF1ZXJ5TGlzdDxEZXBlbmRlbmN5Pikge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBRdWVyeSB3aGljaCB3b3VsZCBjb250YWluIGBEZXBlbmRlbmN5YCA0LCA1IGFuZCA2LlxyXG4gKlxyXG4gKiAjIyMgT3B0aW9uYWwgaW5qZWN0aW9uXHJcbiAqXHJcbiAqIFRoZSBub3JtYWwgYmVoYXZpb3Igb2YgZGlyZWN0aXZlcyBpcyB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBhIHNwZWNpZmllZCBkZXBlbmRlbmN5IGNhbm5vdCBiZVxyXG4gKiByZXNvbHZlZC4gSWYgeW91XHJcbiAqIHdvdWxkIGxpa2UgdG8gaW5qZWN0IGBudWxsYCBvbiB1bnJlc29sdmVkIGRlcGVuZGVuY3kgaW5zdGVhZCwgeW91IGNhbiBhbm5vdGF0ZSB0aGF0IGRlcGVuZGVuY3lcclxuICogd2l0aCBgQE9wdGlvbmFsKClgLlxyXG4gKiBUaGlzIGV4cGxpY2l0bHkgcGVybWl0cyB0aGUgYXV0aG9yIG9mIGEgdGVtcGxhdGUgdG8gdHJlYXQgc29tZSBvZiB0aGUgc3Vycm91bmRpbmcgZGlyZWN0aXZlcyBhc1xyXG4gKiBvcHRpb25hbC5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxyXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XHJcbiAqICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGBEZXBlbmRlbmN5YCBkaXJlY3RpdmUgZm91bmQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICogSWYgbm9uZSBjYW4gYmVcclxuICogZm91bmQsIHRoZSBpbmplY3RvciBzdXBwbGllcyBgbnVsbGAgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvci5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBIZXJlIHdlIHVzZSBhIGRlY29yYXRvciBkaXJlY3RpdmUgdG8gc2ltcGx5IGRlZmluZSBiYXNpYyB0b29sLXRpcCBiZWhhdmlvci5cclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnW3Rvb2x0aXBdJyxcclxuICogICBpbnB1dHM6IFtcclxuICogICAgICd0ZXh0OiB0b29sdGlwJ1xyXG4gKiAgIF0sXHJcbiAqICAgaG9zdDoge1xyXG4gKiAgICAgJyhtb3VzZWVudGVyKSc6ICdvbk1vdXNlRW50ZXIoKScsXHJcbiAqICAgICAnKG1vdXNlbGVhdmUpJzogJ29uTW91c2VMZWF2ZSgpJ1xyXG4gKiAgIH1cclxuICogfSlcclxuICogY2xhc3MgVG9vbHRpcHtcclxuICogICB0ZXh0OnN0cmluZztcclxuICogICBvdmVybGF5Ok92ZXJsYXk7IC8vIE5PVCBZRVQgSU1QTEVNRU5URURcclxuICogICBvdmVybGF5TWFuYWdlcjpPdmVybGF5TWFuYWdlcjsgLy8gTk9UIFlFVCBJTVBMRU1FTlRFRFxyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyKSB7XHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xyXG4gKiAgIH1cclxuICpcclxuICogICBvbk1vdXNlRW50ZXIoKSB7XHJcbiAqICAgICAvLyBleGFjdCBzaWduYXR1cmUgdG8gYmUgZGV0ZXJtaW5lZFxyXG4gKiAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5vdmVybGF5TWFuYWdlci5vcGVuKHRleHQsIC4uLik7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIG9uTW91c2VMZWF2ZSgpIHtcclxuICogICAgIHRoaXMub3ZlcmxheS5jbG9zZSgpO1xyXG4gKiAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqIEluIG91ciBIVE1MIHRlbXBsYXRlLCB3ZSBjYW4gdGhlbiBhZGQgdGhpcyBiZWhhdmlvciB0byBhIGA8ZGl2PmAgb3IgYW55IG90aGVyIGVsZW1lbnQgd2l0aCB0aGVcclxuICogYHRvb2x0aXBgIHNlbGVjdG9yLFxyXG4gKiBsaWtlIHNvOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGRpdiB0b29sdGlwPVwic29tZSB0ZXh0IGhlcmVcIj48L2Rpdj5cclxuICogYGBgXHJcbiAqXHJcbiAqIERpcmVjdGl2ZXMgY2FuIGFsc28gY29udHJvbCB0aGUgaW5zdGFudGlhdGlvbiwgZGVzdHJ1Y3Rpb24sIGFuZCBwb3NpdGlvbmluZyBvZiBpbmxpbmUgdGVtcGxhdGVcclxuICogZWxlbWVudHM6XHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIHVzZXMgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gdG8gaW5zdGFudGlhdGUsIGluc2VydCwgbW92ZSwgYW5kIGRlc3Ryb3kgdmlld3MgYXRcclxuICogcnVudGltZS5cclxuICogVGhlIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSBpcyBjcmVhdGVkIGFzIGEgcmVzdWx0IG9mIGA8dGVtcGxhdGU+YCBlbGVtZW50LCBhbmQgcmVwcmVzZW50cyBhXHJcbiAqIGxvY2F0aW9uIGluIHRoZSBjdXJyZW50IHZpZXdcclxuICogd2hlcmUgdGhlc2UgYWN0aW9ucyBhcmUgcGVyZm9ybWVkLlxyXG4gKlxyXG4gKiBWaWV3cyBhcmUgYWx3YXlzIGNyZWF0ZWQgYXMgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQge0BsaW5rIFZpZXdNZXRhZGF0YX0sIGFuZCBhcyBzaWJsaW5ncyBvZiB0aGVcclxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuIFRodXMgYVxyXG4gKiBkaXJlY3RpdmUgaW4gYSBjaGlsZCB2aWV3IGNhbm5vdCBpbmplY3QgdGhlIGRpcmVjdGl2ZSB0aGF0IGNyZWF0ZWQgaXQuXHJcbiAqXHJcbiAqIFNpbmNlIGRpcmVjdGl2ZXMgdGhhdCBjcmVhdGUgdmlld3MgdmlhIFZpZXdDb250YWluZXJzIGFyZSBjb21tb24gaW4gQW5ndWxhciwgYW5kIHVzaW5nIHRoZSBmdWxsXHJcbiAqIGA8dGVtcGxhdGU+YCBlbGVtZW50IHN5bnRheCBpcyB3b3JkeSwgQW5ndWxhclxyXG4gKiBhbHNvIHN1cHBvcnRzIGEgc2hvcnRoYW5kIG5vdGF0aW9uOiBgPGxpICpmb289XCJiYXJcIj5gIGFuZCBgPGxpIHRlbXBsYXRlPVwiZm9vOiBiYXJcIj5gIGFyZVxyXG4gKiBlcXVpdmFsZW50LlxyXG4gKlxyXG4gKiBUaHVzLFxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDxsaSAqZm9vPVwiYmFyXCIgdGl0bGU9XCJ0ZXh0XCI+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEV4cGFuZHMgaW4gdXNlIHRvOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBbZm9vXT1cImJhclwiPlxyXG4gKiAgICAgPGxpIHRpdGxlPVwidGV4dFwiPjwvbGk+XHJcbiAqICAgPC90ZW1wbGF0ZT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IGFsdGhvdWdoIHRoZSBzaG9ydGhhbmQgcGxhY2VzIGAqZm9vPVwiYmFyXCJgIHdpdGhpbiB0aGUgYDxsaT5gIGVsZW1lbnQsIHRoZSBiaW5kaW5nIGZvclxyXG4gKiB0aGUgZGlyZWN0aXZlXHJcbiAqIGNvbnRyb2xsZXIgaXMgY29ycmVjdGx5IGluc3RhbnRpYXRlZCBvbiB0aGUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgcmF0aGVyIHRoYW4gdGhlIGA8bGk+YCBlbGVtZW50LlxyXG4gKlxyXG4gKiAjIyBMaWZlY3ljbGUgaG9va3NcclxuICpcclxuICogV2hlbiB0aGUgZGlyZWN0aXZlIGNsYXNzIGltcGxlbWVudHMgc29tZSB7QGxpbmsgYW5ndWxhcjIvbGlmZWN5Y2xlX2hvb2tzfSB0aGUgY2FsbGJhY2tzIGFyZVxyXG4gKiBjYWxsZWQgYnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gYXQgZGVmaW5lZCBwb2ludHMgaW4gdGltZSBkdXJpbmcgdGhlIGxpZmUgb2YgdGhlIGRpcmVjdGl2ZS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBMZXQncyBzdXBwb3NlIHdlIHdhbnQgdG8gaW1wbGVtZW50IHRoZSBgdW5sZXNzYCBiZWhhdmlvciwgdG8gY29uZGl0aW9uYWxseSBpbmNsdWRlIGEgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIEhlcmUgaXMgYSBzaW1wbGUgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcnMgb24gYW4gYHVubGVzc2Agc2VsZWN0b3I6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ1t1bmxlc3NdJyxcclxuICogICBpbnB1dHM6IFsndW5sZXNzJ11cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIFVubGVzcyB7XHJcbiAqICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcclxuICogICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY7XHJcbiAqICAgcHJldkNvbmRpdGlvbjogYm9vbGVhbjtcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWYpIHtcclxuICogICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XHJcbiAqICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XHJcbiAqICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBudWxsO1xyXG4gKiAgIH1cclxuICpcclxuICogICBzZXQgdW5sZXNzKG5ld0NvbmRpdGlvbikge1xyXG4gKiAgICAgaWYgKG5ld0NvbmRpdGlvbiAmJiAoaXNCbGFuayh0aGlzLnByZXZDb25kaXRpb24pIHx8ICF0aGlzLnByZXZDb25kaXRpb24pKSB7XHJcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IHRydWU7XHJcbiAqICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xyXG4gKiAgICAgfSBlbHNlIGlmICghbmV3Q29uZGl0aW9uICYmIChpc0JsYW5rKHRoaXMucHJldkNvbmRpdGlvbikgfHwgdGhpcy5wcmV2Q29uZGl0aW9uKSkge1xyXG4gKiAgICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBmYWxzZTtcclxuICogICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZSh0aGlzLnRlbXBsYXRlUmVmKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFdlIGNhbiB0aGVuIHVzZSB0aGlzIGB1bmxlc3NgIHNlbGVjdG9yIGluIGEgdGVtcGxhdGU6XHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICp1bmxlc3M9XCJleHByXCI+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE9uY2UgdGhlIGRpcmVjdGl2ZSBpbnN0YW50aWF0ZXMgdGhlIGNoaWxkIHZpZXcsIHRoZSBzaG9ydGhhbmQgbm90YXRpb24gZm9yIHRoZSB0ZW1wbGF0ZSBleHBhbmRzXHJcbiAqIGFuZCB0aGUgcmVzdWx0IGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBbdW5sZXNzXT1cImV4cFwiPlxyXG4gKiAgICAgPGxpPjwvbGk+XHJcbiAqICAgPC90ZW1wbGF0ZT5cclxuICogICA8bGk+PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgYWxzbyB0aGF0IGFsdGhvdWdoIHRoZSBgPGxpPjwvbGk+YCB0ZW1wbGF0ZSBzdGlsbCBleGlzdHMgaW5zaWRlIHRoZSBgPHRlbXBsYXRlPjwvdGVtcGxhdGU+YCxcclxuICogdGhlIGluc3RhbnRpYXRlZFxyXG4gKiB2aWV3IG9jY3VycyBvbiB0aGUgc2Vjb25kIGA8bGk+PC9saT5gIHdoaWNoIGlzIGEgc2libGluZyB0byB0aGUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXHJcbiAqL1xyXG52YXIgRGlyZWN0aXZlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERpcmVjdGl2ZU1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgcHJvcGVydGllcyA9IF9iLnByb3BlcnRpZXMsIGV2ZW50cyA9IF9iLmV2ZW50cywgaG9zdCA9IF9iLmhvc3QsIGJpbmRpbmdzID0gX2IuYmluZGluZ3MsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgbW9kdWxlSWQgPSBfYi5tb2R1bGVJZCwgcXVlcmllcyA9IF9iLnF1ZXJpZXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgIHRoaXMuX2lucHV0cyA9IGlucHV0cztcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuICAgICAgICB0aGlzLl9vdXRwdXRzID0gb3V0cHV0cztcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBldmVudHM7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVJZCA9IG1vZHVsZUlkO1xyXG4gICAgICAgIHRoaXMucXVlcmllcyA9IHF1ZXJpZXM7XHJcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzID0gcHJvdmlkZXJzO1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzID0gYmluZGluZ3M7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImlucHV0c1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW51bWVyYXRlcyB0aGUgc2V0IG9mIGRhdGEtYm91bmQgaW5wdXQgcHJvcGVydGllcyBmb3IgYSBkaXJlY3RpdmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSB1cGRhdGVzIGlucHV0IHByb3BlcnRpZXMgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgYGlucHV0c2AgcHJvcGVydHkgZGVmaW5lcyBhIHNldCBvZiBgZGlyZWN0aXZlUHJvcGVydHlgIHRvIGBiaW5kaW5nUHJvcGVydHlgXHJcbiAgICAgICAgICogY29uZmlndXJhdGlvbjpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0gYGRpcmVjdGl2ZVByb3BlcnR5YCBzcGVjaWZpZXMgdGhlIGNvbXBvbmVudCBwcm9wZXJ0eSB3aGVyZSB0aGUgdmFsdWUgaXMgd3JpdHRlbi5cclxuICAgICAgICAgKiAtIGBiaW5kaW5nUHJvcGVydHlgIHNwZWNpZmllcyB0aGUgRE9NIHByb3BlcnR5IHdoZXJlIHRoZSB2YWx1ZSBpcyByZWFkIGZyb20uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGBiaW5kaW5nUHJvcGVydHlgIGlzIG5vdCBwcm92aWRlZCwgaXQgaXMgYXNzdW1lZCB0byBiZSBlcXVhbCB0byBgZGlyZWN0aXZlUHJvcGVydHlgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2l2aGZYWT9wPXByZXZpZXcpKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgd2l0aCB0d28gZGF0YS1ib3VuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xyXG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdiYW5rLWFjY291bnQnLFxyXG4gICAgICAgICAqICAgaW5wdXRzOiBbJ2JhbmtOYW1lJywgJ2lkOiBhY2NvdW50LWlkJ10sXHJcbiAgICAgICAgICogICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgICAqICAgICBCYW5rIE5hbWU6IHt7YmFua05hbWV9fVxyXG4gICAgICAgICAqICAgICBBY2NvdW50IElkOiB7e2lkfX1cclxuICAgICAgICAgKiAgIGBcclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqIGNsYXNzIEJhbmtBY2NvdW50IHtcclxuICAgICAgICAgKiAgIGJhbmtOYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgICogICBpZDogc3RyaW5nO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCBib3VuZCwgYW5kIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSBBbmd1bGFyXHJcbiAgICAgICAgICogICBub3JtYWxpemVkQmFua05hbWU6IHN0cmluZztcclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAQ29tcG9uZW50KHtcclxuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgICogICAgIDxiYW5rLWFjY291bnQgYmFuay1uYW1lPVwiUkJDXCIgYWNjb3VudC1pZD1cIjQ3NDdcIj48L2JhbmstYWNjb3VudD5cclxuICAgICAgICAgKiAgIGAsXHJcbiAgICAgICAgICogICBkaXJlY3RpdmVzOiBbQmFua0FjY291bnRdXHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiBjbGFzcyBBcHAge31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGJvb3RzdHJhcChBcHApO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3Byb3BlcnRpZXMpICYmIHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoID4gMCA/IHRoaXMuX3Byb3BlcnRpZXMgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJwcm9wZXJ0aWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5wdXRzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUsIFwib3V0cHV0c1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW51bWVyYXRlcyB0aGUgc2V0IG9mIGV2ZW50LWJvdW5kIG91dHB1dCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBhbiBvdXRwdXQgcHJvcGVydHkgZW1pdHMgYW4gZXZlbnQsIGFuIGV2ZW50IGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudFxyXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBpcyBpbnZva2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGBvdXRwdXRzYCBwcm9wZXJ0eSBkZWZpbmVzIGEgc2V0IG9mIGBkaXJlY3RpdmVQcm9wZXJ0eWAgdG8gYGJpbmRpbmdQcm9wZXJ0eWBcclxuICAgICAgICAgKiBjb25maWd1cmF0aW9uOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBgZGlyZWN0aXZlUHJvcGVydHlgIHNwZWNpZmllcyB0aGUgY29tcG9uZW50IHByb3BlcnR5IHRoYXQgZW1pdHMgZXZlbnRzLlxyXG4gICAgICAgICAqIC0gYGJpbmRpbmdQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBET00gcHJvcGVydHkgdGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZDVDTnE3P3A9cHJldmlldykpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgICAgICogQERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2ludGVydmFsLWRpcicsXHJcbiAgICAgICAgICogICBvdXRwdXRzOiBbJ2V2ZXJ5U2Vjb25kJywgJ2ZpdmU1U2VjczogZXZlcnlGaXZlU2Vjb25kcyddXHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiBjbGFzcyBJbnRlcnZhbERpciB7XHJcbiAgICAgICAgICogICBldmVyeVNlY29uZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAgKiAgIGZpdmU1U2VjcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICogICAgIHNldEludGVydmFsKCgpID0+IHRoaXMuZXZlcnlTZWNvbmQubmV4dChcImV2ZW50XCIpLCAxMDAwKTtcclxuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5maXZlNVNlY3MubmV4dChcImV2ZW50XCIpLCA1MDAwKTtcclxuICAgICAgICAgKiAgIH1cclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAQ29tcG9uZW50KHtcclxuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgICogICAgIDxpbnRlcnZhbC1kaXIgKGV2ZXJ5LXNlY29uZCk9XCJldmVyeVNlY29uZCgpXCIgKGV2ZXJ5LWZpdmUtc2Vjb25kcyk9XCJldmVyeUZpdmVTZWNvbmRzKClcIj5cclxuICAgICAgICAgKiAgICAgPC9pbnRlcnZhbC1kaXI+XHJcbiAgICAgICAgICogICBgLFxyXG4gICAgICAgICAqICAgZGlyZWN0aXZlczogW0ludGVydmFsRGlyXVxyXG4gICAgICAgICAqIH0pXHJcbiAgICAgICAgICogY2xhc3MgQXBwIHtcclxuICAgICAgICAgKiAgIGV2ZXJ5U2Vjb25kKCkgeyBjb25zb2xlLmxvZygnc2Vjb25kJyk7IH1cclxuICAgICAgICAgKiAgIGV2ZXJ5Rml2ZVNlY29uZHMoKSB7IGNvbnNvbGUubG9nKCdmaXZlIHNlY29uZHMnKTsgfVxyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKiBib290c3RyYXAoQXBwKTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9ldmVudHMpICYmIHRoaXMuX2V2ZW50cy5sZW5ndGggPiAwID8gdGhpcy5fZXZlbnRzIDogdGhpcy5fb3V0cHV0cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub3V0cHV0czsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcInByb3ZpZGVyc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyB0aGUgc2V0IG9mIGluamVjdGFibGUgb2JqZWN0cyB0aGF0IGFyZSB2aXNpYmxlIHRvIGEgRGlyZWN0aXZlIGFuZCBpdHMgbGlnaHQgRE9NXHJcbiAgICAgICAgICogY2hpbGRyZW4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAjIyBTaW1wbGUgRXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSGVyZSBpcyBhbiBleGFtcGxlIG9mIGEgY2xhc3MgdGhhdCBjYW4gYmUgaW5qZWN0ZWQ6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKiBjbGFzcyBHcmVldGVyIHtcclxuICAgICAgICAgKiAgICBncmVldChuYW1lOnN0cmluZykge1xyXG4gICAgICAgICAqICAgICAgcmV0dXJuICdIZWxsbyAnICsgbmFtZSArICchJztcclxuICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICAgICAgICAgKiAgIGJpbmRpbmdzOiBbXHJcbiAgICAgICAgICogICAgIEdyZWV0ZXJcclxuICAgICAgICAgKiAgIF1cclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqIGNsYXNzIEhlbGxvV29ybGQge1xyXG4gICAgICAgICAqICAgZ3JlZXRlcjpHcmVldGVyO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihncmVldGVyOkdyZWV0ZXIpIHtcclxuICAgICAgICAgKiAgICAgdGhpcy5ncmVldGVyID0gZ3JlZXRlcjtcclxuICAgICAgICAgKiAgIH1cclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2JpbmRpbmdzKSAmJiB0aGlzLl9iaW5kaW5ncy5sZW5ndGggPiAwID8gdGhpcy5fYmluZGluZ3MgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXJzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJiaW5kaW5nc1wiLCB7XHJcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnByb3ZpZGVyczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEaXJlY3RpdmVNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgRGlyZWN0aXZlTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIERpcmVjdGl2ZU1ldGFkYXRhO1xyXG59KShtZXRhZGF0YV8xLkluamVjdGFibGVNZXRhZGF0YSk7XHJcbmV4cG9ydHMuRGlyZWN0aXZlTWV0YWRhdGEgPSBEaXJlY3RpdmVNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmUgcmV1c2FibGUgVUkgYnVpbGRpbmcgYmxvY2tzIGZvciBhbiBhcHBsaWNhdGlvbi5cclxuICpcclxuICogRWFjaCBBbmd1bGFyIGNvbXBvbmVudCByZXF1aXJlcyBhIHNpbmdsZSBgQENvbXBvbmVudGAgYW5kIGF0IGxlYXN0IG9uZSBgQFZpZXdgIGFubm90YXRpb24uIFRoZVxyXG4gKiBgQENvbXBvbmVudGBcclxuICogYW5ub3RhdGlvbiBzcGVjaWZpZXMgd2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIGFuZCB3aGljaCBwcm9wZXJ0aWVzIGFuZCBob3N0TGlzdGVuZXJzIGl0XHJcbiAqIGJpbmRzIHRvLlxyXG4gKlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgQW5ndWxhclxyXG4gKiAtIGNyZWF0ZXMgYSBzaGFkb3cgRE9NIGZvciB0aGUgY29tcG9uZW50LlxyXG4gKiAtIGxvYWRzIHRoZSBzZWxlY3RlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBzaGFkb3cgRE9NLlxyXG4gKiAtIGNyZWF0ZXMgYWxsIHRoZSBpbmplY3RhYmxlIG9iamVjdHMgY29uZmlndXJlZCB3aXRoIGBwcm92aWRlcnNgIGFuZCBgdmlld1Byb3ZpZGVyc2AuXHJcbiAqXHJcbiAqIEFsbCB0ZW1wbGF0ZSBleHByZXNzaW9ucyBhbmQgc3RhdGVtZW50cyBhcmUgdGhlbiBldmFsdWF0ZWQgYWdhaW5zdCB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBWaWV3YCBhbm5vdGF0aW9uLCBzZWUge0BsaW5rIFZpZXdNZXRhZGF0YX0uXHJcbiAqXHJcbiAqICMjIExpZmVjeWNsZSBob29rc1xyXG4gKlxyXG4gKiBXaGVuIHRoZSBjb21wb25lbnQgY2xhc3MgaW1wbGVtZW50cyBzb21lIHtAbGluayBhbmd1bGFyMi9saWZlY3ljbGVfaG9va3N9IHRoZSBjYWxsYmFja3MgYXJlXHJcbiAqIGNhbGxlZCBieSB0aGUgY2hhbmdlIGRldGVjdGlvbiBhdCBkZWZpbmVkIHBvaW50cyBpbiB0aW1lIGR1cmluZyB0aGUgbGlmZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19ISdcclxuICogfSlcclxuICogY2xhc3MgR3JlZXQge1xyXG4gKiAgIG5hbWU6IHN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxudmFyIENvbXBvbmVudE1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRNZXRhZGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudE1ldGFkYXRhKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIHByb3BlcnRpZXMgPSBfYi5wcm9wZXJ0aWVzLCBldmVudHMgPSBfYi5ldmVudHMsIGhvc3QgPSBfYi5ob3N0LCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBtb2R1bGVJZCA9IF9iLm1vZHVsZUlkLCBiaW5kaW5ncyA9IF9iLmJpbmRpbmdzLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIHZpZXdCaW5kaW5ncyA9IF9iLnZpZXdCaW5kaW5ncywgdmlld1Byb3ZpZGVycyA9IF9iLnZpZXdQcm92aWRlcnMsIF9jID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYyA9PT0gdm9pZCAwID8gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQgOiBfYywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgc3R5bGVzID0gX2Iuc3R5bGVzLCBkaXJlY3RpdmVzID0gX2IuZGlyZWN0aXZlcywgcGlwZXMgPSBfYi5waXBlcywgZW5jYXBzdWxhdGlvbiA9IF9iLmVuY2Fwc3VsYXRpb247XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywge1xyXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcclxuICAgICAgICAgICAgaG9zdDogaG9zdCxcclxuICAgICAgICAgICAgZXhwb3J0QXM6IGV4cG9ydEFzLFxyXG4gICAgICAgICAgICBtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBiaW5kaW5ncyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXHJcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbiA9IGNoYW5nZURldGVjdGlvbjtcclxuICAgICAgICB0aGlzLl92aWV3UHJvdmlkZXJzID0gdmlld1Byb3ZpZGVycztcclxuICAgICAgICB0aGlzLl92aWV3QmluZGluZ3MgPSB2aWV3QmluZGluZ3M7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcclxuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudE1ldGFkYXRhLnByb3RvdHlwZSwgXCJ2aWV3UHJvdmlkZXJzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBzZXQgb2YgaW5qZWN0YWJsZSBvYmplY3RzIHRoYXQgYXJlIHZpc2libGUgdG8gaXRzIHZpZXcgRE9NIGNoaWxkcmVuLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIyMgU2ltcGxlIEV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiBhIGNsYXNzIHRoYXQgY2FuIGJlIGluamVjdGVkOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICogY2xhc3MgR3JlZXRlciB7XHJcbiAgICAgICAgICogICAgZ3JlZXQobmFtZTpzdHJpbmcpIHtcclxuICAgICAgICAgKiAgICAgIHJldHVybiAnSGVsbG8gJyArIG5hbWUgKyAnISc7XHJcbiAgICAgICAgICogICAgfVxyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAqICAgc2VsZWN0b3I6ICduZWVkcy1ncmVldGVyJ1xyXG4gICAgICAgICAqIH0pXHJcbiAgICAgICAgICogY2xhc3MgTmVlZHNHcmVldGVyIHtcclxuICAgICAgICAgKiAgIGdyZWV0ZXI6R3JlZXRlcjtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgY29uc3RydWN0b3IoZ3JlZXRlcjpHcmVldGVyKSB7XHJcbiAgICAgICAgICogICAgIHRoaXMuZ3JlZXRlciA9IGdyZWV0ZXI7XHJcbiAgICAgICAgICogICB9XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQENvbXBvbmVudCh7XHJcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcclxuICAgICAgICAgKiAgICAgR3JlZXRlclxyXG4gICAgICAgICAqICAgXSxcclxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgPG5lZWRzLWdyZWV0ZXI+PC9uZWVkcy1ncmVldGVyPmAsXHJcbiAgICAgICAgICogICBkaXJlY3RpdmVzOiBbTmVlZHNHcmVldGVyXVxyXG4gICAgICAgICAqIH0pXHJcbiAgICAgICAgICogY2xhc3MgSGVsbG9Xb3JsZCB7XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3ZpZXdCaW5kaW5ncykgJiYgdGhpcy5fdmlld0JpbmRpbmdzLmxlbmd0aCA+IDAgPyB0aGlzLl92aWV3QmluZGluZ3MgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld1Byb3ZpZGVycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRNZXRhZGF0YS5wcm90b3R5cGUsIFwidmlld0JpbmRpbmdzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlld1Byb3ZpZGVyczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb21wb25lbnRNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgQ29tcG9uZW50TWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIENvbXBvbmVudE1ldGFkYXRhO1xyXG59KShEaXJlY3RpdmVNZXRhZGF0YSk7XHJcbmV4cG9ydHMuQ29tcG9uZW50TWV0YWRhdGEgPSBDb21wb25lbnRNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmUgcmV1c2FibGUgcGlwZSBmdW5jdGlvbi5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQFBpcGUoe1xyXG4gKiAgIG5hbWU6ICdsb3dlcmNhc2UnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIExvd2VyY2FzZSB7XHJcbiAqICAgdHJhbnNmb3JtKHYsIGFyZ3MpIHsgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTsgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFBpcGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGlwZU1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGlwZU1ldGFkYXRhKF9hKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBwdXJlID0gX2EucHVyZTtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX3B1cmUgPSBwdXJlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpcGVNZXRhZGF0YS5wcm90b3R5cGUsIFwicHVyZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3B1cmUpID8gdGhpcy5fcHVyZSA6IHRydWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUGlwZU1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBQaXBlTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIFBpcGVNZXRhZGF0YTtcclxufSkobWV0YWRhdGFfMS5JbmplY3RhYmxlTWV0YWRhdGEpO1xyXG5leHBvcnRzLlBpcGVNZXRhZGF0YSA9IFBpcGVNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgZGF0YS1ib3VuZCBpbnB1dCBwcm9wZXJ0eS5cclxuICpcclxuICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLlxyXG4gKlxyXG4gKiBgSW5wdXRNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lXHJcbiAqIHVzZWQgd2hlbiBpbnN0YW50aWF0aW5nIGEgY29tcG9uZW50IGluIHRoZSB0ZW1wbGF0ZS4gV2hlbiBub3QgcHJvdmlkZWQsXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBkZWNvcmF0ZWQgcHJvcGVydHkgaXMgdXNlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgd2l0aCB0d28gaW5wdXQgcHJvcGVydGllcy5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2JhbmstYWNjb3VudCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIEJhbmsgTmFtZToge3tiYW5rTmFtZX19XHJcbiAqICAgICBBY2NvdW50IElkOiB7e2lkfX1cclxuICogICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEJhbmtBY2NvdW50IHtcclxuICogICBASW5wdXQoKSBiYW5rTmFtZTogc3RyaW5nO1xyXG4gKiAgIEBJbnB1dCgnYWNjb3VudC1pZCcpIGlkOiBzdHJpbmc7XHJcbiAqXHJcbiAqICAgLy8gdGhpcyBwcm9wZXJ0eSBpcyBub3QgYm91bmQsIGFuZCB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYnkgQW5ndWxhclxyXG4gKiAgIG5vcm1hbGl6ZWRCYW5rTmFtZTogc3RyaW5nO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGJhbmstYWNjb3VudCBiYW5rLW5hbWU9XCJSQkNcIiBhY2NvdW50LWlkPVwiNDc0N1wiPjwvYmFuay1hY2NvdW50PlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW0JhbmtBY2NvdW50XVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge31cclxuICpcclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIElucHV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5wdXRNZXRhZGF0YShcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOYW1lIHVzZWQgd2hlbiBpbnN0YW50aWF0aW5nIGEgY29tcG9uZW50IGluIHRoZSB0ZW1sYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdQcm9wZXJ0eU5hbWUgPSBiaW5kaW5nUHJvcGVydHlOYW1lO1xyXG4gICAgfVxyXG4gICAgSW5wdXRNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgSW5wdXRNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gSW5wdXRNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5JbnB1dE1ldGFkYXRhID0gSW5wdXRNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmVzIGFuIGV2ZW50LWJvdW5kIG91dHB1dCBwcm9wZXJ0eS5cclxuICpcclxuICogV2hlbiBhbiBvdXRwdXQgcHJvcGVydHkgZW1pdHMgYW4gZXZlbnQsIGFuIGV2ZW50IGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudFxyXG4gKiB0aGUgdGVtcGxhdGUgaXMgaW52b2tlZC5cclxuICpcclxuICogYE91dHB1dE1ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWVcclxuICogdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnaW50ZXJ2YWwtZGlyJyxcclxuICogfSlcclxuICogY2xhc3MgSW50ZXJ2YWxEaXIge1xyXG4gKiAgIEBPdXRwdXQoKSBldmVyeVNlY29uZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICogICBAT3V0cHV0KCdldmVyeUZpdmVTZWNvbmRzJykgZml2ZTVTZWNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ldmVyeVNlY29uZC5uZXh0KFwiZXZlbnRcIiksIDEwMDApO1xyXG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5maXZlNVNlY3MubmV4dChcImV2ZW50XCIpLCA1MDAwKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8aW50ZXJ2YWwtZGlyIChldmVyeS1zZWNvbmQpPVwiZXZlcnlTZWNvbmQoKVwiIChldmVyeS1maXZlLXNlY29uZHMpPVwiZXZlcnlGaXZlU2Vjb25kcygpXCI+XHJcbiAqICAgICA8L2ludGVydmFsLWRpcj5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtJbnRlcnZhbERpcl1cclxuICogfSlcclxuICogY2xhc3MgQXBwIHtcclxuICogICBldmVyeVNlY29uZCgpIHsgY29uc29sZS5sb2coJ3NlY29uZCcpOyB9XHJcbiAqICAgZXZlcnlGaXZlU2Vjb25kcygpIHsgY29uc29sZS5sb2coJ2ZpdmUgc2Vjb25kcycpOyB9XHJcbiAqIH1cclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE91dHB1dE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE91dHB1dE1ldGFkYXRhKGJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdQcm9wZXJ0eU5hbWUgPSBiaW5kaW5nUHJvcGVydHlOYW1lO1xyXG4gICAgfVxyXG4gICAgT3V0cHV0TWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIE91dHB1dE1ldGFkYXRhKTtcclxuICAgIHJldHVybiBPdXRwdXRNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5PdXRwdXRNZXRhZGF0YSA9IE91dHB1dE1ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZXMgYSBob3N0IHByb3BlcnR5IGJpbmRpbmcuXHJcbiAqXHJcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSBjaGVja3MgaG9zdCBwcm9wZXJ0eSBiaW5kaW5ncyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cclxuICogSWYgYSBiaW5kaW5nIGNoYW5nZXMsIGl0IHdpbGwgdXBkYXRlIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIGRpcmVjdGl2ZS5cclxuICpcclxuICogYEhvc3RCaW5kaW5nTWV0YWRhdGFgIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgcHJvcGVydHlcclxuICogbmFtZSBvZiB0aGUgaG9zdCBlbGVtZW50IHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIGNsYXNzIHByb3BlcnR5IG5hbWUgaXMgdXNlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBkaXJlY3RpdmUgdGhhdCBzZXRzIHRoZSBgdmFsaWRgIGFuZCBgaW52YWxpZGAgY2xhc3Nlc1xyXG4gKiBvbiB0aGUgRE9NIGVsZW1lbnQgdGhhdCBoYXMgbmctbW9kZWwgZGlyZWN0aXZlIG9uIGl0LlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW25nLW1vZGVsXSd9KVxyXG4gKiBjbGFzcyBOZ01vZGVsU3RhdHVzIHtcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgY29udHJvbDpOZ01vZGVsKSB7fVxyXG4gKiAgIEBIb3N0QmluZGluZygnW2NsYXNzLnZhbGlkXScpIGdldCB2YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wudmFsaWQ7IH1cclxuICogICBASG9zdEJpbmRpbmcoJ1tjbGFzcy5pbnZhbGlkXScpIGdldCBpbnZhbGlkIHsgcmV0dXJuIHRoaXMuY29udHJvbC5pbnZhbGlkOyB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgPGlucHV0IFsobmctbW9kZWwpXT1cInByb3BcIj5gLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVMsIE5nTW9kZWxTdGF0dXNdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7XHJcbiAqICAgcHJvcDtcclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSG9zdEJpbmRpbmdNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIb3N0QmluZGluZ01ldGFkYXRhKGhvc3RQcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0eU5hbWUgPSBob3N0UHJvcGVydHlOYW1lO1xyXG4gICAgfVxyXG4gICAgSG9zdEJpbmRpbmdNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgSG9zdEJpbmRpbmdNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gSG9zdEJpbmRpbmdNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5Ib3N0QmluZGluZ01ldGFkYXRhID0gSG9zdEJpbmRpbmdNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgaG9zdCBsaXN0ZW5lci5cclxuICpcclxuICogQW5ndWxhciB3aWxsIGludm9rZSB0aGUgZGVjb3JhdGVkIG1ldGhvZCB3aGVuIHRoZSBob3N0IGVsZW1lbnQgZW1pdHMgdGhlIHNwZWNpZmllZCBldmVudC5cclxuICpcclxuICogSWYgdGhlIGRlY29yYXRlZCBtZXRob2QgcmV0dXJucyBgZmFsc2VgLCB0aGVuIGBwcmV2ZW50RGVmYXVsdGAgaXMgYXBwbGllZCBvbiB0aGUgRE9NXHJcbiAqIGV2ZW50LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVjbGFyZXMgYSBkaXJlY3RpdmUgdGhhdCBhdHRhY2hlcyBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBidXR0b24gYW5kXHJcbiAqIGNvdW50cyBjbGlja3MuXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdidXR0b25bY291bnRpbmddJ30pXHJcbiAqIGNsYXNzIENvdW50Q2xpY2tzIHtcclxuICogICBudW1iZXJPZkNsaWNrcyA9IDA7XHJcbiAqXHJcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcclxuICogICBvbkNsaWNrKGJ0bikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJidXR0b25cIiwgYnRuLCBcIm51bWJlciBvZiBjbGlja3M6XCIsIHRoaXMubnVtYmVyT2ZDbGlja3MrKyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYDxidXR0b24gY291bnRpbmc+SW5jcmVtZW50PC9idXR0b24+YCxcclxuICogICBkaXJlY3RpdmVzOiBbQ291bnRDbGlja3NdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7fVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSG9zdExpc3RlbmVyTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSG9zdExpc3RlbmVyTWV0YWRhdGEoZXZlbnROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIEhvc3RMaXN0ZW5lck1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZywgQXJyYXldKVxyXG4gICAgXSwgSG9zdExpc3RlbmVyTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIEhvc3RMaXN0ZW5lck1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkhvc3RMaXN0ZW5lck1ldGFkYXRhID0gSG9zdExpc3RlbmVyTWV0YWRhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogRGVmaW5lcyB0ZW1wbGF0ZSBhbmQgc3R5bGUgZW5jYXBzdWxhdGlvbiBvcHRpb25zIGF2YWlsYWJsZSBmb3IgQ29tcG9uZW50J3Mge0BsaW5rIFZpZXd9LlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIFZpZXdNZXRhZGF0YSNlbmNhcHN1bGF0aW9ufS5cclxuICovXHJcbihmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogRW11bGF0ZSBgTmF0aXZlYCBzY29waW5nIG9mIHN0eWxlcyBieSBhZGRpbmcgYW4gYXR0cmlidXRlIGNvbnRhaW5pbmcgc3Vycm9nYXRlIGlkIHRvIHRoZSBIb3N0XHJcbiAgICAgKiBFbGVtZW50IGFuZCBwcmUtcHJvY2Vzc2luZyB0aGUgc3R5bGUgcnVsZXMgcHJvdmlkZWQgdmlhXHJcbiAgICAgKiB7QGxpbmsgVmlld01ldGFkYXRhI3N0eWxlc30gb3Ige0BsaW5rIFZpZXdNZXRhZGF0YSNzdHlsZXNVcmxzfSwgYW5kIGFkZGluZyB0aGUgbmV3IEhvc3QgRWxlbWVudFxyXG4gICAgICogYXR0cmlidXRlIHRvIGFsbCBzZWxlY3RvcnMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiRW11bGF0ZWRcIl0gPSAwXSA9IFwiRW11bGF0ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoZSBuYXRpdmUgZW5jYXBzdWxhdGlvbiBtZWNoYW5pc20gb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEZvciB0aGUgRE9NIHRoaXMgbWVhbnMgdXNpbmcgW1NoYWRvdyBET01dKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvc2hhZG93LykgYW5kXHJcbiAgICAgKiBjcmVhdGluZyBhIFNoYWRvd1Jvb3QgZm9yIENvbXBvbmVudCdzIEhvc3QgRWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOYXRpdmVcIl0gPSAxXSA9IFwiTmF0aXZlXCI7XHJcbiAgICAvKipcclxuICAgICAqIERvbid0IHByb3ZpZGUgYW55IHRlbXBsYXRlIG9yIHN0eWxlIGVuY2Fwc3VsYXRpb24uXHJcbiAgICAgKi9cclxuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XHJcbn0pKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gfHwgKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xyXG52YXIgVmlld0VuY2Fwc3VsYXRpb24gPSBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uO1xyXG5leHBvcnRzLlZJRVdfRU5DQVBTVUxBVElPTl9WQUxVRVMgPSBbVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsIFZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSwgVmlld0VuY2Fwc3VsYXRpb24uTm9uZV07XHJcbi8qKlxyXG4gKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXHJcbiAqXHJcbiAqIEVhY2ggQW5ndWxhciBjb21wb25lbnQgcmVxdWlyZXMgYSBzaW5nbGUgYEBDb21wb25lbnRgIGFuZCBhdCBsZWFzdCBvbmUgYEBWaWV3YCBhbm5vdGF0aW9uLiBUaGVcclxuICogYEBWaWV3YCBhbm5vdGF0aW9uIHNwZWNpZmllcyB0aGUgSFRNTCB0ZW1wbGF0ZSB0byB1c2UsIGFuZCBsaXN0cyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBhY3RpdmVcclxuICogd2l0aGluIHRoZSB0ZW1wbGF0ZS5cclxuICpcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgaW50byB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QsIGFuZFxyXG4gKiB0aGUgZXhwcmVzc2lvbnMgYW5kIHN0YXRlbWVudHMgaW4gdGhlIHRlbXBsYXRlIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBDb21wb25lbnRgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXHJcbiAqICAgZGlyZWN0aXZlczogW0dyZWV0VXNlciwgQm9sZF1cclxuICogfSlcclxuICogY2xhc3MgR3JlZXQge1xyXG4gKiAgIG5hbWU6IHN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFZpZXdNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3TWV0YWRhdGEoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgZGlyZWN0aXZlcyA9IF9iLmRpcmVjdGl2ZXMsIHBpcGVzID0gX2IucGlwZXMsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xyXG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XHJcbiAgICB9XHJcbiAgICBWaWV3TWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIFZpZXdNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gVmlld01ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLlZpZXdNZXRhZGF0YSA9IFZpZXdNZXRhZGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgc2V0IG9mIGNvbW1vbiBQaXBlcy5cclxuICovXHJcbnZhciBhc3luY19waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2FzeW5jX3BpcGUnKTtcclxuZXhwb3J0cy5Bc3luY1BpcGUgPSBhc3luY19waXBlXzEuQXN5bmNQaXBlO1xyXG52YXIgZGF0ZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2RhdGVfcGlwZScpO1xyXG5leHBvcnRzLkRhdGVQaXBlID0gZGF0ZV9waXBlXzEuRGF0ZVBpcGU7XHJcbnZhciBkZWZhdWx0X3BpcGVzXzEgPSByZXF1aXJlKCcuL3BpcGVzL2RlZmF1bHRfcGlwZXMnKTtcclxuZXhwb3J0cy5ERUZBVUxUX1BJUEVTID0gZGVmYXVsdF9waXBlc18xLkRFRkFVTFRfUElQRVM7XHJcbmV4cG9ydHMuREVGQVVMVF9QSVBFU19UT0tFTiA9IGRlZmF1bHRfcGlwZXNfMS5ERUZBVUxUX1BJUEVTX1RPS0VOO1xyXG52YXIganNvbl9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2pzb25fcGlwZScpO1xyXG5leHBvcnRzLkpzb25QaXBlID0ganNvbl9waXBlXzEuSnNvblBpcGU7XHJcbnZhciBzbGljZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL3NsaWNlX3BpcGUnKTtcclxuZXhwb3J0cy5TbGljZVBpcGUgPSBzbGljZV9waXBlXzEuU2xpY2VQaXBlO1xyXG52YXIgbG93ZXJjYXNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvbG93ZXJjYXNlX3BpcGUnKTtcclxuZXhwb3J0cy5Mb3dlckNhc2VQaXBlID0gbG93ZXJjYXNlX3BpcGVfMS5Mb3dlckNhc2VQaXBlO1xyXG52YXIgbnVtYmVyX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvbnVtYmVyX3BpcGUnKTtcclxuZXhwb3J0cy5OdW1iZXJQaXBlID0gbnVtYmVyX3BpcGVfMS5OdW1iZXJQaXBlO1xyXG5leHBvcnRzLkRlY2ltYWxQaXBlID0gbnVtYmVyX3BpcGVfMS5EZWNpbWFsUGlwZTtcclxuZXhwb3J0cy5QZXJjZW50UGlwZSA9IG51bWJlcl9waXBlXzEuUGVyY2VudFBpcGU7XHJcbmV4cG9ydHMuQ3VycmVuY3lQaXBlID0gbnVtYmVyX3BpcGVfMS5DdXJyZW5jeVBpcGU7XHJcbnZhciB1cHBlcmNhc2VfcGlwZV8xID0gcmVxdWlyZSgnLi9waXBlcy91cHBlcmNhc2VfcGlwZScpO1xyXG5leHBvcnRzLlVwcGVyQ2FzZVBpcGUgPSB1cHBlcmNhc2VfcGlwZV8xLlVwcGVyQ2FzZVBpcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcclxudmFyIE9ic2VydmFibGVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RyYXRlZ3koKSB7XHJcbiAgICB9XHJcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KTtcclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuZGlzcG9zZShzdWJzY3JpcHRpb24pOyB9O1xyXG4gICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuZGlzcG9zZShzdWJzY3JpcHRpb24pOyB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGVTdHJhdGVneTtcclxufSkoKTtcclxudmFyIFByb21pc2VTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9taXNlU3RyYXRlZ3koKSB7XHJcbiAgICB9XHJcbiAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYXN5bmMudGhlbih1cGRhdGVMYXRlc3RWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyB9O1xyXG4gICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XHJcbiAgICByZXR1cm4gUHJvbWlzZVN0cmF0ZWd5O1xyXG59KSgpO1xyXG52YXIgX3Byb21pc2VTdHJhdGVneSA9IG5ldyBQcm9taXNlU3RyYXRlZ3koKTtcclxudmFyIF9vYnNlcnZhYmxlU3RyYXRlZ3kgPSBuZXcgT2JzZXJ2YWJsZVN0cmF0ZWd5KCk7XHJcbi8qKlxyXG4gKiBUaGUgYGFzeW5jYCBwaXBlIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSBvciBQcm9taXNlIGFuZCByZXR1cm5zIHRoZSBsYXRlc3QgdmFsdWUgaXQgaGFzXHJcbiAqIGVtaXR0ZWQuXHJcbiAqIFdoZW4gYSBuZXcgdmFsdWUgaXMgZW1pdHRlZCwgdGhlIGBhc3luY2AgcGlwZSBtYXJrcyB0aGUgY29tcG9uZW50IHRvIGJlIGNoZWNrZWQgZm9yIGNoYW5nZXMuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBiaW5kcyB0aGUgYHRpbWVgIE9ic2VydmFibGUgdG8gdGhlIHZpZXcuIEV2ZXJ5IDUwMG1zLCB0aGUgYHRpbWVgIE9ic2VydmFibGVcclxuICogdXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBjdXJyZW50IHRpbWUuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge09ic2VydmFibGV9IGZyb20gJ2FuZ3VsYXIyL2NvcmUnO1xyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogXCJ0YXNrLWNtcFwiLFxyXG4gKiAgIHRlbXBsYXRlOiBcIlRpbWU6IHt7IHRpbWUgfCBhc3luYyB9fVwiXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFRhc2sge1xyXG4gKiAgIHRpbWUgPSBuZXcgT2JzZXJ2YWJsZTxudW1iZXI+KG9ic2VydmVyID0+IHtcclxuICogICAgIHNldEludGVydmFsKF8gPT5cclxuICogICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgRGF0ZSgpLmdldFRpbWUoKSksIDUwMCk7XHJcbiAqICAgfSk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgQXN5bmNQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFzeW5jUGlwZShfcmVmKSB7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX29iaiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3JlZiA9IF9yZWY7XHJcbiAgICB9XHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9zdWJzY3JpcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX29iaikpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmogIT09IHRoaXMuX29iaikge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uXzEuV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9vYmogPSBvYmo7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSB0aGlzLl9zZWxlY3RTdHJhdGVneShvYmopO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5LmNyZWF0ZVN1YnNjcmlwdGlvbihvYmosIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZUxhdGVzdFZhbHVlKG9iaiwgdmFsdWUpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zZWxlY3RTdHJhdGVneSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJvbWlzZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVN0cmF0ZWd5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmlzT2JzZXJ2YWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVN0cmF0ZWd5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKEFzeW5jUGlwZSwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5kaXNwb3NlKHRoaXMuX3N1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl91cGRhdGVMYXRlc3RWYWx1ZSA9IGZ1bmN0aW9uIChhc3luYywgdmFsdWUpIHtcclxuICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFzeW5jUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdhc3luYycsIHB1cmU6IGZhbHNlIH0pLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxyXG4gICAgXSwgQXN5bmNQaXBlKTtcclxuICAgIHJldHVybiBBc3luY1BpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXN5bmNQaXBlID0gQXN5bmNQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luY19waXBlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGludGxfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9pbnRsJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbicpO1xyXG4vLyBUT0RPOiBtb3ZlIHRvIGEgZ2xvYmFsIGNvbmZpZ3VyYWJsZSBsb2NhdGlvbiBhbG9uZyB3aXRoIG90aGVyIGkxOG4gY29tcG9uZW50cy5cclxudmFyIGRlZmF1bHRMb2NhbGUgPSAnZW4tVVMnO1xyXG4vKipcclxuICogV0FSTklORzogdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS5cclxuICogVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYSBicm93c2Vycy5cclxuICpcclxuICogRm9ybWF0cyBhIGRhdGUgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXHJcbiAqXHJcbiAqICMgVXNhZ2VcclxuICpcclxuICogICAgIGV4cHJlc3Npb24gfCBkYXRlWzpmb3JtYXRdXHJcbiAqXHJcbiAqIHdoZXJlIGBleHByZXNzaW9uYCBpcyBhIGRhdGUgb2JqZWN0IG9yIGEgbnVtYmVyIChtaWxsaXNlY29uZHMgc2luY2UgVVRDIGVwb2NoKSBhbmRcclxuICogYGZvcm1hdGAgaW5kaWNhdGVzIHdoaWNoIGRhdGUvdGltZSBjb21wb25lbnRzIHRvIGluY2x1ZGU6XHJcbiAqXHJcbiAqICB8IENvbXBvbmVudCB8IFN5bWJvbCB8IFNob3J0IEZvcm0gICB8IExvbmcgRm9ybSAgICAgICAgIHwgTnVtZXJpYyAgIHwgMi1kaWdpdCAgIHxcclxuICogIHwtLS0tLS0tLS0tLXw6LS0tLS0tOnwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxyXG4gKiAgfCBlcmEgICAgICAgfCAgIEcgICAgfCBHIChBRCkgICAgICAgfCBHR0dHIChBbm5vIERvbWluaSl8IC0gICAgICAgICB8IC0gICAgICAgICB8XHJcbiAqICB8IHllYXIgICAgICB8ICAgeSAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgeSAoMjAxNSkgIHwgeXkgKDE1KSAgIHxcclxuICogIHwgbW9udGggICAgIHwgICBNICAgIHwgTU1NIChTZXApICAgIHwgTU1NTSAoU2VwdGVtYmVyKSAgfCBNICg5KSAgICAgfCBNTSAoMDkpICAgfFxyXG4gKiAgfCBkYXkgICAgICAgfCAgIGQgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGQgKDMpICAgICB8IGRkICgwMykgICB8XHJcbiAqICB8IHdlZWtkYXkgICB8ICAgRSAgICB8IEVFRSAoU3VuKSAgICB8IEVFRUUgKFN1bmRheSkgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcclxuICogIHwgaG91ciAgICAgIHwgICBqICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBqICgxMykgICAgfCBqaiAoMTMpICAgfFxyXG4gKiAgfCBob3VyMTIgICAgfCAgIGggICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGggKDEgUE0pICB8IGhoICgwMSBQTSl8XHJcbiAqICB8IGhvdXIyNCAgICB8ICAgSCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgSCAoMTMpICAgIHwgSEggKDEzKSAgIHxcclxuICogIHwgbWludXRlICAgIHwgICBtICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBtICg1KSAgICAgfCBtbSAoMDUpICAgfFxyXG4gKiAgfCBzZWNvbmQgICAgfCAgIHMgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IHMgKDkpICAgICB8IHNzICgwOSkgICB8XHJcbiAqICB8IHRpbWV6b25lICB8ICAgeiAgICB8IC0gICAgICAgICAgICB8IHogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSl8IC0gIHwgLSAgICAgICAgIHxcclxuICogIHwgdGltZXpvbmUgIHwgICBaICAgIHwgWiAoR01ULTg6MDApIHwgLSAgICAgICAgICAgICAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxyXG4gKlxyXG4gKiBJbiBqYXZhc2NyaXB0LCBvbmx5IHRoZSBjb21wb25lbnRzIHNwZWNpZmllZCB3aWxsIGJlIHJlc3BlY3RlZCAobm90IHRoZSBvcmRlcmluZyxcclxuICogcHVuY3R1YXRpb25zLCAuLi4pIGFuZCBkZXRhaWxzIG9mIHRoZSBmb3JtYXR0aW5nIHdpbGwgYmUgZGVwZW5kZW50IG9uIHRoZSBsb2NhbGUuXHJcbiAqIE9uIHRoZSBvdGhlciBoYW5kIGluIERhcnQgdmVyc2lvbiwgeW91IGNhbiBhbHNvIGluY2x1ZGUgcXVvdGVkIHRleHQgYXMgd2VsbCBhcyBzb21lIGV4dHJhXHJcbiAqIGRhdGUvdGltZSBjb21wb25lbnRzIHN1Y2ggYXMgcXVhcnRlci4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlOlxyXG4gKiBodHRwczovL2FwaS5kYXJ0bGFuZy5vcmcvYXBpZG9jcy9jaGFubmVscy9zdGFibGUvZGFydGRvYy12aWV3ZXIvaW50bC9pbnRsLkRhdGVGb3JtYXQuXHJcbiAqXHJcbiAqIGBmb3JtYXRgIGNhbiBhbHNvIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHByZWRlZmluZWQgZm9ybWF0czpcclxuICpcclxuICogIC0gYCdtZWRpdW0nYDogZXF1aXZhbGVudCB0byBgJ3lNTU1kam1zJ2AgKGUuZy4gU2VwIDMsIDIwMTAsIDEyOjA1OjA4IFBNIGZvciBlbi1VUylcclxuICogIC0gYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAneU1kam0nYCAoZS5nLiA5LzMvMjAxMCwgMTI6MDUgUE0gZm9yIGVuLVVTKVxyXG4gKiAgLSBgJ2Z1bGxEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NTUVFRUVkJ2AgKGUuZy4gRnJpZGF5LCBTZXB0ZW1iZXIgMywgMjAxMCBmb3IgZW4tVVMpXHJcbiAqICAtIGAnbG9uZ0RhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1NZCdgIChlLmcuIFNlcHRlbWJlciAzLCAyMDEwKVxyXG4gKiAgLSBgJ21lZGl1bURhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1kJ2AgKGUuZy4gU2VwIDMsIDIwMTAgZm9yIGVuLVVTKVxyXG4gKiAgLSBgJ3Nob3J0RGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1kJ2AgKGUuZy4gOS8zLzIwMTAgZm9yIGVuLVVTKVxyXG4gKiAgLSBgJ21lZGl1bVRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2ptcydgIChlLmcuIDEyOjA1OjA4IFBNIGZvciBlbi1VUylcclxuICogIC0gYCdzaG9ydFRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2ptJ2AgKGUuZy4gMTI6MDUgUE0gZm9yIGVuLVVTKVxyXG4gKlxyXG4gKiBUaW1lem9uZSBvZiB0aGUgZm9ybWF0dGVkIHRleHQgd2lsbCBiZSB0aGUgbG9jYWwgc3lzdGVtIHRpbWV6b25lIG9mIHRoZSBlbmQtdXNlcnMgbWFjaGluZS5cclxuICpcclxuICogIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBBc3N1bWluZyBgZGF0ZU9iamAgaXMgKHllYXI6IDIwMTUsIG1vbnRoOiA2LCBkYXk6IDE1LCBob3VyOiAyMSwgbWludXRlOiA0Mywgc2Vjb25kOiAxMSlcclxuICogaW4gdGhlIF9sb2NhbF8gdGltZSBhbmQgbG9jYWxlIGlzICdlbi1VUyc6XHJcbiAqXHJcbiAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZSB9fSAgICAgICAgICAgICAgIC8vIG91dHB1dCBpcyAnSnVuIDE1LCAyMDE1J1xyXG4gKiAgICAge3sgZGF0ZU9iaiB8IGRhdGU6J21lZGl1bScgfX0gICAgICAvLyBvdXRwdXQgaXMgJ0p1biAxNSwgMjAxNSwgOTo0MzoxMSBQTSdcclxuICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidzaG9ydFRpbWUnIH19ICAgLy8gb3V0cHV0IGlzICc5OjQzIFBNJ1xyXG4gKiAgICAge3sgZGF0ZU9iaiB8IGRhdGU6J21tc3MnIH19ICAgICAgICAvLyBvdXRwdXQgaXMgJzQzOjExJ1xyXG4gKi9cclxudmFyIERhdGVQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGVQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgRGF0ZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0cyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKERhdGVQaXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXR0ZXJuID0gbGFuZ18xLmlzUHJlc2VudChhcmdzKSAmJiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogJ21lZGl1bURhdGUnO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbGFuZ18xLkRhdGVXcmFwcGVyLmZyb21NaWxsaXModmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMoRGF0ZVBpcGUuX0FMSUFTRVMsIHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoRGF0ZVBpcGUuX0FMSUFTRVMsIHBhdHRlcm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW50bF8xLkRhdGVGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBkZWZhdWx0TG9jYWxlLCBwYXR0ZXJuKTtcclxuICAgIH07XHJcbiAgICBEYXRlUGlwZS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBsYW5nXzEuaXNEYXRlKG9iaikgfHwgbGFuZ18xLmlzTnVtYmVyKG9iaik7IH07XHJcbiAgICBEYXRlUGlwZS5fQUxJQVNFUyA9IHtcclxuICAgICAgICAnbWVkaXVtJzogJ3lNTU1kam1zJyxcclxuICAgICAgICAnc2hvcnQnOiAneU1kam0nLFxyXG4gICAgICAgICdmdWxsRGF0ZSc6ICd5TU1NTUVFRUVkJyxcclxuICAgICAgICAnbG9uZ0RhdGUnOiAneU1NTU1kJyxcclxuICAgICAgICAnbWVkaXVtRGF0ZSc6ICd5TU1NZCcsXHJcbiAgICAgICAgJ3Nob3J0RGF0ZSc6ICd5TWQnLFxyXG4gICAgICAgICdtZWRpdW1UaW1lJzogJ2ptcycsXHJcbiAgICAgICAgJ3Nob3J0VGltZSc6ICdqbSdcclxuICAgIH07XHJcbiAgICBEYXRlUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdkYXRlJyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIERhdGVQaXBlKTtcclxuICAgIHJldHVybiBEYXRlUGlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRlUGlwZSA9IERhdGVQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlX3BpcGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBhc3luY19waXBlXzEgPSByZXF1aXJlKCcuL2FzeW5jX3BpcGUnKTtcclxudmFyIHVwcGVyY2FzZV9waXBlXzEgPSByZXF1aXJlKCcuL3VwcGVyY2FzZV9waXBlJyk7XHJcbnZhciBsb3dlcmNhc2VfcGlwZV8xID0gcmVxdWlyZSgnLi9sb3dlcmNhc2VfcGlwZScpO1xyXG52YXIganNvbl9waXBlXzEgPSByZXF1aXJlKCcuL2pzb25fcGlwZScpO1xyXG52YXIgc2xpY2VfcGlwZV8xID0gcmVxdWlyZSgnLi9zbGljZV9waXBlJyk7XHJcbnZhciBkYXRlX3BpcGVfMSA9IHJlcXVpcmUoJy4vZGF0ZV9waXBlJyk7XHJcbnZhciBudW1iZXJfcGlwZV8xID0gcmVxdWlyZSgnLi9udW1iZXJfcGlwZScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgREVGQVVMVF9QSVBFU19MSVNUID0gbGFuZ18xLkNPTlNUX0VYUFIoW1xyXG4gICAgYXN5bmNfcGlwZV8xLkFzeW5jUGlwZSxcclxuICAgIHVwcGVyY2FzZV9waXBlXzEuVXBwZXJDYXNlUGlwZSxcclxuICAgIGxvd2VyY2FzZV9waXBlXzEuTG93ZXJDYXNlUGlwZSxcclxuICAgIGpzb25fcGlwZV8xLkpzb25QaXBlLFxyXG4gICAgc2xpY2VfcGlwZV8xLlNsaWNlUGlwZSxcclxuICAgIG51bWJlcl9waXBlXzEuRGVjaW1hbFBpcGUsXHJcbiAgICBudW1iZXJfcGlwZV8xLlBlcmNlbnRQaXBlLFxyXG4gICAgbnVtYmVyX3BpcGVfMS5DdXJyZW5jeVBpcGUsXHJcbiAgICBkYXRlX3BpcGVfMS5EYXRlUGlwZVxyXG5dKTtcclxuZXhwb3J0cy5ERUZBVUxUX1BJUEVTX1RPS0VOID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJEZWZhdWx0IFBpcGVzXCIpKTtcclxuZXhwb3J0cy5ERUZBVUxUX1BJUEVTID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIoZXhwb3J0cy5ERUZBVUxUX1BJUEVTX1RPS0VOLCB7IHVzZVZhbHVlOiBERUZBVUxUX1BJUEVTX0xJU1QgfSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X3BpcGVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIEludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIGFyZ3VtZW50ICdcIiArIHZhbHVlICsgXCInIGZvciBwaXBlICdcIiArIHR5cGUgKyBcIidcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbjtcclxufSkoZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pO1xyXG5leHBvcnRzLkludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24gPSBJbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGpzb24gdHJhbnNmb3JtcyB0byBhbnkgb2JqZWN0LlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogSW4gdGhpcyBleGFtcGxlIHdlIHRyYW5zZm9ybSB0aGUgdXNlciBvYmplY3QgdG8ganNvbi5cclxuICpcclxuICogIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogXCJ1c2VyLWNtcFwiLFxyXG4gKiAgIHRlbXBsYXRlOiBcIlVzZXI6IHt7IHVzZXIgfCBqc29uIH19XCJcclxuICogfSlcclxuICogY2xhc3MgVXNlcm5hbWUge1xyXG4gKiAgdXNlcjpPYmplY3RcclxuICogIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICB0aGlzLnVzZXIgPSB7IG5hbWU6IFwiUGF0cmlja0pTXCIgfTtcclxuICogIH1cclxuICogfVxyXG4gKlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBKc29uUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKc29uUGlwZSgpIHtcclxuICAgIH1cclxuICAgIEpzb25QaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5Kc29uLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgSnNvblBpcGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSxcclxuICAgICAgICBtZXRhZGF0YV8xLlBpcGUoeyBuYW1lOiAnanNvbicgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBKc29uUGlwZSk7XHJcbiAgICByZXR1cm4gSnNvblBpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSnNvblBpcGUgPSBKc29uUGlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbl9waXBlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudHMgbG93ZXJjYXNlIHRyYW5zZm9ybXMgdG8gdGV4dC5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSB3ZSB0cmFuc2Zvcm0gdGhlIHVzZXIgdGV4dCBsb3dlcmNhc2UuXHJcbiAqXHJcbiAqICBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6IFwidXNlcm5hbWUtY21wXCIsXHJcbiAqICAgdGVtcGxhdGU6IFwiVXNlcm5hbWU6IHt7IHVzZXIgfCBsb3dlcmNhc2UgfX1cIlxyXG4gKiB9KVxyXG4gKiBjbGFzcyBVc2VybmFtZSB7XHJcbiAqICAgdXNlcjpzdHJpbmc7XHJcbiAqIH1cclxuICpcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTG93ZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb3dlckNhc2VQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgTG93ZXJDYXNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKExvd2VyQ2FzZVBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnRvTG93ZXJDYXNlKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBMb3dlckNhc2VQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ2xvd2VyY2FzZScgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBMb3dlckNhc2VQaXBlKTtcclxuICAgIHJldHVybiBMb3dlckNhc2VQaXBlO1xyXG59KSgpO1xyXG5leHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBMb3dlckNhc2VQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3dlcmNhc2VfcGlwZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgaW50bF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2ludGwnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XHJcbnZhciBkZWZhdWx0TG9jYWxlID0gJ2VuLVVTJztcclxudmFyIF9yZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnXihcXFxcZCspP1xcXFwuKChcXFxcZCspKFxcXFwtKFxcXFxkKykpPyk/JCcpO1xyXG52YXIgTnVtYmVyUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOdW1iZXJQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgTnVtYmVyUGlwZS5fZm9ybWF0ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHlsZSwgZGlnaXRzLCBjdXJyZW5jeSwgY3VycmVuY3lBc1N5bWJvbCkge1xyXG4gICAgICAgIGlmIChjdXJyZW5jeSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChjdXJyZW5jeUFzU3ltYm9sID09PSB2b2lkIDApIHsgY3VycmVuY3lBc1N5bWJvbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihOdW1iZXJQaXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW5JbnQgPSAxLCBtaW5GcmFjdGlvbiA9IDAsIG1heEZyYWN0aW9uID0gMztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkaWdpdHMpKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX3JlLCBkaWdpdHMpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFydHMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oZGlnaXRzICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW5mbyBmb3IgbnVtYmVyIHBpcGVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcnRzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgbWluSW50ID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcnRzWzNdKSkge1xyXG4gICAgICAgICAgICAgICAgbWluRnJhY3Rpb24gPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1szXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFydHNbNV0pKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4KHBhcnRzWzVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW50bF8xLk51bWJlckZvcm1hdHRlci5mb3JtYXQodmFsdWUsIGRlZmF1bHRMb2NhbGUsIHN0eWxlLCB7XHJcbiAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiBtaW5JbnQsXHJcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbWluRnJhY3Rpb24sXHJcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4RnJhY3Rpb24sXHJcbiAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcclxuICAgICAgICAgICAgY3VycmVuY3lBc1N5bWJvbDogY3VycmVuY3lBc1N5bWJvbFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE51bWJlclBpcGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIE51bWJlclBpcGUpO1xyXG4gICAgcmV0dXJuIE51bWJlclBpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTnVtYmVyUGlwZSA9IE51bWJlclBpcGU7XHJcbi8qKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJLlxyXG4gKiBUaGVyZWZvcmUgaXQgaXMgb25seSByZWxpYWJsZSBpbiBDaHJvbWUgYW5kIE9wZXJhIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIGxvY2FsIHRleHQuIGkuZS4gZ3JvdXAgc2l6aW5nIGFuZCBzZXBhcmF0b3IgYW5kIG90aGVyIGxvY2FsZS1zcGVjaWZpY1xyXG4gKiBjb25maWd1cmF0aW9ucyBhcmUgYmFzZWQgb24gdGhlIGFjdGl2ZSBsb2NhbGUuXHJcbiAqXHJcbiAqICMgVXNhZ2VcclxuICpcclxuICogICAgIGV4cHJlc3Npb24gfCBudW1iZXJbOmRpZ2l0SW5mb11cclxuICpcclxuICogd2hlcmUgYGV4cHJlc3Npb25gIGlzIGEgbnVtYmVyIGFuZCBgZGlnaXRJbmZvYCBoYXMgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XHJcbiAqXHJcbiAqICAgICB7bWluSW50ZWdlckRpZ2l0c30ue21pbkZyYWN0aW9uRGlnaXRzfS17bWF4RnJhY3Rpb25EaWdpdHN9XHJcbiAqXHJcbiAqIC0gbWluSW50ZWdlckRpZ2l0cyBpcyB0aGUgbWluaW11bSBudW1iZXIgb2YgaW50ZWdlciBkaWdpdHMgdG8gdXNlLiBEZWZhdWx0cyB0byAxLlxyXG4gKiAtIG1pbkZyYWN0aW9uRGlnaXRzIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIDAuXHJcbiAqIC0gbWF4RnJhY3Rpb25EaWdpdHMgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmcmFjdGlvbi4gRGVmYXVsdHMgdG8gMy5cclxuICpcclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGFjY2VwdGFibGUgcmFuZ2UgZm9yIGVhY2ggb2YgdGhlc2UgbnVtYmVycyBhbmQgb3RoZXJcclxuICogZGV0YWlscyBzZWUgeW91ciBuYXRpdmUgaW50ZXJuYXRpb25hbGl6YXRpb24gbGlicmFyeS5cclxuICpcclxuICogIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiAgICAge3sgMTIzIHwgbnVtYmVyIH19ICAgICAgICAgICAgICAvLyBvdXRwdXQgaXMgMTIzXHJcbiAqICAgICB7eyAxMjMuMSB8IG51bWJlcjogJy4yLTMnIH19ICAgIC8vIG91dHB1dCBpcyAxMjMuMTBcclxuICogICAgIHt7IDEgfCBudW1iZXI6ICcyLjInIH19ICAgICAgICAgLy8gb3V0cHV0IGlzIDAxLjAwXHJcbiAqL1xyXG52YXIgRGVjaW1hbFBpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERlY2ltYWxQaXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVjaW1hbFBpcGUoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBEZWNpbWFsUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGRpZ2l0cyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdChhcmdzKTtcclxuICAgICAgICByZXR1cm4gTnVtYmVyUGlwZS5fZm9ybWF0KHZhbHVlLCBpbnRsXzEuTnVtYmVyRm9ybWF0U3R5bGUuRGVjaW1hbCwgZGlnaXRzKTtcclxuICAgIH07XHJcbiAgICBEZWNpbWFsUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdudW1iZXInIH0pLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRGVjaW1hbFBpcGUpO1xyXG4gICAgcmV0dXJuIERlY2ltYWxQaXBlO1xyXG59KShOdW1iZXJQaXBlKTtcclxuZXhwb3J0cy5EZWNpbWFsUGlwZSA9IERlY2ltYWxQaXBlO1xyXG4vKipcclxuICogV0FSTklORzogdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS5cclxuICogVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYSBicm93c2Vycy5cclxuICpcclxuICogRm9ybWF0cyBhIG51bWJlciBhcyBsb2NhbCBwZXJjZW50LlxyXG4gKlxyXG4gKiAjIFVzYWdlXHJcbiAqXHJcbiAqICAgICBleHByZXNzaW9uIHwgcGVyY2VudFs6ZGlnaXRJbmZvXVxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBgZGlnaXRJbmZvYCBzZWUge0BsaW5rIERlY2ltYWxQaXBlfVxyXG4gKi9cclxudmFyIFBlcmNlbnRQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQZXJjZW50UGlwZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBlcmNlbnRQaXBlKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgUGVyY2VudFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3QoYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlclBpcGUuX2Zvcm1hdCh2YWx1ZSwgaW50bF8xLk51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQsIGRpZ2l0cyk7XHJcbiAgICB9O1xyXG4gICAgUGVyY2VudFBpcGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSxcclxuICAgICAgICBtZXRhZGF0YV8xLlBpcGUoeyBuYW1lOiAncGVyY2VudCcgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBQZXJjZW50UGlwZSk7XHJcbiAgICByZXR1cm4gUGVyY2VudFBpcGU7XHJcbn0pKE51bWJlclBpcGUpO1xyXG5leHBvcnRzLlBlcmNlbnRQaXBlID0gUGVyY2VudFBpcGU7XHJcbi8qKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJLlxyXG4gKiBUaGVyZWZvcmUgaXQgaXMgb25seSByZWxpYWJsZSBpbiBDaHJvbWUgYW5kIE9wZXJhIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIGxvY2FsIGN1cnJlbmN5LlxyXG4gKlxyXG4gKiAjIFVzYWdlXHJcbiAqXHJcbiAqICAgICBleHByZXNzaW9uIHwgY3VycmVuY3lbOmN1cnJlbmN5Q29kZVs6c3ltYm9sRGlzcGxheVs6ZGlnaXRJbmZvXV1dXHJcbiAqXHJcbiAqIHdoZXJlIGBjdXJyZW5jeUNvZGVgIGlzIHRoZSBJU08gNDIxNyBjdXJyZW5jeSBjb2RlLCBzdWNoIGFzIFwiVVNEXCIgZm9yIHRoZSBVUyBkb2xsYXIgYW5kXHJcbiAqIFwiRVVSXCIgZm9yIHRoZSBldXJvLiBgc3ltYm9sRGlzcGxheWAgaXMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byB1c2UgdGhlIGN1cnJlbmN5XHJcbiAqIHN5bWJvbCAoZS5nLiAkKSBvciB0aGUgY3VycmVuY3kgY29kZSAoZS5nLiBVU0QpIGluIHRoZSBvdXRwdXQuIFRoZSBkZWZhdWx0IGZvciB0aGlzIHZhbHVlXHJcbiAqIGlzIGBmYWxzZWAuXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGBkaWdpdEluZm9gIHNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9XHJcbiAqL1xyXG52YXIgQ3VycmVuY3lQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDdXJyZW5jeVBpcGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDdXJyZW5jeVBpcGUoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBDdXJyZW5jeVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIHZhciBjdXJyZW5jeUNvZGUgPSBsYW5nXzEuaXNQcmVzZW50KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiAnVVNEJztcclxuICAgICAgICB2YXIgc3ltYm9sRGlzcGxheSA9IGxhbmdfMS5pc1ByZXNlbnQoYXJncykgJiYgYXJncy5sZW5ndGggPiAxID8gYXJnc1sxXSA6IGZhbHNlO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBsYW5nXzEuaXNQcmVzZW50KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3NbMl0gOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBOdW1iZXJQaXBlLl9mb3JtYXQodmFsdWUsIGludGxfMS5OdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSwgZGlnaXRzLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXkpO1xyXG4gICAgfTtcclxuICAgIEN1cnJlbmN5UGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdjdXJyZW5jeScgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBDdXJyZW5jeVBpcGUpO1xyXG4gICAgcmV0dXJuIEN1cnJlbmN5UGlwZTtcclxufSkoTnVtYmVyUGlwZSk7XHJcbmV4cG9ydHMuQ3VycmVuY3lQaXBlID0gQ3VycmVuY3lQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJfcGlwZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIHByb3ZpZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9wcm92aWRlcicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBQaXBlUHJvdmlkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBpcGVQcm92aWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBpcGVQcm92aWRlcihuYW1lLCBwdXJlLCBrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aUJpbmRpbmcpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aUJpbmRpbmcpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wdXJlID0gcHVyZTtcclxuICAgIH1cclxuICAgIFBpcGVQcm92aWRlci5jcmVhdGVGcm9tVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBkaV8xLlByb3ZpZGVyKHR5cGUsIHsgdXNlQ2xhc3M6IHR5cGUgfSk7XHJcbiAgICAgICAgdmFyIHJiID0gcHJvdmlkZXJfMS5yZXNvbHZlUHJvdmlkZXIocHJvdmlkZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGlwZVByb3ZpZGVyKG1ldGFkYXRhLm5hbWUsIG1ldGFkYXRhLnB1cmUsIHJiLmtleSwgcmIucmVzb2x2ZWRGYWN0b3JpZXMsIHJiLm11bHRpUHJvdmlkZXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQaXBlUHJvdmlkZXI7XHJcbn0pKHByb3ZpZGVyXzEuUmVzb2x2ZWRQcm92aWRlcl8pO1xyXG5leHBvcnRzLlBpcGVQcm92aWRlciA9IFBpcGVQcm92aWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZV9wcm92aWRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGNkID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9waXBlcycpO1xyXG52YXIgUHJvdG9QaXBlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b1BpcGVzKFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogTWFwIG9mIHtAbGluayBQaXBlTWV0YWRhdGF9IG5hbWVzIHRvIHtAbGluayBQaXBlTWV0YWRhdGF9IGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgUHJvdG9QaXBlcy5mcm9tUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBjb25maWcgPSB7fTtcclxuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYikgeyByZXR1cm4gY29uZmlnW2IubmFtZV0gPSBiOyB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb3RvUGlwZXMoY29uZmlnKTtcclxuICAgIH07XHJcbiAgICBQcm90b1BpcGVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMuY29uZmlnW25hbWVdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwcm92aWRlcikpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIHBpcGUgJ1wiICsgbmFtZSArIFwiJy5cIik7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm90b1BpcGVzO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvUGlwZXMgPSBQcm90b1BpcGVzO1xyXG52YXIgUGlwZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGlwZXMocHJvdG8sIGluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5wcm90byA9IHByb3RvO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0ge307XHJcbiAgICB9XHJcbiAgICBQaXBlcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgY2FjaGVkID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KHRoaXMuX2NvbmZpZywgbmFtZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2FjaGVkKSlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucHJvdG8uZ2V0KG5hbWUpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmluamVjdG9yLmluc3RhbnRpYXRlUmVzb2x2ZWQocCk7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBjZC5TZWxlY3RlZFBpcGUodHJhbnNmb3JtLCBwLnB1cmUpO1xyXG4gICAgICAgIGlmIChwLnB1cmUpIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHRoaXMuX2NvbmZpZywgbmFtZSwgcmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGlwZXM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGlwZXMgPSBQaXBlcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbicpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4uL21ldGFkYXRhJyk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IExpc3Qgb3IgU3RyaW5nIGNvbnRhaW5pbmcgb25seSBhIHN1YnNldCAoc2xpY2UpIG9mIHRoZVxyXG4gKiBlbGVtZW50cy5cclxuICpcclxuICogVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuIGlzIHNwZWNpZmllZCBieSB0aGUgYHN0YXJ0YCBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqIFRoZSBlbmRpbmcgaW5kZXggb2YgdGhlIHN1YnNldCB0byByZXR1cm4gaXMgc3BlY2lmaWVkIGJ5IHRoZSBvcHRpb25hbCBgZW5kYCBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqICMgVXNhZ2VcclxuICpcclxuICogICAgIGV4cHJlc3Npb24gfCBzbGljZTpzdGFydFs6ZW5kXVxyXG4gKlxyXG4gKiBBbGwgYmVoYXZpb3IgaXMgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGJlaGF2aW9yIG9mIHRoZSBKYXZhU2NyaXB0IEFQSVxyXG4gKiBBcnJheS5wcm90b3R5cGUuc2xpY2UoKSBhbmQgU3RyaW5nLnByb3RvdHlwZS5zbGljZSgpXHJcbiAqXHJcbiAqIFdoZXJlIHRoZSBpbnB1dCBleHByZXNzaW9uIGlzIGEgW0xpc3RdIG9yIFtTdHJpbmddLCBhbmQgYHN0YXJ0YCBpczpcclxuICpcclxuICogLSAqKmEgcG9zaXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgX3N0YXJ0XyBpbmRleCBhbmQgYWxsIGl0ZW1zIGFmdGVyXHJcbiAqIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxyXG4gKiAtICoqYSBuZWdhdGl2ZSBpbnRlZ2VyKio6IHJldHVybiB0aGUgaXRlbSBhdCBfc3RhcnRfIGluZGV4IGZyb20gdGhlIGVuZCBhbmQgYWxsIGl0ZW1zIGFmdGVyXHJcbiAqIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxyXG4gKiAtICoqYHxzdGFydHxgIGdyZWF0ZXIgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgZXhwcmVzc2lvbioqOiByZXR1cm4gYW4gZW1wdHkgbGlzdCBvciBzdHJpbmcuXHJcbiAqIC0gKipgfHN0YXJ0fGAgbmVnYXRpdmUgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBlbnRpcmUgbGlzdCBvclxyXG4gKiBzdHJpbmcgZXhwcmVzc2lvbi5cclxuICpcclxuICogYW5kIHdoZXJlIGBlbmRgIGlzOlxyXG4gKlxyXG4gKiAtICoqb21pdHRlZCoqOiByZXR1cm4gYWxsIGl0ZW1zIHVudGlsIHRoZSBlbmQgb2YgdGhlIGlucHV0XHJcbiAqIC0gKiphIHBvc2l0aXZlIGludGVnZXIqKjogcmV0dXJuIGFsbCBpdGVtcyBiZWZvcmUgX2VuZF8gaW5kZXggb2YgdGhlIGxpc3Qgb3Igc3RyaW5nXHJcbiAqIGV4cHJlc3Npb24uXHJcbiAqIC0gKiphIG5lZ2F0aXZlIGludGVnZXIqKjogcmV0dXJuIGFsbCBpdGVtcyBiZWZvcmUgX2VuZF8gaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0XHJcbiAqIG9yIHN0cmluZyBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBXaGVuIG9wZXJhdGluZyBvbiBhIFtMaXN0XSwgdGhlIHJldHVybmVkIGxpc3QgaXMgYWx3YXlzIGEgY29weSBldmVuIHdoZW4gYWxsXHJcbiAqIHRoZSBlbGVtZW50cyBhcmUgYmVpbmcgcmV0dXJuZWQuXHJcbiAqXHJcbiAqICMgRXhhbXBsZXNcclxuICpcclxuICogIyMgTGlzdCBFeGFtcGxlXHJcbiAqXHJcbiAqIEFzc3VtaW5nIGB2YXIgY29sbGVjdGlvbiA9IFsnYScsICdiJywgJ2MnLCAnZCddYCwgdGhpcyBgbmctZm9yYCBkaXJlY3RpdmU6XHJcbiAqXHJcbiAqICAgICA8bGkgKm5nLWZvcj1cInZhciBpIGluIGNvbGxlY3Rpb24gfCBzbGljZToxOjNcIj57e2l9fTwvbGk+XHJcbiAqXHJcbiAqIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqICAgICA8bGk+YjwvbGk+XHJcbiAqICAgICA8bGk+YzwvbGk+XHJcbiAqXHJcbiAqICMjIFN0cmluZyBFeGFtcGxlc1xyXG4gKlxyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6MDo0IH19ICAgICAgIC8vIG91dHB1dCBpcyAnYWJjZCdcclxuICogICAgIHt7ICdhYmNkZWZnaGlqJyB8IHNsaWNlOjQ6MCB9fSAgICAgICAvLyBvdXRwdXQgaXMgJydcclxuICogICAgIHt7ICdhYmNkZWZnaGlqJyB8IHNsaWNlOi00IH19ICAgICAgLy8gb3V0cHV0IGlzICdnaGlqJ1xyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6LTQsLTIgfX0gICAgICAvLyBvdXRwdXQgaXMgJ2doJ1xyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6IC0xMDAgfX0gICAgLy8gb3V0cHV0IGlzICdhYmNkZWZnaGlqJ1xyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6IDEwMCB9fSAgICAvLyBvdXRwdXQgaXMgJydcclxuICovXHJcbnZhciBTbGljZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2xpY2VQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgU2xpY2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGFyZ3MpIHx8IGFyZ3MubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdTbGljZSBwaXBlIHJlcXVpcmVzIG9uZSBhcmd1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihTbGljZVBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGFyZ3NbMF07XHJcbiAgICAgICAgdmFyIGVuZCA9IGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3NbMV0gOiBudWxsO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5zbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIFNsaWNlUGlwZS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBsYW5nXzEuaXNTdHJpbmcob2JqKSB8fCBsYW5nXzEuaXNBcnJheShvYmopOyB9O1xyXG4gICAgU2xpY2VQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ3NsaWNlJyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFNsaWNlUGlwZSk7XHJcbiAgICByZXR1cm4gU2xpY2VQaXBlO1xyXG59KSgpO1xyXG5leHBvcnRzLlNsaWNlUGlwZSA9IFNsaWNlUGlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfcGlwZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHVwcGVyY2FzZSB0cmFuc2Zvcm1zIHRvIHRleHQuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBJbiB0aGlzIGV4YW1wbGUgd2UgdHJhbnNmb3JtIHRoZSB1c2VyIHRleHQgdXBwZXJjYXNlLlxyXG4gKlxyXG4gKiAgYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiBcInVzZXJuYW1lLWNtcFwiLFxyXG4gKiAgIHRlbXBsYXRlOiBcIlVzZXJuYW1lOiB7eyB1c2VyIHwgdXBwZXJjYXNlIH19XCJcclxuICogfSlcclxuICogY2xhc3MgVXNlcm5hbWUge1xyXG4gKiAgIHVzZXI6c3RyaW5nO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFVwcGVyQ2FzZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXBwZXJDYXNlUGlwZSgpIHtcclxuICAgIH1cclxuICAgIFVwcGVyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IG51bGw7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihVcHBlckNhc2VQaXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci50b1VwcGVyQ2FzZSh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgVXBwZXJDYXNlUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICd1cHBlcmNhc2UnIH0pLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgVXBwZXJDYXNlUGlwZSk7XHJcbiAgICByZXR1cm4gVXBwZXJDYXNlUGlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5VcHBlckNhc2VQaXBlID0gVXBwZXJDYXNlUGlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBwZXJjYXNlX3BpcGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbmV4cG9ydHMuRVhDRVBUSU9OX1BST1ZJREVSID0gZGlfMS5wcm92aWRlKGV4Y2VwdGlvbnNfMS5FeGNlcHRpb25IYW5kbGVyLCB7IHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBleGNlcHRpb25zXzEuRXhjZXB0aW9uSGFuZGxlcihkb21fYWRhcHRlcl8xLkRPTSwgZmFsc2UpOyB9LCBkZXBzOiBbXSB9KTtcclxuZXhwb3J0cy5FWENFUFRJT05fQklORElORyA9IGV4cG9ydHMuRVhDRVBUSU9OX1BST1ZJREVSO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybV9iaW5kaW5ncy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGltcGwgPSByZXF1aXJlKFwiLi93dGZfaW1wbFwiKTtcclxuLy8gQ2hhbmdlIGV4cG9ydHMgdG8gY29uc3Qgb25jZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci90czJkYXJ0L2lzc3Vlcy8xNTBcclxuLyoqXHJcbiAqIFRydWUgaWYgV1RGIGlzIGVuYWJsZWQuXHJcbiAqL1xyXG5leHBvcnRzLnd0ZkVuYWJsZWQgPSBpbXBsLmRldGVjdFdURigpO1xyXG5mdW5jdGlvbiBub29wU2NvcGUoYXJnMCwgYXJnMSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0cmFjZSBzY29wZS5cclxuICpcclxuICogU2NvcGVzIG11c3QgYmUgc3RyaWN0bHkgbmVzdGVkIGFuZCBhcmUgYW5hbG9nb3VzIHRvIHN0YWNrIGZyYW1lcywgYnV0XHJcbiAqIGRvIG5vdCBoYXZlIHRvIGZvbGxvdyB0aGUgc3RhY2sgZnJhbWVzLiBJbnN0ZWFkIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdGhleSBmb2xsb3cgbG9naWNhbFxyXG4gKiBuZXN0aW5nLiBZb3UgbWF5IHdhbnQgdG8gdXNlXHJcbiAqIFtFdmVudFxyXG4gKiBTaWduYXR1cmVzXShodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby90cmFjaW5nLWZyYW1ld29yay9pbnN0cnVtZW50aW5nLWNvZGUuaHRtbCNjdXN0b20tZXZlbnRzKVxyXG4gKiBhcyB0aGV5IGFyZSBkZWZpbmVkIGluIFdURi5cclxuICpcclxuICogVXNlZCB0byBtYXJrIHNjb3BlIGVudHJ5LiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgdG8gbGVhdmUgdGhlIHNjb3BlLlxyXG4gKlxyXG4gKiAgICAgdmFyIG15U2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnTXlDbGFzcyNteU1ldGhvZChhc2NpaSBzb21lVmFsKScpO1xyXG4gKlxyXG4gKiAgICAgc29tZU1ldGhvZCgpIHtcclxuICogICAgICAgIHZhciBzID0gbXlTY29wZSgnRm9vJyk7IC8vICdGb28nIGdldHMgc3RvcmVkIGluIHRyYWNpbmcgVUlcclxuICogICAgICAgIC8vIERPIFNPTUUgV09SSyBIRVJFXHJcbiAqICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgMTIzKTsgLy8gUmV0dXJuIHZhbHVlIDEyM1xyXG4gKiAgICAgfVxyXG4gKlxyXG4gKiBOb3RlLCBhZGRpbmcgdHJ5LWZpbmFsbHkgYmxvY2sgYXJvdW5kIHRoZSB3b3JrIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQgY2FuXHJcbiAqIG5lZ2F0aXZlbHkgaW1wYWN0IHRoZSBwZXJmb3JtYW5jZSBvZiB5b3VyIGFwcGxpY2F0aW9uLiBGb3IgdGhpcyByZWFzb24gd2UgcmVjb21tZW5kIHRoYXRcclxuICogeW91IGRvbid0IGFkZCB0aGVtIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQuIEluIHByb2R1Y3Rpb24gYHd0ZkxlYXZlYCBpcyBhIG5vb3AgYW5kXHJcbiAqIHNvIHRyeS1maW5hbGx5IGJsb2NrIGhhcyBubyB2YWx1ZS4gV2hlbiBkZWJ1Z2dpbmcgcGVyZiBpc3N1ZXMsIHNraXBwaW5nIGB3dGZMZWF2ZWAsIGRvIHRvXHJcbiAqIGV4Y2VwdGlvbiwgd2lsbCBwcm9kdWNlIGluY29ycmVjdCB0cmFjZSwgYnV0IHByZXNlbmNlIG9mIGV4Y2VwdGlvbiBzaWduaWZpZXMgbG9naWMgZXJyb3Igd2hpY2hcclxuICogbmVlZHMgdG8gYmUgZml4ZWQgYmVmb3JlIHRoZSBhcHAgc2hvdWxkIGJlIHByb2ZpbGVkLiBBZGQgdHJ5LWZpbmFsbHkgb25seSB3aGVuIHlvdSBleHBlY3QgdGhhdFxyXG4gKiBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWQgZHVyaW5nIG5vcm1hbCBleGVjdXRpb24gd2hpbGUgcHJvZmlsaW5nLlxyXG4gKlxyXG4gKi9cclxuZXhwb3J0cy53dGZDcmVhdGVTY29wZSA9IGV4cG9ydHMud3RmRW5hYmxlZCA/IGltcGwuY3JlYXRlU2NvcGUgOiBmdW5jdGlvbiAoc2lnbmF0dXJlLCBmbGFncykgeyByZXR1cm4gbm9vcFNjb3BlOyB9O1xyXG4vKipcclxuICogVXNlZCB0byBtYXJrIGVuZCBvZiBTY29wZS5cclxuICpcclxuICogLSBgc2NvcGVgIHRvIGVuZC5cclxuICogLSBgcmV0dXJuVmFsdWVgIChvcHRpb25hbCkgdG8gYmUgcGFzc2VkIHRvIHRoZSBXVEYuXHJcbiAqXHJcbiAqIFJldHVybnMgdGhlIGByZXR1cm5WYWx1ZSBmb3IgZWFzeSBjaGFpbmluZy5cclxuICovXHJcbmV4cG9ydHMud3RmTGVhdmUgPSBleHBvcnRzLnd0ZkVuYWJsZWQgPyBpbXBsLmxlYXZlIDogZnVuY3Rpb24gKHMsIHIpIHsgcmV0dXJuIHI7IH07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIG1hcmsgQXN5bmMgc3RhcnQuIEFzeW5jIGFyZSBzaW1pbGFyIHRvIHNjb3BlIGJ1dCB0aGV5IGRvbid0IGhhdmUgdG8gYmUgc3RyaWN0bHkgbmVzdGVkLlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW4gdGhlIGNhbGwgdG8gW2VuZEFzeW5jXS4gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cclxuICogZW5hYmxlZC5cclxuICpcclxuICogICAgIHNvbWVNZXRob2QoKSB7XHJcbiAqICAgICAgICB2YXIgcyA9IHd0ZlN0YXJ0VGltZVJhbmdlKCdIVFRQOkdFVCcsICdzb21lLnVybCcpO1xyXG4gKiAgICAgICAgdmFyIGZ1dHVyZSA9IG5ldyBGdXR1cmUuZGVsYXkoNSkudGhlbigoXykge1xyXG4gKiAgICAgICAgICB3dGZFbmRUaW1lUmFuZ2Uocyk7XHJcbiAqICAgICAgICB9KTtcclxuICogICAgIH1cclxuICovXHJcbmV4cG9ydHMud3RmU3RhcnRUaW1lUmFuZ2UgPSBleHBvcnRzLnd0ZkVuYWJsZWQgPyBpbXBsLnN0YXJ0VGltZVJhbmdlIDogZnVuY3Rpb24gKHJhbmdlVHlwZSwgYWN0aW9uKSB7IHJldHVybiBudWxsOyB9O1xyXG4vKipcclxuICogRW5kcyBhIGFzeW5jIHRpbWUgcmFuZ2Ugb3BlcmF0aW9uLlxyXG4gKiBbcmFuZ2VdIGlzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBbd3RmU3RhcnRUaW1lUmFuZ2VdIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXHJcbiAqIGVuYWJsZWQuXHJcbiAqL1xyXG5leHBvcnRzLnd0ZkVuZFRpbWVSYW5nZSA9IGV4cG9ydHMud3RmRW5hYmxlZCA/IGltcGwuZW5kVGltZVJhbmdlIDogZnVuY3Rpb24gKHIpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9maWxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vZmFjYWRlL2xhbmcnKTtcclxudmFyIHRyYWNlO1xyXG52YXIgZXZlbnRzO1xyXG5mdW5jdGlvbiBkZXRlY3RXVEYoKSB7XHJcbiAgICB2YXIgd3RmID0gbGFuZ18xLmdsb2JhbFsnd3RmJ107XHJcbiAgICBpZiAod3RmKSB7XHJcbiAgICAgICAgdHJhY2UgPSB3dGZbJ3RyYWNlJ107XHJcbiAgICAgICAgaWYgKHRyYWNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHRyYWNlWydldmVudHMnXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuZGV0ZWN0V1RGID0gZGV0ZWN0V1RGO1xyXG5mdW5jdGlvbiBjcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKSB7XHJcbiAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9IG51bGw7IH1cclxuICAgIHJldHVybiBldmVudHMuY3JlYXRlU2NvcGUoc2lnbmF0dXJlLCBmbGFncyk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVTY29wZSA9IGNyZWF0ZVNjb3BlO1xyXG5mdW5jdGlvbiBsZWF2ZShzY29wZSwgcmV0dXJuVmFsdWUpIHtcclxuICAgIHRyYWNlLmxlYXZlU2NvcGUoc2NvcGUsIHJldHVyblZhbHVlKTtcclxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxufVxyXG5leHBvcnRzLmxlYXZlID0gbGVhdmU7XHJcbmZ1bmN0aW9uIHN0YXJ0VGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gdHJhY2UuYmVnaW5UaW1lUmFuZ2UocmFuZ2VUeXBlLCBhY3Rpb24pO1xyXG59XHJcbmV4cG9ydHMuc3RhcnRUaW1lUmFuZ2UgPSBzdGFydFRpbWVSYW5nZTtcclxuZnVuY3Rpb24gZW5kVGltZVJhbmdlKHJhbmdlKSB7XHJcbiAgICB0cmFjZS5lbmRUaW1lUmFuZ2UocmFuZ2UpO1xyXG59XHJcbmV4cG9ydHMuZW5kVGltZVJhbmdlID0gZW5kVGltZVJhbmdlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13dGZfaW1wbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIFRoaXMgaXMgaGVyZSBiZWNhdXNlIERBUlQgcmVxdWlyZXMgaXQuIEl0IGlzIG5vb3AgaW4gSlMuXHJcbiAqL1xyXG5mdW5jdGlvbiB3dGZJbml0KCkgeyB9XHJcbmV4cG9ydHMud3RmSW5pdCA9IHd0ZkluaXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXd0Zl9pbml0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgcmVmbGVjdG9yXzEgPSByZXF1aXJlKCcuL3JlZmxlY3RvcicpO1xyXG52YXIgcmVmbGVjdG9yXzIgPSByZXF1aXJlKCcuL3JlZmxlY3RvcicpO1xyXG5leHBvcnRzLlJlZmxlY3RvciA9IHJlZmxlY3Rvcl8yLlJlZmxlY3RvcjtcclxuZXhwb3J0cy5SZWZsZWN0aW9uSW5mbyA9IHJlZmxlY3Rvcl8yLlJlZmxlY3Rpb25JbmZvO1xyXG52YXIgcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXNfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXMnKTtcclxuZXhwb3J0cy5yZWZsZWN0b3IgPSBuZXcgcmVmbGVjdG9yXzEuUmVmbGVjdG9yKG5ldyByZWZsZWN0aW9uX2NhcGFiaWxpdGllc18xLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMocmVmbGVjdCkge1xyXG4gICAgICAgIHRoaXMuX3JlZmxlY3QgPSBsYW5nXzEuaXNQcmVzZW50KHJlZmxlY3QpID8gcmVmbGVjdCA6IGxhbmdfMS5nbG9iYWwuUmVmbGVjdDtcclxuICAgIH1cclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmlzUmVmbGVjdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgc3dpdGNoICh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHQoKTsgfTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSkgeyByZXR1cm4gbmV3IHQoYTEpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMikgeyByZXR1cm4gbmV3IHQoYTEsIGEyKTsgfTtcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzKTsgfTtcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1KTsgfTtcclxuICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KTsgfTtcclxuICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTsgfTtcclxuICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KTsgfTtcclxuICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAxNjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE4OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAxOTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCwgYTE5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgsIGExOSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4LCBhMTksIGEyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4LCBhMTksIGEyMCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGZhY3RvcnkgZm9yICdcIiArIGxhbmdfMS5zdHJpbmdpZnkodCkgKyBcIicgYmVjYXVzZSBpdHMgY29uc3RydWN0b3IgaGFzIG1vcmUgdGhhbiAyMCBhcmd1bWVudHNcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuX3ppcFR5cGVzQW5kQW5ub3RhaW9ucyA9IGZ1bmN0aW9uIChwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocGFyYW1Bbm5vdGF0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShwYXJhbVR5cGVzLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIG91dHB1dHMgT2JqZWN0IGZvciBwYXJhbWV0ZXJzIHdpdGhvdXQgdHlwZXMsIHdoaWxlIFRyYWNldXIgb21pdHNcclxuICAgICAgICAgICAgLy8gdGhlIGFubm90YXRpb25zLiBGb3Igbm93IHdlIHByZXNlcnZlIHRoZSBUcmFjZXVyIGJlaGF2aW9yIHRvIGFpZFxyXG4gICAgICAgICAgICAvLyBtaWdyYXRpb24sIGJ1dCB0aGlzIGNhbiBiZSByZXZpc2l0ZWQuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtVHlwZXNbaV0gIT0gT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbcGFyYW1UeXBlc1tpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJhbUFubm90YXRpb25zKSAmJiBsYW5nXzEuaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0uY29uY2F0KHBhcmFtQW5ub3RhdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XHJcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMucGFyYW1ldGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVPckZ1bmMucGFyYW1ldGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVmbGVjdCkgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCB0eXBlT3JGdW5jKTtcclxuICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIHR5cGVPckZ1bmMpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJhbVR5cGVzKSB8fCBsYW5nXzEuaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5femlwVHlwZXNBbmRBbm5vdGFpb25zKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHR5cGVPckZ1bmMubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XHJcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMuYW5ub3RhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHR5cGVPckZ1bmMuYW5ub3RhdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihhbm5vdGF0aW9ucykgJiYgYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Fubm90YXRpb25zJywgdHlwZU9yRnVuYyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFubm90YXRpb25zKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XHJcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMucHJvcE1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdHlwZU9yRnVuYy5wcm9wTWV0YWRhdGE7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihwcm9wTWV0YWRhdGEpICYmIHByb3BNZXRhZGF0YS5wcm9wTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHByb3BNZXRhZGF0YS5wcm9wTWV0YWRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVmbGVjdCkgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdHlwZU9yRnVuYyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3BNZXRhZGF0YSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaW50ZXJmYWNlcyA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiSmF2YVNjcmlwdCBkb2VzIG5vdCBzdXBwb3J0IGludGVyZmFjZXNcIik7XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICdyZXR1cm4gby4nICsgbmFtZSArICc7Jyk7IH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAndicsICdyZXR1cm4gby4nICsgbmFtZSArICcgPSB2OycpO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uQm9keSA9IFwiaWYgKCFvLlwiICsgbmFtZSArIFwiKSB0aHJvdyBuZXcgRXJyb3IoJ1xcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgdW5kZWZpbmVkJyk7XFxuICAgICAgICByZXR1cm4gby5cIiArIG5hbWUgKyBcIi5hcHBseShvLCBhcmdzKTtcIjtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ2FyZ3MnLCBmdW5jdGlvbkJvZHkpO1xyXG4gICAgfTtcclxuICAgIC8vIFRoZXJlIGlzIG5vdCBhIGNvbmNlcHQgb2YgaW1wb3J0IHVyaSBpbiBKcywgYnV0IHRoaXMgaXMgdXNlZnVsIGluIGRldmVsb3BpbmcgRGFydCBhcHBsaWNhdGlvbnMuXHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gJy4vJzsgfTtcclxuICAgIHJldHVybiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uX2NhcGFiaWxpdGllcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIFJlZmxlY3Rpb25JbmZvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25JbmZvKGFubm90YXRpb25zLCBwYXJhbWV0ZXJzLCBmYWN0b3J5LCBpbnRlcmZhY2VzLCBwcm9wTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcclxuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlcyA9IGludGVyZmFjZXM7XHJcbiAgICAgICAgdGhpcy5wcm9wTWV0YWRhdGEgPSBwcm9wTWV0YWRhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVmbGVjdGlvbkluZm87XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVmbGVjdGlvbkluZm8gPSBSZWZsZWN0aW9uSW5mbztcclxudmFyIFJlZmxlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWZsZWN0b3IocmVmbGVjdGlvbkNhcGFiaWxpdGllcykge1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9pbmplY3RhYmxlSW5mbyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2dldHRlcnMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9zZXR0ZXJzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdXNlZEtleXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmlzUmVmbGVjdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaXNSZWZsZWN0aW9uRW5hYmxlZCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXVzZXMgYHRoaXNgIHJlZmxlY3RvciB0byB0cmFjayBrZXlzIHVzZWQgdG8gYWNjZXNzXHJcbiAgICAgKiB7QGxpbmsgUmVmbGVjdGlvbkluZm99IG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUudHJhY2tVc2FnZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdXNlZEtleXMgPSBuZXcgY29sbGVjdGlvbl8xLlNldCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0cyB0eXBlcyBmb3Igd2hpY2ggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgbm90IHJlcXVlc3RlZCBzaW5jZVxyXG4gICAgICoge0BsaW5rICN0cmFja1VzYWdlfSB3YXMgY2FsbGVkLiBUaGlzIGxpc3QgY291bGQgbGF0ZXIgYmUgYXVkaXRlZCBhc1xyXG4gICAgICogcG90ZW50aWFsIGRlYWQgY29kZS5cclxuICAgICAqL1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5saXN0VW51c2VkS2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl91c2VkS2V5cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVXNhZ2UgdHJhY2tpbmcgaXMgZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbFR5cGVzID0gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIua2V5cyh0aGlzLl9pbmplY3RhYmxlSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWx0ZXIoYWxsVHlwZXMsIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMoX3RoaXMuX3VzZWRLZXlzLCBrZXkpOyB9KTtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYywgZnVuY0luZm8pIHtcclxuICAgICAgICB0aGlzLl9pbmplY3RhYmxlSW5mby5zZXQoZnVuYywgZnVuY0luZm8pO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24gKHR5cGUsIHR5cGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5faW5qZWN0YWJsZUluZm8uc2V0KHR5cGUsIHR5cGVJbmZvKTtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyR2V0dGVycyA9IGZ1bmN0aW9uIChnZXR0ZXJzKSB7IF9tZXJnZU1hcHModGhpcy5fZ2V0dGVycywgZ2V0dGVycyk7IH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyU2V0dGVycyA9IGZ1bmN0aW9uIChzZXR0ZXJzKSB7IF9tZXJnZU1hcHModGhpcy5fc2V0dGVycywgc2V0dGVycyk7IH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kcyA9IGZ1bmN0aW9uIChtZXRob2RzKSB7IF9tZXJnZU1hcHModGhpcy5fbWV0aG9kcywgbWV0aG9kcyk7IH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1JlZmxlY3Rpb25JbmZvKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlKS5mYWN0b3J5O1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZmFjdG9yeSh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlT3JGdW5jKS5wYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYykpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGVPckZ1bmMpLmFubm90YXRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmFubm90YXRpb25zKHR5cGVPckZ1bmMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luamVjdGFibGVJbmZvLmhhcyh0eXBlT3JGdW5jKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fZ2V0UmVmbGVjdGlvbkluZm8odHlwZU9yRnVuYykucHJvcE1ldGFkYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDoge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlKS5pbnRlcmZhY2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmludGVyZmFjZXModHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ2V0dGVycy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldHRlcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5nZXR0ZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2V0dGVycy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRlcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5zZXR0ZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWV0aG9kcy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5tZXRob2QobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuX2dldFJlZmxlY3Rpb25JbmZvID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl91c2VkS2V5cykpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXNlZEtleXMuYWRkKHR5cGVPckZ1bmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0YWJsZUluZm8uZ2V0KHR5cGVPckZ1bmMpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuX2NvbnRhaW5zUmVmbGVjdGlvbkluZm8gPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyByZXR1cm4gdGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpOyB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmltcG9ydFVyaSh0eXBlKTsgfTtcclxuICAgIHJldHVybiBSZWZsZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVmbGVjdG9yID0gUmVmbGVjdG9yO1xyXG5mdW5jdGlvbiBfbWVyZ2VNYXBzKHRhcmdldCwgY29uZmlnKSB7XHJcbiAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGNvbmZpZywgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHRhcmdldC5zZXQoaywgdik7IH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gUHVibGljIEFQSSBmb3IgcmVuZGVyXHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJy4vcmVuZGVyL3JlbmRlcicpO1xyXG5leHBvcnRzLlJlbmRlcmVyID0gcmVuZGVyXzEuUmVuZGVyZXI7XHJcbmV4cG9ydHMuUmVuZGVyVmlld1JlZiA9IHJlbmRlcl8xLlJlbmRlclZpZXdSZWY7XHJcbmV4cG9ydHMuUmVuZGVyUHJvdG9WaWV3UmVmID0gcmVuZGVyXzEuUmVuZGVyUHJvdG9WaWV3UmVmO1xyXG5leHBvcnRzLlJlbmRlckZyYWdtZW50UmVmID0gcmVuZGVyXzEuUmVuZGVyRnJhZ21lbnRSZWY7XHJcbmV4cG9ydHMuUmVuZGVyVmlld1dpdGhGcmFnbWVudHMgPSByZW5kZXJfMS5SZW5kZXJWaWV3V2l0aEZyYWdtZW50cztcclxuZXhwb3J0cy5ET0NVTUVOVCA9IHJlbmRlcl8xLkRPQ1VNRU5UO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIEFuZ3VsYXIgUHJvdG9WaWV3IGluIHRoZSBSZW5kZXJpbmcgQ29udGV4dC5cclxuICpcclxuICogV2hlbiB5b3UgaW1wbGVtZW50IGEgY3VzdG9tIHtAbGluayBSZW5kZXJlcn0sIGBSZW5kZXJQcm90b1ZpZXdSZWZgIHNwZWNpZmllcyB3aGF0IFJlbmRlciBWaWV3XHJcbiAqIHlvdXIgcmVuZGVyZXIgc2hvdWxkIGNyZWF0ZS5cclxuICpcclxuICogYFJlbmRlclByb3RvVmlld1JlZmAgaXMgYSBjb3VudGVycGFydCB0byB7QGxpbmsgUHJvdG9WaWV3UmVmfSBhdmFpbGFibGUgaW4gdGhlIEFwcGxpY2F0aW9uXHJcbiAqIENvbnRleHQuIEJ1dCB1bmxpa2UgYFByb3RvVmlld1JlZmAsIGBSZW5kZXJQcm90b1ZpZXdSZWZgIGNvbnRhaW5zIGFsbCBzdGF0aWMgbmVzdGVkIFByb3RvIFZpZXdzXHJcbiAqIHRoYXQgYXJlIHJlY3Vyc2l2ZWx5IG1lcmdlZCBpbnRvIGEgc2luZ2xlIFJlbmRlciBQcm90byBWaWV3LlxyXG5cclxuICpcclxuICogPCEtLSBUT0RPOiB0aGlzIGlzIGNyZWF0ZWQgYnkgUmVuZGVyZXIjY3JlYXRlUHJvdG9WaWV3IGluIHRoZSBuZXcgY29tcGlsZXIgLS0+XHJcbiAqL1xyXG52YXIgUmVuZGVyUHJvdG9WaWV3UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclByb3RvVmlld1JlZigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBSZW5kZXJQcm90b1ZpZXdSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVuZGVyUHJvdG9WaWV3UmVmID0gUmVuZGVyUHJvdG9WaWV3UmVmO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGxpc3Qgb2Ygc2libGluZyBOb2RlcyB0aGF0IGNhbiBiZSBtb3ZlZCBieSB0aGUge0BsaW5rIFJlbmRlcmVyfSBpbmRlcGVuZGVudGx5IG9mXHJcbiAqIG90aGVyIFJlbmRlciBGcmFnbWVudHMuXHJcbiAqXHJcbiAqIEFueSB7QGxpbmsgUmVuZGVyVmlld30gaGFzIG9uZSBSZW5kZXIgRnJhZ21lbnQuXHJcbiAqXHJcbiAqIEFkZGl0aW9uYWxseSBhbnkgVmlldyB3aXRoIGFuIEVtYmVkZGVkIFZpZXcgdGhhdCBjb250YWlucyBhIHtAbGluayBOZ0NvbnRlbnQgVmlldyBQcm9qZWN0aW9ufVxyXG4gKiByZXN1bHRzIGluIGFkZGl0aW9uYWwgUmVuZGVyIEZyYWdtZW50LlxyXG4gKi9cclxuLypcclxuICA8ZGl2PmZvbzwvZGl2PlxyXG4gIHt7YmFyfX1cclxuXHJcblxyXG4gIDxkaXY+Zm9vPC9kaXY+IC0+IHZpZXcgMSAvIGZyYWdtZW50IDFcclxuICA8dWw+XHJcbiAgICA8dGVtcGxhdGUgbmctZm9yPlxyXG4gICAgICA8bGk+e3tmZ319PC9saT4gLT4gdmlldyAyIC8gZnJhZ21lbnQgMVxyXG4gICAgPC90ZW1wbGF0ZT5cclxuICA8L3VsPlxyXG4gIHt7YmFyfX1cclxuXHJcblxyXG4gIDxkaXY+Zm9vPC9kaXY+IC0+IHZpZXcgMSAvIGZyYWdtZW50IDFcclxuICA8dWw+XHJcbiAgICA8dGVtcGxhdGUgbmctaWY+XHJcbiAgICAgIDxsaT48bmctY29udGVudD48Lz48L2xpPiAtPiB2aWV3IDEgLyBmcmFnbWVudCAyXHJcbiAgICA8L3RlbXBsYXRlPlxyXG4gICAgPHRlbXBsYXRlIG5nLWZvcj5cclxuICAgICAgPGxpPjxuZy1jb250ZW50PjwvPjwvbGk+IC0+XHJcbiAgICAgIDxsaT48L2xpPiAgICAgICAgICAgICAgICAtPiB2aWV3IDEgLyBmcmFnbWVudCAyICsgdmlldyAyIC8gZnJhZ21lbnQgMS4ubi0xXHJcbiAgICA8L3RlbXBsYXRlPlxyXG4gIDwvdWw+XHJcbiAge3tiYXJ9fVxyXG4gKi9cclxuLy8gVE9ETyhpKTogcmVmYWN0b3IgaW50byBhbiBpbnRlcmZhY2VcclxudmFyIFJlbmRlckZyYWdtZW50UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbmRlckZyYWdtZW50UmVmKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbmRlckZyYWdtZW50UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlbmRlckZyYWdtZW50UmVmID0gUmVuZGVyRnJhZ21lbnRSZWY7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIEFuZ3VsYXIgVmlldyBpbiB0aGUgUmVuZGVyaW5nIENvbnRleHQuXHJcbiAqXHJcbiAqIGBSZW5kZXJWaWV3UmVmYCBzcGVjaWZpZXMgdG8gdGhlIHtAbGluayBSZW5kZXJlcn0gd2hhdCBWaWV3IHRvIHVwZGF0ZSBvciBkZXN0cm95LlxyXG4gKlxyXG4gKiBVbmxpa2UgYSB7QGxpbmsgVmlld1JlZn0gYXZhaWxhYmxlIGluIHRoZSBBcHBsaWNhdGlvbiBDb250ZXh0LCBSZW5kZXIgVmlldyBjb250YWlucyBhbGwgdGhlXHJcbiAqIHN0YXRpYyBDb21wb25lbnQgVmlld3MgdGhhdCBoYXZlIGJlZW4gcmVjdXJzaXZlbHkgbWVyZ2VkIGludG8gYSBzaW5nbGUgUmVuZGVyIFZpZXcuXHJcbiAqXHJcbiAqIEVhY2ggYFJlbmRlclZpZXdSZWZgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHtAbGluayBSZW5kZXJGcmFnbWVudFJlZiBSZW5kZXIgRnJhZ21lbnRzfSwgdGhlc2VcclxuICogRnJhZ21lbnRzIGFyZSBjcmVhdGVkLCBoeWRyYXRlZCwgZGVoeWRyYXRlZCBhbmQgZGVzdHJveWVkIGFzIGEgc2luZ2xlIHVuaXQgdG9nZXRoZXIgd2l0aCB0aGVcclxuICogVmlldy5cclxuICovXHJcbi8vIFRPRE8oaSk6IHJlZmFjdG9yIGludG8gYW4gaW50ZXJmYWNlXHJcbnZhciBSZW5kZXJWaWV3UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclZpZXdSZWYoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVuZGVyVmlld1JlZjtcclxufSkoKTtcclxuZXhwb3J0cy5SZW5kZXJWaWV3UmVmID0gUmVuZGVyVmlld1JlZjtcclxuLyoqXHJcbiAqIENvbnRhaW5lciBjbGFzcyBwcm9kdWNlZCBieSBhIHtAbGluayBSZW5kZXJlcn0gd2hlbiBjcmVhdGluZyBhIFJlbmRlciBWaWV3LlxyXG4gKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiBgUmVuZGVyVmlld1dpdGhGcmFnbWVudHNgIGNvbnRhaW5zIGEge0BsaW5rIFJlbmRlclZpZXdSZWZ9IGFuZCBhbiBhcnJheSBvZlxyXG4gKiB7QGxpbmsgUmVuZGVyRnJhZ21lbnRSZWZ9cyBiZWxvbmdpbmcgdG8gdGhpcyBSZW5kZXIgVmlldy5cclxuICovXHJcbi8vIFRPRE8oaSk6IHJlZmFjdG9yIHRoaXMgYnkgUmVuZGVyVmlld1dpdGhGcmFnbWVudHMgYW5kIGFkZGluZyBmcmFnbWVudHMgZGlyZWN0bHkgdG8gUmVuZGVyVmlld1JlZlxyXG52YXIgUmVuZGVyVmlld1dpdGhGcmFnbWVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyVmlld1dpdGhGcmFnbWVudHMoXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgUmVuZGVyVmlld1JlZn0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmlld1JlZiwgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2Yge0BsaW5rIFJlbmRlckZyYWdtZW50UmVmfXMgb3JkZXJlZCBpbiB0aGUgZGVwdGgtZmlyc3Qgb3JkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnJhZ21lbnRSZWZzKSB7XHJcbiAgICAgICAgdGhpcy52aWV3UmVmID0gdmlld1JlZjtcclxuICAgICAgICB0aGlzLmZyYWdtZW50UmVmcyA9IGZyYWdtZW50UmVmcztcclxuICAgIH1cclxuICAgIHJldHVybiBSZW5kZXJWaWV3V2l0aEZyYWdtZW50cztcclxufSkoKTtcclxuZXhwb3J0cy5SZW5kZXJWaWV3V2l0aEZyYWdtZW50cyA9IFJlbmRlclZpZXdXaXRoRnJhZ21lbnRzO1xyXG4vKipcclxuICogSW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBsb3ctbGV2ZWwgaW50ZXJmYWNlIGZvciBtb2RpZnlpbmcgdGhlIFVJLlxyXG4gKlxyXG4gKiBVc2UgdGhpcyBzZXJ2aWNlIHRvIGJ5cGFzcyBBbmd1bGFyJ3MgdGVtcGxhdGluZyBhbmQgbWFrZSBjdXN0b20gVUkgY2hhbmdlcyB0aGF0IGNhbid0IGJlXHJcbiAqIGV4cHJlc3NlZCBkZWNsYXJhdGl2ZWx5LiBGb3IgZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBzZXQgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBpc1xyXG4gKiBub3Qgc3RhdGljYWxseSBrbm93biwgdXNlIHtAbGluayAjc2V0RWxlbWVudFByb3BlcnR5fSBvciB7QGxpbmsgI3NldEVsZW1lbnRBdHRyaWJ1dGV9XHJcbiAqIHJlc3BlY3RpdmVseS5cclxuICpcclxuICogSWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gcmVuZGVyZXIsIHlvdSBtdXN0IGltcGxlbWVudCB0aGlzIGludGVyZmFjZS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gaXMge0BsaW5rIERvbVJlbmRlcmVyfS4gQWxzbyBzZWUge0BsaW5rIFdlYldvcmtlclJlbmRlcmVyfS5cclxuICovXHJcbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBSZW5kZXJlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgYW5pbWF0aW9uX2J1aWxkZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9hbmltYXRlL2FuaW1hdGlvbl9idWlsZGVyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGV2ZW50X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vZXZlbnRzL2V2ZW50X21hbmFnZXInKTtcclxudmFyIHNoYXJlZF9zdHlsZXNfaG9zdF8xID0gcmVxdWlyZSgnLi9zaGFyZWRfc3R5bGVzX2hvc3QnKTtcclxudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4uLy4uL3Byb2ZpbGUvcHJvZmlsZScpO1xyXG52YXIgYXBpXzEgPSByZXF1aXJlKCcuLi9hcGknKTtcclxudmFyIGRvbV90b2tlbnNfMSA9IHJlcXVpcmUoJy4vZG9tX3Rva2VucycpO1xyXG52YXIgdmlld19mYWN0b3J5XzEgPSByZXF1aXJlKCcuLi92aWV3X2ZhY3RvcnknKTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG52YXIgRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERvbVJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRG9tUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlUHJvdG9WaWV3ID0gZnVuY3Rpb24gKGNtZHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHZpZXdfMS5EZWZhdWx0UHJvdG9WaWV3UmVmKGNtZHMpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5nZXROYXRpdmVFbGVtZW50U3luYyA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGxvY2F0aW9uLnJlbmRlclZpZXcpLmJvdW5kRWxlbWVudHNbbG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5nZXRSb290Tm9kZXMgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHsgcmV0dXJuIHJlc29sdmVJbnRlcm5hbERvbUZyYWdtZW50KGZyYWdtZW50KTsgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hGcmFnbWVudEFmdGVyRnJhZ21lbnQgPSBmdW5jdGlvbiAocHJldmlvdXNGcmFnbWVudFJlZiwgZnJhZ21lbnRSZWYpIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNGcmFnbWVudE5vZGVzID0gcmVzb2x2ZUludGVybmFsRG9tRnJhZ21lbnQocHJldmlvdXNGcmFnbWVudFJlZik7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzRnJhZ21lbnROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWJsaW5nID0gcHJldmlvdXNGcmFnbWVudE5vZGVzW3ByZXZpb3VzRnJhZ21lbnROb2Rlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdmFyIG5vZGVzID0gcmVzb2x2ZUludGVybmFsRG9tRnJhZ21lbnQoZnJhZ21lbnRSZWYpO1xyXG4gICAgICAgICAgICBtb3ZlTm9kZXNBZnRlclNpYmxpbmcoc2libGluZywgbm9kZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVOb2Rlc0VudGVyKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBub2RlcyBiZWluZyBhZGRlZCB0byB0aGUgRE9NIGFuZCBhbmltYXRlcyB0aGVtIGlmIG5lY2Vzc2FyeVxyXG4gICAgICogQHBhcmFtIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlTm9kZXNFbnRlciA9IGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZU5vZGVFbnRlcihub2Rlc1tpXSk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaEZyYWdtZW50QWZ0ZXJFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRSZWYsIGZyYWdtZW50UmVmKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFZpZXcgPSByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGVsZW1lbnRSZWYucmVuZGVyVmlldyk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXJlbnRWaWV3LmJvdW5kRWxlbWVudHNbZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIG5vZGVzID0gcmVzb2x2ZUludGVybmFsRG9tRnJhZ21lbnQoZnJhZ21lbnRSZWYpO1xyXG4gICAgICAgIG1vdmVOb2Rlc0FmdGVyU2libGluZyhlbGVtZW50LCBub2Rlcyk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRlTm9kZXNFbnRlcihub2Rlcyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmh5ZHJhdGVWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHsgcmVzb2x2ZUludGVybmFsRG9tVmlldyh2aWV3UmVmKS5oeWRyYXRlKCk7IH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGVoeWRyYXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7IHJlc29sdmVJbnRlcm5hbERvbVZpZXcodmlld1JlZikuZGVoeWRyYXRlKCk7IH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAoYXR0ck5hbWVBbmRWYWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnLCBhdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRvbV9hZGFwdGVyXzEuRE9NLmNyZWF0ZVRleHROb2RlKGxhbmdfMS5pc1ByZXNlbnQodmFsdWUpID8gdmFsdWUgOiAnJyk7IH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkgeyBkb21fYWRhcHRlcl8xLkRPTS5hcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKTsgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAobG9jYXRpb24sIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyhsb2NhdGlvbi5yZW5kZXJWaWV3KTtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRQcm9wZXJ0eSh2aWV3LmJvdW5kRWxlbWVudHNbbG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXhdLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyhsb2NhdGlvbi5yZW5kZXJWaWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIGRhc2hDYXNlZEF0dHJpYnV0ZU5hbWUgPSB1dGlsXzEuY2FtZWxDYXNlVG9EYXNoQ2FzZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdHRyaWJ1dGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0QXR0cmlidXRlKGVsZW1lbnQsIGRhc2hDYXNlZEF0dHJpYnV0ZU5hbWUsIGxhbmdfMS5zdHJpbmdpZnkoYXR0cmlidXRlVmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBkYXNoQ2FzZWRBdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgY2xhc3NOYW1lLCBpc0FkZCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyhsb2NhdGlvbi5yZW5kZXJWaWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgaWYgKGlzQWRkKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHJlc29sdmVJbnRlcm5hbERvbVZpZXcobG9jYXRpb24ucmVuZGVyVmlldyk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2aWV3LmJvdW5kRWxlbWVudHNbbG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHZhciBkYXNoQ2FzZWRTdHlsZU5hbWUgPSB1dGlsXzEuY2FtZWxDYXNlVG9EYXNoQ2FzZShzdHlsZU5hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0eWxlVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldFN0eWxlKGVsZW1lbnQsIGRhc2hDYXNlZFN0eWxlTmFtZSwgbGFuZ18xLnN0cmluZ2lmeShzdHlsZVZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmVTdHlsZShlbGVtZW50LCBkYXNoQ2FzZWRTdHlsZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuaW52b2tlRWxlbWVudE1ldGhvZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyhsb2NhdGlvbi5yZW5kZXJWaWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uaW52b2tlKGVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHZpZXdSZWYsIHRleHROb2RlSW5kZXgsIHRleHQpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHJlc29sdmVJbnRlcm5hbERvbVZpZXcodmlld1JlZik7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0VGV4dCh2aWV3LmJvdW5kVGV4dE5vZGVzW3RleHROb2RlSW5kZXhdLCB0ZXh0KTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKHZpZXdSZWYsIGRpc3BhdGNoZXIpIHtcclxuICAgICAgICByZXNvbHZlSW50ZXJuYWxEb21WaWV3KHZpZXdSZWYpLnNldEV2ZW50RGlzcGF0Y2hlcihkaXNwYXRjaGVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRG9tUmVuZGVyZXI7XHJcbn0pKGFwaV8xLlJlbmRlcmVyKTtcclxuZXhwb3J0cy5Eb21SZW5kZXJlciA9IERvbVJlbmRlcmVyO1xyXG52YXIgRG9tUmVuZGVyZXJfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEb21SZW5kZXJlcl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEb21SZW5kZXJlcl8oX2V2ZW50TWFuYWdlciwgX2RvbVNoYXJlZFN0eWxlc0hvc3QsIF9hbmltYXRlLCBkb2N1bWVudCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IF9ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fZG9tU2hhcmVkU3R5bGVzSG9zdCA9IF9kb21TaGFyZWRTdHlsZXNIb3N0O1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBfYW5pbWF0ZTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRDbWRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX25hdGl2ZVNoYWRvd1N0eWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlUm9vdEhvc3RWaWV3U2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0RvbVJlbmRlcmVyI2NyZWF0ZVJvb3RIb3N0VmlldygpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVZpZXdTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnRG9tUmVuZGVyZXIjY3JlYXRlVmlldygpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2RldGFjaEZyYWdtZW50U2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0RvbVJlbmRlcmVyI2RldGFjaEZyYWdtZW50KCknKTtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5yZWdpc3RlckNvbXBvbmVudFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlSWQsIGNvbW1hbmRzLCBzdHlsZXMsIG5hdGl2ZVNoYWRvdykge1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudENtZHMuc2V0KHRlbXBsYXRlSWQsIGNvbW1hbmRzKTtcclxuICAgICAgICBpZiAobmF0aXZlU2hhZG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVNoYWRvd1N0eWxlcy5zZXQodGVtcGxhdGVJZCwgc3R5bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RvbVNoYXJlZFN0eWxlc0hvc3QuYWRkU3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50Q21kcy5nZXQodGVtcGxhdGVJZCk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5jcmVhdGVSb290SG9zdFZpZXcgPSBmdW5jdGlvbiAoaG9zdFByb3RvVmlld1JlZiwgZnJhZ21lbnRDb3VudCwgaG9zdEVsZW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlUm9vdEhvc3RWaWV3U2NvcGUoKTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvbV9hZGFwdGVyXzEuRE9NLnF1ZXJ5U2VsZWN0b3IodGhpcy5fZG9jdW1lbnQsIGhvc3RFbGVtZW50U2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICBwcm9maWxlXzEud3RmTGVhdmUocyk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBob3N0RWxlbWVudFNlbGVjdG9yICsgXCJcXFwiIGRpZCBub3QgbWF0Y2ggYW55IGVsZW1lbnRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHRoaXMuX2NyZWF0ZVZpZXcoaG9zdFByb3RvVmlld1JlZiwgZWxlbWVudCkpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuY3JlYXRlVmlldyA9IGZ1bmN0aW9uIChwcm90b1ZpZXdSZWYsIGZyYWdtZW50Q291bnQpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2NyZWF0ZVZpZXdTY29wZSgpO1xyXG4gICAgICAgIHJldHVybiBwcm9maWxlXzEud3RmTGVhdmUocywgdGhpcy5fY3JlYXRlVmlldyhwcm90b1ZpZXdSZWYsIG51bGwpKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLl9jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlld1JlZiwgaW5wbGFjZUVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdfZmFjdG9yeV8xLmNyZWF0ZVJlbmRlclZpZXcocHJvdG9WaWV3UmVmLmNtZHMsIGlucGxhY2VFbGVtZW50LCB0aGlzKTtcclxuICAgICAgICB2YXIgc2RSb290cyA9IHZpZXcubmF0aXZlU2hhZG93Um9vdHM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZFJvb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RvbVNoYXJlZFN0eWxlc0hvc3QuYWRkSG9zdChzZFJvb3RzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhcGlfMS5SZW5kZXJWaWV3V2l0aEZyYWdtZW50cyh2aWV3LCB2aWV3LmZyYWdtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5kZXN0cm95VmlldyA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3UmVmO1xyXG4gICAgICAgIHZhciBzZFJvb3RzID0gdmlldy5uYXRpdmVTaGFkb3dSb290cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNkUm9vdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fZG9tU2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KHNkUm9vdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLmFuaW1hdGVOb2RlRW50ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGlmIChkb21fYWRhcHRlcl8xLkRPTS5pc0VsZW1lbnROb2RlKG5vZGUpICYmIGRvbV9hZGFwdGVyXzEuRE9NLmhhc0NsYXNzKG5vZGUsICduZy1hbmltYXRlJykpIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uYWRkQ2xhc3Mobm9kZSwgJ25nLWVudGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUuY3NzKClcclxuICAgICAgICAgICAgICAgIC5hZGRBbmltYXRpb25DbGFzcygnbmctZW50ZXItYWN0aXZlJylcclxuICAgICAgICAgICAgICAgIC5zdGFydChub2RlKVxyXG4gICAgICAgICAgICAgICAgLm9uQ29tcGxldGUoZnVuY3Rpb24gKCkgeyBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmVDbGFzcyhub2RlLCAnbmctZW50ZXInKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuYW5pbWF0ZU5vZGVMZWF2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzRWxlbWVudE5vZGUobm9kZSkgJiYgZG9tX2FkYXB0ZXJfMS5ET00uaGFzQ2xhc3Mobm9kZSwgJ25nLWFuaW1hdGUnKSkge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hZGRDbGFzcyhub2RlLCAnbmctbGVhdmUnKTtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZS5jc3MoKVxyXG4gICAgICAgICAgICAgICAgLmFkZEFuaW1hdGlvbkNsYXNzKCduZy1sZWF2ZS1hY3RpdmUnKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KG5vZGUpXHJcbiAgICAgICAgICAgICAgICAub25Db21wbGV0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmVDbGFzcyhub2RlLCAnbmctbGVhdmUnKTtcclxuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuZGV0YWNoRnJhZ21lbnQgPSBmdW5jdGlvbiAoZnJhZ21lbnRSZWYpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2RldGFjaEZyYWdtZW50U2NvcGUoKTtcclxuICAgICAgICB2YXIgZnJhZ21lbnROb2RlcyA9IHJlc29sdmVJbnRlcm5hbERvbUZyYWdtZW50KGZyYWdtZW50UmVmKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50Tm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlTm9kZUxlYXZlKGZyYWdtZW50Tm9kZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9maWxlXzEud3RmTGVhdmUocyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGVsID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlRWxlbWVudChuYW1lKTtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGVsLCBhdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUubWVyZ2VFbGVtZW50ID0gZnVuY3Rpb24gKGV4aXN0aW5nLCBhdHRyTmFtZUFuZFZhbHVlcykge1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmNsZWFyTm9kZXMoZXhpc3RpbmcpO1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoZXhpc3RpbmcsIGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLl9zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG5vZGUsIGF0dHJOYW1lQW5kVmFsdWVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXR0cklkeCA9IDA7IGF0dHJJZHggPCBhdHRyTmFtZUFuZFZhbHVlcy5sZW5ndGg7IGF0dHJJZHggKz0gMikge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRBdHRyaWJ1dGUobm9kZSwgYXR0ck5hbWVBbmRWYWx1ZXNbYXR0cklkeF0sIGF0dHJOYW1lQW5kVmFsdWVzW2F0dHJJZHggKyAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuY3JlYXRlUm9vdENvbnRlbnRJbnNlcnRpb25Qb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlQ29tbWVudCgncm9vdC1jb250ZW50LWluc2VydGlvbi1wb2ludCcpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChob3N0LCB0ZW1wbGF0ZUlkKSB7XHJcbiAgICAgICAgdmFyIHNyID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlU2hhZG93Um9vdChob3N0KTtcclxuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5fbmF0aXZlU2hhZG93U3R5bGVzLmdldCh0ZW1wbGF0ZUlkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hcHBlbmRDaGlsZChzciwgZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlU3R5bGVFbGVtZW50KHN0eWxlc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3I7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5nbG9iYWxPbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDMsIGRpXzEuSW5qZWN0KGRvbV90b2tlbnNfMS5ET0NVTUVOVCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyLCBzaGFyZWRfc3R5bGVzX2hvc3RfMS5Eb21TaGFyZWRTdHlsZXNIb3N0LCBhbmltYXRpb25fYnVpbGRlcl8xLkFuaW1hdGlvbkJ1aWxkZXIsIE9iamVjdF0pXHJcbiAgICBdLCBEb21SZW5kZXJlcl8pO1xyXG4gICAgcmV0dXJuIERvbVJlbmRlcmVyXztcclxufSkoRG9tUmVuZGVyZXIpO1xyXG5leHBvcnRzLkRvbVJlbmRlcmVyXyA9IERvbVJlbmRlcmVyXztcclxuZnVuY3Rpb24gcmVzb2x2ZUludGVybmFsRG9tVmlldyh2aWV3UmVmKSB7XHJcbiAgICByZXR1cm4gdmlld1JlZjtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlSW50ZXJuYWxEb21GcmFnbWVudChmcmFnbWVudFJlZikge1xyXG4gICAgcmV0dXJuIGZyYWdtZW50UmVmLm5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIG1vdmVOb2Rlc0FmdGVyU2libGluZyhzaWJsaW5nLCBub2Rlcykge1xyXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgbGFuZ18xLmlzUHJlc2VudChkb21fYWRhcHRlcl8xLkRPTS5wYXJlbnRFbGVtZW50KHNpYmxpbmcpKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uaW5zZXJ0QmVmb3JlKHNpYmxpbmcsIG5vZGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uaW5zZXJ0QmVmb3JlKG5vZGVzWzBdLCBzaWJsaW5nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtb3ZlQ2hpbGROb2Rlcyhzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgdmFyIGN1cnJDaGlsZCA9IGRvbV9hZGFwdGVyXzEuRE9NLmZpcnN0Q2hpbGQoc291cmNlKTtcclxuICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KGN1cnJDaGlsZCkpIHtcclxuICAgICAgICB2YXIgbmV4dENoaWxkID0gZG9tX2FkYXB0ZXJfMS5ET00ubmV4dFNpYmxpbmcoY3VyckNoaWxkKTtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hcHBlbmRDaGlsZCh0YXJnZXQsIGN1cnJDaGlsZCk7XHJcbiAgICAgICAgY3VyckNoaWxkID0gbmV4dENoaWxkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlY29yYXRlUHJldmVudERlZmF1bHQoZXZlbnRIYW5kbGVyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGFsbG93RGVmYXVsdEJlaGF2aW9yID0gZXZlbnRIYW5kbGVyKGV2ZW50KTtcclxuICAgICAgICBpZiAoIWFsbG93RGVmYXVsdEJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSBwcmV2ZW50RGVmYXVsdCBpbnRvIGV2ZW50IHBsdWdpbnMuLi5cclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ucHJldmVudERlZmF1bHQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tX3JlbmRlcmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgdGhlIG1haW4gcmVuZGVyaW5nIGNvbnRleHQuIEluIGEgYnJvd3NlciB0aGlzIGlzIHRoZSBET00gRG9jdW1lbnQuXHJcbiAqXHJcbiAqIE5vdGU6IERvY3VtZW50IG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gdGhlIEFwcGxpY2F0aW9uIENvbnRleHQgd2hlbiBBcHBsaWNhdGlvbiBhbmQgUmVuZGVyaW5nXHJcbiAqIENvbnRleHRzIGFyZSBub3QgdGhlIHNhbWUgKGUuZy4gd2hlbiBydW5uaW5nIHRoZSBhcHBsaWNhdGlvbiBpbnRvIGEgV2ViIFdvcmtlcikuXHJcbiAqL1xyXG5leHBvcnRzLkRPQ1VNRU5UID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oJ0RvY3VtZW50VG9rZW4nKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV90b2tlbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3pvbmUvbmdfem9uZScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbmV4cG9ydHMuRVZFTlRfTUFOQUdFUl9QTFVHSU5TID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJFdmVudE1hbmFnZXJQbHVnaW5zXCIpKTtcclxudmFyIEV2ZW50TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIocGx1Z2lucywgX3pvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcclxuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubWFuYWdlciA9IF90aGlzOyB9KTtcclxuICAgICAgICB0aGlzLl9wbHVnaW5zID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJldmVyc2VkKHBsdWdpbnMpO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcGx1Z2luLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5fZmluZFBsdWdpbkZvcihldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBwbHVnaW4uYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fem9uZTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2ZpbmRQbHVnaW5Gb3IgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tpXTtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0cyhldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vIGV2ZW50IG1hbmFnZXIgcGx1Z2luIGZvdW5kIGZvciBldmVudCBcIiArIGV2ZW50TmFtZSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLkluamVjdChleHBvcnRzLkVWRU5UX01BTkFHRVJfUExVR0lOUykpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtBcnJheSwgbmdfem9uZV8xLk5nWm9uZV0pXHJcbiAgICBdLCBFdmVudE1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcclxufSkoKTtcclxuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XHJcbnZhciBFdmVudE1hbmFnZXJQbHVnaW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyUGx1Z2luKCkge1xyXG4gICAgfVxyXG4gICAgLy8gVGhhdCBpcyBlcXVpdmFsZW50IHRvIGhhdmluZyBzdXBwb3J0aW5nICRldmVudC50YXJnZXRcclxuICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aHJvdyBcIm5vdCBpbXBsZW1lbnRlZFwiO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aHJvdyBcIm5vdCBpbXBsZW1lbnRlZFwiO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudE1hbmFnZXJQbHVnaW47XHJcbn0pKCk7XHJcbmV4cG9ydHMuRXZlbnRNYW5hZ2VyUGx1Z2luID0gRXZlbnRNYW5hZ2VyUGx1Z2luO1xyXG52YXIgRG9tRXZlbnRzUGx1Z2luID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEb21FdmVudHNQbHVnaW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEb21FdmVudHNQbHVnaW4oKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIHBsdWdpbiBzaG91bGQgY29tZSBsYXN0IGluIHRoZSBsaXN0IG9mIHBsdWdpbnMsIGJlY2F1c2UgaXQgYWNjZXB0cyBhbGxcclxuICAgIC8vIGV2ZW50cy5cclxuICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcclxuICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHpvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZXIoZXZlbnQpOyB9KTsgfTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgZG9tX2FkYXB0ZXJfMS5ET00ub24oZWxlbWVudCwgZXZlbnROYW1lLCBvdXRzaWRlSGFuZGxlcik7IH0pO1xyXG4gICAgfTtcclxuICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0R2xvYmFsRXZlbnRUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XHJcbiAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiB6b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7IH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00ub25BbmRDYW5jZWwoZWxlbWVudCwgZXZlbnROYW1lLCBvdXRzaWRlSGFuZGxlcik7IH0pO1xyXG4gICAgfTtcclxuICAgIERvbUV2ZW50c1BsdWdpbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRG9tRXZlbnRzUGx1Z2luKTtcclxuICAgIHJldHVybiBEb21FdmVudHNQbHVnaW47XHJcbn0pKEV2ZW50TWFuYWdlclBsdWdpbik7XHJcbmV4cG9ydHMuRG9tRXZlbnRzUGx1Z2luID0gRG9tRXZlbnRzUGx1Z2luO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9tYW5hZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9ldmVudF9tYW5hZ2VyJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgX2V2ZW50TmFtZXMgPSB7XHJcbiAgICAvLyBwYW5cclxuICAgICdwYW4nOiB0cnVlLFxyXG4gICAgJ3BhbnN0YXJ0JzogdHJ1ZSxcclxuICAgICdwYW5tb3ZlJzogdHJ1ZSxcclxuICAgICdwYW5lbmQnOiB0cnVlLFxyXG4gICAgJ3BhbmNhbmNlbCc6IHRydWUsXHJcbiAgICAncGFubGVmdCc6IHRydWUsXHJcbiAgICAncGFucmlnaHQnOiB0cnVlLFxyXG4gICAgJ3BhbnVwJzogdHJ1ZSxcclxuICAgICdwYW5kb3duJzogdHJ1ZSxcclxuICAgIC8vIHBpbmNoXHJcbiAgICAncGluY2gnOiB0cnVlLFxyXG4gICAgJ3BpbmNoc3RhcnQnOiB0cnVlLFxyXG4gICAgJ3BpbmNobW92ZSc6IHRydWUsXHJcbiAgICAncGluY2hlbmQnOiB0cnVlLFxyXG4gICAgJ3BpbmNoY2FuY2VsJzogdHJ1ZSxcclxuICAgICdwaW5jaGluJzogdHJ1ZSxcclxuICAgICdwaW5jaG91dCc6IHRydWUsXHJcbiAgICAvLyBwcmVzc1xyXG4gICAgJ3ByZXNzJzogdHJ1ZSxcclxuICAgICdwcmVzc3VwJzogdHJ1ZSxcclxuICAgIC8vIHJvdGF0ZVxyXG4gICAgJ3JvdGF0ZSc6IHRydWUsXHJcbiAgICAncm90YXRlc3RhcnQnOiB0cnVlLFxyXG4gICAgJ3JvdGF0ZW1vdmUnOiB0cnVlLFxyXG4gICAgJ3JvdGF0ZWVuZCc6IHRydWUsXHJcbiAgICAncm90YXRlY2FuY2VsJzogdHJ1ZSxcclxuICAgIC8vIHN3aXBlXHJcbiAgICAnc3dpcGUnOiB0cnVlLFxyXG4gICAgJ3N3aXBlbGVmdCc6IHRydWUsXHJcbiAgICAnc3dpcGVyaWdodCc6IHRydWUsXHJcbiAgICAnc3dpcGV1cCc6IHRydWUsXHJcbiAgICAnc3dpcGVkb3duJzogdHJ1ZSxcclxuICAgIC8vIHRhcFxyXG4gICAgJ3RhcCc6IHRydWUsXHJcbn07XHJcbnZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbigpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMoX2V2ZW50TmFtZXMsIGV2ZW50TmFtZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uO1xyXG59KShldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyUGx1Z2luKTtcclxuZXhwb3J0cy5IYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiA9IEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW1tZXJfY29tbW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgaGFtbWVyX2NvbW1vbl8xID0gcmVxdWlyZSgnLi9oYW1tZXJfY29tbW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgSGFtbWVyR2VzdHVyZXNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEhhbW1lckdlc3R1cmVzUGx1Z2luLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXNQbHVnaW4oKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFfc3VwZXIucHJvdG90eXBlLnN1cHBvcnRzLmNhbGwodGhpcywgZXZlbnROYW1lKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICghbGFuZ18xLmlzUHJlc2VudCh3aW5kb3dbJ0hhbW1lciddKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJIYW1tZXIuanMgaXMgbm90IGxvYWRlZCwgY2FuIG5vdCBiaW5kIFwiICsgZXZlbnROYW1lICsgXCIgZXZlbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcclxuICAgICAgICAgICAgdmFyIG1jID0gbmV3IEhhbW1lcihlbGVtZW50KTtcclxuICAgICAgICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbWMuZ2V0KCdyb3RhdGUnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIG1jLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50T2JqKSB7IHpvbmUucnVuKGZ1bmN0aW9uICgpIHsgaGFuZGxlcihldmVudE9iaik7IH0pOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgSGFtbWVyR2VzdHVyZXNQbHVnaW4pO1xyXG4gICAgcmV0dXJuIEhhbW1lckdlc3R1cmVzUGx1Z2luO1xyXG59KShoYW1tZXJfY29tbW9uXzEuSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24pO1xyXG5leHBvcnRzLkhhbW1lckdlc3R1cmVzUGx1Z2luID0gSGFtbWVyR2VzdHVyZXNQbHVnaW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbW1lcl9nZXN0dXJlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9ldmVudF9tYW5hZ2VyJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIG1vZGlmaWVyS2V5cyA9IFsnYWx0JywgJ2NvbnRyb2wnLCAnbWV0YScsICdzaGlmdCddO1xyXG52YXIgbW9kaWZpZXJLZXlHZXR0ZXJzID0ge1xyXG4gICAgJ2FsdCc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuYWx0S2V5OyB9LFxyXG4gICAgJ2NvbnRyb2wnOiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmN0cmxLZXk7IH0sXHJcbiAgICAnbWV0YSc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubWV0YUtleTsgfSxcclxuICAgICdzaGlmdCc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuc2hpZnRLZXk7IH1cclxufTtcclxudmFyIEtleUV2ZW50c1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoS2V5RXZlbnRzUGx1Z2luLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gS2V5RXZlbnRzUGx1Z2luKCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgS2V5RXZlbnRzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUoZXZlbnROYW1lKSk7XHJcbiAgICB9O1xyXG4gICAgS2V5RXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBwYXJzZWRFdmVudCA9IEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpO1xyXG4gICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrKGVsZW1lbnQsIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChwYXJzZWRFdmVudCwgJ2Z1bGxLZXknKSwgaGFuZGxlciwgdGhpcy5tYW5hZ2VyLmdldFpvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLm9uKGVsZW1lbnQsIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChwYXJzZWRFdmVudCwgJ2RvbUV2ZW50TmFtZScpLCBvdXRzaWRlSGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgdmFyIGRvbUV2ZW50TmFtZSA9IHBhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKChwYXJ0cy5sZW5ndGggPT09IDApIHx8XHJcbiAgICAgICAgICAgICEobGFuZ18xLlN0cmluZ1dyYXBwZXIuZXF1YWxzKGRvbUV2ZW50TmFtZSwgJ2tleWRvd24nKSB8fFxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZXF1YWxzKGRvbUV2ZW50TmFtZSwgJ2tleXVwJykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5ID0gS2V5RXZlbnRzUGx1Z2luLl9ub3JtYWxpemVLZXkocGFydHMucG9wKCkpO1xyXG4gICAgICAgIHZhciBmdWxsS2V5ID0gJyc7XHJcbiAgICAgICAgbW9kaWZpZXJLZXlzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKHBhcnRzLCBtb2RpZmllck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHBhcnRzLCBtb2RpZmllck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBmdWxsS2V5ICs9IGtleTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9IDAgfHwga2V5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgbnVsbCBpbnN0ZWFkIG9mIHRocm93aW5nIHRvIGxldCBhbm90aGVyIHBsdWdpbiBwcm9jZXNzIHRoZSBldmVudFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldChyZXN1bHQsICdkb21FdmVudE5hbWUnLCBkb21FdmVudE5hbWUpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldChyZXN1bHQsICdmdWxsS2V5JywgZnVsbEtleSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4uZ2V0RXZlbnRGdWxsS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGZ1bGxLZXkgPSAnJztcclxuICAgICAgICB2YXIga2V5ID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0RXZlbnRLZXkoZXZlbnQpO1xyXG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoa2V5LCAnICcpKSB7XHJcbiAgICAgICAgICAgIGtleSA9ICdzcGFjZSc7IC8vIGZvciByZWFkYWJpbGl0eVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoa2V5LCAnLicpKSB7XHJcbiAgICAgICAgICAgIGtleSA9ICdkb3QnOyAvLyBiZWNhdXNlICcuJyBpcyB1c2VkIGFzIGEgc2VwYXJhdG9yIGluIGV2ZW50IG5hbWVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGlmaWVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyTmFtZSAhPSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllckdldHRlciA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChtb2RpZmllcktleUdldHRlcnMsIG1vZGlmaWVyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJHZXR0ZXIoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBmdWxsS2V5ICs9IGtleTtcclxuICAgICAgICByZXR1cm4gZnVsbEtleTtcclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChlbGVtZW50LCBmdWxsS2V5LCBoYW5kbGVyLCB6b25lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuZXF1YWxzKEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkoZXZlbnQpLCBmdWxsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleSA9IGZ1bmN0aW9uIChrZXlOYW1lKSB7XHJcbiAgICAgICAgLy8gVE9ETzogc3dpdGNoIHRvIGEgU3RyaW5nTWFwIGlmIHRoZSBtYXBwaW5nIGdyb3dzIHRvbyBtdWNoXHJcbiAgICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VzYyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VzY2FwZSc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5TmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS2V5RXZlbnRzUGx1Z2luID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBLZXlFdmVudHNQbHVnaW4pO1xyXG4gICAgcmV0dXJuIEtleUV2ZW50c1BsdWdpbjtcclxufSkoZXZlbnRfbWFuYWdlcl8xLkV2ZW50TWFuYWdlclBsdWdpbik7XHJcbmV4cG9ydHMuS2V5RXZlbnRzUGx1Z2luID0gS2V5RXZlbnRzUGx1Z2luO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlfZXZlbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkb21fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2RvbV90b2tlbnMnKTtcclxudmFyIFNoYXJlZFN0eWxlc0hvc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2hhcmVkU3R5bGVzSG9zdCgpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fc3R5bGVzID0gW107XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3N0eWxlc1NldCA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmFkZFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcclxuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMoX3RoaXMuX3N0eWxlc1NldCwgc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVzU2V0LmFkZChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVzLnB1c2goc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vblN0eWxlc0FkZGVkKGFkZGl0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHsgfTtcclxuICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmdldEFsbFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfTtcclxuICAgIFNoYXJlZFN0eWxlc0hvc3QgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFNoYXJlZFN0eWxlc0hvc3QpO1xyXG4gICAgcmV0dXJuIFNoYXJlZFN0eWxlc0hvc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2hhcmVkU3R5bGVzSG9zdCA9IFNoYXJlZFN0eWxlc0hvc3Q7XHJcbnZhciBEb21TaGFyZWRTdHlsZXNIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEb21TaGFyZWRTdHlsZXNIb3N0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRG9tU2hhcmVkU3R5bGVzSG9zdChkb2MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9ob3N0Tm9kZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5faG9zdE5vZGVzLmFkZChkb2MuaGVhZCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5fYWRkU3R5bGVzVG9Ib3N0ID0gZnVuY3Rpb24gKHN0eWxlcywgaG9zdCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tpXTtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uYXBwZW5kQ2hpbGQoaG9zdCwgZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlU3R5bGVFbGVtZW50KHN0eWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmFkZEhvc3QgPSBmdW5jdGlvbiAoaG9zdE5vZGUpIHtcclxuICAgICAgICB0aGlzLl9hZGRTdHlsZXNUb0hvc3QodGhpcy5fc3R5bGVzLCBob3N0Tm9kZSk7XHJcbiAgICAgICAgdGhpcy5faG9zdE5vZGVzLmFkZChob3N0Tm9kZSk7XHJcbiAgICB9O1xyXG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUucmVtb3ZlSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkgeyBjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5kZWxldGUodGhpcy5faG9zdE5vZGVzLCBob3N0Tm9kZSk7IH07XHJcbiAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gZnVuY3Rpb24gKGFkZGl0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faG9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGhvc3ROb2RlKSB7IF90aGlzLl9hZGRTdHlsZXNUb0hvc3QoYWRkaXRpb25zLCBob3N0Tm9kZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIERvbVNoYXJlZFN0eWxlc0hvc3QgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDAsIGRpXzEuSW5qZWN0KGRvbV90b2tlbnNfMS5ET0NVTUVOVCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgRG9tU2hhcmVkU3R5bGVzSG9zdCk7XHJcbiAgICByZXR1cm4gRG9tU2hhcmVkU3R5bGVzSG9zdDtcclxufSkoU2hhcmVkU3R5bGVzSG9zdCk7XHJcbmV4cG9ydHMuRG9tU2hhcmVkU3R5bGVzSG9zdCA9IERvbVNoYXJlZFN0eWxlc0hvc3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZF9zdHlsZXNfaG9zdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBDQU1FTF9DQVNFX1JFR0VYUCA9IC8oW0EtWl0pL2c7XHJcbnZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0oW2Etel0pL2c7XHJcbmZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBDQU1FTF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5jYW1lbENhc2VUb0Rhc2hDYXNlID0gY2FtZWxDYXNlVG9EYXNoQ2FzZTtcclxuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG59XHJcbmV4cG9ydHMuZGFzaENhc2VUb0NhbWVsQ2FzZSA9IGRhc2hDYXNlVG9DYW1lbENhc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhZHZhbmNlZCBzdXBwb3J0IGZvciBleHRlbmRpbmcgZG9tIHN0cmF0ZWd5LlxyXG4gKi9cclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZG9tL3NoYXJlZF9zdHlsZXNfaG9zdCcpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9kb20vZG9tX3JlbmRlcmVyJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RvbS9kb21fdG9rZW5zJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2FwaScpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXBpXzEgPSByZXF1aXJlKCcuL2FwaScpO1xyXG52YXIgRGVmYXVsdFByb3RvVmlld1JlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGVmYXVsdFByb3RvVmlld1JlZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRQcm90b1ZpZXdSZWYoY21kcykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY21kcyA9IGNtZHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGVmYXVsdFByb3RvVmlld1JlZjtcclxufSkoYXBpXzEuUmVuZGVyUHJvdG9WaWV3UmVmKTtcclxuZXhwb3J0cy5EZWZhdWx0UHJvdG9WaWV3UmVmID0gRGVmYXVsdFByb3RvVmlld1JlZjtcclxudmFyIERlZmF1bHRSZW5kZXJGcmFnbWVudFJlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmKG5vZGVzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERlZmF1bHRSZW5kZXJGcmFnbWVudFJlZjtcclxufSkoYXBpXzEuUmVuZGVyRnJhZ21lbnRSZWYpO1xyXG5leHBvcnRzLkRlZmF1bHRSZW5kZXJGcmFnbWVudFJlZiA9IERlZmF1bHRSZW5kZXJGcmFnbWVudFJlZjtcclxudmFyIERlZmF1bHRSZW5kZXJWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWZhdWx0UmVuZGVyVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRSZW5kZXJWaWV3KGZyYWdtZW50cywgYm91bmRUZXh0Tm9kZXMsIGJvdW5kRWxlbWVudHMsIG5hdGl2ZVNoYWRvd1Jvb3RzLCBnbG9iYWxFdmVudEFkZGVycywgcm9vdENvbnRlbnRJbnNlcnRpb25Qb2ludHMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcclxuICAgICAgICB0aGlzLmJvdW5kVGV4dE5vZGVzID0gYm91bmRUZXh0Tm9kZXM7XHJcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRzID0gYm91bmRFbGVtZW50cztcclxuICAgICAgICB0aGlzLm5hdGl2ZVNoYWRvd1Jvb3RzID0gbmF0aXZlU2hhZG93Um9vdHM7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudEFkZGVycyA9IGdsb2JhbEV2ZW50QWRkZXJzO1xyXG4gICAgICAgIHRoaXMucm9vdENvbnRlbnRJbnNlcnRpb25Qb2ludHMgPSByb290Q29udGVudEluc2VydGlvblBvaW50cztcclxuICAgICAgICB0aGlzLmh5ZHJhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRSZW1vdmVycyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBEZWZhdWx0UmVuZGVyVmlldy5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oeWRyYXRlZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdUaGUgdmlldyBpcyBhbHJlYWR5IGh5ZHJhdGVkLicpO1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRSZW1vdmVycyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodGhpcy5nbG9iYWxFdmVudEFkZGVycy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxFdmVudEFkZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbEV2ZW50UmVtb3ZlcnNbaV0gPSB0aGlzLmdsb2JhbEV2ZW50QWRkZXJzW2ldKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRSZW5kZXJWaWV3LnByb3RvdHlwZS5kZWh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmh5ZHJhdGVkKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1RoZSB2aWV3IGlzIGFscmVhZHkgZGVoeWRyYXRlZC4nKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2xvYmFsRXZlbnRSZW1vdmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbEV2ZW50UmVtb3ZlcnNbaV0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudFJlbW92ZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmh5ZHJhdGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdFJlbmRlclZpZXcucHJvdG90eXBlLnNldEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7IHRoaXMuZXZlbnREaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjsgfTtcclxuICAgIERlZmF1bHRSZW5kZXJWaWV3LnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckV2ZW50ID0gZnVuY3Rpb24gKGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGFsbG93RGVmYXVsdEJlaGF2aW9yID0gdHJ1ZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmV2ZW50RGlzcGF0Y2hlcikpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FscyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgICAgIGxvY2Fscy5zZXQoJyRldmVudCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgYWxsb3dEZWZhdWx0QmVoYXZpb3IgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hSZW5kZXJFdmVudChib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBsb2NhbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsb3dEZWZhdWx0QmVoYXZpb3I7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlZmF1bHRSZW5kZXJWaWV3O1xyXG59KShhcGlfMS5SZW5kZXJWaWV3UmVmKTtcclxuZXhwb3J0cy5EZWZhdWx0UmVuZGVyVmlldyA9IERlZmF1bHRSZW5kZXJWaWV3O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJy4vdmlldycpO1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJWaWV3KGZyYWdtZW50Q21kcywgaW5wbGFjZUVsZW1lbnQsIG5vZGVGYWN0b3J5KSB7XHJcbiAgICB2YXIgdmlldztcclxuICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gdmlldy5kaXNwYXRjaFJlbmRlckV2ZW50KGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGV2ZW50KTtcclxuICAgIH07XHJcbiAgICB2YXIgY29udGV4dCA9IG5ldyBCdWlsZENvbnRleHQoZXZlbnREaXNwYXRjaGVyLCBub2RlRmFjdG9yeSwgaW5wbGFjZUVsZW1lbnQpO1xyXG4gICAgY29udGV4dC5idWlsZChmcmFnbWVudENtZHMpO1xyXG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0LmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZyYWdtZW50cy5wdXNoKG5ldyB2aWV3XzEuRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmKGNvbnRleHQuZnJhZ21lbnRzW2ldKSk7XHJcbiAgICB9XHJcbiAgICB2aWV3ID0gbmV3IHZpZXdfMS5EZWZhdWx0UmVuZGVyVmlldyhmcmFnbWVudHMsIGNvbnRleHQuYm91bmRUZXh0Tm9kZXMsIGNvbnRleHQuYm91bmRFbGVtZW50cywgY29udGV4dC5uYXRpdmVTaGFkb3dSb290cywgY29udGV4dC5nbG9iYWxFdmVudEFkZGVycywgY29udGV4dC5yb290Q29udGVudEluc2VydGlvblBvaW50cyk7XHJcbiAgICByZXR1cm4gdmlldztcclxufVxyXG5leHBvcnRzLmNyZWF0ZVJlbmRlclZpZXcgPSBjcmVhdGVSZW5kZXJWaWV3O1xyXG52YXIgQnVpbGRDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1aWxkQ29udGV4dChfZXZlbnREaXNwYXRjaGVyLCBmYWN0b3J5LCBfaW5wbGFjZUVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLl9ldmVudERpc3BhdGNoZXIgPSBfZXZlbnREaXNwYXRjaGVyO1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5faW5wbGFjZUVsZW1lbnQgPSBfaW5wbGFjZUVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fYnVpbGRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmdsb2JhbEV2ZW50QWRkZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5ib3VuZFRleHROb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmF0aXZlU2hhZG93Um9vdHMgPSBbXTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMucm9vdENvbnRlbnRJbnNlcnRpb25Qb2ludHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmlzSG9zdCA9IGxhbmdfMS5pc1ByZXNlbnQoKF9pbnBsYWNlRWxlbWVudCkpO1xyXG4gICAgfVxyXG4gICAgQnVpbGRDb250ZXh0LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChmcmFnbWVudENtZHMpIHtcclxuICAgICAgICB0aGlzLmVucXVldWVGcmFnbWVudEJ1aWxkZXIobnVsbCwgZnJhZ21lbnRDbWRzKTtcclxuICAgICAgICB0aGlzLl9idWlsZCh0aGlzLl9idWlsZGVyc1swXSk7XHJcbiAgICB9O1xyXG4gICAgQnVpbGRDb250ZXh0LnByb3RvdHlwZS5fYnVpbGQgPSBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgIHRoaXMuX2J1aWxkZXJzID0gW107XHJcbiAgICAgICAgYnVpbGRlci5idWlsZCh0aGlzKTtcclxuICAgICAgICB2YXIgZW5xdWV1ZWRCdWlsZGVycyA9IHRoaXMuX2J1aWxkZXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5xdWV1ZWRCdWlsZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9idWlsZChlbnF1ZXVlZEJ1aWxkZXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnVpbGRDb250ZXh0LnByb3RvdHlwZS5lbnF1ZXVlQ29tcG9uZW50QnVpbGRlciA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudENvdW50Kys7XHJcbiAgICAgICAgdGhpcy5fYnVpbGRlcnMucHVzaChuZXcgUmVuZGVyVmlld0J1aWxkZXIoY29tcG9uZW50LCBudWxsLCB0aGlzLmZhY3RvcnkucmVzb2x2ZUNvbXBvbmVudFRlbXBsYXRlKGNvbXBvbmVudC5jbWQudGVtcGxhdGVJZCkpKTtcclxuICAgIH07XHJcbiAgICBCdWlsZENvbnRleHQucHJvdG90eXBlLmVucXVldWVGcmFnbWVudEJ1aWxkZXIgPSBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBjb21tYW5kcykge1xyXG4gICAgICAgIHZhciByb290Tm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cy5wdXNoKHJvb3ROb2Rlcyk7XHJcbiAgICAgICAgdGhpcy5fYnVpbGRlcnMucHVzaChuZXcgUmVuZGVyVmlld0J1aWxkZXIocGFyZW50Q29tcG9uZW50LCByb290Tm9kZXMsIGNvbW1hbmRzKSk7XHJcbiAgICB9O1xyXG4gICAgQnVpbGRDb250ZXh0LnByb3RvdHlwZS5jb25zdW1lSW5wbGFjZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2lucGxhY2VFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuX2lucGxhY2VFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEJ1aWxkQ29udGV4dC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChib3VuZEVsZW1lbnRJbmRleCwgdGFyZ2V0LCBldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gY3JlYXRlRXZlbnRIYW5kbGVyKGJvdW5kRWxlbWVudEluZGV4LCB0YXJnZXQgKyBcIjpcIiArIGV2ZW50TmFtZSwgdGhpcy5fZXZlbnREaXNwYXRjaGVyKTtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxFdmVudEFkZGVycy5wdXNoKGNyZWF0ZUdsb2JhbEV2ZW50QWRkZXIodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIHRoaXMuZmFjdG9yeSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBjcmVhdGVFdmVudEhhbmRsZXIoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgdGhpcy5fZXZlbnREaXNwYXRjaGVyKTtcclxuICAgICAgICAgICAgdGhpcy5mYWN0b3J5Lm9uKHRoaXMuYm91bmRFbGVtZW50c1tib3VuZEVsZW1lbnRJbmRleF0sIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCdWlsZENvbnRleHQ7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SGFuZGxlcihib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBldmVudERpc3BhdGNoZXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoJGV2ZW50KSB7IHJldHVybiBldmVudERpc3BhdGNoZXIoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgJGV2ZW50KTsgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxFdmVudEFkZGVyKHRhcmdldCwgZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIG5vZGVGYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZUZhY3RvcnkuZ2xvYmFsT24odGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7IH07XHJcbn1cclxudmFyIFJlbmRlclZpZXdCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclZpZXdCdWlsZGVyKHBhcmVudENvbXBvbmVudCwgZnJhZ21lbnRSb290Tm9kZXMsIGNvbW1hbmRzKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDb21wb25lbnQgPSBwYXJlbnRDb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFJvb3ROb2RlcyA9IGZyYWdtZW50Um9vdE5vZGVzO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcclxuICAgICAgICB2YXIgcm9vdE5vZGVzUGFyZW50ID0gbGFuZ18xLmlzUHJlc2VudChmcmFnbWVudFJvb3ROb2RlcykgPyBudWxsIDogcGFyZW50Q29tcG9uZW50LnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRTdGFjayA9IFtyb290Tm9kZXNQYXJlbnRdO1xyXG4gICAgfVxyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1tpXS52aXNpdCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRTdGFja1t0aGlzLnBhcmVudFN0YWNrLmxlbmd0aCAtIDFdOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSBjb250ZXh0LmZhY3RvcnkuY3JlYXRlVGV4dChjbWQudmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX2FkZENoaWxkKHRleHQsIGNtZC5uZ0NvbnRlbnRJbmRleCwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGNtZC5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYm91bmRUZXh0Tm9kZXMucHVzaCh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucGFyZW50Q29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDb21wb25lbnQuaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBjb250ZXh0LmZhY3RvcnkuY3JlYXRlUm9vdENvbnRlbnRJbnNlcnRpb25Qb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5mYWN0b3J5LmFwcGVuZENoaWxkKHRoaXMucGFyZW50LnNoYWRvd1Jvb3QsIGluc2VydGlvblBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmFjdG9yeS5hcHBlbmRDaGlsZCh0aGlzLnBhcmVudCwgaW5zZXJ0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yb290Q29udGVudEluc2VydGlvblBvaW50cy5wdXNoKGluc2VydGlvblBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWROb2RlcyA9IHRoaXMucGFyZW50Q29tcG9uZW50LnByb2plY3QoY21kLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvamVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHByb2plY3RlZE5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKG5vZGUsIGNtZC5uZ0NvbnRlbnRJbmRleCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50U3RhY2sucHVzaCh0aGlzLl9iZWdpbkVsZW1lbnQoY21kLCBjb250ZXh0KSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW5kRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fZW5kRWxlbWVudCgpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEJlZ2luQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2JlZ2luRWxlbWVudChjbWQsIGNvbnRleHQpO1xyXG4gICAgICAgIHZhciByb290ID0gZWw7XHJcbiAgICAgICAgaWYgKGNtZC5uYXRpdmVTaGFkb3cpIHtcclxuICAgICAgICAgICAgcm9vdCA9IGNvbnRleHQuZmFjdG9yeS5jcmVhdGVTaGFkb3dSb290KGVsLCBjbWQudGVtcGxhdGVJZCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubmF0aXZlU2hhZG93Um9vdHMucHVzaChyb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzUm9vdCA9IGNvbnRleHQuY29tcG9uZW50Q291bnQgPT09IDAgJiYgY29udGV4dC5pc0hvc3Q7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoZWwsIHJvb3QsIGNtZCwgaXNSb290KTtcclxuICAgICAgICBjb250ZXh0LmVucXVldWVDb21wb25lbnRCdWlsZGVyKGNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRTdGFjay5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9lbmRFbGVtZW50KCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZWwgPSBjb250ZXh0LmZhY3RvcnkuY3JlYXRlVGVtcGxhdGVBbmNob3IoY21kLmF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgICAgICB0aGlzLl9hZGRDaGlsZChlbCwgY21kLm5nQ29udGVudEluZGV4LCBjb250ZXh0KTtcclxuICAgICAgICBjb250ZXh0LmJvdW5kRWxlbWVudHMucHVzaChlbCk7XHJcbiAgICAgICAgaWYgKGNtZC5pc01lcmdlZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmVucXVldWVGcmFnbWVudEJ1aWxkZXIodGhpcy5wYXJlbnRDb21wb25lbnQsIGNtZC5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZS5fYmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBlbCA9IGNvbnRleHQuY29uc3VtZUlucGxhY2VFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWwpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmFjdG9yeS5tZXJnZUVsZW1lbnQoZWwsIGNtZC5hdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRSb290Tm9kZXMucHVzaChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IGNvbnRleHQuZmFjdG9yeS5jcmVhdGVFbGVtZW50KGNtZC5uYW1lLCBjbWQuYXR0ck5hbWVBbmRWYWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChlbCwgY21kLm5nQ29udGVudEluZGV4LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNtZC5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IGNvbnRleHQuYm91bmRFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYm91bmRFbGVtZW50cy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbWQuZXZlbnRUYXJnZXRBbmROYW1lcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNtZC5ldmVudFRhcmdldEFuZE5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGNtZC5ldmVudFRhcmdldEFuZE5hbWVzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcihib3VuZEVsZW1lbnRJbmRleCwgdGFyZ2V0LCBldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUuX2VuZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucGFyZW50U3RhY2sucG9wKCk7IH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUuX2FkZENoaWxkID0gZnVuY3Rpb24gKG5vZGUsIG5nQ29udGVudEluZGV4LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmFkZENvbnRlbnROb2RlKG5nQ29udGVudEluZGV4LCBub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmFjdG9yeS5hcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50Um9vdE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSZW5kZXJWaWV3QnVpbGRlcjtcclxufSkoKTtcclxudmFyIENvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnQoaG9zdEVsZW1lbnQsIHNoYWRvd1Jvb3QsIGNtZCwgaXNSb290KSB7XHJcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgdGhpcy5jbWQgPSBjbWQ7XHJcbiAgICAgICAgdGhpcy5pc1Jvb3QgPSBpc1Jvb3Q7XHJcbiAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4ID0gW107XHJcbiAgICB9XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFkZENvbnRlbnROb2RlID0gZnVuY3Rpb24gKG5nQ29udGVudEluZGV4LCBub2RlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG5nQ29udGVudEluZGV4KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbWQubmF0aXZlU2hhZG93KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZhY3RvcnkuYXBwZW5kQ2hpbGQodGhpcy5ob3N0RWxlbWVudCwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXgubGVuZ3RoIDw9IG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXgucHVzaChbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W25nQ29udGVudEluZGV4XS5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAobmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbmdDb250ZW50SW5kZXggPCB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXgubGVuZ3RoID9cclxuICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W25nQ29udGVudEluZGV4XSA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wb25lbnQ7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGFkZEFsbChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0YXJnZXQucHVzaChzb3VyY2VbaV0pO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gUHVibGljIEFQSSBmb3IgU2VydmljZXNcclxudmFyIGFwcF9yb290X3VybF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYXBwX3Jvb3RfdXJsJyk7XHJcbmV4cG9ydHMuQXBwUm9vdFVybCA9IGFwcF9yb290X3VybF8xLkFwcFJvb3RVcmw7XHJcbnZhciB1cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3VybF9yZXNvbHZlcicpO1xyXG5leHBvcnRzLlVybFJlc29sdmVyID0gdXJsX3Jlc29sdmVyXzEuVXJsUmVzb2x2ZXI7XHJcbnZhciB0aXRsZV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvc2VydmljZXMvdGl0bGUnKTtcclxuZXhwb3J0cy5UaXRsZSA9IHRpdGxlXzEuVGl0bGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2VzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG4vKipcclxuICogQSBzZXJ2aWNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGFuZCBzZXQgdGhlIHRpdGxlIG9mIGEgY3VycmVudCBIVE1MIGRvY3VtZW50LlxyXG4gKlxyXG4gKiBTaW5jZSBhbiBBbmd1bGFyIDIgYXBwbGljYXRpb24gY2FuJ3QgYmUgYm9vdHN0cmFwcGVkIG9uIHRoZSBlbnRpcmUgSFRNTCBkb2N1bWVudCAoYDxodG1sPmAgdGFnKVxyXG4gKiBpdCBpcyBub3QgcG9zc2libGUgdG8gYmluZCB0byB0aGUgYHRleHRgIHByb3BlcnR5IG9mIHRoZSBgSFRNTFRpdGxlRWxlbWVudGAgZWxlbWVudHNcclxuICogKHJlcHJlc2VudGluZyB0aGUgYDx0aXRsZT5gIHRhZykuIEluc3RlYWQsIHRoaXMgc2VydmljZSBjYW4gYmUgdXNlZCB0byBzZXQgYW5kIGdldCB0aGUgY3VycmVudFxyXG4gKiB0aXRsZSB2YWx1ZS5cclxuICovXHJcbnZhciBUaXRsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUaXRsZSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgVGl0bGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0VGl0bGUoKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxyXG4gICAgICogQHBhcmFtIG5ld1RpdGxlXHJcbiAgICAgKi9cclxuICAgIFRpdGxlLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uIChuZXdUaXRsZSkgeyBkb21fYWRhcHRlcl8xLkRPTS5zZXRUaXRsZShuZXdUaXRsZSk7IH07XHJcbiAgICByZXR1cm4gVGl0bGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGl0bGUgPSBUaXRsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGl0bGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciB0ZXN0YWJpbGl0eV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvdGVzdGFiaWxpdHkvdGVzdGFiaWxpdHknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBQdWJsaWNUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQdWJsaWNUZXN0YWJpbGl0eSh0ZXN0YWJpbGl0eSkge1xyXG4gICAgICAgIHRoaXMuX3Rlc3RhYmlsaXR5ID0gdGVzdGFiaWxpdHk7XHJcbiAgICB9XHJcbiAgICBQdWJsaWNUZXN0YWJpbGl0eS5wcm90b3R5cGUuaXNTdGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90ZXN0YWJpbGl0eS5pc1N0YWJsZSgpOyB9O1xyXG4gICAgUHVibGljVGVzdGFiaWxpdHkucHJvdG90eXBlLndoZW5TdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fdGVzdGFiaWxpdHkud2hlblN0YWJsZShjYWxsYmFjayk7IH07XHJcbiAgICBQdWJsaWNUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZEJpbmRpbmdzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRQcm92aWRlcnModXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKTtcclxuICAgIH07XHJcbiAgICBQdWJsaWNUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdGFiaWxpdHkuZmluZEJpbmRpbmdzKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFB1YmxpY1Rlc3RhYmlsaXR5O1xyXG59KSgpO1xyXG52YXIgQnJvd3NlckdldFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpIHtcclxuICAgIH1cclxuICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0ZXN0YWJpbGl0eV8xLnNldFRlc3RhYmlsaXR5R2V0dGVyKG5ldyBCcm93c2VyR2V0VGVzdGFiaWxpdHkoKSk7IH07XHJcbiAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgbGFuZ18xLmdsb2JhbC5nZXRBbmd1bGFyVGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgIGlmIChmaW5kSW5BbmNlc3RvcnMgPT09IHZvaWQgMCkgeyBmaW5kSW5BbmNlc3RvcnMgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0eSA9IHJlZ2lzdHJ5LmZpbmRUZXN0YWJpbGl0eUluVHJlZShlbGVtLCBmaW5kSW5BbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0ZXN0YWJpbGl0eSBmb3IgZWxlbWVudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1YmxpY1Rlc3RhYmlsaXR5KHRlc3RhYmlsaXR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxhbmdfMS5nbG9iYWwuZ2V0QWxsQW5ndWxhclRlc3RhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0aWVzID0gcmVnaXN0cnkuZ2V0QWxsVGVzdGFiaWxpdGllcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVzdGFiaWxpdGllcy5tYXAoZnVuY3Rpb24gKHRlc3RhYmlsaXR5KSB7IHJldHVybiBuZXcgUHVibGljVGVzdGFiaWxpdHkodGVzdGFiaWxpdHkpOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCcm93c2VyR2V0VGVzdGFiaWxpdHk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQnJvd3NlckdldFRlc3RhYmlsaXR5ID0gQnJvd3NlckdldFRlc3RhYmlsaXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyX3Rlc3RhYmlsaXR5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBuZ196b25lXzEgPSByZXF1aXJlKCcuLi96b25lL25nX3pvbmUnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxuLyoqXHJcbiAqIFRoZSBUZXN0YWJpbGl0eSBzZXJ2aWNlIHByb3ZpZGVzIHRlc3RpbmcgaG9va3MgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbVxyXG4gKiB0aGUgYnJvd3NlciBhbmQgYnkgc2VydmljZXMgc3VjaCBhcyBQcm90cmFjdG9yLiBFYWNoIGJvb3RzdHJhcHBlZCBBbmd1bGFyXHJcbiAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cclxuICovXHJcbnZhciBUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZXN0YWJpbGl0eShfbmdab25lKSB7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9pc0FuZ3VsYXJFdmVudFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl93YXRjaEFuZ3VsYXJFdmVudHMoX25nWm9uZSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3dhdGNoQW5ndWxhckV2ZW50cyA9IGZ1bmN0aW9uIChfbmdab25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfbmdab25lLm92ZXJyaWRlT25UdXJuU3RhcnQoZnVuY3Rpb24gKCkgeyBfdGhpcy5faXNBbmd1bGFyRXZlbnRQZW5kaW5nID0gdHJ1ZTsgfSk7XHJcbiAgICAgICAgX25nWm9uZS5vdmVycmlkZU9uRXZlbnREb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2lzQW5ndWxhckV2ZW50UGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ICs9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcclxuICAgIH07XHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZGVjcmVhc2VQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQ291bnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbigncGVuZGluZyBhc3luYyByZXF1ZXN0cyBiZWxvdyB6ZXJvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pc1N0YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudCA9PSAwICYmICF0aGlzLl9pc0FuZ3VsYXJFdmVudFBlbmRpbmc7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3J1bkNhbGxiYWNrc0lmUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuaXNTdGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vdCByZWFkeVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTY2hlZHVsZXMgdGhlIGNhbGwgYmFja3MgaW4gYSBuZXcgZnJhbWUgc28gdGhhdCBpdCBpcyBhbHdheXMgYXN5bmMuXHJcbiAgICAgICAgYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgd2hpbGUgKF90aGlzLl9jYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAoX3RoaXMuX2NhbGxiYWNrcy5wb3AoKSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS53aGVuU3RhYmxlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcclxuICAgIH07XHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZ2V0UGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDsgfTtcclxuICAgIC8vIFRoaXMgb25seSBhY2NvdW50cyBmb3Igbmdab25lLCBhbmQgbm90IHBlbmRpbmcgY291bnRzLiBVc2UgYHdoZW5TdGFibGVgIHRvXHJcbiAgICAvLyBjaGVjayBmb3Igc3RhYmlsaXR5LlxyXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmlzQW5ndWxhckV2ZW50UGVuZGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lzQW5ndWxhckV2ZW50UGVuZGluZzsgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kQmluZGluZ3MgPSBmdW5jdGlvbiAodXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcclxuICAgICAgICAvLyBUT0RPKGp1bGllbXIpOiBpbXBsZW1lbnQuXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW25nX3pvbmVfMS5OZ1pvbmVdKVxyXG4gICAgXSwgVGVzdGFiaWxpdHkpO1xyXG4gICAgcmV0dXJuIFRlc3RhYmlsaXR5O1xyXG59KSgpO1xyXG5leHBvcnRzLlRlc3RhYmlsaXR5ID0gVGVzdGFiaWxpdHk7XHJcbnZhciBUZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5UmVnaXN0cnkoKSB7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGVzdGFiaWxpdHlHZXR0ZXIuYWRkVG9XaW5kb3codGhpcyk7XHJcbiAgICB9XHJcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKHRva2VuLCB0ZXN0YWJpbGl0eSkge1xyXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucy5zZXQodG9rZW4sIHRlc3RhYmlsaXR5KTtcclxuICAgIH07XHJcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FwcGxpY2F0aW9ucyk7IH07XHJcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoZWxlbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYXBwbGljYXRpb25zLmhhcyhlbGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWZpbmRJbkFuY2VzdG9ycykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzU2hhZG93Um9vdChlbGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUoZG9tX2FkYXB0ZXJfMS5ET00uZ2V0SG9zdChlbGVtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShkb21fYWRhcHRlcl8xLkRPTS5wYXJlbnRFbGVtZW50KGVsZW0pKTtcclxuICAgIH07XHJcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBUZXN0YWJpbGl0eVJlZ2lzdHJ5KTtcclxuICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xyXG59KSgpO1xyXG5leHBvcnRzLlRlc3RhYmlsaXR5UmVnaXN0cnkgPSBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xyXG52YXIgTm9vcEdldFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vb3BHZXRUZXN0YWJpbGl0eSgpIHtcclxuICAgIH1cclxuICAgIE5vb3BHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHsgfTtcclxuICAgIE5vb3BHZXRUZXN0YWJpbGl0eSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgTm9vcEdldFRlc3RhYmlsaXR5KTtcclxuICAgIHJldHVybiBOb29wR2V0VGVzdGFiaWxpdHk7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIHNldFRlc3RhYmlsaXR5R2V0dGVyKGdldHRlcikge1xyXG4gICAgdGVzdGFiaWxpdHlHZXR0ZXIgPSBnZXR0ZXI7XHJcbn1cclxuZXhwb3J0cy5zZXRUZXN0YWJpbGl0eUdldHRlciA9IHNldFRlc3RhYmlsaXR5R2V0dGVyO1xyXG52YXIgdGVzdGFiaWxpdHlHZXR0ZXIgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgTm9vcEdldFRlc3RhYmlsaXR5KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0YWJpbGl0eS5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gUHVibGljIEFQSSBmb3IgdXRpbFxyXG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi91dGlsL2RlY29yYXRvcnMnKTtcclxuZXhwb3J0cy5DbGFzcyA9IGRlY29yYXRvcnNfMS5DbGFzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmZ1bmN0aW9uIGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcclxuICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihhbm5vdGF0aW9uKSAmJiBhbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdhbm5vdGF0aW9uJykpIHtcclxuICAgICAgICAvLyBpdCBpcyBhIGRlY29yYXRvciwgZXh0cmFjdCBhbm5vdGF0aW9uXHJcbiAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb24uYW5ub3RhdGlvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5UGFyYW1zKGZuT3JBcnJheSwga2V5KSB7XHJcbiAgICBpZiAoZm5PckFycmF5ID09PSBPYmplY3QgfHwgZm5PckFycmF5ID09PSBTdHJpbmcgfHwgZm5PckFycmF5ID09PSBGdW5jdGlvbiB8fFxyXG4gICAgICAgIGZuT3JBcnJheSA9PT0gTnVtYmVyIHx8IGZuT3JBcnJheSA9PT0gQXJyYXkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBuYXRpdmUgXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIiBhcyBjb25zdHJ1Y3RvclwiKTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihmbk9yQXJyYXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuT3JBcnJheTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZuT3JBcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gZm5PckFycmF5O1xyXG4gICAgICAgIHZhciBmbiA9IGZuT3JBcnJheVtmbk9yQXJyYXkubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCBwb3NpdGlvbiBvZiBDbGFzcyBtZXRob2QgYXJyYXkgbXVzdCBiZSBGdW5jdGlvbiBpbiBrZXkgXCIgKyBrZXkgKyBcIiB3YXMgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShmbikgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbm5vTGVuZ3RoID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAoYW5ub0xlbmd0aCAhPSBmbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGFubm90YXRpb25zIChcIiArIGFubm9MZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIgKyBmbi5sZW5ndGggKyBcIikgaW4gdGhlIGZ1bmN0aW9uOiBcIiArIGxhbmdfMS5zdHJpbmdpZnkoZm4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtc0Fubm90YXRpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtQW5ub3RhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcclxuICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbm5vdGF0aW9uLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb25bal0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNGdW5jdGlvbihhbm5vdGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1zQW5ub3RhdGlvbnMsIGZuKTtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEZ1bmN0aW9uIG9yIEFycmF5IGlzIHN1cHBvcnRlZCBpbiBDbGFzcyBkZWZpbml0aW9uIGZvciBrZXkgJ1wiICsga2V5ICsgXCInIGlzICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoZm5PckFycmF5KSArIFwiJ1wiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJvdmlkZXMgYSB3YXkgZm9yIGV4cHJlc3NpbmcgRVM2IGNsYXNzZXMgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnMgaW4gRVM1LlxyXG4gKlxyXG4gKiAjIyBCYXNpYyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgR3JlZXRlciA9IG5nLkNsYXNzKHtcclxuICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obmFtZSkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICogICB9LFxyXG4gKlxyXG4gKiAgIGdyZWV0OiBmdW5jdGlvbigpIHtcclxuICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogaXMgZXF1aXZhbGVudCB0byBFUzY6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjbGFzcyBHcmVldGVyIHtcclxuICogICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gKiAgIH1cclxuICpcclxuICogICBncmVldCgpIHtcclxuICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIG9yIGVxdWl2YWxlbnQgdG8gRVM1OlxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIEdyZWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gKiAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAqIH1cclxuICpcclxuICogR3JlZXRlci5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAqICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgTXlTZXJ2aWNlID0gbmcuQ2xhc3Moe1xyXG4gKiAgIGNvbnN0cnVjdG9yOiBbU3RyaW5nLCBbbmV3IFF1ZXJ5KCksIFF1ZXJ5TGlzdF0sIGZ1bmN0aW9uKG5hbWUsIHF1ZXJ5TGlzdCkge1xyXG4gKiAgICAgLi4uXHJcbiAqICAgfV1cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcclxuICpcclxuICogYGBgXHJcbiAqIGNsYXNzIE15U2VydmljZSB7XHJcbiAqICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBAUXVlcnkoKSBxdWVyeUxpc3Q6IFF1ZXJ5TGlzdCkge1xyXG4gKiAgICAgLi4uXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlIHdpdGggaW5oZXJpdGFuY2VcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBTaGFwZSA9IG5nLkNsYXNzKHtcclxuICogICBjb25zdHJ1Y3RvcjogKGNvbG9yKSB7XHJcbiAqICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAqICAgfVxyXG4gKiB9KTtcclxuICpcclxuICogdmFyIFNxdWFyZSA9IG5nLkNsYXNzKHtcclxuICogICBleHRlbmRzOiBTaGFwZSxcclxuICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oY29sb3IsIHNpemUpIHtcclxuICogICAgIFNoYXBlLmNhbGwodGhpcywgY29sb3IpO1xyXG4gKiAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIENsYXNzKGNsc0RlZikge1xyXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXBwbHlQYXJhbXMoY2xzRGVmLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID8gY2xzRGVmLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLCAnY29uc3RydWN0b3InKTtcclxuICAgIHZhciBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICAgIGlmIChjbHNEZWYuaGFzT3duUHJvcGVydHkoJ2V4dGVuZHMnKSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihjbHNEZWYuZXh0ZW5kcykpIHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gcHJvdG8gPVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjbHNEZWYuZXh0ZW5kcy5wcm90b3R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3MgZGVmaW5pdGlvbiAnZXh0ZW5kcycgcHJvcGVydHkgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdhczogXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGNsc0RlZi5leHRlbmRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIGNsc0RlZikge1xyXG4gICAgICAgIGlmIChrZXkgIT0gJ2V4dGVuZHMnICYmIGtleSAhPSAncHJvdG90eXBlJyAmJiBjbHNEZWYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBwcm90b1trZXldID0gYXBwbHlQYXJhbXMoY2xzRGVmW2tleV0sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMgJiYgdGhpcy5hbm5vdGF0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCB0aGlzLmFubm90YXRpb25zLCBjb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uc3RydWN0b3I7XHJcbn1cclxuZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xyXG52YXIgUmVmbGVjdCA9IGxhbmdfMS5nbG9iYWwuUmVmbGVjdDtcclxuaWYgKCEoUmVmbGVjdCAmJiBSZWZsZWN0LmdldE1ldGFkYXRhKSkge1xyXG4gICAgdGhyb3cgJ3JlZmxlY3QtbWV0YWRhdGEgc2hpbSBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGNsYXNzIGRlY29yYXRvcnMnO1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VEZWNvcmF0b3IoYW5ub3RhdGlvbkNscywgY2hhaW5Gbikge1xyXG4gICAgaWYgKGNoYWluRm4gPT09IHZvaWQgMCkgeyBjaGFpbkZuID0gbnVsbDsgfVxyXG4gICAgZnVuY3Rpb24gRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpIHtcclxuICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gbmV3IGFubm90YXRpb25DbHMob2JqT3JUeXBlKTtcclxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGFubm90YXRpb25DbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25JbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFpbkFubm90YXRpb24gPSBsYW5nXzEuaXNGdW5jdGlvbih0aGlzKSAmJiB0aGlzLmFubm90YXRpb25zIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmFubm90YXRpb25zIDogW107XHJcbiAgICAgICAgICAgIGNoYWluQW5ub3RhdGlvbi5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHZhciBUeXBlRGVjb3JhdG9yID0gZnVuY3Rpb24gVHlwZURlY29yYXRvcihjbHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgY2xzKTtcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMgfHwgW107XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGFubm90YXRpb25zLCBjbHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNscztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHlwZURlY29yYXRvci5hbm5vdGF0aW9ucyA9IGNoYWluQW5ub3RhdGlvbjtcclxuICAgICAgICAgICAgVHlwZURlY29yYXRvci5DbGFzcyA9IENsYXNzO1xyXG4gICAgICAgICAgICBpZiAoY2hhaW5GbilcclxuICAgICAgICAgICAgICAgIGNoYWluRm4oVHlwZURlY29yYXRvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBUeXBlRGVjb3JhdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbm5vdGF0aW9uQ2xzLnByb3RvdHlwZSk7XHJcbiAgICByZXR1cm4gRGVjb3JhdG9yRmFjdG9yeTtcclxufVxyXG5leHBvcnRzLm1ha2VEZWNvcmF0b3IgPSBtYWtlRGVjb3JhdG9yO1xyXG5mdW5jdGlvbiBtYWtlUGFyYW1EZWNvcmF0b3IoYW5ub3RhdGlvbkNscykge1xyXG4gICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFubm90YXRpb25JbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUoYW5ub3RhdGlvbkNscy5wcm90b3R5cGUpO1xyXG4gICAgICAgIGFubm90YXRpb25DbHMuYXBwbHkoYW5ub3RhdGlvbkluc3RhbmNlLCBhcmdzKTtcclxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGFubm90YXRpb25DbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25JbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFBhcmFtRGVjb3JhdG9yLmFubm90YXRpb24gPSBhbm5vdGF0aW9uSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJhbURlY29yYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3IoY2xzLCB1bnVzZWRLZXksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gUmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIGNscyk7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IFtdO1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBnYXBzIGlmIHNvbWUgaW4gYmV0d2VlbiBwYXJhbWV0ZXJzIGRvIG5vdCBoYXZlIGFubm90YXRpb25zLlxyXG4gICAgICAgICAgICAvLyB3ZSBwYWQgd2l0aCBudWxscy5cclxuICAgICAgICAgICAgd2hpbGUgKHBhcmFtZXRlcnMubGVuZ3RoIDw9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyYW1ldGVyc1tpbmRleF0gPSBwYXJhbWV0ZXJzW2luZGV4XSB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIGFubm90YXRpb25zRm9yUGFyYW0gPSBwYXJhbWV0ZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgYW5ub3RhdGlvbnNGb3JQYXJhbS5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbWV0ZXJzLCBjbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFBhcmFtRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFubm90YXRpb25DbHMucHJvdG90eXBlKTtcclxuICAgIHJldHVybiBQYXJhbURlY29yYXRvckZhY3Rvcnk7XHJcbn1cclxuZXhwb3J0cy5tYWtlUGFyYW1EZWNvcmF0b3IgPSBtYWtlUGFyYW1EZWNvcmF0b3I7XHJcbmZ1bmN0aW9uIG1ha2VQcm9wRGVjb3JhdG9yKGRlY29yYXRvckNscykge1xyXG4gICAgZnVuY3Rpb24gUHJvcERlY29yYXRvckZhY3RvcnkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVjb3JhdG9ySW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKGRlY29yYXRvckNscy5wcm90b3R5cGUpO1xyXG4gICAgICAgIGRlY29yYXRvckNscy5hcHBseShkZWNvcmF0b3JJbnN0YW5jZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBkZWNvcmF0b3JDbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvckluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIFByb3BEZWNvcmF0b3IodGFyZ2V0LCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWV0YSA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgICAgICBtZXRhID0gbWV0YSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0gPSBtZXRhW25hbWVdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgbWV0YVtuYW1lXS51bnNoaWZ0KGRlY29yYXRvckluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIG1ldGEsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUHJvcERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShkZWNvcmF0b3JDbHMucHJvdG90eXBlKTtcclxuICAgIHJldHVybiBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcclxufVxyXG5leHBvcnRzLm1ha2VQcm9wRGVjb3JhdG9yID0gbWFrZVByb3BEZWNvcmF0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29yYXRvcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFB1YmxpYyBBUEkgZm9yIFpvbmVcclxudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJy4vem9uZS9uZ196b25lJyk7XHJcbmV4cG9ydHMuTmdab25lID0gbmdfem9uZV8xLk5nWm9uZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9em9uZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi4vcHJvZmlsZS9wcm9maWxlJyk7XHJcbi8qKlxyXG4gKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgZm9yIGV4ZWN1dGluZyB3b3JrIGluc2lkZSBvciBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIHdoZW4gc3RhcnRpbmcgYSB3b3JrIGNvbnNpc3Rpbmcgb2ZcclxuICogb25lIG9yIG1vcmUgYXN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgcmVxdWlyZSBVSSB1cGRhdGVzIG9yIGVycm9yIGhhbmRsaW5nIHRvIGJlIGhhbmRsZWQgYnlcclxuICogQW5ndWxhci4gU3VjaCB0YXNrcyBjYW4gYmUga2lja2VkIG9mZiB2aWEge0BsaW5rICNydW5PdXRzaWRlQW5ndWxhcn0gYW5kIGlmIG5lZWRlZCwgdGhlc2UgdGFza3NcclxuICogY2FuIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSB2aWEge0BsaW5rICNydW59LlxyXG4gKlxyXG4gKiA8IS0tIFRPRE86IGFkZC9maXggbGlua3MgdG86XHJcbiAqICAgLSBkb2NzIGV4cGxhaW5pbmcgem9uZXMgYW5kIHRoZSB1c2Ugb2Ygem9uZXMgaW4gQW5ndWxhciBhbmQgY2hhbmdlLWRldGVjdGlvblxyXG4gKiAgIC0gbGluayB0byBydW5PdXRzaWRlQW5ndWxhci9ydW4gKHRocm91Z2hvdXQgdGhpcyBmaWxlISlcclxuICogICAtLT5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2xZOW04SEx5N3owNnZEb1VhU04yP3A9cHJldmlldykpXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgVmlldywgTmdJZiwgTmdab25lfSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbmctem9uZS1kZW1vJy5cclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGgyPkRlbW86IE5nWm9uZTwvaDI+XHJcbiAqXHJcbiAqICAgICA8cD5Qcm9ncmVzczoge3twcm9ncmVzc319JTwvcD5cclxuICogICAgIDxwICpuZy1pZj1cInByb2dyZXNzID49IDEwMFwiPkRvbmUgcHJvY2Vzc2luZyB7e2xhYmVsfX0gb2YgQW5ndWxhciB6b25lITwvcD5cclxuICpcclxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyB3aXRoaW4gQW5ndWxhciB6b25lPC9idXR0b24+XHJcbiAqICAgICA8YnV0dG9uIChjbGljayk9XCJwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKVwiPlByb2Nlc3Mgb3V0c2lkZSBvZiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtOZ0lmXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgTmdab25lRGVtbyB7XHJcbiAqICAgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XHJcbiAqICAgbGFiZWw6IHN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge31cclxuICpcclxuICogICAvLyBMb29wIGluc2lkZSB0aGUgQW5ndWxhciB6b25lXHJcbiAqICAgLy8gc28gdGhlIFVJIERPRVMgcmVmcmVzaCBhZnRlciBlYWNoIHNldFRpbWVvdXQgY3ljbGVcclxuICogICBwcm9jZXNzV2l0aGluQW5ndWxhclpvbmUoKSB7XHJcbiAqICAgICB0aGlzLmxhYmVsID0gJ2luc2lkZSc7XHJcbiAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICogICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4gY29uc29sZS5sb2coJ0luc2lkZSBEb25lIScpKTtcclxuICogICB9XHJcbiAqXHJcbiAqICAgLy8gTG9vcCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmVcclxuICogICAvLyBzbyB0aGUgVUkgRE9FUyBOT1QgcmVmcmVzaCBhZnRlciBlYWNoIHNldFRpbWVvdXQgY3ljbGVcclxuICogICBwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKSB7XHJcbiAqICAgICB0aGlzLmxhYmVsID0gJ291dHNpZGUnO1xyXG4gKiAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcbiAqICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gKiAgICAgICB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKCgpID0+IHtcclxuICogICAgICAgLy8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkaXNwbGF5IGRvbmVcclxuICogICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7Y29uc29sZS5sb2coJ091dHNpZGUgRG9uZSEnKSB9KTtcclxuICogICAgIH19KSk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKlxyXG4gKiAgIF9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gKiAgICAgdGhpcy5wcm9ncmVzcyArPSAxO1xyXG4gKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XHJcbiAqXHJcbiAqICAgICBpZiAodGhpcy5wcm9ncmVzcyA8IDEwMCkge1xyXG4gKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgIGRvbmVDYWxsYmFjaygpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBOZ1pvbmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGVuYWJsZUxvbmdTdGFja1RyYWNlIHdoZXRoZXIgdG8gZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2UuIFRoZXkgc2hvdWxkIG9ubHkgYmVcclxuICAgICAqICAgICAgICAgICAgICAgZW5hYmxlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGFzIHRoZXkgc2lnbmlmaWNhbnRseSBpbXBhY3QgcGVyZi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmdab25lKF9hKSB7XHJcbiAgICAgICAgdmFyIGVuYWJsZUxvbmdTdGFja1RyYWNlID0gX2EuZW5hYmxlTG9uZ1N0YWNrVHJhY2U7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3J1blNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKFwiTmdab25lI3J1bigpXCIpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9taWNyb3Rhc2tTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZShcIk5nWm9uZSNtaWNyb3Rhc2soKVwiKTtcclxuICAgICAgICAvLyBOdW1iZXIgb2YgbWljcm90YXNrcyBwZW5kaW5nIGZyb20gX2lubmVyWm9uZSAoJiBkZXNjZW5kYW50cylcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ01pY3JvdGFza3MgPSAwO1xyXG4gICAgICAgIC8vIFdoZXRoZXIgc29tZSBjb2RlIGhhcyBiZWVuIGV4ZWN1dGVkIGluIHRoZSBfaW5uZXJab25lICgmIGRlc2NlbmRhbnRzKSBpbiB0aGUgY3VycmVudCB0dXJuXHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2hhc0V4ZWN1dGVkQ29kZUluSW5uZXJab25lID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcnVuKCkgY2FsbCBkZXB0aCBpbiBfbW91bnRab25lLiAwIGF0IHRoZSBlbmQgb2YgYSBtYWNyb3Rhc2tcclxuICAgICAgICAvLyB6b25lLnJ1bigoKSA9PiB7ICAgICAgICAgLy8gdG9wLWxldmVsIGNhbGxcclxuICAgICAgICAvLyAgIHpvbmUucnVuKCgpID0+IHt9KTsgICAgLy8gbmVzdGVkIGNhbGwgLT4gaW4tdHVyblxyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXN0ZWRSdW4gPSAwO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9pblZtVHVybkRvbmUgPSBmYWxzZTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RpbWVvdXRzID0gW107XHJcbiAgICAgICAgaWYgKGxhbmdfMS5nbG9iYWwuem9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VudFpvbmUgPSBsYW5nXzEuZ2xvYmFsLnpvbmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lubmVyWm9uZSA9IHRoaXMuX2NyZWF0ZUlubmVyWm9uZSh0aGlzLl9tb3VudFpvbmUsIGVuYWJsZUxvbmdTdGFja1RyYWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbW91bnRab25lID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHpvbmUgaG9vayB0aGF0IGlzIGNhbGxlZCBqdXN0IGJlZm9yZSBhIGJyb3dzZXIgdGFzayB0aGF0IGlzIGhhbmRsZWQgYnkgQW5ndWxhclxyXG4gICAgICogZXhlY3V0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGhvb2sgaXMgY2FsbGVkIG9uY2UgcGVyIGJyb3dzZXIgdGFzayB0aGF0IGlzIGhhbmRsZWQgYnkgQW5ndWxhci5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoZSBob29rIG92ZXJyaWRlcyBhbnkgcHJldmlvdXNseSBzZXQgaG9vay5cclxuICAgICAqL1xyXG4gICAgTmdab25lLnByb3RvdHlwZS5vdmVycmlkZU9uVHVyblN0YXJ0ID0gZnVuY3Rpb24gKG9uVHVyblN0YXJ0SG9vaykge1xyXG4gICAgICAgIHRoaXMuX29uVHVyblN0YXJ0ID0gbGFuZ18xLm5vcm1hbGl6ZUJsYW5rKG9uVHVyblN0YXJ0SG9vayk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b25lIGhvb2sgdGhhdCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgQW5ndWxhciB6b25lIGlzIGRvbmUgcHJvY2Vzc2luZyB0aGUgY3VycmVudFxyXG4gICAgICogdGFzayBhbmQgYW55IG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gdGhhdCB0YXNrLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgd2hlcmUgd2UgdHlwaWNhbGx5IGRvIGNoYW5nZS1kZXRlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGhvb2sgaXMgY2FsbGVkIG9uY2UgcGVyIGJyb3dzZXIgdGFzayB0aGF0IGlzIGhhbmRsZWQgYnkgQW5ndWxhci5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoZSBob29rIG92ZXJyaWRlcyBhbnkgcHJldmlvdXNseSBzZXQgaG9vay5cclxuICAgICAqL1xyXG4gICAgTmdab25lLnByb3RvdHlwZS5vdmVycmlkZU9uVHVybkRvbmUgPSBmdW5jdGlvbiAob25UdXJuRG9uZUhvb2spIHtcclxuICAgICAgICB0aGlzLl9vblR1cm5Eb25lID0gbGFuZ18xLm5vcm1hbGl6ZUJsYW5rKG9uVHVybkRvbmVIb29rKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHpvbmUgaG9vayB0aGF0IGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYG9uVHVybkRvbmVgIGNhbGxiYWNrIGlzIGNhbGxlZCBhbmQgYW55XHJcbiAgICAgKiBtaWNyb3N0YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhhdCBjYWxsYmFjayBhcmUgZHJhaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBgb25FdmVudERvbmVGbmAgaXMgZXhlY3V0ZWQgb3V0c2lkZSBBbmd1bGFyIHpvbmUsIHdoaWNoIG1lYW5zIHRoYXQgd2Ugd2lsbCBubyBsb25nZXIgYXR0ZW1wdCB0b1xyXG4gICAgICogc3luYyB0aGUgVUkgd2l0aCBhbnkgbW9kZWwgY2hhbmdlcyB0aGF0IG9jY3VyIHdpdGhpbiB0aGlzIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaG9vayBpcyB1c2VmdWwgZm9yIHZhbGlkYXRpbmcgYXBwbGljYXRpb24gc3RhdGUgKGUuZy4gaW4gYSB0ZXN0KS5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoZSBob29rIG92ZXJyaWRlcyBhbnkgcHJldmlvdXNseSBzZXQgaG9vay5cclxuICAgICAqL1xyXG4gICAgTmdab25lLnByb3RvdHlwZS5vdmVycmlkZU9uRXZlbnREb25lID0gZnVuY3Rpb24gKG9uRXZlbnREb25lRm4sIG9wdF93YWl0Rm9yQXN5bmMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvcHRfd2FpdEZvckFzeW5jID09PSB2b2lkIDApIHsgb3B0X3dhaXRGb3JBc3luYyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRPbkV2ZW50RG9uZSA9IGxhbmdfMS5ub3JtYWxpemVCbGFuayhvbkV2ZW50RG9uZUZuKTtcclxuICAgICAgICBpZiAob3B0X3dhaXRGb3JBc3luYykge1xyXG4gICAgICAgICAgICB0aGlzLl9vbkV2ZW50RG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3BlbmRpbmdUaW1lb3V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkT25FdmVudERvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRXZlbnREb25lID0gbm9ybWFsaXplZE9uRXZlbnREb25lO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHpvbmUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgQW5ndWxhciB6b25lLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGhvb2sgb3ZlcnJpZGVzIGFueSBwcmV2aW91c2x5IHNldCBob29rLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLm92ZXJyaWRlT25FcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fb25FcnJvckhhbmRsZXIgPSBsYW5nXzEubm9ybWFsaXplQmxhbmsoZXJyb3JIYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcclxuICAgICAqIHRoZSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxyXG4gICAgICogb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lICh0eXBpY2FsbHkgc3RhcnRlZCB2aWEge0BsaW5rICNydW5PdXRzaWRlQW5ndWxhcn0pLlxyXG4gICAgICpcclxuICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXHJcbiAgICAgKiB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZS5cclxuICAgICAqL1xyXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuX3J1blNjb3BlKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJab25lLnJ1bihmbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBwcm9maWxlXzEud3RmTGVhdmUocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZuYCBmdW5jdGlvbiBzeW5jaHJvbm91c2x5IGluIEFuZ3VsYXIncyBwYXJlbnQgem9uZSBhbmQgcmV0dXJucyB2YWx1ZSByZXR1cm5lZCBieVxyXG4gICAgICogdGhlIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBgcnVuT3V0c2lkZUFuZ3VsYXJgIGFsbG93cyB5b3UgdG8gZXNjYXBlIEFuZ3VsYXIncyB6b25lIGFuZCBkbyB3b3JrIHRoYXRcclxuICAgICAqIGRvZXNuJ3QgdHJpZ2dlciBBbmd1bGFyIGNoYW5nZS1kZXRlY3Rpb24gb3IgaXMgc3ViamVjdCB0byBBbmd1bGFyJ3MgZXJyb3IgaGFuZGxpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGZ1dHVyZSB0YXNrcyBvciBtaWNyb3Rhc2tzIHNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udGludWUgZXhlY3V0aW5nIGZyb21cclxuICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cclxuICAgICAqXHJcbiAgICAgKiBVc2Uge0BsaW5rICNydW59IHRvIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZG8gd29yayB0aGF0IHVwZGF0ZXMgdGhlIGFwcGxpY2F0aW9uIG1vZGVsLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLnJ1bk91dHNpZGVBbmd1bGFyID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vdW50Wm9uZS5ydW4oZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLl9jcmVhdGVJbm5lclpvbmUgPSBmdW5jdGlvbiAoem9uZSwgZW5hYmxlTG9uZ1N0YWNrVHJhY2UpIHtcclxuICAgICAgICB2YXIgbWljcm90YXNrU2NvcGUgPSB0aGlzLl9taWNyb3Rhc2tTY29wZTtcclxuICAgICAgICB2YXIgbmdab25lID0gdGhpcztcclxuICAgICAgICB2YXIgZXJyb3JIYW5kbGluZztcclxuICAgICAgICBpZiAoZW5hYmxlTG9uZ1N0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGluZyA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKFpvbmUubG9uZ1N0YWNrVHJhY2Vab25lLCB7IG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7IG5nWm9uZS5fb25FcnJvcih0aGlzLCBlKTsgfSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxpbmcgPSB7IG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7IG5nWm9uZS5fb25FcnJvcih0aGlzLCBlKTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9uZS5mb3JrKGVycm9ySGFuZGxpbmcpXHJcbiAgICAgICAgICAgIC5mb3JrKHtcclxuICAgICAgICAgICAgJyRydW4nOiBmdW5jdGlvbiAocGFyZW50UnVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZS5fbmVzdGVkUnVuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmdab25lLl9oYXNFeGVjdXRlZENvZGVJbklubmVyWm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdab25lLl9oYXNFeGVjdXRlZENvZGVJbklubmVyWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmdab25lLl9vblR1cm5TdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5jYWxsKG5nWm9uZS5faW5uZXJab25lLCBuZ1pvbmUuX29uVHVyblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50UnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ1pvbmUuX25lc3RlZFJ1bi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBwZW5kaW5nIG1pY3JvdGFza3MsIHdlIGFyZSBhdCB0aGUgZW5kIG9mIGEgVk0gdHVybiAob3IgaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25UdXJuU3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIF9uZXN0ZWRSdW4gd2lsbCBiZSAwIGF0IHRoZSBlbmQgb2YgYSBtYWNyb3Rhc2tzIChpdCBjb3VsZCBiZSA+IDAgd2hlbiB0aGVyZSBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVzdGVkIGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJ1bigpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5nWm9uZS5fcGVuZGluZ01pY3JvdGFza3MgPT0gMCAmJiBuZ1pvbmUuX25lc3RlZFJ1biA9PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5faW5WbVR1cm5Eb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmdab25lLl9vblR1cm5Eb25lICYmIG5nWm9uZS5faGFzRXhlY3V0ZWRDb2RlSW5Jbm5lclpvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pblZtVHVybkRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2FsbChuZ1pvbmUuX2lubmVyWm9uZSwgbmdab25lLl9vblR1cm5Eb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luVm1UdXJuRG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ1pvbmUuX2hhc0V4ZWN1dGVkQ29kZUluSW5uZXJab25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5nWm9uZS5fcGVuZGluZ01pY3JvdGFza3MgPT09IDAgJiYgbGFuZ18xLmlzUHJlc2VudChuZ1pvbmUuX29uRXZlbnREb25lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihuZ1pvbmUuX29uRXZlbnREb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICckc2NoZWR1bGVNaWNyb3Rhc2snOiBmdW5jdGlvbiAocGFyZW50U2NoZWR1bGVNaWNyb3Rhc2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZ1pvbmUuX3BlbmRpbmdNaWNyb3Rhc2tzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pY3JvdGFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBtaWNyb3Rhc2tTY29wZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZS5fcGVuZGluZ01pY3JvdGFza3MtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2NoZWR1bGVNaWNyb3Rhc2suY2FsbCh0aGlzLCBtaWNyb3Rhc2spO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyRzZXRUaW1lb3V0JzogZnVuY3Rpb24gKHBhcmVudFNldFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4sIGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKG5nWm9uZS5fcGVuZGluZ1RpbWVvdXRzLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcmVudFNldFRpbWVvdXQoY2IsIGRlbGF5LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBuZ1pvbmUuX3BlbmRpbmdUaW1lb3V0cy5wdXNoKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnJGNsZWFyVGltZW91dCc6IGZ1bmN0aW9uIChwYXJlbnRDbGVhclRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUobmdab25lLl9wZW5kaW5nVGltZW91dHMsIGlkKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9pbm5lclpvbmU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKHpvbmUsIGUpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9vbkVycm9ySGFuZGxlcikpIHtcclxuICAgICAgICAgICAgdmFyIHRyYWNlID0gW2xhbmdfMS5ub3JtYWxpemVCbGFuayhlLnN0YWNrKV07XHJcbiAgICAgICAgICAgIHdoaWxlICh6b25lICYmIHpvbmUuY29uc3RydWN0ZWRBdEV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UucHVzaCh6b25lLmNvbnN0cnVjdGVkQXRFeGNlcHRpb24uZ2V0KCkpO1xyXG4gICAgICAgICAgICAgICAgem9uZSA9IHpvbmUucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3JIYW5kbGVyKGUsIHRyYWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjIyBfb25FcnJvciAjIycpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nWm9uZTtcclxufSkoKTtcclxuZXhwb3J0cy5OZ1pvbmUgPSBOZ1pvbmU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX3pvbmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgQXN5bmNSb3V0ZUhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXN5bmNSb3V0ZUhhbmRsZXIoX2xvYWRlciwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IF9sb2FkZXI7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgQXN5bmNSb3V0ZUhhbmRsZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVzb2x2ZWRDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQ29tcG9uZW50ID0gdGhpcy5fbG9hZGVyKCkudGhlbihmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFR5cGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFzeW5jUm91dGVIYW5kbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkFzeW5jUm91dGVIYW5kbGVyID0gQXN5bmNSb3V0ZUhhbmRsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jX3JvdXRlX2hhbmRsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBhbmd1bGFyMl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvYW5ndWxhcjInKTtcclxudmFyIGxvY2F0aW9uX3N0cmF0ZWd5XzEgPSByZXF1aXJlKCcuL2xvY2F0aW9uX3N0cmF0ZWd5Jyk7XHJcbi8qKlxyXG4gKiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzIGEge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IHVzZWQgdG8gY29uZmlndXJlIHRoZVxyXG4gKiB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcclxuICogW2hhc2ggZnJhZ21lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaWZvcm1fUmVzb3VyY2VfTG9jYXRvciNTeW50YXgpXHJcbiAqIG9mIHRoZSBicm93c2VyJ3MgVVJMLlxyXG4gKlxyXG4gKiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBjYWxsIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcclxuICogYGV4YW1wbGUuY29tIy9mb29gLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgVmlld30gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge1xyXG4gKiAgIFJPVVRFUl9ESVJFQ1RJVkVTLFxyXG4gKiAgIFJPVVRFUl9QUk9WSURFUlMsXHJcbiAqICAgUm91dGVDb25maWcsXHJcbiAqICAgTG9jYXRpb25cclxuICogfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogIHsuLi59LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge1xyXG4gKiAgIGNvbnN0cnVjdG9yKGxvY2F0aW9uOiBMb2NhdGlvbikge1xyXG4gKiAgICAgbG9jYXRpb24uZ28oJy9mb28nKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcENtcCwgW1JPVVRFUl9QUk9WSURFUlNdKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEhhc2hMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGFzaExvY2F0aW9uU3RyYXRlZ3koKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRMb2NhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRIaXN0b3J5KCk7XHJcbiAgICB9XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmdldEdsb2JhbEV2ZW50VGFyZ2V0KCd3aW5kb3cnKS5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZuLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB0aGUgaGFzaCB2YWx1ZSBpcyBhbHdheXMgcHJlZml4ZWQgd2l0aCBhIGAjYFxyXG4gICAgICAgIC8vIGFuZCBpZiBpdCBpcyBlbXB0eSB0aGVuIGl0IHdpbGwgc3RheSBlbXB0eVxyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fbG9jYXRpb24uaGFzaDtcclxuICAgICAgICAvLyBEYXJ0IHdpbGwgY29tcGxhaW4gaWYgYSBjYWxsIHRvIHN1YnN0cmluZyBpc1xyXG4gICAgICAgIC8vIGV4ZWN1dGVkIHdpdGggYSBwb3NpdGlvbiB2YWx1ZSB0aGF0IGV4dGVuZHMgdGhlXHJcbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZy5cclxuICAgICAgICByZXR1cm4gKHBhdGgubGVuZ3RoID4gMCA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aCkgK1xyXG4gICAgICAgICAgICBsb2NhdGlvbl9zdHJhdGVneV8xLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHRoaXMuX2xvY2F0aW9uLnNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIHVybCA9IHBhdGggKyBsb2NhdGlvbl9zdHJhdGVneV8xLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXJsID0gJyMnICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XHJcbiAgICB9O1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hpc3RvcnkuZm9yd2FyZCgpOyB9O1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hpc3RvcnkuYmFjaygpOyB9O1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBhbmd1bGFyMl8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEhhc2hMb2NhdGlvblN0cmF0ZWd5KTtcclxuICAgIHJldHVybiBIYXNoTG9jYXRpb25TdHJhdGVneTtcclxufSkobG9jYXRpb25fc3RyYXRlZ3lfMS5Mb2NhdGlvblN0cmF0ZWd5KTtcclxuZXhwb3J0cy5IYXNoTG9jYXRpb25TdHJhdGVneSA9IEhhc2hMb2NhdGlvblN0cmF0ZWd5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoX2xvY2F0aW9uX3N0cmF0ZWd5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogYFJvdXRlUGFyYW1zYCBpcyBhbiBpbW11dGFibGUgbWFwIG9mIHBhcmFtZXRlcnMgZm9yIHRoZSBnaXZlbiByb3V0ZVxyXG4gKiBiYXNlZCBvbiB0aGUgdXJsIG1hdGNoZXIgYW5kIG9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoYXQgcm91dGUuXHJcbiAqXHJcbiAqIFlvdSBjYW4gaW5qZWN0IGBSb3V0ZVBhcmFtc2AgaW50byB0aGUgY29uc3RydWN0b3Igb2YgYSBjb21wb25lbnQgdG8gdXNlIGl0LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge2Jvb3RzdHJhcCwgQ29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7Um91dGVyLCBST1VURVJfRElSRUNUSVZFUywgUk9VVEVSX1BST1ZJREVSUywgUm91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAge3BhdGg6ICcvdXNlci86aWQnLCBjb21wb25lbnQ6IFVzZXJDbXAsIGFzOiAnVXNlckNtcCd9LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge31cclxuICpcclxuICogQENvbXBvbmVudCh7IHRlbXBsYXRlOiAndXNlcjoge3tpZH19JyB9KVxyXG4gKiBjbGFzcyBVc2VyQ21wIHtcclxuICogICBzdHJpbmc6IGlkO1xyXG4gKiAgIGNvbnN0cnVjdG9yKHBhcmFtczogUm91dGVQYXJhbXMpIHtcclxuICogICAgIHRoaXMuaWQgPSBwYXJhbXMuZ2V0KCdpZCcpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBST1VURVJfUFJPVklERVJTKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgUm91dGVQYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUm91dGVQYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICBSb3V0ZVBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBsYW5nXzEubm9ybWFsaXplQmxhbmsoY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KHRoaXMucGFyYW1zLCBwYXJhbSkpOyB9O1xyXG4gICAgcmV0dXJuIFJvdXRlUGFyYW1zO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlUGFyYW1zID0gUm91dGVQYXJhbXM7XHJcbi8qKlxyXG4gKiBgSW5zdHJ1Y3Rpb25gIGlzIGEgdHJlZSBvZiB7QGxpbmsgQ29tcG9uZW50SW5zdHJ1Y3Rpb259cyB3aXRoIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkXHJcbiAqIHRvIHRyYW5zaXRpb24gZWFjaCBjb21wb25lbnQgaW4gdGhlIGFwcCB0byBhIGdpdmVuIHJvdXRlLCBpbmNsdWRpbmcgYWxsIGF1eGlsaWFyeSByb3V0ZXMuXHJcbiAqXHJcbiAqIGBJbnN0cnVjdGlvbmBzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHtAbGluayBSb3V0ZXIjZ2VuZXJhdGV9LCBhbmQgY2FuIGJlIHVzZWQgdG9cclxuICogcGVyZm9ybSByb3V0ZSBjaGFuZ2VzIHdpdGgge0BsaW5rIFJvdXRlciNuYXZpZ2F0ZUJ5SW5zdHJ1Y3Rpb259LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge2Jvb3RzdHJhcCwgQ29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7Um91dGVyLCBST1VURVJfRElSRUNUSVZFUywgUk9VVEVSX1BST1ZJREVSUywgUm91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgY29uc3RydWN0b3Iocm91dGVyOiBSb3V0ZXIpIHtcclxuICogICAgIHZhciBpbnN0cnVjdGlvbiA9IHJvdXRlci5nZW5lcmF0ZShbJy9NeVJvdXRlJ10pO1xyXG4gKiAgICAgcm91dGVyLm5hdmlnYXRlQnlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbik7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFJPVVRFUl9QUk9WSURFUlMpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBJbnN0cnVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnN0cnVjdGlvbihjb21wb25lbnQsIGNoaWxkLCBhdXhJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBjaGlsZDtcclxuICAgICAgICB0aGlzLmF1eEluc3RydWN0aW9uID0gYXV4SW5zdHJ1Y3Rpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgaW5zdHJ1Y3Rpb24gdGhhdCBzaGFyZXMgdGhlIHN0YXRlIG9mIHRoZSBleGlzdGluZyBpbnN0cnVjdGlvbiwgYnV0IHdpdGhcclxuICAgICAqIHRoZSBnaXZlbiBjaGlsZCB7QGxpbmsgSW5zdHJ1Y3Rpb259IHJlcGxhY2luZyB0aGUgZXhpc3RpbmcgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIEluc3RydWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluc3RydWN0aW9uKHRoaXMuY29tcG9uZW50LCBjaGlsZCwgdGhpcy5hdXhJbnN0cnVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluc3RydWN0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLkluc3RydWN0aW9uID0gSW5zdHJ1Y3Rpb247XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcGFydGlhbGx5IGNvbXBsZXRlZCBpbnN0cnVjdGlvbiBkdXJpbmcgcmVjb2duaXRpb24gdGhhdCBvbmx5IGhhcyB0aGVcclxuICogcHJpbWFyeSAobm9uLWF1eCkgcm91dGUgaW5zdHJ1Y3Rpb25zIG1hdGNoZWQuXHJcbiAqXHJcbiAqIGBQcmltYXJ5SW5zdHJ1Y3Rpb25gIGlzIGFuIGludGVybmFsIGNsYXNzIHVzZWQgYnkgYFJvdXRlUmVjb2duaXplcmAgd2hpbGUgaXQnc1xyXG4gKiBmaWd1cmluZyBvdXQgd2hlcmUgdG8gbmF2aWdhdGUuXHJcbiAqL1xyXG52YXIgUHJpbWFyeUluc3RydWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByaW1hcnlJbnN0cnVjdGlvbihjb21wb25lbnQsIGNoaWxkLCBhdXhVcmxzKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMuYXV4VXJscyA9IGF1eFVybHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJpbWFyeUluc3RydWN0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLlByaW1hcnlJbnN0cnVjdGlvbiA9IFByaW1hcnlJbnN0cnVjdGlvbjtcclxuZnVuY3Rpb24gc3RyaW5naWZ5SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnlJbnN0cnVjdGlvblBhdGgoaW5zdHJ1Y3Rpb24pICsgc3RyaW5naWZ5SW5zdHJ1Y3Rpb25RdWVyeShpbnN0cnVjdGlvbik7XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdpZnlJbnN0cnVjdGlvbiA9IHN0cmluZ2lmeUluc3RydWN0aW9uO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlJbnN0cnVjdGlvblBhdGgoaW5zdHJ1Y3Rpb24pIHtcclxuICAgIHJldHVybiBpbnN0cnVjdGlvbi5jb21wb25lbnQudXJsUGF0aCArIHN0cmluZ2lmeUF1eChpbnN0cnVjdGlvbikgK1xyXG4gICAgICAgIHN0cmluZ2lmeVByaW1hcnkoaW5zdHJ1Y3Rpb24uY2hpbGQpO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5naWZ5SW5zdHJ1Y3Rpb25QYXRoID0gc3RyaW5naWZ5SW5zdHJ1Y3Rpb25QYXRoO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlJbnN0cnVjdGlvblF1ZXJ5KGluc3RydWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnVybFBhcmFtcy5sZW5ndGggPiAwID9cclxuICAgICAgICAoJz8nICsgaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnVybFBhcmFtcy5qb2luKCcmJykpIDpcclxuICAgICAgICAnJztcclxufVxyXG5leHBvcnRzLnN0cmluZ2lmeUluc3RydWN0aW9uUXVlcnkgPSBzdHJpbmdpZnlJbnN0cnVjdGlvblF1ZXJ5O1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlQcmltYXJ5KGluc3RydWN0aW9uKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtcyA9IGluc3RydWN0aW9uLmNvbXBvbmVudC51cmxQYXJhbXMubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgKCc7JyArIGluc3RydWN0aW9uLmNvbXBvbmVudC51cmxQYXJhbXMuam9pbignOycpKSA6XHJcbiAgICAgICAgJyc7XHJcbiAgICByZXR1cm4gJy8nICsgaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnVybFBhdGggKyBwYXJhbXMgKyBzdHJpbmdpZnlBdXgoaW5zdHJ1Y3Rpb24pICtcclxuICAgICAgICBzdHJpbmdpZnlQcmltYXJ5KGluc3RydWN0aW9uLmNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlBdXgoaW5zdHJ1Y3Rpb24pIHtcclxuICAgIHZhciByb3V0ZXMgPSBbXTtcclxuICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goaW5zdHJ1Y3Rpb24uYXV4SW5zdHJ1Y3Rpb24sIGZ1bmN0aW9uIChhdXhJbnN0cnVjdGlvbiwgXykge1xyXG4gICAgICAgIHJvdXRlcy5wdXNoKHN0cmluZ2lmeVByaW1hcnkoYXV4SW5zdHJ1Y3Rpb24pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHJvdXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcoJyArIHJvdXRlcy5qb2luKCcvLycpICsgJyknO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBDb21wb25lbnRJbnN0cnVjdGlvbmAgcmVwcmVzZW50cyB0aGUgcm91dGUgc3RhdGUgZm9yIGEgc2luZ2xlIGNvbXBvbmVudC4gQW4gYEluc3RydWN0aW9uYCBpc1xyXG4gKiBjb21wb3NlZCBvZiBhIHRyZWUgb2YgdGhlc2UgYENvbXBvbmVudEluc3RydWN0aW9uYHMuXHJcbiAqXHJcbiAqIGBDb21wb25lbnRJbnN0cnVjdGlvbnNgIGlzIGEgcHVibGljIEFQSS4gSW5zdGFuY2VzIG9mIGBDb21wb25lbnRJbnN0cnVjdGlvbmAgYXJlIHBhc3NlZFxyXG4gKiB0byByb3V0ZSBsaWZlY3ljbGUgaG9va3MsIGxpa2Uge0BsaW5rIENhbkFjdGl2YXRlfS5cclxuICpcclxuICogYENvbXBvbmVudEluc3RydWN0aW9uYHMgYXJlIFtodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXNoX2NvbnNpbmddKGhhc2ggY29uc2VkKS4gWW91IHNob3VsZFxyXG4gKiBuZXZlciBjb25zdHJ1Y3Qgb25lIHlvdXJzZWxmIHdpdGggXCJuZXcuXCIgSW5zdGVhZCwgcmVseSBvbiB7QGxpbmsgUm91dGVyL1BhdGhSZWNvZ25pemVyfSB0b1xyXG4gKiBjb25zdHJ1Y3QgYENvbXBvbmVudEluc3RydWN0aW9uYHMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgbm90IG1vZGlmeSB0aGlzIG9iamVjdC4gSXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLlxyXG4gKi9cclxudmFyIENvbXBvbmVudEluc3RydWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudEluc3RydWN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmV1c2UgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRJbnN0cnVjdGlvbi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IHR5cGUgb2YgdGhlIHJlcHJlc2VudGVkIHJvdXRlLCBvciBgbnVsbGAgaWYgdGhpcyBpbnN0cnVjdGlvblxyXG4gICAgICAgICAqIGhhc24ndCBiZWVuIHJlc29sdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50SW5zdHJ1Y3Rpb24ucHJvdG90eXBlLCBcInNwZWNpZmljaXR5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgcm91dGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEluc3RydWN0aW9uYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudEluc3RydWN0aW9uLnByb3RvdHlwZSwgXCJ0ZXJtaW5hbFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbXBvbmVudCB0eXBlIG9mIHRoaXMgaW5zdHJ1Y3Rpb24gaGFzIG5vIGNoaWxkIHtAbGluayBSb3V0ZUNvbmZpZ30sXHJcbiAgICAgICAgICogb3IgYGZhbHNlYCBpZiBpdCBkb2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQ29tcG9uZW50SW5zdHJ1Y3Rpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBDb21wb25lbnRJbnN0cnVjdGlvbjtcclxudmFyIENvbXBvbmVudEluc3RydWN0aW9uXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29tcG9uZW50SW5zdHJ1Y3Rpb25fLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50SW5zdHJ1Y3Rpb25fKHVybFBhdGgsIHVybFBhcmFtcywgX3JlY29nbml6ZXIsIHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSBudWxsOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcmVjb2duaXplciA9IF9yZWNvZ25pemVyO1xyXG4gICAgICAgIHRoaXMudXJsUGF0aCA9IHVybFBhdGg7XHJcbiAgICAgICAgdGhpcy51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50SW5zdHJ1Y3Rpb25fLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuaGFuZGxlci5jb21wb25lbnRUeXBlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvbXBvbmVudEluc3RydWN0aW9uXy5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWNvZ25pemVyLmhhbmRsZXIucmVzb2x2ZUNvbXBvbmVudFR5cGUoKTsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRJbnN0cnVjdGlvbl8ucHJvdG90eXBlLCBcInNwZWNpZmljaXR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuc3BlY2lmaWNpdHk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudEluc3RydWN0aW9uXy5wcm90b3R5cGUsIFwidGVybWluYWxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVjb2duaXplci50ZXJtaW5hbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb21wb25lbnRJbnN0cnVjdGlvbl8ucHJvdG90eXBlLnJvdXRlRGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuaGFuZGxlci5kYXRhOyB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudEluc3RydWN0aW9uXztcclxufSkoQ29tcG9uZW50SW5zdHJ1Y3Rpb24pO1xyXG5leHBvcnRzLkNvbXBvbmVudEluc3RydWN0aW9uXyA9IENvbXBvbmVudEluc3RydWN0aW9uXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdHJ1Y3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBUaGlzIGluZGlyZWN0aW9uIGlzIG5lZWRlZCB0byBmcmVlIHVwIENvbXBvbmVudCwgZXRjIHN5bWJvbHMgaW4gdGhlIHB1YmxpYyBBUElcclxuICogdG8gYmUgdXNlZCBieSB0aGUgZGVjb3JhdG9yIHZlcnNpb25zIG9mIHRoZXNlIGFubm90YXRpb25zLlxyXG4gKi9cclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3V0aWwvZGVjb3JhdG9ycycpO1xyXG52YXIgbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMSA9IHJlcXVpcmUoJy4vbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGwnKTtcclxudmFyIGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzIgPSByZXF1aXJlKCcuL2xpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsJyk7XHJcbmV4cG9ydHMuY2FuUmV1c2UgPSBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8yLmNhblJldXNlO1xyXG5leHBvcnRzLmNhbkRlYWN0aXZhdGUgPSBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8yLmNhbkRlYWN0aXZhdGU7XHJcbmV4cG9ydHMub25BY3RpdmF0ZSA9IGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzIub25BY3RpdmF0ZTtcclxuZXhwb3J0cy5vblJldXNlID0gbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMi5vblJldXNlO1xyXG5leHBvcnRzLm9uRGVhY3RpdmF0ZSA9IGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzIub25EZWFjdGl2YXRlO1xyXG4vKipcclxuICogRGVmaW5lcyByb3V0ZSBsaWZlY3ljbGUgaG9vayBgQ2FuQWN0aXZhdGVgLCB3aGljaCBpcyBjYWxsZWQgYnkgdGhlIHJvdXRlciB0byBkZXRlcm1pbmVcclxuICogaWYgYSBjb21wb25lbnQgY2FuIGJlIGluc3RhbnRpYXRlZCBhcyBwYXJ0IG9mIGEgbmF2aWdhdGlvbi5cclxuICpcclxuICogVGhlIGBDYW5BY3RpdmF0ZWAgaG9vayBpcyBjYWxsZWQgd2l0aCB0d28ge0BsaW5rIENvbXBvbmVudEluc3RydWN0aW9ufXMgYXMgcGFyYW1ldGVycywgdGhlIGZpcnN0XHJcbiAqIHJlcHJlc2VudGluZ1xyXG4gKiB0aGUgY3VycmVudCByb3V0ZSBiZWluZyBuYXZpZ2F0ZWQgdG8sIGFuZCB0aGUgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHJvdXRlIG9yXHJcbiAqIGBudWxsYC5cclxuICpcclxuICogTm90ZSB0aGF0IHVubGlrZSBvdGhlciBsaWZlY3ljbGUgaG9va3MsIHRoaXMgb25lIHVzZXMgYW4gYW5ub3RhdGlvbiByYXRoZXIgdGhhbiBhbiBpbnRlcmZhY2UuXHJcbiAqIFRoaXMgaXMgYmVjYXVzZSB0aGUgYENhbkFjdGl2YXRlYCBmdW5jdGlvbiBpcyBjYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLlxyXG4gKlxyXG4gKiBJZiBgQ2FuQWN0aXZhdGVgIHJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYGZhbHNlYCwgdGhlIG5hdmlnYXRpb24gaXMgY2FuY2VsbGVkLlxyXG4gKiBJZiBgQ2FuQWN0aXZhdGVgIHRocm93cyBvciByZWplY3RzLCB0aGUgbmF2aWdhdGlvbiBpcyBhbHNvIGNhbmNlbGxlZC5cclxuICogSWYgYENhbkFjdGl2YXRlYCByZXR1cm5zIG9yIHJlc29sdmVzIHRvIGB0cnVlYCwgbmF2aWdhdGlvbiBjb250aW51ZXMsIHRoZSBjb21wb25lbnQgaXNcclxuICogaW5zdGFudGlhdGVkLCBhbmQgdGhlIHtAbGluayBPbkFjdGl2YXRlfSBob29rIG9mIHRoYXQgY29tcG9uZW50IGlzIGNhbGxlZCBpZiBpbXBsZW1lbnRlZC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtDYW5BY3RpdmF0ZX0gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdjb250cm9sLXBhbmVsLWNtcCcsXHJcbiAqICAgdGVtcGxhdGU6ICc8ZGl2PkNvbnRyb2wgUGFuZWw6IC4uLjwvZGl2PidcclxuICogfSlcclxuICogQENhbkFjdGl2YXRlKCgpID0+IGNoZWNrSWZVc2VySXNMb2dnZWRJbigpKVxyXG4gKiBjbGFzcyBDb250cm9sUGFuZWxDbXAge1xyXG4gKiAgIC8vIC4uLlxyXG4gKiB9XHJcbiAqICBgYGBcclxuICovXHJcbmV4cG9ydHMuQ2FuQWN0aXZhdGUgPSBkZWNvcmF0b3JzXzEubWFrZURlY29yYXRvcihsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8xLkNhbkFjdGl2YXRlKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmZWN5Y2xlX2Fubm90YXRpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIFJvdXRlTGlmZWN5Y2xlSG9vayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZUxpZmVjeWNsZUhvb2sobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgICBSb3V0ZUxpZmVjeWNsZUhvb2sgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIFJvdXRlTGlmZWN5Y2xlSG9vayk7XHJcbiAgICByZXR1cm4gUm91dGVMaWZlY3ljbGVIb29rO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlTGlmZWN5Y2xlSG9vayA9IFJvdXRlTGlmZWN5Y2xlSG9vaztcclxudmFyIENhbkFjdGl2YXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhbkFjdGl2YXRlKGZuKSB7XHJcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgfVxyXG4gICAgQ2FuQWN0aXZhdGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbRnVuY3Rpb25dKVxyXG4gICAgXSwgQ2FuQWN0aXZhdGUpO1xyXG4gICAgcmV0dXJuIENhbkFjdGl2YXRlO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhbkFjdGl2YXRlID0gQ2FuQWN0aXZhdGU7XHJcbmV4cG9ydHMuY2FuUmV1c2UgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgUm91dGVMaWZlY3ljbGVIb29rKFwiY2FuUmV1c2VcIikpO1xyXG5leHBvcnRzLmNhbkRlYWN0aXZhdGUgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgUm91dGVMaWZlY3ljbGVIb29rKFwiY2FuRGVhY3RpdmF0ZVwiKSk7XHJcbmV4cG9ydHMub25BY3RpdmF0ZSA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBSb3V0ZUxpZmVjeWNsZUhvb2soXCJvbkFjdGl2YXRlXCIpKTtcclxuZXhwb3J0cy5vblJldXNlID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IFJvdXRlTGlmZWN5Y2xlSG9vayhcIm9uUmV1c2VcIikpO1xyXG5leHBvcnRzLm9uRGVhY3RpdmF0ZSA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBSb3V0ZUxpZmVjeWNsZUhvb2soXCJvbkRlYWN0aXZhdGVcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vbG9jYXRpb25fc3RyYXRlZ3knKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBsYW5nXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGFuZ3VsYXIyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG4vKipcclxuICogVGhlIGBBUFBfQkFTRV9IUkVGYCB0b2tlbiByZXByZXNlbnRzIHRoZSBiYXNlIGhyZWYgdG8gYmUgdXNlZCB3aXRoIHRoZVxyXG4gKiB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LlxyXG4gKlxyXG4gKiBJZiB5b3UncmUgdXNpbmcge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSwgeW91IG11c3QgcHJvdmlkZSBhIHByb3ZpZGVyIHRvIGEgc3RyaW5nXHJcbiAqIHJlcHJlc2VudGluZyB0aGUgVVJMIHByZWZpeCB0aGF0IHNob3VsZCBiZSBwcmVzZXJ2ZWQgd2hlbiBnZW5lcmF0aW5nIGFuZCByZWNvZ25pemluZ1xyXG4gKiBVUkxzLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge1JPVVRFUl9ESVJFQ1RJVkVTLCBST1VURVJfUFJPVklERVJTLCBSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7ZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTXX0pXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICB7Li4ufSxcclxuICogXSlcclxuICogY2xhc3MgQXBwQ21wIHtcclxuICogICAvLyAuLi5cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBbXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBQYXRoTG9jYXRpb25TdHJhdGVneSxcclxuICogICBwcm92aWRlKEFQUF9CQVNFX0hSRUYsIHt1c2VWYWx1ZTogJy9teS9hcHAnfSlcclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5BUFBfQkFTRV9IUkVGID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGFuZ3VsYXIyXzEuT3BhcXVlVG9rZW4oJ2FwcEJhc2VIcmVmJykpO1xyXG4vKipcclxuICogYExvY2F0aW9uYCBpcyBhIHNlcnZpY2UgdGhhdCBhcHBsaWNhdGlvbnMgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIGEgYnJvd3NlcidzIFVSTC5cclxuICogRGVwZW5kaW5nIG9uIHdoaWNoIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBpcyB1c2VkLCBgTG9jYXRpb25gIHdpbGwgZWl0aGVyIHBlcnNpc3RcclxuICogdG8gdGhlIFVSTCdzIHBhdGggb3IgdGhlIFVSTCdzIGhhc2ggc2VnbWVudC5cclxuICpcclxuICogTm90ZTogaXQncyBiZXR0ZXIgdG8gdXNlIHtAbGluayBSb3V0ZXIjbmF2aWdhdGV9IHNlcnZpY2UgdG8gdHJpZ2dlciByb3V0ZSBjaGFuZ2VzLiBVc2VcclxuICogYExvY2F0aW9uYCBvbmx5IGlmIHlvdSBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgY3JlYXRlIG5vcm1hbGl6ZWQgVVJMcyBvdXRzaWRlIG9mXHJcbiAqIHJvdXRpbmcuXHJcbiAqXHJcbiAqIGBMb2NhdGlvbmAgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIHRoZSBVUkwgYWdhaW5zdCB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYuXHJcbiAqIEEgbm9ybWFsaXplZCBVUkwgaXMgYWJzb2x1dGUgZnJvbSB0aGUgVVJMIGhvc3QsIGluY2x1ZGVzIHRoZSBhcHBsaWNhdGlvbidzIGJhc2UgaHJlZiwgYW5kIGhhcyBub1xyXG4gKiB0cmFpbGluZyBzbGFzaDpcclxuICogLSBgL215L2FwcC91c2VyLzEyM2AgaXMgbm9ybWFsaXplZFxyXG4gKiAtIGBteS9hcHAvdXNlci8xMjNgICoqaXMgbm90Kiogbm9ybWFsaXplZFxyXG4gKiAtIGAvbXkvYXBwL3VzZXIvMTIzL2AgKippcyBub3QqKiBub3JtYWxpemVkXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7XHJcbiAqICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBSb3V0ZUNvbmZpZyxcclxuICogICBMb2NhdGlvblxyXG4gKiB9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgY29uc3RydWN0b3IobG9jYXRpb246IExvY2F0aW9uKSB7XHJcbiAqICAgICBsb2NhdGlvbi5nbygnL2ZvbycpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBbUk9VVEVSX1BST1ZJREVSU10pO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBMb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2NhdGlvbihwbGF0Zm9ybVN0cmF0ZWd5LCBocmVmKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kgPSBwbGF0Zm9ybVN0cmF0ZWd5O1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdmFyIGJyb3dzZXJCYXNlSHJlZiA9IGxhbmdfMS5pc1ByZXNlbnQoaHJlZikgPyBocmVmIDogdGhpcy5wbGF0Zm9ybVN0cmF0ZWd5LmdldEJhc2VIcmVmKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMi5pc0JsYW5rKGJyb3dzZXJCYXNlSHJlZikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gYmFzZSBocmVmIHNldC4gRWl0aGVyIHByb3ZpZGUgYSBwcm92aWRlciBmb3IgdGhlIEFQUF9CQVNFX0hSRUYgdG9rZW4gb3IgYWRkIGEgYmFzZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gc3RyaXBUcmFpbGluZ1NsYXNoKHN0cmlwSW5kZXhIdG1sKGJyb3dzZXJCYXNlSHJlZikpO1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm1TdHJhdGVneS5vblBvcFN0YXRlKGZ1bmN0aW9uIChfKSB7IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQoX3RoaXMuX3N1YmplY3QsIHsgJ3VybCc6IF90aGlzLnBhdGgoKSwgJ3BvcCc6IHRydWUgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoLlxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsaXplKHRoaXMucGxhdGZvcm1TdHJhdGVneS5wYXRoKCkpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGguXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBCYXNlSHJlZih0aGlzLl9iYXNlSHJlZiwgc3RyaXBJbmRleEh0bWwodXJsKSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVJMLCByZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoLlxyXG4gICAgICogSWYgdGhlIGdpdmVuIFVSTCBkb2Vzbid0IGJlZ2luIHdpdGggYSBsZWFkaW5nIHNsYXNoIChgJy8nYCksIHRoaXMgbWV0aG9kIGFkZHMgb25lXHJcbiAgICAgKiBiZWZvcmUgbm9ybWFsaXppbmcuXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemVBYnNvbHV0ZWx5ID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJpcFRyYWlsaW5nU2xhc2goX2FkZEJhc2VIcmVmKHRoaXMuX2Jhc2VIcmVmLCB1cmwpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGJyb3dzZXJzIFVSTCB0byB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBVUkwsIGFuZCBwdXNoZXMgYVxyXG4gICAgICogbmV3IGl0ZW0gb250byB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XHJcbiAgICAgICAgdmFyIGFic29sdXRlUGF0aCA9IHRoaXMubm9ybWFsaXplQWJzb2x1dGVseShwYXRoKTtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kucHVzaFN0YXRlKG51bGwsICcnLCBhYnNvbHV0ZVBhdGgsIHF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kuZm9yd2FyZCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgYmFjayBpbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wbGF0Zm9ybVN0cmF0ZWd5LmJhY2soKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBwbGF0Zm9ybSdzIGBwb3BTdGF0ZWAgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9uTmV4dCwgb25UaHJvdywgb25SZXR1cm4pIHtcclxuICAgICAgICBpZiAob25UaHJvdyA9PT0gdm9pZCAwKSB7IG9uVGhyb3cgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG9uUmV0dXJuID09PSB2b2lkIDApIHsgb25SZXR1cm4gPSBudWxsOyB9XHJcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUodGhpcy5fc3ViamVjdCwgb25OZXh0LCBvblRocm93LCBvblJldHVybik7XHJcbiAgICB9O1xyXG4gICAgTG9jYXRpb24gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBhbmd1bGFyMl8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGFuZ3VsYXIyXzEuT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBhbmd1bGFyMl8xLkluamVjdChleHBvcnRzLkFQUF9CQVNFX0hSRUYpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbG9jYXRpb25fc3RyYXRlZ3lfMS5Mb2NhdGlvblN0cmF0ZWd5LCBTdHJpbmddKVxyXG4gICAgXSwgTG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIExvY2F0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLkxvY2F0aW9uID0gTG9jYXRpb247XHJcbmZ1bmN0aW9uIF9zdHJpcEJhc2VIcmVmKGJhc2VIcmVmLCB1cmwpIHtcclxuICAgIGlmIChiYXNlSHJlZi5sZW5ndGggPiAwICYmIHVybC5zdGFydHNXaXRoKGJhc2VIcmVmKSkge1xyXG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKGJhc2VIcmVmLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIF9hZGRCYXNlSHJlZihiYXNlSHJlZiwgdXJsKSB7XHJcbiAgICBpZiAoIXVybC5zdGFydHNXaXRoKGJhc2VIcmVmKSkge1xyXG4gICAgICAgIHJldHVybiBiYXNlSHJlZiArIHVybDtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuZnVuY3Rpb24gc3RyaXBJbmRleEh0bWwodXJsKSB7XHJcbiAgICBpZiAoL1xcL2luZGV4Lmh0bWwkL2cudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgLy8gJy9pbmRleC5odG1sJy5sZW5ndGggPT0gMTFcclxuICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMTEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5mdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2godXJsKSB7XHJcbiAgICBpZiAoL1xcLyQvZy50ZXN0KHVybCkpIHtcclxuICAgICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBgTG9jYXRpb25TdHJhdGVneWAgaXMgcmVzcG9uc2libGUgZm9yIHJlcHJlc2VudGluZyBhbmQgcmVhZGluZyByb3V0ZSBzdGF0ZVxyXG4gKiBmcm9tIHRoZSB0aGUgYnJvd3NlcidzIFVSTC4gQW5ndWxhciBwcm92aWRlcyB0d28gc3RyYXRlZ2llczpcclxuICoge0BsaW5rIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSAoZGVmYXVsdCkgYW5kIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0uXHJcbiAqXHJcbiAqIFRoaXMgaXMgdXNlZCB1bmRlciB0aGUgaG9vZCBvZiB0aGUge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgc2hvdWxkIHVzZSB0aGUge0BsaW5rIFJvdXRlcn0gb3Ige0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlcyB0b1xyXG4gKiBpbnRlcmFjdCB3aXRoIGFwcGxpY2F0aW9uIHJvdXRlIHN0YXRlLlxyXG4gKlxyXG4gKiBGb3IgaW5zdGFuY2UsIHtAbGluayBIYXNoTG9jYXRpb25TdHJhdGVneX0gcHJvZHVjZXMgVVJMcyBsaWtlXHJcbiAqIGBodHRwOi8vZXhhbXBsZS5jb20jL2Zvb2AsIGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzXHJcbiAqIGBodHRwOi8vZXhhbXBsZS5jb20vZm9vYCBhcyBhbiBlcXVpdmFsZW50IFVSTC5cclxuICpcclxuICogU2VlIHRoZXNlIHR3byBjbGFzc2VzIGZvciBtb3JlLlxyXG4gKi9cclxudmFyIExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9jYXRpb25TdHJhdGVneSgpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBMb2NhdGlvblN0cmF0ZWd5O1xyXG59KSgpO1xyXG5leHBvcnRzLkxvY2F0aW9uU3RyYXRlZ3kgPSBMb2NhdGlvblN0cmF0ZWd5O1xyXG5mdW5jdGlvbiBub3JtYWxpemVRdWVyeVBhcmFtcyhwYXJhbXMpIHtcclxuICAgIHJldHVybiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgcGFyYW1zLnN1YnN0cmluZygwLCAxKSAhPSAnPycpID8gKCc/JyArIHBhcmFtcykgOiBwYXJhbXM7XHJcbn1cclxuZXhwb3J0cy5ub3JtYWxpemVRdWVyeVBhcmFtcyA9IG5vcm1hbGl6ZVF1ZXJ5UGFyYW1zO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhdGlvbl9zdHJhdGVneS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGFuZ3VsYXIyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vbG9jYXRpb25fc3RyYXRlZ3knKTtcclxuLyoqXHJcbiAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgYSB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gdXNlZCB0byBjb25maWd1cmUgdGhlXHJcbiAqIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB0byByZXByZXNlbnQgaXRzIHN0YXRlIGluIHRoZVxyXG4gKiBbcGF0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheCkgb2YgdGhlXHJcbiAqIGJyb3dzZXIncyBVUkwuXHJcbiAqXHJcbiAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgdGhlIGRlZmF1bHQgYmluZGluZyBmb3Ige0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XHJcbiAqIHByb3ZpZGVkIGluIHtAbGluayBST1VURVJfUFJPVklERVJTfS5cclxuICpcclxuICogSWYgeW91J3JlIHVzaW5nIGBQYXRoTG9jYXRpb25TdHJhdGVneWAsIHlvdSBtdXN0IHByb3ZpZGUgYSBwcm92aWRlciBmb3JcclxuICoge0BsaW5rIEFQUF9CQVNFX0hSRUZ9IHRvIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgVVJMIHByZWZpeCB0aGF0IHNob3VsZFxyXG4gKiBiZSBwcmVzZXJ2ZWQgd2hlbiBnZW5lcmF0aW5nIGFuZCByZWNvZ25pemluZyBVUkxzLlxyXG4gKlxyXG4gKiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBwcm92aWRlIGFuIGBBUFBfQkFTRV9IUkVGYCBvZiBgJy9teS9hcHAnYCBhbmQgY2FsbFxyXG4gKiBgbG9jYXRpb24uZ28oJy9mb28nKWAsIHRoZSBicm93c2VyJ3MgVVJMIHdpbGwgYmVjb21lXHJcbiAqIGBleGFtcGxlLmNvbS9teS9hcHAvZm9vYC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnQsIHByb3ZpZGV9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtcclxuICogICBBUFBfQkFTRV9IUkVGXHJcbiAqICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBSb3V0ZUNvbmZpZyxcclxuICogICBMb2NhdGlvblxyXG4gKiB9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgY29uc3RydWN0b3IobG9jYXRpb246IExvY2F0aW9uKSB7XHJcbiAqICAgICBsb2NhdGlvbi5nbygnL2ZvbycpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBbXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUywgLy8gaW5jbHVkZXMgYmluZGluZyB0byBQYXRoTG9jYXRpb25TdHJhdGVneVxyXG4gKiAgIHByb3ZpZGUoQVBQX0JBU0VfSFJFRiwge3VzZVZhbHVlOiAnL215L2FwcCd9KVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgUGF0aExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhdGhMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGF0aExvY2F0aW9uU3RyYXRlZ3koKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRMb2NhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRIaXN0b3J5KCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRCYXNlSHJlZigpO1xyXG4gICAgfVxyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5nZXRHbG9iYWxFdmVudFRhcmdldCgnd2luZG93JykuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmbiwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmOyB9O1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uX3N0cmF0ZWd5XzEubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fbG9jYXRpb24uc2VhcmNoKTsgfTtcclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCAodXJsICsgbG9jYXRpb25fc3RyYXRlZ3lfMS5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpKTtcclxuICAgIH07XHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5mb3J3YXJkKCk7IH07XHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5iYWNrKCk7IH07XHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGFuZ3VsYXIyXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgUGF0aExvY2F0aW9uU3RyYXRlZ3kpO1xyXG4gICAgcmV0dXJuIFBhdGhMb2NhdGlvblN0cmF0ZWd5O1xyXG59KShsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3kpO1xyXG5leHBvcnRzLlBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhfbG9jYXRpb25fc3RyYXRlZ3kuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciB1cmxfcGFyc2VyXzEgPSByZXF1aXJlKCcuL3VybF9wYXJzZXInKTtcclxudmFyIGluc3RydWN0aW9uXzEgPSByZXF1aXJlKCcuL2luc3RydWN0aW9uJyk7XHJcbnZhciBUb3VjaE1hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUb3VjaE1hcChtYXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgdGhpcy5rZXlzID0ge307XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWFwKSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKG1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1hcFtrZXldID0gbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmtleXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRvdWNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZGVsZXRlKHRoaXMua2V5cywga2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XTtcclxuICAgIH07XHJcbiAgICBUb3VjaE1hcC5wcm90b3R5cGUuZ2V0VW51c2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVudXNlZCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBrZXlzID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIua2V5cyh0aGlzLmtleXMpO1xyXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB1bnVzZWRba2V5XSA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChfdGhpcy5tYXAsIGtleSk7IH0pO1xyXG4gICAgICAgIHJldHVybiB1bnVzZWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRvdWNoTWFwO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmcob2JqKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XHJcbnZhciBDb250aW51YXRpb25TZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRpbnVhdGlvblNlZ21lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB9XHJcbiAgICBDb250aW51YXRpb25TZWdtZW50LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuICcnOyB9O1xyXG4gICAgQ29udGludWF0aW9uU2VnbWVudC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIHJldHVybiBDb250aW51YXRpb25TZWdtZW50O1xyXG59KSgpO1xyXG52YXIgU3RhdGljU2VnbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdGF0aWNTZWdtZW50KHBhdGgpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgfVxyXG4gICAgU3RhdGljU2VnbWVudC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aCA9PSB0aGlzLnBhdGg7IH07XHJcbiAgICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHRoaXMucGF0aDsgfTtcclxuICAgIHJldHVybiBTdGF0aWNTZWdtZW50O1xyXG59KSgpO1xyXG52YXIgRHluYW1pY1NlZ21lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHluYW1pY1NlZ21lbnQobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgICBEeW5hbWljU2VnbWVudC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5sZW5ndGggPiAwOyB9O1xyXG4gICAgRHluYW1pY1NlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIGlmICghY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMocGFyYW1zLm1hcCwgdGhpcy5uYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJSb3V0ZSBnZW5lcmF0b3IgZm9yICdcIiArIHRoaXMubmFtZSArIFwiJyB3YXMgbm90IGluY2x1ZGVkIGluIHBhcmFtZXRlcnMgcGFzc2VkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZyhwYXJhbXMuZ2V0KHRoaXMubmFtZSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEeW5hbWljU2VnbWVudDtcclxufSkoKTtcclxudmFyIFN0YXJTZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXJTZWdtZW50KG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgfVxyXG4gICAgU3RhclNlZ21lbnQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICBTdGFyU2VnbWVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBub3JtYWxpemVTdHJpbmcocGFyYW1zLmdldCh0aGlzLm5hbWUpKTsgfTtcclxuICAgIHJldHVybiBTdGFyU2VnbWVudDtcclxufSkoKTtcclxudmFyIHBhcmFtTWF0Y2hlciA9IC9eOihbXlxcL10rKSQvZztcclxudmFyIHdpbGRjYXJkTWF0Y2hlciA9IC9eXFwqKFteXFwvXSspJC9nO1xyXG5mdW5jdGlvbiBwYXJzZVBhdGhTdHJpbmcocm91dGUpIHtcclxuICAgIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXHJcbiAgICAvLyBhbHNvIG5vcm1hbGl6ZS5cclxuICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKHJvdXRlLCBcIi9cIikpIHtcclxuICAgICAgICByb3V0ZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN1YnN0cmluZyhyb3V0ZSwgMSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2VnbWVudHMgPSBzcGxpdEJ5U2xhc2gocm91dGUpO1xyXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgIHZhciBzcGVjaWZpY2l0eSA9IDA7XHJcbiAgICAvLyBUaGUgXCJzcGVjaWZpY2l0eVwiIG9mIGEgcGF0aCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCByb3V0ZSBpcyB1c2VkIHdoZW4gbXVsdGlwbGUgcm91dGVzIG1hdGNoXHJcbiAgICAvLyBhIFVSTC5cclxuICAgIC8vIFN0YXRpYyBzZWdtZW50cyAobGlrZSBcIi9mb29cIikgYXJlIHRoZSBtb3N0IHNwZWNpZmljLCBmb2xsb3dlZCBieSBkeW5hbWljIHNlZ21lbnRzIChsaWtlXHJcbiAgICAvLyBcIi86aWRcIikuIFN0YXIgc2VnbWVudHNcclxuICAgIC8vIGFkZCBubyBzcGVjaWZpY2l0eS4gU2VnbWVudHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIGFyZSBtb3JlIHNwZWNpZmljIHRoYW4gcHJvY2VlZGluZyBvbmVzLlxyXG4gICAgLy8gVGhlIGNvZGUgYmVsb3cgdXNlcyBwbGFjZSB2YWx1ZXMgdG8gY29tYmluZSB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIHNlZ21lbnRzIGludG8gYSBzaW5nbGVcclxuICAgIC8vIGludGVnZXIgdGhhdCB3ZSBjYW5cclxuICAgIC8vIHNvcnQgbGF0ZXIuIEVhY2ggc3RhdGljIHNlZ21lbnQgaXMgd29ydGggaHVuZHJlZHMgb2YgcG9pbnRzIG9mIHNwZWNpZmljaXR5ICgxMDAwMCwgOTkwMCwgLi4uLFxyXG4gICAgLy8gMjAwKSwgYW5kIGVhY2hcclxuICAgIC8vIGR5bmFtaWMgc2VnbWVudCBpcyB3b3J0aCBzaW5nbGUgcG9pbnRzIG9mIHNwZWNpZmljaXR5ICgxMDAsIDk5LCAuLi4gMikuXHJcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gOTgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCInXCIgKyByb3V0ZSArIFwiJyBoYXMgbW9yZSB0aGFuIHRoZSBtYXhpbXVtIHN1cHBvcnRlZCBudW1iZXIgb2Ygc2VnbWVudHMuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxpbWl0ID0gc2VnbWVudHMubGVuZ3RoIC0gMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxpbWl0OyBpKyspIHtcclxuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLCBtYXRjaDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2gocGFyYW1NYXRjaGVyLCBzZWdtZW50KSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBEeW5hbWljU2VnbWVudChtYXRjaFsxXSkpO1xyXG4gICAgICAgICAgICBzcGVjaWZpY2l0eSArPSAoMTAwIC0gaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2ggPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKHdpbGRjYXJkTWF0Y2hlciwgc2VnbWVudCkpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgU3RhclNlZ21lbnQobWF0Y2hbMV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PSAnLi4uJykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIChtYXRza28pOiBzZXR1cCBhIHByb3BlciBlcnJvciBoZXJlIGBcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgXFxcIi4uLlxcXCIgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHBhdGggZm9yIFxcXCJcIiArIHJvdXRlICsgXCJcXFwiLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IENvbnRpbnVhdGlvblNlZ21lbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IFN0YXRpY1NlZ21lbnQoc2VnbWVudCkpO1xyXG4gICAgICAgICAgICBzcGVjaWZpY2l0eSArPSAxMDAgKiAoMTAwIC0gaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSgpO1xyXG4gICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHJlc3VsdCwgJ3NlZ21lbnRzJywgcmVzdWx0cyk7XHJcbiAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQocmVzdWx0LCAnc3BlY2lmaWNpdHknLCBzcGVjaWZpY2l0eSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJvdXRlIGNvbmZpZyBwYXRoIGxpa2UgYC9mb28vOmlkYCBjb2xsaWRlcyB3aXRoXHJcbi8vIGAvZm9vLzpuYW1lYFxyXG5mdW5jdGlvbiBwYXRoRHNsSGFzaChzZWdtZW50cykge1xyXG4gICAgcmV0dXJuIHNlZ21lbnRzLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgU3RhclNlZ21lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcqJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIENvbnRpbnVhdGlvblNlZ21lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuLi4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRHluYW1pY1NlZ21lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc6JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIFN0YXRpY1NlZ21lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQucGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC5qb2luKCcvJyk7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRCeVNsYXNoKHVybCkge1xyXG4gICAgcmV0dXJuIHVybC5zcGxpdCgnLycpO1xyXG59XHJcbnZhciBSRVNFUlZFRF9DSEFSUyA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnLy98XFxcXCh8XFxcXCl8O3xcXFxcP3w9Jyk7XHJcbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xyXG4gICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNvbnRhaW5zKHBhdGgsICcjJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJQYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgc2hvdWxkIG5vdCBpbmNsdWRlIFxcXCIjXFxcIi4gVXNlIFxcXCJIYXNoTG9jYXRpb25TdHJhdGVneVxcXCIgaW5zdGVhZC5cIik7XHJcbiAgICB9XHJcbiAgICB2YXIgaWxsZWdhbENoYXJhY3RlciA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goUkVTRVJWRURfQ0hBUlMsIHBhdGgpO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaWxsZWdhbENoYXJhY3RlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJQYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgY29udGFpbnMgXFxcIlwiICsgaWxsZWdhbENoYXJhY3RlclswXSArIFwiXFxcIiB3aGljaCBpcyBub3QgYWxsb3dlZCBpbiBhIHJvdXRlIGNvbmZpZy5cIik7XHJcbiAgICB9XHJcbn1cclxudmFyIFBhdGhNYXRjaCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXRoTWF0Y2goaW5zdHJ1Y3Rpb24sIHJlbWFpbmluZywgcmVtYWluaW5nQXV4KSB7XHJcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xyXG4gICAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nO1xyXG4gICAgICAgIHRoaXMucmVtYWluaW5nQXV4ID0gcmVtYWluaW5nQXV4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBhdGhNYXRjaDtcclxufSkoKTtcclxuZXhwb3J0cy5QYXRoTWF0Y2ggPSBQYXRoTWF0Y2g7XHJcbi8vIHJlcHJlc2VudHMgc29tZXRoaW5nIGxpa2UgJy9mb28vOmJhcidcclxudmFyIFBhdGhSZWNvZ25pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFRPRE86IGNhY2hlIGNvbXBvbmVudCBpbnN0cnVjdGlvbiBpbnN0YW5jZXMgYnkgcGFyYW1zIGFuZCBieSBQYXJzZWRVcmwgaW5zdGFuY2VcclxuICAgIGZ1bmN0aW9uIFBhdGhSZWNvZ25pemVyKHBhdGgsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIGFzc2VydFBhdGgocGF0aCk7XHJcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aFN0cmluZyhwYXRoKTtcclxuICAgICAgICB0aGlzLl9zZWdtZW50cyA9IHBhcnNlZFsnc2VnbWVudHMnXTtcclxuICAgICAgICB0aGlzLnNwZWNpZmljaXR5ID0gcGFyc2VkWydzcGVjaWZpY2l0eSddO1xyXG4gICAgICAgIHRoaXMuaGFzaCA9IHBhdGhEc2xIYXNoKHRoaXMuX3NlZ21lbnRzKTtcclxuICAgICAgICB2YXIgbGFzdFNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICB0aGlzLnRlcm1pbmFsID0gIShsYXN0U2VnbWVudCBpbnN0YW5jZW9mIENvbnRpbnVhdGlvblNlZ21lbnQpO1xyXG4gICAgfVxyXG4gICAgUGF0aFJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uIChiZWdpbm5pbmdTZWdtZW50KSB7XHJcbiAgICAgICAgdmFyIG5leHRTZWdtZW50ID0gYmVnaW5uaW5nU2VnbWVudDtcclxuICAgICAgICB2YXIgY3VycmVudFNlZ21lbnQ7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uYWxQYXJhbXMgPSB7fTtcclxuICAgICAgICB2YXIgY2FwdHVyZWQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gbmV4dFNlZ21lbnQ7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgQ29udGludWF0aW9uU2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY3VycmVudFNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlZC5wdXNoKGN1cnJlbnRTZWdtZW50LnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0YXIgc2VnbWVudCBjb25zdW1lcyBhbGwgb2YgdGhlIHJlbWFpbmluZyBVUkwsIGluY2x1ZGluZyBtYXRyaXggcGFyYW1zXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIFN0YXJTZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25hbFBhcmFtc1tzZWdtZW50Lm5hbWVdID0gY3VycmVudFNlZ21lbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIER5bmFtaWNTZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25hbFBhcmFtc1tzZWdtZW50Lm5hbWVdID0gY3VycmVudFNlZ21lbnQucGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWdtZW50Lm1hdGNoKGN1cnJlbnRTZWdtZW50LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IGN1cnJlbnRTZWdtZW50LmNoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZWdtZW50Lm1hdGNoKCcnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGVybWluYWwgJiYgbGFuZ18xLmlzUHJlc2VudChuZXh0U2VnbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1cmxQYXRoID0gY2FwdHVyZWQuam9pbignLycpO1xyXG4gICAgICAgIHZhciBhdXhpbGlhcnk7XHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uO1xyXG4gICAgICAgIHZhciB1cmxQYXJhbXM7XHJcbiAgICAgICAgdmFyIGFsbFBhcmFtcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjdXJyZW50U2VnbWVudCkpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBjb21wb25lbnQsIHJlYWQgcXVlcnkgcGFyYW1zLiBPdGhlcndpc2UsIHJlYWQgbWF0cml4IHBhcmFtcy5cclxuICAgICAgICAgICAgdmFyIHBhcmFtc1NlZ21lbnQgPSBiZWdpbm5pbmdTZWdtZW50IGluc3RhbmNlb2YgdXJsX3BhcnNlcl8xLlJvb3RVcmwgPyBiZWdpbm5pbmdTZWdtZW50IDogY3VycmVudFNlZ21lbnQ7XHJcbiAgICAgICAgICAgIGFsbFBhcmFtcyA9IGxhbmdfMS5pc1ByZXNlbnQocGFyYW1zU2VnbWVudC5wYXJhbXMpID9cclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHBhcmFtc1NlZ21lbnQucGFyYW1zLCBwb3NpdGlvbmFsUGFyYW1zKSA6XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbmFsUGFyYW1zO1xyXG4gICAgICAgICAgICB1cmxQYXJhbXMgPSB1cmxfcGFyc2VyXzEuc2VyaWFsaXplUGFyYW1zKHBhcmFtc1NlZ21lbnQucGFyYW1zKTtcclxuICAgICAgICAgICAgYXV4aWxpYXJ5ID0gY3VycmVudFNlZ21lbnQuYXV4aWxpYXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWxsUGFyYW1zID0gcG9zaXRpb25hbFBhcmFtcztcclxuICAgICAgICAgICAgYXV4aWxpYXJ5ID0gW107XHJcbiAgICAgICAgICAgIHVybFBhcmFtcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0cnVjdGlvbiA9IHRoaXMuX2dldEluc3RydWN0aW9uKHVybFBhdGgsIHVybFBhcmFtcywgdGhpcywgYWxsUGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBhdGhNYXRjaChpbnN0cnVjdGlvbiwgbmV4dFNlZ21lbnQsIGF1eGlsaWFyeSk7XHJcbiAgICB9O1xyXG4gICAgUGF0aFJlY29nbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBwYXJhbVRva2VucyA9IG5ldyBUb3VjaE1hcChwYXJhbXMpO1xyXG4gICAgICAgIHZhciBwYXRoID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIShzZWdtZW50IGluc3RhbmNlb2YgQ29udGludWF0aW9uU2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChzZWdtZW50LmdlbmVyYXRlKHBhcmFtVG9rZW5zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybFBhdGggPSBwYXRoLmpvaW4oJy8nKTtcclxuICAgICAgICB2YXIgbm9uUG9zaXRpb25hbFBhcmFtcyA9IHBhcmFtVG9rZW5zLmdldFVudXNlZCgpO1xyXG4gICAgICAgIHZhciB1cmxQYXJhbXMgPSB1cmxfcGFyc2VyXzEuc2VyaWFsaXplUGFyYW1zKG5vblBvc2l0aW9uYWxQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnN0cnVjdGlvbih1cmxQYXRoLCB1cmxQYXJhbXMsIHRoaXMsIHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgUGF0aFJlY29nbml6ZXIucHJvdG90eXBlLl9nZXRJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh1cmxQYXRoLCB1cmxQYXJhbXMsIF9yZWNvZ25pemVyLCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgaGFzaEtleSA9IHVybFBhdGggKyAnPycgKyB1cmxQYXJhbXMuam9pbignPycpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoaGFzaEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmdldChoYXNoS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uID0gbmV3IGluc3RydWN0aW9uXzEuQ29tcG9uZW50SW5zdHJ1Y3Rpb25fKHVybFBhdGgsIHVybFBhcmFtcywgX3JlY29nbml6ZXIsIHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGhhc2hLZXksIGluc3RydWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhdGhSZWNvZ25pemVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlBhdGhSZWNvZ25pemVyID0gUGF0aFJlY29nbml6ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhfcmVjb2duaXplci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIHJvdXRlX2NvbmZpZ19pbXBsXzEgPSByZXF1aXJlKCcuL3JvdXRlX2NvbmZpZ19pbXBsJyk7XHJcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS91dGlsL2RlY29yYXRvcnMnKTtcclxudmFyIHJvdXRlX2NvbmZpZ19pbXBsXzIgPSByZXF1aXJlKCcuL3JvdXRlX2NvbmZpZ19pbXBsJyk7XHJcbmV4cG9ydHMuUm91dGUgPSByb3V0ZV9jb25maWdfaW1wbF8yLlJvdXRlO1xyXG5leHBvcnRzLlJlZGlyZWN0ID0gcm91dGVfY29uZmlnX2ltcGxfMi5SZWRpcmVjdDtcclxuZXhwb3J0cy5BdXhSb3V0ZSA9IHJvdXRlX2NvbmZpZ19pbXBsXzIuQXV4Um91dGU7XHJcbmV4cG9ydHMuQXN5bmNSb3V0ZSA9IHJvdXRlX2NvbmZpZ19pbXBsXzIuQXN5bmNSb3V0ZTtcclxuZXhwb3J0cy5Sb3V0ZUNvbmZpZyA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKHJvdXRlX2NvbmZpZ19pbXBsXzEuUm91dGVDb25maWcpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZV9jb25maWdfZGVjb3JhdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFRoZSBgUm91dGVDb25maWdgIGRlY29yYXRvciBkZWZpbmVzIHJvdXRlcyBmb3IgYSBnaXZlbiBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEl0IHRha2VzIGFuIGFycmF5IG9mIHtAbGluayBSb3V0ZURlZmluaXRpb259cy5cclxuICovXHJcbnZhciBSb3V0ZUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZUNvbmZpZyhjb25maWdzKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWdzID0gY29uZmlncztcclxuICAgIH1cclxuICAgIFJvdXRlQ29uZmlnID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0FycmF5XSlcclxuICAgIF0sIFJvdXRlQ29uZmlnKTtcclxuICAgIHJldHVybiBSb3V0ZUNvbmZpZztcclxufSkoKTtcclxuZXhwb3J0cy5Sb3V0ZUNvbmZpZyA9IFJvdXRlQ29uZmlnO1xyXG4vKipcclxuICogYFJvdXRlYCBpcyBhIHR5cGUgb2Yge0BsaW5rIFJvdXRlRGVmaW5pdGlvbn0gdXNlZCB0byByb3V0ZSBhIHBhdGggdG8gYSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEl0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqIC0gYHBhdGhgIGlzIGEgc3RyaW5nIHRoYXQgdXNlcyB0aGUgcm91dGUgbWF0Y2hlciBEU0wuXHJcbiAqIC0gYGNvbXBvbmVudGAgYSBjb21wb25lbnQgdHlwZS5cclxuICogLSBgYXNgIGlzIGFuIG9wdGlvbmFsIGBDYW1lbENhc2VgIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIHJvdXRlLlxyXG4gKiAtIGBkYXRhYCBpcyBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiBhbnkgdHlwZSByZXByZXNlbnRpbmcgYXJiaXRyYXJ5IHJvdXRlIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW5cclxuICogcm91dGUuIEl0IGlzIGluamVjdGFibGUgdmlhIHRoZSB7QGxpbmsgUk9VVEVfREFUQX0gdG9rZW4uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Um91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICAge3BhdGg6ICcvaG9tZScsIGNvbXBvbmVudDogSG9tZUNtcCwgYXM6ICdIb21lQ21wJyB9XHJcbiAqIF0pXHJcbiAqIGNsYXNzIE15QXBwIHt9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFJvdXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlKF9hKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBfYS5wYXRoLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGFzID0gX2EuYXMsIGRhdGEgPSBfYS5kYXRhO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5hcyA9IGFzO1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VG8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgICBSb3V0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgUm91dGUpO1xyXG4gICAgcmV0dXJuIFJvdXRlO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlID0gUm91dGU7XHJcbi8qKlxyXG4gKiBgQXV4Um91dGVgIGlzIGEgdHlwZSBvZiB7QGxpbmsgUm91dGVEZWZpbml0aW9ufSB1c2VkIHRvIGRlZmluZSBhbiBhdXhpbGlhcnkgcm91dGUuXHJcbiAqXHJcbiAqIEl0IHRha2VzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogLSBgcGF0aGAgaXMgYSBzdHJpbmcgdGhhdCB1c2VzIHRoZSByb3V0ZSBtYXRjaGVyIERTTC5cclxuICogLSBgY29tcG9uZW50YCBhIGNvbXBvbmVudCB0eXBlLlxyXG4gKiAtIGBhc2AgaXMgYW4gb3B0aW9uYWwgYENhbWVsQ2FzZWAgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgcm91dGUuXHJcbiAqIC0gYGRhdGFgIGlzIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIGFueSB0eXBlIHJlcHJlc2VudGluZyBhcmJpdHJhcnkgcm91dGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlblxyXG4gKiByb3V0ZS4gSXQgaXMgaW5qZWN0YWJsZSB2aWEgdGhlIHtAbGluayBST1VURV9EQVRBfSB0b2tlbi5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtSb3V0ZUNvbmZpZywgQXV4Um91dGV9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICAgbmV3IEF1eFJvdXRlKHtwYXRoOiAnL2hvbWUnLCBjb21wb25lbnQ6IEhvbWVDbXB9KVxyXG4gKiBdKVxyXG4gKiBjbGFzcyBNeUFwcCB7fVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBBdXhSb3V0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdXhSb3V0ZShfYSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gX2EucGF0aCwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBhcyA9IF9hLmFzO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgLy8gYWRkZWQgbmV4dCB0d28gcHJvcGVydGllcyB0byB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQxMDdcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWRpcmVjdFRvID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuYXMgPSBhcztcclxuICAgIH1cclxuICAgIEF1eFJvdXRlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBBdXhSb3V0ZSk7XHJcbiAgICByZXR1cm4gQXV4Um91dGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXV4Um91dGUgPSBBdXhSb3V0ZTtcclxuLyoqXHJcbiAqIGBBc3luY1JvdXRlYCBpcyBhIHR5cGUgb2Yge0BsaW5rIFJvdXRlRGVmaW5pdGlvbn0gdXNlZCB0byByb3V0ZSBhIHBhdGggdG8gYW4gYXN5bmNocm9ub3VzbHlcclxuICogbG9hZGVkIGNvbXBvbmVudC5cclxuICpcclxuICogSXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogLSBgcGF0aGAgaXMgYSBzdHJpbmcgdGhhdCB1c2VzIHRoZSByb3V0ZSBtYXRjaGVyIERTTC5cclxuICogLSBgbG9hZGVyYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbXBvbmVudC5cclxuICogLSBgYXNgIGlzIGFuIG9wdGlvbmFsIGBDYW1lbENhc2VgIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIHJvdXRlLlxyXG4gKiAtIGBkYXRhYCBpcyBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiBhbnkgdHlwZSByZXByZXNlbnRpbmcgYXJiaXRyYXJ5IHJvdXRlIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW5cclxuICogcm91dGUuIEl0IGlzIGluamVjdGFibGUgdmlhIHRoZSB7QGxpbmsgUk9VVEVfREFUQX0gdG9rZW4uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Um91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICAge3BhdGg6ICcvaG9tZScsIGxvYWRlcjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKE15TG9hZGVkQ21wKSwgYXM6ICdNeUxvYWRlZENtcCd9XHJcbiAqIF0pXHJcbiAqIGNsYXNzIE15QXBwIHt9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEFzeW5jUm91dGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXN5bmNSb3V0ZShfYSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gX2EucGF0aCwgbG9hZGVyID0gX2EubG9hZGVyLCBhcyA9IF9hLmFzLCBkYXRhID0gX2EuZGF0YTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuYXMgPSBhcztcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgQXN5bmNSb3V0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgQXN5bmNSb3V0ZSk7XHJcbiAgICByZXR1cm4gQXN5bmNSb3V0ZTtcclxufSkoKTtcclxuZXhwb3J0cy5Bc3luY1JvdXRlID0gQXN5bmNSb3V0ZTtcclxuLyoqXHJcbiAqIGBSZWRpcmVjdGAgaXMgYSB0eXBlIG9mIHtAbGluayBSb3V0ZURlZmluaXRpb259IHVzZWQgdG8gcm91dGUgYSBwYXRoIHRvIGFuIGFzeW5jaHJvbm91c2x5IGxvYWRlZFxyXG4gKiBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEl0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqIC0gYHBhdGhgIGlzIGEgc3RyaW5nIHRoYXQgdXNlcyB0aGUgcm91dGUgbWF0Y2hlciBEU0wuXHJcbiAqIC0gYHJlZGlyZWN0VG9gIGlzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmV3IFVSTCB0byBiZSBtYXRjaGVkIGFnYWluc3QuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Um91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICAge3BhdGg6ICcvJywgcmVkaXJlY3RUbzogJy9ob21lJ30sXHJcbiAqICAge3BhdGg6ICcvaG9tZScsIGNvbXBvbmVudDogSG9tZUNtcH1cclxuICogXSlcclxuICogY2xhc3MgTXlBcHAge31cclxuICogYGBgXHJcbiAqL1xyXG52YXIgUmVkaXJlY3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVkaXJlY3QoX2EpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IF9hLnBhdGgsIHJlZGlyZWN0VG8gPSBfYS5yZWRpcmVjdFRvO1xyXG4gICAgICAgIHRoaXMuYXMgPSBudWxsO1xyXG4gICAgICAgIC8vIGFkZGVkIG5leHQgcHJvcGVydHkgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80MTA3XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VG8gPSByZWRpcmVjdFRvO1xyXG4gICAgfVxyXG4gICAgUmVkaXJlY3QgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIFJlZGlyZWN0KTtcclxuICAgIHJldHVybiBSZWRpcmVjdDtcclxufSkoKTtcclxuZXhwb3J0cy5SZWRpcmVjdCA9IFJlZGlyZWN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZV9jb25maWdfaW1wbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMSA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX2RlY29yYXRvcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbi8qKlxyXG4gKiBHaXZlbiBhIEpTIE9iamVjdCB0aGF0IHJlcHJlc2VudHMuLi4gcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgUm91dGUsIEFzeW5jUm91dGUsIG9yIFJlZGlyZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZUNvbmZpZyhjb25maWcpIHtcclxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuUm91dGUgfHwgY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLlJlZGlyZWN0IHx8IGNvbmZpZyBpbnN0YW5jZW9mIHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Bc3luY1JvdXRlIHx8XHJcbiAgICAgICAgY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLkF1eFJvdXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIGlmICgoKyEhY29uZmlnLmNvbXBvbmVudCkgKyAoKyEhY29uZmlnLnJlZGlyZWN0VG8pICsgKCshIWNvbmZpZy5sb2FkZXIpICE9IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJSb3V0ZSBjb25maWcgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgXFxcImNvbXBvbmVudFxcXCIsIFxcXCJsb2FkZXJcXFwiLCBvciBcXFwicmVkaXJlY3RUb1xcXCIgcHJvcGVydHkuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5sb2FkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Bc3luY1JvdXRlKHsgcGF0aDogY29uZmlnLnBhdGgsIGxvYWRlcjogY29uZmlnLmxvYWRlciwgYXM6IGNvbmZpZy5hcyB9KTtcclxuICAgIH1cclxuICAgIGlmIChjb25maWcuY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuY29tcG9uZW50ID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnREZWZpbml0aW9uT2JqZWN0ID0gY29uZmlnLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudERlZmluaXRpb25PYmplY3QudHlwZSA9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Sb3V0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY29uZmlnLnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnREZWZpbml0aW9uT2JqZWN0LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGFzOiBjb25maWcuYXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudERlZmluaXRpb25PYmplY3QudHlwZSA9PSAnbG9hZGVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuQXN5bmNSb3V0ZSh7IHBhdGg6IGNvbmZpZy5wYXRoLCBsb2FkZXI6IGNvbXBvbmVudERlZmluaXRpb25PYmplY3QubG9hZGVyLCBhczogY29uZmlnLmFzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiSW52YWxpZCBjb21wb25lbnQgdHlwZSBcXFwiXCIgKyBjb21wb25lbnREZWZpbml0aW9uT2JqZWN0LnR5cGUgKyBcIlxcXCIuIFZhbGlkIHR5cGVzIGFyZSBcXFwiY29uc3RydWN0b3JcXFwiIGFuZCBcXFwibG9hZGVyXFxcIi5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuUm91dGUoY29uZmlnKTtcclxuICAgIH1cclxuICAgIGlmIChjb25maWcucmVkaXJlY3RUbykge1xyXG4gICAgICAgIHJldHVybiBuZXcgcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLlJlZGlyZWN0KHsgcGF0aDogY29uZmlnLnBhdGgsIHJlZGlyZWN0VG86IGNvbmZpZy5yZWRpcmVjdFRvIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5leHBvcnRzLm5vcm1hbGl6ZVJvdXRlQ29uZmlnID0gbm9ybWFsaXplUm91dGVDb25maWc7XHJcbmZ1bmN0aW9uIGFzc2VydENvbXBvbmVudEV4aXN0cyhjb21wb25lbnQsIHBhdGgpIHtcclxuICAgIGlmICghbGFuZ18xLmlzVHlwZShjb21wb25lbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50IGZvciByb3V0ZSBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLCBvciBpcyBub3QgYSBjbGFzcy5cIik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hc3NlcnRDb21wb25lbnRFeGlzdHMgPSBhc3NlcnRDb21wb25lbnRFeGlzdHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX2NvbmZpZ19ub21hbGl6ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBhbmd1bGFyMl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvYW5ndWxhcjInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmV4cG9ydHMuUk9VVEVfREFUQSA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBhbmd1bGFyMl8xLk9wYXF1ZVRva2VuKCdyb3V0ZURhdGEnKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX2RhdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX2RlZmluaXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMSA9IHJlcXVpcmUoJy4vbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGwnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG5mdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKGUsIHR5cGUpIHtcclxuICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBsYW5nXzEuVHlwZSkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGUubmFtZSBpbiB0eXBlLnByb3RvdHlwZTtcclxufVxyXG5leHBvcnRzLmhhc0xpZmVjeWNsZUhvb2sgPSBoYXNMaWZlY3ljbGVIb29rO1xyXG5mdW5jdGlvbiBnZXRDYW5BY3RpdmF0ZUhvb2sodHlwZSkge1xyXG4gICAgdmFyIGFubm90YXRpb25zID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xyXG4gICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMS5DYW5BY3RpdmF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbi5mbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnRzLmdldENhbkFjdGl2YXRlSG9vayA9IGdldENhbkFjdGl2YXRlSG9vaztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIHBhdGhfcmVjb2duaXplcl8xID0gcmVxdWlyZSgnLi9wYXRoX3JlY29nbml6ZXInKTtcclxudmFyIHJvdXRlX2NvbmZpZ19pbXBsXzEgPSByZXF1aXJlKCcuL3JvdXRlX2NvbmZpZ19pbXBsJyk7XHJcbnZhciBhc3luY19yb3V0ZV9oYW5kbGVyXzEgPSByZXF1aXJlKCcuL2FzeW5jX3JvdXRlX2hhbmRsZXInKTtcclxudmFyIHN5bmNfcm91dGVfaGFuZGxlcl8xID0gcmVxdWlyZSgnLi9zeW5jX3JvdXRlX2hhbmRsZXInKTtcclxudmFyIHVybF9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vdXJsX3BhcnNlcicpO1xyXG4vKipcclxuICogYFJvdXRlUmVjb2duaXplcmAgaXMgcmVzcG9uc2libGUgZm9yIHJlY29nbml6aW5nIHJvdXRlcyBmb3IgYSBzaW5nbGUgY29tcG9uZW50LlxyXG4gKiBJdCBpcyBjb25zdW1lZCBieSBgUm91dGVSZWdpc3RyeWAsIHdoaWNoIGtub3dzIGhvdyB0byByZWNvZ25pemUgYW4gZW50aXJlIGhpZXJhcmNoeSBvZlxyXG4gKiBjb21wb25lbnRzLlxyXG4gKi9cclxudmFyIFJvdXRlUmVjb2duaXplciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZVJlY29nbml6ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5hdXhSb3V0ZXMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXMgaW50byBhIHRyaWVcclxuICAgICAgICB0aGlzLm1hdGNoZXJzID0gW107XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpcyBpbnRvIGEgdHJpZVxyXG4gICAgICAgIHRoaXMucmVkaXJlY3RzID0gW107XHJcbiAgICB9XHJcbiAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICB2YXIgaGFuZGxlcjtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb25maWcuYXMpICYmIGNvbmZpZy5hc1swXS50b1VwcGVyQ2FzZSgpICE9IGNvbmZpZy5hc1swXSkge1xyXG4gICAgICAgICAgICB2YXIgc3VnZ2VzdGVkQWxpYXMgPSBjb25maWcuYXNbMF0udG9VcHBlckNhc2UoKSArIGNvbmZpZy5hcy5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlJvdXRlICdcIiArIGNvbmZpZy5wYXRoICsgXCInIHdpdGggYWxpYXMgJ1wiICsgY29uZmlnLmFzICsgXCInIGRvZXMgbm90IGJlZ2luIHdpdGggYW4gdXBwZXJjYXNlIGxldHRlci4gUm91dGUgYWxpYXNlcyBzaG91bGQgYmUgQ2FtZWxDYXNlIGxpa2UgJ1wiICsgc3VnZ2VzdGVkQWxpYXMgKyBcIicuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5BdXhSb3V0ZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyID0gbmV3IHN5bmNfcm91dGVfaGFuZGxlcl8xLlN5bmNSb3V0ZUhhbmRsZXIoY29uZmlnLmNvbXBvbmVudCwgY29uZmlnLmRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGgoY29uZmlnLnBhdGgsICcvJykgPyBjb25maWcucGF0aC5zdWJzdHJpbmcoMSkgOiBjb25maWcucGF0aDtcclxuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgcGF0aF9yZWNvZ25pemVyXzEuUGF0aFJlY29nbml6ZXIoY29uZmlnLnBhdGgsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmF1eFJvdXRlcy5zZXQocGF0aCwgcmVjb2duaXplcik7XHJcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyLnRlcm1pbmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5SZWRpcmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0cy5wdXNoKG5ldyBSZWRpcmVjdG9yKGNvbmZpZy5wYXRoLCBjb25maWcucmVkaXJlY3RUbykpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIHJvdXRlX2NvbmZpZ19pbXBsXzEuUm91dGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IG5ldyBzeW5jX3JvdXRlX2hhbmRsZXJfMS5TeW5jUm91dGVIYW5kbGVyKGNvbmZpZy5jb21wb25lbnQsIGNvbmZpZy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5Bc3luY1JvdXRlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIgPSBuZXcgYXN5bmNfcm91dGVfaGFuZGxlcl8xLkFzeW5jUm91dGVIYW5kbGVyKGNvbmZpZy5sb2FkZXIsIGNvbmZpZy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgcGF0aF9yZWNvZ25pemVyXzEuUGF0aFJlY29nbml6ZXIoY29uZmlnLnBhdGgsIGhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMubWF0Y2hlcnMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hlcikge1xyXG4gICAgICAgICAgICBpZiAocmVjb2duaXplci5oYXNoID09IG1hdGNoZXIuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29uZmlndXJhdGlvbiAnXCIgKyBjb25maWcucGF0aCArIFwiJyBjb25mbGljdHMgd2l0aCBleGlzdGluZyByb3V0ZSAnXCIgKyBtYXRjaGVyLnBhdGggKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hdGNoZXJzLnB1c2gocmVjb2duaXplcik7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29uZmlnLmFzKSkge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWVzLnNldChjb25maWcuYXMsIHJlY29nbml6ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb2duaXplci50ZXJtaW5hbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJMLCByZXR1cm5zIGEgbGlzdCBvZiBgUm91dGVNYXRjaGBlcywgd2hpY2ggYXJlIHBhcnRpYWwgcmVjb2duaXRpb25zIGZvciBzb21lIHJvdXRlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5yZWNvZ25pemUgPSBmdW5jdGlvbiAodXJsUGFyc2UpIHtcclxuICAgICAgICB2YXIgc29sdXRpb25zID0gW107XHJcbiAgICAgICAgdXJsUGFyc2UgPSB0aGlzLl9yZWRpcmVjdCh1cmxQYXJzZSk7XHJcbiAgICAgICAgdGhpcy5tYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoUmVjb2duaXplcikge1xyXG4gICAgICAgICAgICB2YXIgcGF0aE1hdGNoID0gcGF0aFJlY29nbml6ZXIucmVjb2duaXplKHVybFBhcnNlKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGF0aE1hdGNoKSkge1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2gocGF0aE1hdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fcmVkaXJlY3QgPSBmdW5jdGlvbiAodXJsUGFyc2UpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVkaXJlY3RzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciByZWRpcmVjdG9yID0gdGhpcy5yZWRpcmVjdHNbaV07XHJcbiAgICAgICAgICAgIHZhciByZWRpcmVjdGVkVXJsID0gcmVkaXJlY3Rvci5yZWRpcmVjdCh1cmxQYXJzZSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHJlZGlyZWN0ZWRVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVkaXJlY3RlZFVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsUGFyc2U7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5yZWNvZ25pemVBdXhpbGlhcnkgPSBmdW5jdGlvbiAodXJsUGFyc2UpIHtcclxuICAgICAgICB2YXIgcGF0aFJlY29nbml6ZXIgPSB0aGlzLmF1eFJvdXRlcy5nZXQodXJsUGFyc2UucGF0aCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGhSZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGhSZWNvZ25pemVyLnJlY29nbml6ZSh1cmxQYXJzZSk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5oYXNSb3V0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLm5hbWVzLmhhcyhuYW1lKTsgfTtcclxuICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIHBhdGhSZWNvZ25pemVyID0gdGhpcy5uYW1lcy5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGhSZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGhSZWNvZ25pemVyLmdlbmVyYXRlKHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJvdXRlUmVjb2duaXplcjtcclxufSkoKTtcclxuZXhwb3J0cy5Sb3V0ZVJlY29nbml6ZXIgPSBSb3V0ZVJlY29nbml6ZXI7XHJcbnZhciBSZWRpcmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZGlyZWN0b3IocGF0aCwgcmVkaXJlY3RUbykge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnRvU2VnbWVudHMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aChwYXRoLCAnLycpKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aChyZWRpcmVjdFRvLCAnLycpKSB7XHJcbiAgICAgICAgICAgIHJlZGlyZWN0VG8gPSByZWRpcmVjdFRvLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b1NlZ21lbnRzID0gcmVkaXJlY3RUby5zcGxpdCgnLycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGBudWxsYCBvciBhIGBQYXJzZWRVcmxgIHJlcHJlc2VudGluZyB0aGUgbmV3IHBhdGggdG8gbWF0Y2hcclxuICAgICAqL1xyXG4gICAgUmVkaXJlY3Rvci5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAodXJsUGFyc2UpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHVybFBhcnNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc2VnbWVudCAhPSB1cmxQYXJzZS5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cmxQYXJzZSA9IHVybFBhcnNlLmNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50b1NlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy50b1NlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICB1cmxQYXJzZSA9IG5ldyB1cmxfcGFyc2VyXzEuVXJsKHNlZ21lbnQsIHVybFBhcnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybFBhcnNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWRpcmVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlZGlyZWN0b3IgPSBSZWRpcmVjdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZV9yZWNvZ25pemVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgcm91dGVfcmVjb2duaXplcl8xID0gcmVxdWlyZSgnLi9yb3V0ZV9yZWNvZ25pemVyJyk7XHJcbnZhciBpbnN0cnVjdGlvbl8xID0gcmVxdWlyZSgnLi9pbnN0cnVjdGlvbicpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgcm91dGVfY29uZmlnX2ltcGxfMSA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX2ltcGwnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgYW5ndWxhcjJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbnZhciByb3V0ZV9jb25maWdfbm9tYWxpemVyXzEgPSByZXF1aXJlKCcuL3JvdXRlX2NvbmZpZ19ub21hbGl6ZXInKTtcclxudmFyIHVybF9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vdXJsX3BhcnNlcicpO1xyXG52YXIgX3Jlc29sdmVUb051bGwgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUobnVsbCk7XHJcbi8qKlxyXG4gKiBUaGUgUm91dGVSZWdpc3RyeSBob2xkcyByb3V0ZSBjb25maWd1cmF0aW9ucyBmb3IgZWFjaCBjb21wb25lbnQgaW4gYW4gQW5ndWxhciBhcHAuXHJcbiAqIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBJbnN0cnVjdGlvbnMgZnJvbSBVUkxzLCBhbmQgZ2VuZXJhdGluZyBVUkxzIGJhc2VkIG9uIHJvdXRlIGFuZFxyXG4gKiBwYXJhbWV0ZXJzLlxyXG4gKi9cclxudmFyIFJvdXRlUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUm91dGVSZWdpc3RyeSgpIHtcclxuICAgICAgICB0aGlzLl9ydWxlcyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29tcG9uZW50IGFuZCBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhZGQgdGhlIHJvdXRlIHRvIHRoaXMgcmVnaXN0cnlcclxuICAgICAqL1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnID0gcm91dGVfY29uZmlnX25vbWFsaXplcl8xLm5vcm1hbGl6ZVJvdXRlQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBoZXJlIGJlY2F1c2UgRGFydCB0eXBlIGd1YXJkIHJlYXNvbnNcclxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5Sb3V0ZSkge1xyXG4gICAgICAgICAgICByb3V0ZV9jb25maWdfbm9tYWxpemVyXzEuYXNzZXJ0Q29tcG9uZW50RXhpc3RzKGNvbmZpZy5jb21wb25lbnQsIGNvbmZpZy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5BdXhSb3V0ZSkge1xyXG4gICAgICAgICAgICByb3V0ZV9jb25maWdfbm9tYWxpemVyXzEuYXNzZXJ0Q29tcG9uZW50RXhpc3RzKGNvbmZpZy5jb21wb25lbnQsIGNvbmZpZy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLl9ydWxlcy5nZXQocGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVjb2duaXplcikpIHtcclxuICAgICAgICAgICAgcmVjb2duaXplciA9IG5ldyByb3V0ZV9yZWNvZ25pemVyXzEuUm91dGVSZWNvZ25pemVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bGVzLnNldChwYXJlbnRDb21wb25lbnQsIHJlY29nbml6ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGVybWluYWwgPSByZWNvZ25pemVyLmNvbmZpZyhjb25maWcpO1xyXG4gICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLlJvdXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0VGVybWluYWxDb21wb25lbnQoY29uZmlnLmNvbXBvbmVudCwgY29uZmlnLnBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdGcm9tQ29tcG9uZW50KGNvbmZpZy5jb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIGFubm90YXRpb25zIG9mIGEgY29tcG9uZW50IGFuZCBjb25maWd1cmVzIHRoZSByZWdpc3RyeSBiYXNlZCBvbiB0aGVtXHJcbiAgICAgKi9cclxuICAgIFJvdXRlUmVnaXN0cnkucHJvdG90eXBlLmNvbmZpZ0Zyb21Db21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1R5cGUoY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvbid0IHJlYWQgdGhlIGFubm90YXRpb25zIGZyb20gYSB0eXBlIG1vcmUgdGhhbiBvbmNlIOKAk1xyXG4gICAgICAgIC8vIHRoaXMgcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCBpZiBhIGNvbXBvbmVudCByb3V0ZXMgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgaWYgKHRoaXMuX3J1bGVzLmhhcyhjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5hbm5vdGF0aW9ucyhjb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFubm90YXRpb25zKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLlJvdXRlQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlQ2ZncyA9IGFubm90YXRpb24uY29uZmlncztcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUNmZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7IHJldHVybiBfdGhpcy5jb25maWcoY29tcG9uZW50LCBjb25maWcpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJMIGFuZCBhIHBhcmVudCBjb21wb25lbnQsIHJldHVybiB0aGUgbW9zdCBzcGVjaWZpYyBpbnN0cnVjdGlvbiBmb3IgbmF2aWdhdGluZ1xyXG4gICAgICogdGhlIGFwcGxpY2F0aW9uIGludG8gdGhlIHN0YXRlIHNwZWNpZmllZCBieSB0aGUgdXJsXHJcbiAgICAgKi9cclxuICAgIFJvdXRlUmVnaXN0cnkucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uICh1cmwsIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBwYXJzZWRVcmwgPSB1cmxfcGFyc2VyXzEucGFyc2VyLnBhcnNlKHVybCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShwYXJzZWRVcmwsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuX3JlY29nbml6ZSA9IGZ1bmN0aW9uIChwYXJzZWRVcmwsIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZVByaW1hcnlSb3V0ZShwYXJzZWRVcmwsIHBhcmVudENvbXBvbmVudClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGxldGVBdXhpbGlhcnlSb3V0ZU1hdGNoZXMoaW5zdHJ1Y3Rpb24sIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuX3JlY29nbml6ZVByaW1hcnlSb3V0ZSA9IGZ1bmN0aW9uIChwYXJzZWRVcmwsIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlY29nbml6ZXIgPSB0aGlzLl9ydWxlcy5nZXQocGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcG9uZW50UmVjb2duaXplcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9OdWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYXRjaGVzIHNvbWUgYmVnaW5uaW5nIHBhcnQgb2YgdGhlIGdpdmVuIFVSTFxyXG4gICAgICAgIHZhciBwb3NzaWJsZU1hdGNoZXMgPSBjb21wb25lbnRSZWNvZ25pemVyLnJlY29nbml6ZShwYXJzZWRVcmwpO1xyXG4gICAgICAgIHZhciBtYXRjaFByb21pc2VzID0gcG9zc2libGVNYXRjaGVzLm1hcChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7IHJldHVybiBfdGhpcy5fY29tcGxldGVQcmltYXJ5Um91dGVNYXRjaChjYW5kaWRhdGUpOyB9KTtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwobWF0Y2hQcm9taXNlcykudGhlbihtb3N0U3BlY2lmaWMpO1xyXG4gICAgfTtcclxuICAgIFJvdXRlUmVnaXN0cnkucHJvdG90eXBlLl9jb21wbGV0ZVByaW1hcnlSb3V0ZU1hdGNoID0gZnVuY3Rpb24gKHBhcnRpYWxNYXRjaCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uID0gcGFydGlhbE1hdGNoLmluc3RydWN0aW9uO1xyXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbi5yZXNvbHZlQ29tcG9uZW50VHlwZSgpLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgX3RoaXMuY29uZmlnRnJvbUNvbXBvbmVudChjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnRlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluc3RydWN0aW9uXzEuUHJpbWFyeUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBudWxsLCBwYXJ0aWFsTWF0Y2gucmVtYWluaW5nQXV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlY29nbml6ZVByaW1hcnlSb3V0ZShwYXJ0aWFsTWF0Y2gucmVtYWluaW5nLCBjb21wb25lbnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNoaWxkSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjaGlsZEluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVjdGlvbl8xLlByaW1hcnlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgY2hpbGRJbnN0cnVjdGlvbiwgcGFydGlhbE1hdGNoLnJlbWFpbmluZ0F1eCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJvdXRlUmVnaXN0cnkucHJvdG90eXBlLl9jb21wbGV0ZUF1eGlsaWFyeVJvdXRlTWF0Y2hlcyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvTnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlY29nbml6ZXIgPSB0aGlzLl9ydWxlcy5nZXQocGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB2YXIgYXV4SW5zdHJ1Y3Rpb25zID0ge307XHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gaW5zdHJ1Y3Rpb24uYXV4VXJscy5tYXAoZnVuY3Rpb24gKGF1eFNlZ21lbnQpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gY29tcG9uZW50UmVjb2duaXplci5yZWNvZ25pemVBdXhpbGlhcnkoYXV4U2VnbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXRjaCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvTnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBsZXRlUHJpbWFyeVJvdXRlTWF0Y2gobWF0Y2gpLnRoZW4oZnVuY3Rpb24gKGF1eEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdXhJbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBsZXRlQXV4aWxpYXJ5Um91dGVNYXRjaGVzKGF1eEluc3RydWN0aW9uLCBwYXJlbnRDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmaW5pc2hlZEF1eFJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1eEluc3RydWN0aW9uc1thdXhTZWdtZW50LnBhdGhdID0gZmluaXNoZWRBdXhSb3V0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnN0cnVjdGlvbi5jaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbihpbnN0cnVjdGlvbi5jb21wb25lbnQsIG51bGwsIGF1eEluc3RydWN0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21wbGV0ZUF1eGlsaWFyeVJvdXRlTWF0Y2hlcyhpbnN0cnVjdGlvbi5jaGlsZCwgaW5zdHJ1Y3Rpb24uY29tcG9uZW50LmNvbXBvbmVudFR5cGUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcGxldGVDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKGluc3RydWN0aW9uLmNvbXBvbmVudCwgY29tcGxldGVDaGlsZCwgYXV4SW5zdHJ1Y3Rpb25zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIG5vcm1hbGl6ZWQgbGlzdCB3aXRoIGNvbXBvbmVudCBuYW1lcyBhbmQgcGFyYW1zIGxpa2U6IGBbJ3VzZXInLCB7aWQ6IDMgfV1gXHJcbiAgICAgKiBnZW5lcmF0ZXMgYSB1cmwgd2l0aCBhIGxlYWRpbmcgc2xhc2ggcmVsYXRpdmUgdG8gdGhlIHByb3ZpZGVkIGBwYXJlbnRDb21wb25lbnRgLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChsaW5rUGFyYW1zLCBwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICB2YXIgY29tcG9uZW50Q3Vyc29yID0gcGFyZW50Q29tcG9uZW50O1xyXG4gICAgICAgIHZhciBsYXN0SW5zdHJ1Y3Rpb25Jc1Rlcm1pbmFsID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rUGFyYW1zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbGlua1BhcmFtc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBvbmVudEN1cnNvcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBmaW5kIHJvdXRlIG5hbWVkIFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbGFuZ18xLmlzU3RyaW5nKHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbmV4cGVjdGVkIHNlZ21lbnQgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIiBpbiBsaW5rIERTTC4gRXhwZWN0ZWQgYSBzdHJpbmcuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlZ21lbnQgPT0gJycgfHwgc2VnbWVudCA9PSAnLicgfHwgc2VnbWVudCA9PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJcXFwiXCIgKyBzZWdtZW50ICsgXCIvXFxcIiBpcyBvbmx5IGFsbG93ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmsgRFNMLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGxpbmtQYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBsaW5rUGFyYW1zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmdNYXAobmV4dFNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbmV4dFNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWNvZ25pemVyID0gdGhpcy5fcnVsZXMuZ2V0KGNvbXBvbmVudEN1cnNvcik7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnRSZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50IFxcXCJcIiArIGxhbmdfMS5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyhjb21wb25lbnRDdXJzb3IpICsgXCJcXFwiIGhhcyBubyByb3V0ZSBjb25maWcuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGNvbXBvbmVudFJlY29nbml6ZXIuZ2VuZXJhdGUoc2VnbWVudCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50IFxcXCJcIiArIGxhbmdfMS5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyhjb21wb25lbnRDdXJzb3IpICsgXCJcXFwiIGhhcyBubyByb3V0ZSBuYW1lZCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgY29tcG9uZW50Q3Vyc29yID0gcmVzcG9uc2UuY29tcG9uZW50VHlwZTtcclxuICAgICAgICAgICAgbGFzdEluc3RydWN0aW9uSXNUZXJtaW5hbCA9IHJlc3BvbnNlLnRlcm1pbmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIGlmICghbGFzdEluc3RydWN0aW9uSXNUZXJtaW5hbCkge1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHRoaXMuX2dlbmVyYXRlUmVkaXJlY3RzKGNvbXBvbmVudEN1cnNvcik7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQobGFzdEluc3RydWN0aW9uLmNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbnN0cnVjdGlvbiA9IGxhc3RJbnN0cnVjdGlvbi5jaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RJbnN0cnVjdGlvbklzVGVybWluYWwgPSBsYXN0SW5zdHJ1Y3Rpb24uY29tcG9uZW50LnRlcm1pbmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBvbmVudEN1cnNvcikgJiYgIWxhc3RJbnN0cnVjdGlvbklzVGVybWluYWwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkxpbmsgXFxcIlwiICsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnRvSlNPTihsaW5rUGFyYW1zKSArIFwiXFxcIiBkb2VzIG5vdCByZXNvbHZlIHRvIGEgdGVybWluYWwgb3IgYXN5bmMgaW5zdHJ1Y3Rpb24uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gbmV3IGluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oc2VnbWVudHMucG9wKCksIGluc3RydWN0aW9uLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcclxuICAgIH07XHJcbiAgICAvLyBpZiB0aGUgY2hpbGQgaW5jbHVkZXMgYSByZWRpcmVjdCBsaWtlIDogXCIvXCIgLT4gXCIvc29tZXRoaW5nXCIsXHJcbiAgICAvLyB3ZSB3YW50IHRvIGhvbm9yIHRoYXQgcmVkaXJlY3Rpb24gd2hlbiBjcmVhdGluZyB0aGUgbGlua1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuX2dlbmVyYXRlUmVkaXJlY3RzID0gZnVuY3Rpb24gKGNvbXBvbmVudEN1cnNvcikge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnRDdXJzb3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcG9uZW50UmVjb2duaXplciA9IHRoaXMuX3J1bGVzLmdldChjb21wb25lbnRDdXJzb3IpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnRSZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRSZWNvZ25pemVyLnJlZGlyZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgcmVkaXJlY3QgPSBjb21wb25lbnRSZWNvZ25pemVyLnJlZGlyZWN0c1tpXTtcclxuICAgICAgICAgICAgLy8gd2Ugb25seSBoYW5kbGUgcmVkaXJlY3RpbmcgZnJvbSBhbiBlbXB0eSBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdC5zZWdtZW50cy5sZW5ndGggPT0gMSAmJiByZWRpcmVjdC5zZWdtZW50c1swXSA9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvU2VnbWVudHMgPSB1cmxfcGFyc2VyXzEucGF0aFNlZ21lbnRzVG9VcmwocmVkaXJlY3QudG9TZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudFJlY29nbml6ZXIucmVjb2duaXplKHRvU2VnbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlJbnN0cnVjdGlvbiA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5tYXhpbXVtKG1hdGNoZXMsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gbWF0Y2guaW5zdHJ1Y3Rpb24uc3BlY2lmaWNpdHk7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJpbWFyeUluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2dlbmVyYXRlUmVkaXJlY3RzKHByaW1hcnlJbnN0cnVjdGlvbi5pbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24ocHJpbWFyeUluc3RydWN0aW9uLmluc3RydWN0aW9uLCBjaGlsZCwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWdpc3RyeSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGFuZ3VsYXIyXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgUm91dGVSZWdpc3RyeSk7XHJcbiAgICByZXR1cm4gUm91dGVSZWdpc3RyeTtcclxufSkoKTtcclxuZXhwb3J0cy5Sb3V0ZVJlZ2lzdHJ5ID0gUm91dGVSZWdpc3RyeTtcclxuLypcclxuICogR2l2ZW4gYSBsaXN0IG9mIGluc3RydWN0aW9ucywgcmV0dXJucyB0aGUgbW9zdCBzcGVjaWZpYyBpbnN0cnVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gbW9zdFNwZWNpZmljKGluc3RydWN0aW9ucykge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5tYXhpbXVtKGluc3RydWN0aW9ucywgZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7IHJldHVybiBpbnN0cnVjdGlvbi5jb21wb25lbnQuc3BlY2lmaWNpdHk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydFRlcm1pbmFsQ29tcG9uZW50KGNvbXBvbmVudCwgcGF0aCkge1xyXG4gICAgaWYgKCFsYW5nXzEuaXNUeXBlKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGNvbXBvbmVudCk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhbm5vdGF0aW9ucykpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5Sb3V0ZUNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2hpbGQgcm91dGVzIGFyZSBub3QgYWxsb3dlZCBmb3IgXFxcIlwiICsgcGF0aCArIFwiXFxcIi4gVXNlIFxcXCIuLi5cXFwiIG9uIHRoZSBwYXJlbnQncyByb3V0ZSBwYXRoLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZV9yZWdpc3RyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGluc3RydWN0aW9uXzEgPSByZXF1aXJlKCcuL2luc3RydWN0aW9uJyk7XHJcbnZhciByb3V0ZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEgPSByZXF1aXJlKCcuL3JvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3InKTtcclxudmFyIF9yZXNvbHZlVG9UcnVlID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKHRydWUpO1xyXG52YXIgX3Jlc29sdmVUb0ZhbHNlID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKGZhbHNlKTtcclxuLyoqXHJcbiAqIFRoZSBgUm91dGVyYCBpcyByZXNwb25zaWJsZSBmb3IgbWFwcGluZyBVUkxzIHRvIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gc2VlIHRoZSBzdGF0ZSBvZiB0aGUgcm91dGVyIGJ5IGluc3BlY3RpbmcgdGhlIHJlYWQtb25seSBmaWVsZCBgcm91dGVyLm5hdmlnYXRpbmdgLlxyXG4gKiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIHNob3dpbmcgYSBzcGlubmVyLCBmb3IgaW5zdGFuY2UuXHJcbiAqXHJcbiAqICMjIENvbmNlcHRzXHJcbiAqXHJcbiAqIFJvdXRlcnMgYW5kIGNvbXBvbmVudCBpbnN0YW5jZXMgaGF2ZSBhIDE6MSBjb3JyZXNwb25kZW5jZS5cclxuICpcclxuICogVGhlIHJvdXRlciBob2xkcyByZWZlcmVuY2UgdG8gYSBudW1iZXIgb2Yge0BsaW5rIFJvdXRlck91dGxldH0uXHJcbiAqIEFuIG91dGxldCBpcyBhIHBsYWNlaG9sZGVyIHRoYXQgdGhlIHJvdXRlciBkeW5hbWljYWxseSBmaWxscyBpbiBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgVVJMLlxyXG4gKlxyXG4gKiBXaGVuIHRoZSByb3V0ZXIgbmF2aWdhdGVzIGZyb20gYSBVUkwsIGl0IG11c3QgZmlyc3QgcmVjb2duaXplIGl0IGFuZCBzZXJpYWxpemUgaXQgaW50byBhblxyXG4gKiBgSW5zdHJ1Y3Rpb25gLlxyXG4gKiBUaGUgcm91dGVyIHVzZXMgdGhlIGBSb3V0ZVJlZ2lzdHJ5YCB0byBnZXQgYW4gYEluc3RydWN0aW9uYC5cclxuICovXHJcbnZhciBSb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUm91dGVyKHJlZ2lzdHJ5LCBwYXJlbnQsIGhvc3RDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ob3N0Q29tcG9uZW50ID0gaG9zdENvbXBvbmVudDtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnROYXZpZ2F0aW9uID0gX3Jlc29sdmVUb1RydWU7XHJcbiAgICAgICAgdGhpcy5fb3V0bGV0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hdXhSb3V0ZXJzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBjaGlsZCByb3V0ZXIuIFlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzIHVubGVzcyB5b3UncmUgd3JpdGluZyBhIHJldXNhYmxlXHJcbiAgICAgKiBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuY2hpbGRSb3V0ZXIgPSBmdW5jdGlvbiAoaG9zdENvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZFJvdXRlciA9IG5ldyBDaGlsZFJvdXRlcih0aGlzLCBob3N0Q29tcG9uZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBjaGlsZCByb3V0ZXIuIFlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzIHVubGVzcyB5b3UncmUgd3JpdGluZyBhIHJldXNhYmxlXHJcbiAgICAgKiBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuYXV4Um91dGVyID0gZnVuY3Rpb24gKGhvc3RDb21wb25lbnQpIHsgcmV0dXJuIG5ldyBDaGlsZFJvdXRlcih0aGlzLCBob3N0Q29tcG9uZW50KTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYW4gb3V0bGV0IHRvIG5vdGlmaWVkIG9mIHByaW1hcnkgcm91dGUgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcyB1bmxlc3MgeW91J3JlIHdyaXRpbmcgYSByZXVzYWJsZSBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVnaXN0ZXJQcmltYXJ5T3V0bGV0ID0gZnVuY3Rpb24gKG91dGxldCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG91dGxldC5uYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJyZWdpc3RlckF1eE91dGxldCBleHBlY3RzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIHVubmFtZWQgb3V0bGV0LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3V0bGV0ID0gb3V0bGV0O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWl0KHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3Jlc29sdmVUb1RydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhbiBvdXRsZXQgdG8gbm90aWZpZWQgb2YgYXV4aWxpYXJ5IHJvdXRlIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMgdW5sZXNzIHlvdSdyZSB3cml0aW5nIGEgcmV1c2FibGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlZ2lzdGVyQXV4T3V0bGV0ID0gZnVuY3Rpb24gKG91dGxldCkge1xyXG4gICAgICAgIHZhciBvdXRsZXROYW1lID0gb3V0bGV0Lm5hbWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG91dGxldE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcInJlZ2lzdGVyQXV4T3V0bGV0IGV4cGVjdHMgdG8gYmUgY2FsbGVkIHdpdGggYW4gb3V0bGV0IHdpdGggYSBuYW1lLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETy4uLlxyXG4gICAgICAgIC8vIHdoYXQgaXMgdGhlIGhvc3Qgb2YgYW4gYXV4IHJvdXRlPz8/XHJcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuYXV4Um91dGVyKHRoaXMuaG9zdENvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fYXV4Um91dGVycy5zZXQob3V0bGV0TmFtZSwgcm91dGVyKTtcclxuICAgICAgICByb3V0ZXIuX291dGxldCA9IG91dGxldDtcclxuICAgICAgICB2YXIgYXV4SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY3VycmVudEluc3RydWN0aW9uKSAmJlxyXG4gICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KGF1eEluc3RydWN0aW9uID0gdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmF1eEluc3RydWN0aW9uW291dGxldE5hbWVdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmNvbW1pdChhdXhJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGluc3RydWN0aW9uLCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5zdHJ1Y3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZSxcclxuICAgICAqIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmlzUm91dGVBY3RpdmUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcztcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChyb3V0ZXIucGFyZW50KSAmJiBsYW5nXzEuaXNQcmVzZW50KGluc3RydWN0aW9uLmNoaWxkKSkge1xyXG4gICAgICAgICAgICByb3V0ZXIgPSByb3V0ZXIucGFyZW50O1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLmNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbi5jb21wb25lbnQgPT0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRHluYW1pY2FsbHkgdXBkYXRlIHRoZSByb3V0aW5nIGNvbmZpZ3VyYXRpb24gYW5kIHRyaWdnZXIgYSBuYXZpZ2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqICMgVXNhZ2VcclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHJvdXRlci5jb25maWcoW1xyXG4gICAgICogICB7ICdwYXRoJzogJy8nLCAnY29tcG9uZW50JzogSW5kZXhDb21wIH0sXHJcbiAgICAgKiAgIHsgJ3BhdGgnOiAnL3VzZXIvOmlkJywgJ2NvbXBvbmVudCc6IFVzZXJDb21wIH0sXHJcbiAgICAgKiBdKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uIChkZWZpbml0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocm91dGVEZWZpbml0aW9uKSB7IF90aGlzLnJlZ2lzdHJ5LmNvbmZpZyhfdGhpcy5ob3N0Q29tcG9uZW50LCByb3V0ZURlZmluaXRpb24pOyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5hdmlnYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgUm91dGUgTGluayBEU0wuIEl0J3MgcHJlZmVycmVkIHRvIG5hdmlnYXRlIHdpdGggdGhpcyBtZXRob2RcclxuICAgICAqIG92ZXIgYG5hdmlnYXRlQnlVcmxgLlxyXG4gICAgICpcclxuICAgICAqICMgVXNhZ2VcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIFJvdXRlIExpbmsgRFNMOlxyXG4gICAgICogYGBgXHJcbiAgICAgKiBbJy4vTXlDbXAnLCB7cGFyYW06IDN9XVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBTZWUgdGhlIHtAbGluayBSb3V0ZXJMaW5rfSBkaXJlY3RpdmUgZm9yIG1vcmUuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAobGlua1BhcmFtcykge1xyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IHRoaXMuZ2VuZXJhdGUobGlua1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGVCeUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZSB0byBhIFVSTC4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIG5hdmlnYXRpb24gaXMgY29tcGxldGUuXHJcbiAgICAgKiBJdCdzIHByZWZlcnJlZCB0byBuYXZpZ2F0ZSB3aXRoIGBuYXZpZ2F0ZWAgaW5zdGVhZCBvZiB0aGlzIG1ldGhvZCwgc2luY2UgVVJMcyBhcmUgbW9yZSBicml0dGxlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBnaXZlbiBVUkwgYmVnaW5zIHdpdGggYSBgL2AsIHJvdXRlciB3aWxsIG5hdmlnYXRlIGFic29sdXRlbHkuXHJcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gVVJMIGRvZXMgbm90IGJlZ2luIHdpdGggYC9gLCB0aGUgcm91dGVyIHdpbGwgbmF2aWdhdGUgcmVsYXRpdmUgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVCeVVybCA9IGZ1bmN0aW9uICh1cmwsIF9za2lwTG9jYXRpb25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChfc2tpcExvY2F0aW9uQ2hhbmdlID09PSB2b2lkIDApIHsgX3NraXBMb2NhdGlvbkNoYW5nZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnROYXZpZ2F0aW9uID0gdGhpcy5fY3VycmVudE5hdmlnYXRpb24udGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICBfdGhpcy5sYXN0TmF2aWdhdGlvbkF0dGVtcHQgPSB1cmw7XHJcbiAgICAgICAgICAgIF90aGlzLl9zdGFydE5hdmlnYXRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hZnRlclByb21pc2VGaW5pc2hOYXZpZ2F0aW5nKF90aGlzLnJlY29nbml6ZSh1cmwpLnRoZW4oZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9uYXZpZ2F0ZShpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlIHZpYSB0aGUgcHJvdmlkZWQgaW5zdHJ1Y3Rpb24uIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBuYXZpZ2F0aW9uIGlzXHJcbiAgICAgKiBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJ5SW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIF9za2lwTG9jYXRpb25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChfc2tpcExvY2F0aW9uQ2hhbmdlID09PSB2b2lkIDApIHsgX3NraXBMb2NhdGlvbkNoYW5nZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Jlc29sdmVUb0ZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudE5hdmlnYXRpb24gPSB0aGlzLl9jdXJyZW50TmF2aWdhdGlvbi50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9zdGFydE5hdmlnYXRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hZnRlclByb21pc2VGaW5pc2hOYXZpZ2F0aW5nKF90aGlzLl9uYXZpZ2F0ZShpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX25hdmlnYXRlID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGxlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5fY2FuUmV1c2UoaW5zdHJ1Y3Rpb24pOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMuX2NhbkFjdGl2YXRlKGluc3RydWN0aW9uKTsgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2FuRGVhY3RpdmF0ZShpbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tbWl0KGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdE5hdmlnYXRpb25GaW5pc2goaW5zdHJ1Y3Rpb25fMS5zdHJpbmdpZnlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETyhidGZvcmQpOiBpdCdkIGJlIG5pY2UgdG8gcmVtb3ZlIHRoaXMgbWV0aG9kIGFzIHBhcnQgb2YgY2xlYW5pbmcgdXAgdGhlIHRyYXZlcnNhbCBsb2dpY1xyXG4gICAgLy8gU2luY2UgcmVmYWN0b3JpbmcgYFJvdXRlci5nZW5lcmF0ZWAgdG8gcmV0dXJuIGFuIGluc3RydWN0aW9uIHJhdGhlciB0aGFuIGEgc3RyaW5nLCBpdCdzIG5vdFxyXG4gICAgLy8gZ3VhcmFudGVlZCB0aGF0IHRoZSBgY29tcG9uZW50VHlwZWBzIGZvciB0aGUgdGVybWluYWwgYXN5bmMgcm91dGVzIGhhdmUgYmVlbiBsb2FkZWQgYnkgdGhlIHRpbWVcclxuICAgIC8vIHdlIGJlZ2luIG5hdmlnYXRpb24uIFRoZSBtZXRob2QgYmVsb3cgc2ltcGx5IHRyYXZlcnNlcyBpbnN0cnVjdGlvbnMgYW5kIHJlc29sdmVzIGFueSBjb21wb25lbnRzXHJcbiAgICAvLyBmb3Igd2hpY2ggYGNvbXBvbmVudFR5cGVgIGlzIG5vdCBwcmVzZW50XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLl9zZXR0bGVJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuc2V0dGxlZEluc3RydWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnN0cnVjdGlvbi5jb21wb25lbnQuY29tcG9uZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgdW5zZXR0bGVkSW5zdHJ1Y3Rpb25zLnB1c2goaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnJlc29sdmVDb21wb25lbnRUeXBlKCkudGhlbihmdW5jdGlvbiAodHlwZSkgeyBfdGhpcy5yZWdpc3RyeS5jb25maWdGcm9tQ29tcG9uZW50KHR5cGUpOyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGluc3RydWN0aW9uLmNoaWxkKSkge1xyXG4gICAgICAgICAgICB1bnNldHRsZWRJbnN0cnVjdGlvbnMucHVzaCh0aGlzLl9zZXR0bGVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbi5jaGlsZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGluc3RydWN0aW9uLmF1eEluc3RydWN0aW9uLCBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIF8pIHtcclxuICAgICAgICAgICAgdW5zZXR0bGVkSW5zdHJ1Y3Rpb25zLnB1c2goX3RoaXMuX3NldHRsZUluc3RydWN0aW9uKGluc3RydWN0aW9uKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKHVuc2V0dGxlZEluc3RydWN0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fZW1pdE5hdmlnYXRpb25GaW5pc2ggPSBmdW5jdGlvbiAodXJsKSB7IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQodGhpcy5fc3ViamVjdCwgdXJsKTsgfTtcclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2FmdGVyUHJvbWlzZUZpbmlzaE5hdmlnYXRpbmcgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuY2F0Y2hFcnJvcihwcm9taXNlLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLl9maW5pc2hOYXZpZ2F0aW5nKCk7IH0pLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9maW5pc2hOYXZpZ2F0aW5nKCk7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogUmVjdXJzaXZlbHkgc2V0IHJldXNlIGZsYWdzXHJcbiAgICAgKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NhblJldXNlID0gZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fb3V0bGV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Jlc29sdmVUb0ZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3V0bGV0LmNhblJldXNlKGluc3RydWN0aW9uLmNvbXBvbmVudClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21wb25lbnQucmV1c2UgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgbGFuZ18xLmlzUHJlc2VudChfdGhpcy5fY2hpbGRSb3V0ZXIpICYmIGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24uY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkUm91dGVyLl9jYW5SZXVzZShpbnN0cnVjdGlvbi5jaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLl9jYW5BY3RpdmF0ZSA9IGZ1bmN0aW9uIChuZXh0SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gY2FuQWN0aXZhdGVPbmUobmV4dEluc3RydWN0aW9uLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgfTtcclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NhbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9vdXRsZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHQ7XHJcbiAgICAgICAgdmFyIGNoaWxkSW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciByZXVzZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRJbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5jaGlsZDtcclxuICAgICAgICAgICAgY29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHJldXNlID0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnJldXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmV1c2UpIHtcclxuICAgICAgICAgICAgbmV4dCA9IF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dCA9IHRoaXMuX291dGxldC5jYW5EZWFjdGl2YXRlKGNvbXBvbmVudEluc3RydWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogYXV4IHJvdXRlIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIHJldHVybiBuZXh0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3RoaXMuX2NoaWxkUm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jaGlsZFJvdXRlci5fY2FuRGVhY3RpdmF0ZShjaGlsZEluc3RydWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyByb3V0ZXIgYW5kIGFsbCBkZXNjZW5kYW50IHJvdXRlcnMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBpbnN0cnVjdGlvblxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9za2lwTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBfc2tpcExvY2F0aW9uQ2hhbmdlID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcclxuICAgICAgICB2YXIgbmV4dCA9IF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX291dGxldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50SW5zdHJ1Y3Rpb24ucmV1c2UpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLl9vdXRsZXQucmV1c2UoY29tcG9uZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKGluc3RydWN0aW9uKS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5fb3V0bGV0LmFjdGl2YXRlKGNvbXBvbmVudEluc3RydWN0aW9uKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24uY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3RoaXMuX2NoaWxkUm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkUm91dGVyLmNvbW1pdChpbnN0cnVjdGlvbi5jaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5fYXV4Um91dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZXIsIG5hbWUpIHsgcHJvbWlzZXMucHVzaChyb3V0ZXIuY29tbWl0KGluc3RydWN0aW9uLmF1eEluc3RydWN0aW9uW25hbWVdKSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBuZXh0LnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKHByb21pc2VzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fc3RhcnROYXZpZ2F0aW5nID0gZnVuY3Rpb24gKCkgeyB0aGlzLm5hdmlnYXRpbmcgPSB0cnVlOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fZmluaXNoTmF2aWdhdGluZyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7IH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byBVUkwgdXBkYXRlcyBmcm9tIHRoZSByb3V0ZXJcclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob25OZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlKHRoaXMuX3N1YmplY3QsIG9uTmV4dCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdXRlcidzIG91dGxldCBhbmQgYWxsIGRlc2NlbmRhbnQgb3V0bGV0c1xyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjaGlsZEluc3RydWN0aW9uID0gbnVsbDtcclxuICAgICAgICB2YXIgY29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICBjaGlsZEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uY2hpbGQ7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dCA9IF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NoaWxkUm91dGVyKSkge1xyXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5fY2hpbGRSb3V0ZXIuZGVhY3RpdmF0ZShjaGlsZEluc3RydWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fb3V0bGV0KSkge1xyXG4gICAgICAgICAgICBuZXh0ID0gbmV4dC50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5fb3V0bGV0LmRlYWN0aXZhdGUoY29tcG9uZW50SW5zdHJ1Y3Rpb24pOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGF1eCByb3V0ZXNcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJMLCByZXR1cm5zIGFuIGluc3RydWN0aW9uIHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50IGdyYXBoXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnJlY29nbml6ZSh1cmwsIHRoaXMuaG9zdENvbXBvbmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gZWl0aGVyIHRoZSBsYXN0IFVSTCBzdWNjZXNzZnVsbHkgbmF2aWdhdGVkIHRvLCBvciB0aGUgbGFzdCBVUkwgcmVxdWVzdGVkIGlmIHRoZVxyXG4gICAgICogcm91dGVyIGhhcyB5ZXQgdG8gc3VjY2Vzc2Z1bGx5IG5hdmlnYXRlLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlbmF2aWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMubGFzdE5hdmlnYXRpb25BdHRlbXB0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudE5hdmlnYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5sYXN0TmF2aWdhdGlvbkF0dGVtcHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSBVUkwgZnJvbSBhIGNvbXBvbmVudCBuYW1lIGFuZCBvcHRpb25hbCBtYXAgb2YgcGFyYW1ldGVycy4gVGhlIFVSTCBpcyByZWxhdGl2ZSB0byB0aGVcclxuICAgICAqIGFwcCdzIGJhc2UgaHJlZi5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChsaW5rUGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRMaW5rUGFyYW1zID0gc3BsaXRBbmRGbGF0dGVuTGlua1BhcmFtcyhsaW5rUGFyYW1zKTtcclxuICAgICAgICB2YXIgZmlyc3QgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3Qobm9ybWFsaXplZExpbmtQYXJhbXMpO1xyXG4gICAgICAgIHZhciByZXN0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNsaWNlKG5vcm1hbGl6ZWRMaW5rUGFyYW1zLCAxKTtcclxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcztcclxuICAgICAgICAvLyBUaGUgZmlyc3Qgc2VnbWVudCBzaG91bGQgYmUgZWl0aGVyICcuJyAoZ2VuZXJhdGUgZnJvbSBwYXJlbnQpIG9yICcnIChnZW5lcmF0ZSBmcm9tIHJvb3QpLlxyXG4gICAgICAgIC8vIFdoZW4gd2Ugbm9ybWFsaXplIGFib3ZlLCB3ZSBzdHJpcCBhbGwgdGhlIHNsYXNoZXMsICcuLycgYmVjb21lcyAnLicgYW5kICcvJyBiZWNvbWVzICcnLlxyXG4gICAgICAgIGlmIChmaXJzdCA9PSAnJykge1xyXG4gICAgICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChyb3V0ZXIucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcm91dGVyID0gcm91dGVyLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmaXJzdCA9PSAnLi4nKSB7XHJcbiAgICAgICAgICAgIHJvdXRlciA9IHJvdXRlci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3QocmVzdCkgPT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5zbGljZShyZXN0LCAxKTtcclxuICAgICAgICAgICAgICAgIHJvdXRlciA9IHJvdXRlci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkxpbmsgXFxcIlwiICsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnRvSlNPTihsaW5rUGFyYW1zKSArIFwiXFxcIiBoYXMgdG9vIG1hbnkgXFxcIi4uL1xcXCIgc2VnbWVudHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ICE9ICcuJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJMaW5rIFxcXCJcIiArIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci50b0pTT04obGlua1BhcmFtcykgKyBcIlxcXCIgbXVzdCBzdGFydCB3aXRoIFxcXCIvXFxcIiwgXFxcIi4vXFxcIiwgb3IgXFxcIi4uL1xcXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN0W3Jlc3QubGVuZ3RoIC0gMV0gPT0gJycpIHtcclxuICAgICAgICAgICAgcmVzdC5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJMaW5rIFxcXCJcIiArIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci50b0pTT04obGlua1BhcmFtcykgKyBcIlxcXCIgbXVzdCBpbmNsdWRlIGEgcm91dGUgbmFtZS5cIjtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHN0cnVjdHVyYWwgY2xvbmluZyBhbmQgd2hhdG5vdFxyXG4gICAgICAgIHZhciB1cmwgPSBbXTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gcm91dGVyLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHVybC51bnNoaWZ0KHBhcmVudC5fY3VycmVudEluc3RydWN0aW9uKTtcclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHRJbnN0cnVjdGlvbiA9IHRoaXMucmVnaXN0cnkuZ2VuZXJhdGUocmVzdCwgcm91dGVyLmhvc3RDb21wb25lbnQpO1xyXG4gICAgICAgIHdoaWxlICh1cmwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBuZXh0SW5zdHJ1Y3Rpb24gPSB1cmwucG9wKCkucmVwbGFjZUNoaWxkKG5leHRJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0SW5zdHJ1Y3Rpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJvdXRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Sb3V0ZXIgPSBSb3V0ZXI7XHJcbnZhciBSb290Um91dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb290Um91dGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUm9vdFJvdXRlcihyZWdpc3RyeSwgbG9jYXRpb24sIHByaW1hcnlDb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHJlZ2lzdHJ5LCBudWxsLCBwcmltYXJ5Q29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLnN1YnNjcmliZShmdW5jdGlvbiAoY2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5uYXZpZ2F0ZUJ5VXJsKGNoYW5nZVsndXJsJ10sIGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlWydwb3AnXSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVnaXN0cnkuY29uZmlnRnJvbUNvbXBvbmVudChwcmltYXJ5Q29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLm5hdmlnYXRlQnlVcmwobG9jYXRpb24ucGF0aCgpKTtcclxuICAgIH1cclxuICAgIFJvb3RSb3V0ZXIucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9za2lwTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBfc2tpcExvY2F0aW9uQ2hhbmdlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgZW1pdFBhdGggPSBpbnN0cnVjdGlvbl8xLnN0cmluZ2lmeUluc3RydWN0aW9uUGF0aChpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgdmFyIGVtaXRRdWVyeSA9IGluc3RydWN0aW9uXzEuc3RyaW5naWZ5SW5zdHJ1Y3Rpb25RdWVyeShpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgaWYgKGVtaXRQYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZW1pdFBhdGggPSAnLycgKyBlbWl0UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBfc3VwZXIucHJvdG90eXBlLmNvbW1pdC5jYWxsKHRoaXMsIGluc3RydWN0aW9uKTtcclxuICAgICAgICBpZiAoIV9za2lwTG9jYXRpb25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoXykgeyBfdGhpcy5fbG9jYXRpb24uZ28oZW1pdFBhdGgsIGVtaXRRdWVyeSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm9vdFJvdXRlcjtcclxufSkoUm91dGVyKTtcclxuZXhwb3J0cy5Sb290Um91dGVyID0gUm9vdFJvdXRlcjtcclxudmFyIENoaWxkUm91dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDaGlsZFJvdXRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENoaWxkUm91dGVyKHBhcmVudCwgaG9zdENvbXBvbmVudCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudC5yZWdpc3RyeSwgcGFyZW50LCBob3N0Q29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIH1cclxuICAgIENoaWxkUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJ5VXJsID0gZnVuY3Rpb24gKHVybCwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIGlmIChfc2tpcExvY2F0aW9uQ2hhbmdlID09PSB2b2lkIDApIHsgX3NraXBMb2NhdGlvbkNoYW5nZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgLy8gRGVsZWdhdGUgbmF2aWdhdGlvbiB0byB0aGUgcm9vdCByb3V0ZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubmF2aWdhdGVCeVVybCh1cmwsIF9za2lwTG9jYXRpb25DaGFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENoaWxkUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJ5SW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIF9za2lwTG9jYXRpb25DaGFuZ2UpIHtcclxuICAgICAgICBpZiAoX3NraXBMb2NhdGlvbkNoYW5nZSA9PT0gdm9pZCAwKSB7IF9za2lwTG9jYXRpb25DaGFuZ2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIC8vIERlbGVnYXRlIG5hdmlnYXRpb24gdG8gdGhlIHJvb3Qgcm91dGVyXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5hdmlnYXRlQnlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENoaWxkUm91dGVyO1xyXG59KShSb3V0ZXIpO1xyXG4vKlxyXG4gKiBHaXZlbjogWycvYS9iJywge2M6IDJ9XVxyXG4gKiBSZXR1cm5zOiBbJycsICdhJywgJ2InLCB7YzogMn1dXHJcbiAqL1xyXG52YXIgU0xBU0ggPSBuZXcgUmVnRXhwKCcvJyk7XHJcbmZ1bmN0aW9uIHNwbGl0QW5kRmxhdHRlbkxpbmtQYXJhbXMobGlua1BhcmFtcykge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZWR1Y2UobGlua1BhcmFtcywgZnVuY3Rpb24gKGFjY3VtdWxhdGlvbiwgaXRlbSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGlvbi5jb25jYXQobGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQoaXRlbSwgU0xBU0gpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWNjdW11bGF0aW9uLnB1c2goaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGlvbjtcclxuICAgIH0sIFtdKTtcclxufVxyXG5mdW5jdGlvbiBjYW5BY3RpdmF0ZU9uZShuZXh0SW5zdHJ1Y3Rpb24sIHByZXZJbnN0cnVjdGlvbikge1xyXG4gICAgdmFyIG5leHQgPSBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5leHRJbnN0cnVjdGlvbi5jaGlsZCkpIHtcclxuICAgICAgICBuZXh0ID0gY2FuQWN0aXZhdGVPbmUobmV4dEluc3RydWN0aW9uLmNoaWxkLCBsYW5nXzEuaXNQcmVzZW50KHByZXZJbnN0cnVjdGlvbikgPyBwcmV2SW5zdHJ1Y3Rpb24uY2hpbGQgOiBudWxsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dEluc3RydWN0aW9uLmNvbXBvbmVudC5yZXVzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhvb2sgPSByb3V0ZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEuZ2V0Q2FuQWN0aXZhdGVIb29rKG5leHRJbnN0cnVjdGlvbi5jb21wb25lbnQuY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaG9vaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvb2sobmV4dEluc3RydWN0aW9uLmNvbXBvbmVudCwgbGFuZ18xLmlzUHJlc2VudChwcmV2SW5zdHJ1Y3Rpb24pID8gcHJldkluc3RydWN0aW9uLmNvbXBvbmVudCA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCcuLi9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciByb3V0ZXJfMSA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XHJcbnZhciBsb2NhdGlvbl8xID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpO1xyXG52YXIgaW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoJy4vaW5zdHJ1Y3Rpb24nKTtcclxuLyoqXHJcbiAqIFRoZSBSb3V0ZXJMaW5rIGRpcmVjdGl2ZSBsZXRzIHlvdSBsaW5rIHRvIHNwZWNpZmljIHBhcnRzIG9mIHlvdXIgYXBwLlxyXG4gKlxyXG4gKiBDb25zaWRlciB0aGUgZm9sbG93aW5nIHJvdXRlIGNvbmZpZ3VyYXRpb246XHJcblxyXG4gKiBgYGBcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogICB7IHBhdGg6ICcvdXNlcicsIGNvbXBvbmVudDogVXNlckNtcCwgYXM6ICdVc2VyJyB9XHJcbiAqIF0pO1xyXG4gKiBjbGFzcyBNeUNvbXAge31cclxuICogYGBgXHJcbiAqXHJcbiAqIFdoZW4gbGlua2luZyB0byB0aGlzIGBVc2VyYCByb3V0ZSwgeW91IGNhbiB3cml0ZTpcclxuICpcclxuICogYGBgXHJcbiAqIDxhIFtyb3V0ZXItbGlua109XCJbJy4vVXNlciddXCI+bGluayB0byB1c2VyIGNvbXBvbmVudDwvYT5cclxuICogYGBgXHJcbiAqXHJcbiAqIFJvdXRlckxpbmsgZXhwZWN0cyB0aGUgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb2Ygcm91dGUgbmFtZXMsIGZvbGxvd2VkIGJ5IHRoZSBwYXJhbXNcclxuICogZm9yIHRoYXQgbGV2ZWwgb2Ygcm91dGluZy4gRm9yIGluc3RhbmNlIGBbJy9UZWFtJywge3RlYW1JZDogMX0sICdVc2VyJywge3VzZXJJZDogMn1dYFxyXG4gKiBtZWFucyB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgYSBsaW5rIGZvciB0aGUgYFRlYW1gIHJvdXRlIHdpdGggcGFyYW1zIGB7dGVhbUlkOiAxfWAsXHJcbiAqIGFuZCB3aXRoIGEgY2hpbGQgcm91dGUgYFVzZXJgIHdpdGggcGFyYW1zIGB7dXNlcklkOiAyfWAuXHJcbiAqXHJcbiAqIFRoZSBmaXJzdCByb3V0ZSBuYW1lIHNob3VsZCBiZSBwcmVwZW5kZWQgd2l0aCBgL2AsIGAuL2AsIG9yIGAuLi9gLlxyXG4gKiBJZiB0aGUgcm91dGUgYmVnaW5zIHdpdGggYC9gLCB0aGUgcm91dGVyIHdpbGwgbG9vayB1cCB0aGUgcm91dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgYXBwLlxyXG4gKiBJZiB0aGUgcm91dGUgYmVnaW5zIHdpdGggYC4vYCwgdGhlIHJvdXRlciB3aWxsIGluc3RlYWQgbG9vayBpbiB0aGUgY3VycmVudCBjb21wb25lbnQnc1xyXG4gKiBjaGlsZHJlbiBmb3IgdGhlIHJvdXRlLiBBbmQgaWYgdGhlIHJvdXRlIGJlZ2lucyB3aXRoIGAuLi9gLCB0aGUgcm91dGVyIHdpbGwgbG9vayBhdCB0aGVcclxuICogY3VycmVudCBjb21wb25lbnQncyBwYXJlbnQuXHJcbiAqL1xyXG52YXIgUm91dGVyTGluayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZXJMaW5rKF9yb3V0ZXIsIF9sb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBfbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyTGluay5wcm90b3R5cGUsIFwiaXNSb3V0ZUFjdGl2ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXIuaXNSb3V0ZUFjdGl2ZSh0aGlzLl9uYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJyb3V0ZVBhcmFtc1wiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9yb3V0ZVBhcmFtcyA9IGNoYW5nZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX25hdmlnYXRpb25JbnN0cnVjdGlvbiA9IHRoaXMuX3JvdXRlci5nZW5lcmF0ZSh0aGlzLl9yb3V0ZVBhcmFtcyk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgdGhlIHJpZ2h0IHNwb3QgZm9yIHRoaXM/XHJcbiAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uSHJlZiA9ICcvJyArIGluc3RydWN0aW9uXzEuc3RyaW5naWZ5SW5zdHJ1Y3Rpb24odGhpcy5fbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlSHJlZiA9IHRoaXMuX2xvY2F0aW9uLm5vcm1hbGl6ZUFic29sdXRlbHkobmF2aWdhdGlvbkhyZWYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUm91dGVyTGluay5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGVCeUluc3RydWN0aW9uKHRoaXMuX25hdmlnYXRpb25JbnN0cnVjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFJvdXRlckxpbmsgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JvdXRlci1saW5rXScsXHJcbiAgICAgICAgICAgIGlucHV0czogWydyb3V0ZVBhcmFtczogcm91dGVyTGluayddLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdvbkNsaWNrKCknLFxyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmhyZWZdJzogJ3Zpc2libGVIcmVmJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3Mucm91dGVyLWxpbmstYWN0aXZlXSc6ICdpc1JvdXRlQWN0aXZlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JvdXRlcl8xLlJvdXRlciwgbG9jYXRpb25fMS5Mb2NhdGlvbl0pXHJcbiAgICBdLCBSb3V0ZXJMaW5rKTtcclxuICAgIHJldHVybiBSb3V0ZXJMaW5rO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlckxpbmsgPSBSb3V0ZXJMaW5rO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXJfbGluay5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgYW5ndWxhcjJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbnZhciByb3V0ZXJNb2QgPSByZXF1aXJlKCcuL3JvdXRlcicpO1xyXG52YXIgaW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoJy4vaW5zdHJ1Y3Rpb24nKTtcclxudmFyIHJvdXRlX2RhdGFfMSA9IHJlcXVpcmUoJy4vcm91dGVfZGF0YScpO1xyXG52YXIgaG9va01vZCA9IHJlcXVpcmUoJy4vbGlmZWN5Y2xlX2Fubm90YXRpb25zJyk7XHJcbnZhciByb3V0ZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEgPSByZXF1aXJlKCcuL3JvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3InKTtcclxudmFyIF9yZXNvbHZlVG9UcnVlID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKHRydWUpO1xyXG4vKipcclxuICogQSByb3V0ZXIgb3V0bGV0IGlzIGEgcGxhY2Vob2xkZXIgdGhhdCBBbmd1bGFyIGR5bmFtaWNhbGx5IGZpbGxzIGJhc2VkIG9uIHRoZSBhcHBsaWNhdGlvbidzIHJvdXRlLlxyXG4gKlxyXG4gKiAjIyBVc2VcclxuICpcclxuICogYGBgXHJcbiAqIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgUm91dGVyT3V0bGV0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlck91dGxldChfZWxlbWVudFJlZiwgX2xvYWRlciwgX3BhcmVudFJvdXRlciwgbmFtZUF0dHIpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gX2xvYWRlcjtcclxuICAgICAgICB0aGlzLl9wYXJlbnRSb3V0ZXIgPSBfcGFyZW50Um91dGVyO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5hbWVBdHRyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lQXR0cjtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Um91dGVyLnJlZ2lzdGVyQXV4T3V0bGV0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Um91dGVyLnJlZ2lzdGVyUHJpbWFyeU91dGxldCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBieSB0aGUgUm91dGVyIHRvIGluc3RhbnRpYXRlIGEgbmV3IGNvbXBvbmVudCBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBvZiBhIG5hdmlnYXRpb24uXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpbiB0dXJuIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBgb25BY3RpdmF0ZWAgaG9vayBvZiBpdHMgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAobmV4dEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJldmlvdXNJbnN0cnVjdGlvbiA9IHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24gPSBuZXh0SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFR5cGUgPSBuZXh0SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZTtcclxuICAgICAgICB2YXIgY2hpbGRSb3V0ZXIgPSB0aGlzLl9wYXJlbnRSb3V0ZXIuY2hpbGRSb3V0ZXIoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVycyA9IGFuZ3VsYXIyXzEuSW5qZWN0b3IucmVzb2x2ZShbXHJcbiAgICAgICAgICAgIGFuZ3VsYXIyXzEucHJvdmlkZShyb3V0ZV9kYXRhXzEuUk9VVEVfREFUQSwgeyB1c2VWYWx1ZTogbmV4dEluc3RydWN0aW9uLnJvdXRlRGF0YSgpIH0pLFxyXG4gICAgICAgICAgICBhbmd1bGFyMl8xLnByb3ZpZGUoaW5zdHJ1Y3Rpb25fMS5Sb3V0ZVBhcmFtcywgeyB1c2VWYWx1ZTogbmV3IGluc3RydWN0aW9uXzEuUm91dGVQYXJhbXMobmV4dEluc3RydWN0aW9uLnBhcmFtcykgfSksXHJcbiAgICAgICAgICAgIGFuZ3VsYXIyXzEucHJvdmlkZShyb3V0ZXJNb2QuUm91dGVyLCB7IHVzZVZhbHVlOiBjaGlsZFJvdXRlciB9KVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZE5leHRUb0xvY2F0aW9uKGNvbXBvbmVudFR5cGUsIHRoaXMuX2VsZW1lbnRSZWYsIHByb3ZpZGVycylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xyXG4gICAgICAgICAgICBfdGhpcy5fY29tcG9uZW50UmVmID0gY29tcG9uZW50UmVmO1xyXG4gICAgICAgICAgICBpZiAocm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9va01vZC5vbkFjdGl2YXRlLCBjb21wb25lbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2Uub25BY3RpdmF0ZShuZXh0SW5zdHJ1Y3Rpb24sIHByZXZpb3VzSW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgdGhlIHtAbGluayBSb3V0ZXJ9IGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIG9mIGEgbmF2aWdhdGlvbiB3aGVuIGFuIG91dGxldFxyXG4gICAgICogcmV1c2VzIGEgY29tcG9uZW50IGJldHdlZW4gZGlmZmVyZW50IHJvdXRlcy5cclxuICAgICAqIFRoaXMgbWV0aG9kIGluIHR1cm4gaXMgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgdGhlIGBvblJldXNlYCBob29rIG9mIGl0cyBjaGlsZC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uIChuZXh0SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNJbnN0cnVjdGlvbiA9IHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24gPSBuZXh0SW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2NvbXBvbmVudFJlZikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IHJldXNlIGFuIG91dGxldCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYSBjb21wb25lbnQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2tNb2Qub25SZXVzZSwgdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpID9cclxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLm9uUmV1c2UobmV4dEluc3RydWN0aW9uLCBwcmV2aW91c0luc3RydWN0aW9uKSA6XHJcbiAgICAgICAgICAgIHRydWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSB7QGxpbmsgUm91dGVyfSB3aGVuIGFuIG91dGxldCByZXVzZXMgYSBjb21wb25lbnQgYWNyb3NzIG5hdmlnYXRpb25zLlxyXG4gICAgICogVGhpcyBtZXRob2QgaW4gdHVybiBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgYG9uUmV1c2VgIGhvb2sgb2YgaXRzIGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAobmV4dEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbmV4dCA9IF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NvbXBvbmVudFJlZikgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pICYmXHJcbiAgICAgICAgICAgIHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2tNb2Qub25EZWFjdGl2YXRlLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZSh0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2Uub25EZWFjdGl2YXRlKG5leHRJbnN0cnVjdGlvbiwgdGhpcy5fY3VycmVudEluc3RydWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0LnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3RoaXMuX2NvbXBvbmVudFJlZikpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb21wb25lbnRSZWYuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBvbmVudFJlZiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBieSB0aGUge0BsaW5rIFJvdXRlcn0gZHVyaW5nIHJlY29nbml0aW9uIHBoYXNlIG9mIGEgbmF2aWdhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIHJlc29sdmVzIHRvIGBmYWxzZWAsIHRoZSBnaXZlbiBuYXZpZ2F0aW9uIGlzIGNhbmNlbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBkZWxlZ2F0ZXMgdG8gdGhlIGNoaWxkIGNvbXBvbmVudCdzIGBjYW5EZWFjdGl2YXRlYCBob29rIGlmIGl0IGV4aXN0cyxcclxuICAgICAqIGFuZCBvdGhlcndpc2UgcmVzb2x2ZXMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5jYW5EZWFjdGl2YXRlID0gZnVuY3Rpb24gKG5leHRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2tNb2QuY2FuRGVhY3RpdmF0ZSwgdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLmNhbkRlYWN0aXZhdGUobmV4dEluc3RydWN0aW9uLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSB7QGxpbmsgUm91dGVyfSBkdXJpbmcgcmVjb2duaXRpb24gcGhhc2Ugb2YgYSBuYXZpZ2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBuZXcgY2hpbGQgY29tcG9uZW50IGhhcyBhIGRpZmZlcmVudCBUeXBlIHRoYW4gdGhlIGV4aXN0aW5nIGNoaWxkIGNvbXBvbmVudCxcclxuICAgICAqIHRoaXMgd2lsbCByZXNvbHZlIHRvIGBmYWxzZWAuIFlvdSBjYW4ndCByZXVzZSBhbiBvbGQgY29tcG9uZW50IHdoZW4gdGhlIG5ldyBjb21wb25lbnRcclxuICAgICAqIGlzIG9mIGEgZGlmZmVyZW50IFR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBkZWxlZ2F0ZXMgdG8gdGhlIGNoaWxkIGNvbXBvbmVudCdzIGBjYW5SZXVzZWAgaG9vayBpZiBpdCBleGlzdHMsXHJcbiAgICAgKiBvciByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBob29rIGlzIG5vdCBwcmVzZW50LlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmNhblJldXNlID0gZnVuY3Rpb24gKG5leHRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikgfHxcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUgIT0gbmV4dEluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2tNb2QuY2FuUmV1c2UsIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY2FuUmV1c2UobmV4dEluc3RydWN0aW9uLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV4dEluc3RydWN0aW9uID09IHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgKGxhbmdfMS5pc1ByZXNlbnQobmV4dEluc3RydWN0aW9uLnBhcmFtcykgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24ucGFyYW1zKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmVxdWFscyhuZXh0SW5zdHJ1Y3Rpb24ucGFyYW1zLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24ucGFyYW1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXJPdXRsZXQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBhbmd1bGFyMl8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAncm91dGVyLW91dGxldCcgfSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBhbmd1bGFyMl8xLkF0dHJpYnV0ZSgnbmFtZScpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbYW5ndWxhcjJfMS5FbGVtZW50UmVmLCBhbmd1bGFyMl8xLkR5bmFtaWNDb21wb25lbnRMb2FkZXIsIHJvdXRlck1vZC5Sb3V0ZXIsIFN0cmluZ10pXHJcbiAgICBdLCBSb3V0ZXJPdXRsZXQpO1xyXG4gICAgcmV0dXJuIFJvdXRlck91dGxldDtcclxufSkoKTtcclxuZXhwb3J0cy5Sb3V0ZXJPdXRsZXQgPSBSb3V0ZXJPdXRsZXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlcl9vdXRsZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBTeW5jUm91dGVIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN5bmNSb3V0ZUhhbmRsZXIoY29tcG9uZW50VHlwZSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVkQ29tcG9uZW50ID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgfVxyXG4gICAgU3luY1JvdXRlSGFuZGxlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXNvbHZlZENvbXBvbmVudDsgfTtcclxuICAgIHJldHVybiBTeW5jUm91dGVIYW5kbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlN5bmNSb3V0ZUhhbmRsZXIgPSBTeW5jUm91dGVIYW5kbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW5jX3JvdXRlX2hhbmRsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBwYXJzZWQgVVJMXHJcbiAqL1xyXG52YXIgVXJsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVybChwYXRoLCBjaGlsZCwgYXV4aWxpYXJ5LCBwYXJhbXMpIHtcclxuICAgICAgICBpZiAoY2hpbGQgPT09IHZvaWQgMCkgeyBjaGlsZCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoYXV4aWxpYXJ5ID09PSB2b2lkIDApIHsgYXV4aWxpYXJ5ID0gbGFuZ18xLkNPTlNUX0VYUFIoW10pOyB9XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBjaGlsZDtcclxuICAgICAgICB0aGlzLmF1eGlsaWFyeSA9IGF1eGlsaWFyeTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIFVybC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aCArIHRoaXMuX21hdHJpeFBhcmFtc1RvU3RyaW5nKCkgKyB0aGlzLl9hdXhUb1N0cmluZygpICsgdGhpcy5fY2hpbGRTdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBVcmwucHJvdG90eXBlLnNlZ21lbnRUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGF0aCArIHRoaXMuX21hdHJpeFBhcmFtc1RvU3RyaW5nKCk7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBVcmwucHJvdG90eXBlLl9hdXhUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXhpbGlhcnkubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgICgnKCcgKyB0aGlzLmF1eGlsaWFyeS5tYXAoZnVuY3Rpb24gKHNpYmxpbmcpIHsgcmV0dXJuIHNpYmxpbmcudG9TdHJpbmcoKTsgfSkuam9pbignLy8nKSArICcpJykgOlxyXG4gICAgICAgICAgICAnJztcclxuICAgIH07XHJcbiAgICBVcmwucHJvdG90eXBlLl9tYXRyaXhQYXJhbXNUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5wYXJhbXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc7JyArIHNlcmlhbGl6ZVBhcmFtcyh0aGlzLnBhcmFtcykuam9pbignOycpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFVybC5wcm90b3R5cGUuX2NoaWxkU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNoaWxkKSA/ICgnLycgKyB0aGlzLmNoaWxkLnRvU3RyaW5nKCkpIDogJyc7IH07XHJcbiAgICByZXR1cm4gVXJsO1xyXG59KSgpO1xyXG5leHBvcnRzLlVybCA9IFVybDtcclxudmFyIFJvb3RVcmwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJvb3RVcmwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSb290VXJsKHBhdGgsIGNoaWxkLCBhdXhpbGlhcnksIHBhcmFtcykge1xyXG4gICAgICAgIGlmIChjaGlsZCA9PT0gdm9pZCAwKSB7IGNoaWxkID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChhdXhpbGlhcnkgPT09IHZvaWQgMCkgeyBhdXhpbGlhcnkgPSBsYW5nXzEuQ09OU1RfRVhQUihbXSk7IH1cclxuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0gbnVsbDsgfVxyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsIGNoaWxkLCBhdXhpbGlhcnksIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBSb290VXJsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoICsgdGhpcy5fYXV4VG9TdHJpbmcoKSArIHRoaXMuX2NoaWxkU3RyaW5nKCkgKyB0aGlzLl9xdWVyeVBhcmFtc1RvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgUm9vdFVybC5wcm90b3R5cGUuc2VnbWVudFRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXRoICsgdGhpcy5fcXVlcnlQYXJhbXNUb1N0cmluZygpOyB9O1xyXG4gICAgUm9vdFVybC5wcm90b3R5cGUuX3F1ZXJ5UGFyYW1zVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMucGFyYW1zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnPycgKyBzZXJpYWxpemVQYXJhbXModGhpcy5wYXJhbXMpLmpvaW4oJyYnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm9vdFVybDtcclxufSkoVXJsKTtcclxuZXhwb3J0cy5Sb290VXJsID0gUm9vdFVybDtcclxuZnVuY3Rpb24gcGF0aFNlZ21lbnRzVG9VcmwocGF0aFNlZ21lbnRzKSB7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVybChwYXRoU2VnbWVudHNbcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDFdKTtcclxuICAgIGZvciAodmFyIGkgPSBwYXRoU2VnbWVudHMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICB1cmwgPSBuZXcgVXJsKHBhdGhTZWdtZW50c1tpXSwgdXJsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuZXhwb3J0cy5wYXRoU2VnbWVudHNUb1VybCA9IHBhdGhTZWdtZW50c1RvVXJsO1xyXG52YXIgU0VHTUVOVF9SRSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnXlteXFxcXC9cXFxcKFxcXFwpXFxcXD87PSYjXSsnKTtcclxuZnVuY3Rpb24gbWF0Y2hVcmxTZWdtZW50KHN0cikge1xyXG4gICAgdmFyIG1hdGNoID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChTRUdNRU5UX1JFLCBzdHIpO1xyXG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQobWF0Y2gpID8gbWF0Y2hbMF0gOiAnJztcclxufVxyXG52YXIgVXJsUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVybFBhcnNlcigpIHtcclxuICAgIH1cclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGVla1N0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKHRoaXMuX3JlbWFpbmluZywgc3RyKTsgfTtcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICBpZiAoIWxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGgodGhpcy5fcmVtYWluaW5nLCBzdHIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkV4cGVjdGVkIFxcXCJcIiArIHN0ciArIFwiXFxcIi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IHRoaXMuX3JlbWFpbmluZy5zdWJzdHJpbmcoc3RyLmxlbmd0aCk7XHJcbiAgICB9O1xyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB0aGlzLl9yZW1haW5pbmcgPSB1cmw7XHJcbiAgICAgICAgaWYgKHVybCA9PSAnJyB8fCB1cmwgPT0gJy8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSb290KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gc2VnbWVudCArIChhdXggc2VnbWVudHMpICsgKHF1ZXJ5IHBhcmFtcylcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VSb290ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gbWF0Y2hVcmxTZWdtZW50KHRoaXMuX3JlbWFpbmluZyk7XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlKHBhdGgpO1xyXG4gICAgICAgIHZhciBhdXggPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XHJcbiAgICAgICAgICAgIGF1eCA9IHRoaXMucGFyc2VBdXhpbGlhcnlSb3V0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJzsnKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhlc2UgcGFyYW1zIGp1c3QgYmUgZHJvcHBlZD9cclxuICAgICAgICAgICAgdGhpcy5wYXJzZU1hdHJpeFBhcmFtcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2hpbGQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XHJcbiAgICAgICAgICAgIGNoaWxkID0gdGhpcy5wYXJzZVNlZ21lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnPycpKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gdGhpcy5wYXJzZVF1ZXJ5UGFyYW1zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUm9vdFVybChwYXRoLCBjaGlsZCwgYXV4LCBxdWVyeVBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gc2VnbWVudCArIChtYXRyaXggcGFyYW1zKSArIChhdXggc2VnbWVudHMpXHJcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IG1hdGNoVXJsU2VnbWVudCh0aGlzLl9yZW1haW5pbmcpO1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZShwYXRoKTtcclxuICAgICAgICB2YXIgbWF0cml4UGFyYW1zID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnOycpKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeFBhcmFtcyA9IHRoaXMucGFyc2VNYXRyaXhQYXJhbXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGF1eCA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcoJykpIHtcclxuICAgICAgICAgICAgYXV4ID0gdGhpcy5wYXJzZUF1eGlsaWFyeVJvdXRlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2hpbGQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XHJcbiAgICAgICAgICAgIGNoaWxkID0gdGhpcy5wYXJzZVNlZ21lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVcmwocGF0aCwgY2hpbGQsIGF1eCwgbWF0cml4UGFyYW1zKTtcclxuICAgIH07XHJcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZSgnPycpO1xyXG4gICAgICAgIHRoaXMucGFyc2VQYXJhbShwYXJhbXMpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLl9yZW1haW5pbmcubGVuZ3RoID4gMCAmJiB0aGlzLnBlZWtTdGFydHNXaXRoKCcmJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcmJyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VQYXJhbShwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VNYXRyaXhQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHdoaWxlICh0aGlzLl9yZW1haW5pbmcubGVuZ3RoID4gMCAmJiB0aGlzLnBlZWtTdGFydHNXaXRoKCc7JykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCc7Jyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VQYXJhbShwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXJhbSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICB2YXIga2V5ID0gbWF0Y2hVcmxTZWdtZW50KHRoaXMuX3JlbWFpbmluZyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhcHR1cmUoa2V5KTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCc9JykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCc9Jyk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hVcmxTZWdtZW50KHRoaXMuX3JlbWFpbmluZyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbHVlTWF0Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlTWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF1eGlsaWFyeVJvdXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm91dGVzID0gW107XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlKCcoJyk7XHJcbiAgICAgICAgd2hpbGUgKCF0aGlzLnBlZWtTdGFydHNXaXRoKCcpJykgJiYgdGhpcy5fcmVtYWluaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcm91dGVzLnB1c2godGhpcy5wYXJzZVNlZ21lbnQoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvLycpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8vJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlKCcpJyk7XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVXJsUGFyc2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLlVybFBhcnNlciA9IFVybFBhcnNlcjtcclxuZXhwb3J0cy5wYXJzZXIgPSBuZXcgVXJsUGFyc2VyKCk7XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbU1hcCkge1xyXG4gICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyYW1NYXApKSB7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChwYXJhbU1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZXhwb3J0cy5zZXJpYWxpemVQYXJhbXMgPSBzZXJpYWxpemVQYXJhbXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybF9wYXJzZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIE5vdGU6IFRoaXMgY2xhc3MgaXMgb25seSBoZXJlIHNvIHRoYXQgd2UgY2FuIHJlZmVyZW5jZSBpdCBmcm9tIFR5cGVTY3JpcHQgY29kZS5cclxuLy8gVGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBsaXZlcyB1bmRlciBtb2R1bGVzX2RhcnQuXHJcbi8vIFRPRE8odGJvc2NoKTogTW92ZSB0aGUgY29ycmVzcG9uZGluZyBjb2RlIGludG8gYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIgb25jZVxyXG4vLyB0aGUgbmV3IGNvbXBpbGVyIGlzIGRvbmUuXHJcbnZhciBDb2RlZ2VuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvZGVnZW4obW9kdWxlQWxpYXMpIHtcclxuICAgIH1cclxuICAgIENvZGVnZW4ucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBjaGFuZ2VEZXRlY3RvclR5cGVOYW1lLCBkZWYpIHtcclxuICAgICAgICB0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZCBpbiBKU1wiO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZCBpbiBKU1wiOyB9O1xyXG4gICAgcmV0dXJuIENvZGVnZW47XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29kZWdlbiA9IENvZGVnZW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rvcl9jb2RlZ2VuLmpzLm1hcCIsIi8vIFRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIHZpYSB0aGUgYGNvbW1vbmpzYCBHcnVudCB0YXNrLiBZb3UgY2FuIHJlcXVpcmUoKSB0aGlzIGZpbGUgaW4gYSBDb21tb25KUyBlbnZpcm9ubWVudC5cbnJlcXVpcmUoJy4uLy4uL2pzL3RyYW5zaXRpb24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvYWxlcnQuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvYnV0dG9uLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2Nhcm91c2VsLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2NvbGxhcHNlLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2Ryb3Bkb3duLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL21vZGFsLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3Rvb2x0aXAuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvcG9wb3Zlci5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9zY3JvbGxzcHkuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvdGFiLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL2FmZml4LmpzJykiLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWZmaXguanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhZmZpeFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFGRklYIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBBZmZpeCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFmZml4LkRFRkFVTFRTLCBvcHRpb25zKVxuXG4gICAgdGhpcy4kdGFyZ2V0ID0gJCh0aGlzLm9wdGlvbnMudGFyZ2V0KVxuICAgICAgLm9uKCdzY3JvbGwuYnMuYWZmaXguZGF0YS1hcGknLCAkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcykpXG4gICAgICAub24oJ2NsaWNrLmJzLmFmZml4LmRhdGEtYXBpJywgICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCwgdGhpcykpXG5cbiAgICB0aGlzLiRlbGVtZW50ICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLmFmZml4ZWQgICAgICA9IG51bGxcbiAgICB0aGlzLnVucGluICAgICAgICA9IG51bGxcbiAgICB0aGlzLnBpbm5lZE9mZnNldCA9IG51bGxcblxuICAgIHRoaXMuY2hlY2tQb3NpdGlvbigpXG4gIH1cblxuICBBZmZpeC5WRVJTSU9OICA9ICczLjMuNSdcblxuICBBZmZpeC5SRVNFVCAgICA9ICdhZmZpeCBhZmZpeC10b3AgYWZmaXgtYm90dG9tJ1xuXG4gIEFmZml4LkRFRkFVTFRTID0ge1xuICAgIG9mZnNldDogMCxcbiAgICB0YXJnZXQ6IHdpbmRvd1xuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHNjcm9sbEhlaWdodCwgaGVpZ2h0LCBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSkge1xuICAgIHZhciBzY3JvbGxUb3AgICAgPSB0aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKClcbiAgICB2YXIgcG9zaXRpb24gICAgID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVxuICAgIHZhciB0YXJnZXRIZWlnaHQgPSB0aGlzLiR0YXJnZXQuaGVpZ2h0KClcblxuICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCAmJiB0aGlzLmFmZml4ZWQgPT0gJ3RvcCcpIHJldHVybiBzY3JvbGxUb3AgPCBvZmZzZXRUb3AgPyAndG9wJyA6IGZhbHNlXG5cbiAgICBpZiAodGhpcy5hZmZpeGVkID09ICdib3R0b20nKSB7XG4gICAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwpIHJldHVybiAoc2Nyb2xsVG9wICsgdGhpcy51bnBpbiA8PSBwb3NpdGlvbi50b3ApID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgICAgcmV0dXJuIChzY3JvbGxUb3AgKyB0YXJnZXRIZWlnaHQgPD0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0Qm90dG9tKSA/IGZhbHNlIDogJ2JvdHRvbSdcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbGl6aW5nICAgPSB0aGlzLmFmZml4ZWQgPT0gbnVsbFxuICAgIHZhciBjb2xsaWRlclRvcCAgICA9IGluaXRpYWxpemluZyA/IHNjcm9sbFRvcCA6IHBvc2l0aW9uLnRvcFxuICAgIHZhciBjb2xsaWRlckhlaWdodCA9IGluaXRpYWxpemluZyA/IHRhcmdldEhlaWdodCA6IGhlaWdodFxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHNjcm9sbFRvcCA8PSBvZmZzZXRUb3ApIHJldHVybiAndG9wJ1xuICAgIGlmIChvZmZzZXRCb3R0b20gIT0gbnVsbCAmJiAoY29sbGlkZXJUb3AgKyBjb2xsaWRlckhlaWdodCA+PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pKSByZXR1cm4gJ2JvdHRvbSdcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmdldFBpbm5lZE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5waW5uZWRPZmZzZXQpIHJldHVybiB0aGlzLnBpbm5lZE9mZnNldFxuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoQWZmaXguUkVTRVQpLmFkZENsYXNzKCdhZmZpeCcpXG4gICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgcmV0dXJuICh0aGlzLnBpbm5lZE9mZnNldCA9IHBvc2l0aW9uLnRvcCAtIHNjcm9sbFRvcClcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSwgMSlcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkgcmV0dXJuXG5cbiAgICB2YXIgaGVpZ2h0ICAgICAgID0gdGhpcy4kZWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXQgICAgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIG9mZnNldFRvcCAgICA9IG9mZnNldC50b3BcbiAgICB2YXIgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0LmJvdHRvbVxuICAgIHZhciBzY3JvbGxIZWlnaHQgPSBNYXRoLm1heCgkKGRvY3VtZW50KS5oZWlnaHQoKSwgJChkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSlcblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9ICdvYmplY3QnKSAgICAgICAgIG9mZnNldEJvdHRvbSA9IG9mZnNldFRvcCA9IG9mZnNldFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0VG9wID09ICdmdW5jdGlvbicpICAgIG9mZnNldFRvcCAgICA9IG9mZnNldC50b3AodGhpcy4kZWxlbWVudClcbiAgICBpZiAodHlwZW9mIG9mZnNldEJvdHRvbSA9PSAnZnVuY3Rpb24nKSBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tKHRoaXMuJGVsZW1lbnQpXG5cbiAgICB2YXIgYWZmaXggPSB0aGlzLmdldFN0YXRlKHNjcm9sbEhlaWdodCwgaGVpZ2h0LCBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSlcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgIT0gYWZmaXgpIHtcbiAgICAgIGlmICh0aGlzLnVucGluICE9IG51bGwpIHRoaXMuJGVsZW1lbnQuY3NzKCd0b3AnLCAnJylcblxuICAgICAgdmFyIGFmZml4VHlwZSA9ICdhZmZpeCcgKyAoYWZmaXggPyAnLScgKyBhZmZpeCA6ICcnKVxuICAgICAgdmFyIGUgICAgICAgICA9ICQuRXZlbnQoYWZmaXhUeXBlICsgJy5icy5hZmZpeCcpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgIHRoaXMuYWZmaXhlZCA9IGFmZml4XG4gICAgICB0aGlzLnVucGluID0gYWZmaXggPT0gJ2JvdHRvbScgPyB0aGlzLmdldFBpbm5lZE9mZnNldCgpIDogbnVsbFxuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVClcbiAgICAgICAgLmFkZENsYXNzKGFmZml4VHlwZSlcbiAgICAgICAgLnRyaWdnZXIoYWZmaXhUeXBlLnJlcGxhY2UoJ2FmZml4JywgJ2FmZml4ZWQnKSArICcuYnMuYWZmaXgnKVxuICAgIH1cblxuICAgIGlmIChhZmZpeCA9PSAnYm90dG9tJykge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmZzZXQoe1xuICAgICAgICB0b3A6IHNjcm9sbEhlaWdodCAtIGhlaWdodCAtIG9mZnNldEJvdHRvbVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuXG4gIC8vIEFGRklYIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmFmZml4JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hZmZpeCcsIChkYXRhID0gbmV3IEFmZml4KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hZmZpeFxuXG4gICQuZm4uYWZmaXggICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hZmZpeC5Db25zdHJ1Y3RvciA9IEFmZml4XG5cblxuICAvLyBBRkZJWCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWZmaXgubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFmZml4ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUZGSVggREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgPSAkc3B5LmRhdGEoKVxuXG4gICAgICBkYXRhLm9mZnNldCA9IGRhdGEub2Zmc2V0IHx8IHt9XG5cbiAgICAgIGlmIChkYXRhLm9mZnNldEJvdHRvbSAhPSBudWxsKSBkYXRhLm9mZnNldC5ib3R0b20gPSBkYXRhLm9mZnNldEJvdHRvbVxuICAgICAgaWYgKGRhdGEub2Zmc2V0VG9wICAgICE9IG51bGwpIGRhdGEub2Zmc2V0LnRvcCAgICA9IGRhdGEub2Zmc2V0VG9wXG5cbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksIGRhdGEpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFsZXJ0LmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGRpc21pc3MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB2YXIgQWxlcnQgICA9IGZ1bmN0aW9uIChlbCkge1xuICAgICQoZWwpLm9uKCdjbGljaycsIGRpc21pc3MsIHRoaXMuY2xvc2UpXG4gIH1cblxuICBBbGVydC5WRVJTSU9OID0gJzMuMy41J1xuXG4gIEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gJChzZWxlY3RvcilcblxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICRwYXJlbnQgPSAkdGhpcy5jbG9zZXN0KCcuYWxlcnQnKVxuICAgIH1cblxuICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnY2xvc2UuYnMuYWxlcnQnKSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBwYXJlbnQsIGZpcmUgZXZlbnQgdGhlbiBjbGVhbiB1cCBkYXRhXG4gICAgICAkcGFyZW50LmRldGFjaCgpLnRyaWdnZXIoJ2Nsb3NlZC5icy5hbGVydCcpLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHBhcmVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgcmVtb3ZlRWxlbWVudClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHJlbW92ZUVsZW1lbnQoKVxuICB9XG5cblxuICAvLyBBTEVSVCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hbGVydCcsIChkYXRhID0gbmV3IEFsZXJ0KHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWxlcnRcblxuICAkLmZuLmFsZXJ0ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWxlcnQuQ29uc3RydWN0b3IgPSBBbGVydFxuXG5cbiAgLy8gQUxFUlQgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFsZXJ0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hbGVydCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFMRVJUIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpJywgZGlzbWlzcywgQWxlcnQucHJvdG90eXBlLmNsb3NlKVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYnV0dG9uLmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYnV0dG9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEJVVFRPTiBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICA9ICQuZXh0ZW5kKHt9LCBCdXR0b24uREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICB9XG5cbiAgQnV0dG9uLlZFUlNJT04gID0gJzMuMy41J1xuXG4gIEJ1dHRvbi5ERUZBVUxUUyA9IHtcbiAgICBsb2FkaW5nVGV4dDogJ2xvYWRpbmcuLi4nXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGQgICAgPSAnZGlzYWJsZWQnXG4gICAgdmFyICRlbCAgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIHZhbCAgPSAkZWwuaXMoJ2lucHV0JykgPyAndmFsJyA6ICdodG1sJ1xuICAgIHZhciBkYXRhID0gJGVsLmRhdGEoKVxuXG4gICAgc3RhdGUgKz0gJ1RleHQnXG5cbiAgICBpZiAoZGF0YS5yZXNldFRleHQgPT0gbnVsbCkgJGVsLmRhdGEoJ3Jlc2V0VGV4dCcsICRlbFt2YWxdKCkpXG5cbiAgICAvLyBwdXNoIHRvIGV2ZW50IGxvb3AgdG8gYWxsb3cgZm9ybXMgdG8gc3VibWl0XG4gICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICRlbFt2YWxdKGRhdGFbc3RhdGVdID09IG51bGwgPyB0aGlzLm9wdGlvbnNbc3RhdGVdIDogZGF0YVtzdGF0ZV0pXG5cbiAgICAgIGlmIChzdGF0ZSA9PSAnbG9hZGluZ1RleHQnKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZVxuICAgICAgICAkZWwuYWRkQ2xhc3MoZCkuYXR0cihkLCBkKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhkKS5yZW1vdmVBdHRyKGQpXG4gICAgICB9XG4gICAgfSwgdGhpcyksIDApXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWVcbiAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScpXG5cbiAgICBpZiAoJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHZhciAkaW5wdXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0JylcbiAgICAgIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdyYWRpbycpIHtcbiAgICAgICAgaWYgKCRpbnB1dC5wcm9wKCdjaGVja2VkJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICAkcGFyZW50LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIH0gZWxzZSBpZiAoJGlucHV0LnByb3AoJ3R5cGUnKSA9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGlmICgoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSkgIT09IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSBjaGFuZ2VkID0gZmFsc2VcbiAgICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgICAgIH1cbiAgICAgICRpbnB1dC5wcm9wKCdjaGVja2VkJywgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgICBpZiAoY2hhbmdlZCkgJGlucHV0LnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1wcmVzc2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKVxuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgICB9XG4gIH1cblxuXG4gIC8vIEJVVFRPTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYnV0dG9uJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5idXR0b24nLCAoZGF0YSA9IG5ldyBCdXR0b24odGhpcywgb3B0aW9ucykpKVxuXG4gICAgICBpZiAob3B0aW9uID09ICd0b2dnbGUnKSBkYXRhLnRvZ2dsZSgpXG4gICAgICBlbHNlIGlmIChvcHRpb24pIGRhdGEuc2V0U3RhdGUob3B0aW9uKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5idXR0b25cblxuICAkLmZuLmJ1dHRvbiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmJ1dHRvbi5Db25zdHJ1Y3RvciA9IEJ1dHRvblxuXG5cbiAgLy8gQlVUVE9OIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYnV0dG9uLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5idXR0b24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBCVVRUT04gREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkYnRuID0gJChlLnRhcmdldClcbiAgICAgIGlmICghJGJ0bi5oYXNDbGFzcygnYnRuJykpICRidG4gPSAkYnRuLmNsb3Nlc3QoJy5idG4nKVxuICAgICAgUGx1Z2luLmNhbGwoJGJ0biwgJ3RvZ2dsZScpXG4gICAgICBpZiAoISgkKGUudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cInJhZGlvXCJdJykgfHwgJChlLnRhcmdldCkuaXMoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfSlcbiAgICAub24oJ2ZvY3VzLmJzLmJ1dHRvbi5kYXRhLWFwaSBibHVyLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5idG4nKS50b2dnbGVDbGFzcygnZm9jdXMnLCAvXmZvY3VzKGluKT8kLy50ZXN0KGUudHlwZSkpXG4gICAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGNhcm91c2VsLmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jY2Fyb3VzZWxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDQVJPVVNFTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ2Fyb3VzZWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy4kaW5kaWNhdG9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmNhcm91c2VsLWluZGljYXRvcnMnKVxuICAgIHRoaXMub3B0aW9ucyAgICAgPSBvcHRpb25zXG4gICAgdGhpcy5wYXVzZWQgICAgICA9IG51bGxcbiAgICB0aGlzLnNsaWRpbmcgICAgID0gbnVsbFxuICAgIHRoaXMuaW50ZXJ2YWwgICAgPSBudWxsXG4gICAgdGhpcy4kYWN0aXZlICAgICA9IG51bGxcbiAgICB0aGlzLiRpdGVtcyAgICAgID0gbnVsbFxuXG4gICAgdGhpcy5vcHRpb25zLmtleWJvYXJkICYmIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMua2V5ZG93biwgdGhpcykpXG5cbiAgICB0aGlzLm9wdGlvbnMucGF1c2UgPT0gJ2hvdmVyJyAmJiAhKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgJiYgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCdtb3VzZWVudGVyLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLnBhdXNlLCB0aGlzKSlcbiAgICAgIC5vbignbW91c2VsZWF2ZS5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5jeWNsZSwgdGhpcykpXG4gIH1cblxuICBDYXJvdXNlbC5WRVJTSU9OICA9ICczLjMuNSdcblxuICBDYXJvdXNlbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAwXG5cbiAgQ2Fyb3VzZWwuREVGQVVMVFMgPSB7XG4gICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAgcGF1c2U6ICdob3ZlcicsXG4gICAgd3JhcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpKSByZXR1cm5cbiAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgIGNhc2UgMzc6IHRoaXMucHJldigpOyBicmVha1xuICAgICAgY2FzZSAzOTogdGhpcy5uZXh0KCk7IGJyZWFrXG4gICAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5jeWNsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSBmYWxzZSlcblxuICAgIHRoaXMuaW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgdGhpcy5vcHRpb25zLmludGVydmFsXG4gICAgICAmJiAhdGhpcy5wYXVzZWRcbiAgICAgICYmICh0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoJC5wcm94eSh0aGlzLm5leHQsIHRoaXMpLCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXRJdGVtSW5kZXggPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuJGl0ZW1zID0gaXRlbS5wYXJlbnQoKS5jaGlsZHJlbignLml0ZW0nKVxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5pbmRleChpdGVtIHx8IHRoaXMuJGFjdGl2ZSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXRJdGVtRm9yRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgYWN0aXZlKSB7XG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRJdGVtSW5kZXgoYWN0aXZlKVxuICAgIHZhciB3aWxsV3JhcCA9IChkaXJlY3Rpb24gPT0gJ3ByZXYnICYmIGFjdGl2ZUluZGV4ID09PSAwKVxuICAgICAgICAgICAgICAgIHx8IChkaXJlY3Rpb24gPT0gJ25leHQnICYmIGFjdGl2ZUluZGV4ID09ICh0aGlzLiRpdGVtcy5sZW5ndGggLSAxKSlcbiAgICBpZiAod2lsbFdyYXAgJiYgIXRoaXMub3B0aW9ucy53cmFwKSByZXR1cm4gYWN0aXZlXG4gICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09ICdwcmV2JyA/IC0xIDogMVxuICAgIHZhciBpdGVtSW5kZXggPSAoYWN0aXZlSW5kZXggKyBkZWx0YSkgJSB0aGlzLiRpdGVtcy5sZW5ndGhcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuZXEoaXRlbUluZGV4KVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciB0aGF0ICAgICAgICA9IHRoaXNcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleCh0aGlzLiRhY3RpdmUgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pdGVtLmFjdGl2ZScpKVxuXG4gICAgaWYgKHBvcyA+ICh0aGlzLiRpdGVtcy5sZW5ndGggLSAxKSB8fCBwb3MgPCAwKSByZXR1cm5cblxuICAgIGlmICh0aGlzLnNsaWRpbmcpICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50Lm9uZSgnc2xpZC5icy5jYXJvdXNlbCcsIGZ1bmN0aW9uICgpIHsgdGhhdC50byhwb3MpIH0pIC8vIHllcywgXCJzbGlkXCJcbiAgICBpZiAoYWN0aXZlSW5kZXggPT0gcG9zKSByZXR1cm4gdGhpcy5wYXVzZSgpLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzLnNsaWRlKHBvcyA+IGFjdGl2ZUluZGV4ID8gJ25leHQnIDogJ3ByZXYnLCB0aGlzLiRpdGVtcy5lcShwb3MpKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlIHx8ICh0aGlzLnBhdXNlZCA9IHRydWUpXG5cbiAgICBpZiAodGhpcy4kZWxlbWVudC5maW5kKCcubmV4dCwgLnByZXYnKS5sZW5ndGggJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpXG4gICAgICB0aGlzLmN5Y2xlKHRydWUpXG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zbGlkaW5nKSByZXR1cm5cbiAgICByZXR1cm4gdGhpcy5zbGlkZSgnbmV4dCcpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zbGlkaW5nKSByZXR1cm5cbiAgICByZXR1cm4gdGhpcy5zbGlkZSgncHJldicpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuc2xpZGUgPSBmdW5jdGlvbiAodHlwZSwgbmV4dCkge1xuICAgIHZhciAkYWN0aXZlICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pdGVtLmFjdGl2ZScpXG4gICAgdmFyICRuZXh0ICAgICA9IG5leHQgfHwgdGhpcy5nZXRJdGVtRm9yRGlyZWN0aW9uKHR5cGUsICRhY3RpdmUpXG4gICAgdmFyIGlzQ3ljbGluZyA9IHRoaXMuaW50ZXJ2YWxcbiAgICB2YXIgZGlyZWN0aW9uID0gdHlwZSA9PSAnbmV4dCcgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgdmFyIHRoYXQgICAgICA9IHRoaXNcblxuICAgIGlmICgkbmV4dC5oYXNDbGFzcygnYWN0aXZlJykpIHJldHVybiAodGhpcy5zbGlkaW5nID0gZmFsc2UpXG5cbiAgICB2YXIgcmVsYXRlZFRhcmdldCA9ICRuZXh0WzBdXG4gICAgdmFyIHNsaWRlRXZlbnQgPSAkLkV2ZW50KCdzbGlkZS5icy5jYXJvdXNlbCcsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHNsaWRlRXZlbnQpXG4gICAgaWYgKHNsaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5zbGlkaW5nID0gdHJ1ZVxuXG4gICAgaXNDeWNsaW5nICYmIHRoaXMucGF1c2UoKVxuXG4gICAgaWYgKHRoaXMuJGluZGljYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLiRpbmRpY2F0b3JzLmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgIHZhciAkbmV4dEluZGljYXRvciA9ICQodGhpcy4kaW5kaWNhdG9ycy5jaGlsZHJlbigpW3RoaXMuZ2V0SXRlbUluZGV4KCRuZXh0KV0pXG4gICAgICAkbmV4dEluZGljYXRvciAmJiAkbmV4dEluZGljYXRvci5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICB2YXIgc2xpZEV2ZW50ID0gJC5FdmVudCgnc2xpZC5icy5jYXJvdXNlbCcsIHsgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmICgkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdzbGlkZScpKSB7XG4gICAgICAkbmV4dC5hZGRDbGFzcyh0eXBlKVxuICAgICAgJG5leHRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICAkYWN0aXZlLmFkZENsYXNzKGRpcmVjdGlvbilcbiAgICAgICRuZXh0LmFkZENsYXNzKGRpcmVjdGlvbilcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRuZXh0LnJlbW92ZUNsYXNzKFt0eXBlLCBkaXJlY3Rpb25dLmpvaW4oJyAnKSkuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcyhbJ2FjdGl2ZScsIGRpcmVjdGlvbl0uam9pbignICcpKVxuICAgICAgICAgIHRoYXQuc2xpZGluZyA9IGZhbHNlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgICAgICAgIH0sIDApXG4gICAgICAgIH0pXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDYXJvdXNlbC5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICAgIH0gZWxzZSB7XG4gICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZVxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHNsaWRFdmVudClcbiAgICB9XG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5jeWNsZSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDQVJPVVNFTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5jYXJvdXNlbCcpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDYXJvdXNlbC5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcbiAgICAgIHZhciBhY3Rpb24gID0gdHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyA/IG9wdGlvbiA6IG9wdGlvbnMuc2xpZGVcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5jYXJvdXNlbCcsIChkYXRhID0gbmV3IENhcm91c2VsKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdudW1iZXInKSBkYXRhLnRvKG9wdGlvbilcbiAgICAgIGVsc2UgaWYgKGFjdGlvbikgZGF0YVthY3Rpb25dKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaW50ZXJ2YWwpIGRhdGEucGF1c2UoKS5jeWNsZSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmNhcm91c2VsXG5cbiAgJC5mbi5jYXJvdXNlbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmNhcm91c2VsLkNvbnN0cnVjdG9yID0gQ2Fyb3VzZWxcblxuXG4gIC8vIENBUk9VU0VMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5jYXJvdXNlbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY2Fyb3VzZWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDQVJPVVNFTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBocmVmXG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgPSAkdGhpcy5hdHRyKCdocmVmJykpICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgaWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKCdjYXJvdXNlbCcpKSByZXR1cm5cbiAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuICAgIHZhciBzbGlkZUluZGV4ID0gJHRoaXMuYXR0cignZGF0YS1zbGlkZS10bycpXG4gICAgaWYgKHNsaWRlSW5kZXgpIG9wdGlvbnMuaW50ZXJ2YWwgPSBmYWxzZVxuXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9ucylcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICAkdGFyZ2V0LmRhdGEoJ2JzLmNhcm91c2VsJykudG8oc2xpZGVJbmRleClcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaScsICdbZGF0YS1zbGlkZV0nLCBjbGlja0hhbmRsZXIpXG4gICAgLm9uKCdjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaScsICdbZGF0YS1zbGlkZS10b10nLCBjbGlja0hhbmRsZXIpXG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRjYXJvdXNlbCA9ICQodGhpcylcbiAgICAgIFBsdWdpbi5jYWxsKCRjYXJvdXNlbCwgJGNhcm91c2VsLmRhdGEoKSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY29sbGFwc2UuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjb2xsYXBzZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENPTExBUFNFIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENvbGxhcHNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuJHRyaWdnZXIgICAgICA9ICQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXScpXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gbnVsbFxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCwgdGhpcy4kdHJpZ2dlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRvZ2dsZSkgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgQ29sbGFwc2UuVkVSU0lPTiAgPSAnMy4zLjUnXG5cbiAgQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTiA9IDM1MFxuXG4gIENvbGxhcHNlLkRFRkFVTFRTID0ge1xuICAgIHRvZ2dsZTogdHJ1ZVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmRpbWVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzV2lkdGggPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCd3aWR0aCcpXG4gICAgcmV0dXJuIGhhc1dpZHRoID8gJ3dpZHRoJyA6ICdoZWlnaHQnXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIGFjdGl2ZXNEYXRhXG4gICAgdmFyIGFjdGl2ZXMgPSB0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50LmNoaWxkcmVuKCcucGFuZWwnKS5jaGlsZHJlbignLmluLCAuY29sbGFwc2luZycpXG5cbiAgICBpZiAoYWN0aXZlcyAmJiBhY3RpdmVzLmxlbmd0aCkge1xuICAgICAgYWN0aXZlc0RhdGEgPSBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS50cmFuc2l0aW9uaW5nKSByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMuY29sbGFwc2UnKVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBQbHVnaW4uY2FsbChhY3RpdmVzLCAnaGlkZScpXG4gICAgICBhY3RpdmVzRGF0YSB8fCBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJywgbnVsbClcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVtkaW1lbnNpb25dKDApXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAxXG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UgaW4nKVtkaW1lbnNpb25dKCcnKVxuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB2YXIgc2Nyb2xsU2l6ZSA9ICQuY2FtZWxDYXNlKFsnc2Nyb2xsJywgZGltZW5zaW9uXS5qb2luKCctJykpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbMF1bc2Nyb2xsU2l6ZV0pXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8ICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uKClcblxuICAgIHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSh0aGlzLiRlbGVtZW50W2RpbWVuc2lvbl0oKSlbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZSBpbicpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy4kdHJpZ2dlclxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZWQnKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDBcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICBbZGltZW5zaW9uXSgwKVxuICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eShjb21wbGV0ZSwgdGhpcykpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpID8gJ2hpZGUnIDogJ3Nob3cnXSgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkKHRoaXMub3B0aW9ucy5wYXJlbnQpXG4gICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInICsgdGhpcy5vcHRpb25zLnBhcmVudCArICdcIl0nKVxuICAgICAgLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICAgIHRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGdldFRhcmdldEZyb21UcmlnZ2VyKCRlbGVtZW50KSwgJGVsZW1lbnQpXG4gICAgICB9LCB0aGlzKSlcbiAgICAgIC5lbmQoKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uICgkZWxlbWVudCwgJHRyaWdnZXIpIHtcbiAgICB2YXIgaXNPcGVuID0gJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJylcblxuICAgICRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gICAgJHRyaWdnZXJcbiAgICAgIC50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzT3BlbilcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRyaWdnZXIpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciB0YXJnZXQgPSAkdHJpZ2dlci5hdHRyKCdkYXRhLXRhcmdldCcpXG4gICAgICB8fCAoaHJlZiA9ICR0cmlnZ2VyLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuXG4gICAgcmV0dXJuICQodGFyZ2V0KVxuICB9XG5cblxuICAvLyBDT0xMQVBTRSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbnMudG9nZ2xlICYmIC9zaG93fGhpZGUvLnRlc3Qob3B0aW9uKSkgb3B0aW9ucy50b2dnbGUgPSBmYWxzZVxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScsIChkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jb2xsYXBzZVxuXG4gICQuZm4uY29sbGFwc2UgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jb2xsYXBzZS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlXG5cblxuICAvLyBDT0xMQVBTRSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY29sbGFwc2Uubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNvbGxhcHNlID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ09MTEFQU0UgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuXG4gICAgaWYgKCEkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHZhciAkdGFyZ2V0ID0gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRoaXMpXG4gICAgdmFyIGRhdGEgICAgPSAkdGFyZ2V0LmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICB2YXIgb3B0aW9uICA9IGRhdGEgPyAndG9nZ2xlJyA6ICR0aGlzLmRhdGEoKVxuXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uKVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogZHJvcGRvd24uanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNkcm9wZG93bnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBEUk9QRE9XTiBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgYmFja2Ryb3AgPSAnLmRyb3Bkb3duLWJhY2tkcm9wJ1xuICB2YXIgdG9nZ2xlICAgPSAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS5vbignY2xpY2suYnMuZHJvcGRvd24nLCB0aGlzLnRvZ2dsZSlcbiAgfVxuXG4gIERyb3Bkb3duLlZFUlNJT04gPSAnMy4zLjUnXG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KCR0aGlzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgLyNbQS1aYS16XS8udGVzdChzZWxlY3RvcikgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICB2YXIgJHBhcmVudCA9IHNlbGVjdG9yICYmICQoc2VsZWN0b3IpXG5cbiAgICByZXR1cm4gJHBhcmVudCAmJiAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkdGhpcy5wYXJlbnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJNZW51cyhlKSB7XG4gICAgaWYgKGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuXG4gICAgJChiYWNrZHJvcCkucmVtb3ZlKClcbiAgICAkKHRvZ2dsZSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgICAgICA9ICQodGhpcylcbiAgICAgIHZhciAkcGFyZW50ICAgICAgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuXG4gICAgICBpZiAoISRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKSkgcmV0dXJuXG5cbiAgICAgIGlmIChlICYmIGUudHlwZSA9PSAnY2xpY2snICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkgJiYgJC5jb250YWlucygkcGFyZW50WzBdLCBlLnRhcmdldCkpIHJldHVyblxuXG4gICAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2hpZGUuYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICAkdGhpcy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJylcbiAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ29wZW4nKS50cmlnZ2VyKCdoaWRkZW4uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgY2xlYXJNZW51cygpXG5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIG1vYmlsZSB3ZSB1c2UgYSBiYWNrZHJvcCBiZWNhdXNlIGNsaWNrIGV2ZW50cyBkb24ndCBkZWxlZ2F0ZVxuICAgICAgICAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgIC5hZGRDbGFzcygnZHJvcGRvd24tYmFja2Ryb3AnKVxuICAgICAgICAgIC5pbnNlcnRBZnRlcigkKHRoaXMpKVxuICAgICAgICAgIC5vbignY2xpY2snLCBjbGVhck1lbnVzKVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG4gICAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ3Nob3cuYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICAkdGhpc1xuICAgICAgICAudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJylcblxuICAgICAgJHBhcmVudFxuICAgICAgICAudG9nZ2xlQ2xhc3MoJ29wZW4nKVxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghLygzOHw0MHwyN3wzMikvLnRlc3QoZS53aGljaCkgfHwgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSAmJiBlLndoaWNoICE9IDI3IHx8IGlzQWN0aXZlICYmIGUud2hpY2ggPT0gMjcpIHtcbiAgICAgIGlmIChlLndoaWNoID09IDI3KSAkcGFyZW50LmZpbmQodG9nZ2xlKS50cmlnZ2VyKCdmb2N1cycpXG4gICAgICByZXR1cm4gJHRoaXMudHJpZ2dlcignY2xpY2snKVxuICAgIH1cblxuICAgIHZhciBkZXNjID0gJyBsaTpub3QoLmRpc2FibGVkKTp2aXNpYmxlIGEnXG4gICAgdmFyICRpdGVtcyA9ICRwYXJlbnQuZmluZCgnLmRyb3Bkb3duLW1lbnUnICsgZGVzYylcblxuICAgIGlmICghJGl0ZW1zLmxlbmd0aCkgcmV0dXJuXG5cbiAgICB2YXIgaW5kZXggPSAkaXRlbXMuaW5kZXgoZS50YXJnZXQpXG5cbiAgICBpZiAoZS53aGljaCA9PSAzOCAmJiBpbmRleCA+IDApICAgICAgICAgICAgICAgICBpbmRleC0tICAgICAgICAgLy8gdXBcbiAgICBpZiAoZS53aGljaCA9PSA0MCAmJiBpbmRleCA8ICRpdGVtcy5sZW5ndGggLSAxKSBpbmRleCsrICAgICAgICAgLy8gZG93blxuICAgIGlmICghfmluZGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuXG4gICAgJGl0ZW1zLmVxKGluZGV4KS50cmlnZ2VyKCdmb2N1cycpXG4gIH1cblxuXG4gIC8vIERST1BET1dOIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJywgKGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5kcm9wZG93blxuXG4gICQuZm4uZHJvcGRvd24gICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG5cblxuICAvLyBEUk9QRE9XTiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uZHJvcGRvd24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmRyb3Bkb3duID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQVBQTFkgVE8gU1RBTkRBUkQgRFJPUERPV04gRUxFTUVOVFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBjbGVhck1lbnVzKVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnLmRyb3Bkb3duIGZvcm0nLCBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpIH0pXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSlcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24tbWVudScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLiRib2R5ICAgICAgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGRpYWxvZyAgICAgICAgICAgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWRpYWxvZycpXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuaXNTaG93biAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCAgICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCAgICAgID0gMFxuICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy41J1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuc2V0U2Nyb2xsYmFyKClcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2RhbC1vcGVuJylcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSlcblxuICAgIHRoaXMuJGRpYWxvZy5vbignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9uZSgnbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoYXQuJGVsZW1lbnQpKSB0aGF0Lmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgdGhhdC5hZGp1c3REaWFsb2coKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGF0LiRlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50LmFkZENsYXNzKCdpbicpXG5cbiAgICAgIHRoYXQuZW5mb3JjZUZvY3VzKClcblxuICAgICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93bi5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgICAgdHJhbnNpdGlvbiA/XG4gICAgICAgIHRoYXQuJGRpYWxvZyAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKCdmb2N1c2luLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnaW4nKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAub2ZmKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVNb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldCAmJiAhdGhpcy4kZWxlbWVudC5oYXMoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS53aGljaCA9PSAyNyAmJiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbigncmVzaXplLmJzLm1vZGFsJywgJC5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSwgdGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbC1iYWNrZHJvcCAnICsgYW5pbWF0ZSlcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGJvZHkpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm5cbiAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXG4gICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzKClcbiAgICAgICAgICA6IHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcblxuICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKCdpbicpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuXG4gICAgICBkb0FuaW1hdGUgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93biAmJiB0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG5cbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLy8gdGhlc2UgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuXG4gIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGp1c3REaWFsb2coKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kYWxJc092ZXJmbG93aW5nID0gdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogICF0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmIG1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmdWxsV2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGlmICghZnVsbFdpbmRvd1dpZHRoKSB7IC8vIHdvcmthcm91bmQgZm9yIG1pc3Npbmcgd2luZG93LmlubmVyV2lkdGggaW4gSUU4XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgZnVsbFdpbmRvd1dpZHRoID0gZG9jdW1lbnRFbGVtZW50UmVjdC5yaWdodCAtIE1hdGguYWJzKGRvY3VtZW50RWxlbWVudFJlY3QubGVmdClcbiAgICB9XG4gICAgdGhpcy5ib2R5SXNPdmVyZmxvd2luZyA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCBmdWxsV2luZG93V2lkdGhcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCB8fCAnJ1xuICAgIGlmICh0aGlzLmJvZHlJc092ZXJmbG93aW5nKSB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIGJvZHlQYWQgKyB0aGlzLnNjcm9sbGJhcldpZHRoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgdGhpcy5vcmlnaW5hbEJvZHlQYWQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHsgLy8gdGh4IHdhbHNoXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbiAgICB0aGlzLiRib2R5LmFwcGVuZChzY3JvbGxEaXYpXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXG4gICAgdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoXG4gIH1cblxuXG4gIC8vIE1PREFMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbiwgX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5tb2RhbCcpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5tb2RhbCcsIChkYXRhID0gbmV3IE1vZGFsKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oX3JlbGF0ZWRUYXJnZXQpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLnNob3cpIGRhdGEuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4ubW9kYWxcblxuICAkLmZuLm1vZGFsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ubW9kYWwuQ29uc3RydWN0b3IgPSBNb2RhbFxuXG5cbiAgLy8gTU9EQUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLm1vZGFsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5tb2RhbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIE1PREFMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgaHJlZiAgICA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIHZhciBvcHRpb24gID0gJHRhcmdldC5kYXRhKCdicy5tb2RhbCcpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7IHJlbW90ZTogIS8jLy50ZXN0KGhyZWYpICYmIGhyZWYgfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgIGlmICgkdGhpcy5pcygnYScpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICR0YXJnZXQub25lKCdzaG93LmJzLm1vZGFsJywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICR0YXJnZXQub25lKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICR0aGlzLmlzKCc6dmlzaWJsZScpICYmICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24sIHRoaXMpXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBwb3BvdmVyLmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jcG9wb3ZlcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBQT1BPVkVSIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgUG9wb3ZlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCdwb3BvdmVyJywgZWxlbWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghJC5mbi50b29sdGlwKSB0aHJvdyBuZXcgRXJyb3IoJ1BvcG92ZXIgcmVxdWlyZXMgdG9vbHRpcC5qcycpXG5cbiAgUG9wb3Zlci5WRVJTSU9OICA9ICczLjMuNSdcblxuICBQb3BvdmVyLkRFRkFVTFRTID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUywge1xuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nXG4gIH0pXG5cblxuICAvLyBOT1RFOiBQT1BPVkVSIEVYVEVORFMgdG9vbHRpcC5qc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIFBvcG92ZXIucHJvdG90eXBlID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb3BvdmVyXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXIuREVGQVVMVFNcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHRpdGxlICAgPSB0aGlzLmdldFRpdGxlKClcbiAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpXG5cbiAgICAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJylbdGhpcy5vcHRpb25zLmh0bWwgPyAnaHRtbCcgOiAndGV4dCddKHRpdGxlKVxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItY29udGVudCcpLmNoaWxkcmVuKCkuZGV0YWNoKCkuZW5kKClbIC8vIHdlIHVzZSBhcHBlbmQgZm9yIGh0bWwgb2JqZWN0cyB0byBtYWludGFpbiBqcyBldmVudHNcbiAgICAgIHRoaXMub3B0aW9ucy5odG1sID8gKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnID8gJ2h0bWwnIDogJ2FwcGVuZCcpIDogJ3RleHQnXG4gICAgXShjb250ZW50KVxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSB0b3AgYm90dG9tIGxlZnQgcmlnaHQgaW4nKVxuXG4gICAgLy8gSUU4IGRvZXNuJ3QgYWNjZXB0IGhpZGluZyB2aWEgdGhlIGA6ZW1wdHlgIHBzZXVkbyBzZWxlY3Rvciwgd2UgaGF2ZSB0byBkb1xuICAgIC8vIHRoaXMgbWFudWFsbHkgYnkgY2hlY2tpbmcgdGhlIGNvbnRlbnRzLlxuICAgIGlmICghJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmh0bWwoKSkgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmhpZGUoKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuZ2V0Q29udGVudCgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkZSA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgbyAgPSB0aGlzLm9wdGlvbnNcblxuICAgIHJldHVybiAkZS5hdHRyKCdkYXRhLWNvbnRlbnQnKVxuICAgICAgfHwgKHR5cGVvZiBvLmNvbnRlbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBvLmNvbnRlbnQuY2FsbCgkZVswXSkgOlxuICAgICAgICAgICAgby5jb250ZW50KVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLmFycm93JykpXG4gIH1cblxuXG4gIC8vIFBPUE9WRVIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3Qob3B0aW9uKSkgcmV0dXJuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHNjcm9sbHNweS5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Njcm9sbHNweVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFNDUk9MTFNQWSBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gU2Nyb2xsU3B5KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRib2R5ICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQgPSAkKGVsZW1lbnQpLmlzKGRvY3VtZW50LmJvZHkpID8gJCh3aW5kb3cpIDogJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgICAgICAgPSAkLmV4dGVuZCh7fSwgU2Nyb2xsU3B5LkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuc2VsZWN0b3IgICAgICAgPSAodGhpcy5vcHRpb25zLnRhcmdldCB8fCAnJykgKyAnIC5uYXYgbGkgPiBhJ1xuICAgIHRoaXMub2Zmc2V0cyAgICAgICAgPSBbXVxuICAgIHRoaXMudGFyZ2V0cyAgICAgICAgPSBbXVxuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgICA9IDBcblxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQub24oJ3Njcm9sbC5icy5zY3JvbGxzcHknLCAkLnByb3h5KHRoaXMucHJvY2VzcywgdGhpcykpXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLnByb2Nlc3MoKVxuICB9XG5cbiAgU2Nyb2xsU3B5LlZFUlNJT04gID0gJzMuMy41J1xuXG4gIFNjcm9sbFNweS5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDEwXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kc2Nyb2xsRWxlbWVudFswXS5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgICAgICAgICAgPSB0aGlzXG4gICAgdmFyIG9mZnNldE1ldGhvZCAgPSAnb2Zmc2V0J1xuICAgIHZhciBvZmZzZXRCYXNlICAgID0gMFxuXG4gICAgdGhpcy5vZmZzZXRzICAgICAgPSBbXVxuICAgIHRoaXMudGFyZ2V0cyAgICAgID0gW11cbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcblxuICAgIGlmICghJC5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKSkge1xuICAgICAgb2Zmc2V0TWV0aG9kID0gJ3Bvc2l0aW9uJ1xuICAgICAgb2Zmc2V0QmFzZSAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKVxuICAgIH1cblxuICAgIHRoaXMuJGJvZHlcbiAgICAgIC5maW5kKHRoaXMuc2VsZWN0b3IpXG4gICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbCAgID0gJCh0aGlzKVxuICAgICAgICB2YXIgaHJlZiAgPSAkZWwuZGF0YSgndGFyZ2V0JykgfHwgJGVsLmF0dHIoJ2hyZWYnKVxuICAgICAgICB2YXIgJGhyZWYgPSAvXiMuLy50ZXN0KGhyZWYpICYmICQoaHJlZilcblxuICAgICAgICByZXR1cm4gKCRocmVmXG4gICAgICAgICAgJiYgJGhyZWYubGVuZ3RoXG4gICAgICAgICAgJiYgJGhyZWYuaXMoJzp2aXNpYmxlJylcbiAgICAgICAgICAmJiBbWyRocmVmW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLCBocmVmXV0pIHx8IG51bGxcbiAgICAgIH0pXG4gICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF0gfSlcbiAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5vZmZzZXRzLnB1c2godGhpc1swXSlcbiAgICAgICAgdGhhdC50YXJnZXRzLnB1c2godGhpc1sxXSlcbiAgICAgIH0pXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkgKyB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcbiAgICB2YXIgbWF4U2Nyb2xsICAgID0gdGhpcy5vcHRpb25zLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0cyAgICAgID0gdGhpcy5vZmZzZXRzXG4gICAgdmFyIHRhcmdldHMgICAgICA9IHRoaXMudGFyZ2V0c1xuICAgIHZhciBhY3RpdmVUYXJnZXQgPSB0aGlzLmFjdGl2ZVRhcmdldFxuICAgIHZhciBpXG5cbiAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgIT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0ICE9IChpID0gdGFyZ2V0c1t0YXJnZXRzLmxlbmd0aCAtIDFdKSAmJiB0aGlzLmFjdGl2YXRlKGkpXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCBvZmZzZXRzWzBdKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYWN0aXZlVGFyZ2V0ICE9IHRhcmdldHNbaV1cbiAgICAgICAgJiYgc2Nyb2xsVG9wID49IG9mZnNldHNbaV1cbiAgICAgICAgJiYgKG9mZnNldHNbaSArIDFdID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsVG9wIDwgb2Zmc2V0c1tpICsgMV0pXG4gICAgICAgICYmIHRoaXMuYWN0aXZhdGUodGFyZ2V0c1tpXSlcbiAgICB9XG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLmNsZWFyKClcblxuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgK1xuICAgICAgJ1tkYXRhLXRhcmdldD1cIicgKyB0YXJnZXQgKyAnXCJdLCcgK1xuICAgICAgdGhpcy5zZWxlY3RvciArICdbaHJlZj1cIicgKyB0YXJnZXQgKyAnXCJdJ1xuXG4gICAgdmFyIGFjdGl2ZSA9ICQoc2VsZWN0b3IpXG4gICAgICAucGFyZW50cygnbGknKVxuICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuXG4gICAgaWYgKGFjdGl2ZS5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICBhY3RpdmUgPSBhY3RpdmVcbiAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIGFjdGl2ZS50cmlnZ2VyKCdhY3RpdmF0ZS5icy5zY3JvbGxzcHknKVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKHRoaXMuc2VsZWN0b3IpXG4gICAgICAucGFyZW50c1VudGlsKHRoaXMub3B0aW9ucy50YXJnZXQsICcuYWN0aXZlJylcbiAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScsIChkYXRhID0gbmV3IFNjcm9sbFNweSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uc2Nyb2xsc3B5XG5cbiAgJC5mbi5zY3JvbGxzcHkgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3IgPSBTY3JvbGxTcHlcblxuXG4gIC8vIFNDUk9MTFNQWSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uc2Nyb2xsc3B5ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksICRzcHkuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVEFCIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBqc2NzOmRpc2FibGUgcmVxdWlyZURvbGxhckJlZm9yZWpRdWVyeUFzc2lnbm1lbnRcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgLy8ganNjczplbmFibGUgcmVxdWlyZURvbGxhckJlZm9yZWpRdWVyeUFzc2lnbm1lbnRcbiAgfVxuXG4gIFRhYi5WRVJTSU9OID0gJzMuMy41J1xuXG4gIFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGhpcyAgICA9IHRoaXMuZWxlbWVudFxuICAgIHZhciAkdWwgICAgICA9ICR0aGlzLmNsb3Nlc3QoJ3VsOm5vdCguZHJvcGRvd24tbWVudSknKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmRhdGEoJ3RhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIGlmICgkdGhpcy5wYXJlbnQoJ2xpJykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm5cblxuICAgIHZhciAkcHJldmlvdXMgPSAkdWwuZmluZCgnLmFjdGl2ZTpsYXN0IGEnKVxuICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgfSlcbiAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudCgnc2hvdy5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICB9KVxuXG4gICAgJHByZXZpb3VzLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICR0aGlzLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyICR0YXJnZXQgPSAkKHNlbGVjdG9yKVxuXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGhpcy5jbG9zZXN0KCdsaScpLCAkdWwpXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGFyZ2V0LCAkdGFyZ2V0LnBhcmVudCgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkcHJldmlvdXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdoaWRkZW4uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICAgIH0pXG4gICAgICAkdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ3Nob3duLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgVGFiLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyICRhY3RpdmUgICAgPSBjb250YWluZXIuZmluZCgnPiAuYWN0aXZlJylcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGNhbGxiYWNrXG4gICAgICAmJiAkLnN1cHBvcnQudHJhbnNpdGlvblxuICAgICAgJiYgKCRhY3RpdmUubGVuZ3RoICYmICRhY3RpdmUuaGFzQ2xhc3MoJ2ZhZGUnKSB8fCAhIWNvbnRhaW5lci5maW5kKCc+IC5mYWRlJykubGVuZ3RoKVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmUnKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgIGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2ZhZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgJGFjdGl2ZS5sZW5ndGggJiYgdHJhbnNpdGlvbiA/XG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIG5leHQpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUYWIuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgbmV4dCgpXG5cbiAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKCdpbicpXG4gIH1cblxuXG4gIC8vIFRBQiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy50YWInKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRhYicsIChkYXRhID0gbmV3IFRhYih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udGFiXG5cbiAgJC5mbi50YWIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi50YWIuQ29uc3RydWN0b3IgPSBUYWJcblxuXG4gIC8vIFRBQiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkLmZuLnRhYi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udGFiID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gVEFCIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PVxuXG4gIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIFBsdWdpbi5jYWxsKCQodGhpcyksICdzaG93JylcbiAgfVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInBpbGxcIl0nLCBjbGlja0hhbmRsZXIpXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0b29sdGlwLmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdG9vbHRpcFxuICogSW5zcGlyZWQgYnkgdGhlIG9yaWdpbmFsIGpRdWVyeS50aXBzeSBieSBKYXNvbiBGcmFtZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRPT0xUSVAgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcHRpb25zICAgID0gbnVsbFxuICAgIHRoaXMuZW5hYmxlZCAgICA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgICAgPSBudWxsXG4gICAgdGhpcy5ob3ZlclN0YXRlID0gbnVsbFxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcbiAgICB0aGlzLmluU3RhdGUgICAgPSBudWxsXG5cbiAgICB0aGlzLmluaXQoJ3Rvb2x0aXAnLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgVG9vbHRpcC5WRVJTSU9OICA9ICczLjMuNSdcblxuICBUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUb29sdGlwLkRFRkFVTFRTID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBkZWxheTogMCxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgICAgcGFkZGluZzogMFxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodHlwZSwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCAgID0gdHJ1ZVxuICAgIHRoaXMudHlwZSAgICAgID0gdHlwZVxuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gdGhpcy5nZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy4kdmlld3BvcnQgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgJCgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnZpZXdwb3J0KSA/IHRoaXMub3B0aW9ucy52aWV3cG9ydC5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQpIDogKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpKVxuICAgIHRoaXMuaW5TdGF0ZSAgID0geyBjbGljazogZmFsc2UsIGhvdmVyOiBmYWxzZSwgZm9jdXM6IGZhbHNlIH1cblxuICAgIGlmICh0aGlzLiRlbGVtZW50WzBdIGluc3RhbmNlb2YgZG9jdW1lbnQuY29uc3RydWN0b3IgJiYgIXRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgc2VsZWN0b3JgIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemluZyAnICsgdGhpcy50eXBlICsgJyBvbiB0aGUgd2luZG93LmRvY3VtZW50IG9iamVjdCEnKVxuICAgIH1cblxuICAgIHZhciB0cmlnZ2VycyA9IHRoaXMub3B0aW9ucy50cmlnZ2VyLnNwbGl0KCcgJylcblxuICAgIGZvciAodmFyIGkgPSB0cmlnZ2Vycy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gdHJpZ2dlcnNbaV1cblxuICAgICAgaWYgKHRyaWdnZXIgPT0gJ2NsaWNrJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy50b2dnbGUsIHRoaXMpKVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9ICdtYW51YWwnKSB7XG4gICAgICAgIHZhciBldmVudEluICA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWVudGVyJyA6ICdmb2N1c2luJ1xuICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VsZWF2ZScgOiAnZm9jdXNvdXQnXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudEluICArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMuZW50ZXIsIHRoaXMpKVxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50T3V0ICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5sZWF2ZSwgdGhpcykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnNlbGVjdG9yID9cbiAgICAgICh0aGlzLl9vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgeyB0cmlnZ2VyOiAnbWFudWFsJywgc2VsZWN0b3I6ICcnIH0pKSA6XG4gICAgICB0aGlzLmZpeFRpdGxlKClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUb29sdGlwLkRFRkFVTFRTXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMuZ2V0RGVmYXVsdHMoKSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpXG5cbiAgICBpZiAob3B0aW9ucy5kZWxheSAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSA9PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogb3B0aW9ucy5kZWxheSxcbiAgICAgICAgaGlkZTogb3B0aW9ucy5kZWxheVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgID0ge31cbiAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmdldERlZmF1bHRzKClcblxuICAgIHRoaXMuX29wdGlvbnMgJiYgJC5lYWNoKHRoaXMuX29wdGlvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoZGVmYXVsdHNba2V5XSAhPSB2YWx1ZSkgb3B0aW9uc1trZXldID0gdmFsdWVcbiAgICB9KVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiAkLkV2ZW50KSB7XG4gICAgICBzZWxmLmluU3RhdGVbb2JqLnR5cGUgPT0gJ2ZvY3VzaW4nID8gJ2ZvY3VzJyA6ICdob3ZlciddID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzZWxmLnRpcCgpLmhhc0NsYXNzKCdpbicpIHx8IHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSB7XG4gICAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaXNJblN0YXRlVHJ1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pblN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5pblN0YXRlW2tleV0pIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgJC5FdmVudCkge1xuICAgICAgc2VsZi5pblN0YXRlW29iai50eXBlID09ICdmb2N1c291dCcgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzZWxmLmlzSW5TdGF0ZVRydWUoKSkgcmV0dXJuXG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ291dCdcblxuICAgIGlmICghc2VsZi5vcHRpb25zLmRlbGF5IHx8ICFzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSkgcmV0dXJuIHNlbGYuaGlkZSgpXG5cbiAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmhvdmVyU3RhdGUgPT0gJ291dCcpIHNlbGYuaGlkZSgpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gJC5FdmVudCgnc2hvdy5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKHRoaXMuaGFzQ29udGVudCgpICYmIHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIHZhciBpbkRvbSA9ICQuY29udGFpbnModGhpcy4kZWxlbWVudFswXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy4kZWxlbWVudFswXSlcbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpbkRvbSkgcmV0dXJuXG4gICAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgICAgdmFyICR0aXAgPSB0aGlzLnRpcCgpXG5cbiAgICAgIHZhciB0aXBJZCA9IHRoaXMuZ2V0VUlEKHRoaXMudHlwZSlcblxuICAgICAgdGhpcy5zZXRDb250ZW50KClcbiAgICAgICR0aXAuYXR0cignaWQnLCB0aXBJZClcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRpcElkKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikgJHRpcC5hZGRDbGFzcygnZmFkZScpXG5cbiAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudC5jYWxsKHRoaXMsICR0aXBbMF0sIHRoaXMuJGVsZW1lbnRbMF0pIDpcbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudFxuXG4gICAgICB2YXIgYXV0b1Rva2VuID0gL1xccz9hdXRvP1xccz8vaVxuICAgICAgdmFyIGF1dG9QbGFjZSA9IGF1dG9Ub2tlbi50ZXN0KHBsYWNlbWVudClcbiAgICAgIGlmIChhdXRvUGxhY2UpIHBsYWNlbWVudCA9IHBsYWNlbWVudC5yZXBsYWNlKGF1dG9Ub2tlbiwgJycpIHx8ICd0b3AnXG5cbiAgICAgICR0aXBcbiAgICAgICAgLmRldGFjaCgpXG4gICAgICAgIC5jc3MoeyB0b3A6IDAsIGxlZnQ6IDAsIGRpc3BsYXk6ICdibG9jaycgfSlcbiAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgICAgLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHRoaXMpXG5cbiAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkdGlwLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogJHRpcC5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KVxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnNlcnRlZC5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgICB2YXIgcG9zICAgICAgICAgID0gdGhpcy5nZXRQb3NpdGlvbigpXG4gICAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgICAgdmFyIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgdmFyIG9yZ1BsYWNlbWVudCA9IHBsYWNlbWVudFxuICAgICAgICB2YXIgdmlld3BvcnREaW0gPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gdmlld3BvcnREaW0uYm90dG9tID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3RvcCcgICAgJiYgcG9zLnRvcCAgICAtIGFjdHVhbEhlaWdodCA8IHZpZXdwb3J0RGltLnRvcCAgICA/ICdib3R0b20nIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCAgKyBhY3R1YWxXaWR0aCAgPiB2aWV3cG9ydERpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgdmlld3BvcnREaW0ubGVmdCAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRcblxuICAgICAgICAkdGlwXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKG9yZ1BsYWNlbWVudClcbiAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgfVxuXG4gICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChjYWxjdWxhdGVkT2Zmc2V0LCBwbGFjZW1lbnQpXG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZIb3ZlclN0YXRlID0gdGhhdC5ob3ZlclN0YXRlXG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvd24uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgICAgdGhhdC5ob3ZlclN0YXRlID0gbnVsbFxuXG4gICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PSAnb3V0JykgdGhhdC5sZWF2ZSh0aGF0KVxuICAgICAgfVxuXG4gICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgICR0aXBcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcHBseVBsYWNlbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQsIHBsYWNlbWVudCkge1xuICAgIHZhciAkdGlwICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIC8vIG1hbnVhbGx5IHJlYWQgbWFyZ2lucyBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpbmNsdWRlcyBkaWZmZXJlbmNlXG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tdG9wJyksIDEwKVxuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi1sZWZ0JyksIDEwKVxuXG4gICAgLy8gd2UgbXVzdCBjaGVjayBmb3IgTmFOIGZvciBpZSA4LzlcbiAgICBpZiAoaXNOYU4obWFyZ2luVG9wKSkgIG1hcmdpblRvcCAgPSAwXG4gICAgaWYgKGlzTmFOKG1hcmdpbkxlZnQpKSBtYXJnaW5MZWZ0ID0gMFxuXG4gICAgb2Zmc2V0LnRvcCAgKz0gbWFyZ2luVG9wXG4gICAgb2Zmc2V0LmxlZnQgKz0gbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNWZXJ0aWNhbCkge1xuICAgIHRoaXMuYXJyb3coKVxuICAgICAgLmNzcyhpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCcsIDUwICogKDEgLSBkZWx0YSAvIGRpbWVuc2lvbikgKyAnJScpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gJCh0aGlzLiR0aXApXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdoaWRlLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICh0aGF0LmhvdmVyU3RhdGUgIT0gJ2luJykgJHRpcC5kZXRhY2goKVxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykgIT0gJ3N0cmluZycpIHtcbiAgICAgICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCAkZS5hdHRyKCd0aXRsZScpIHx8ICcnKS5hdHRyKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAkZWxlbWVudCAgID0gJGVsZW1lbnQgfHwgdGhpcy4kZWxlbWVudFxuXG4gICAgdmFyIGVsICAgICA9ICRlbGVtZW50WzBdXG4gICAgdmFyIGlzQm9keSA9IGVsLnRhZ05hbWUgPT0gJ0JPRFknXG5cbiAgICB2YXIgZWxSZWN0ICAgID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoZWxSZWN0LndpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG1pc3NpbmcgaW4gSUU4LCBzbyBjb21wdXRlIHRoZW0gbWFudWFsbHk7IHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzE0MDkzXG4gICAgICBlbFJlY3QgPSAkLmV4dGVuZCh7fSwgZWxSZWN0LCB7IHdpZHRoOiBlbFJlY3QucmlnaHQgLSBlbFJlY3QubGVmdCwgaGVpZ2h0OiBlbFJlY3QuYm90dG9tIC0gZWxSZWN0LnRvcCB9KVxuICAgIH1cbiAgICB2YXIgZWxPZmZzZXQgID0gaXNCb2R5ID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6ICRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHNjcm9sbCAgICA9IHsgc2Nyb2xsOiBpc0JvZHkgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIDogJGVsZW1lbnQuc2Nyb2xsVG9wKCkgfVxuICAgIHZhciBvdXRlckRpbXMgPSBpc0JvZHkgPyB7IHdpZHRoOiAkKHdpbmRvdykud2lkdGgoKSwgaGVpZ2h0OiAkKHdpbmRvdykuaGVpZ2h0KCkgfSA6IG51bGxcblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZWxSZWN0LCBzY3JvbGwsIG91dGVyRGltcywgZWxPZmZzZXQpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudCA9PSAnYm90dG9tJyA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgICBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRoIH0gOlxuICAgICAgICAvKiBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAqLyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLnJpZ2h0KSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkge1xuICAgICAgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgICBpZiAodGhpcy4kdGlwLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnR5cGUgKyAnIGB0ZW1wbGF0ZWAgb3B0aW9uIG11c3QgY29uc2lzdCBvZiBleGFjdGx5IDEgdG9wLWxldmVsIGVsZW1lbnQhJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLnRvb2x0aXAtYXJyb3cnKSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWRcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKGUpIHtcbiAgICAgIHNlbGYgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcbiAgICAgIGlmICghc2VsZikge1xuICAgICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZS5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgc2VsZi5pblN0YXRlLmNsaWNrID0gIXNlbGYuaW5TdGF0ZS5jbGlja1xuICAgICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSBzZWxmLmVudGVyKHNlbGYpXG4gICAgICBlbHNlIHNlbGYubGVhdmUoc2VsZilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50aXAoKS5oYXNDbGFzcygnaW4nKSA/IHNlbGYubGVhdmUoc2VsZikgOiBzZWxmLmVudGVyKHNlbGYpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgICBpZiAodGhhdC4kdGlwKSB7XG4gICAgICAgIHRoYXQuJHRpcC5kZXRhY2goKVxuICAgICAgfVxuICAgICAgdGhhdC4kdGlwID0gbnVsbFxuICAgICAgdGhhdC4kYXJyb3cgPSBudWxsXG4gICAgICB0aGF0LiR2aWV3cG9ydCA9IG51bGxcbiAgICB9KVxuICB9XG5cblxuICAvLyBUT09MVElQIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGVzdHJveXxoaWRlLy50ZXN0KG9wdGlvbikpIHJldHVyblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qISBAbGljZW5zZSBGaXJlYmFzZSB2Mi4zLjFcbiAgICBMaWNlbnNlOiBodHRwczovL3d3dy5maXJlYmFzZS5jb20vdGVybXMvdGVybXMtb2Ytc2VydmljZS5odG1sICovXG4oZnVuY3Rpb24oKSB7dmFyIGcsYWE9dGhpcztmdW5jdGlvbiBuKGEpe3JldHVybiB2b2lkIDAhPT1hfWZ1bmN0aW9uIGJhKCl7fWZ1bmN0aW9uIGNhKGEpe2EudWI9ZnVuY3Rpb24oKXtyZXR1cm4gYS51Zj9hLnVmOmEudWY9bmV3IGF9fVxuZnVuY3Rpb24gZGEoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSl7cmV0dXJuXCJhcnJheVwiPT1kYShhKX1mdW5jdGlvbiBmYShhKXt2YXIgYj1kYShhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBwKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGdhKGEpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGhhKGEpe3JldHVyblwiZnVuY3Rpb25cIj09ZGEoYSl9ZnVuY3Rpb24gaWEoYSl7dmFyIGI9dHlwZW9mIGE7cmV0dXJuXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGphKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfVxuZnVuY3Rpb24ga2EoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcShhLGIsYyl7cT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2phOmthO3JldHVybiBxLmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgbGE9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfTtcbmZ1bmN0aW9uIG1hKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLmJoPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5ZZz1mdW5jdGlvbihhLGMsZil7Zm9yKHZhciBoPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMiksaz0yO2s8YXJndW1lbnRzLmxlbmd0aDtrKyspaFtrLTJdPWFyZ3VtZW50c1trXTtyZXR1cm4gYi5wcm90b3R5cGVbY10uYXBwbHkoYSxoKX19O2Z1bmN0aW9uIHIoYSxiKXtmb3IodmFyIGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKX1mdW5jdGlvbiBuYShhLGIpe3ZhciBjPXt9LGQ7Zm9yKGQgaW4gYSljW2RdPWIuY2FsbCh2b2lkIDAsYVtkXSxkLGEpO3JldHVybiBjfWZ1bmN0aW9uIG9hKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHBhKGEpe3ZhciBiPTAsYztmb3IoYyBpbiBhKWIrKztyZXR1cm4gYn1mdW5jdGlvbiBxYShhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4gYn1mdW5jdGlvbiByYShhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1hW2RdO3JldHVybiBifWZ1bmN0aW9uIHNhKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWQ7cmV0dXJuIGJ9ZnVuY3Rpb24gdGEoYSxiKXtmb3IodmFyIGMgaW4gYSlpZihhW2NdPT1iKXJldHVybiEwO3JldHVybiExfVxuZnVuY3Rpb24gdWEoYSxiLGMpe2Zvcih2YXIgZCBpbiBhKWlmKGIuY2FsbChjLGFbZF0sZCxhKSlyZXR1cm4gZH1mdW5jdGlvbiB2YShhLGIpe3ZhciBjPXVhKGEsYix2b2lkIDApO3JldHVybiBjJiZhW2NdfWZ1bmN0aW9uIHdhKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHhhKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9dmFyIHlhPVwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gemEoYSxiKXtmb3IodmFyIGMsZCxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKHZhciBmPTA7Zjx5YS5sZW5ndGg7ZisrKWM9eWFbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pfX07ZnVuY3Rpb24gQWEoYSl7YT1TdHJpbmcoYSk7aWYoL15cXHMqJC8udGVzdChhKT8wOi9eW1xcXSw6e31cXHNcXHUyMDI4XFx1MjAyOV0qJC8udGVzdChhLnJlcGxhY2UoL1xcXFxbXCJcXFxcXFwvYmZucnR1XS9nLFwiQFwiKS5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHgwMC1cXHgwOFxceDBhLVxceDFmXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZyxcIl1cIikucmVwbGFjZSgvKD86Xnw6fCwpKD86W1xcc1xcdTIwMjhcXHUyMDI5XSpcXFspKy9nLFwiXCIpKSl0cnl7cmV0dXJuIGV2YWwoXCIoXCIrYStcIilcIil9Y2F0Y2goYil7fXRocm93IEVycm9yKFwiSW52YWxpZCBKU09OIHN0cmluZzogXCIrYSk7fWZ1bmN0aW9uIEJhKCl7dGhpcy5TZD12b2lkIDB9XG5mdW5jdGlvbiBDYShhLGIsYyl7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwic3RyaW5nXCI6RGEoYixjKTticmVhaztjYXNlIFwibnVtYmVyXCI6Yy5wdXNoKGlzRmluaXRlKGIpJiYhaXNOYU4oYik/YjpcIm51bGxcIik7YnJlYWs7Y2FzZSBcImJvb2xlYW5cIjpjLnB1c2goYik7YnJlYWs7Y2FzZSBcInVuZGVmaW5lZFwiOmMucHVzaChcIm51bGxcIik7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOmlmKG51bGw9PWIpe2MucHVzaChcIm51bGxcIik7YnJlYWt9aWYoZWEoYikpe3ZhciBkPWIubGVuZ3RoO2MucHVzaChcIltcIik7Zm9yKHZhciBlPVwiXCIsZj0wO2Y8ZDtmKyspYy5wdXNoKGUpLGU9YltmXSxDYShhLGEuU2Q/YS5TZC5jYWxsKGIsU3RyaW5nKGYpLGUpOmUsYyksZT1cIixcIjtjLnB1c2goXCJdXCIpO2JyZWFrfWMucHVzaChcIntcIik7ZD1cIlwiO2ZvcihmIGluIGIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsZikmJihlPWJbZl0sXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmKGMucHVzaChkKSxEYShmLGMpLFxuYy5wdXNoKFwiOlwiKSxDYShhLGEuU2Q/YS5TZC5jYWxsKGIsZixlKTplLGMpLGQ9XCIsXCIpKTtjLnB1c2goXCJ9XCIpO2JyZWFrO2Nhc2UgXCJmdW5jdGlvblwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiK3R5cGVvZiBiKTt9fXZhciBFYT17J1wiJzonXFxcXFwiJyxcIlxcXFxcIjpcIlxcXFxcXFxcXCIsXCIvXCI6XCJcXFxcL1wiLFwiXFxiXCI6XCJcXFxcYlwiLFwiXFxmXCI6XCJcXFxcZlwiLFwiXFxuXCI6XCJcXFxcblwiLFwiXFxyXCI6XCJcXFxcclwiLFwiXFx0XCI6XCJcXFxcdFwiLFwiXFx4MEJcIjpcIlxcXFx1MDAwYlwifSxGYT0vXFx1ZmZmZi8udGVzdChcIlxcdWZmZmZcIik/L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx1ZmZmZl0vZzovW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHhmZl0vZztcbmZ1bmN0aW9uIERhKGEsYil7Yi5wdXNoKCdcIicsYS5yZXBsYWNlKEZhLGZ1bmN0aW9uKGEpe2lmKGEgaW4gRWEpcmV0dXJuIEVhW2FdO3ZhciBiPWEuY2hhckNvZGVBdCgwKSxlPVwiXFxcXHVcIjsxNj5iP2UrPVwiMDAwXCI6MjU2PmI/ZSs9XCIwMFwiOjQwOTY+YiYmKGUrPVwiMFwiKTtyZXR1cm4gRWFbYV09ZStiLnRvU3RyaW5nKDE2KX0pLCdcIicpfTtmdW5jdGlvbiBHYSgpe3JldHVybiBNYXRoLmZsb29yKDIxNDc0ODM2NDgqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpK01hdGguYWJzKE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKV5sYSgpKS50b1N0cmluZygzNil9O3ZhciBIYTthOnt2YXIgSWE9YWEubmF2aWdhdG9yO2lmKElhKXt2YXIgSmE9SWEudXNlckFnZW50O2lmKEphKXtIYT1KYTticmVhayBhfX1IYT1cIlwifTtmdW5jdGlvbiBLYSgpe3RoaXMuVmE9LTF9O2Z1bmN0aW9uIExhKCl7dGhpcy5WYT0tMTt0aGlzLlZhPTY0O3RoaXMuTj1bXTt0aGlzLm1lPVtdO3RoaXMuV2Y9W107dGhpcy5MZD1bXTt0aGlzLkxkWzBdPTEyODtmb3IodmFyIGE9MTthPHRoaXMuVmE7KythKXRoaXMuTGRbYV09MDt0aGlzLmRlPXRoaXMuYWM9MDt0aGlzLnJlc2V0KCl9bWEoTGEsS2EpO0xhLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuTlswXT0xNzMyNTg0MTkzO3RoaXMuTlsxXT00MDIzMjMzNDE3O3RoaXMuTlsyXT0yNTYyMzgzMTAyO3RoaXMuTlszXT0yNzE3MzM4Nzg7dGhpcy5OWzRdPTMyODUzNzc1MjA7dGhpcy5kZT10aGlzLmFjPTB9O1xuZnVuY3Rpb24gTWEoYSxiLGMpe2N8fChjPTApO3ZhciBkPWEuV2Y7aWYocChiKSlmb3IodmFyIGU9MDsxNj5lO2UrKylkW2VdPWIuY2hhckNvZGVBdChjKTw8MjR8Yi5jaGFyQ29kZUF0KGMrMSk8PDE2fGIuY2hhckNvZGVBdChjKzIpPDw4fGIuY2hhckNvZGVBdChjKzMpLGMrPTQ7ZWxzZSBmb3IoZT0wOzE2PmU7ZSsrKWRbZV09YltjXTw8MjR8YltjKzFdPDwxNnxiW2MrMl08PDh8YltjKzNdLGMrPTQ7Zm9yKGU9MTY7ODA+ZTtlKyspe3ZhciBmPWRbZS0zXV5kW2UtOF1eZFtlLTE0XV5kW2UtMTZdO2RbZV09KGY8PDF8Zj4+PjMxKSY0Mjk0OTY3Mjk1fWI9YS5OWzBdO2M9YS5OWzFdO2Zvcih2YXIgaD1hLk5bMl0saz1hLk5bM10sbD1hLk5bNF0sbSxlPTA7ODA+ZTtlKyspNDA+ZT8yMD5lPyhmPWteYyYoaF5rKSxtPTE1MTg1MDAyNDkpOihmPWNeaF5rLG09MTg1OTc3NTM5Myk6NjA+ZT8oZj1jJmh8ayYoY3xoKSxtPTI0MDA5NTk3MDgpOihmPWNeaF5rLG09MzM5NTQ2OTc4MiksZj0oYjw8XG41fGI+Pj4yNykrZitsK20rZFtlXSY0Mjk0OTY3Mjk1LGw9ayxrPWgsaD0oYzw8MzB8Yz4+PjIpJjQyOTQ5NjcyOTUsYz1iLGI9ZjthLk5bMF09YS5OWzBdK2ImNDI5NDk2NzI5NTthLk5bMV09YS5OWzFdK2MmNDI5NDk2NzI5NTthLk5bMl09YS5OWzJdK2gmNDI5NDk2NzI5NTthLk5bM109YS5OWzNdK2smNDI5NDk2NzI5NTthLk5bNF09YS5OWzRdK2wmNDI5NDk2NzI5NX1cbkxhLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXtuKGIpfHwoYj1hLmxlbmd0aCk7Zm9yKHZhciBjPWItdGhpcy5WYSxkPTAsZT10aGlzLm1lLGY9dGhpcy5hYztkPGI7KXtpZigwPT1mKWZvcig7ZDw9YzspTWEodGhpcyxhLGQpLGQrPXRoaXMuVmE7aWYocChhKSlmb3IoO2Q8Yjspe2lmKGVbZl09YS5jaGFyQ29kZUF0KGQpLCsrZiwrK2QsZj09dGhpcy5WYSl7TWEodGhpcyxlKTtmPTA7YnJlYWt9fWVsc2UgZm9yKDtkPGI7KWlmKGVbZl09YVtkXSwrK2YsKytkLGY9PXRoaXMuVmEpe01hKHRoaXMsZSk7Zj0wO2JyZWFrfX10aGlzLmFjPWY7dGhpcy5kZSs9Yn19O3ZhciB1PUFycmF5LnByb3RvdHlwZSxOYT11LmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1LmluZGV4T2YuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtjPW51bGw9PWM/MDowPmM/TWF0aC5tYXgoMCxhLmxlbmd0aCtjKTpjO2lmKHAoYSkpcmV0dXJuIHAoYikmJjE9PWIubGVuZ3RoP2EuaW5kZXhPZihiLGMpOi0xO2Zvcig7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sT2E9dS5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt1LmZvckVhY2guY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKX0sUGE9dS5maWx0ZXI/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1LmZpbHRlci5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxoPXAoYSk/XG5hLnNwbGl0KFwiXCIpOmEsaz0wO2s8ZDtrKyspaWYoayBpbiBoKXt2YXIgbD1oW2tdO2IuY2FsbChjLGwsayxhKSYmKGVbZisrXT1sKX1yZXR1cm4gZX0sUWE9dS5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB1Lm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9cChhKT9hLnNwbGl0KFwiXCIpOmEsaD0wO2g8ZDtoKyspaCBpbiBmJiYoZVtoXT1iLmNhbGwoYyxmW2hdLGgsYSkpO3JldHVybiBlfSxSYT11LnJlZHVjZT9mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9W10sZj0xLGg9YXJndW1lbnRzLmxlbmd0aDtmPGg7ZisrKWUucHVzaChhcmd1bWVudHNbZl0pO2QmJihlWzBdPXEoYixkKSk7cmV0dXJuIHUucmVkdWNlLmFwcGx5KGEsZSl9OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWM7T2EoYSxmdW5jdGlvbihjLGgpe2U9Yi5jYWxsKGQsZSxjLGgsYSl9KTtyZXR1cm4gZX0sU2E9dS5ldmVyeT9mdW5jdGlvbihhLGIsXG5jKXtyZXR1cm4gdS5ldmVyeS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmIWIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMTtyZXR1cm4hMH07ZnVuY3Rpb24gVGEoYSxiKXt2YXIgYz1VYShhLGIsdm9pZCAwKTtyZXR1cm4gMD5jP251bGw6cChhKT9hLmNoYXJBdChjKTphW2NdfWZ1bmN0aW9uIFVhKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4gZjtyZXR1cm4tMX1mdW5jdGlvbiBWYShhLGIpe3ZhciBjPU5hKGEsYik7MDw9YyYmdS5zcGxpY2UuY2FsbChhLGMsMSl9ZnVuY3Rpb24gV2EoYSxiLGMpe3JldHVybiAyPj1hcmd1bWVudHMubGVuZ3RoP3Uuc2xpY2UuY2FsbChhLGIpOnUuc2xpY2UuY2FsbChhLGIsYyl9XG5mdW5jdGlvbiBYYShhLGIpe2Euc29ydChifHxZYSl9ZnVuY3Rpb24gWWEoYSxiKXtyZXR1cm4gYT5iPzE6YTxiPy0xOjB9O3ZhciBaYT0tMSE9SGEuaW5kZXhPZihcIk9wZXJhXCIpfHwtMSE9SGEuaW5kZXhPZihcIk9QUlwiKSwkYT0tMSE9SGEuaW5kZXhPZihcIlRyaWRlbnRcIil8fC0xIT1IYS5pbmRleE9mKFwiTVNJRVwiKSxhYj0tMSE9SGEuaW5kZXhPZihcIkdlY2tvXCIpJiYtMT09SGEudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhKC0xIT1IYS5pbmRleE9mKFwiVHJpZGVudFwiKXx8LTEhPUhhLmluZGV4T2YoXCJNU0lFXCIpKSxiYj0tMSE9SGEudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpO1xuKGZ1bmN0aW9uKCl7dmFyIGE9XCJcIixiO2lmKFphJiZhYS5vcGVyYSlyZXR1cm4gYT1hYS5vcGVyYS52ZXJzaW9uLGhhKGEpP2EoKTphO2FiP2I9L3J2XFw6KFteXFwpO10rKShcXCl8OykvOiRhP2I9L1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLzpiYiYmKGI9L1dlYktpdFxcLyhcXFMrKS8pO2ImJihhPShhPWIuZXhlYyhIYSkpP2FbMV06XCJcIik7cmV0dXJuICRhJiYoYj0oYj1hYS5kb2N1bWVudCk/Yi5kb2N1bWVudE1vZGU6dm9pZCAwLGI+cGFyc2VGbG9hdChhKSk/U3RyaW5nKGIpOmF9KSgpO3ZhciBjYj1udWxsLGRiPW51bGwsZWI9bnVsbDtmdW5jdGlvbiBmYihhLGIpe2lmKCFmYShhKSl0aHJvdyBFcnJvcihcImVuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlclwiKTtnYigpO2Zvcih2YXIgYz1iP2RiOmNiLGQ9W10sZT0wO2U8YS5sZW5ndGg7ZSs9Myl7dmFyIGY9YVtlXSxoPWUrMTxhLmxlbmd0aCxrPWg/YVtlKzFdOjAsbD1lKzI8YS5sZW5ndGgsbT1sP2FbZSsyXTowLHQ9Zj4+MixmPShmJjMpPDw0fGs+PjQsaz0oayYxNSk8PDJ8bT4+NixtPW0mNjM7bHx8KG09NjQsaHx8KGs9NjQpKTtkLnB1c2goY1t0XSxjW2ZdLGNba10sY1ttXSl9cmV0dXJuIGQuam9pbihcIlwiKX1cbmZ1bmN0aW9uIGdiKCl7aWYoIWNiKXtjYj17fTtkYj17fTtlYj17fTtmb3IodmFyIGE9MDs2NT5hO2ErKyljYlthXT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIuY2hhckF0KGEpLGRiW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXy5cIi5jaGFyQXQoYSksZWJbZGJbYV1dPWEsNjI8PWEmJihlYltcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIuY2hhckF0KGEpXT1hKX19O3ZhciBoYj1oYnx8XCIyLjMuMVwiO2Z1bmN0aW9uIHYoYSxiKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYil9ZnVuY3Rpb24gdyhhLGIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGIpKXJldHVybiBhW2JdfWZ1bmN0aW9uIGliKGEsYil7Zm9yKHZhciBjIGluIGEpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYykmJmIoYyxhW2NdKX1mdW5jdGlvbiBqYihhKXt2YXIgYj17fTtpYihhLGZ1bmN0aW9uKGEsZCl7YlthXT1kfSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIGtiKGEpe3ZhciBiPVtdO2liKGEsZnVuY3Rpb24oYSxkKXtlYShkKT9PYShkLGZ1bmN0aW9uKGQpe2IucHVzaChlbmNvZGVVUklDb21wb25lbnQoYSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGQpKX0pOmIucHVzaChlbmNvZGVVUklDb21wb25lbnQoYSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGQpKX0pO3JldHVybiBiLmxlbmd0aD9cIiZcIitiLmpvaW4oXCImXCIpOlwiXCJ9ZnVuY3Rpb24gbGIoYSl7dmFyIGI9e307YT1hLnJlcGxhY2UoL15cXD8vLFwiXCIpLnNwbGl0KFwiJlwiKTtPYShhLGZ1bmN0aW9uKGEpe2EmJihhPWEuc3BsaXQoXCI9XCIpLGJbYVswXV09YVsxXSl9KTtyZXR1cm4gYn07ZnVuY3Rpb24geChhLGIsYyxkKXt2YXIgZTtkPGI/ZT1cImF0IGxlYXN0IFwiK2I6ZD5jJiYoZT0wPT09Yz9cIm5vbmVcIjpcIm5vIG1vcmUgdGhhbiBcIitjKTtpZihlKXRocm93IEVycm9yKGErXCIgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggXCIrZCsoMT09PWQ/XCIgYXJndW1lbnQuXCI6XCIgYXJndW1lbnRzLlwiKStcIiBFeHBlY3RzIFwiK2UrXCIuXCIpO31mdW5jdGlvbiB5KGEsYixjKXt2YXIgZD1cIlwiO3N3aXRjaChiKXtjYXNlIDE6ZD1jP1wiZmlyc3RcIjpcIkZpcnN0XCI7YnJlYWs7Y2FzZSAyOmQ9Yz9cInNlY29uZFwiOlwiU2Vjb25kXCI7YnJlYWs7Y2FzZSAzOmQ9Yz9cInRoaXJkXCI6XCJUaGlyZFwiO2JyZWFrO2Nhc2UgNDpkPWM/XCJmb3VydGhcIjpcIkZvdXJ0aFwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJlcnJvclByZWZpeCBjYWxsZWQgd2l0aCBhcmd1bWVudE51bWJlciA+IDQuICBOZWVkIHRvIHVwZGF0ZSBpdD9cIik7fXJldHVybiBhPWErXCIgZmFpbGVkOiBcIisoZCtcIiBhcmd1bWVudCBcIil9XG5mdW5jdGlvbiBBKGEsYixjLGQpe2lmKCghZHx8bihjKSkmJiFoYShjKSl0aHJvdyBFcnJvcih5KGEsYixkKStcIm11c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi5cIik7fWZ1bmN0aW9uIG1iKGEsYixjKXtpZihuKGMpJiYoIWlhKGMpfHxudWxsPT09YykpdGhyb3cgRXJyb3IoeShhLGIsITApK1wibXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LlwiKTt9O2Z1bmN0aW9uIG5iKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgSlNPTiYmbihKU09OLnBhcnNlKT9KU09OLnBhcnNlKGEpOkFhKGEpfWZ1bmN0aW9uIEIoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZuKEpTT04uc3RyaW5naWZ5KSlhPUpTT04uc3RyaW5naWZ5KGEpO2Vsc2V7dmFyIGI9W107Q2EobmV3IEJhLGEsYik7YT1iLmpvaW4oXCJcIil9cmV0dXJuIGF9O2Z1bmN0aW9uIG9iKCl7dGhpcy5XZD1DfW9iLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLldkLlEoYSl9O29iLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLldkLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIHBiKCl7fXBiLnByb3RvdHlwZS5xZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtwYi5wcm90b3R5cGUueWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07dmFyIHFiPW5ldyBwYjtmdW5jdGlvbiByYihhLGIsYyl7dGhpcy5UZj1hO3RoaXMuS2E9Yjt0aGlzLktkPWN9cmIucHJvdG90eXBlLnFmPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuS2EuTztpZihzYihiLGEpKXJldHVybiBiLmooKS5SKGEpO2I9bnVsbCE9dGhpcy5LZD9uZXcgdGIodGhpcy5LZCwhMCwhMSk6dGhpcy5LYS53KCk7cmV0dXJuIHRoaXMuVGYueGMoYSxiKX07cmIucHJvdG90eXBlLnllPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsIT10aGlzLktkP3RoaXMuS2Q6dWIodGhpcy5LYSk7YT10aGlzLlRmLm5lKGQsYiwxLGMsYSk7cmV0dXJuIDA9PT1hLmxlbmd0aD9udWxsOmFbMF19O2Z1bmN0aW9uIHZiKCl7dGhpcy50Yj1bXX1mdW5jdGlvbiB3YihhLGIpe2Zvcih2YXIgYz1udWxsLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXSxmPWUuWmIoKTtudWxsPT09Y3x8Zi5jYShjLlpiKCkpfHwoYS50Yi5wdXNoKGMpLGM9bnVsbCk7bnVsbD09PWMmJihjPW5ldyB4YihmKSk7Yy5hZGQoZSl9YyYmYS50Yi5wdXNoKGMpfWZ1bmN0aW9uIHliKGEsYixjKXt3YihhLGMpO3piKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2EoYil9KX1mdW5jdGlvbiBBYihhLGIsYyl7d2IoYSxjKTt6YihhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRhaW5zKGIpfHxiLmNvbnRhaW5zKGEpfSl9XG5mdW5jdGlvbiB6YihhLGIpe2Zvcih2YXIgYz0hMCxkPTA7ZDxhLnRiLmxlbmd0aDtkKyspe3ZhciBlPWEudGJbZF07aWYoZSlpZihlPWUuWmIoKSxiKGUpKXtmb3IodmFyIGU9YS50YltkXSxmPTA7ZjxlLnZkLmxlbmd0aDtmKyspe3ZhciBoPWUudmRbZl07aWYobnVsbCE9PWgpe2UudmRbZl09bnVsbDt2YXIgaz1oLlZiKCk7QmImJkNiKFwiZXZlbnQ6IFwiK2gudG9TdHJpbmcoKSk7RGIoayl9fWEudGJbZF09bnVsbH1lbHNlIGM9ITF9YyYmKGEudGI9W10pfWZ1bmN0aW9uIHhiKGEpe3RoaXMucmE9YTt0aGlzLnZkPVtdfXhiLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy52ZC5wdXNoKGEpfTt4Yi5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yYX07ZnVuY3Rpb24gRChhLGIsYyxkKXt0aGlzLnR5cGU9YTt0aGlzLkphPWI7dGhpcy5XYT1jO3RoaXMuS2U9ZDt0aGlzLlFkPXZvaWQgMH1mdW5jdGlvbiBFYihhKXtyZXR1cm4gbmV3IEQoRmIsYSl9dmFyIEZiPVwidmFsdWVcIjtmdW5jdGlvbiBHYihhLGIsYyxkKXt0aGlzLnVlPWI7dGhpcy5aZD1jO3RoaXMuUWQ9ZDt0aGlzLnVkPWF9R2IucHJvdG90eXBlLlpiPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5aZC5JYigpO3JldHVyblwidmFsdWVcIj09PXRoaXMudWQ/YS5wYXRoOmEucGFyZW50KCkucGF0aH07R2IucHJvdG90eXBlLnplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWR9O0diLnByb3RvdHlwZS5WYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVlLlZiKHRoaXMpfTtHYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5aYigpLnRvU3RyaW5nKCkrXCI6XCIrdGhpcy51ZCtcIjpcIitCKHRoaXMuWmQubWYoKSl9O2Z1bmN0aW9uIEhiKGEsYixjKXt0aGlzLnVlPWE7dGhpcy5lcnJvcj1iO3RoaXMucGF0aD1jfUhiLnByb3RvdHlwZS5aYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGh9O0hiLnByb3RvdHlwZS56ZT1mdW5jdGlvbigpe3JldHVyblwiY2FuY2VsXCJ9O1xuSGIucHJvdG90eXBlLlZiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWUuVmIodGhpcyl9O0hiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKStcIjpjYW5jZWxcIn07ZnVuY3Rpb24gdGIoYSxiLGMpe3RoaXMuQT1hO3RoaXMuZWE9Yjt0aGlzLlViPWN9ZnVuY3Rpb24gSWIoYSl7cmV0dXJuIGEuZWF9ZnVuY3Rpb24gSmIoYSl7cmV0dXJuIGEuVWJ9ZnVuY3Rpb24gS2IoYSxiKXtyZXR1cm4gYi5lKCk/YS5lYSYmIWEuVWI6c2IoYSxFKGIpKX1mdW5jdGlvbiBzYihhLGIpe3JldHVybiBhLmVhJiYhYS5VYnx8YS5BLkRhKGIpfXRiLnByb3RvdHlwZS5qPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQX07ZnVuY3Rpb24gTGIoYSl7dGhpcy5nZz1hO3RoaXMuRGQ9bnVsbH1MYi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZy5nZXQoKSxiPXhhKGEpO2lmKHRoaXMuRGQpZm9yKHZhciBjIGluIHRoaXMuRGQpYltjXS09dGhpcy5EZFtjXTt0aGlzLkRkPWE7cmV0dXJuIGJ9O2Z1bmN0aW9uIE1iKGEsYil7dGhpcy5PZj17fTt0aGlzLmZkPW5ldyBMYihhKTt0aGlzLmJhPWI7dmFyIGM9MUU0KzJFNCpNYXRoLnJhbmRvbSgpO3NldFRpbWVvdXQocSh0aGlzLklmLHRoaXMpLE1hdGguZmxvb3IoYykpfU1iLnByb3RvdHlwZS5JZj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZmQuZ2V0KCksYj17fSxjPSExLGQ7Zm9yKGQgaW4gYSkwPGFbZF0mJnYodGhpcy5PZixkKSYmKGJbZF09YVtkXSxjPSEwKTtjJiZ0aGlzLmJhLlVlKGIpO3NldFRpbWVvdXQocSh0aGlzLklmLHRoaXMpLE1hdGguZmxvb3IoNkU1Kk1hdGgucmFuZG9tKCkpKX07ZnVuY3Rpb24gTmIoKXt0aGlzLkVjPXt9fWZ1bmN0aW9uIE9iKGEsYixjKXtuKGMpfHwoYz0xKTt2KGEuRWMsYil8fChhLkVjW2JdPTApO2EuRWNbYl0rPWN9TmIucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3JldHVybiB4YSh0aGlzLkVjKX07dmFyIFBiPXt9LFFiPXt9O2Z1bmN0aW9uIFJiKGEpe2E9YS50b1N0cmluZygpO1BiW2FdfHwoUGJbYV09bmV3IE5iKTtyZXR1cm4gUGJbYV19ZnVuY3Rpb24gU2IoYSxiKXt2YXIgYz1hLnRvU3RyaW5nKCk7UWJbY118fChRYltjXT1iKCkpO3JldHVybiBRYltjXX07ZnVuY3Rpb24gRihhLGIpe3RoaXMubmFtZT1hO3RoaXMuUz1ifWZ1bmN0aW9uIFRiKGEsYil7cmV0dXJuIG5ldyBGKGEsYil9O2Z1bmN0aW9uIFViKGEsYil7cmV0dXJuIFZiKGEubmFtZSxiLm5hbWUpfWZ1bmN0aW9uIFdiKGEsYil7cmV0dXJuIFZiKGEsYil9O2Z1bmN0aW9uIFhiKGEsYixjKXt0aGlzLnR5cGU9WWI7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLkdhPWN9WGIucHJvdG90eXBlLlhjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBYYih0aGlzLnNvdXJjZSxHLHRoaXMuR2EuUihhKSk6bmV3IFhiKHRoaXMuc291cmNlLEgodGhpcy5wYXRoKSx0aGlzLkdhKX07WGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG92ZXJ3cml0ZTogXCIrdGhpcy5HYS50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBaYihhLGIpe3RoaXMudHlwZT0kYjt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1ifVpiLnByb3RvdHlwZS5YYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBaYih0aGlzLnNvdXJjZSxHKTpuZXcgWmIodGhpcy5zb3VyY2UsSCh0aGlzLnBhdGgpKX07WmIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGxpc3Rlbl9jb21wbGV0ZSlcIn07ZnVuY3Rpb24gYWMoYSxiKXt0aGlzLkxhPWE7dGhpcy53YT1iP2I6YmN9Zz1hYy5wcm90b3R5cGU7Zy5PYT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgYWModGhpcy5MYSx0aGlzLndhLk9hKGEsYix0aGlzLkxhKS5ZKG51bGwsbnVsbCwhMSxudWxsLG51bGwpKX07Zy5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBhYyh0aGlzLkxhLHRoaXMud2EucmVtb3ZlKGEsdGhpcy5MYSkuWShudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2cuZ2V0PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjPXRoaXMud2E7IWMuZSgpOyl7Yj10aGlzLkxhKGEsYy5rZXkpO2lmKDA9PT1iKXJldHVybiBjLnZhbHVlOzA+Yj9jPWMubGVmdDowPGImJihjPWMucmlnaHQpfXJldHVybiBudWxsfTtcbmZ1bmN0aW9uIGNjKGEsYil7Zm9yKHZhciBjLGQ9YS53YSxlPW51bGw7IWQuZSgpOyl7Yz1hLkxhKGIsZC5rZXkpO2lmKDA9PT1jKXtpZihkLmxlZnQuZSgpKXJldHVybiBlP2Uua2V5Om51bGw7Zm9yKGQ9ZC5sZWZ0OyFkLnJpZ2h0LmUoKTspZD1kLnJpZ2h0O3JldHVybiBkLmtleX0wPmM/ZD1kLmxlZnQ6MDxjJiYoZT1kLGQ9ZC5yaWdodCl9dGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZmluZCBwcmVkZWNlc3NvciBrZXkgZm9yIGEgbm9uZXhpc3RlbnQga2V5LiAgV2hhdCBnaXZlcz9cIik7fWcuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhLmUoKX07Zy5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhLmNvdW50KCl9O2cuU2M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YS5TYygpfTtnLmZjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2EuZmMoKX07Zy5pYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy53YS5pYShhKX07XG5nLlhiPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgZGModGhpcy53YSxudWxsLHRoaXMuTGEsITEsYSl9O2cuWWI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGRjKHRoaXMud2EsYSx0aGlzLkxhLCExLGIpfTtnLiRiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBkYyh0aGlzLndhLGEsdGhpcy5MYSwhMCxiKX07Zy5zZj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGRjKHRoaXMud2EsbnVsbCx0aGlzLkxhLCEwLGEpfTtmdW5jdGlvbiBkYyhhLGIsYyxkLGUpe3RoaXMuVWQ9ZXx8bnVsbDt0aGlzLkZlPWQ7dGhpcy5QYT1bXTtmb3IoZT0xOyFhLmUoKTspaWYoZT1iP2MoYS5rZXksYik6MSxkJiYoZSo9LTEpLDA+ZSlhPXRoaXMuRmU/YS5sZWZ0OmEucmlnaHQ7ZWxzZSBpZigwPT09ZSl7dGhpcy5QYS5wdXNoKGEpO2JyZWFrfWVsc2UgdGhpcy5QYS5wdXNoKGEpLGE9dGhpcy5GZT9hLnJpZ2h0OmEubGVmdH1cbmZ1bmN0aW9uIEooYSl7aWYoMD09PWEuUGEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiPWEuUGEucG9wKCksYztjPWEuVWQ/YS5VZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9O2lmKGEuRmUpZm9yKGI9Yi5sZWZ0OyFiLmUoKTspYS5QYS5wdXNoKGIpLGI9Yi5yaWdodDtlbHNlIGZvcihiPWIucmlnaHQ7IWIuZSgpOylhLlBhLnB1c2goYiksYj1iLmxlZnQ7cmV0dXJuIGN9ZnVuY3Rpb24gZWMoYSl7aWYoMD09PWEuUGEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiO2I9YS5QYTtiPWJbYi5sZW5ndGgtMV07cmV0dXJuIGEuVWQ/YS5VZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9fWZ1bmN0aW9uIGZjKGEsYixjLGQsZSl7dGhpcy5rZXk9YTt0aGlzLnZhbHVlPWI7dGhpcy5jb2xvcj1udWxsIT1jP2M6ITA7dGhpcy5sZWZ0PW51bGwhPWQ/ZDpiYzt0aGlzLnJpZ2h0PW51bGwhPWU/ZTpiY31nPWZjLnByb3RvdHlwZTtcbmcuWT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBuZXcgZmMobnVsbCE9YT9hOnRoaXMua2V5LG51bGwhPWI/Yjp0aGlzLnZhbHVlLG51bGwhPWM/Yzp0aGlzLmNvbG9yLG51bGwhPWQ/ZDp0aGlzLmxlZnQsbnVsbCE9ZT9lOnRoaXMucmlnaHQpfTtnLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVmdC5jb3VudCgpKzErdGhpcy5yaWdodC5jb3VudCgpfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5pYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5sZWZ0LmlhKGEpfHxhKHRoaXMua2V5LHRoaXMudmFsdWUpfHx0aGlzLnJpZ2h0LmlhKGEpfTtmdW5jdGlvbiBnYyhhKXtyZXR1cm4gYS5sZWZ0LmUoKT9hOmdjKGEubGVmdCl9Zy5TYz1mdW5jdGlvbigpe3JldHVybiBnYyh0aGlzKS5rZXl9O2cuZmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodC5lKCk/dGhpcy5rZXk6dGhpcy5yaWdodC5mYygpfTtcbmcuT2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7ZT10aGlzO2Q9YyhhLGUua2V5KTtlPTA+ZD9lLlkobnVsbCxudWxsLG51bGwsZS5sZWZ0Lk9hKGEsYixjKSxudWxsKTowPT09ZD9lLlkobnVsbCxiLG51bGwsbnVsbCxudWxsKTplLlkobnVsbCxudWxsLG51bGwsbnVsbCxlLnJpZ2h0Lk9hKGEsYixjKSk7cmV0dXJuIGhjKGUpfTtmdW5jdGlvbiBpYyhhKXtpZihhLmxlZnQuZSgpKXJldHVybiBiYzthLmxlZnQuZmEoKXx8YS5sZWZ0LmxlZnQuZmEoKXx8KGE9amMoYSkpO2E9YS5ZKG51bGwsbnVsbCxudWxsLGljKGEubGVmdCksbnVsbCk7cmV0dXJuIGhjKGEpfVxuZy5yZW1vdmU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2M9dGhpcztpZigwPmIoYSxjLmtleSkpYy5sZWZ0LmUoKXx8Yy5sZWZ0LmZhKCl8fGMubGVmdC5sZWZ0LmZhKCl8fChjPWpjKGMpKSxjPWMuWShudWxsLG51bGwsbnVsbCxjLmxlZnQucmVtb3ZlKGEsYiksbnVsbCk7ZWxzZXtjLmxlZnQuZmEoKSYmKGM9a2MoYykpO2MucmlnaHQuZSgpfHxjLnJpZ2h0LmZhKCl8fGMucmlnaHQubGVmdC5mYSgpfHwoYz1sYyhjKSxjLmxlZnQubGVmdC5mYSgpJiYoYz1rYyhjKSxjPWxjKGMpKSk7aWYoMD09PWIoYSxjLmtleSkpe2lmKGMucmlnaHQuZSgpKXJldHVybiBiYztkPWdjKGMucmlnaHQpO2M9Yy5ZKGQua2V5LGQudmFsdWUsbnVsbCxudWxsLGljKGMucmlnaHQpKX1jPWMuWShudWxsLG51bGwsbnVsbCxudWxsLGMucmlnaHQucmVtb3ZlKGEsYikpfXJldHVybiBoYyhjKX07Zy5mYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbG9yfTtcbmZ1bmN0aW9uIGhjKGEpe2EucmlnaHQuZmEoKSYmIWEubGVmdC5mYSgpJiYoYT1tYyhhKSk7YS5sZWZ0LmZhKCkmJmEubGVmdC5sZWZ0LmZhKCkmJihhPWtjKGEpKTthLmxlZnQuZmEoKSYmYS5yaWdodC5mYSgpJiYoYT1sYyhhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gamMoYSl7YT1sYyhhKTthLnJpZ2h0LmxlZnQuZmEoKSYmKGE9YS5ZKG51bGwsbnVsbCxudWxsLG51bGwsa2MoYS5yaWdodCkpLGE9bWMoYSksYT1sYyhhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gbWMoYSl7cmV0dXJuIGEucmlnaHQuWShudWxsLG51bGwsYS5jb2xvcixhLlkobnVsbCxudWxsLCEwLG51bGwsYS5yaWdodC5sZWZ0KSxudWxsKX1mdW5jdGlvbiBrYyhhKXtyZXR1cm4gYS5sZWZ0LlkobnVsbCxudWxsLGEuY29sb3IsbnVsbCxhLlkobnVsbCxudWxsLCEwLGEubGVmdC5yaWdodCxudWxsKSl9XG5mdW5jdGlvbiBsYyhhKXtyZXR1cm4gYS5ZKG51bGwsbnVsbCwhYS5jb2xvcixhLmxlZnQuWShudWxsLG51bGwsIWEubGVmdC5jb2xvcixudWxsLG51bGwpLGEucmlnaHQuWShudWxsLG51bGwsIWEucmlnaHQuY29sb3IsbnVsbCxudWxsKSl9ZnVuY3Rpb24gbmMoKXt9Zz1uYy5wcm90b3R5cGU7Zy5ZPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2cuT2E9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGZjKGEsYixudWxsKX07Zy5yZW1vdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5jb3VudD1mdW5jdGlvbigpe3JldHVybiAwfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5pYT1mdW5jdGlvbigpe3JldHVybiExfTtnLlNjPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2cuZmM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07Zy5mYT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgYmM9bmV3IG5jO2Z1bmN0aW9uIG9jKGEsYil7cmV0dXJuIGEmJlwib2JqZWN0XCI9PT10eXBlb2YgYT8oSyhcIi5zdlwiaW4gYSxcIlVuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzXCIpLGJbYVtcIi5zdlwiXV0pOmF9ZnVuY3Rpb24gcGMoYSxiKXt2YXIgYz1uZXcgcWM7cmMoYSxuZXcgTChcIlwiKSxmdW5jdGlvbihhLGUpe2MubmMoYSxzYyhlLGIpKX0pO3JldHVybiBjfWZ1bmN0aW9uIHNjKGEsYil7dmFyIGM9YS5DKCkuSSgpLGM9b2MoYyxiKSxkO2lmKGEuSygpKXt2YXIgZT1vYyhhLkNhKCksYik7cmV0dXJuIGUhPT1hLkNhKCl8fGMhPT1hLkMoKS5JKCk/bmV3IHRjKGUsTShjKSk6YX1kPWE7YyE9PWEuQygpLkkoKSYmKGQ9ZC5nYShuZXcgdGMoYykpKTthLlAoTixmdW5jdGlvbihhLGMpe3ZhciBlPXNjKGMsYik7ZSE9PWMmJihkPWQuVShhLGUpKX0pO3JldHVybiBkfTtmdW5jdGlvbiB1Yygpe3RoaXMud2M9e319dWMucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe251bGw9PWI/ZGVsZXRlIHRoaXMud2NbYV06dGhpcy53Y1thXT1ifTt1Yy5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiB2KHRoaXMud2MsYSk/dGhpcy53Y1thXTpudWxsfTt1Yy5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLndjW2FdfTt1Yy5wcm90b3R5cGUud2Y9ITA7ZnVuY3Rpb24gdmMoYSl7dGhpcy5GYz1hO3RoaXMuUGQ9XCJmaXJlYmFzZTpcIn1nPXZjLnByb3RvdHlwZTtnLnNldD1mdW5jdGlvbihhLGIpe251bGw9PWI/dGhpcy5GYy5yZW1vdmVJdGVtKHRoaXMuUGQrYSk6dGhpcy5GYy5zZXRJdGVtKHRoaXMuUGQrYSxCKGIpKX07Zy5nZXQ9ZnVuY3Rpb24oYSl7YT10aGlzLkZjLmdldEl0ZW0odGhpcy5QZCthKTtyZXR1cm4gbnVsbD09YT9udWxsOm5iKGEpfTtnLnJlbW92ZT1mdW5jdGlvbihhKXt0aGlzLkZjLnJlbW92ZUl0ZW0odGhpcy5QZCthKX07Zy53Zj0hMTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRmMudG9TdHJpbmcoKX07ZnVuY3Rpb24gd2MoYSl7dHJ5e2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvd1thXSl7dmFyIGI9d2luZG93W2FdO2Iuc2V0SXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIsXCJjYWNoZVwiKTtiLnJlbW92ZUl0ZW0oXCJmaXJlYmFzZTpzZW50aW5lbFwiKTtyZXR1cm4gbmV3IHZjKGIpfX1jYXRjaChjKXt9cmV0dXJuIG5ldyB1Y312YXIgeGM9d2MoXCJsb2NhbFN0b3JhZ2VcIikseWM9d2MoXCJzZXNzaW9uU3RvcmFnZVwiKTtmdW5jdGlvbiB6YyhhLGIsYyxkLGUpe3RoaXMuaG9zdD1hLnRvTG93ZXJDYXNlKCk7dGhpcy5kb21haW49dGhpcy5ob3N0LnN1YnN0cih0aGlzLmhvc3QuaW5kZXhPZihcIi5cIikrMSk7dGhpcy5rYj1iO3RoaXMuaGM9Yzt0aGlzLldnPWQ7dGhpcy5PZD1lfHxcIlwiO3RoaXMuWWE9eGMuZ2V0KFwiaG9zdDpcIithKXx8dGhpcy5ob3N0fWZ1bmN0aW9uIEFjKGEsYil7YiE9PWEuWWEmJihhLllhPWIsXCJzLVwiPT09YS5ZYS5zdWJzdHIoMCwyKSYmeGMuc2V0KFwiaG9zdDpcIithLmhvc3QsYS5ZYSkpfVxuZnVuY3Rpb24gQmMoYSxiLGMpe0soXCJzdHJpbmdcIj09PXR5cGVvZiBiLFwidHlwZW9mIHR5cGUgbXVzdCA9PSBzdHJpbmdcIik7SyhcIm9iamVjdFwiPT09dHlwZW9mIGMsXCJ0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0XCIpO2lmKGI9PT1DYyliPShhLmtiP1wid3NzOi8vXCI6XCJ3czovL1wiKSthLllhK1wiLy53cz9cIjtlbHNlIGlmKGI9PT1EYyliPShhLmtiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrYS5ZYStcIi8ubHA/XCI7ZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gY29ubmVjdGlvbiB0eXBlOiBcIitiKTthLmhvc3QhPT1hLllhJiYoYy5ucz1hLmhjKTt2YXIgZD1bXTtyKGMsZnVuY3Rpb24oYSxiKXtkLnB1c2goYitcIj1cIithKX0pO3JldHVybiBiK2Quam9pbihcIiZcIil9emMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9KHRoaXMua2I/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSt0aGlzLmhvc3Q7dGhpcy5PZCYmKGErPVwiPFwiK3RoaXMuT2QrXCI+XCIpO3JldHVybiBhfTt2YXIgRWM9ZnVuY3Rpb24oKXt2YXIgYT0xO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhKyt9fSgpO2Z1bmN0aW9uIEsoYSxiKXtpZighYSl0aHJvdyBGYyhiKTt9ZnVuY3Rpb24gRmMoYSl7cmV0dXJuIEVycm9yKFwiRmlyZWJhc2UgKFwiK2hiK1wiKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiBcIithKX1cbmZ1bmN0aW9uIEdjKGEpe3RyeXt2YXIgYjtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGF0b2IpYj1hdG9iKGEpO2Vsc2V7Z2IoKTtmb3IodmFyIGM9ZWIsZD1bXSxlPTA7ZTxhLmxlbmd0aDspe3ZhciBmPWNbYS5jaGFyQXQoZSsrKV0saD1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjA7KytlO3ZhciBrPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06NjQ7KytlO3ZhciBsPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06NjQ7KytlO2lmKG51bGw9PWZ8fG51bGw9PWh8fG51bGw9PWt8fG51bGw9PWwpdGhyb3cgRXJyb3IoKTtkLnB1c2goZjw8MnxoPj40KTs2NCE9ayYmKGQucHVzaChoPDw0JjI0MHxrPj4yKSw2NCE9bCYmZC5wdXNoKGs8PDYmMTkyfGwpKX1pZig4MTkyPmQubGVuZ3RoKWI9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGQpO2Vsc2V7YT1cIlwiO2ZvcihjPTA7YzxkLmxlbmd0aDtjKz04MTkyKWErPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxXYShkLGMsXG5jKzgxOTIpKTtiPWF9fXJldHVybiBifWNhdGNoKG0pe0NiKFwiYmFzZTY0RGVjb2RlIGZhaWxlZDogXCIsbSl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSGMoYSl7dmFyIGI9SWMoYSk7YT1uZXcgTGE7YS51cGRhdGUoYik7dmFyIGI9W10sYz04KmEuZGU7NTY+YS5hYz9hLnVwZGF0ZShhLkxkLDU2LWEuYWMpOmEudXBkYXRlKGEuTGQsYS5WYS0oYS5hYy01NikpO2Zvcih2YXIgZD1hLlZhLTE7NTY8PWQ7ZC0tKWEubWVbZF09YyYyNTUsYy89MjU2O01hKGEsYS5tZSk7Zm9yKGQ9Yz0wOzU+ZDtkKyspZm9yKHZhciBlPTI0OzA8PWU7ZS09OCliW2NdPWEuTltkXT4+ZSYyNTUsKytjO3JldHVybiBmYihiKX1cbmZ1bmN0aW9uIEpjKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWI9ZmEoYXJndW1lbnRzW2NdKT9iK0pjLmFwcGx5KG51bGwsYXJndW1lbnRzW2NdKTpcIm9iamVjdFwiPT09dHlwZW9mIGFyZ3VtZW50c1tjXT9iK0IoYXJndW1lbnRzW2NdKTpiK2FyZ3VtZW50c1tjXSxiKz1cIiBcIjtyZXR1cm4gYn12YXIgQmI9bnVsbCxLYz0hMDtmdW5jdGlvbiBDYihhKXshMD09PUtjJiYoS2M9ITEsbnVsbD09PUJiJiYhMD09PXljLmdldChcImxvZ2dpbmdfZW5hYmxlZFwiKSYmTGMoITApKTtpZihCYil7dmFyIGI9SmMuYXBwbHkobnVsbCxhcmd1bWVudHMpO0JiKGIpfX1mdW5jdGlvbiBNYyhhKXtyZXR1cm4gZnVuY3Rpb24oKXtDYihhLGFyZ3VtZW50cyl9fVxuZnVuY3Rpb24gTmMoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiBcIitKYy5hcHBseShudWxsLGFyZ3VtZW50cyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlLmVycm9yP2NvbnNvbGUuZXJyb3IoYik6Y29uc29sZS5sb2coYil9fWZ1bmN0aW9uIE9jKGEpe3ZhciBiPUpjLmFwcGx5KG51bGwsYXJndW1lbnRzKTt0aHJvdyBFcnJvcihcIkZJUkVCQVNFIEZBVEFMIEVSUk9SOiBcIitiKTt9ZnVuY3Rpb24gTyhhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBiPVwiRklSRUJBU0UgV0FSTklORzogXCIrSmMuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS53YXJuP2NvbnNvbGUud2FybihiKTpjb25zb2xlLmxvZyhiKX19XG5mdW5jdGlvbiBQYyhhKXt2YXIgYj1cIlwiLGM9XCJcIixkPVwiXCIsZT1cIlwiLGY9ITAsaD1cImh0dHBzXCIsaz00NDM7aWYocChhKSl7dmFyIGw9YS5pbmRleE9mKFwiLy9cIik7MDw9bCYmKGg9YS5zdWJzdHJpbmcoMCxsLTEpLGE9YS5zdWJzdHJpbmcobCsyKSk7bD1hLmluZGV4T2YoXCIvXCIpOy0xPT09bCYmKGw9YS5sZW5ndGgpO2I9YS5zdWJzdHJpbmcoMCxsKTtlPVwiXCI7YT1hLnN1YnN0cmluZyhsKS5zcGxpdChcIi9cIik7Zm9yKGw9MDtsPGEubGVuZ3RoO2wrKylpZigwPGFbbF0ubGVuZ3RoKXt2YXIgbT1hW2xdO3RyeXttPWRlY29kZVVSSUNvbXBvbmVudChtLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSl9Y2F0Y2godCl7fWUrPVwiL1wiK219YT1iLnNwbGl0KFwiLlwiKTszPT09YS5sZW5ndGg/KGM9YVsxXSxkPWFbMF0udG9Mb3dlckNhc2UoKSk6Mj09PWEubGVuZ3RoJiYoYz1hWzBdKTtsPWIuaW5kZXhPZihcIjpcIik7MDw9bCYmKGY9XCJodHRwc1wiPT09aHx8XCJ3c3NcIj09PWgsaz1iLnN1YnN0cmluZyhsKzEpLGlzRmluaXRlKGspJiZcbihrPVN0cmluZyhrKSksaz1wKGspPy9eXFxzKi0/MHgvaS50ZXN0KGspP3BhcnNlSW50KGssMTYpOnBhcnNlSW50KGssMTApOk5hTil9cmV0dXJue2hvc3Q6Yixwb3J0OmssZG9tYWluOmMsVGc6ZCxrYjpmLHNjaGVtZTpoLCRjOmV9fWZ1bmN0aW9uIFFjKGEpe3JldHVybiBnYShhKSYmKGEhPWF8fGE9PU51bWJlci5QT1NJVElWRV9JTkZJTklUWXx8YT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKX1cbmZ1bmN0aW9uIFJjKGEpe2lmKFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUpYSgpO2Vsc2V7dmFyIGI9ITEsYz1mdW5jdGlvbigpe2RvY3VtZW50LmJvZHk/Ynx8KGI9ITAsYSgpKTpzZXRUaW1lb3V0KGMsTWF0aC5mbG9vcigxMCkpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGMsITEpKTpkb2N1bWVudC5hdHRhY2hFdmVudCYmKGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZjKCl9KSx3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixjKSl9fVxuZnVuY3Rpb24gVmIoYSxiKXtpZihhPT09YilyZXR1cm4gMDtpZihcIltNSU5fTkFNRV1cIj09PWF8fFwiW01BWF9OQU1FXVwiPT09YilyZXR1cm4tMTtpZihcIltNSU5fTkFNRV1cIj09PWJ8fFwiW01BWF9OQU1FXVwiPT09YSlyZXR1cm4gMTt2YXIgYz1TYyhhKSxkPVNjKGIpO3JldHVybiBudWxsIT09Yz9udWxsIT09ZD8wPT1jLWQ/YS5sZW5ndGgtYi5sZW5ndGg6Yy1kOi0xOm51bGwhPT1kPzE6YTxiPy0xOjF9ZnVuY3Rpb24gVGMoYSxiKXtpZihiJiZhIGluIGIpcmV0dXJuIGJbYV07dGhyb3cgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGtleSAoXCIrYStcIikgaW4gb2JqZWN0OiBcIitCKGIpKTt9XG5mdW5jdGlvbiBVYyhhKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiBCKGEpO3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSliLnB1c2goYyk7Yi5zb3J0KCk7Yz1cIntcIjtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKykwIT09ZCYmKGMrPVwiLFwiKSxjKz1CKGJbZF0pLGMrPVwiOlwiLGMrPVVjKGFbYltkXV0pO3JldHVybiBjK1wifVwifWZ1bmN0aW9uIFZjKGEsYil7aWYoYS5sZW5ndGg8PWIpcmV0dXJuW2FdO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKz1iKWQrYj5hP2MucHVzaChhLnN1YnN0cmluZyhkLGEubGVuZ3RoKSk6Yy5wdXNoKGEuc3Vic3RyaW5nKGQsZCtiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gV2MoYSxiKXtpZihlYShhKSlmb3IodmFyIGM9MDtjPGEubGVuZ3RoOysrYyliKGMsYVtjXSk7ZWxzZSByKGEsYil9XG5mdW5jdGlvbiBYYyhhKXtLKCFRYyhhKSxcIkludmFsaWQgSlNPTiBudW1iZXJcIik7dmFyIGIsYyxkLGU7MD09PWE/KGQ9Yz0wLGI9LUluZmluaXR5PT09MS9hPzE6MCk6KGI9MD5hLGE9TWF0aC5hYnMoYSksYT49TWF0aC5wb3coMiwtMTAyMik/KGQ9TWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLkxOMiksMTAyMyksYz1kKzEwMjMsZD1NYXRoLnJvdW5kKGEqTWF0aC5wb3coMiw1Mi1kKS1NYXRoLnBvdygyLDUyKSkpOihjPTAsZD1NYXRoLnJvdW5kKGEvTWF0aC5wb3coMiwtMTA3NCkpKSk7ZT1bXTtmb3IoYT01MjthOy0tYSllLnB1c2goZCUyPzE6MCksZD1NYXRoLmZsb29yKGQvMik7Zm9yKGE9MTE7YTstLWEpZS5wdXNoKGMlMj8xOjApLGM9TWF0aC5mbG9vcihjLzIpO2UucHVzaChiPzE6MCk7ZS5yZXZlcnNlKCk7Yj1lLmpvaW4oXCJcIik7Yz1cIlwiO2ZvcihhPTA7NjQ+YTthKz04KWQ9cGFyc2VJbnQoYi5zdWJzdHIoYSw4KSwyKS50b1N0cmluZygxNiksMT09PWQubGVuZ3RoJiZcbihkPVwiMFwiK2QpLGMrPWQ7cmV0dXJuIGMudG9Mb3dlckNhc2UoKX12YXIgWWM9L14tP1xcZHsxLDEwfSQvO2Z1bmN0aW9uIFNjKGEpe3JldHVybiBZYy50ZXN0KGEpJiYoYT1OdW1iZXIoYSksLTIxNDc0ODM2NDg8PWEmJjIxNDc0ODM2NDc+PWEpP2E6bnVsbH1mdW5jdGlvbiBEYihhKXt0cnl7YSgpfWNhdGNoKGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtPKFwiRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay5cIixiLnN0YWNrfHxcIlwiKTt0aHJvdyBiO30sTWF0aC5mbG9vcigwKSl9fWZ1bmN0aW9uIFAoYSxiKXtpZihoYShhKSl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLnNsaWNlKCk7RGIoZnVuY3Rpb24oKXthLmFwcGx5KG51bGwsYyl9KX19O2Z1bmN0aW9uIEljKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hLmNoYXJDb2RlQXQoZCk7NTUyOTY8PWUmJjU2MzE5Pj1lJiYoZS09NTUyOTYsZCsrLEsoZDxhLmxlbmd0aCxcIlN1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLlwiKSxlPTY1NTM2KyhlPDwxMCkrKGEuY2hhckNvZGVBdChkKS01NjMyMCkpOzEyOD5lP2JbYysrXT1lOigyMDQ4PmU/YltjKytdPWU+PjZ8MTkyOig2NTUzNj5lP2JbYysrXT1lPj4xMnwyMjQ6KGJbYysrXT1lPj4xOHwyNDAsYltjKytdPWU+PjEyJjYzfDEyOCksYltjKytdPWU+PjYmNjN8MTI4KSxiW2MrK109ZSY2M3wxMjgpfXJldHVybiBifWZ1bmN0aW9uIFpjKGEpe2Zvcih2YXIgYj0wLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzEyOD5kP2IrKzoyMDQ4PmQ/Yis9Mjo1NTI5Njw9ZCYmNTYzMTk+PWQ/KGIrPTQsYysrKTpiKz0zfXJldHVybiBifTtmdW5jdGlvbiAkYyhhKXt2YXIgYj17fSxjPXt9LGQ9e30sZT1cIlwiO3RyeXt2YXIgZj1hLnNwbGl0KFwiLlwiKSxiPW5iKEdjKGZbMF0pfHxcIlwiKSxjPW5iKEdjKGZbMV0pfHxcIlwiKSxlPWZbMl0sZD1jLmR8fHt9O2RlbGV0ZSBjLmR9Y2F0Y2goaCl7fXJldHVybntaZzpiLEJjOmMsZGF0YTpkLFFnOmV9fWZ1bmN0aW9uIGFkKGEpe2E9JGMoYSkuQmM7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZhLmhhc093blByb3BlcnR5KFwiaWF0XCIpP3coYSxcImlhdFwiKTpudWxsfWZ1bmN0aW9uIGJkKGEpe2E9JGMoYSk7dmFyIGI9YS5CYztyZXR1cm4hIWEuUWcmJiEhYiYmXCJvYmplY3RcIj09PXR5cGVvZiBiJiZiLmhhc093blByb3BlcnR5KFwiaWF0XCIpfTtmdW5jdGlvbiBjZChhKXt0aGlzLlc9YTt0aGlzLmc9YS5uLmd9ZnVuY3Rpb24gZGQoYSxiLGMsZCl7dmFyIGU9W10sZj1bXTtPYShiLGZ1bmN0aW9uKGIpe1wiY2hpbGRfY2hhbmdlZFwiPT09Yi50eXBlJiZhLmcuQWQoYi5LZSxiLkphKSYmZi5wdXNoKG5ldyBEKFwiY2hpbGRfbW92ZWRcIixiLkphLGIuV2EpKX0pO2VkKGEsZSxcImNoaWxkX3JlbW92ZWRcIixiLGQsYyk7ZWQoYSxlLFwiY2hpbGRfYWRkZWRcIixiLGQsYyk7ZWQoYSxlLFwiY2hpbGRfbW92ZWRcIixmLGQsYyk7ZWQoYSxlLFwiY2hpbGRfY2hhbmdlZFwiLGIsZCxjKTtlZChhLGUsRmIsYixkLGMpO3JldHVybiBlfWZ1bmN0aW9uIGVkKGEsYixjLGQsZSxmKXtkPVBhKGQsZnVuY3Rpb24oYSl7cmV0dXJuIGEudHlwZT09PWN9KTtYYShkLHEoYS5oZyxhKSk7T2EoZCxmdW5jdGlvbihjKXt2YXIgZD1mZChhLGMsZik7T2EoZSxmdW5jdGlvbihlKXtlLktmKGMudHlwZSkmJmIucHVzaChlLmNyZWF0ZUV2ZW50KGQsYS5XKSl9KX0pfVxuZnVuY3Rpb24gZmQoYSxiLGMpe1widmFsdWVcIiE9PWIudHlwZSYmXCJjaGlsZF9yZW1vdmVkXCIhPT1iLnR5cGUmJihiLlFkPWMucmYoYi5XYSxiLkphLGEuZykpO3JldHVybiBifWNkLnByb3RvdHlwZS5oZz1mdW5jdGlvbihhLGIpe2lmKG51bGw9PWEuV2F8fG51bGw9PWIuV2EpdGhyb3cgRmMoXCJTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuXCIpO3JldHVybiB0aGlzLmcuY29tcGFyZShuZXcgRihhLldhLGEuSmEpLG5ldyBGKGIuV2EsYi5KYSkpfTtmdW5jdGlvbiBnZCgpe3RoaXMuYmI9e319XG5mdW5jdGlvbiBoZChhLGIpe3ZhciBjPWIudHlwZSxkPWIuV2E7SyhcImNoaWxkX2FkZGVkXCI9PWN8fFwiY2hpbGRfY2hhbmdlZFwiPT1jfHxcImNoaWxkX3JlbW92ZWRcIj09YyxcIk9ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nXCIpO0soXCIucHJpb3JpdHlcIiE9PWQsXCJPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLlwiKTt2YXIgZT13KGEuYmIsZCk7aWYoZSl7dmFyIGY9ZS50eXBlO2lmKFwiY2hpbGRfYWRkZWRcIj09YyYmXCJjaGlsZF9yZW1vdmVkXCI9PWYpYS5iYltkXT1uZXcgRChcImNoaWxkX2NoYW5nZWRcIixiLkphLGQsZS5KYSk7ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9hZGRlZFwiPT1mKWRlbGV0ZSBhLmJiW2RdO2Vsc2UgaWYoXCJjaGlsZF9yZW1vdmVkXCI9PWMmJlwiY2hpbGRfY2hhbmdlZFwiPT1mKWEuYmJbZF09bmV3IEQoXCJjaGlsZF9yZW1vdmVkXCIsZS5LZSxkKTtlbHNlIGlmKFwiY2hpbGRfY2hhbmdlZFwiPT1jJiZcblwiY2hpbGRfYWRkZWRcIj09ZilhLmJiW2RdPW5ldyBEKFwiY2hpbGRfYWRkZWRcIixiLkphLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlwiY2hpbGRfY2hhbmdlZFwiPT1mKWEuYmJbZF09bmV3IEQoXCJjaGlsZF9jaGFuZ2VkXCIsYi5KYSxkLGUuS2UpO2Vsc2UgdGhyb3cgRmMoXCJJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6IFwiK2IrXCIgb2NjdXJyZWQgYWZ0ZXIgXCIrZSk7fWVsc2UgYS5iYltkXT1ifTtmdW5jdGlvbiBpZChhLGIsYyl7dGhpcy5SYj1hO3RoaXMucGI9Yjt0aGlzLnJiPWN8fG51bGx9Zz1pZC5wcm90b3R5cGU7Zy5LZj1mdW5jdGlvbihhKXtyZXR1cm5cInZhbHVlXCI9PT1hfTtnLmNyZWF0ZUV2ZW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5uLmc7cmV0dXJuIG5ldyBHYihcInZhbHVlXCIsdGhpcyxuZXcgUShhLkphLGIuSWIoKSxjKSl9O2cuVmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5yYjtpZihcImNhbmNlbFwiPT09YS56ZSgpKXtLKHRoaXMucGIsXCJSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2tcIik7dmFyIGM9dGhpcy5wYjtyZXR1cm4gZnVuY3Rpb24oKXtjLmNhbGwoYixhLmVycm9yKX19dmFyIGQ9dGhpcy5SYjtyZXR1cm4gZnVuY3Rpb24oKXtkLmNhbGwoYixhLlpkKX19O2cuZ2Y9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wYj9uZXcgSGIodGhpcyxhLGIpOm51bGx9O1xuZy5tYXRjaGVzPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgaWQ/YS5SYiYmdGhpcy5SYj9hLlJiPT09dGhpcy5SYiYmYS5yYj09PXRoaXMucmI6ITA6ITF9O2cudGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuUmJ9O2Z1bmN0aW9uIGpkKGEsYixjKXt0aGlzLmhhPWE7dGhpcy5wYj1iO3RoaXMucmI9Y31nPWpkLnByb3RvdHlwZTtnLktmPWZ1bmN0aW9uKGEpe2E9XCJjaGlsZHJlbl9hZGRlZFwiPT09YT9cImNoaWxkX2FkZGVkXCI6YTtyZXR1cm4oXCJjaGlsZHJlbl9yZW1vdmVkXCI9PT1hP1wiY2hpbGRfcmVtb3ZlZFwiOmEpaW4gdGhpcy5oYX07Zy5nZj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnBiP25ldyBIYih0aGlzLGEsYik6bnVsbH07XG5nLmNyZWF0ZUV2ZW50PWZ1bmN0aW9uKGEsYil7SyhudWxsIT1hLldhLFwiQ2hpbGQgZXZlbnRzIHNob3VsZCBoYXZlIGEgY2hpbGROYW1lLlwiKTt2YXIgYz1iLkliKCkudShhLldhKTtyZXR1cm4gbmV3IEdiKGEudHlwZSx0aGlzLG5ldyBRKGEuSmEsYyxiLm4uZyksYS5RZCl9O2cuVmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5yYjtpZihcImNhbmNlbFwiPT09YS56ZSgpKXtLKHRoaXMucGIsXCJSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2tcIik7dmFyIGM9dGhpcy5wYjtyZXR1cm4gZnVuY3Rpb24oKXtjLmNhbGwoYixhLmVycm9yKX19dmFyIGQ9dGhpcy5oYVthLnVkXTtyZXR1cm4gZnVuY3Rpb24oKXtkLmNhbGwoYixhLlpkLGEuUWQpfX07XG5nLm1hdGNoZXM9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIGpkKXtpZighdGhpcy5oYXx8IWEuaGEpcmV0dXJuITA7aWYodGhpcy5yYj09PWEucmIpe3ZhciBiPXBhKGEuaGEpO2lmKGI9PT1wYSh0aGlzLmhhKSl7aWYoMT09PWIpe3ZhciBiPXFhKGEuaGEpLGM9cWEodGhpcy5oYSk7cmV0dXJuIGM9PT1iJiYoIWEuaGFbYl18fCF0aGlzLmhhW2NdfHxhLmhhW2JdPT09dGhpcy5oYVtjXSl9cmV0dXJuIG9hKHRoaXMuaGEsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5oYVtjXT09PWJ9KX19fXJldHVybiExfTtnLnRmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmhhfTtmdW5jdGlvbiBrZChhKXt0aGlzLmc9YX1nPWtkLnByb3RvdHlwZTtnLkc9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe0soYS5KYyh0aGlzLmcpLFwiQSBub2RlIG11c3QgYmUgaW5kZXhlZCBpZiBvbmx5IGEgY2hpbGQgaXMgdXBkYXRlZFwiKTtlPWEuUihiKTtpZihlLlEoZCkuY2EoYy5RKGQpKSYmZS5lKCk9PWMuZSgpKXJldHVybiBhO251bGwhPWYmJihjLmUoKT9hLkRhKGIpP2hkKGYsbmV3IEQoXCJjaGlsZF9yZW1vdmVkXCIsZSxiKSk6SyhhLksoKSxcIkEgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGVcIik6ZS5lKCk/aGQoZixuZXcgRChcImNoaWxkX2FkZGVkXCIsYyxiKSk6aGQoZixuZXcgRChcImNoaWxkX2NoYW5nZWRcIixjLGIsZSkpKTtyZXR1cm4gYS5LKCkmJmMuZSgpP2E6YS5VKGIsYykubGIodGhpcy5nKX07XG5nLnhhPWZ1bmN0aW9uKGEsYixjKXtudWxsIT1jJiYoYS5LKCl8fGEuUChOLGZ1bmN0aW9uKGEsZSl7Yi5EYShhKXx8aGQoYyxuZXcgRChcImNoaWxkX3JlbW92ZWRcIixlLGEpKX0pLGIuSygpfHxiLlAoTixmdW5jdGlvbihiLGUpe2lmKGEuRGEoYikpe3ZhciBmPWEuUihiKTtmLmNhKGUpfHxoZChjLG5ldyBEKFwiY2hpbGRfY2hhbmdlZFwiLGUsYixmKSl9ZWxzZSBoZChjLG5ldyBEKFwiY2hpbGRfYWRkZWRcIixlLGIpKX0pKTtyZXR1cm4gYi5sYih0aGlzLmcpfTtnLmdhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZSgpP0M6YS5nYShiKX07Zy5OYT1mdW5jdGlvbigpe3JldHVybiExfTtnLldiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGxkKGEpe3RoaXMuQmU9bmV3IGtkKGEuZyk7dGhpcy5nPWEuZzt2YXIgYjthLm1hPyhiPW1kKGEpLGI9YS5nLlBjKG5kKGEpLGIpKTpiPWEuZy5UYygpO3RoaXMuZWQ9YjthLnBhPyhiPW9kKGEpLGE9YS5nLlBjKHBkKGEpLGIpKTphPWEuZy5RYygpO3RoaXMuR2M9YX1nPWxkLnByb3RvdHlwZTtnLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+PXRoaXMuZy5jb21wYXJlKHRoaXMuZWQsYSkmJjA+PXRoaXMuZy5jb21wYXJlKGEsdGhpcy5HYyl9O2cuRz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5tYXRjaGVzKG5ldyBGKGIsYykpfHwoYz1DKTtyZXR1cm4gdGhpcy5CZS5HKGEsYixjLGQsZSxmKX07XG5nLnhhPWZ1bmN0aW9uKGEsYixjKXtiLksoKSYmKGI9Qyk7dmFyIGQ9Yi5sYih0aGlzLmcpLGQ9ZC5nYShDKSxlPXRoaXM7Yi5QKE4sZnVuY3Rpb24oYSxiKXtlLm1hdGNoZXMobmV3IEYoYSxiKSl8fChkPWQuVShhLEMpKX0pO3JldHVybiB0aGlzLkJlLnhhKGEsZCxjKX07Zy5nYT1mdW5jdGlvbihhKXtyZXR1cm4gYX07Zy5OYT1mdW5jdGlvbigpe3JldHVybiEwfTtnLldiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQmV9O2Z1bmN0aW9uIHFkKGEpe3RoaXMuc2E9bmV3IGxkKGEpO3RoaXMuZz1hLmc7SyhhLmphLFwiT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXRcIik7dGhpcy5rYT1hLmthO3RoaXMuSmI9IXJkKGEpfWc9cWQucHJvdG90eXBlO2cuRz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5zYS5tYXRjaGVzKG5ldyBGKGIsYykpfHwoYz1DKTtyZXR1cm4gYS5SKGIpLmNhKGMpP2E6YS5EYigpPHRoaXMua2E/dGhpcy5zYS5XYigpLkcoYSxiLGMsZCxlLGYpOnNkKHRoaXMsYSxiLGMsZSxmKX07XG5nLnhhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZDtpZihiLksoKXx8Yi5lKCkpZD1DLmxiKHRoaXMuZyk7ZWxzZSBpZigyKnRoaXMua2E8Yi5EYigpJiZiLkpjKHRoaXMuZykpe2Q9Qy5sYih0aGlzLmcpO2I9dGhpcy5KYj9iLiRiKHRoaXMuc2EuR2MsdGhpcy5nKTpiLlliKHRoaXMuc2EuZWQsdGhpcy5nKTtmb3IodmFyIGU9MDswPGIuUGEubGVuZ3RoJiZlPHRoaXMua2E7KXt2YXIgZj1KKGIpLGg7aWYoaD10aGlzLkpiPzA+PXRoaXMuZy5jb21wYXJlKHRoaXMuc2EuZWQsZik6MD49dGhpcy5nLmNvbXBhcmUoZix0aGlzLnNhLkdjKSlkPWQuVShmLm5hbWUsZi5TKSxlKys7ZWxzZSBicmVha319ZWxzZXtkPWIubGIodGhpcy5nKTtkPWQuZ2EoQyk7dmFyIGssbCxtO2lmKHRoaXMuSmIpe2I9ZC5zZih0aGlzLmcpO2s9dGhpcy5zYS5HYztsPXRoaXMuc2EuZWQ7dmFyIHQ9dGQodGhpcy5nKTttPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHQoYixhKX19ZWxzZSBiPWQuWGIodGhpcy5nKSxrPXRoaXMuc2EuZWQsXG5sPXRoaXMuc2EuR2MsbT10ZCh0aGlzLmcpO2Zvcih2YXIgZT0wLHo9ITE7MDxiLlBhLmxlbmd0aDspZj1KKGIpLCF6JiYwPj1tKGssZikmJih6PSEwKSwoaD16JiZlPHRoaXMua2EmJjA+PW0oZixsKSk/ZSsrOmQ9ZC5VKGYubmFtZSxDKX1yZXR1cm4gdGhpcy5zYS5XYigpLnhhKGEsZCxjKX07Zy5nYT1mdW5jdGlvbihhKXtyZXR1cm4gYX07Zy5OYT1mdW5jdGlvbigpe3JldHVybiEwfTtnLldiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2EuV2IoKX07XG5mdW5jdGlvbiBzZChhLGIsYyxkLGUsZil7dmFyIGg7aWYoYS5KYil7dmFyIGs9dGQoYS5nKTtoPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGsoYixhKX19ZWxzZSBoPXRkKGEuZyk7SyhiLkRiKCk9PWEua2EsXCJcIik7dmFyIGw9bmV3IEYoYyxkKSxtPWEuSmI/dWQoYixhLmcpOnZkKGIsYS5nKSx0PWEuc2EubWF0Y2hlcyhsKTtpZihiLkRhKGMpKXtmb3IodmFyIHo9Yi5SKGMpLG09ZS55ZShhLmcsbSxhLkpiKTtudWxsIT1tJiYobS5uYW1lPT1jfHxiLkRhKG0ubmFtZSkpOyltPWUueWUoYS5nLG0sYS5KYik7ZT1udWxsPT1tPzE6aChtLGwpO2lmKHQmJiFkLmUoKSYmMDw9ZSlyZXR1cm4gbnVsbCE9ZiYmaGQoZixuZXcgRChcImNoaWxkX2NoYW5nZWRcIixkLGMseikpLGIuVShjLGQpO251bGwhPWYmJmhkKGYsbmV3IEQoXCJjaGlsZF9yZW1vdmVkXCIseixjKSk7Yj1iLlUoYyxDKTtyZXR1cm4gbnVsbCE9bSYmYS5zYS5tYXRjaGVzKG0pPyhudWxsIT1mJiZoZChmLG5ldyBEKFwiY2hpbGRfYWRkZWRcIixcbm0uUyxtLm5hbWUpKSxiLlUobS5uYW1lLG0uUykpOmJ9cmV0dXJuIGQuZSgpP2I6dCYmMDw9aChtLGwpPyhudWxsIT1mJiYoaGQoZixuZXcgRChcImNoaWxkX3JlbW92ZWRcIixtLlMsbS5uYW1lKSksaGQoZixuZXcgRChcImNoaWxkX2FkZGVkXCIsZCxjKSkpLGIuVShjLGQpLlUobS5uYW1lLEMpKTpifTtmdW5jdGlvbiB3ZChhLGIpe3RoaXMuamU9YTt0aGlzLmZnPWJ9ZnVuY3Rpb24geGQoYSl7dGhpcy5WPWF9XG54ZC5wcm90b3R5cGUuYWI9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IGdkLGY7aWYoYi50eXBlPT09WWIpYi5zb3VyY2Uud2U/Yz15ZCh0aGlzLGEsYi5wYXRoLGIuR2EsYyxkLGUpOihLKGIuc291cmNlLnBmLFwiVW5rbm93biBzb3VyY2UuXCIpLGY9Yi5zb3VyY2UuYWZ8fEpiKGEudygpKSYmIWIucGF0aC5lKCksYz1BZCh0aGlzLGEsYi5wYXRoLGIuR2EsYyxkLGYsZSkpO2Vsc2UgaWYoYi50eXBlPT09QmQpYi5zb3VyY2Uud2U/Yz1DZCh0aGlzLGEsYi5wYXRoLGIuY2hpbGRyZW4sYyxkLGUpOihLKGIuc291cmNlLnBmLFwiVW5rbm93biBzb3VyY2UuXCIpLGY9Yi5zb3VyY2UuYWZ8fEpiKGEudygpKSxjPURkKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1FZClpZihiLlZkKWlmKGI9Yi5wYXRoLG51bGwhPWMudGMoYikpYz1hO2Vsc2V7Zj1uZXcgcmIoYyxhLGQpO2Q9YS5PLmooKTtpZihiLmUoKXx8XCIucHJpb3JpdHlcIj09PUUoYikpSWIoYS53KCkpP1xuYj1jLnphKHViKGEpKTooYj1hLncoKS5qKCksSyhiIGluc3RhbmNlb2YgUixcInNlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZVwiKSxiPWMueWMoYikpLGI9dGhpcy5WLnhhKGQsYixlKTtlbHNle3ZhciBoPUUoYiksaz1jLnhjKGgsYS53KCkpO251bGw9PWsmJnNiKGEudygpLGgpJiYoaz1kLlIoaCkpO2I9bnVsbCE9az90aGlzLlYuRyhkLGgsayxIKGIpLGYsZSk6YS5PLmooKS5EYShoKT90aGlzLlYuRyhkLGgsQyxIKGIpLGYsZSk6ZDtiLmUoKSYmSWIoYS53KCkpJiYoZD1jLnphKHViKGEpKSxkLksoKSYmKGI9dGhpcy5WLnhhKGIsZCxlKSkpfWQ9SWIoYS53KCkpfHxudWxsIT1jLnRjKEcpO2M9RmQoYSxiLGQsdGhpcy5WLk5hKCkpfWVsc2UgYz1HZCh0aGlzLGEsYi5wYXRoLGIuUWIsYyxkLGUpO2Vsc2UgaWYoYi50eXBlPT09JGIpZD1iLnBhdGgsYj1hLncoKSxmPWIuaigpLGg9Yi5lYXx8ZC5lKCksYz1IZCh0aGlzLG5ldyBJZChhLk8sbmV3IHRiKGYsXG5oLGIuVWIpKSxkLGMscWIsZSk7ZWxzZSB0aHJvdyBGYyhcIlVua25vd24gb3BlcmF0aW9uIHR5cGU6IFwiK2IudHlwZSk7ZT1yYShlLmJiKTtkPWM7Yj1kLk87Yi5lYSYmKGY9Yi5qKCkuSygpfHxiLmooKS5lKCksaD1KZChhKSwoMDxlLmxlbmd0aHx8IWEuTy5lYXx8ZiYmIWIuaigpLmNhKGgpfHwhYi5qKCkuQygpLmNhKGguQygpKSkmJmUucHVzaChFYihKZChkKSkpKTtyZXR1cm4gbmV3IHdkKGMsZSl9O1xuZnVuY3Rpb24gSGQoYSxiLGMsZCxlLGYpe3ZhciBoPWIuTztpZihudWxsIT1kLnRjKGMpKXJldHVybiBiO3ZhciBrO2lmKGMuZSgpKUsoSWIoYi53KCkpLFwiSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YVwiKSxKYihiLncoKSk/KGU9dWIoYiksZD1kLnljKGUgaW5zdGFuY2VvZiBSP2U6QykpOmQ9ZC56YSh1YihiKSksZj1hLlYueGEoYi5PLmooKSxkLGYpO2Vsc2V7dmFyIGw9RShjKTtpZihcIi5wcmlvcml0eVwiPT1sKUsoMT09S2QoYyksXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKSxmPWguaigpLGs9Yi53KCkuaigpLGQ9ZC5sZChjLGYsayksZj1udWxsIT1kP2EuVi5nYShmLGQpOmguaigpO2Vsc2V7dmFyIG09SChjKTtzYihoLGwpPyhrPWIudygpLmooKSxkPWQubGQoYyxoLmooKSxrKSxkPW51bGwhPWQ/aC5qKCkuUihsKS5HKG0sZCk6aC5qKCkuUihsKSk6ZD1kLnhjKGwsXG5iLncoKSk7Zj1udWxsIT1kP2EuVi5HKGguaigpLGwsZCxtLGUsZik6aC5qKCl9fXJldHVybiBGZChiLGYsaC5lYXx8Yy5lKCksYS5WLk5hKCkpfWZ1bmN0aW9uIEFkKGEsYixjLGQsZSxmLGgsayl7dmFyIGw9Yi53KCk7aD1oP2EuVjphLlYuV2IoKTtpZihjLmUoKSlkPWgueGEobC5qKCksZCxudWxsKTtlbHNlIGlmKGguTmEoKSYmIWwuVWIpZD1sLmooKS5HKGMsZCksZD1oLnhhKGwuaigpLGQsbnVsbCk7ZWxzZXt2YXIgbT1FKGMpO2lmKCFLYihsLGMpJiYxPEtkKGMpKXJldHVybiBiO3ZhciB0PUgoYyk7ZD1sLmooKS5SKG0pLkcodCxkKTtkPVwiLnByaW9yaXR5XCI9PW0/aC5nYShsLmooKSxkKTpoLkcobC5qKCksbSxkLHQscWIsbnVsbCl9bD1sLmVhfHxjLmUoKTtiPW5ldyBJZChiLk8sbmV3IHRiKGQsbCxoLk5hKCkpKTtyZXR1cm4gSGQoYSxiLGMsZSxuZXcgcmIoZSxiLGYpLGspfVxuZnVuY3Rpb24geWQoYSxiLGMsZCxlLGYsaCl7dmFyIGs9Yi5PO2U9bmV3IHJiKGUsYixmKTtpZihjLmUoKSloPWEuVi54YShiLk8uaigpLGQsaCksYT1GZChiLGgsITAsYS5WLk5hKCkpO2Vsc2UgaWYoZj1FKGMpLFwiLnByaW9yaXR5XCI9PT1mKWg9YS5WLmdhKGIuTy5qKCksZCksYT1GZChiLGgsay5lYSxrLlViKTtlbHNle2M9SChjKTt2YXIgbD1rLmooKS5SKGYpO2lmKCFjLmUoKSl7dmFyIG09ZS5xZihmKTtkPW51bGwhPW0/XCIucHJpb3JpdHlcIj09PUxkKGMpJiZtLlEoYy5wYXJlbnQoKSkuZSgpP206bS5HKGMsZCk6Q31sLmNhKGQpP2E9YjooaD1hLlYuRyhrLmooKSxmLGQsYyxlLGgpLGE9RmQoYixoLGsuZWEsYS5WLk5hKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIENkKGEsYixjLGQsZSxmLGgpe3ZhciBrPWI7TWQoZCxmdW5jdGlvbihkLG0pe3ZhciB0PWMudShkKTtzYihiLk8sRSh0KSkmJihrPXlkKGEsayx0LG0sZSxmLGgpKX0pO01kKGQsZnVuY3Rpb24oZCxtKXt2YXIgdD1jLnUoZCk7c2IoYi5PLEUodCkpfHwoaz15ZChhLGssdCxtLGUsZixoKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBOZChhLGIpe01kKGIsZnVuY3Rpb24oYixkKXthPWEuRyhiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBEZChhLGIsYyxkLGUsZixoLGspe2lmKGIudygpLmooKS5lKCkmJiFJYihiLncoKSkpcmV0dXJuIGI7dmFyIGw9YjtjPWMuZSgpP2Q6T2QoUGQsYyxkKTt2YXIgbT1iLncoKS5qKCk7Yy5jaGlsZHJlbi5pYShmdW5jdGlvbihjLGQpe2lmKG0uRGEoYykpe3ZhciBJPWIudygpLmooKS5SKGMpLEk9TmQoSSxkKTtsPUFkKGEsbCxuZXcgTChjKSxJLGUsZixoLGspfX0pO2MuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYyxkKXt2YXIgST0hc2IoYi53KCksYykmJm51bGw9PWQudmFsdWU7bS5EYShjKXx8SXx8KEk9Yi53KCkuaigpLlIoYyksST1OZChJLGQpLGw9QWQoYSxsLG5ldyBMKGMpLEksZSxmLGgsaykpfSk7cmV0dXJuIGx9XG5mdW5jdGlvbiBHZChhLGIsYyxkLGUsZixoKXtpZihudWxsIT1lLnRjKGMpKXJldHVybiBiO3ZhciBrPUpiKGIudygpKSxsPWIudygpO2lmKG51bGwhPWQudmFsdWUpe2lmKGMuZSgpJiZsLmVhfHxLYihsLGMpKXJldHVybiBBZChhLGIsYyxsLmooKS5RKGMpLGUsZixrLGgpO2lmKGMuZSgpKXt2YXIgbT1QZDtsLmooKS5QKFFkLGZ1bmN0aW9uKGEsYil7bT1tLnNldChuZXcgTChhKSxiKX0pO3JldHVybiBEZChhLGIsYyxtLGUsZixrLGgpfXJldHVybiBifW09UGQ7TWQoZCxmdW5jdGlvbihhKXt2YXIgYj1jLnUoYSk7S2IobCxiKSYmKG09bS5zZXQoYSxsLmooKS5RKGIpKSl9KTtyZXR1cm4gRGQoYSxiLGMsbSxlLGYsayxoKX07ZnVuY3Rpb24gUmQoKXt9dmFyIFNkPXt9O2Z1bmN0aW9uIHRkKGEpe3JldHVybiBxKGEuY29tcGFyZSxhKX1SZC5wcm90b3R5cGUuQWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMCE9PXRoaXMuY29tcGFyZShuZXcgRihcIltNSU5fTkFNRV1cIixhKSxuZXcgRihcIltNSU5fTkFNRV1cIixiKSl9O1JkLnByb3RvdHlwZS5UYz1mdW5jdGlvbigpe3JldHVybiBUZH07ZnVuY3Rpb24gVWQoYSl7SyghYS5lKCkmJlwiLnByaW9yaXR5XCIhPT1FKGEpLFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiKTt0aGlzLmNjPWF9bWEoVWQsUmQpO2c9VWQucHJvdG90eXBlO2cuSWM9ZnVuY3Rpb24oYSl7cmV0dXJuIWEuUSh0aGlzLmNjKS5lKCl9O2cuY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuUy5RKHRoaXMuY2MpLGQ9Yi5TLlEodGhpcy5jYyksYz1jLkRjKGQpO3JldHVybiAwPT09Yz9WYihhLm5hbWUsYi5uYW1lKTpjfTtcbmcuUGM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NKGEpLGM9Qy5HKHRoaXMuY2MsYyk7cmV0dXJuIG5ldyBGKGIsYyl9O2cuUWM9ZnVuY3Rpb24oKXt2YXIgYT1DLkcodGhpcy5jYyxWZCk7cmV0dXJuIG5ldyBGKFwiW01BWF9OQU1FXVwiLGEpfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2Muc2xpY2UoKS5qb2luKFwiL1wiKX07ZnVuY3Rpb24gV2QoKXt9bWEoV2QsUmQpO2c9V2QucHJvdG90eXBlO2cuY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuUy5DKCksZD1iLlMuQygpLGM9Yy5EYyhkKTtyZXR1cm4gMD09PWM/VmIoYS5uYW1lLGIubmFtZSk6Y307Zy5JYz1mdW5jdGlvbihhKXtyZXR1cm4hYS5DKCkuZSgpfTtnLkFkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIWEuQygpLmNhKGIuQygpKX07Zy5UYz1mdW5jdGlvbigpe3JldHVybiBUZH07Zy5RYz1mdW5jdGlvbigpe3JldHVybiBuZXcgRihcIltNQVhfTkFNRV1cIixuZXcgdGMoXCJbUFJJT1JJVFktUE9TVF1cIixWZCkpfTtcbmcuUGM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NKGEpO3JldHVybiBuZXcgRihiLG5ldyB0YyhcIltQUklPUklUWS1QT1NUXVwiLGMpKX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnByaW9yaXR5XCJ9O3ZhciBOPW5ldyBXZDtmdW5jdGlvbiBYZCgpe31tYShYZCxSZCk7Zz1YZC5wcm90b3R5cGU7Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFZiKGEubmFtZSxiLm5hbWUpfTtnLkljPWZ1bmN0aW9uKCl7dGhyb3cgRmMoXCJLZXlJbmRleC5pc0RlZmluZWRPbiBub3QgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkLlwiKTt9O2cuQWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5UYz1mdW5jdGlvbigpe3JldHVybiBUZH07Zy5RYz1mdW5jdGlvbigpe3JldHVybiBuZXcgRihcIltNQVhfTkFNRV1cIixDKX07Zy5QYz1mdW5jdGlvbihhKXtLKHAoYSksXCJLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLlwiKTtyZXR1cm4gbmV3IEYoYSxDKX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLmtleVwifTtcbnZhciBRZD1uZXcgWGQ7ZnVuY3Rpb24gWWQoKXt9bWEoWWQsUmQpO2c9WWQucHJvdG90eXBlO2cuY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuUy5EYyhiLlMpO3JldHVybiAwPT09Yz9WYihhLm5hbWUsYi5uYW1lKTpjfTtnLkljPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuQWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5jYShiKX07Zy5UYz1mdW5jdGlvbigpe3JldHVybiBUZH07Zy5RYz1mdW5jdGlvbigpe3JldHVybiBaZH07Zy5QYz1mdW5jdGlvbihhLGIpe3ZhciBjPU0oYSk7cmV0dXJuIG5ldyBGKGIsYyl9O2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIi52YWx1ZVwifTt2YXIgJGQ9bmV3IFlkO2Z1bmN0aW9uIGFlKCl7dGhpcy5UYj10aGlzLnBhPXRoaXMuTGI9dGhpcy5tYT10aGlzLmphPSExO3RoaXMua2E9MDt0aGlzLk5iPVwiXCI7dGhpcy5lYz1udWxsO3RoaXMueGI9XCJcIjt0aGlzLmJjPW51bGw7dGhpcy52Yj1cIlwiO3RoaXMuZz1OfXZhciBiZT1uZXcgYWU7ZnVuY3Rpb24gcmQoYSl7cmV0dXJuXCJcIj09PWEuTmI/YS5tYTpcImxcIj09PWEuTmJ9ZnVuY3Rpb24gbmQoYSl7SyhhLm1hLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuZWN9ZnVuY3Rpb24gbWQoYSl7SyhhLm1hLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuTGI/YS54YjpcIltNSU5fTkFNRV1cIn1mdW5jdGlvbiBwZChhKXtLKGEucGEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuYmN9XG5mdW5jdGlvbiBvZChhKXtLKGEucGEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuVGI/YS52YjpcIltNQVhfTkFNRV1cIn1mdW5jdGlvbiBjZShhKXt2YXIgYj1uZXcgYWU7Yi5qYT1hLmphO2Iua2E9YS5rYTtiLm1hPWEubWE7Yi5lYz1hLmVjO2IuTGI9YS5MYjtiLnhiPWEueGI7Yi5wYT1hLnBhO2IuYmM9YS5iYztiLlRiPWEuVGI7Yi52Yj1hLnZiO2IuZz1hLmc7cmV0dXJuIGJ9Zz1hZS5wcm90b3R5cGU7Zy5IZT1mdW5jdGlvbihhKXt2YXIgYj1jZSh0aGlzKTtiLmphPSEwO2Iua2E9YTtiLk5iPVwiXCI7cmV0dXJuIGJ9O2cuSWU9ZnVuY3Rpb24oYSl7dmFyIGI9Y2UodGhpcyk7Yi5qYT0hMDtiLmthPWE7Yi5OYj1cImxcIjtyZXR1cm4gYn07Zy5KZT1mdW5jdGlvbihhKXt2YXIgYj1jZSh0aGlzKTtiLmphPSEwO2Iua2E9YTtiLk5iPVwiclwiO3JldHVybiBifTtcbmcuJGQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1jZSh0aGlzKTtjLm1hPSEwO24oYSl8fChhPW51bGwpO2MuZWM9YTtudWxsIT1iPyhjLkxiPSEwLGMueGI9Yik6KGMuTGI9ITEsYy54Yj1cIlwiKTtyZXR1cm4gY307Zy50ZD1mdW5jdGlvbihhLGIpe3ZhciBjPWNlKHRoaXMpO2MucGE9ITA7bihhKXx8KGE9bnVsbCk7Yy5iYz1hO24oYik/KGMuVGI9ITAsYy52Yj1iKTooYy5haD0hMSxjLnZiPVwiXCIpO3JldHVybiBjfTtmdW5jdGlvbiBkZShhLGIpe3ZhciBjPWNlKGEpO2MuZz1iO3JldHVybiBjfWZ1bmN0aW9uIGVlKGEpe3ZhciBiPXt9O2EubWEmJihiLnNwPWEuZWMsYS5MYiYmKGIuc249YS54YikpO2EucGEmJihiLmVwPWEuYmMsYS5UYiYmKGIuZW49YS52YikpO2lmKGEuamEpe2IubD1hLmthO3ZhciBjPWEuTmI7XCJcIj09PWMmJihjPXJkKGEpP1wibFwiOlwiclwiKTtiLnZmPWN9YS5nIT09TiYmKGIuaT1hLmcudG9TdHJpbmcoKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBTKGEpe3JldHVybiEoYS5tYXx8YS5wYXx8YS5qYSl9ZnVuY3Rpb24gZmUoYSl7cmV0dXJuIFMoYSkmJmEuZz09Tn1mdW5jdGlvbiBnZShhKXt2YXIgYj17fTtpZihmZShhKSlyZXR1cm4gYjt2YXIgYzthLmc9PT1OP2M9XCIkcHJpb3JpdHlcIjphLmc9PT0kZD9jPVwiJHZhbHVlXCI6YS5nPT09UWQ/Yz1cIiRrZXlcIjooSyhhLmcgaW5zdGFuY2VvZiBVZCxcIlVucmVjb2duaXplZCBpbmRleCB0eXBlIVwiKSxjPWEuZy50b1N0cmluZygpKTtiLm9yZGVyQnk9QihjKTthLm1hJiYoYi5zdGFydEF0PUIoYS5lYyksYS5MYiYmKGIuc3RhcnRBdCs9XCIsXCIrQihhLnhiKSkpO2EucGEmJihiLmVuZEF0PUIoYS5iYyksYS5UYiYmKGIuZW5kQXQrPVwiLFwiK0IoYS52YikpKTthLmphJiYocmQoYSk/Yi5saW1pdFRvRmlyc3Q9YS5rYTpiLmxpbWl0VG9MYXN0PWEua2EpO3JldHVybiBifWcudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gQihlZSh0aGlzKSl9O2Z1bmN0aW9uIGhlKGEsYil7dGhpcy5CZD1hO3RoaXMuZGM9Yn1oZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPXcodGhpcy5CZCxhKTtpZighYil0aHJvdyBFcnJvcihcIk5vIGluZGV4IGRlZmluZWQgZm9yIFwiK2EpO3JldHVybiBiPT09U2Q/bnVsbDpifTtmdW5jdGlvbiBpZShhLGIsYyl7dmFyIGQ9bmEoYS5CZCxmdW5jdGlvbihkLGYpe3ZhciBoPXcoYS5kYyxmKTtLKGgsXCJNaXNzaW5nIGluZGV4IGltcGxlbWVudGF0aW9uIGZvciBcIitmKTtpZihkPT09U2Qpe2lmKGguSWMoYi5TKSl7Zm9yKHZhciBrPVtdLGw9Yy5YYihUYiksbT1KKGwpO207KW0ubmFtZSE9Yi5uYW1lJiZrLnB1c2gobSksbT1KKGwpO2sucHVzaChiKTtyZXR1cm4gamUoayx0ZChoKSl9cmV0dXJuIFNkfWg9Yy5nZXQoYi5uYW1lKTtrPWQ7aCYmKGs9ay5yZW1vdmUobmV3IEYoYi5uYW1lLGgpKSk7cmV0dXJuIGsuT2EoYixiLlMpfSk7cmV0dXJuIG5ldyBoZShkLGEuZGMpfVxuZnVuY3Rpb24ga2UoYSxiLGMpe3ZhciBkPW5hKGEuQmQsZnVuY3Rpb24oYSl7aWYoYT09PVNkKXJldHVybiBhO3ZhciBkPWMuZ2V0KGIubmFtZSk7cmV0dXJuIGQ/YS5yZW1vdmUobmV3IEYoYi5uYW1lLGQpKTphfSk7cmV0dXJuIG5ldyBoZShkLGEuZGMpfXZhciBsZT1uZXcgaGUoe1wiLnByaW9yaXR5XCI6U2R9LHtcIi5wcmlvcml0eVwiOk59KTtmdW5jdGlvbiB0YyhhLGIpe3RoaXMuQj1hO0sobih0aGlzLkIpJiZudWxsIT09dGhpcy5CLFwiTGVhZk5vZGUgc2hvdWxkbid0IGJlIGNyZWF0ZWQgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZS5cIik7dGhpcy5hYT1ifHxDO21lKHRoaXMuYWEpO3RoaXMuQ2I9bnVsbH12YXIgbmU9W1wib2JqZWN0XCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcInN0cmluZ1wiXTtnPXRjLnByb3RvdHlwZTtnLks9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWF9O2cuZ2E9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyB0Yyh0aGlzLkIsYSl9O2cuUj1mdW5jdGlvbihhKXtyZXR1cm5cIi5wcmlvcml0eVwiPT09YT90aGlzLmFhOkN9O2cuUT1mdW5jdGlvbihhKXtyZXR1cm4gYS5lKCk/dGhpczpcIi5wcmlvcml0eVwiPT09RShhKT90aGlzLmFhOkN9O2cuRGE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5yZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcbmcuVT1mdW5jdGlvbihhLGIpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuZ2EoYik6Yi5lKCkmJlwiLnByaW9yaXR5XCIhPT1hP3RoaXM6Qy5VKGEsYikuZ2EodGhpcy5hYSl9O2cuRz1mdW5jdGlvbihhLGIpe3ZhciBjPUUoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYi5lKCkmJlwiLnByaW9yaXR5XCIhPT1jKXJldHVybiB0aGlzO0soXCIucHJpb3JpdHlcIiE9PWN8fDE9PT1LZChhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTtyZXR1cm4gdGhpcy5VKGMsQy5HKEgoYSksYikpfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5EYj1mdW5jdGlvbigpe3JldHVybiAwfTtnLlA9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5JPWZ1bmN0aW9uKGEpe3JldHVybiBhJiYhdGhpcy5DKCkuZSgpP3tcIi52YWx1ZVwiOnRoaXMuQ2EoKSxcIi5wcmlvcml0eVwiOnRoaXMuQygpLkkoKX06dGhpcy5DYSgpfTtcbmcuaGFzaD1mdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLkNiKXt2YXIgYT1cIlwiO3RoaXMuYWEuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitvZSh0aGlzLmFhLkkoKSkrXCI6XCIpO3ZhciBiPXR5cGVvZiB0aGlzLkIsYT1hKyhiK1wiOlwiKSxhPVwibnVtYmVyXCI9PT1iP2ErWGModGhpcy5CKTphK3RoaXMuQjt0aGlzLkNiPUhjKGEpfXJldHVybiB0aGlzLkNifTtnLkNhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQn07Zy5EYz1mdW5jdGlvbihhKXtpZihhPT09QylyZXR1cm4gMTtpZihhIGluc3RhbmNlb2YgUilyZXR1cm4tMTtLKGEuSygpLFwiVW5rbm93biBub2RlIHR5cGVcIik7dmFyIGI9dHlwZW9mIGEuQixjPXR5cGVvZiB0aGlzLkIsZD1OYShuZSxiKSxlPU5hKG5lLGMpO0soMDw9ZCxcIlVua25vd24gbGVhZiB0eXBlOiBcIitiKTtLKDA8PWUsXCJVbmtub3duIGxlYWYgdHlwZTogXCIrYyk7cmV0dXJuIGQ9PT1lP1wib2JqZWN0XCI9PT1jPzA6dGhpcy5CPGEuQj8tMTp0aGlzLkI9PT1hLkI/MDoxOmUtZH07XG5nLmxiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2cuSmM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5jYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/ITA6YS5LKCk/dGhpcy5CPT09YS5CJiZ0aGlzLmFhLmNhKGEuYWEpOiExfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcy5JKCEwKSl9O2Z1bmN0aW9uIFIoYSxiLGMpe3RoaXMubT1hOyh0aGlzLmFhPWIpJiZtZSh0aGlzLmFhKTthLmUoKSYmSyghdGhpcy5hYXx8dGhpcy5hYS5lKCksXCJBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHlcIik7dGhpcy53Yj1jO3RoaXMuQ2I9bnVsbH1nPVIucHJvdG90eXBlO2cuSz1mdW5jdGlvbigpe3JldHVybiExfTtnLkM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYXx8Q307Zy5nYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tLmUoKT90aGlzOm5ldyBSKHRoaXMubSxhLHRoaXMud2IpfTtnLlI9ZnVuY3Rpb24oYSl7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuQygpO2E9dGhpcy5tLmdldChhKTtyZXR1cm4gbnVsbD09PWE/QzphfTtnLlE9ZnVuY3Rpb24oYSl7dmFyIGI9RShhKTtyZXR1cm4gbnVsbD09PWI/dGhpczp0aGlzLlIoYikuUShIKGEpKX07Zy5EYT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9PXRoaXMubS5nZXQoYSl9O1xuZy5VPWZ1bmN0aW9uKGEsYil7SyhiLFwiV2Ugc2hvdWxkIGFsd2F5cyBiZSBwYXNzaW5nIHNuYXBzaG90IG5vZGVzXCIpO2lmKFwiLnByaW9yaXR5XCI9PT1hKXJldHVybiB0aGlzLmdhKGIpO3ZhciBjPW5ldyBGKGEsYiksZCxlO2IuZSgpPyhkPXRoaXMubS5yZW1vdmUoYSksYz1rZSh0aGlzLndiLGMsdGhpcy5tKSk6KGQ9dGhpcy5tLk9hKGEsYiksYz1pZSh0aGlzLndiLGMsdGhpcy5tKSk7ZT1kLmUoKT9DOnRoaXMuYWE7cmV0dXJuIG5ldyBSKGQsZSxjKX07Zy5HPWZ1bmN0aW9uKGEsYil7dmFyIGM9RShhKTtpZihudWxsPT09YylyZXR1cm4gYjtLKFwiLnByaW9yaXR5XCIhPT1FKGEpfHwxPT09S2QoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7dmFyIGQ9dGhpcy5SKGMpLkcoSChhKSxiKTtyZXR1cm4gdGhpcy5VKGMsZCl9O2cuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm0uZSgpfTtnLkRiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5jb3VudCgpfTtcbnZhciBwZT0vXigwfFsxLTldXFxkKikkLztnPVIucHJvdG90eXBlO2cuST1mdW5jdGlvbihhKXtpZih0aGlzLmUoKSlyZXR1cm4gbnVsbDt2YXIgYj17fSxjPTAsZD0wLGU9ITA7dGhpcy5QKE4sZnVuY3Rpb24oZixoKXtiW2ZdPWguSShhKTtjKys7ZSYmcGUudGVzdChmKT9kPU1hdGgubWF4KGQsTnVtYmVyKGYpKTplPSExfSk7aWYoIWEmJmUmJmQ8MipjKXt2YXIgZj1bXSxoO2ZvcihoIGluIGIpZltoXT1iW2hdO3JldHVybiBmfWEmJiF0aGlzLkMoKS5lKCkmJihiW1wiLnByaW9yaXR5XCJdPXRoaXMuQygpLkkoKSk7cmV0dXJuIGJ9O2cuaGFzaD1mdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLkNiKXt2YXIgYT1cIlwiO3RoaXMuQygpLmUoKXx8KGErPVwicHJpb3JpdHk6XCIrb2UodGhpcy5DKCkuSSgpKStcIjpcIik7dGhpcy5QKE4sZnVuY3Rpb24oYixjKXt2YXIgZD1jLmhhc2goKTtcIlwiIT09ZCYmKGErPVwiOlwiK2IrXCI6XCIrZCl9KTt0aGlzLkNiPVwiXCI9PT1hP1wiXCI6SGMoYSl9cmV0dXJuIHRoaXMuQ2J9O1xuZy5yZj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuKGM9cWUodGhpcyxjKSk/KGE9Y2MoYyxuZXcgRihhLGIpKSk/YS5uYW1lOm51bGw6Y2ModGhpcy5tLGEpfTtmdW5jdGlvbiB1ZChhLGIpe3ZhciBjO2M9KGM9cWUoYSxiKSk/KGM9Yy5TYygpKSYmYy5uYW1lOmEubS5TYygpO3JldHVybiBjP25ldyBGKGMsYS5tLmdldChjKSk6bnVsbH1mdW5jdGlvbiB2ZChhLGIpe3ZhciBjO2M9KGM9cWUoYSxiKSk/KGM9Yy5mYygpKSYmYy5uYW1lOmEubS5mYygpO3JldHVybiBjP25ldyBGKGMsYS5tLmdldChjKSk6bnVsbH1nLlA9ZnVuY3Rpb24oYSxiKXt2YXIgYz1xZSh0aGlzLGEpO3JldHVybiBjP2MuaWEoZnVuY3Rpb24oYSl7cmV0dXJuIGIoYS5uYW1lLGEuUyl9KTp0aGlzLm0uaWEoYil9O2cuWGI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWWIoYS5UYygpLGEpfTtcbmcuWWI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1xZSh0aGlzLGIpO2lmKGMpcmV0dXJuIGMuWWIoYSxmdW5jdGlvbihhKXtyZXR1cm4gYX0pO2Zvcih2YXIgYz10aGlzLm0uWWIoYS5uYW1lLFRiKSxkPWVjKGMpO251bGwhPWQmJjA+Yi5jb21wYXJlKGQsYSk7KUooYyksZD1lYyhjKTtyZXR1cm4gY307Zy5zZj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy4kYihhLlFjKCksYSl9O2cuJGI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1xZSh0aGlzLGIpO2lmKGMpcmV0dXJuIGMuJGIoYSxmdW5jdGlvbihhKXtyZXR1cm4gYX0pO2Zvcih2YXIgYz10aGlzLm0uJGIoYS5uYW1lLFRiKSxkPWVjKGMpO251bGwhPWQmJjA8Yi5jb21wYXJlKGQsYSk7KUooYyksZD1lYyhjKTtyZXR1cm4gY307Zy5EYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lKCk/YS5lKCk/MDotMTphLksoKXx8YS5lKCk/MTphPT09VmQ/LTE6MH07XG5nLmxiPWZ1bmN0aW9uKGEpe2lmKGE9PT1RZHx8dGEodGhpcy53Yi5kYyxhLnRvU3RyaW5nKCkpKXJldHVybiB0aGlzO3ZhciBiPXRoaXMud2IsYz10aGlzLm07SyhhIT09UWQsXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO2Zvcih2YXIgZD1bXSxlPSExLGM9Yy5YYihUYiksZj1KKGMpO2Y7KWU9ZXx8YS5JYyhmLlMpLGQucHVzaChmKSxmPUooYyk7ZD1lP2plKGQsdGQoYSkpOlNkO2U9YS50b1N0cmluZygpO2M9eGEoYi5kYyk7Y1tlXT1hO2E9eGEoYi5CZCk7YVtlXT1kO3JldHVybiBuZXcgUih0aGlzLm0sdGhpcy5hYSxuZXcgaGUoYSxjKSl9O2cuSmM9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1RZHx8dGEodGhpcy53Yi5kYyxhLnRvU3RyaW5nKCkpfTtcbmcuY2E9ZnVuY3Rpb24oYSl7aWYoYT09PXRoaXMpcmV0dXJuITA7aWYoYS5LKCkpcmV0dXJuITE7aWYodGhpcy5DKCkuY2EoYS5DKCkpJiZ0aGlzLm0uY291bnQoKT09PWEubS5jb3VudCgpKXt2YXIgYj10aGlzLlhiKE4pO2E9YS5YYihOKTtmb3IodmFyIGM9SihiKSxkPUooYSk7YyYmZDspe2lmKGMubmFtZSE9PWQubmFtZXx8IWMuUy5jYShkLlMpKXJldHVybiExO2M9SihiKTtkPUooYSl9cmV0dXJuIG51bGw9PT1jJiZudWxsPT09ZH1yZXR1cm4hMX07ZnVuY3Rpb24gcWUoYSxiKXtyZXR1cm4gYj09PVFkP251bGw6YS53Yi5nZXQoYi50b1N0cmluZygpKX1nLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcy5JKCEwKSl9O2Z1bmN0aW9uIE0oYSxiKXtpZihudWxsPT09YSlyZXR1cm4gQzt2YXIgYz1udWxsO1wib2JqZWN0XCI9PT10eXBlb2YgYSYmXCIucHJpb3JpdHlcImluIGE/Yz1hW1wiLnByaW9yaXR5XCJdOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYiYmKGM9Yik7SyhudWxsPT09Y3x8XCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGN8fFwib2JqZWN0XCI9PT10eXBlb2YgYyYmXCIuc3ZcImluIGMsXCJJbnZhbGlkIHByaW9yaXR5IHR5cGUgZm91bmQ6IFwiK3R5cGVvZiBjKTtcIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiLnZhbHVlXCJpbiBhJiZudWxsIT09YVtcIi52YWx1ZVwiXSYmKGE9YVtcIi52YWx1ZVwiXSk7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxcIi5zdlwiaW4gYSlyZXR1cm4gbmV3IHRjKGEsTShjKSk7aWYoYSBpbnN0YW5jZW9mIEFycmF5KXt2YXIgZD1DLGU9YTtyKGUsZnVuY3Rpb24oYSxiKXtpZih2KGUsYikmJlwiLlwiIT09Yi5zdWJzdHJpbmcoMCwxKSl7dmFyIGM9TShhKTtpZihjLksoKXx8IWMuZSgpKWQ9XG5kLlUoYixjKX19KTtyZXR1cm4gZC5nYShNKGMpKX12YXIgZj1bXSxoPSExLGs9YTtpYihrLGZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYXx8XCIuXCIhPT1hLnN1YnN0cmluZygwLDEpKXt2YXIgYj1NKGtbYV0pO2IuZSgpfHwoaD1ofHwhYi5DKCkuZSgpLGYucHVzaChuZXcgRihhLGIpKSl9fSk7aWYoMD09Zi5sZW5ndGgpcmV0dXJuIEM7dmFyIGw9amUoZixVYixmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lfSxXYik7aWYoaCl7dmFyIG09amUoZix0ZChOKSk7cmV0dXJuIG5ldyBSKGwsTShjKSxuZXcgaGUoe1wiLnByaW9yaXR5XCI6bX0se1wiLnByaW9yaXR5XCI6Tn0pKX1yZXR1cm4gbmV3IFIobCxNKGMpLGxlKX12YXIgcmU9TWF0aC5sb2coMik7XG5mdW5jdGlvbiBzZShhKXt0aGlzLmNvdW50PXBhcnNlSW50KE1hdGgubG9nKGErMSkvcmUsMTApO3RoaXMuamY9dGhpcy5jb3VudC0xO3RoaXMuZWc9YSsxJnBhcnNlSW50KEFycmF5KHRoaXMuY291bnQrMSkuam9pbihcIjFcIiksMil9ZnVuY3Rpb24gdGUoYSl7dmFyIGI9IShhLmVnJjE8PGEuamYpO2EuamYtLTtyZXR1cm4gYn1cbmZ1bmN0aW9uIGplKGEsYixjLGQpe2Z1bmN0aW9uIGUoYixkKXt2YXIgZj1kLWI7aWYoMD09ZilyZXR1cm4gbnVsbDtpZigxPT1mKXt2YXIgbT1hW2JdLHQ9Yz9jKG0pOm07cmV0dXJuIG5ldyBmYyh0LG0uUywhMSxudWxsLG51bGwpfXZhciBtPXBhcnNlSW50KGYvMiwxMCkrYixmPWUoYixtKSx6PWUobSsxLGQpLG09YVttXSx0PWM/YyhtKTptO3JldHVybiBuZXcgZmModCxtLlMsITEsZix6KX1hLnNvcnQoYik7dmFyIGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZChiLGgpe3ZhciBrPXQtYix6PXQ7dC09Yjt2YXIgej1lKGsrMSx6KSxrPWFba10sST1jP2Moayk6ayx6PW5ldyBmYyhJLGsuUyxoLG51bGwseik7Zj9mLmxlZnQ9ejptPXo7Zj16fWZvcih2YXIgZj1udWxsLG09bnVsbCx0PWEubGVuZ3RoLHo9MDt6PGIuY291bnQ7Kyt6KXt2YXIgST10ZShiKSx6ZD1NYXRoLnBvdygyLGIuY291bnQtKHorMSkpO0k/ZCh6ZCwhMSk6KGQoemQsITEpLGQoemQsITApKX1yZXR1cm4gbX0obmV3IHNlKGEubGVuZ3RoKSk7XG5yZXR1cm4gbnVsbCE9PWY/bmV3IGFjKGR8fGIsZik6bmV3IGFjKGR8fGIpfWZ1bmN0aW9uIG9lKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYT9cIm51bWJlcjpcIitYYyhhKTpcInN0cmluZzpcIithfWZ1bmN0aW9uIG1lKGEpe2lmKGEuSygpKXt2YXIgYj1hLkkoKTtLKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBifHxcIm9iamVjdFwiPT09dHlwZW9mIGImJnYoYixcIi5zdlwiKSxcIlByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKX1lbHNlIEsoYT09PVZkfHxhLmUoKSxcInByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS5cIik7SyhhPT09VmR8fGEuQygpLmUoKSxcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpfXZhciBDPW5ldyBSKG5ldyBhYyhXYiksbnVsbCxsZSk7ZnVuY3Rpb24gdWUoKXtSLmNhbGwodGhpcyxuZXcgYWMoV2IpLEMsbGUpfW1hKHVlLFIpO2c9dWUucHJvdG90eXBlO1xuZy5EYz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/MDoxfTtnLmNhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpc307Zy5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2cuUj1mdW5jdGlvbigpe3JldHVybiBDfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIFZkPW5ldyB1ZSxUZD1uZXcgRihcIltNSU5fTkFNRV1cIixDKSxaZD1uZXcgRihcIltNQVhfTkFNRV1cIixWZCk7ZnVuY3Rpb24gSWQoYSxiKXt0aGlzLk89YTt0aGlzLllkPWJ9ZnVuY3Rpb24gRmQoYSxiLGMsZCl7cmV0dXJuIG5ldyBJZChuZXcgdGIoYixjLGQpLGEuWWQpfWZ1bmN0aW9uIEpkKGEpe3JldHVybiBhLk8uZWE/YS5PLmooKTpudWxsfUlkLnByb3RvdHlwZS53PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWWR9O2Z1bmN0aW9uIHViKGEpe3JldHVybiBhLllkLmVhP2EuWWQuaigpOm51bGx9O2Z1bmN0aW9uIHZlKGEsYil7dGhpcy5XPWE7dmFyIGM9YS5uLGQ9bmV3IGtkKGMuZyksYz1TKGMpP25ldyBrZChjLmcpOmMuamE/bmV3IHFkKGMpOm5ldyBsZChjKTt0aGlzLkhmPW5ldyB4ZChjKTt2YXIgZT1iLncoKSxmPWIuTyxoPWQueGEoQyxlLmooKSxudWxsKSxrPWMueGEoQyxmLmooKSxudWxsKTt0aGlzLkthPW5ldyBJZChuZXcgdGIoayxmLmVhLGMuTmEoKSksbmV3IHRiKGgsZS5lYSxkLk5hKCkpKTt0aGlzLlhhPVtdO3RoaXMubGc9bmV3IGNkKGEpfWZ1bmN0aW9uIHdlKGEpe3JldHVybiBhLld9Zz12ZS5wcm90b3R5cGU7Zy53PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuS2EudygpLmooKX07Zy5mYj1mdW5jdGlvbihhKXt2YXIgYj11Yih0aGlzLkthKTtyZXR1cm4gYiYmKFModGhpcy5XLm4pfHwhYS5lKCkmJiFiLlIoRShhKSkuZSgpKT9iLlEoYSk6bnVsbH07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLlhhLmxlbmd0aH07Zy5QYj1mdW5jdGlvbihhKXt0aGlzLlhhLnB1c2goYSl9O1xuZy5qYj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKGIpe0sobnVsbD09YSxcIkEgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXCIpO3ZhciBkPXRoaXMuVy5wYXRoO09hKHRoaXMuWGEsZnVuY3Rpb24oYSl7KGE9YS5nZihiLGQpKSYmYy5wdXNoKGEpfSl9aWYoYSl7Zm9yKHZhciBlPVtdLGY9MDtmPHRoaXMuWGEubGVuZ3RoOysrZil7dmFyIGg9dGhpcy5YYVtmXTtpZighaC5tYXRjaGVzKGEpKWUucHVzaChoKTtlbHNlIGlmKGEudGYoKSl7ZT1lLmNvbmNhdCh0aGlzLlhhLnNsaWNlKGYrMSkpO2JyZWFrfX10aGlzLlhhPWV9ZWxzZSB0aGlzLlhhPVtdO3JldHVybiBjfTtcbmcuYWI9ZnVuY3Rpb24oYSxiLGMpe2EudHlwZT09PUJkJiZudWxsIT09YS5zb3VyY2UuSGImJihLKHViKHRoaXMuS2EpLFwiV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzXCIpLEsoSmQodGhpcy5LYSksXCJNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlXCIpKTt2YXIgZD10aGlzLkthO2E9dGhpcy5IZi5hYihkLGEsYixjKTtiPXRoaXMuSGY7Yz1hLmplO0soYy5PLmooKS5KYyhiLlYuZyksXCJFdmVudCBzbmFwIG5vdCBpbmRleGVkXCIpO0soYy53KCkuaigpLkpjKGIuVi5nKSxcIlNlcnZlciBzbmFwIG5vdCBpbmRleGVkXCIpO0soSWIoYS5qZS53KCkpfHwhSWIoZC53KCkpLFwiT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFja1wiKTt0aGlzLkthPWEuamU7cmV0dXJuIHhlKHRoaXMsYS5mZyxhLmplLk8uaigpLG51bGwpfTtcbmZ1bmN0aW9uIHllKGEsYil7dmFyIGM9YS5LYS5PLGQ9W107Yy5qKCkuSygpfHxjLmooKS5QKE4sZnVuY3Rpb24oYSxiKXtkLnB1c2gobmV3IEQoXCJjaGlsZF9hZGRlZFwiLGIsYSkpfSk7Yy5lYSYmZC5wdXNoKEViKGMuaigpKSk7cmV0dXJuIHhlKGEsZCxjLmooKSxiKX1mdW5jdGlvbiB4ZShhLGIsYyxkKXtyZXR1cm4gZGQoYS5sZyxiLGMsZD9bZF06YS5YYSl9O2Z1bmN0aW9uIHplKGEsYixjKXt0aGlzLnR5cGU9QmQ7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLmNoaWxkcmVuPWN9emUucHJvdG90eXBlLlhjPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpcmV0dXJuIGE9dGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBMKGEpKSxhLmUoKT9udWxsOmEudmFsdWU/bmV3IFhiKHRoaXMuc291cmNlLEcsYS52YWx1ZSk6bmV3IHplKHRoaXMuc291cmNlLEcsYSk7SyhFKHRoaXMucGF0aCk9PT1hLFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7cmV0dXJuIG5ldyB6ZSh0aGlzLnNvdXJjZSxIKHRoaXMucGF0aCksdGhpcy5jaGlsZHJlbil9O3plLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBtZXJnZTogXCIrdGhpcy5jaGlsZHJlbi50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBBZShhLGIpe3RoaXMuZj1NYyhcInA6cmVzdDpcIik7dGhpcy5GPWE7dGhpcy5HYj1iO3RoaXMuQWE9bnVsbDt0aGlzLiQ9e319ZnVuY3Rpb24gQmUoYSxiKXtpZihuKGIpKXJldHVyblwidGFnJFwiK2I7SyhmZShhLm4pLFwic2hvdWxkIGhhdmUgYSB0YWcgaWYgaXQncyBub3QgYSBkZWZhdWx0IHF1ZXJ5LlwiKTtyZXR1cm4gYS5wYXRoLnRvU3RyaW5nKCl9Zz1BZS5wcm90b3R5cGU7XG5nLnlmPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEucGF0aC50b1N0cmluZygpO3RoaXMuZihcIkxpc3RlbiBjYWxsZWQgZm9yIFwiK2UrXCIgXCIrYS52YSgpKTt2YXIgZj1CZShhLGMpLGg9e307dGhpcy4kW2ZdPWg7YT1nZShhLm4pO3ZhciBrPXRoaXM7Q2UodGhpcyxlK1wiLmpzb25cIixhLGZ1bmN0aW9uKGEsYil7dmFyIHQ9Yjs0MDQ9PT1hJiYoYT10PW51bGwpO251bGw9PT1hJiZrLkdiKGUsdCwhMSxjKTt3KGsuJCxmKT09PWgmJmQoYT80MDE9PWE/XCJwZXJtaXNzaW9uX2RlbmllZFwiOlwicmVzdF9lcnJvcjpcIithOlwib2tcIixudWxsKX0pfTtnLlJmPWZ1bmN0aW9uKGEsYil7dmFyIGM9QmUoYSxiKTtkZWxldGUgdGhpcy4kW2NdfTtnLk09ZnVuY3Rpb24oYSxiKXt0aGlzLkFhPWE7dmFyIGM9JGMoYSksZD1jLmRhdGEsYz1jLkJjJiZjLkJjLmV4cDtiJiZiKFwib2tcIix7YXV0aDpkLGV4cGlyZXM6Y30pfTtnLmdlPWZ1bmN0aW9uKGEpe3RoaXMuQWE9bnVsbDthKFwib2tcIixudWxsKX07Zy5NZT1mdW5jdGlvbigpe307XG5nLkNmPWZ1bmN0aW9uKCl7fTtnLkpkPWZ1bmN0aW9uKCl7fTtnLnB1dD1mdW5jdGlvbigpe307Zy56Zj1mdW5jdGlvbigpe307Zy5VZT1mdW5jdGlvbigpe307XG5mdW5jdGlvbiBDZShhLGIsYyxkKXtjPWN8fHt9O2MuZm9ybWF0PVwiZXhwb3J0XCI7YS5BYSYmKGMuYXV0aD1hLkFhKTt2YXIgZT0oYS5GLmtiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrYS5GLmhvc3QrYitcIj9cIitrYihjKTthLmYoXCJTZW5kaW5nIFJFU1QgcmVxdWVzdCBmb3IgXCIrZSk7dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O2Yub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZCYmND09PWYucmVhZHlTdGF0ZSl7YS5mKFwiUkVTVCBSZXNwb25zZSBmb3IgXCIrZStcIiByZWNlaXZlZC4gc3RhdHVzOlwiLGYuc3RhdHVzLFwicmVzcG9uc2U6XCIsZi5yZXNwb25zZVRleHQpO3ZhciBiPW51bGw7aWYoMjAwPD1mLnN0YXR1cyYmMzAwPmYuc3RhdHVzKXt0cnl7Yj1uYihmLnJlc3BvbnNlVGV4dCl9Y2F0Y2goYyl7TyhcIkZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlIGZvciBcIitlK1wiOiBcIitmLnJlc3BvbnNlVGV4dCl9ZChudWxsLGIpfWVsc2UgNDAxIT09Zi5zdGF0dXMmJjQwNCE9PVxuZi5zdGF0dXMmJk8oXCJHb3QgdW5zdWNjZXNzZnVsIFJFU1QgcmVzcG9uc2UgZm9yIFwiK2UrXCIgU3RhdHVzOiBcIitmLnN0YXR1cyksZChmLnN0YXR1cyk7ZD1udWxsfX07Zi5vcGVuKFwiR0VUXCIsZSwhMCk7Zi5zZW5kKCl9O2Z1bmN0aW9uIERlKGEpe0soZWEoYSkmJjA8YS5sZW5ndGgsXCJSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheVwiKTt0aGlzLlhmPWE7dGhpcy5PYz17fX1EZS5wcm90b3R5cGUuZmU9ZnVuY3Rpb24oYSxiKXt2YXIgYztjPXRoaXMuT2NbYV18fFtdO3ZhciBkPWMubGVuZ3RoO2lmKDA8ZCl7Zm9yKHZhciBlPUFycmF5KGQpLGY9MDtmPGQ7ZisrKWVbZl09Y1tmXTtjPWV9ZWxzZSBjPVtdO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS56Yy5hcHBseShjW2RdLk1hLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9O0RlLnByb3RvdHlwZS5FYj1mdW5jdGlvbihhLGIsYyl7RWUodGhpcyxhKTt0aGlzLk9jW2FdPXRoaXMuT2NbYV18fFtdO3RoaXMuT2NbYV0ucHVzaCh7emM6YixNYTpjfSk7KGE9dGhpcy5BZShhKSkmJmIuYXBwbHkoYyxhKX07XG5EZS5wcm90b3R5cGUuaWM9ZnVuY3Rpb24oYSxiLGMpe0VlKHRoaXMsYSk7YT10aGlzLk9jW2FdfHxbXTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnpjPT09YiYmKCFjfHxjPT09YVtkXS5NYSkpe2Euc3BsaWNlKGQsMSk7YnJlYWt9fTtmdW5jdGlvbiBFZShhLGIpe0soVGEoYS5YZixmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9KSxcIlVua25vd24gZXZlbnQ6IFwiK2IpfTt2YXIgRmU9ZnVuY3Rpb24oKXt2YXIgYT0wLGI9W107cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBkPWM9PT1hO2E9Yztmb3IodmFyIGU9QXJyYXkoOCksZj03OzA8PWY7Zi0tKWVbZl09XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGMlNjQpLGM9TWF0aC5mbG9vcihjLzY0KTtLKDA9PT1jLFwiQ2Fubm90IHB1c2ggYXQgdGltZSA9PSAwXCIpO2M9ZS5qb2luKFwiXCIpO2lmKGQpe2ZvcihmPTExOzA8PWYmJjYzPT09YltmXTtmLS0pYltmXT0wO2JbZl0rK31lbHNlIGZvcihmPTA7MTI+ZjtmKyspYltmXT1NYXRoLmZsb29yKDY0Kk1hdGgucmFuZG9tKCkpO2ZvcihmPTA7MTI+ZjtmKyspYys9XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGJbZl0pO0soMjA9PT1jLmxlbmd0aCxcIm5leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuXCIpO1xucmV0dXJuIGN9fSgpO2Z1bmN0aW9uIEdlKCl7RGUuY2FsbCh0aGlzLFtcIm9ubGluZVwiXSk7dGhpcy5rYz0hMDtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7dmFyIGE9dGhpczt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLGZ1bmN0aW9uKCl7YS5rY3x8KGEua2M9ITAsYS5mZShcIm9ubGluZVwiLCEwKSl9LCExKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIixmdW5jdGlvbigpe2Eua2MmJihhLmtjPSExLGEuZmUoXCJvbmxpbmVcIiwhMSkpfSwhMSl9fW1hKEdlLERlKTtHZS5wcm90b3R5cGUuQWU9ZnVuY3Rpb24oYSl7SyhcIm9ubGluZVwiPT09YSxcIlVua25vd24gZXZlbnQgdHlwZTogXCIrYSk7cmV0dXJuW3RoaXMua2NdfTtjYShHZSk7ZnVuY3Rpb24gSGUoKXtEZS5jYWxsKHRoaXMsW1widmlzaWJsZVwiXSk7dmFyIGEsYjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXImJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmhpZGRlbj8oYj1cInZpc2liaWxpdHljaGFuZ2VcIixhPVwiaGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhiPVwibW96dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtb3pIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbj8oYj1cIm1zdmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtc0hpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGI9XCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIndlYmtpdEhpZGRlblwiKSk7dGhpcy5PYj0hMDtpZihiKXt2YXIgYz10aGlzO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYixcbmZ1bmN0aW9uKCl7dmFyIGI9IWRvY3VtZW50W2FdO2IhPT1jLk9iJiYoYy5PYj1iLGMuZmUoXCJ2aXNpYmxlXCIsYikpfSwhMSl9fW1hKEhlLERlKTtIZS5wcm90b3R5cGUuQWU9ZnVuY3Rpb24oYSl7SyhcInZpc2libGVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLk9iXX07Y2EoSGUpO2Z1bmN0aW9uIEwoYSxiKXtpZigxPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLm89YS5zcGxpdChcIi9cIik7Zm9yKHZhciBjPTAsZD0wO2Q8dGhpcy5vLmxlbmd0aDtkKyspMDx0aGlzLm9bZF0ubGVuZ3RoJiYodGhpcy5vW2NdPXRoaXMub1tkXSxjKyspO3RoaXMuby5sZW5ndGg9Yzt0aGlzLlo9MH1lbHNlIHRoaXMubz1hLHRoaXMuWj1ifWZ1bmN0aW9uIFQoYSxiKXt2YXIgYz1FKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGM9PT1FKGIpKXJldHVybiBUKEgoYSksSChiKSk7dGhyb3cgRXJyb3IoXCJJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoIChcIitiK1wiKSBpcyBub3Qgd2l0aGluIG91dGVyUGF0aCAoXCIrYStcIilcIik7fVxuZnVuY3Rpb24gSWUoYSxiKXtmb3IodmFyIGM9YS5zbGljZSgpLGQ9Yi5zbGljZSgpLGU9MDtlPGMubGVuZ3RoJiZlPGQubGVuZ3RoO2UrKyl7dmFyIGY9VmIoY1tlXSxkW2VdKTtpZigwIT09ZilyZXR1cm4gZn1yZXR1cm4gYy5sZW5ndGg9PT1kLmxlbmd0aD8wOmMubGVuZ3RoPGQubGVuZ3RoPy0xOjF9ZnVuY3Rpb24gRShhKXtyZXR1cm4gYS5aPj1hLm8ubGVuZ3RoP251bGw6YS5vW2EuWl19ZnVuY3Rpb24gS2QoYSl7cmV0dXJuIGEuby5sZW5ndGgtYS5afWZ1bmN0aW9uIEgoYSl7dmFyIGI9YS5aO2I8YS5vLmxlbmd0aCYmYisrO3JldHVybiBuZXcgTChhLm8sYil9ZnVuY3Rpb24gTGQoYSl7cmV0dXJuIGEuWjxhLm8ubGVuZ3RoP2Eub1thLm8ubGVuZ3RoLTFdOm51bGx9Zz1MLnByb3RvdHlwZTtcbmcudG9TdHJpbmc9ZnVuY3Rpb24oKXtmb3IodmFyIGE9XCJcIixiPXRoaXMuWjtiPHRoaXMuby5sZW5ndGg7YisrKVwiXCIhPT10aGlzLm9bYl0mJihhKz1cIi9cIit0aGlzLm9bYl0pO3JldHVybiBhfHxcIi9cIn07Zy5zbGljZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vLnNsaWNlKHRoaXMuWisoYXx8MCkpfTtnLnBhcmVudD1mdW5jdGlvbigpe2lmKHRoaXMuWj49dGhpcy5vLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGE9W10sYj10aGlzLlo7Yjx0aGlzLm8ubGVuZ3RoLTE7YisrKWEucHVzaCh0aGlzLm9bYl0pO3JldHVybiBuZXcgTChhLDApfTtcbmcudT1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz10aGlzLlo7Yzx0aGlzLm8ubGVuZ3RoO2MrKyliLnB1c2godGhpcy5vW2NdKTtpZihhIGluc3RhbmNlb2YgTClmb3IoYz1hLlo7YzxhLm8ubGVuZ3RoO2MrKyliLnB1c2goYS5vW2NdKTtlbHNlIGZvcihhPWEuc3BsaXQoXCIvXCIpLGM9MDtjPGEubGVuZ3RoO2MrKykwPGFbY10ubGVuZ3RoJiZiLnB1c2goYVtjXSk7cmV0dXJuIG5ldyBMKGIsMCl9O2cuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLlo+PXRoaXMuby5sZW5ndGh9O2cuY2E9ZnVuY3Rpb24oYSl7aWYoS2QodGhpcykhPT1LZChhKSlyZXR1cm4hMTtmb3IodmFyIGI9dGhpcy5aLGM9YS5aO2I8PXRoaXMuby5sZW5ndGg7YisrLGMrKylpZih0aGlzLm9bYl0hPT1hLm9bY10pcmV0dXJuITE7cmV0dXJuITB9O1xuZy5jb250YWlucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLlosYz1hLlo7aWYoS2QodGhpcyk+S2QoYSkpcmV0dXJuITE7Zm9yKDtiPHRoaXMuby5sZW5ndGg7KXtpZih0aGlzLm9bYl0hPT1hLm9bY10pcmV0dXJuITE7KytiOysrY31yZXR1cm4hMH07dmFyIEc9bmV3IEwoXCJcIik7ZnVuY3Rpb24gSmUoYSxiKXt0aGlzLlFhPWEuc2xpY2UoKTt0aGlzLkhhPU1hdGgubWF4KDEsdGhpcy5RYS5sZW5ndGgpO3RoaXMubGY9Yjtmb3IodmFyIGM9MDtjPHRoaXMuUWEubGVuZ3RoO2MrKyl0aGlzLkhhKz1aYyh0aGlzLlFhW2NdKTtLZSh0aGlzKX1KZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihhKXswPHRoaXMuUWEubGVuZ3RoJiYodGhpcy5IYSs9MSk7dGhpcy5RYS5wdXNoKGEpO3RoaXMuSGErPVpjKGEpO0tlKHRoaXMpfTtKZS5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5RYS5wb3AoKTt0aGlzLkhhLT1aYyhhKTswPHRoaXMuUWEubGVuZ3RoJiYtLXRoaXMuSGF9O1xuZnVuY3Rpb24gS2UoYSl7aWYoNzY4PGEuSGEpdGhyb3cgRXJyb3IoYS5sZitcImhhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuIDc2OCBieXRlcyAoXCIrYS5IYStcIikuXCIpO2lmKDMyPGEuUWEubGVuZ3RoKXRocm93IEVycm9yKGEubGYrXCJwYXRoIHNwZWNpZmllZCBleGNlZWRzIHRoZSBtYXhpbXVtIGRlcHRoIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKDMyKSBvciBvYmplY3QgY29udGFpbnMgYSBjeWNsZSBcIitMZShhKSk7fWZ1bmN0aW9uIExlKGEpe3JldHVybiAwPT1hLlFhLmxlbmd0aD9cIlwiOlwiaW4gcHJvcGVydHkgJ1wiK2EuUWEuam9pbihcIi5cIikrXCInXCJ9O2Z1bmN0aW9uIE1lKGEsYil7dGhpcy52YWx1ZT1hO3RoaXMuY2hpbGRyZW49Ynx8TmV9dmFyIE5lPW5ldyBhYyhmdW5jdGlvbihhLGIpe3JldHVybiBhPT09Yj8wOmE8Yj8tMToxfSk7ZnVuY3Rpb24gT2UoYSl7dmFyIGI9UGQ7cihhLGZ1bmN0aW9uKGEsZCl7Yj1iLnNldChuZXcgTChkKSxhKX0pO3JldHVybiBifWc9TWUucHJvdG90eXBlO2cuZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZSYmdGhpcy5jaGlsZHJlbi5lKCl9O2Z1bmN0aW9uIFBlKGEsYixjKXtpZihudWxsIT1hLnZhbHVlJiZjKGEudmFsdWUpKXJldHVybntwYXRoOkcsdmFsdWU6YS52YWx1ZX07aWYoYi5lKCkpcmV0dXJuIG51bGw7dmFyIGQ9RShiKTthPWEuY2hpbGRyZW4uZ2V0KGQpO3JldHVybiBudWxsIT09YT8oYj1QZShhLEgoYiksYyksbnVsbCE9Yj97cGF0aDoobmV3IEwoZCkpLnUoYi5wYXRoKSx2YWx1ZTpiLnZhbHVlfTpudWxsKTpudWxsfVxuZnVuY3Rpb24gUWUoYSxiKXtyZXR1cm4gUGUoYSxiLGZ1bmN0aW9uKCl7cmV0dXJuITB9KX1nLnN1YnRyZWU9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoRShhKSk7cmV0dXJuIG51bGwhPT1iP2Iuc3VidHJlZShIKGEpKTpQZH07Zy5zZXQ9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSlyZXR1cm4gbmV3IE1lKGIsdGhpcy5jaGlsZHJlbik7dmFyIGM9RShhKSxkPSh0aGlzLmNoaWxkcmVuLmdldChjKXx8UGQpLnNldChIKGEpLGIpLGM9dGhpcy5jaGlsZHJlbi5PYShjLGQpO3JldHVybiBuZXcgTWUodGhpcy52YWx1ZSxjKX07XG5nLnJlbW92ZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy5jaGlsZHJlbi5lKCk/UGQ6bmV3IE1lKG51bGwsdGhpcy5jaGlsZHJlbik7dmFyIGI9RShhKSxjPXRoaXMuY2hpbGRyZW4uZ2V0KGIpO3JldHVybiBjPyhhPWMucmVtb3ZlKEgoYSkpLGI9YS5lKCk/dGhpcy5jaGlsZHJlbi5yZW1vdmUoYik6dGhpcy5jaGlsZHJlbi5PYShiLGEpLG51bGw9PT10aGlzLnZhbHVlJiZiLmUoKT9QZDpuZXcgTWUodGhpcy52YWx1ZSxiKSk6dGhpc307Zy5nZXQ9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXMudmFsdWU7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoRShhKSk7cmV0dXJuIGI/Yi5nZXQoSChhKSk6bnVsbH07XG5mdW5jdGlvbiBPZChhLGIsYyl7aWYoYi5lKCkpcmV0dXJuIGM7dmFyIGQ9RShiKTtiPU9kKGEuY2hpbGRyZW4uZ2V0KGQpfHxQZCxIKGIpLGMpO2Q9Yi5lKCk/YS5jaGlsZHJlbi5yZW1vdmUoZCk6YS5jaGlsZHJlbi5PYShkLGIpO3JldHVybiBuZXcgTWUoYS52YWx1ZSxkKX1mdW5jdGlvbiBSZShhLGIpe3JldHVybiBTZShhLEcsYil9ZnVuY3Rpb24gU2UoYSxiLGMpe3ZhciBkPXt9O2EuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYSxmKXtkW2FdPVNlKGYsYi51KGEpLGMpfSk7cmV0dXJuIGMoYixhLnZhbHVlLGQpfWZ1bmN0aW9uIFRlKGEsYixjKXtyZXR1cm4gVWUoYSxiLEcsYyl9ZnVuY3Rpb24gVWUoYSxiLGMsZCl7dmFyIGU9YS52YWx1ZT9kKGMsYS52YWx1ZSk6ITE7aWYoZSlyZXR1cm4gZTtpZihiLmUoKSlyZXR1cm4gbnVsbDtlPUUoYik7cmV0dXJuKGE9YS5jaGlsZHJlbi5nZXQoZSkpP1VlKGEsSChiKSxjLnUoZSksZCk6bnVsbH1cbmZ1bmN0aW9uIFZlKGEsYixjKXt2YXIgZD1HO2lmKCFiLmUoKSl7dmFyIGU9ITA7YS52YWx1ZSYmKGU9YyhkLGEudmFsdWUpKTshMD09PWUmJihlPUUoYiksKGE9YS5jaGlsZHJlbi5nZXQoZSkpJiZXZShhLEgoYiksZC51KGUpLGMpKX19ZnVuY3Rpb24gV2UoYSxiLGMsZCl7aWYoYi5lKCkpcmV0dXJuIGE7YS52YWx1ZSYmZChjLGEudmFsdWUpO3ZhciBlPUUoYik7cmV0dXJuKGE9YS5jaGlsZHJlbi5nZXQoZSkpP1dlKGEsSChiKSxjLnUoZSksZCk6UGR9ZnVuY3Rpb24gTWQoYSxiKXtYZShhLEcsYil9ZnVuY3Rpb24gWGUoYSxiLGMpe2EuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYSxlKXtYZShlLGIudShhKSxjKX0pO2EudmFsdWUmJmMoYixhLnZhbHVlKX1mdW5jdGlvbiBZZShhLGIpe2EuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYSxkKXtkLnZhbHVlJiZiKGEsZC52YWx1ZSl9KX12YXIgUGQ9bmV3IE1lKG51bGwpO1xuTWUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9e307TWQodGhpcyxmdW5jdGlvbihiLGMpe2FbYi50b1N0cmluZygpXT1jLnRvU3RyaW5nKCl9KTtyZXR1cm4gQihhKX07ZnVuY3Rpb24gWmUoYSxiLGMpe3RoaXMudHlwZT1FZDt0aGlzLnNvdXJjZT0kZTt0aGlzLnBhdGg9YTt0aGlzLlFiPWI7dGhpcy5WZD1jfVplLnByb3RvdHlwZS5YYz1mdW5jdGlvbihhKXtpZih0aGlzLnBhdGguZSgpKXtpZihudWxsIT10aGlzLlFiLnZhbHVlKXJldHVybiBLKHRoaXMuUWIuY2hpbGRyZW4uZSgpLFwiYWZmZWN0ZWRUcmVlIHNob3VsZCBub3QgaGF2ZSBvdmVybGFwcGluZyBhZmZlY3RlZCBwYXRocy5cIiksdGhpczthPXRoaXMuUWIuc3VidHJlZShuZXcgTChhKSk7cmV0dXJuIG5ldyBaZShHLGEsdGhpcy5WZCl9SyhFKHRoaXMucGF0aCk9PT1hLFwib3BlcmF0aW9uRm9yQ2hpbGQgY2FsbGVkIGZvciB1bnJlbGF0ZWQgY2hpbGQuXCIpO3JldHVybiBuZXcgWmUoSCh0aGlzLnBhdGgpLHRoaXMuUWIsdGhpcy5WZCl9O1xuWmUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGFjayB3cml0ZSByZXZlcnQ9XCIrdGhpcy5WZCtcIiBhZmZlY3RlZFRyZWU9XCIrdGhpcy5RYitcIilcIn07dmFyIFliPTAsQmQ9MSxFZD0yLCRiPTM7ZnVuY3Rpb24gYWYoYSxiLGMsZCl7dGhpcy53ZT1hO3RoaXMucGY9Yjt0aGlzLkhiPWM7dGhpcy5hZj1kO0soIWR8fGIsXCJUYWdnZWQgcXVlcmllcyBtdXN0IGJlIGZyb20gc2VydmVyLlwiKX12YXIgJGU9bmV3IGFmKCEwLCExLG51bGwsITEpLGJmPW5ldyBhZighMSwhMCxudWxsLCExKTthZi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZT9cInVzZXJcIjp0aGlzLmFmP1wic2VydmVyKHF1ZXJ5SUQ9XCIrdGhpcy5IYitcIilcIjpcInNlcnZlclwifTtmdW5jdGlvbiBjZihhKXt0aGlzLlg9YX12YXIgZGY9bmV3IGNmKG5ldyBNZShudWxsKSk7ZnVuY3Rpb24gZWYoYSxiLGMpe2lmKGIuZSgpKXJldHVybiBuZXcgY2YobmV3IE1lKGMpKTt2YXIgZD1RZShhLlgsYik7aWYobnVsbCE9ZCl7dmFyIGU9ZC5wYXRoLGQ9ZC52YWx1ZTtiPVQoZSxiKTtkPWQuRyhiLGMpO3JldHVybiBuZXcgY2YoYS5YLnNldChlLGQpKX1hPU9kKGEuWCxiLG5ldyBNZShjKSk7cmV0dXJuIG5ldyBjZihhKX1mdW5jdGlvbiBmZihhLGIsYyl7dmFyIGQ9YTtpYihjLGZ1bmN0aW9uKGEsYyl7ZD1lZihkLGIudShhKSxjKX0pO3JldHVybiBkfWNmLnByb3RvdHlwZS5SZD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gZGY7YT1PZCh0aGlzLlgsYSxQZCk7cmV0dXJuIG5ldyBjZihhKX07ZnVuY3Rpb24gZ2YoYSxiKXt2YXIgYz1RZShhLlgsYik7cmV0dXJuIG51bGwhPWM/YS5YLmdldChjLnBhdGgpLlEoVChjLnBhdGgsYikpOm51bGx9XG5mdW5jdGlvbiBoZihhKXt2YXIgYj1bXSxjPWEuWC52YWx1ZTtudWxsIT1jP2MuSygpfHxjLlAoTixmdW5jdGlvbihhLGMpe2IucHVzaChuZXcgRihhLGMpKX0pOmEuWC5jaGlsZHJlbi5pYShmdW5jdGlvbihhLGMpe251bGwhPWMudmFsdWUmJmIucHVzaChuZXcgRihhLGMudmFsdWUpKX0pO3JldHVybiBifWZ1bmN0aW9uIGpmKGEsYil7aWYoYi5lKCkpcmV0dXJuIGE7dmFyIGM9Z2YoYSxiKTtyZXR1cm4gbnVsbCE9Yz9uZXcgY2YobmV3IE1lKGMpKTpuZXcgY2YoYS5YLnN1YnRyZWUoYikpfWNmLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWC5lKCl9O2NmLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXtyZXR1cm4ga2YoRyx0aGlzLlgsYSl9O1xuZnVuY3Rpb24ga2YoYSxiLGMpe2lmKG51bGwhPWIudmFsdWUpcmV0dXJuIGMuRyhhLGIudmFsdWUpO3ZhciBkPW51bGw7Yi5jaGlsZHJlbi5pYShmdW5jdGlvbihiLGYpe1wiLnByaW9yaXR5XCI9PT1iPyhLKG51bGwhPT1mLnZhbHVlLFwiUHJpb3JpdHkgd3JpdGVzIG11c3QgYWx3YXlzIGJlIGxlYWYgbm9kZXNcIiksZD1mLnZhbHVlKTpjPWtmKGEudShiKSxmLGMpfSk7Yy5RKGEpLmUoKXx8bnVsbD09PWR8fChjPWMuRyhhLnUoXCIucHJpb3JpdHlcIiksZCkpO3JldHVybiBjfTtmdW5jdGlvbiBsZigpe3RoaXMuVD1kZjt0aGlzLm5hPVtdO3RoaXMuTWM9LTF9ZnVuY3Rpb24gbWYoYSxiKXtmb3IodmFyIGM9MDtjPGEubmEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5uYVtjXTtpZihkLmtkPT09YilyZXR1cm4gZH1yZXR1cm4gbnVsbH1nPWxmLnByb3RvdHlwZTtcbmcuUmQ9ZnVuY3Rpb24oYSl7dmFyIGI9VWEodGhpcy5uYSxmdW5jdGlvbihiKXtyZXR1cm4gYi5rZD09PWF9KTtLKDA8PWIsXCJyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLlwiKTt2YXIgYz10aGlzLm5hW2JdO3RoaXMubmEuc3BsaWNlKGIsMSk7Zm9yKHZhciBkPWMudmlzaWJsZSxlPSExLGY9dGhpcy5uYS5sZW5ndGgtMTtkJiYwPD1mOyl7dmFyIGg9dGhpcy5uYVtmXTtoLnZpc2libGUmJihmPj1iJiZuZihoLGMucGF0aCk/ZD0hMTpjLnBhdGguY29udGFpbnMoaC5wYXRoKSYmKGU9ITApKTtmLS19aWYoZCl7aWYoZSl0aGlzLlQ9b2YodGhpcy5uYSxwZixHKSx0aGlzLk1jPTA8dGhpcy5uYS5sZW5ndGg/dGhpcy5uYVt0aGlzLm5hLmxlbmd0aC0xXS5rZDotMTtlbHNlIGlmKGMuR2EpdGhpcy5UPXRoaXMuVC5SZChjLnBhdGgpO2Vsc2V7dmFyIGs9dGhpcztyKGMuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtrLlQ9ay5ULlJkKGMucGF0aC51KGIpKX0pfXJldHVybiEwfXJldHVybiExfTtcbmcuemE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoY3x8ZCl7dmFyIGU9amYodGhpcy5ULGEpO3JldHVybiFkJiZlLmUoKT9iOmR8fG51bGwhPWJ8fG51bGwhPWdmKGUsRyk/KGU9b2YodGhpcy5uYSxmdW5jdGlvbihiKXtyZXR1cm4oYi52aXNpYmxlfHxkKSYmKCFjfHwhKDA8PU5hKGMsYi5rZCkpKSYmKGIucGF0aC5jb250YWlucyhhKXx8YS5jb250YWlucyhiLnBhdGgpKX0sYSksYj1ifHxDLGUuYXBwbHkoYikpOm51bGx9ZT1nZih0aGlzLlQsYSk7aWYobnVsbCE9ZSlyZXR1cm4gZTtlPWpmKHRoaXMuVCxhKTtyZXR1cm4gZS5lKCk/YjpudWxsIT1ifHxudWxsIT1nZihlLEcpPyhiPWJ8fEMsZS5hcHBseShiKSk6bnVsbH07XG5nLnljPWZ1bmN0aW9uKGEsYil7dmFyIGM9QyxkPWdmKHRoaXMuVCxhKTtpZihkKWQuSygpfHxkLlAoTixmdW5jdGlvbihhLGIpe2M9Yy5VKGEsYil9KTtlbHNlIGlmKGIpe3ZhciBlPWpmKHRoaXMuVCxhKTtiLlAoTixmdW5jdGlvbihhLGIpe3ZhciBkPWpmKGUsbmV3IEwoYSkpLmFwcGx5KGIpO2M9Yy5VKGEsZCl9KTtPYShoZihlKSxmdW5jdGlvbihhKXtjPWMuVShhLm5hbWUsYS5TKX0pfWVsc2UgZT1qZih0aGlzLlQsYSksT2EoaGYoZSksZnVuY3Rpb24oYSl7Yz1jLlUoYS5uYW1lLGEuUyl9KTtyZXR1cm4gY307Zy5sZD1mdW5jdGlvbihhLGIsYyxkKXtLKGN8fGQsXCJFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcIik7YT1hLnUoYik7aWYobnVsbCE9Z2YodGhpcy5ULGEpKXJldHVybiBudWxsO2E9amYodGhpcy5ULGEpO3JldHVybiBhLmUoKT9kLlEoYik6YS5hcHBseShkLlEoYikpfTtcbmcueGM9ZnVuY3Rpb24oYSxiLGMpe2E9YS51KGIpO3ZhciBkPWdmKHRoaXMuVCxhKTtyZXR1cm4gbnVsbCE9ZD9kOnNiKGMsYik/amYodGhpcy5ULGEpLmFwcGx5KGMuaigpLlIoYikpOm51bGx9O2cudGM9ZnVuY3Rpb24oYSl7cmV0dXJuIGdmKHRoaXMuVCxhKX07Zy5uZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGg7YT1qZih0aGlzLlQsYSk7aD1nZihhLEcpO2lmKG51bGw9PWgpaWYobnVsbCE9YiloPWEuYXBwbHkoYik7ZWxzZSByZXR1cm5bXTtoPWgubGIoZik7aWYoaC5lKCl8fGguSygpKXJldHVybltdO2I9W107YT10ZChmKTtlPWU/aC4kYihjLGYpOmguWWIoYyxmKTtmb3IoZj1KKGUpO2YmJmIubGVuZ3RoPGQ7KTAhPT1hKGYsYykmJmIucHVzaChmKSxmPUooZSk7cmV0dXJuIGJ9O1xuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm4gYS5HYT9hLnBhdGguY29udGFpbnMoYik6ISF1YShhLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEucGF0aC51KGQpLmNvbnRhaW5zKGIpfSl9ZnVuY3Rpb24gcGYoYSl7cmV0dXJuIGEudmlzaWJsZX1cbmZ1bmN0aW9uIG9mKGEsYixjKXtmb3IodmFyIGQ9ZGYsZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKGIoZikpe3ZhciBoPWYucGF0aDtpZihmLkdhKWMuY29udGFpbnMoaCk/KGg9VChjLGgpLGQ9ZWYoZCxoLGYuR2EpKTpoLmNvbnRhaW5zKGMpJiYoaD1UKGgsYyksZD1lZihkLEcsZi5HYS5RKGgpKSk7ZWxzZSBpZihmLmNoaWxkcmVuKWlmKGMuY29udGFpbnMoaCkpaD1UKGMsaCksZD1mZihkLGgsZi5jaGlsZHJlbik7ZWxzZXtpZihoLmNvbnRhaW5zKGMpKWlmKGg9VChoLGMpLGguZSgpKWQ9ZmYoZCxHLGYuY2hpbGRyZW4pO2Vsc2UgaWYoZj13KGYuY2hpbGRyZW4sRShoKSkpZj1mLlEoSChoKSksZD1lZihkLEcsZil9ZWxzZSB0aHJvdyBGYyhcIldyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlblwiKTt9fXJldHVybiBkfWZ1bmN0aW9uIHFmKGEsYil7dGhpcy5NYj1hO3RoaXMuWD1ifWc9cWYucHJvdG90eXBlO1xuZy56YT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuWC56YSh0aGlzLk1iLGEsYixjKX07Zy55Yz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5YLnljKHRoaXMuTWIsYSl9O2cubGQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlgubGQodGhpcy5NYixhLGIsYyl9O2cudGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWC50Yyh0aGlzLk1iLnUoYSkpfTtnLm5lPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuWC5uZSh0aGlzLk1iLGEsYixjLGQsZSl9O2cueGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5YLnhjKHRoaXMuTWIsYSxiKX07Zy51PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgcWYodGhpcy5NYi51KGEpLHRoaXMuWCl9O2Z1bmN0aW9uIHJmKCl7dGhpcy55YT17fX1nPXJmLnByb3RvdHlwZTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4gd2EodGhpcy55YSl9O2cuYWI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuc291cmNlLkhiO2lmKG51bGwhPT1kKXJldHVybiBkPXcodGhpcy55YSxkKSxLKG51bGwhPWQsXCJTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LlwiKSxkLmFiKGEsYixjKTt2YXIgZT1bXTtyKHRoaXMueWEsZnVuY3Rpb24oZCl7ZT1lLmNvbmNhdChkLmFiKGEsYixjKSl9KTtyZXR1cm4gZX07Zy5QYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEudmEoKSxoPXcodGhpcy55YSxmKTtpZighaCl7dmFyIGg9Yy56YShlP2Q6bnVsbCksaz0hMTtoP2s9ITA6KGg9ZCBpbnN0YW5jZW9mIFI/Yy55YyhkKTpDLGs9ITEpO2g9bmV3IHZlKGEsbmV3IElkKG5ldyB0YihoLGssITEpLG5ldyB0YihkLGUsITEpKSk7dGhpcy55YVtmXT1ofWguUGIoYik7cmV0dXJuIHllKGgsYil9O1xuZy5qYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS52YSgpLGU9W10sZj1bXSxoPW51bGwhPXNmKHRoaXMpO2lmKFwiZGVmYXVsdFwiPT09ZCl7dmFyIGs9dGhpcztyKHRoaXMueWEsZnVuY3Rpb24oYSxkKXtmPWYuY29uY2F0KGEuamIoYixjKSk7YS5lKCkmJihkZWxldGUgay55YVtkXSxTKGEuVy5uKXx8ZS5wdXNoKGEuVykpfSl9ZWxzZXt2YXIgbD13KHRoaXMueWEsZCk7bCYmKGY9Zi5jb25jYXQobC5qYihiLGMpKSxsLmUoKSYmKGRlbGV0ZSB0aGlzLnlhW2RdLFMobC5XLm4pfHxlLnB1c2gobC5XKSkpfWgmJm51bGw9PXNmKHRoaXMpJiZlLnB1c2gobmV3IFUoYS5rLGEucGF0aCkpO3JldHVybntLZzplLG1nOmZ9fTtmdW5jdGlvbiB0ZihhKXtyZXR1cm4gUGEocmEoYS55YSksZnVuY3Rpb24oYSl7cmV0dXJuIVMoYS5XLm4pfSl9Zy5mYj1mdW5jdGlvbihhKXt2YXIgYj1udWxsO3IodGhpcy55YSxmdW5jdGlvbihjKXtiPWJ8fGMuZmIoYSl9KTtyZXR1cm4gYn07XG5mdW5jdGlvbiB1ZihhLGIpe2lmKFMoYi5uKSlyZXR1cm4gc2YoYSk7dmFyIGM9Yi52YSgpO3JldHVybiB3KGEueWEsYyl9ZnVuY3Rpb24gc2YoYSl7cmV0dXJuIHZhKGEueWEsZnVuY3Rpb24oYSl7cmV0dXJuIFMoYS5XLm4pfSl8fG51bGx9O2Z1bmN0aW9uIHZmKGEpe3RoaXMudGE9UGQ7dGhpcy5pYj1uZXcgbGY7dGhpcy4kZT17fTt0aGlzLm1jPXt9O3RoaXMuTmM9YX1mdW5jdGlvbiB3ZihhLGIsYyxkLGUpe3ZhciBmPWEuaWIsaD1lO0soZD5mLk1jLFwiU3RhY2tpbmcgYW4gb2xkZXIgd3JpdGUgb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7bihoKXx8KGg9ITApO2YubmEucHVzaCh7cGF0aDpiLEdhOmMsa2Q6ZCx2aXNpYmxlOmh9KTtoJiYoZi5UPWVmKGYuVCxiLGMpKTtmLk1jPWQ7cmV0dXJuIGU/eGYoYSxuZXcgWGIoJGUsYixjKSk6W119ZnVuY3Rpb24geWYoYSxiLGMsZCl7dmFyIGU9YS5pYjtLKGQ+ZS5NYyxcIlN0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzXCIpO2UubmEucHVzaCh7cGF0aDpiLGNoaWxkcmVuOmMsa2Q6ZCx2aXNpYmxlOiEwfSk7ZS5UPWZmKGUuVCxiLGMpO2UuTWM9ZDtjPU9lKGMpO3JldHVybiB4ZihhLG5ldyB6ZSgkZSxiLGMpKX1cbmZ1bmN0aW9uIHpmKGEsYixjKXtjPWN8fCExO3ZhciBkPW1mKGEuaWIsYik7aWYoYS5pYi5SZChiKSl7dmFyIGU9UGQ7bnVsbCE9ZC5HYT9lPWUuc2V0KEcsITApOmliKGQuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtlPWUuc2V0KG5ldyBMKGEpLGIpfSk7cmV0dXJuIHhmKGEsbmV3IFplKGQucGF0aCxlLGMpKX1yZXR1cm5bXX1mdW5jdGlvbiBBZihhLGIsYyl7Yz1PZShjKTtyZXR1cm4geGYoYSxuZXcgemUoYmYsYixjKSl9ZnVuY3Rpb24gQmYoYSxiLGMsZCl7ZD1DZihhLGQpO2lmKG51bGwhPWQpe3ZhciBlPURmKGQpO2Q9ZS5wYXRoO2U9ZS5IYjtiPVQoZCxiKTtjPW5ldyBYYihuZXcgYWYoITEsITAsZSwhMCksYixjKTtyZXR1cm4gRWYoYSxkLGMpfXJldHVybltdfVxuZnVuY3Rpb24gRmYoYSxiLGMsZCl7aWYoZD1DZihhLGQpKXt2YXIgZT1EZihkKTtkPWUucGF0aDtlPWUuSGI7Yj1UKGQsYik7Yz1PZShjKTtjPW5ldyB6ZShuZXcgYWYoITEsITAsZSwhMCksYixjKTtyZXR1cm4gRWYoYSxkLGMpfXJldHVybltdfVxudmYucHJvdG90eXBlLlBiPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLGQ9bnVsbCxlPSExO1ZlKHRoaXMudGEsYyxmdW5jdGlvbihhLGIpe3ZhciBmPVQoYSxjKTtkPWIuZmIoZik7ZT1lfHxudWxsIT1zZihiKTtyZXR1cm4hZH0pO3ZhciBmPXRoaXMudGEuZ2V0KGMpO2Y/KGU9ZXx8bnVsbCE9c2YoZiksZD1kfHxmLmZiKEcpKTooZj1uZXcgcmYsdGhpcy50YT10aGlzLnRhLnNldChjLGYpKTt2YXIgaDtudWxsIT1kP2g9ITA6KGg9ITEsZD1DLFllKHRoaXMudGEuc3VidHJlZShjKSxmdW5jdGlvbihhLGIpe3ZhciBjPWIuZmIoRyk7YyYmKGQ9ZC5VKGEsYykpfSkpO3ZhciBrPW51bGwhPXVmKGYsYSk7aWYoIWsmJiFTKGEubikpe3ZhciBsPUdmKGEpO0soIShsIGluIHRoaXMubWMpLFwiVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWdcIik7dmFyIG09SGYrKzt0aGlzLm1jW2xdPW07dGhpcy4kZVtcIl9cIittXT1sfWg9Zi5QYihhLGIsbmV3IHFmKGMsdGhpcy5pYiksZCxcbmgpO2t8fGV8fChmPXVmKGYsYSksaD1oLmNvbmNhdChJZih0aGlzLGEsZikpKTtyZXR1cm4gaH07XG52Zi5wcm90b3R5cGUuamI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEucGF0aCxlPXRoaXMudGEuZ2V0KGQpLGY9W107aWYoZSYmKFwiZGVmYXVsdFwiPT09YS52YSgpfHxudWxsIT11ZihlLGEpKSl7Zj1lLmpiKGEsYixjKTtlLmUoKSYmKHRoaXMudGE9dGhpcy50YS5yZW1vdmUoZCkpO2U9Zi5LZztmPWYubWc7Yj0tMSE9PVVhKGUsZnVuY3Rpb24oYSl7cmV0dXJuIFMoYS5uKX0pO3ZhciBoPVRlKHRoaXMudGEsZCxmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1zZihiKX0pO2lmKGImJiFoJiYoZD10aGlzLnRhLnN1YnRyZWUoZCksIWQuZSgpKSlmb3IodmFyIGQ9SmYoZCksaz0wO2s8ZC5sZW5ndGg7KytrKXt2YXIgbD1kW2tdLG09bC5XLGw9S2YodGhpcyxsKTt0aGlzLk5jLlhlKExmKG0pLE1mKHRoaXMsbSksbC54ZCxsLkgpfWlmKCFoJiYwPGUubGVuZ3RoJiYhYylpZihiKXRoaXMuTmMuYWUoTGYoYSksbnVsbCk7ZWxzZXt2YXIgdD10aGlzO09hKGUsZnVuY3Rpb24oYSl7YS52YSgpO1xudmFyIGI9dC5tY1tHZihhKV07dC5OYy5hZShMZihhKSxiKX0pfU5mKHRoaXMsZSl9cmV0dXJuIGZ9O3ZmLnByb3RvdHlwZS56YT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuaWIsZD1UZSh0aGlzLnRhLGEsZnVuY3Rpb24oYixjKXt2YXIgZD1UKGIsYSk7aWYoZD1jLmZiKGQpKXJldHVybiBkfSk7cmV0dXJuIGMuemEoYSxkLGIsITApfTtmdW5jdGlvbiBKZihhKXtyZXR1cm4gUmUoYSxmdW5jdGlvbihhLGMsZCl7aWYoYyYmbnVsbCE9c2YoYykpcmV0dXJuW3NmKGMpXTt2YXIgZT1bXTtjJiYoZT10ZihjKSk7cihkLGZ1bmN0aW9uKGEpe2U9ZS5jb25jYXQoYSl9KTtyZXR1cm4gZX0pfWZ1bmN0aW9uIE5mKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDsrK2Mpe3ZhciBkPWJbY107aWYoIVMoZC5uKSl7dmFyIGQ9R2YoZCksZT1hLm1jW2RdO2RlbGV0ZSBhLm1jW2RdO2RlbGV0ZSBhLiRlW1wiX1wiK2VdfX19XG5mdW5jdGlvbiBMZihhKXtyZXR1cm4gUyhhLm4pJiYhZmUoYS5uKT9hLkliKCk6YX1mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9Yi5wYXRoLGU9TWYoYSxiKTtjPUtmKGEsYyk7Yj1hLk5jLlhlKExmKGIpLGUsYy54ZCxjLkgpO2Q9YS50YS5zdWJ0cmVlKGQpO2lmKGUpSyhudWxsPT1zZihkLnZhbHVlKSxcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIik7ZWxzZSBmb3IoZT1SZShkLGZ1bmN0aW9uKGEsYixjKXtpZighYS5lKCkmJmImJm51bGwhPXNmKGIpKXJldHVyblt3ZShzZihiKSldO3ZhciBkPVtdO2ImJihkPWQuY29uY2F0KFFhKHRmKGIpLGZ1bmN0aW9uKGEpe3JldHVybiBhLld9KSkpO3IoYyxmdW5jdGlvbihhKXtkPWQuY29uY2F0KGEpfSk7cmV0dXJuIGR9KSxkPTA7ZDxlLmxlbmd0aDsrK2QpYz1lW2RdLGEuTmMuYWUoTGYoYyksTWYoYSxjKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBLZihhLGIpe3ZhciBjPWIuVyxkPU1mKGEsYyk7cmV0dXJue3hkOmZ1bmN0aW9uKCl7cmV0dXJuKGIudygpfHxDKS5oYXNoKCl9LEg6ZnVuY3Rpb24oYil7aWYoXCJva1wiPT09Yil7aWYoZCl7dmFyIGY9Yy5wYXRoO2lmKGI9Q2YoYSxkKSl7dmFyIGg9RGYoYik7Yj1oLnBhdGg7aD1oLkhiO2Y9VChiLGYpO2Y9bmV3IFpiKG5ldyBhZighMSwhMCxoLCEwKSxmKTtiPUVmKGEsYixmKX1lbHNlIGI9W119ZWxzZSBiPXhmKGEsbmV3IFpiKGJmLGMucGF0aCkpO3JldHVybiBifWY9XCJVbmtub3duIEVycm9yXCI7XCJ0b29fYmlnXCI9PT1iP2Y9XCJUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC5cIjpcInBlcm1pc3Npb25fZGVuaWVkXCI9PWI/Zj1cIkNsaWVudCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIGRlc2lyZWQgZGF0YS5cIjpcInVuYXZhaWxhYmxlXCI9PWImJlxuKGY9XCJUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZVwiKTtmPUVycm9yKGIrXCI6IFwiK2YpO2YuY29kZT1iLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGEuamIoYyxudWxsLGYpfX19ZnVuY3Rpb24gR2YoYSl7cmV0dXJuIGEucGF0aC50b1N0cmluZygpK1wiJFwiK2EudmEoKX1mdW5jdGlvbiBEZihhKXt2YXIgYj1hLmluZGV4T2YoXCIkXCIpO0soLTEhPT1iJiZiPGEubGVuZ3RoLTEsXCJCYWQgcXVlcnlLZXkuXCIpO3JldHVybntIYjphLnN1YnN0cihiKzEpLHBhdGg6bmV3IEwoYS5zdWJzdHIoMCxiKSl9fWZ1bmN0aW9uIENmKGEsYil7dmFyIGM9YS4kZSxkPVwiX1wiK2I7cmV0dXJuIGQgaW4gYz9jW2RdOnZvaWQgMH1mdW5jdGlvbiBNZihhLGIpe3ZhciBjPUdmKGIpO3JldHVybiB3KGEubWMsYyl9dmFyIEhmPTE7XG5mdW5jdGlvbiBFZihhLGIsYyl7dmFyIGQ9YS50YS5nZXQoYik7SyhkLFwiTWlzc2luZyBzeW5jIHBvaW50IGZvciBxdWVyeSB0YWcgdGhhdCB3ZSdyZSB0cmFja2luZ1wiKTtyZXR1cm4gZC5hYihjLG5ldyBxZihiLGEuaWIpLG51bGwpfWZ1bmN0aW9uIHhmKGEsYil7cmV0dXJuIE9mKGEsYixhLnRhLG51bGwsbmV3IHFmKEcsYS5pYikpfWZ1bmN0aW9uIE9mKGEsYixjLGQsZSl7aWYoYi5wYXRoLmUoKSlyZXR1cm4gUGYoYSxiLGMsZCxlKTt2YXIgZj1jLmdldChHKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmZiKEcpKTt2YXIgaD1bXSxrPUUoYi5wYXRoKSxsPWIuWGMoayk7aWYoKGM9Yy5jaGlsZHJlbi5nZXQoaykpJiZsKXZhciBtPWQ/ZC5SKGspOm51bGwsaz1lLnUoayksaD1oLmNvbmNhdChPZihhLGwsYyxtLGspKTtmJiYoaD1oLmNvbmNhdChmLmFiKGIsZSxkKSkpO3JldHVybiBofVxuZnVuY3Rpb24gUGYoYSxiLGMsZCxlKXt2YXIgZj1jLmdldChHKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmZiKEcpKTt2YXIgaD1bXTtjLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGMsZil7dmFyIG09ZD9kLlIoYyk6bnVsbCx0PWUudShjKSx6PWIuWGMoYyk7eiYmKGg9aC5jb25jYXQoUGYoYSx6LGYsbSx0KSkpfSk7ZiYmKGg9aC5jb25jYXQoZi5hYihiLGUsZCkpKTtyZXR1cm4gaH07ZnVuY3Rpb24gUWYoKXt0aGlzLmNoaWxkcmVuPXt9O3RoaXMubmQ9MDt0aGlzLnZhbHVlPW51bGx9ZnVuY3Rpb24gUmYoYSxiLGMpe3RoaXMuR2Q9YT9hOlwiXCI7dGhpcy5aYz1iP2I6bnVsbDt0aGlzLkE9Yz9jOm5ldyBRZn1mdW5jdGlvbiBTZihhLGIpe2Zvcih2YXIgYz1iIGluc3RhbmNlb2YgTD9iOm5ldyBMKGIpLGQ9YSxlO251bGwhPT0oZT1FKGMpKTspZD1uZXcgUmYoZSxkLHcoZC5BLmNoaWxkcmVuLGUpfHxuZXcgUWYpLGM9SChjKTtyZXR1cm4gZH1nPVJmLnByb3RvdHlwZTtnLkNhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQS52YWx1ZX07ZnVuY3Rpb24gVGYoYSxiKXtLKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYixcIkNhbm5vdCBzZXQgdmFsdWUgdG8gdW5kZWZpbmVkXCIpO2EuQS52YWx1ZT1iO1VmKGEpfWcuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLkEudmFsdWU9bnVsbDt0aGlzLkEuY2hpbGRyZW49e307dGhpcy5BLm5kPTA7VWYodGhpcyl9O1xuZy53ZD1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuQS5uZH07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLkNhKCkmJiF0aGlzLndkKCl9O2cuUD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3IodGhpcy5BLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7YShuZXcgUmYoZCxiLGMpKX0pfTtmdW5jdGlvbiBWZihhLGIsYyxkKXtjJiYhZCYmYihhKTthLlAoZnVuY3Rpb24oYSl7VmYoYSxiLCEwLGQpfSk7YyYmZCYmYihhKX1mdW5jdGlvbiBXZihhLGIpe2Zvcih2YXIgYz1hLnBhcmVudCgpO251bGwhPT1jJiYhYihjKTspYz1jLnBhcmVudCgpfWcucGF0aD1mdW5jdGlvbigpe3JldHVybiBuZXcgTChudWxsPT09dGhpcy5aYz90aGlzLkdkOnRoaXMuWmMucGF0aCgpK1wiL1wiK3RoaXMuR2QpfTtnLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5HZH07Zy5wYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5aY307XG5mdW5jdGlvbiBVZihhKXtpZihudWxsIT09YS5aYyl7dmFyIGI9YS5aYyxjPWEuR2QsZD1hLmUoKSxlPXYoYi5BLmNoaWxkcmVuLGMpO2QmJmU/KGRlbGV0ZSBiLkEuY2hpbGRyZW5bY10sYi5BLm5kLS0sVWYoYikpOmR8fGV8fChiLkEuY2hpbGRyZW5bY109YS5BLGIuQS5uZCsrLFVmKGIpKX19O3ZhciBYZj0vW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLyxZZj0vW1xcW1xcXS4jJFxcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLyxaZj0vXlthLXpBLVpdW2EtekEtWi5fXFwtK10rJC87ZnVuY3Rpb24gJGYoYSl7cmV0dXJuIHAoYSkmJjAhPT1hLmxlbmd0aCYmIVhmLnRlc3QoYSl9ZnVuY3Rpb24gYWcoYSl7cmV0dXJuIG51bGw9PT1hfHxwKGEpfHxnYShhKSYmIVFjKGEpfHxpYShhKSYmdihhLFwiLnN2XCIpfWZ1bmN0aW9uIGJnKGEsYixjLGQpe2QmJiFuKGIpfHxjZyh5KGEsMSxkKSxiLGMpfVxuZnVuY3Rpb24gY2coYSxiLGMpe2MgaW5zdGFuY2VvZiBMJiYoYz1uZXcgSmUoYyxhKSk7aWYoIW4oYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIHVuZGVmaW5lZCBcIitMZShjKSk7aWYoaGEoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgZnVuY3Rpb24gXCIrTGUoYykrXCIgd2l0aCBjb250ZW50czogXCIrYi50b1N0cmluZygpKTtpZihRYyhiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgXCIrYi50b1N0cmluZygpK1wiIFwiK0xlKGMpKTtpZihwKGIpJiZiLmxlbmd0aD4xMDQ4NTc2MC8zJiYxMDQ4NTc2MDxaYyhiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYSBzdHJpbmcgZ3JlYXRlciB0aGFuIDEwNDg1NzYwIHV0ZjggYnl0ZXMgXCIrTGUoYykrXCIgKCdcIitiLnN1YnN0cmluZygwLDUwKStcIi4uLicpXCIpO2lmKGlhKGIpKXt2YXIgZD0hMSxlPSExO2liKGIsZnVuY3Rpb24oYixoKXtpZihcIi52YWx1ZVwiPT09YilkPSEwO2Vsc2UgaWYoXCIucHJpb3JpdHlcIiE9PWImJlwiLnN2XCIhPT1iJiYoZT1cbiEwLCEkZihiKSkpdGhyb3cgRXJyb3IoYStcIiBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoXCIrYitcIikgXCIrTGUoYykrJy4gIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtjLnB1c2goYik7Y2coYSxoLGMpO2MucG9wKCl9KTtpZihkJiZlKXRocm93IEVycm9yKGErJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkICcrTGUoYykrXCIgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLlwiKTt9fVxuZnVuY3Rpb24gZGcoYSxiKXt2YXIgYyxkO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspe2Q9YltjXTtmb3IodmFyIGU9ZC5zbGljZSgpLGY9MDtmPGUubGVuZ3RoO2YrKylpZigoXCIucHJpb3JpdHlcIiE9PWVbZl18fGYhPT1lLmxlbmd0aC0xKSYmISRmKGVbZl0pKXRocm93IEVycm9yKGErXCJjb250YWlucyBhbiBpbnZhbGlkIGtleSAoXCIrZVtmXStcIikgaW4gcGF0aCBcIitkLnRvU3RyaW5nKCkrJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO31iLnNvcnQoSWUpO2U9bnVsbDtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKXtkPWJbY107aWYobnVsbCE9PWUmJmUuY29udGFpbnMoZCkpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgcGF0aCBcIitlLnRvU3RyaW5nKCkrXCIgdGhhdCBpcyBhbmNlc3RvciBvZiBhbm90aGVyIHBhdGggXCIrZC50b1N0cmluZygpKTtlPWR9fVxuZnVuY3Rpb24gZWcoYSxiLGMpe3ZhciBkPXkoYSwxLCExKTtpZighaWEoYil8fGVhKGIpKXRocm93IEVycm9yKGQrXCIgbXVzdCBiZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hpbGRyZW4gdG8gcmVwbGFjZS5cIik7dmFyIGU9W107aWIoYixmdW5jdGlvbihhLGIpe3ZhciBrPW5ldyBMKGEpO2NnKGQsYixjLnUoaykpO2lmKFwiLnByaW9yaXR5XCI9PT1MZChrKSYmIWFnKGIpKXRocm93IEVycm9yKGQrXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIray50b1N0cmluZygpK1wiJywgd2hpY2ggbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS5cIik7ZS5wdXNoKGspfSk7ZGcoZCxlKX1cbmZ1bmN0aW9uIGZnKGEsYixjKXtpZihRYyhjKSl0aHJvdyBFcnJvcih5KGEsYiwhMSkrXCJpcyBcIitjLnRvU3RyaW5nKCkrXCIsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTtpZighYWcoYykpdGhyb3cgRXJyb3IoeShhLGIsITEpK1wibXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS5cIik7fVxuZnVuY3Rpb24gZ2coYSxiLGMpe2lmKCFjfHxuKGIpKXN3aXRjaChiKXtjYXNlIFwidmFsdWVcIjpjYXNlIFwiY2hpbGRfYWRkZWRcIjpjYXNlIFwiY2hpbGRfcmVtb3ZlZFwiOmNhc2UgXCJjaGlsZF9jaGFuZ2VkXCI6Y2FzZSBcImNoaWxkX21vdmVkXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KGEsMSxjKSsnbXVzdCBiZSBhIHZhbGlkIGV2ZW50IHR5cGU6IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBcImNoaWxkX3JlbW92ZWRcIiwgXCJjaGlsZF9jaGFuZ2VkXCIsIG9yIFwiY2hpbGRfbW92ZWRcIi4nKTt9fWZ1bmN0aW9uIGhnKGEsYil7aWYobihiKSYmISRmKGIpKXRocm93IEVycm9yKHkoYSwyLCEwKSsnd2FzIGFuIGludmFsaWQga2V5OiBcIicrYisnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiKS4nKTt9XG5mdW5jdGlvbiBpZyhhLGIpe2lmKCFwKGIpfHwwPT09Yi5sZW5ndGh8fFlmLnRlc3QoYikpdGhyb3cgRXJyb3IoeShhLDEsITEpKyd3YXMgYW4gaW52YWxpZCBwYXRoOiBcIicrYisnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCInKTt9ZnVuY3Rpb24gamcoYSxiKXtpZihcIi5pbmZvXCI9PT1FKGIpKXRocm93IEVycm9yKGErXCIgZmFpbGVkOiBDYW4ndCBtb2RpZnkgZGF0YSB1bmRlciAvLmluZm8vXCIpO31mdW5jdGlvbiBrZyhhLGIpe2lmKCFwKGIpKXRocm93IEVycm9yKHkoYSwxLCExKStcIm11c3QgYmUgYSB2YWxpZCBjcmVkZW50aWFsIChhIHN0cmluZykuXCIpO31mdW5jdGlvbiBsZyhhLGIsYyl7aWYoIXAoYykpdGhyb3cgRXJyb3IoeShhLGIsITEpK1wibXVzdCBiZSBhIHZhbGlkIHN0cmluZy5cIik7fVxuZnVuY3Rpb24gbWcoYSxiKXtsZyhhLDEsYik7aWYoIVpmLnRlc3QoYikpdGhyb3cgRXJyb3IoeShhLDEsITEpK1wiJ1wiK2IrXCInIGlzIG5vdCBhIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyLlwiKTt9ZnVuY3Rpb24gbmcoYSxiLGMsZCl7aWYoIWR8fG4oYykpaWYoIWlhKGMpfHxudWxsPT09Yyl0aHJvdyBFcnJvcih5KGEsYixkKStcIm11c3QgYmUgYSB2YWxpZCBvYmplY3QuXCIpO31mdW5jdGlvbiBvZyhhLGIsYyl7aWYoIWlhKGIpfHwhdihiLGMpKXRocm93IEVycm9yKHkoYSwxLCExKSsnbXVzdCBjb250YWluIHRoZSBrZXkgXCInK2MrJ1wiJyk7aWYoIXAodyhiLGMpKSl0aHJvdyBFcnJvcih5KGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIiB3aXRoIHR5cGUgXCJzdHJpbmdcIicpO307ZnVuY3Rpb24gcGcoKXt0aGlzLnNldD17fX1nPXBnLnByb3RvdHlwZTtnLmFkZD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0W2FdPW51bGwhPT1iP2I6ITB9O2cuY29udGFpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIHYodGhpcy5zZXQsYSl9O2cuZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNvbnRhaW5zKGEpP3RoaXMuc2V0W2FdOnZvaWQgMH07Zy5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuc2V0W2FdfTtnLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5zZXQ9e319O2cuZT1mdW5jdGlvbigpe3JldHVybiB3YSh0aGlzLnNldCl9O2cuY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gcGEodGhpcy5zZXQpfTtmdW5jdGlvbiBxZyhhLGIpe3IoYS5zZXQsZnVuY3Rpb24oYSxkKXtiKGQsYSl9KX1nLmtleXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyKHRoaXMuc2V0LGZ1bmN0aW9uKGIsYyl7YS5wdXNoKGMpfSk7cmV0dXJuIGF9O2Z1bmN0aW9uIHFjKCl7dGhpcy5tPXRoaXMuQj1udWxsfXFjLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuQilyZXR1cm4gdGhpcy5CLlEoYSk7aWYoYS5lKCl8fG51bGw9PXRoaXMubSlyZXR1cm4gbnVsbDt2YXIgYj1FKGEpO2E9SChhKTtyZXR1cm4gdGhpcy5tLmNvbnRhaW5zKGIpP3RoaXMubS5nZXQoYikuZmluZChhKTpudWxsfTtxYy5wcm90b3R5cGUubmM9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSl0aGlzLkI9Yix0aGlzLm09bnVsbDtlbHNlIGlmKG51bGwhPT10aGlzLkIpdGhpcy5CPXRoaXMuQi5HKGEsYik7ZWxzZXtudWxsPT10aGlzLm0mJih0aGlzLm09bmV3IHBnKTt2YXIgYz1FKGEpO3RoaXMubS5jb250YWlucyhjKXx8dGhpcy5tLmFkZChjLG5ldyBxYyk7Yz10aGlzLm0uZ2V0KGMpO2E9SChhKTtjLm5jKGEsYil9fTtcbmZ1bmN0aW9uIHJnKGEsYil7aWYoYi5lKCkpcmV0dXJuIGEuQj1udWxsLGEubT1udWxsLCEwO2lmKG51bGwhPT1hLkIpe2lmKGEuQi5LKCkpcmV0dXJuITE7dmFyIGM9YS5CO2EuQj1udWxsO2MuUChOLGZ1bmN0aW9uKGIsYyl7YS5uYyhuZXcgTChiKSxjKX0pO3JldHVybiByZyhhLGIpfXJldHVybiBudWxsIT09YS5tPyhjPUUoYiksYj1IKGIpLGEubS5jb250YWlucyhjKSYmcmcoYS5tLmdldChjKSxiKSYmYS5tLnJlbW92ZShjKSxhLm0uZSgpPyhhLm09bnVsbCwhMCk6ITEpOiEwfWZ1bmN0aW9uIHJjKGEsYixjKXtudWxsIT09YS5CP2MoYixhLkIpOmEuUChmdW5jdGlvbihhLGUpe3ZhciBmPW5ldyBMKGIudG9TdHJpbmcoKStcIi9cIithKTtyYyhlLGYsYyl9KX1xYy5wcm90b3R5cGUuUD1mdW5jdGlvbihhKXtudWxsIT09dGhpcy5tJiZxZyh0aGlzLm0sZnVuY3Rpb24oYixjKXthKGIsYyl9KX07dmFyIHNnPVwiYXV0aC5maXJlYmFzZS5jb21cIjtmdW5jdGlvbiB0ZyhhLGIsYyl7dGhpcy5vZD1hfHx7fTt0aGlzLmVlPWJ8fHt9O3RoaXMuJGE9Y3x8e307dGhpcy5vZC5yZW1lbWJlcnx8KHRoaXMub2QucmVtZW1iZXI9XCJkZWZhdWx0XCIpfXZhciB1Zz1bXCJyZW1lbWJlclwiLFwicmVkaXJlY3RUb1wiXTtmdW5jdGlvbiB2ZyhhKXt2YXIgYj17fSxjPXt9O2liKGF8fHt9LGZ1bmN0aW9uKGEsZSl7MDw9TmEodWcsYSk/YlthXT1lOmNbYV09ZX0pO3JldHVybiBuZXcgdGcoYix7fSxjKX07ZnVuY3Rpb24gd2coYSxiKXt0aGlzLlFlPVtcInNlc3Npb25cIixhLk9kLGEuaGNdLmpvaW4oXCI6XCIpO3RoaXMuYmU9Yn13Zy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7aWYoIWIpaWYodGhpcy5iZS5sZW5ndGgpYj10aGlzLmJlWzBdO2Vsc2UgdGhyb3cgRXJyb3IoXCJmYi5sb2dpbi5TZXNzaW9uTWFuYWdlciA6IE5vIHN0b3JhZ2Ugb3B0aW9ucyBhdmFpbGFibGUhXCIpO2Iuc2V0KHRoaXMuUWUsYSl9O3dnLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt2YXIgYT1RYSh0aGlzLmJlLHEodGhpcy5xZyx0aGlzKSksYT1QYShhLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09YX0pO1hhKGEsZnVuY3Rpb24oYSxjKXtyZXR1cm4gYWQoYy50b2tlbiktYWQoYS50b2tlbil9KTtyZXR1cm4gMDxhLmxlbmd0aD9hLnNoaWZ0KCk6bnVsbH07d2cucHJvdG90eXBlLnFnPWZ1bmN0aW9uKGEpe3RyeXt2YXIgYj1hLmdldCh0aGlzLlFlKTtpZihiJiZiLnRva2VuKXJldHVybiBifWNhdGNoKGMpe31yZXR1cm4gbnVsbH07XG53Zy5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO09hKHRoaXMuYmUsZnVuY3Rpb24oYil7Yi5yZW1vdmUoYS5RZSl9KX07ZnVuY3Rpb24geGcoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmXCJzdHJpbmdcIj09PXR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50P25hdmlnYXRvci51c2VyQWdlbnQ6XCJcIn1mdW5jdGlvbiB5Zygpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiYhISh3aW5kb3cuY29yZG92YXx8d2luZG93LnBob25lZ2FwfHx3aW5kb3cuUGhvbmVHYXApJiYvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdCh4ZygpKX1mdW5jdGlvbiB6Zygpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJi9eZmlsZTpcXC8vLnRlc3QobG9jYXRpb24uaHJlZil9XG5mdW5jdGlvbiBBZyhhKXt2YXIgYj14ZygpO2lmKFwiXCI9PT1iKXJldHVybiExO2lmKFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCI9PT1uYXZpZ2F0b3IuYXBwTmFtZSl7aWYoKGI9Yi5tYXRjaCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pKSYmMTxiLmxlbmd0aClyZXR1cm4gcGFyc2VGbG9hdChiWzFdKT49YX1lbHNlIGlmKC0xPGIuaW5kZXhPZihcIlRyaWRlbnRcIikmJihiPWIubWF0Y2goL3J2OihbMC05XXsyLDJ9W1xcLjAtOV17MCx9KS8pKSYmMTxiLmxlbmd0aClyZXR1cm4gcGFyc2VGbG9hdChiWzFdKT49YTtyZXR1cm4hMX07ZnVuY3Rpb24gQmcoKXt2YXIgYT13aW5kb3cub3BlbmVyLmZyYW1lcyxiO2ZvcihiPWEubGVuZ3RoLTE7MDw9YjtiLS0pdHJ5e2lmKGFbYl0ubG9jYXRpb24ucHJvdG9jb2w9PT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wmJmFbYl0ubG9jYXRpb24uaG9zdD09PXdpbmRvdy5sb2NhdGlvbi5ob3N0JiZcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiPT09YVtiXS5uYW1lKXJldHVybiBhW2JdfWNhdGNoKGMpe31yZXR1cm4gbnVsbH1mdW5jdGlvbiBDZyhhLGIsYyl7YS5hdHRhY2hFdmVudD9hLmF0dGFjaEV2ZW50KFwib25cIitiLGMpOmEuYWRkRXZlbnRMaXN0ZW5lciYmYS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9ZnVuY3Rpb24gRGcoYSxiLGMpe2EuZGV0YWNoRXZlbnQ/YS5kZXRhY2hFdmVudChcIm9uXCIrYixjKTphLnJlbW92ZUV2ZW50TGlzdGVuZXImJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpfVxuZnVuY3Rpb24gRWcoYSl7L15odHRwcz86XFwvXFwvLy50ZXN0KGEpfHwoYT13aW5kb3cubG9jYXRpb24uaHJlZik7dmFyIGI9L14oaHR0cHM/OlxcL1xcL1tcXC1fYS16QS1aXFwuMC05Ol0rKS8uZXhlYyhhKTtyZXR1cm4gYj9iWzFdOmF9ZnVuY3Rpb24gRmcoYSl7dmFyIGI9XCJcIjt0cnl7YT1hLnJlcGxhY2UoXCIjXCIsXCJcIik7dmFyIGM9bGIoYSk7YyYmdihjLFwiX19maXJlYmFzZV9yZXF1ZXN0X2tleVwiKSYmKGI9dyhjLFwiX19maXJlYmFzZV9yZXF1ZXN0X2tleVwiKSl9Y2F0Y2goZCl7fXJldHVybiBifWZ1bmN0aW9uIEdnKCl7dmFyIGE9UGMoc2cpO3JldHVybiBhLnNjaGVtZStcIjovL1wiK2EuaG9zdCtcIi92MlwifWZ1bmN0aW9uIEhnKGEpe3JldHVybiBHZygpK1wiL1wiK2ErXCIvYXV0aC9jaGFubmVsXCJ9O2Z1bmN0aW9uIElnKGEpe3ZhciBiPXRoaXM7dGhpcy5BYz1hO3RoaXMuY2U9XCIqXCI7QWcoOCk/dGhpcy5SYz10aGlzLnpkPUJnKCk6KHRoaXMuUmM9d2luZG93Lm9wZW5lcix0aGlzLnpkPXdpbmRvdyk7aWYoIWIuUmMpdGhyb3dcIlVuYWJsZSB0byBmaW5kIHJlbGF5IGZyYW1lXCI7Q2codGhpcy56ZCxcIm1lc3NhZ2VcIixxKHRoaXMuamMsdGhpcykpO0NnKHRoaXMuemQsXCJtZXNzYWdlXCIscSh0aGlzLkJmLHRoaXMpKTt0cnl7SmcodGhpcyx7YTpcInJlYWR5XCJ9KX1jYXRjaChjKXtDZyh0aGlzLlJjLFwibG9hZFwiLGZ1bmN0aW9uKCl7SmcoYix7YTpcInJlYWR5XCJ9KX0pfUNnKHdpbmRvdyxcInVubG9hZFwiLHEodGhpcy5CZyx0aGlzKSl9ZnVuY3Rpb24gSmcoYSxiKXtiPUIoYik7QWcoOCk/YS5SYy5kb1Bvc3QoYixhLmNlKTphLlJjLnBvc3RNZXNzYWdlKGIsYS5jZSl9XG5JZy5wcm90b3R5cGUuamM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjO3RyeXtjPW5iKGEuZGF0YSl9Y2F0Y2goZCl7fWMmJlwicmVxdWVzdFwiPT09Yy5hJiYoRGcod2luZG93LFwibWVzc2FnZVwiLHRoaXMuamMpLHRoaXMuY2U9YS5vcmlnaW4sdGhpcy5BYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2IuQWMoYi5jZSxjLmQsZnVuY3Rpb24oYSxjKXtiLmRnPSFjO2IuQWM9dm9pZCAwO0pnKGIse2E6XCJyZXNwb25zZVwiLGQ6YSxmb3JjZUtlZXBXaW5kb3dPcGVuOmN9KX0pfSwwKSl9O0lnLnByb3RvdHlwZS5CZz1mdW5jdGlvbigpe3RyeXtEZyh0aGlzLnpkLFwibWVzc2FnZVwiLHRoaXMuQmYpfWNhdGNoKGEpe310aGlzLkFjJiYoSmcodGhpcyx7YTpcImVycm9yXCIsZDpcInVua25vd24gY2xvc2VkIHdpbmRvd1wifSksdGhpcy5BYz12b2lkIDApO3RyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtJZy5wcm90b3R5cGUuQmY9ZnVuY3Rpb24oYSl7aWYodGhpcy5kZyYmXCJkaWVcIj09PWEuZGF0YSl0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07ZnVuY3Rpb24gS2coYSl7dGhpcy5wYz1HYSgpK0dhKCkrR2EoKTt0aGlzLkVmPWF9S2cucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt5Yy5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5wYyk7eWMuc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMucGMpO2IucmVxdWVzdElkPXRoaXMucGM7Yi5yZWRpcmVjdFRvPWIucmVkaXJlY3RUb3x8d2luZG93LmxvY2F0aW9uLmhyZWY7YSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikra2IoYik7d2luZG93LmxvY2F0aW9uPWF9O0tnLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIXpnKCkmJiF5ZygpfTtLZy5wcm90b3R5cGUuQ2M9ZnVuY3Rpb24oKXtyZXR1cm5cInJlZGlyZWN0XCJ9O3ZhciBMZz17TkVUV09SS19FUlJPUjpcIlVuYWJsZSB0byBjb250YWN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXIuXCIsU0VSVkVSX0VSUk9SOlwiQW4gdW5rbm93biBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuXCIsVFJBTlNQT1JUX1VOQVZBSUxBQkxFOlwiVGhlcmUgYXJlIG5vIGxvZ2luIHRyYW5zcG9ydHMgYXZhaWxhYmxlIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZC5cIixSRVFVRVNUX0lOVEVSUlVQVEVEOlwiVGhlIGJyb3dzZXIgcmVkaXJlY3RlZCB0aGUgcGFnZSBiZWZvcmUgdGhlIGxvZ2luIHJlcXVlc3QgY291bGQgY29tcGxldGUuXCIsVVNFUl9DQU5DRUxMRUQ6XCJUaGUgdXNlciBjYW5jZWxsZWQgYXV0aGVudGljYXRpb24uXCJ9O2Z1bmN0aW9uIE1nKGEpe3ZhciBiPUVycm9yKHcoTGcsYSksYSk7Yi5jb2RlPWE7cmV0dXJuIGJ9O2Z1bmN0aW9uIE5nKGEpe3ZhciBiOyhiPSFhLndpbmRvd19mZWF0dXJlcyl8fChiPXhnKCksYj0tMSE9PWIuaW5kZXhPZihcIkZlbm5lYy9cIil8fC0xIT09Yi5pbmRleE9mKFwiRmlyZWZveC9cIikmJi0xIT09Yi5pbmRleE9mKFwiQW5kcm9pZFwiKSk7YiYmKGEud2luZG93X2ZlYXR1cmVzPXZvaWQgMCk7YS53aW5kb3dfbmFtZXx8KGEud2luZG93X25hbWU9XCJfYmxhbmtcIik7dGhpcy5vcHRpb25zPWF9XG5OZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtoJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChoKSxoPXZvaWQgMCk7dCYmKHQ9Y2xlYXJJbnRlcnZhbCh0KSk7RGcod2luZG93LFwibWVzc2FnZVwiLGUpO0RnKHdpbmRvdyxcInVubG9hZFwiLGQpO2lmKG0mJiFhKXRyeXttLmNsb3NlKCl9Y2F0Y2goYil7ay5wb3N0TWVzc2FnZShcImRpZVwiLGwpfW09az12b2lkIDB9ZnVuY3Rpb24gZShhKXtpZihhLm9yaWdpbj09PWwpdHJ5e3ZhciBiPW5iKGEuZGF0YSk7XCJyZWFkeVwiPT09Yi5hP2sucG9zdE1lc3NhZ2UoeixsKTpcImVycm9yXCI9PT1iLmE/KGQoITEpLGMmJihjKGIuZCksYz1udWxsKSk6XCJyZXNwb25zZVwiPT09Yi5hJiYoZChiLmZvcmNlS2VlcFdpbmRvd09wZW4pLGMmJihjKG51bGwsYi5kKSxjPW51bGwpKX1jYXRjaChlKXt9fXZhciBmPUFnKDgpLGgsaztpZighdGhpcy5vcHRpb25zLnJlbGF5X3VybClyZXR1cm4gYyhFcnJvcihcImludmFsaWQgYXJndW1lbnRzOiBvcmlnaW4gb2YgdXJsIGFuZCByZWxheV91cmwgbXVzdCBtYXRjaFwiKSk7XG52YXIgbD1FZyhhKTtpZihsIT09RWcodGhpcy5vcHRpb25zLnJlbGF5X3VybCkpYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2MoRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50czogb3JpZ2luIG9mIHVybCBhbmQgcmVsYXlfdXJsIG11c3QgbWF0Y2hcIikpfSwwKTtlbHNle2YmJihoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIiksaC5zZXRBdHRyaWJ1dGUoXCJzcmNcIix0aGlzLm9wdGlvbnMucmVsYXlfdXJsKSxoLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsaC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJfX3dpbmNoYW5fcmVsYXlfZnJhbWVcIiksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoKSxrPWguY29udGVudFdpbmRvdyk7YSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikra2IoYik7dmFyIG09d2luZG93Lm9wZW4oYSx0aGlzLm9wdGlvbnMud2luZG93X25hbWUsdGhpcy5vcHRpb25zLndpbmRvd19mZWF0dXJlcyk7a3x8KGs9bSk7dmFyIHQ9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXttJiZtLmNsb3NlZCYmXG4oZCghMSksYyYmKGMoTWcoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKSl9LDUwMCksej1CKHthOlwicmVxdWVzdFwiLGQ6Yn0pO0NnKHdpbmRvdyxcInVubG9hZFwiLGQpO0NnKHdpbmRvdyxcIm1lc3NhZ2VcIixlKX19O1xuTmcuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXt2YXIgYTtpZihhPVwicG9zdE1lc3NhZ2VcImluIHdpbmRvdyYmIXpnKCkpKGE9eWcoKXx8XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJighIXhnKCkubWF0Y2goL1dpbmRvd3MgUGhvbmUvKXx8ISF3aW5kb3cuV2luZG93cyYmL15tcy1hcHB4Oi8udGVzdChsb2NhdGlvbi5ocmVmKSkpfHwoYT14ZygpLGE9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiYhIShhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kpfHxhLm1hdGNoKC9DcmlPUy8pfHxhLm1hdGNoKC9Ud2l0dGVyIGZvciBpUGhvbmUvKXx8YS5tYXRjaCgvRkJBTlxcL0ZCSU9TLyl8fHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpLGE9IWE7cmV0dXJuIGEmJiF4ZygpLm1hdGNoKC9QaGFudG9tSlMvKX07TmcucHJvdG90eXBlLkNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJwb3B1cFwifTtmdW5jdGlvbiBPZyhhKXthLm1ldGhvZHx8KGEubWV0aG9kPVwiR0VUXCIpO2EuaGVhZGVyc3x8KGEuaGVhZGVycz17fSk7YS5oZWFkZXJzLmNvbnRlbnRfdHlwZXx8KGEuaGVhZGVycy5jb250ZW50X3R5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCIpO2EuaGVhZGVycy5jb250ZW50X3R5cGU9YS5oZWFkZXJzLmNvbnRlbnRfdHlwZS50b0xvd2VyQ2FzZSgpO3RoaXMub3B0aW9ucz1hfVxuT2cucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhNZyhcIlJFUVVFU1RfSU5URVJSVVBURURcIikpLGM9bnVsbCl9dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0LGY9dGhpcy5vcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpLGg7Q2cod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihjJiY0PT09ZS5yZWFkeVN0YXRlKXt2YXIgYTtpZigyMDA8PWUuc3RhdHVzJiYzMDA+ZS5zdGF0dXMpe3RyeXthPW5iKGUucmVzcG9uc2VUZXh0KX1jYXRjaChiKXt9YyhudWxsLGEpfWVsc2UgNTAwPD1lLnN0YXR1cyYmNjAwPmUuc3RhdHVzP2MoTWcoXCJTRVJWRVJfRVJST1JcIikpOmMoTWcoXCJORVRXT1JLX0VSUk9SXCIpKTtjPW51bGw7RGcod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9fTtpZihcIkdFVFwiPT09ZilhKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKStrYihiKSxoPW51bGw7ZWxzZXt2YXIgaz10aGlzLm9wdGlvbnMuaGVhZGVycy5jb250ZW50X3R5cGU7XG5cImFwcGxpY2F0aW9uL2pzb25cIj09PWsmJihoPUIoYikpO1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI9PT1rJiYoaD1rYihiKSl9ZS5vcGVuKGYsYSwhMCk7YT17XCJYLVJlcXVlc3RlZC1XaXRoXCI6XCJYTUxIdHRwUmVxdWVzdFwiLEFjY2VwdDpcImFwcGxpY2F0aW9uL2pzb247dGV4dC9wbGFpblwifTt6YShhLHRoaXMub3B0aW9ucy5oZWFkZXJzKTtmb3IodmFyIGwgaW4gYSllLnNldFJlcXVlc3RIZWFkZXIobCxhW2xdKTtlLnNlbmQoaCl9O09nLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7dmFyIGE7aWYoYT0hIXdpbmRvdy5YTUxIdHRwUmVxdWVzdClhPXhnKCksYT0hKGEubWF0Y2goL01TSUUvKXx8YS5tYXRjaCgvVHJpZGVudC8pKXx8QWcoMTApO3JldHVybiBhfTtPZy5wcm90b3R5cGUuQ2M9ZnVuY3Rpb24oKXtyZXR1cm5cImpzb25cIn07ZnVuY3Rpb24gUGcoYSl7dGhpcy5wYz1HYSgpK0dhKCkrR2EoKTt0aGlzLkVmPWF9XG5QZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKE1nKFwiVVNFUl9DQU5DRUxMRURcIikpLGM9bnVsbCl9dmFyIGU9dGhpcyxmPVBjKHNnKSxoO2IucmVxdWVzdElkPXRoaXMucGM7Yi5yZWRpcmVjdFRvPWYuc2NoZW1lK1wiOi8vXCIrZi5ob3N0K1wiL2JsYW5rL3BhZ2UuaHRtbFwiO2ErPS9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIjthKz1rYihiKTsoaD13aW5kb3cub3BlbihhLFwiX2JsYW5rXCIsXCJsb2NhdGlvbj1ub1wiKSkmJmhhKGguYWRkRXZlbnRMaXN0ZW5lcik/KGguYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLGZ1bmN0aW9uKGEpe3ZhciBiO2lmKGI9YSYmYS51cmwpYTp7dHJ5e3ZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO20uaHJlZj1hLnVybDtiPW0uaG9zdD09PWYuaG9zdCYmXCIvYmxhbmsvcGFnZS5odG1sXCI9PT1tLnBhdGhuYW1lO2JyZWFrIGF9Y2F0Y2godCl7fWI9ITF9YiYmKGE9RmcoYS51cmwpLGgucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImV4aXRcIixcbmQpLGguY2xvc2UoKSxhPW5ldyB0ZyhudWxsLG51bGwse3JlcXVlc3RJZDplLnBjLHJlcXVlc3RLZXk6YX0pLGUuRWYucmVxdWVzdFdpdGhDcmVkZW50aWFsKFwiL2F1dGgvc2Vzc2lvblwiLGEsYyksYz1udWxsKX0pLGguYWRkRXZlbnRMaXN0ZW5lcihcImV4aXRcIixkKSk6YyhNZyhcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9O1BnLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHlnKCl9O1BnLnByb3RvdHlwZS5DYz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gUWcoYSl7YS5jYWxsYmFja19wYXJhbWV0ZXJ8fChhLmNhbGxiYWNrX3BhcmFtZXRlcj1cImNhbGxiYWNrXCIpO3RoaXMub3B0aW9ucz1hO3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnA9d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucHx8e319XG5RZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKE1nKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX1mdW5jdGlvbiBlKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09dm9pZCAwO3dhKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnApJiYod2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD12b2lkIDApO3RyeXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKTthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9Y2F0Y2goYil7fX0sMSk7RGcod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9dmFyIGY9XCJmblwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK01hdGguZmxvb3IoOTk5OTkqTWF0aC5yYW5kb20oKSk7Ylt0aGlzLm9wdGlvbnMuY2FsbGJhY2tfcGFyYW1ldGVyXT1cIl9fZmlyZWJhc2VfYXV0aF9qc29ucC5cIitmO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK2tiKGIpO1xuQ2cod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucFtmXT1mdW5jdGlvbihhKXtjJiYoYyhudWxsLGEpLGM9bnVsbCk7ZSgpfTtSZyhmLGEsYyl9O1xuZnVuY3Rpb24gUmcoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmlkPWE7ZC5hc3luYz0hMDtkLnNyYz1iO2Qub25lcnJvcj1mdW5jdGlvbigpe3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO251bGwhPT1iJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7YyYmYyhNZyhcIk5FVFdPUktfRVJST1JcIikpfTt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIik7KGUmJjAhPWUubGVuZ3RoP2VbMF06ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChkKX1jYXRjaChmKXtjJiZjKE1nKFwiTkVUV09SS19FUlJPUlwiKSl9fSwwKX1RZy5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQmJm51bGwhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnR9O1xuUWcucHJvdG90eXBlLkNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJqc29uXCJ9O2Z1bmN0aW9uIFNnKGEsYixjLGQpe0RlLmNhbGwodGhpcyxbXCJhdXRoX3N0YXR1c1wiXSk7dGhpcy5GPWE7dGhpcy5kZj1iO3RoaXMuVmc9Yzt0aGlzLkxlPWQ7dGhpcy5zYz1uZXcgd2coYSxbeGMseWNdKTt0aGlzLm1iPW51bGw7dGhpcy5TZT0hMTtUZyh0aGlzKX1tYShTZyxEZSk7Zz1TZy5wcm90b3R5cGU7Zy54ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1ifHxudWxsfTtmdW5jdGlvbiBUZyhhKXt5Yy5nZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpJiZVZyhhKTt2YXIgYj1hLnNjLmdldCgpO2ImJmIudG9rZW4/KFZnKGEsYiksYS5kZihiLnRva2VuLGZ1bmN0aW9uKGMsZCl7V2coYSxjLGQsITEsYi50b2tlbixiKX0sZnVuY3Rpb24oYixkKXtYZyhhLFwicmVzdW1lU2Vzc2lvbigpXCIsYixkKX0pKTpWZyhhLG51bGwpfVxuZnVuY3Rpb24gWWcoYSxiLGMsZCxlLGYpe1wiZmlyZWJhc2Vpby1kZW1vLmNvbVwiPT09YS5GLmRvbWFpbiYmTyhcIkZpcmViYXNlIGF1dGhlbnRpY2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gZGVtbyBGaXJlYmFzZXMgKCouZmlyZWJhc2Vpby1kZW1vLmNvbSkuIFRvIHNlY3VyZSB5b3VyIEZpcmViYXNlLCBjcmVhdGUgYSBwcm9kdWN0aW9uIEZpcmViYXNlIGF0IGh0dHBzOi8vd3d3LmZpcmViYXNlLmNvbS5cIik7YS5kZihiLGZ1bmN0aW9uKGYsayl7V2coYSxmLGssITAsYixjLGR8fHt9LGUpfSxmdW5jdGlvbihiLGMpe1hnKGEsXCJhdXRoKClcIixiLGMsZil9KX1mdW5jdGlvbiBaZyhhLGIpe2Euc2MuY2xlYXIoKTtWZyhhLG51bGwpO2EuVmcoZnVuY3Rpb24oYSxkKXtpZihcIm9rXCI9PT1hKVAoYixudWxsKTtlbHNle3ZhciBlPShhfHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksZj1lO2QmJihmKz1cIjogXCIrZCk7Zj1FcnJvcihmKTtmLmNvZGU9ZTtQKGIsZil9fSl9XG5mdW5jdGlvbiBXZyhhLGIsYyxkLGUsZixoLGspe1wib2tcIj09PWI/KGQmJihiPWMuYXV0aCxmLmF1dGg9YixmLmV4cGlyZXM9Yy5leHBpcmVzLGYudG9rZW49YmQoZSk/ZTpcIlwiLGM9bnVsbCxiJiZ2KGIsXCJ1aWRcIik/Yz13KGIsXCJ1aWRcIik6dihmLFwidWlkXCIpJiYoYz13KGYsXCJ1aWRcIikpLGYudWlkPWMsYz1cImN1c3RvbVwiLGImJnYoYixcInByb3ZpZGVyXCIpP2M9dyhiLFwicHJvdmlkZXJcIik6dihmLFwicHJvdmlkZXJcIikmJihjPXcoZixcInByb3ZpZGVyXCIpKSxmLnByb3ZpZGVyPWMsYS5zYy5jbGVhcigpLGJkKGUpJiYoaD1ofHx7fSxjPXhjLFwic2Vzc2lvbk9ubHlcIj09PWgucmVtZW1iZXImJihjPXljKSxcIm5vbmVcIiE9PWgucmVtZW1iZXImJmEuc2Muc2V0KGYsYykpLFZnKGEsZikpLFAoayxudWxsLGYpKTooYS5zYy5jbGVhcigpLFZnKGEsbnVsbCksZj1hPShifHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksYyYmKGYrPVwiOiBcIitjKSxmPUVycm9yKGYpLGYuY29kZT1hLFAoayxmKSl9XG5mdW5jdGlvbiBYZyhhLGIsYyxkLGUpe08oYitcIiB3YXMgY2FuY2VsZWQ6IFwiK2QpO2Euc2MuY2xlYXIoKTtWZyhhLG51bGwpO2E9RXJyb3IoZCk7YS5jb2RlPWMudG9VcHBlckNhc2UoKTtQKGUsYSl9ZnVuY3Rpb24gJGcoYSxiLGMsZCxlKXthaChhKTtjPW5ldyB0ZyhkfHx7fSx7fSxjfHx7fSk7YmgoYSxbT2csUWddLFwiL2F1dGgvXCIrYixjLGUpfVxuZnVuY3Rpb24gY2goYSxiLGMsZCl7YWgoYSk7dmFyIGU9W05nLFBnXTtjPXZnKGMpO1wiYW5vbnltb3VzXCI9PT1ifHxcInBhc3N3b3JkXCI9PT1iP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtQKGQsTWcoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYy5lZS53aW5kb3dfZmVhdHVyZXM9XCJtZW51YmFyPXllcyxtb2RhbD15ZXMsYWx3YXlzUmFpc2VkPXllc2xvY2F0aW9uPXllcyxyZXNpemFibGU9eWVzLHNjcm9sbGJhcnM9eWVzLHN0YXR1cz15ZXMsaGVpZ2h0PTYyNSx3aWR0aD02MjUsdG9wPVwiKyhcIm9iamVjdFwiPT09dHlwZW9mIHNjcmVlbj8uNSooc2NyZWVuLmhlaWdodC02MjUpOjApK1wiLGxlZnQ9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4ud2lkdGgtNjI1KTowKSxjLmVlLnJlbGF5X3VybD1IZyhhLkYuaGMpLGMuZWUucmVxdWVzdFdpdGhDcmVkZW50aWFsPXEoYS5xYyxhKSxiaChhLGUsXCIvYXV0aC9cIitiLGMsZCkpfVxuZnVuY3Rpb24gVWcoYSl7dmFyIGI9eWMuZ2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiKTtpZihiKXt2YXIgYz15Yy5nZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTt5Yy5yZW1vdmUoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO3ljLnJlbW92ZShcInJlZGlyZWN0X2NsaWVudF9vcHRpb25zXCIpO3ZhciBkPVtPZyxRZ10sYj17cmVxdWVzdElkOmIscmVxdWVzdEtleTpGZyhkb2N1bWVudC5sb2NhdGlvbi5oYXNoKX0sYz1uZXcgdGcoYyx7fSxiKTthLlNlPSEwO3RyeXtkb2N1bWVudC5sb2NhdGlvbi5oYXNoPWRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgvJl9fZmlyZWJhc2VfcmVxdWVzdF9rZXk9KFthLXpBLXowLTldKikvLFwiXCIpfWNhdGNoKGUpe31iaChhLGQsXCIvYXV0aC9zZXNzaW9uXCIsYyxmdW5jdGlvbigpe3RoaXMuU2U9ITF9LmJpbmQoYSkpfX1cbmcuc2U9ZnVuY3Rpb24oYSxiKXthaCh0aGlzKTt2YXIgYz12ZyhhKTtjLiRhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5xYyhcIi91c2Vyc1wiLGMsZnVuY3Rpb24oYSxjKXthP1AoYixhKTpQKGIsYSxjKX0pfTtnLlRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczthaCh0aGlzKTt2YXIgZD1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCksZT12ZyhhKTtlLiRhLl9tZXRob2Q9XCJERUxFVEVcIjt0aGlzLnFjKGQsZSxmdW5jdGlvbihhLGQpeyFhJiZkJiZkLnVpZCYmYy5tYiYmYy5tYi51aWQmJmMubWIudWlkPT09ZC51aWQmJlpnKGMpO1AoYixhKX0pfTtnLnBlPWZ1bmN0aW9uKGEsYil7YWgodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpK1wiL3Bhc3N3b3JkXCIsZD12ZyhhKTtkLiRhLl9tZXRob2Q9XCJQVVRcIjtkLiRhLnBhc3N3b3JkPWEubmV3UGFzc3dvcmQ7dGhpcy5xYyhjLGQsZnVuY3Rpb24oYSl7UChiLGEpfSl9O1xuZy5vZT1mdW5jdGlvbihhLGIpe2FoKHRoaXMpO3ZhciBjPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLm9sZEVtYWlsKStcIi9lbWFpbFwiLGQ9dmcoYSk7ZC4kYS5fbWV0aG9kPVwiUFVUXCI7ZC4kYS5lbWFpbD1hLm5ld0VtYWlsO2QuJGEucGFzc3dvcmQ9YS5wYXNzd29yZDt0aGlzLnFjKGMsZCxmdW5jdGlvbihhKXtQKGIsYSl9KX07Zy5WZT1mdW5jdGlvbihhLGIpe2FoKHRoaXMpO3ZhciBjPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKStcIi9wYXNzd29yZFwiLGQ9dmcoYSk7ZC4kYS5fbWV0aG9kPVwiUE9TVFwiO3RoaXMucWMoYyxkLGZ1bmN0aW9uKGEpe1AoYixhKX0pfTtnLnFjPWZ1bmN0aW9uKGEsYixjKXtkaCh0aGlzLFtPZyxRZ10sYSxiLGMpfTtcbmZ1bmN0aW9uIGJoKGEsYixjLGQsZSl7ZGgoYSxiLGMsZCxmdW5jdGlvbihiLGMpeyFiJiZjJiZjLnRva2VuJiZjLnVpZD9ZZyhhLGMudG9rZW4sYyxkLm9kLGZ1bmN0aW9uKGEsYil7YT9QKGUsYSk6UChlLG51bGwsYil9KTpQKGUsYnx8TWcoXCJVTktOT1dOX0VSUk9SXCIpKX0pfVxuZnVuY3Rpb24gZGgoYSxiLGMsZCxlKXtiPVBhKGIsZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuaXNBdmFpbGFibGUmJmEuaXNBdmFpbGFibGUoKX0pOzA9PT1iLmxlbmd0aD9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7UChlLE1nKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX0sMCk6KGI9bmV3IChiLnNoaWZ0KCkpKGQuZWUpLGQ9amIoZC4kYSksZC52PVwianMtXCIraGIsZC50cmFuc3BvcnQ9Yi5DYygpLGQuc3VwcHJlc3Nfc3RhdHVzX2NvZGVzPSEwLGE9R2coKStcIi9cIithLkYuaGMrYyxiLm9wZW4oYSxkLGZ1bmN0aW9uKGEsYil7aWYoYSlQKGUsYSk7ZWxzZSBpZihiJiZiLmVycm9yKXt2YXIgYz1FcnJvcihiLmVycm9yLm1lc3NhZ2UpO2MuY29kZT1iLmVycm9yLmNvZGU7Yy5kZXRhaWxzPWIuZXJyb3IuZGV0YWlscztQKGUsYyl9ZWxzZSBQKGUsbnVsbCxiKX0pKX1cbmZ1bmN0aW9uIFZnKGEsYil7dmFyIGM9bnVsbCE9PWEubWJ8fG51bGwhPT1iO2EubWI9YjtjJiZhLmZlKFwiYXV0aF9zdGF0dXNcIixiKTthLkxlKG51bGwhPT1iKX1nLkFlPWZ1bmN0aW9uKGEpe0soXCJhdXRoX3N0YXR1c1wiPT09YSwnaW5pdGlhbCBldmVudCBtdXN0IGJlIG9mIHR5cGUgXCJhdXRoX3N0YXR1c1wiJyk7cmV0dXJuIHRoaXMuU2U/bnVsbDpbdGhpcy5tYl19O2Z1bmN0aW9uIGFoKGEpe3ZhciBiPWEuRjtpZihcImZpcmViYXNlaW8uY29tXCIhPT1iLmRvbWFpbiYmXCJmaXJlYmFzZWlvLWRlbW8uY29tXCIhPT1iLmRvbWFpbiYmXCJhdXRoLmZpcmViYXNlLmNvbVwiPT09c2cpdGhyb3cgRXJyb3IoXCJUaGlzIGN1c3RvbSBGaXJlYmFzZSBzZXJ2ZXIgKCdcIithLkYuZG9tYWluK1wiJykgZG9lcyBub3Qgc3VwcG9ydCBkZWxlZ2F0ZWQgbG9naW4uXCIpO307dmFyIENjPVwid2Vic29ja2V0XCIsRGM9XCJsb25nX3BvbGxpbmdcIjtmdW5jdGlvbiBlaChhKXt0aGlzLmpjPWE7dGhpcy5OZD1bXTt0aGlzLlNiPTA7dGhpcy5xZT0tMTt0aGlzLkZiPW51bGx9ZnVuY3Rpb24gZmgoYSxiLGMpe2EucWU9YjthLkZiPWM7YS5xZTxhLlNiJiYoYS5GYigpLGEuRmI9bnVsbCl9ZnVuY3Rpb24gZ2goYSxiLGMpe2ZvcihhLk5kW2JdPWM7YS5OZFthLlNiXTspe3ZhciBkPWEuTmRbYS5TYl07ZGVsZXRlIGEuTmRbYS5TYl07Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDsrK2UpaWYoZFtlXSl7dmFyIGY9YTtEYihmdW5jdGlvbigpe2YuamMoZFtlXSl9KX1pZihhLlNiPT09YS5xZSl7YS5GYiYmKGNsZWFyVGltZW91dChhLkZiKSxhLkZiKCksYS5GYj1udWxsKTticmVha31hLlNiKyt9fTtmdW5jdGlvbiBoaChhLGIsYyxkKXt0aGlzLnJlPWE7dGhpcy5mPU1jKGEpO3RoaXMubmI9dGhpcy5vYj0wO3RoaXMuVWE9UmIoYik7dGhpcy5RZj1jO3RoaXMuSGM9ITE7dGhpcy5CYj1kO3RoaXMuamQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEJjKGIsRGMsYSl9fXZhciBpaCxqaDtcbmhoLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy5oZj0wO3RoaXMubGE9Yjt0aGlzLkFmPW5ldyBlaChhKTt0aGlzLnpiPSExO3ZhciBjPXRoaXM7dGhpcy5xYj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mKFwiVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LlwiKTtjLmdiKCk7Yy5xYj1udWxsfSxNYXRoLmZsb29yKDNFNCkpO1JjKGZ1bmN0aW9uKCl7aWYoIWMuemIpe2MuU2E9bmV3IGtoKGZ1bmN0aW9uKGEsYixkLGssbCl7bGgoYyxhcmd1bWVudHMpO2lmKGMuU2EpaWYoYy5xYiYmKGNsZWFyVGltZW91dChjLnFiKSxjLnFiPW51bGwpLGMuSGM9ITAsXCJzdGFydFwiPT1hKWMuaWQ9YixjLkdmPWQ7ZWxzZSBpZihcImNsb3NlXCI9PT1hKWI/KGMuU2EuWGQ9ITEsZmgoYy5BZixiLGZ1bmN0aW9uKCl7Yy5nYigpfSkpOmMuZ2IoKTtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6IFwiK2EpO30sZnVuY3Rpb24oYSxiKXtsaChjLGFyZ3VtZW50cyk7XG5naChjLkFmLGEsYil9LGZ1bmN0aW9uKCl7Yy5nYigpfSxjLmpkKTt2YXIgYT17c3RhcnQ6XCJ0XCJ9O2Euc2VyPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO2MuU2EuaGUmJihhLmNiPWMuU2EuaGUpO2Eudj1cIjVcIjtjLlFmJiYoYS5zPWMuUWYpO2MuQmImJihhLmxzPWMuQmIpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2E9Yy5qZChhKTtjLmYoXCJDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gXCIrYSk7bWgoYy5TYSxhLGZ1bmN0aW9uKCl7fSl9fSl9O1xuaGgucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5TYSxiPXRoaXMuR2Y7YS51Zz10aGlzLmlkO2Eudmc9Yjtmb3IoYS5sZT0hMDtuaChhKTspO2E9dGhpcy5pZDtiPXRoaXMuR2Y7dGhpcy5nYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3ZhciBjPXtkZnJhbWU6XCJ0XCJ9O2MuaWQ9YTtjLnB3PWI7dGhpcy5nYy5zcmM9dGhpcy5qZChjKTt0aGlzLmdjLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmdjKX07XG5oaC5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiBpaHx8IWpoJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZudWxsIT1kb2N1bWVudC5jcmVhdGVFbGVtZW50JiYhKFwib2JqZWN0XCI9PT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY2hyb21lJiZ3aW5kb3cuY2hyb21lLmV4dGVuc2lvbiYmIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkmJiEoXCJvYmplY3RcIj09PXR5cGVvZiBXaW5kb3dzJiZcIm9iamVjdFwiPT09dHlwZW9mIFdpbmRvd3MuWGcpJiYhMH07Zz1oaC5wcm90b3R5cGU7Zy5FZD1mdW5jdGlvbigpe307Zy5kZD1mdW5jdGlvbigpe3RoaXMuemI9ITA7dGhpcy5TYSYmKHRoaXMuU2EuY2xvc2UoKSx0aGlzLlNhPW51bGwpO3RoaXMuZ2MmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZ2MpLHRoaXMuZ2M9bnVsbCk7dGhpcy5xYiYmKGNsZWFyVGltZW91dCh0aGlzLnFiKSx0aGlzLnFiPW51bGwpfTtcbmcuZ2I9ZnVuY3Rpb24oKXt0aGlzLnpifHwodGhpcy5mKFwiTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5kZCgpLHRoaXMubGEmJih0aGlzLmxhKHRoaXMuSGMpLHRoaXMubGE9bnVsbCkpfTtnLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy56Ynx8KHRoaXMuZihcIkxvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC5cIiksdGhpcy5kZCgpKX07Zy5zZW5kPWZ1bmN0aW9uKGEpe2E9QihhKTt0aGlzLm9iKz1hLmxlbmd0aDtPYih0aGlzLlVhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPUljKGEpO2E9ZmIoYSwhMCk7YT1WYyhhLDE4NDApO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLlNhO2MuYWQucHVzaCh7TWc6dGhpcy5oZixVZzphLmxlbmd0aCxrZjphW2JdfSk7Yy5sZSYmbmgoYyk7dGhpcy5oZisrfX07ZnVuY3Rpb24gbGgoYSxiKXt2YXIgYz1CKGIpLmxlbmd0aDthLm5iKz1jO09iKGEuVWEsXCJieXRlc19yZWNlaXZlZFwiLGMpfVxuZnVuY3Rpb24ga2goYSxiLGMsZCl7dGhpcy5qZD1kO3RoaXMuaGI9Yzt0aGlzLlBlPW5ldyBwZzt0aGlzLmFkPVtdO3RoaXMudGU9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7dGhpcy5YZD0hMDt0aGlzLmhlPUVjKCk7d2luZG93W1wicExQQ29tbWFuZFwiK3RoaXMuaGVdPWE7d2luZG93W1wicFJUTFBDQlwiK3RoaXMuaGVdPWI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtpZihkb2N1bWVudC5ib2R5KXtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO3RyeXthLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnR8fENiKFwiTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWRcIil9Y2F0Y2goZSl7YS5zcmM9XCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIrZG9jdW1lbnQuZG9tYWluK1wiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCJ9fWVsc2UgdGhyb3dcIkRvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cIjtcbmEuY29udGVudERvY3VtZW50P2EuZWI9YS5jb250ZW50RG9jdW1lbnQ6YS5jb250ZW50V2luZG93P2EuZWI9YS5jb250ZW50V2luZG93LmRvY3VtZW50OmEuZG9jdW1lbnQmJihhLmViPWEuZG9jdW1lbnQpO3RoaXMuRWE9YTthPVwiXCI7dGhpcy5FYS5zcmMmJlwiamF2YXNjcmlwdDpcIj09PXRoaXMuRWEuc3JjLnN1YnN0cigwLDExKSYmKGE9JzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJytkb2N1bWVudC5kb21haW4rJ1wiO1xceDNjL3NjcmlwdD4nKTthPVwiPGh0bWw+PGJvZHk+XCIrYStcIjwvYm9keT48L2h0bWw+XCI7dHJ5e3RoaXMuRWEuZWIub3BlbigpLHRoaXMuRWEuZWIud3JpdGUoYSksdGhpcy5FYS5lYi5jbG9zZSgpfWNhdGNoKGYpe0NiKFwiZnJhbWUgd3JpdGluZyBleGNlcHRpb25cIiksZi5zdGFjayYmQ2IoZi5zdGFjayksQ2IoZil9fVxua2gucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5sZT0hMTtpZih0aGlzLkVhKXt0aGlzLkVhLmViLmJvZHkuaW5uZXJIVE1MPVwiXCI7dmFyIGE9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbCE9PWEuRWEmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEuRWEpLGEuRWE9bnVsbCl9LE1hdGguZmxvb3IoMCkpfXZhciBiPXRoaXMuaGI7YiYmKHRoaXMuaGI9bnVsbCxiKCkpfTtcbmZ1bmN0aW9uIG5oKGEpe2lmKGEubGUmJmEuWGQmJmEuUGUuY291bnQoKTwoMDxhLmFkLmxlbmd0aD8yOjEpKXthLnRlKys7dmFyIGI9e307Yi5pZD1hLnVnO2IucHc9YS52ZztiLnNlcj1hLnRlO2Zvcih2YXIgYj1hLmpkKGIpLGM9XCJcIixkPTA7MDxhLmFkLmxlbmd0aDspaWYoMTg3MD49YS5hZFswXS5rZi5sZW5ndGgrMzArYy5sZW5ndGgpe3ZhciBlPWEuYWQuc2hpZnQoKSxjPWMrXCImc2VnXCIrZCtcIj1cIitlLk1nK1wiJnRzXCIrZCtcIj1cIitlLlVnK1wiJmRcIitkK1wiPVwiK2Uua2Y7ZCsrfWVsc2UgYnJlYWs7b2goYSxiK2MsYS50ZSk7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gb2goYSxiLGMpe2Z1bmN0aW9uIGQoKXthLlBlLnJlbW92ZShjKTtuaChhKX1hLlBlLmFkZChjLDEpO3ZhciBlPXNldFRpbWVvdXQoZCxNYXRoLmZsb29yKDI1RTMpKTttaChhLGIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZSk7ZCgpfSl9XG5mdW5jdGlvbiBtaChhLGIsYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3RyeXtpZihhLlhkKXt2YXIgZD1hLkVhLmViLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZC50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI7ZC5hc3luYz0hMDtkLnNyYz1iO2Qub25sb2FkPWQub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7dmFyIGE9ZC5yZWFkeVN0YXRlO2EmJlwibG9hZGVkXCIhPT1hJiZcImNvbXBsZXRlXCIhPT1hfHwoZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxkLnBhcmVudE5vZGUmJmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxjKCkpfTtkLm9uZXJyb3I9ZnVuY3Rpb24oKXtDYihcIkxvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6IFwiK2IpO2EuWGQ9ITE7YS5jbG9zZSgpfTthLkVhLmViLmJvZHkuYXBwZW5kQ2hpbGQoZCl9fWNhdGNoKGUpe319LE1hdGguZmxvb3IoMSkpfTt2YXIgcGg9bnVsbDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1veldlYlNvY2tldD9waD1Nb3pXZWJTb2NrZXQ6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBXZWJTb2NrZXQmJihwaD1XZWJTb2NrZXQpO2Z1bmN0aW9uIHFoKGEsYixjLGQpe3RoaXMucmU9YTt0aGlzLmY9TWModGhpcy5yZSk7dGhpcy5mcmFtZXM9dGhpcy5LYz1udWxsO3RoaXMubmI9dGhpcy5vYj10aGlzLmJmPTA7dGhpcy5VYT1SYihiKTthPXt2OlwiNVwifTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGxvY2F0aW9uJiZsb2NhdGlvbi5ocmVmJiYtMSE9PWxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImZpcmViYXNlaW8uY29tXCIpJiYoYS5yPVwiZlwiKTtjJiYoYS5zPWMpO2QmJihhLmxzPWQpO3RoaXMuZWY9QmMoYixDYyxhKX12YXIgcmg7XG5xaC5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3RoaXMuaGI9Yjt0aGlzLnpnPWE7dGhpcy5mKFwiV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gXCIrdGhpcy5lZik7dGhpcy5IYz0hMTt4Yy5zZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiLCEwKTt0cnl7dGhpcy51YT1uZXcgcGgodGhpcy5lZil9Y2F0Y2goYyl7dGhpcy5mKFwiRXJyb3IgaW5zdGFudGlhdGluZyBXZWJTb2NrZXQuXCIpO3ZhciBkPWMubWVzc2FnZXx8Yy5kYXRhO2QmJnRoaXMuZihkKTt0aGlzLmdiKCk7cmV0dXJufXZhciBlPXRoaXM7dGhpcy51YS5vbm9wZW49ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGVkLlwiKTtlLkhjPSEwfTt0aGlzLnVhLm9uY2xvc2U9ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLlwiKTtlLnVhPW51bGw7ZS5nYigpfTt0aGlzLnVhLm9ubWVzc2FnZT1mdW5jdGlvbihhKXtpZihudWxsIT09ZS51YSlpZihhPWEuZGF0YSxlLm5iKz1cbmEubGVuZ3RoLE9iKGUuVWEsXCJieXRlc19yZWNlaXZlZFwiLGEubGVuZ3RoKSxzaChlKSxudWxsIT09ZS5mcmFtZXMpdGgoZSxhKTtlbHNle2E6e0sobnVsbD09PWUuZnJhbWVzLFwiV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyXCIpO2lmKDY+PWEubGVuZ3RoKXt2YXIgYj1OdW1iZXIoYSk7aWYoIWlzTmFOKGIpKXtlLmJmPWI7ZS5mcmFtZXM9W107YT1udWxsO2JyZWFrIGF9fWUuYmY9MTtlLmZyYW1lcz1bXX1udWxsIT09YSYmdGgoZSxhKX19O3RoaXMudWEub25lcnJvcj1mdW5jdGlvbihhKXtlLmYoXCJXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uXCIpOyhhPWEubWVzc2FnZXx8YS5kYXRhKSYmZS5mKGEpO2UuZ2IoKX19O3FoLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe307XG5xaC5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3ZhciBhPSExO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50KXt2YXIgYj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLyk7YiYmMTxiLmxlbmd0aCYmNC40PnBhcnNlRmxvYXQoYlsxXSkmJihhPSEwKX1yZXR1cm4hYSYmbnVsbCE9PXBoJiYhcmh9O3FoLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHk9MjtxaC5oZWFsdGh5VGltZW91dD0zRTQ7Zz1xaC5wcm90b3R5cGU7Zy5FZD1mdW5jdGlvbigpe3hjLnJlbW92ZShcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIpfTtmdW5jdGlvbiB0aChhLGIpe2EuZnJhbWVzLnB1c2goYik7aWYoYS5mcmFtZXMubGVuZ3RoPT1hLmJmKXt2YXIgYz1hLmZyYW1lcy5qb2luKFwiXCIpO2EuZnJhbWVzPW51bGw7Yz1uYihjKTthLnpnKGMpfX1cbmcuc2VuZD1mdW5jdGlvbihhKXtzaCh0aGlzKTthPUIoYSk7dGhpcy5vYis9YS5sZW5ndGg7T2IodGhpcy5VYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT1WYyhhLDE2Mzg0KTsxPGEubGVuZ3RoJiZ0aGlzLnVhLnNlbmQoU3RyaW5nKGEubGVuZ3RoKSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy51YS5zZW5kKGFbYl0pfTtnLmRkPWZ1bmN0aW9uKCl7dGhpcy56Yj0hMDt0aGlzLktjJiYoY2xlYXJJbnRlcnZhbCh0aGlzLktjKSx0aGlzLktjPW51bGwpO3RoaXMudWEmJih0aGlzLnVhLmNsb3NlKCksdGhpcy51YT1udWxsKX07Zy5nYj1mdW5jdGlvbigpe3RoaXMuemJ8fCh0aGlzLmYoXCJXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5kZCgpLHRoaXMuaGImJih0aGlzLmhiKHRoaXMuSGMpLHRoaXMuaGI9bnVsbCkpfTtnLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy56Ynx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBiZWluZyBjbG9zZWRcIiksdGhpcy5kZCgpKX07XG5mdW5jdGlvbiBzaChhKXtjbGVhckludGVydmFsKGEuS2MpO2EuS2M9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLnVhJiZhLnVhLnNlbmQoXCIwXCIpO3NoKGEpfSxNYXRoLmZsb29yKDQ1RTMpKX07ZnVuY3Rpb24gdWgoYSl7dmgodGhpcyxhKX12YXIgd2g9W2hoLHFoXTtmdW5jdGlvbiB2aChhLGIpe3ZhciBjPXFoJiZxaC5pc0F2YWlsYWJsZSgpLGQ9YyYmISh4Yy53Znx8ITA9PT14Yy5nZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKSk7Yi5XZyYmKGN8fE8oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpLGQ9ITApO2lmKGQpYS5nZD1bcWhdO2Vsc2V7dmFyIGU9YS5nZD1bXTtXYyh3aCxmdW5jdGlvbihhLGIpe2ImJmIuaXNBdmFpbGFibGUoKSYmZS5wdXNoKGIpfSl9fWZ1bmN0aW9uIHhoKGEpe2lmKDA8YS5nZC5sZW5ndGgpcmV0dXJuIGEuZ2RbMF07dGhyb3cgRXJyb3IoXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTt9O2Z1bmN0aW9uIHloKGEsYixjLGQsZSxmLGgpe3RoaXMuaWQ9YTt0aGlzLmY9TWMoXCJjOlwiK3RoaXMuaWQrXCI6XCIpO3RoaXMuamM9Yzt0aGlzLldjPWQ7dGhpcy5sYT1lO3RoaXMuTmU9Zjt0aGlzLkY9Yjt0aGlzLk1kPVtdO3RoaXMuZmY9MDt0aGlzLlBmPW5ldyB1aChiKTt0aGlzLlRhPTA7dGhpcy5CYj1oO3RoaXMuZihcIkNvbm5lY3Rpb24gY3JlYXRlZFwiKTt6aCh0aGlzKX1cbmZ1bmN0aW9uIHpoKGEpe3ZhciBiPXhoKGEuUGYpO2EuSj1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLmZmKyssYS5GLHZvaWQgMCxhLkJiKTthLlJlPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDt2YXIgYz1BaChhLGEuSiksZD1CaChhLGEuSik7YS5oZD1hLko7YS5jZD1hLko7YS5EPW51bGw7YS5BYj0hMTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5KJiZhLkoub3BlbihjLGQpfSxNYXRoLmZsb29yKDApKTtiPWIuaGVhbHRoeVRpbWVvdXR8fDA7MDxiJiYoYS55ZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS55ZD1udWxsO2EuQWJ8fChhLkomJjEwMjQwMDxhLkoubmI/KGEuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgcmVjZWl2ZWQgXCIrYS5KLm5iK1wiIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuXCIpLGEuQWI9ITAsYS5KLkVkKCkpOmEuSiYmMTAyNDA8YS5KLm9iP2EuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCBcIitcbmEuSi5vYitcIiBieXRlcy4gIExlYXZpbmcgY29ubmVjdGlvbiBhbGl2ZS5cIik6KGEuZihcIkNsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC5cIiksYS5jbG9zZSgpKSl9LE1hdGguZmxvb3IoYikpKX1mdW5jdGlvbiBCaChhLGIpe3JldHVybiBmdW5jdGlvbihjKXtiPT09YS5KPyhhLko9bnVsbCxjfHwwIT09YS5UYT8xPT09YS5UYSYmYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LlwiKTooYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuXCIpLFwicy1cIj09PWEuRi5ZYS5zdWJzdHIoMCwyKSYmKHhjLnJlbW92ZShcImhvc3Q6XCIrYS5GLmhvc3QpLGEuRi5ZYT1hLkYuaG9zdCkpLGEuY2xvc2UoKSk6Yj09PWEuRD8oYS5mKFwiU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC5cIiksYz1hLkQsYS5EPW51bGwsYS5oZCE9PWMmJmEuY2QhPT1jfHxhLmNsb3NlKCkpOmEuZihcImNsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb25cIil9fVxuZnVuY3Rpb24gQWgoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoMiE9YS5UYSlpZihiPT09YS5jZCl7dmFyIGQ9VGMoXCJ0XCIsYyk7Yz1UYyhcImRcIixjKTtpZihcImNcIj09ZCl7aWYoZD1UYyhcInRcIixjKSxcImRcImluIGMpaWYoYz1jLmQsXCJoXCI9PT1kKXt2YXIgZD1jLnRzLGU9Yy52LGY9Yy5oO2EuTmY9Yy5zO0FjKGEuRixmKTswPT1hLlRhJiYoYS5KLnN0YXJ0KCksQ2goYSxhLkosZCksXCI1XCIhPT1lJiZPKFwiUHJvdG9jb2wgdmVyc2lvbiBtaXNtYXRjaCBkZXRlY3RlZFwiKSxjPWEuUGYsKGM9MTxjLmdkLmxlbmd0aD9jLmdkWzFdOm51bGwpJiZEaChhLGMpKX1lbHNlIGlmKFwiblwiPT09ZCl7YS5mKFwicmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpO2EuY2Q9YS5EO2ZvcihjPTA7YzxhLk1kLmxlbmd0aDsrK2MpYS5JZChhLk1kW2NdKTthLk1kPVtdO0VoKGEpfWVsc2VcInNcIj09PWQ/KGEuZihcIkNvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLlwiKSxcbmEuTmUmJihhLk5lKGMpLGEuTmU9bnVsbCksYS5sYT1udWxsLGEuY2xvc2UoKSk6XCJyXCI9PT1kPyhhLmYoXCJSZXNldCBwYWNrZXQgcmVjZWl2ZWQuICBOZXcgaG9zdDogXCIrYyksQWMoYS5GLGMpLDE9PT1hLlRhP2EuY2xvc2UoKTooRmgoYSksemgoYSkpKTpcImVcIj09PWQ/TmMoXCJTZXJ2ZXIgRXJyb3I6IFwiK2MpOlwib1wiPT09ZD8oYS5mKFwiZ290IHBvbmcgb24gcHJpbWFyeS5cIiksR2goYSksSGgoYSkpOk5jKFwiVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiBcIitkKX1lbHNlXCJkXCI9PWQmJmEuSWQoYyl9ZWxzZSBpZihiPT09YS5EKWlmKGQ9VGMoXCJ0XCIsYyksYz1UYyhcImRcIixjKSxcImNcIj09ZClcInRcImluIGMmJihjPWMudCxcImFcIj09PWM/SWgoYSk6XCJyXCI9PT1jPyhhLmYoXCJHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXRcIiksYS5ELmNsb3NlKCksYS5oZCE9PWEuRCYmYS5jZCE9PWEuRHx8YS5jbG9zZSgpKTpcIm9cIj09PWMmJihhLmYoXCJnb3QgcG9uZyBvbiBzZWNvbmRhcnkuXCIpLFxuYS5NZi0tLEloKGEpKSk7ZWxzZSBpZihcImRcIj09ZClhLk1kLnB1c2goYyk7ZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gcHJvdG9jb2wgbGF5ZXI6IFwiK2QpO2Vsc2UgYS5mKFwibWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvblwiKX19eWgucHJvdG90eXBlLkZhPWZ1bmN0aW9uKGEpe0poKHRoaXMse3Q6XCJkXCIsZDphfSl9O2Z1bmN0aW9uIEVoKGEpe2EuaGQ9PT1hLkQmJmEuY2Q9PT1hLkQmJihhLmYoXCJjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogXCIrYS5ELnJlKSxhLko9YS5ELGEuRD1udWxsKX1cbmZ1bmN0aW9uIEloKGEpezA+PWEuTWY/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEuQWI9ITAsYS5ELkVkKCksYS5ELnN0YXJ0KCksYS5mKFwic2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeVwiKSxhLkQuc2VuZCh7dDpcImNcIixkOnt0OlwiYVwiLGQ6e319fSksYS5mKFwiRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpLGEuSi5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJuXCIsZDp7fX19KSxhLmhkPWEuRCxFaChhKSk6KGEuZihcInNlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuXCIpLGEuRC5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9eWgucHJvdG90eXBlLklkPWZ1bmN0aW9uKGEpe0doKHRoaXMpO3RoaXMuamMoYSl9O2Z1bmN0aW9uIEdoKGEpe2EuQWJ8fChhLlJlLS0sMD49YS5SZSYmKGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLkFiPSEwLGEuSi5FZCgpKSl9XG5mdW5jdGlvbiBEaChhLGIpe2EuRD1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLmZmKyssYS5GLGEuTmYpO2EuTWY9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO2EuRC5vcGVuKEFoKGEsYS5EKSxCaChhLGEuRCkpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkQmJihhLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuXCIpLGEuRC5jbG9zZSgpKX0sTWF0aC5mbG9vcig2RTQpKX1mdW5jdGlvbiBDaChhLGIsYyl7YS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC5cIik7YS5KPWI7YS5UYT0xO2EuV2MmJihhLldjKGMsYS5OZiksYS5XYz1udWxsKTswPT09YS5SZT8oYS5mKFwiUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEuQWI9ITApOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIaChhKX0sTWF0aC5mbG9vcig1RTMpKX1cbmZ1bmN0aW9uIEhoKGEpe2EuQWJ8fDEhPT1hLlRhfHwoYS5mKFwic2VuZGluZyBwaW5nIG9uIHByaW1hcnkuXCIpLEpoKGEse3Q6XCJjXCIsZDp7dDpcInBcIixkOnt9fX0pKX1mdW5jdGlvbiBKaChhLGIpe2lmKDEhPT1hLlRhKXRocm93XCJDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWRcIjthLmhkLnNlbmQoYil9eWgucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7MiE9PXRoaXMuVGEmJih0aGlzLmYoXCJDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uXCIpLHRoaXMuVGE9MixGaCh0aGlzKSx0aGlzLmxhJiYodGhpcy5sYSgpLHRoaXMubGE9bnVsbCkpfTtmdW5jdGlvbiBGaChhKXthLmYoXCJTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9uc1wiKTthLkomJihhLkouY2xvc2UoKSxhLko9bnVsbCk7YS5EJiYoYS5ELmNsb3NlKCksYS5EPW51bGwpO2EueWQmJihjbGVhclRpbWVvdXQoYS55ZCksYS55ZD1udWxsKX07ZnVuY3Rpb24gS2goYSxiLGMsZCl7dGhpcy5pZD1MaCsrO3RoaXMuZj1NYyhcInA6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy54Zj10aGlzLkVlPSExO3RoaXMuJD17fTt0aGlzLnFhPVtdO3RoaXMuWWM9MDt0aGlzLlZjPVtdO3RoaXMub2E9ITE7dGhpcy5aYT0xRTM7dGhpcy5GZD0zRTU7dGhpcy5HYj1iO3RoaXMuVWM9Yzt0aGlzLk9lPWQ7dGhpcy5GPWE7dGhpcy5zYj10aGlzLkFhPXRoaXMuSWE9dGhpcy5CYj10aGlzLldlPW51bGw7dGhpcy5PYj0hMTt0aGlzLlRkPXt9O3RoaXMuTGc9MDt0aGlzLm5mPSEwO3RoaXMuTGM9dGhpcy5HZT1udWxsO01oKHRoaXMsMCk7SGUudWIoKS5FYihcInZpc2libGVcIix0aGlzLkNnLHRoaXMpOy0xPT09YS5ob3N0LmluZGV4T2YoXCJmYmxvY2FsXCIpJiZHZS51YigpLkViKFwib25saW5lXCIsdGhpcy5BZyx0aGlzKX12YXIgTGg9MCxOaD0wO2c9S2gucHJvdG90eXBlO1xuZy5GYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Kyt0aGlzLkxnO2E9e3I6ZCxhOmEsYjpifTt0aGlzLmYoQihhKSk7Syh0aGlzLm9hLFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO3RoaXMuSWEuRmEoYSk7YyYmKHRoaXMuVGRbZF09Yyl9O2cueWY9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS52YSgpLGY9YS5wYXRoLnRvU3RyaW5nKCk7dGhpcy5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZitcIiBcIitlKTt0aGlzLiRbZl09dGhpcy4kW2ZdfHx7fTtLKGZlKGEubil8fCFTKGEubiksXCJsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeVwiKTtLKCF0aGlzLiRbZl1bZV0sXCJsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLlwiKTthPXtIOmQseGQ6YixJZzphLHRhZzpjfTt0aGlzLiRbZl1bZV09YTt0aGlzLm9hJiZPaCh0aGlzLGEpfTtcbmZ1bmN0aW9uIE9oKGEsYil7dmFyIGM9Yi5JZyxkPWMucGF0aC50b1N0cmluZygpLGU9Yy52YSgpO2EuZihcIkxpc3RlbiBvbiBcIitkK1wiIGZvciBcIitlKTt2YXIgZj17cDpkfTtiLnRhZyYmKGYucT1lZShjLm4pLGYudD1iLnRhZyk7Zi5oPWIueGQoKTthLkZhKFwicVwiLGYsZnVuY3Rpb24oZil7dmFyIGs9Zi5kLGw9Zi5zO2lmKGsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmdihrLFwid1wiKSl7dmFyIG09dyhrLFwid1wiKTtlYShtKSYmMDw9TmEobSxcIm5vX2luZGV4XCIpJiZPKFwiVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIENvbnNpZGVyIGFkZGluZyBcIisoJ1wiLmluZGV4T25cIjogXCInK2Mubi5nLnRvU3RyaW5nKCkrJ1wiJykrXCIgYXQgXCIrYy5wYXRoLnRvU3RyaW5nKCkrXCIgdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXCIpfShhLiRbZF0mJmEuJFtkXVtlXSk9PT1iJiYoYS5mKFwibGlzdGVuIHJlc3BvbnNlXCIsZiksXCJva1wiIT09bCYmUGgoYSxkLGUpLGIuSCYmYi5IKGwsXG5rKSl9KX1nLk09ZnVuY3Rpb24oYSxiLGMpe3RoaXMuQWE9e2lnOmEsb2Y6ITEsemM6YixtZDpjfTt0aGlzLmYoXCJBdXRoZW50aWNhdGluZyB1c2luZyBjcmVkZW50aWFsOiBcIithKTtRaCh0aGlzKTsoYj00MD09YS5sZW5ndGgpfHwoYT0kYyhhKS5CYyxiPVwib2JqZWN0XCI9PT10eXBlb2YgYSYmITA9PT13KGEsXCJhZG1pblwiKSk7YiYmKHRoaXMuZihcIkFkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS5cIiksdGhpcy5GZD0zRTQpfTtnLmdlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLkFhO3RoaXMub2EmJnRoaXMuRmEoXCJ1bmF1dGhcIix7fSxmdW5jdGlvbihiKXthKGIucyxiLmQpfSl9O1xuZnVuY3Rpb24gUWgoYSl7dmFyIGI9YS5BYTthLm9hJiZiJiZhLkZhKFwiYXV0aFwiLHtjcmVkOmIuaWd9LGZ1bmN0aW9uKGMpe3ZhciBkPWMucztjPWMuZHx8XCJlcnJvclwiO1wib2tcIiE9PWQmJmEuQWE9PT1iJiZkZWxldGUgYS5BYTtiLm9mP1wib2tcIiE9PWQmJmIubWQmJmIubWQoZCxjKTooYi5vZj0hMCxiLnpjJiZiLnpjKGQsYykpfSl9Zy5SZj1mdW5jdGlvbihhLGIpe3ZhciBjPWEucGF0aC50b1N0cmluZygpLGQ9YS52YSgpO3RoaXMuZihcIlVubGlzdGVuIGNhbGxlZCBmb3IgXCIrYytcIiBcIitkKTtLKGZlKGEubil8fCFTKGEubiksXCJ1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5XCIpO2lmKFBoKHRoaXMsYyxkKSYmdGhpcy5vYSl7dmFyIGU9ZWUoYS5uKTt0aGlzLmYoXCJVbmxpc3RlbiBvbiBcIitjK1wiIGZvciBcIitkKTtjPXtwOmN9O2ImJihjLnE9ZSxjLnQ9Yik7dGhpcy5GYShcIm5cIixjKX19O1xuZy5NZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5vYT9SaCh0aGlzLFwib1wiLGEsYixjKTp0aGlzLlZjLnB1c2goeyRjOmEsYWN0aW9uOlwib1wiLGRhdGE6YixIOmN9KX07Zy5DZj1mdW5jdGlvbihhLGIsYyl7dGhpcy5vYT9SaCh0aGlzLFwib21cIixhLGIsYyk6dGhpcy5WYy5wdXNoKHskYzphLGFjdGlvbjpcIm9tXCIsZGF0YTpiLEg6Y30pfTtnLkpkPWZ1bmN0aW9uKGEsYil7dGhpcy5vYT9SaCh0aGlzLFwib2NcIixhLG51bGwsYik6dGhpcy5WYy5wdXNoKHskYzphLGFjdGlvbjpcIm9jXCIsZGF0YTpudWxsLEg6Yn0pfTtmdW5jdGlvbiBSaChhLGIsYyxkLGUpe2M9e3A6YyxkOmR9O2EuZihcIm9uRGlzY29ubmVjdCBcIitiLGMpO2EuRmEoYixjLGZ1bmN0aW9uKGEpe2UmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGEucyxhLmQpfSxNYXRoLmZsb29yKDApKX0pfWcucHV0PWZ1bmN0aW9uKGEsYixjLGQpe1NoKHRoaXMsXCJwXCIsYSxiLGMsZCl9O1xuZy56Zj1mdW5jdGlvbihhLGIsYyxkKXtTaCh0aGlzLFwibVwiLGEsYixjLGQpfTtmdW5jdGlvbiBTaChhLGIsYyxkLGUsZil7ZD17cDpjLGQ6ZH07bihmKSYmKGQuaD1mKTthLnFhLnB1c2goe2FjdGlvbjpiLEpmOmQsSDplfSk7YS5ZYysrO2I9YS5xYS5sZW5ndGgtMTthLm9hP1RoKGEsYik6YS5mKFwiQnVmZmVyaW5nIHB1dDogXCIrYyl9ZnVuY3Rpb24gVGgoYSxiKXt2YXIgYz1hLnFhW2JdLmFjdGlvbixkPWEucWFbYl0uSmYsZT1hLnFhW2JdLkg7YS5xYVtiXS5KZz1hLm9hO2EuRmEoYyxkLGZ1bmN0aW9uKGQpe2EuZihjK1wiIHJlc3BvbnNlXCIsZCk7ZGVsZXRlIGEucWFbYl07YS5ZYy0tOzA9PT1hLlljJiYoYS5xYT1bXSk7ZSYmZShkLnMsZC5kKX0pfVxuZy5VZT1mdW5jdGlvbihhKXt0aGlzLm9hJiYoYT17YzphfSx0aGlzLmYoXCJyZXBvcnRTdGF0c1wiLGEpLHRoaXMuRmEoXCJzXCIsYSxmdW5jdGlvbihhKXtcIm9rXCIhPT1hLnMmJnRoaXMuZihcInJlcG9ydFN0YXRzXCIsXCJFcnJvciBzZW5kaW5nIHN0YXRzOiBcIithLmQpfSkpfTtcbmcuSWQ9ZnVuY3Rpb24oYSl7aWYoXCJyXCJpbiBhKXt0aGlzLmYoXCJmcm9tIHNlcnZlcjogXCIrQihhKSk7dmFyIGI9YS5yLGM9dGhpcy5UZFtiXTtjJiYoZGVsZXRlIHRoaXMuVGRbYl0sYyhhLmIpKX1lbHNle2lmKFwiZXJyb3JcImluIGEpdGhyb3dcIkEgc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiBcIithLmVycm9yO1wiYVwiaW4gYSYmKGI9YS5hLGM9YS5iLHRoaXMuZihcImhhbmRsZVNlcnZlck1lc3NhZ2VcIixiLGMpLFwiZFwiPT09Yj90aGlzLkdiKGMucCxjLmQsITEsYy50KTpcIm1cIj09PWI/dGhpcy5HYihjLnAsYy5kLCEwLGMudCk6XCJjXCI9PT1iP1VoKHRoaXMsYy5wLGMucSk6XCJhY1wiPT09Yj8oYT1jLnMsYj1jLmQsYz10aGlzLkFhLGRlbGV0ZSB0aGlzLkFhLGMmJmMubWQmJmMubWQoYSxiKSk6XCJzZFwiPT09Yj90aGlzLldlP3RoaXMuV2UoYyk6XCJtc2dcImluIGMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2coXCJGSVJFQkFTRTogXCIrYy5tc2cucmVwbGFjZShcIlxcblwiLFxuXCJcXG5GSVJFQkFTRTogXCIpKTpOYyhcIlVucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiK0IoYikrXCJcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50P1wiKSl9fTtnLldjPWZ1bmN0aW9uKGEsYil7dGhpcy5mKFwiY29ubmVjdGlvbiByZWFkeVwiKTt0aGlzLm9hPSEwO3RoaXMuTGM9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5PZSh7c2VydmVyVGltZU9mZnNldDphLShuZXcgRGF0ZSkuZ2V0VGltZSgpfSk7dGhpcy5CYj1iO2lmKHRoaXMubmYpe3ZhciBjPXt9O2NbXCJzZGsuanMuXCIraGIucmVwbGFjZSgvXFwuL2csXCItXCIpXT0xO3lnKCkmJihjW1wiZnJhbWV3b3JrLmNvcmRvdmFcIl09MSk7dGhpcy5VZShjKX1WaCh0aGlzKTt0aGlzLm5mPSExO3RoaXMuVWMoITApfTtcbmZ1bmN0aW9uIE1oKGEsYil7SyghYS5JYSxcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTthLnNiJiZjbGVhclRpbWVvdXQoYS5zYik7YS5zYj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5zYj1udWxsO1doKGEpfSxNYXRoLmZsb29yKGIpKX1nLkNnPWZ1bmN0aW9uKGEpe2EmJiF0aGlzLk9iJiZ0aGlzLlphPT09dGhpcy5GZCYmKHRoaXMuZihcIldpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LlwiKSx0aGlzLlphPTFFMyx0aGlzLklhfHxNaCh0aGlzLDApKTt0aGlzLk9iPWF9O2cuQWc9ZnVuY3Rpb24oYSl7YT8odGhpcy5mKFwiQnJvd3NlciB3ZW50IG9ubGluZS5cIiksdGhpcy5aYT0xRTMsdGhpcy5JYXx8TWgodGhpcywwKSk6KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvZmZsaW5lLiAgS2lsbGluZyBjb25uZWN0aW9uLlwiKSx0aGlzLklhJiZ0aGlzLklhLmNsb3NlKCkpfTtcbmcuRGY9ZnVuY3Rpb24oKXt0aGlzLmYoXCJkYXRhIGNsaWVudCBkaXNjb25uZWN0ZWRcIik7dGhpcy5vYT0hMTt0aGlzLklhPW51bGw7Zm9yKHZhciBhPTA7YTx0aGlzLnFhLmxlbmd0aDthKyspe3ZhciBiPXRoaXMucWFbYV07YiYmXCJoXCJpbiBiLkpmJiZiLkpnJiYoYi5IJiZiLkgoXCJkaXNjb25uZWN0XCIpLGRlbGV0ZSB0aGlzLnFhW2FdLHRoaXMuWWMtLSl9MD09PXRoaXMuWWMmJih0aGlzLnFhPVtdKTt0aGlzLlRkPXt9O1hoKHRoaXMpJiYodGhpcy5PYj90aGlzLkxjJiYoM0U0PChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuTGMmJih0aGlzLlphPTFFMyksdGhpcy5MYz1udWxsKToodGhpcy5mKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpLHRoaXMuWmE9dGhpcy5GZCx0aGlzLkdlPShuZXcgRGF0ZSkuZ2V0VGltZSgpKSxhPU1hdGgubWF4KDAsdGhpcy5aYS0oKG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5HZSkpLGEqPU1hdGgucmFuZG9tKCksdGhpcy5mKFwiVHJ5aW5nIHRvIHJlY29ubmVjdCBpbiBcIitcbmErXCJtc1wiKSxNaCh0aGlzLGEpLHRoaXMuWmE9TWF0aC5taW4odGhpcy5GZCwxLjMqdGhpcy5aYSkpO3RoaXMuVWMoITEpfTtmdW5jdGlvbiBXaChhKXtpZihYaChhKSl7YS5mKFwiTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0XCIpO2EuR2U9KG5ldyBEYXRlKS5nZXRUaW1lKCk7YS5MYz1udWxsO3ZhciBiPXEoYS5JZCxhKSxjPXEoYS5XYyxhKSxkPXEoYS5EZixhKSxlPWEuaWQrXCI6XCIrTmgrKzthLklhPW5ldyB5aChlLGEuRixiLGMsZCxmdW5jdGlvbihiKXtPKGIrXCIgKFwiK2EuRi50b1N0cmluZygpK1wiKVwiKTthLnhmPSEwfSxhLkJiKX19Zy55Yj1mdW5jdGlvbigpe3RoaXMuRWU9ITA7dGhpcy5JYT90aGlzLklhLmNsb3NlKCk6KHRoaXMuc2ImJihjbGVhclRpbWVvdXQodGhpcy5zYiksdGhpcy5zYj1udWxsKSx0aGlzLm9hJiZ0aGlzLkRmKCkpfTtnLnJjPWZ1bmN0aW9uKCl7dGhpcy5FZT0hMTt0aGlzLlphPTFFMzt0aGlzLklhfHxNaCh0aGlzLDApfTtcbmZ1bmN0aW9uIFVoKGEsYixjKXtjPWM/UWEoYyxmdW5jdGlvbihhKXtyZXR1cm4gVWMoYSl9KS5qb2luKFwiJFwiKTpcImRlZmF1bHRcIjsoYT1QaChhLGIsYykpJiZhLkgmJmEuSChcInBlcm1pc3Npb25fZGVuaWVkXCIpfWZ1bmN0aW9uIFBoKGEsYixjKXtiPShuZXcgTChiKSkudG9TdHJpbmcoKTt2YXIgZDtuKGEuJFtiXSk/KGQ9YS4kW2JdW2NdLGRlbGV0ZSBhLiRbYl1bY10sMD09PXBhKGEuJFtiXSkmJmRlbGV0ZSBhLiRbYl0pOmQ9dm9pZCAwO3JldHVybiBkfWZ1bmN0aW9uIFZoKGEpe1FoKGEpO3IoYS4kLGZ1bmN0aW9uKGIpe3IoYixmdW5jdGlvbihiKXtPaChhLGIpfSl9KTtmb3IodmFyIGI9MDtiPGEucWEubGVuZ3RoO2IrKylhLnFhW2JdJiZUaChhLGIpO2Zvcig7YS5WYy5sZW5ndGg7KWI9YS5WYy5zaGlmdCgpLFJoKGEsYi5hY3Rpb24sYi4kYyxiLmRhdGEsYi5IKX1mdW5jdGlvbiBYaChhKXt2YXIgYjtiPUdlLnViKCkua2M7cmV0dXJuIWEueGYmJiFhLkVlJiZifTt2YXIgVj17b2c6ZnVuY3Rpb24oKXtpaD1yaD0hMH19O1YuZm9yY2VMb25nUG9sbGluZz1WLm9nO1YucGc9ZnVuY3Rpb24oKXtqaD0hMH07Vi5mb3JjZVdlYlNvY2tldHM9Vi5wZztWLlBnPWZ1bmN0aW9uKGEsYil7YS5rLlJhLldlPWJ9O1Yuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVYuUGc7Vi5ZZT1mdW5jdGlvbihhLGIpe2Euay5ZZShiKX07Vi5zdGF0cz1WLlllO1YuWmU9ZnVuY3Rpb24oYSxiKXthLmsuWmUoYil9O1Yuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVYuWmU7Vi5zZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLnNkfTtWLmRhdGFVcGRhdGVDb3VudD1WLnNkO1Yuc2c9ZnVuY3Rpb24oYSxiKXthLmsuRGU9Yn07Vi5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVYuc2c7Vi55Zz1mdW5jdGlvbihhKXtuZXcgSWcoYSl9O1Yub25Qb3B1cE9wZW49Vi55ZztWLk5nPWZ1bmN0aW9uKGEpe3NnPWF9O1Yuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9Vi5OZztmdW5jdGlvbiBRKGEsYixjKXt0aGlzLkE9YTt0aGlzLlc9Yjt0aGlzLmc9Y31RLnByb3RvdHlwZS5JPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC52YWxcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5JKCl9O1EucHJvdG90eXBlLnZhbD1RLnByb3RvdHlwZS5JO1EucHJvdG90eXBlLm1mPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5leHBvcnRWYWxcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5JKCEwKX07US5wcm90b3R5cGUuZXhwb3J0VmFsPVEucHJvdG90eXBlLm1mO1EucHJvdG90eXBlLm5nPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5leGlzdHNcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIXRoaXMuQS5lKCl9O1EucHJvdG90eXBlLmV4aXN0cz1RLnByb3RvdHlwZS5uZztcblEucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5jaGlsZFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtnYShhKSYmKGE9U3RyaW5nKGEpKTtpZyhcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5jaGlsZFwiLGEpO3ZhciBiPW5ldyBMKGEpLGM9dGhpcy5XLnUoYik7cmV0dXJuIG5ldyBRKHRoaXMuQS5RKGIpLGMsTil9O1EucHJvdG90eXBlLmNoaWxkPVEucHJvdG90eXBlLnU7US5wcm90b3R5cGUuRGE9ZnVuY3Rpb24oYSl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZyhcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLGEpO3ZhciBiPW5ldyBMKGEpO3JldHVybiF0aGlzLkEuUShiKS5lKCl9O1EucHJvdG90eXBlLmhhc0NoaWxkPVEucHJvdG90eXBlLkRhO1xuUS5wcm90b3R5cGUuQz1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZ2V0UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5DKCkuSSgpfTtRLnByb3RvdHlwZS5nZXRQcmlvcml0eT1RLnByb3RvdHlwZS5DO1EucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oYSl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5mb3JFYWNoXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO0EoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsYSwhMSk7aWYodGhpcy5BLksoKSlyZXR1cm4hMTt2YXIgYj10aGlzO3JldHVybiEhdGhpcy5BLlAodGhpcy5nLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEobmV3IFEoZCxiLlcudShjKSxOKSl9KX07US5wcm90b3R5cGUuZm9yRWFjaD1RLnByb3RvdHlwZS5mb3JFYWNoO1xuUS5wcm90b3R5cGUud2Q9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkcmVuXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSygpPyExOiF0aGlzLkEuZSgpfTtRLnByb3RvdHlwZS5oYXNDaGlsZHJlbj1RLnByb3RvdHlwZS53ZDtRLnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7TyhcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5KCkgaW5zdGVhZC5cIik7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmtleSgpfTtRLnByb3RvdHlwZS5uYW1lPVEucHJvdG90eXBlLm5hbWU7US5wcm90b3R5cGUua2V5PWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuVy5rZXkoKX07XG5RLnByb3RvdHlwZS5rZXk9US5wcm90b3R5cGUua2V5O1EucHJvdG90eXBlLkRiPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5udW1DaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkRiKCl9O1EucHJvdG90eXBlLm51bUNoaWxkcmVuPVEucHJvdG90eXBlLkRiO1EucHJvdG90eXBlLkliPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5yZWZcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuV307US5wcm90b3R5cGUucmVmPVEucHJvdG90eXBlLkliO2Z1bmN0aW9uIFloKGEsYil7dGhpcy5GPWE7dGhpcy5VYT1SYihhKTt0aGlzLmZkPW51bGw7dGhpcy5kYT1uZXcgdmI7dGhpcy5IZD0xO3RoaXMuUmE9bnVsbDtifHwwPD0oXCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJndpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50fHxcIlwiKS5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKT8odGhpcy5iYT1uZXcgQWUodGhpcy5GLHEodGhpcy5HYix0aGlzKSksc2V0VGltZW91dChxKHRoaXMuVWMsdGhpcywhMCksMCkpOnRoaXMuYmE9dGhpcy5SYT1uZXcgS2godGhpcy5GLHEodGhpcy5HYix0aGlzKSxxKHRoaXMuVWMsdGhpcykscSh0aGlzLk9lLHRoaXMpKTt0aGlzLlNnPVNiKGEscShmdW5jdGlvbigpe3JldHVybiBuZXcgTWIodGhpcy5VYSx0aGlzLmJhKX0sdGhpcykpO3RoaXMudWM9bmV3IFJmO1xudGhpcy5DZT1uZXcgb2I7dmFyIGM9dGhpczt0aGlzLkNkPW5ldyB2Zih7WGU6ZnVuY3Rpb24oYSxiLGYsaCl7Yj1bXTtmPWMuQ2UuaihhLnBhdGgpO2YuZSgpfHwoYj14ZihjLkNkLG5ldyBYYihiZixhLnBhdGgsZikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtoKFwib2tcIil9LDApKTtyZXR1cm4gYn0sYWU6YmF9KTtaaCh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMubGE9bmV3IHFjO3RoaXMuTT1uZXcgU2coYSxxKHRoaXMuYmEuTSx0aGlzLmJhKSxxKHRoaXMuYmEuZ2UsdGhpcy5iYSkscSh0aGlzLkxlLHRoaXMpKTt0aGlzLnNkPTA7dGhpcy5EZT1udWxsO3RoaXMuTD1uZXcgdmYoe1hlOmZ1bmN0aW9uKGEsYixmLGgpe2MuYmEueWYoYSxmLGIsZnVuY3Rpb24oYixlKXt2YXIgZj1oKGIsZSk7QWIoYy5kYSxhLnBhdGgsZil9KTtyZXR1cm5bXX0sYWU6ZnVuY3Rpb24oYSxiKXtjLmJhLlJmKGEsYil9fSl9Zz1ZaC5wcm90b3R5cGU7XG5nLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuRi5rYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuRi5ob3N0fTtnLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5GLmhjfTtmdW5jdGlvbiAkaChhKXthPWEuQ2UuaihuZXcgTChcIi5pbmZvL3NlcnZlclRpbWVPZmZzZXRcIikpLkkoKXx8MDtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKSthfWZ1bmN0aW9uIGFpKGEpe2E9YT17dGltZXN0YW1wOiRoKGEpfTthLnRpbWVzdGFtcD1hLnRpbWVzdGFtcHx8KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIGF9XG5nLkdiPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuc2QrKzt2YXIgZT1uZXcgTChhKTtiPXRoaXMuRGU/dGhpcy5EZShhLGIpOmI7YT1bXTtkP2M/KGI9bmEoYixmdW5jdGlvbihhKXtyZXR1cm4gTShhKX0pLGE9RmYodGhpcy5MLGUsYixkKSk6KGI9TShiKSxhPUJmKHRoaXMuTCxlLGIsZCkpOmM/KGQ9bmEoYixmdW5jdGlvbihhKXtyZXR1cm4gTShhKX0pLGE9QWYodGhpcy5MLGUsZCkpOihkPU0oYiksYT14Zih0aGlzLkwsbmV3IFhiKGJmLGUsZCkpKTtkPWU7MDxhLmxlbmd0aCYmKGQ9YmkodGhpcyxlKSk7QWIodGhpcy5kYSxkLGEpfTtnLlVjPWZ1bmN0aW9uKGEpe1poKHRoaXMsXCJjb25uZWN0ZWRcIixhKTshMT09PWEmJmNpKHRoaXMpfTtnLk9lPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7V2MoYSxmdW5jdGlvbihhLGQpe1poKGIsZCxhKX0pfTtnLkxlPWZ1bmN0aW9uKGEpe1poKHRoaXMsXCJhdXRoZW50aWNhdGVkXCIsYSl9O1xuZnVuY3Rpb24gWmgoYSxiLGMpe2I9bmV3IEwoXCIvLmluZm8vXCIrYik7Yz1NKGMpO3ZhciBkPWEuQ2U7ZC5XZD1kLldkLkcoYixjKTtjPXhmKGEuQ2QsbmV3IFhiKGJmLGIsYykpO0FiKGEuZGEsYixjKX1nLktiPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuZihcInNldFwiLHtwYXRoOmEudG9TdHJpbmcoKSx2YWx1ZTpiLCRnOmN9KTt2YXIgZT1haSh0aGlzKTtiPU0oYixjKTt2YXIgZT1zYyhiLGUpLGY9dGhpcy5IZCsrLGU9d2YodGhpcy5MLGEsZSxmLCEwKTt3Yih0aGlzLmRhLGUpO3ZhciBoPXRoaXM7dGhpcy5iYS5wdXQoYS50b1N0cmluZygpLGIuSSghMCksZnVuY3Rpb24oYixjKXt2YXIgZT1cIm9rXCI9PT1iO2V8fE8oXCJzZXQgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO2U9emYoaC5MLGYsIWUpO0FiKGguZGEsYSxlKTtkaShkLGIsYyl9KTtlPWVpKHRoaXMsYSk7YmkodGhpcyxlKTtBYih0aGlzLmRhLGUsW10pfTtcbmcudXBkYXRlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmYoXCJ1cGRhdGVcIix7cGF0aDphLnRvU3RyaW5nKCksdmFsdWU6Yn0pO3ZhciBkPSEwLGU9YWkodGhpcyksZj17fTtyKGIsZnVuY3Rpb24oYSxiKXtkPSExO3ZhciBjPU0oYSk7ZltiXT1zYyhjLGUpfSk7aWYoZClDYihcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIiksZGkoYyxcIm9rXCIpO2Vsc2V7dmFyIGg9dGhpcy5IZCsrLGs9eWYodGhpcy5MLGEsZixoKTt3Yih0aGlzLmRhLGspO3ZhciBsPXRoaXM7dGhpcy5iYS56ZihhLnRvU3RyaW5nKCksYixmdW5jdGlvbihiLGQpe3ZhciBlPVwib2tcIj09PWI7ZXx8TyhcInVwZGF0ZSBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7dmFyIGU9emYobC5MLGgsIWUpLGY9YTswPGUubGVuZ3RoJiYoZj1iaShsLGEpKTtBYihsLmRhLGYsZSk7ZGkoYyxiLGQpfSk7Yj1laSh0aGlzLGEpO2JpKHRoaXMsYik7QWIodGhpcy5kYSxhLFtdKX19O1xuZnVuY3Rpb24gY2koYSl7YS5mKFwib25EaXNjb25uZWN0RXZlbnRzXCIpO3ZhciBiPWFpKGEpLGM9W107cmMocGMoYS5sYSxiKSxHLGZ1bmN0aW9uKGIsZSl7Yz1jLmNvbmNhdCh4ZihhLkwsbmV3IFhiKGJmLGIsZSkpKTt2YXIgZj1laShhLGIpO2JpKGEsZil9KTthLmxhPW5ldyBxYztBYihhLmRhLEcsYyl9Zy5KZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5iYS5KZChhLnRvU3RyaW5nKCksZnVuY3Rpb24oZCxlKXtcIm9rXCI9PT1kJiZyZyhjLmxhLGEpO2RpKGIsZCxlKX0pfTtmdW5jdGlvbiBmaShhLGIsYyxkKXt2YXIgZT1NKGMpO2EuYmEuTWUoYi50b1N0cmluZygpLGUuSSghMCksZnVuY3Rpb24oYyxoKXtcIm9rXCI9PT1jJiZhLmxhLm5jKGIsZSk7ZGkoZCxjLGgpfSl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXt2YXIgZj1NKGMsZCk7YS5iYS5NZShiLnRvU3RyaW5nKCksZi5JKCEwKSxmdW5jdGlvbihjLGQpe1wib2tcIj09PWMmJmEubGEubmMoYixmKTtkaShlLGMsZCl9KX1cbmZ1bmN0aW9uIGhpKGEsYixjLGQpe3ZhciBlPSEwLGY7Zm9yKGYgaW4gYyllPSExO2U/KENiKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKSxkaShkLFwib2tcIikpOmEuYmEuQ2YoYi50b1N0cmluZygpLGMsZnVuY3Rpb24oZSxmKXtpZihcIm9rXCI9PT1lKWZvcih2YXIgbCBpbiBjKXt2YXIgbT1NKGNbbF0pO2EubGEubmMoYi51KGwpLG0pfWRpKGQsZSxmKX0pfWZ1bmN0aW9uIGlpKGEsYixjKXtjPVwiLmluZm9cIj09PUUoYi5wYXRoKT9hLkNkLlBiKGIsYyk6YS5MLlBiKGIsYyk7eWIoYS5kYSxiLnBhdGgsYyl9Zy55Yj1mdW5jdGlvbigpe3RoaXMuUmEmJnRoaXMuUmEueWIoKX07Zy5yYz1mdW5jdGlvbigpe3RoaXMuUmEmJnRoaXMuUmEucmMoKX07XG5nLlllPWZ1bmN0aW9uKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7YT8odGhpcy5mZHx8KHRoaXMuZmQ9bmV3IExiKHRoaXMuVWEpKSxhPXRoaXMuZmQuZ2V0KCkpOmE9dGhpcy5VYS5nZXQoKTt2YXIgYj1SYShzYShhKSxmdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLm1heChiLmxlbmd0aCxhKX0sMCksYztmb3IoYyBpbiBhKXtmb3IodmFyIGQ9YVtjXSxlPWMubGVuZ3RoO2U8YisyO2UrKyljKz1cIiBcIjtjb25zb2xlLmxvZyhjK2QpfX19O2cuWmU9ZnVuY3Rpb24oYSl7T2IodGhpcy5VYSxhKTt0aGlzLlNnLk9mW2FdPSEwfTtnLmY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJcIjt0aGlzLlJhJiYoYj10aGlzLlJhLmlkK1wiOlwiKTtDYihiLGFyZ3VtZW50cyl9O1xuZnVuY3Rpb24gZGkoYSxiLGMpe2EmJkRiKGZ1bmN0aW9uKCl7aWYoXCJva1wiPT1iKWEobnVsbCk7ZWxzZXt2YXIgZD0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGU9ZDtjJiYoZSs9XCI6IFwiK2MpO2U9RXJyb3IoZSk7ZS5jb2RlPWQ7YShlKX19KX07ZnVuY3Rpb24gamkoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKCl7fWEuZihcInRyYW5zYWN0aW9uIG9uIFwiK2IpO3ZhciBoPW5ldyBVKGEsYik7aC5FYihcInZhbHVlXCIsZik7Yz17cGF0aDpiLHVwZGF0ZTpjLEg6ZCxzdGF0dXM6bnVsbCxGZjpFYygpLGNmOmUsTGY6MCxpZTpmdW5jdGlvbigpe2guaWMoXCJ2YWx1ZVwiLGYpfSxrZTpudWxsLEJhOm51bGwscGQ6bnVsbCxxZDpudWxsLHJkOm51bGx9O2Q9YS5MLnphKGIsdm9pZCAwKXx8QztjLnBkPWQ7ZD1jLnVwZGF0ZShkLkkoKSk7aWYobihkKSl7Y2coXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsZCxjLnBhdGgpO2Muc3RhdHVzPTE7ZT1TZihhLnVjLGIpO3ZhciBrPWUuQ2EoKXx8W107ay5wdXNoKGMpO1RmKGUsayk7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmdihkLFwiLnByaW9yaXR5XCIpPyhrPXcoZCxcIi5wcmlvcml0eVwiKSxLKGFnKGspLFwiSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLlwiKSk6XG5rPShhLkwuemEoYil8fEMpLkMoKS5JKCk7ZT1haShhKTtkPU0oZCxrKTtlPXNjKGQsZSk7Yy5xZD1kO2MucmQ9ZTtjLkJhPWEuSGQrKztjPXdmKGEuTCxiLGUsYy5CYSxjLmNmKTtBYihhLmRhLGIsYyk7a2koYSl9ZWxzZSBjLmllKCksYy5xZD1udWxsLGMucmQ9bnVsbCxjLkgmJihhPW5ldyBRKGMucGQsbmV3IFUoYSxjLnBhdGgpLE4pLGMuSChudWxsLCExLGEpKX1mdW5jdGlvbiBraShhLGIpe3ZhciBjPWJ8fGEudWM7Ynx8bGkoYSxjKTtpZihudWxsIT09Yy5DYSgpKXt2YXIgZD1taShhLGMpO0soMDxkLmxlbmd0aCxcIlNlbmRpbmcgemVybyBsZW5ndGggdHJhbnNhY3Rpb24gcXVldWVcIik7U2EoZCxmdW5jdGlvbihhKXtyZXR1cm4gMT09PWEuc3RhdHVzfSkmJm5pKGEsYy5wYXRoKCksZCl9ZWxzZSBjLndkKCkmJmMuUChmdW5jdGlvbihiKXtraShhLGIpfSl9XG5mdW5jdGlvbiBuaShhLGIsYyl7Zm9yKHZhciBkPVFhKGMsZnVuY3Rpb24oYSl7cmV0dXJuIGEuQmF9KSxlPWEuTC56YShiLGQpfHxDLGQ9ZSxlPWUuaGFzaCgpLGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGg9Y1tmXTtLKDE9PT1oLnN0YXR1cyxcInRyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi5cIik7aC5zdGF0dXM9MjtoLkxmKys7dmFyIGs9VChiLGgucGF0aCksZD1kLkcoayxoLnFkKX1kPWQuSSghMCk7YS5iYS5wdXQoYi50b1N0cmluZygpLGQsZnVuY3Rpb24oZCl7YS5mKFwidHJhbnNhY3Rpb24gcHV0IHJlc3BvbnNlXCIse3BhdGg6Yi50b1N0cmluZygpLHN0YXR1czpkfSk7dmFyIGU9W107aWYoXCJva1wiPT09ZCl7ZD1bXTtmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKXtjW2ZdLnN0YXR1cz0zO2U9ZS5jb25jYXQoemYoYS5MLGNbZl0uQmEpKTtpZihjW2ZdLkgpe3ZhciBoPWNbZl0ucmQsaz1uZXcgVShhLGNbZl0ucGF0aCk7ZC5wdXNoKHEoY1tmXS5ILFxubnVsbCxudWxsLCEwLG5ldyBRKGgsayxOKSkpfWNbZl0uaWUoKX1saShhLFNmKGEudWMsYikpO2tpKGEpO0FiKGEuZGEsYixlKTtmb3IoZj0wO2Y8ZC5sZW5ndGg7ZisrKURiKGRbZl0pfWVsc2V7aWYoXCJkYXRhc3RhbGVcIj09PWQpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKyljW2ZdLnN0YXR1cz00PT09Y1tmXS5zdGF0dXM/NToxO2Vsc2UgZm9yKE8oXCJ0cmFuc2FjdGlvbiBhdCBcIitiLnRvU3RyaW5nKCkrXCIgZmFpbGVkOiBcIitkKSxmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9NSxjW2ZdLmtlPWQ7YmkoYSxiKX19LGUpfWZ1bmN0aW9uIGJpKGEsYil7dmFyIGM9b2koYSxiKSxkPWMucGF0aCgpLGM9bWkoYSxjKTtwaShhLGMsZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiBwaShhLGIsYyl7aWYoMCE9PWIubGVuZ3RoKXtmb3IodmFyIGQ9W10sZT1bXSxmPVFhKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuQmF9KSxoPTA7aDxiLmxlbmd0aDtoKyspe3ZhciBrPWJbaF0sbD1UKGMsay5wYXRoKSxtPSExLHQ7SyhudWxsIT09bCxcInJlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC5cIik7aWYoNT09PWsuc3RhdHVzKW09ITAsdD1rLmtlLGU9ZS5jb25jYXQoemYoYS5MLGsuQmEsITApKTtlbHNlIGlmKDE9PT1rLnN0YXR1cylpZigyNTw9ay5MZiltPSEwLHQ9XCJtYXhyZXRyeVwiLGU9ZS5jb25jYXQoemYoYS5MLGsuQmEsITApKTtlbHNle3ZhciB6PWEuTC56YShrLnBhdGgsZil8fEM7ay5wZD16O3ZhciBJPWJbaF0udXBkYXRlKHouSSgpKTtuKEkpPyhjZyhcInRyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCBcIixJLGsucGF0aCksbD1NKEkpLFwib2JqZWN0XCI9PT10eXBlb2YgSSYmbnVsbCE9XG5JJiZ2KEksXCIucHJpb3JpdHlcIil8fChsPWwuZ2Eoei5DKCkpKSx6PWsuQmEsST1haShhKSxJPXNjKGwsSSksay5xZD1sLGsucmQ9SSxrLkJhPWEuSGQrKyxWYShmLHopLGU9ZS5jb25jYXQod2YoYS5MLGsucGF0aCxJLGsuQmEsay5jZikpLGU9ZS5jb25jYXQoemYoYS5MLHosITApKSk6KG09ITAsdD1cIm5vZGF0YVwiLGU9ZS5jb25jYXQoemYoYS5MLGsuQmEsITApKSl9QWIoYS5kYSxjLGUpO2U9W107bSYmKGJbaF0uc3RhdHVzPTMsc2V0VGltZW91dChiW2hdLmllLE1hdGguZmxvb3IoMCkpLGJbaF0uSCYmKFwibm9kYXRhXCI9PT10PyhrPW5ldyBVKGEsYltoXS5wYXRoKSxkLnB1c2gocShiW2hdLkgsbnVsbCxudWxsLCExLG5ldyBRKGJbaF0ucGQsayxOKSkpKTpkLnB1c2gocShiW2hdLkgsbnVsbCxFcnJvcih0KSwhMSxudWxsKSkpKX1saShhLGEudWMpO2ZvcihoPTA7aDxkLmxlbmd0aDtoKyspRGIoZFtoXSk7a2koYSl9fVxuZnVuY3Rpb24gb2koYSxiKXtmb3IodmFyIGMsZD1hLnVjO251bGwhPT0oYz1FKGIpKSYmbnVsbD09PWQuQ2EoKTspZD1TZihkLGMpLGI9SChiKTtyZXR1cm4gZH1mdW5jdGlvbiBtaShhLGIpe3ZhciBjPVtdO3FpKGEsYixjKTtjLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5GZi1iLkZmfSk7cmV0dXJuIGN9ZnVuY3Rpb24gcWkoYSxiLGMpe3ZhciBkPWIuQ2EoKTtpZihudWxsIT09ZClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyljLnB1c2goZFtlXSk7Yi5QKGZ1bmN0aW9uKGIpe3FpKGEsYixjKX0pfWZ1bmN0aW9uIGxpKGEsYil7dmFyIGM9Yi5DYSgpO2lmKGMpe2Zvcih2YXIgZD0wLGU9MDtlPGMubGVuZ3RoO2UrKykzIT09Y1tlXS5zdGF0dXMmJihjW2RdPWNbZV0sZCsrKTtjLmxlbmd0aD1kO1RmKGIsMDxjLmxlbmd0aD9jOm51bGwpfWIuUChmdW5jdGlvbihiKXtsaShhLGIpfSl9XG5mdW5jdGlvbiBlaShhLGIpe3ZhciBjPW9pKGEsYikucGF0aCgpLGQ9U2YoYS51YyxiKTtXZihkLGZ1bmN0aW9uKGIpe3JpKGEsYil9KTtyaShhLGQpO1ZmKGQsZnVuY3Rpb24oYil7cmkoYSxiKX0pO3JldHVybiBjfVxuZnVuY3Rpb24gcmkoYSxiKXt2YXIgYz1iLkNhKCk7aWYobnVsbCE9PWMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9LTEsaD0wO2g8Yy5sZW5ndGg7aCsrKTQhPT1jW2hdLnN0YXR1cyYmKDI9PT1jW2hdLnN0YXR1cz8oSyhmPT09aC0xLFwiQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS5cIiksZj1oLGNbaF0uc3RhdHVzPTQsY1toXS5rZT1cInNldFwiKTooSygxPT09Y1toXS5zdGF0dXMsXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHN0YXR1cyBpbiBhYm9ydFwiKSxjW2hdLmllKCksZT1lLmNvbmNhdCh6ZihhLkwsY1toXS5CYSwhMCkpLGNbaF0uSCYmZC5wdXNoKHEoY1toXS5ILG51bGwsRXJyb3IoXCJzZXRcIiksITEsbnVsbCkpKSk7LTE9PT1mP1RmKGIsbnVsbCk6Yy5sZW5ndGg9ZisxO0FiKGEuZGEsYi5wYXRoKCksZSk7Zm9yKGg9MDtoPGQubGVuZ3RoO2grKylEYihkW2hdKX19O2Z1bmN0aW9uIFcoKXt0aGlzLm9jPXt9O3RoaXMuU2Y9ITF9Vy5wcm90b3R5cGUueWI9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5vYyl0aGlzLm9jW2FdLnliKCl9O1cucHJvdG90eXBlLnJjPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMub2MpdGhpcy5vY1thXS5yYygpfTtXLnByb3RvdHlwZS52ZT1mdW5jdGlvbigpe3RoaXMuU2Y9ITB9O2NhKFcpO1cucHJvdG90eXBlLmludGVycnVwdD1XLnByb3RvdHlwZS55YjtXLnByb3RvdHlwZS5yZXN1bWU9Vy5wcm90b3R5cGUucmM7ZnVuY3Rpb24gWChhLGIpe3RoaXMuYmQ9YTt0aGlzLnJhPWJ9WC5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKGEpe3goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5jYW5jZWxcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDEsYSwhMCk7dGhpcy5iZC5KZCh0aGlzLnJhLGF8fG51bGwpfTtYLnByb3RvdHlwZS5jYW5jZWw9WC5wcm90b3R5cGUuY2FuY2VsO1gucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsdGhpcy5yYSk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnJlbW92ZVwiLDEsYSwhMCk7ZmkodGhpcy5iZCx0aGlzLnJhLG51bGwsYSl9O1gucHJvdG90eXBlLnJlbW92ZT1YLnByb3RvdHlwZS5yZW1vdmU7XG5YLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0XCIsdGhpcy5yYSk7YmcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIixhLHRoaXMucmEsITEpO0EoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwyLGIsITApO2ZpKHRoaXMuYmQsdGhpcy5yYSxhLGIpfTtYLnByb3RvdHlwZS5zZXQ9WC5wcm90b3R5cGUuc2V0O1xuWC5wcm90b3R5cGUuS2I9ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLnJhKTtiZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsdGhpcy5yYSwhMSk7ZmcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0EoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO2dpKHRoaXMuYmQsdGhpcy5yYSxhLGIsYyl9O1gucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1YLnByb3RvdHlwZS5LYjtcblgucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIix0aGlzLnJhKTtpZihlYShhKSl7Zm9yKHZhciBjPXt9LGQ9MDtkPGEubGVuZ3RoOysrZCljW1wiXCIrZF09YVtkXTthPWM7TyhcIlBhc3NpbmcgYW4gQXJyYXkgdG8gRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byBvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi5cIil9ZWcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIixhLHRoaXMucmEpO0EoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIiwyLGIsITApO1xuaGkodGhpcy5iZCx0aGlzLnJhLGEsYil9O1gucHJvdG90eXBlLnVwZGF0ZT1YLnByb3RvdHlwZS51cGRhdGU7ZnVuY3Rpb24gWShhLGIsYyxkKXt0aGlzLms9YTt0aGlzLnBhdGg9Yjt0aGlzLm49Yzt0aGlzLmxjPWR9XG5mdW5jdGlvbiBzaShhKXt2YXIgYj1udWxsLGM9bnVsbDthLm1hJiYoYj1uZChhKSk7YS5wYSYmKGM9cGQoYSkpO2lmKGEuZz09PVFkKXtpZihhLm1hKXtpZihcIltNSU5fTkFNRV1cIiE9bWQoYSkpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS5cIik7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBiKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fWlmKGEucGEpe2lmKFwiW01BWF9OQU1FXVwiIT1vZChhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihcInN0cmluZ1wiIT09XG50eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuXCIpO319ZWxzZSBpZihhLmc9PT1OKXtpZihudWxsIT1iJiYhYWcoYil8fG51bGwhPWMmJiFhZyhjKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSB2YWxpZCBwcmlvcml0eSB2YWx1ZSAobnVsbCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nKS5cIik7fWVsc2UgaWYoSyhhLmcgaW5zdGFuY2VvZiBVZHx8YS5nPT09JGQsXCJ1bmtub3duIGluZGV4IHR5cGUuXCIpLG51bGwhPWImJlwib2JqZWN0XCI9PT10eXBlb2YgYnx8bnVsbCE9YyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LlwiKTtcbn1mdW5jdGlvbiB0aShhKXtpZihhLm1hJiZhLnBhJiZhLmphJiYoIWEuamF8fFwiXCI9PT1hLk5iKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBDYW4ndCBjb21iaW5lIHN0YXJ0QXQoKSwgZW5kQXQoKSwgYW5kIGxpbWl0KCkuIFVzZSBsaW1pdFRvRmlyc3QoKSBvciBsaW1pdFRvTGFzdCgpIGluc3RlYWQuXCIpO31mdW5jdGlvbiB1aShhLGIpe2lmKCEwPT09YS5sYyl0aHJvdyBFcnJvcihiK1wiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTt9Zz1ZLnByb3RvdHlwZTtnLkliPWZ1bmN0aW9uKCl7eChcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFUodGhpcy5rLHRoaXMucGF0aCl9O1xuZy5FYj1mdW5jdGlvbihhLGIsYyxkKXt4KFwiUXVlcnkub25cIiwyLDQsYXJndW1lbnRzLmxlbmd0aCk7Z2coXCJRdWVyeS5vblwiLGEsITEpO0EoXCJRdWVyeS5vblwiLDIsYiwhMSk7dmFyIGU9dmkoXCJRdWVyeS5vblwiLGMsZCk7aWYoXCJ2YWx1ZVwiPT09YSlpaSh0aGlzLmssdGhpcyxuZXcgaWQoYixlLmNhbmNlbHx8bnVsbCxlLk1hfHxudWxsKSk7ZWxzZXt2YXIgZj17fTtmW2FdPWI7aWkodGhpcy5rLHRoaXMsbmV3IGpkKGYsZS5jYW5jZWwsZS5NYSkpfXJldHVybiBifTtcbmcuaWM9ZnVuY3Rpb24oYSxiLGMpe3goXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7Z2coXCJRdWVyeS5vZmZcIixhLCEwKTtBKFwiUXVlcnkub2ZmXCIsMixiLCEwKTttYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBpZChifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgamQoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMuaztkPVwiLmluZm9cIj09PUUodGhpcy5wYXRoKT9lLkNkLmpiKHRoaXMsZCk6ZS5MLmpiKHRoaXMsZCk7eWIoZS5kYSx0aGlzLnBhdGgsZCl9O1xuZy5EZz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoaCl7ZiYmKGY9ITEsZS5pYyhhLGMpLGIuY2FsbChkLk1hLGgpKX14KFwiUXVlcnkub25jZVwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtnZyhcIlF1ZXJ5Lm9uY2VcIixhLCExKTtBKFwiUXVlcnkub25jZVwiLDIsYiwhMSk7dmFyIGQ9dmkoXCJRdWVyeS5vbmNlXCIsYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSksZT10aGlzLGY9ITA7dGhpcy5FYihhLGMsZnVuY3Rpb24oYil7ZS5pYyhhLGMpO2QuY2FuY2VsJiZkLmNhbmNlbC5jYWxsKGQuTWEsYil9KX07XG5nLkhlPWZ1bmN0aW9uKGEpe08oXCJRdWVyeS5saW1pdCgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgUXVlcnkubGltaXRUb0ZpcnN0KCkgb3IgUXVlcnkubGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTt4KFwiUXVlcnkubGltaXRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoIWdhKGEpfHxNYXRoLmZsb29yKGEpIT09YXx8MD49YSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmphKXRocm93IEVycm9yKFwiUXVlcnkubGltaXQ6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9ybGltaXRUb0xhc3QuXCIpO3ZhciBiPXRoaXMubi5IZShhKTt0aShiKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxiLHRoaXMubGMpfTtcbmcuSWU9ZnVuY3Rpb24oYSl7eChcIlF1ZXJ5LmxpbWl0VG9GaXJzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmphKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5JZShhKSx0aGlzLmxjKX07XG5nLkplPWZ1bmN0aW9uKGEpe3goXCJRdWVyeS5saW1pdFRvTGFzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4uamEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsIGxpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLlwiKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCx0aGlzLm4uSmUoYSksdGhpcy5sYyl9O1xuZy5FZz1mdW5jdGlvbihhKXt4KFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKFwiJGtleVwiPT09YSl0aHJvdyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO2lmKFwiJHByaW9yaXR5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO2lmKFwiJHZhbHVlXCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO2lnKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsYSk7dWkodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlDaGlsZFwiKTt2YXIgYj1uZXcgTChhKTtpZihiLmUoKSl0aHJvdyBFcnJvcihcIlF1ZXJ5Lm9yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLlwiKTtcbmI9bmV3IFVkKGIpO2I9ZGUodGhpcy5uLGIpO3NpKGIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGIsITApfTtnLkZnPWZ1bmN0aW9uKCl7eChcIlF1ZXJ5Lm9yZGVyQnlLZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7dWkodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlLZXlcIik7dmFyIGE9ZGUodGhpcy5uLFFkKTtzaShhKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxhLCEwKX07Zy5HZz1mdW5jdGlvbigpe3goXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7dWkodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiKTt2YXIgYT1kZSh0aGlzLm4sTik7c2koYSk7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1xuZy5IZz1mdW5jdGlvbigpe3goXCJRdWVyeS5vcmRlckJ5VmFsdWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7dWkodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiKTt2YXIgYT1kZSh0aGlzLm4sJGQpO3NpKGEpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtnLiRkPWZ1bmN0aW9uKGEsYil7eChcIlF1ZXJ5LnN0YXJ0QXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7YmcoXCJRdWVyeS5zdGFydEF0XCIsYSx0aGlzLnBhdGgsITApO2hnKFwiUXVlcnkuc3RhcnRBdFwiLGIpO3ZhciBjPXRoaXMubi4kZChhLGIpO3RpKGMpO3NpKGMpO2lmKHRoaXMubi5tYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LnN0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQgb3IgZXF1YWxUbykuXCIpO24oYSl8fChiPWE9bnVsbCk7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYyx0aGlzLmxjKX07XG5nLnRkPWZ1bmN0aW9uKGEsYil7eChcIlF1ZXJ5LmVuZEF0XCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO2JnKFwiUXVlcnkuZW5kQXRcIixhLHRoaXMucGF0aCwhMCk7aGcoXCJRdWVyeS5lbmRBdFwiLGIpO3ZhciBjPXRoaXMubi50ZChhLGIpO3RpKGMpO3NpKGMpO2lmKHRoaXMubi5wYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVuZEF0OiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5sYyl9O1xuZy5rZz1mdW5jdGlvbihhLGIpe3goXCJRdWVyeS5lcXVhbFRvXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2JnKFwiUXVlcnkuZXF1YWxUb1wiLGEsdGhpcy5wYXRoLCExKTtoZyhcIlF1ZXJ5LmVxdWFsVG9cIixiKTtpZih0aGlzLm4ubWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7aWYodGhpcy5uLnBhKXRocm93IEVycm9yKFwiUXVlcnkuZXF1YWxUbzogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtyZXR1cm4gdGhpcy4kZChhLGIpLnRkKGEsYil9O1xuZy50b1N0cmluZz1mdW5jdGlvbigpe3goXCJRdWVyeS50b1N0cmluZ1wiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGE9dGhpcy5wYXRoLGI9XCJcIixjPWEuWjtjPGEuby5sZW5ndGg7YysrKVwiXCIhPT1hLm9bY10mJihiKz1cIi9cIitlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGEub1tjXSkpKTtyZXR1cm4gdGhpcy5rLnRvU3RyaW5nKCkrKGJ8fFwiL1wiKX07Zy52YT1mdW5jdGlvbigpe3ZhciBhPVVjKGVlKHRoaXMubikpO3JldHVyblwie31cIj09PWE/XCJkZWZhdWx0XCI6YX07XG5mdW5jdGlvbiB2aShhLGIsYyl7dmFyIGQ9e2NhbmNlbDpudWxsLE1hOm51bGx9O2lmKGImJmMpZC5jYW5jZWw9YixBKGEsMyxkLmNhbmNlbCwhMCksZC5NYT1jLG1iKGEsNCxkLk1hKTtlbHNlIGlmKGIpaWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09YilkLk1hPWI7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilkLmNhbmNlbD1iO2Vsc2UgdGhyb3cgRXJyb3IoeShhLDMsITApK1wiIG11c3QgZWl0aGVyIGJlIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dCBvYmplY3QuXCIpO3JldHVybiBkfVkucHJvdG90eXBlLnJlZj1ZLnByb3RvdHlwZS5JYjtZLnByb3RvdHlwZS5vbj1ZLnByb3RvdHlwZS5FYjtZLnByb3RvdHlwZS5vZmY9WS5wcm90b3R5cGUuaWM7WS5wcm90b3R5cGUub25jZT1ZLnByb3RvdHlwZS5EZztZLnByb3RvdHlwZS5saW1pdD1ZLnByb3RvdHlwZS5IZTtZLnByb3RvdHlwZS5saW1pdFRvRmlyc3Q9WS5wcm90b3R5cGUuSWU7XG5ZLnByb3RvdHlwZS5saW1pdFRvTGFzdD1ZLnByb3RvdHlwZS5KZTtZLnByb3RvdHlwZS5vcmRlckJ5Q2hpbGQ9WS5wcm90b3R5cGUuRWc7WS5wcm90b3R5cGUub3JkZXJCeUtleT1ZLnByb3RvdHlwZS5GZztZLnByb3RvdHlwZS5vcmRlckJ5UHJpb3JpdHk9WS5wcm90b3R5cGUuR2c7WS5wcm90b3R5cGUub3JkZXJCeVZhbHVlPVkucHJvdG90eXBlLkhnO1kucHJvdG90eXBlLnN0YXJ0QXQ9WS5wcm90b3R5cGUuJGQ7WS5wcm90b3R5cGUuZW5kQXQ9WS5wcm90b3R5cGUudGQ7WS5wcm90b3R5cGUuZXF1YWxUbz1ZLnByb3RvdHlwZS5rZztZLnByb3RvdHlwZS50b1N0cmluZz1ZLnByb3RvdHlwZS50b1N0cmluZzt2YXIgWj17fTtaLnZjPUtoO1ouRGF0YUNvbm5lY3Rpb249Wi52YztLaC5wcm90b3R5cGUuUmc9ZnVuY3Rpb24oYSxiKXt0aGlzLkZhKFwicVwiLHtwOmF9LGIpfTtaLnZjLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW49Wi52Yy5wcm90b3R5cGUuUmc7S2gucHJvdG90eXBlLmpnPWZ1bmN0aW9uKGEsYil7dGhpcy5GYShcImVjaG9cIix7ZDphfSxiKX07Wi52Yy5wcm90b3R5cGUuZWNobz1aLnZjLnByb3RvdHlwZS5qZztLaC5wcm90b3R5cGUuaW50ZXJydXB0PUtoLnByb3RvdHlwZS55YjtaLlZmPXloO1ouUmVhbFRpbWVDb25uZWN0aW9uPVouVmY7eWgucHJvdG90eXBlLnNlbmRSZXF1ZXN0PXloLnByb3RvdHlwZS5GYTt5aC5wcm90b3R5cGUuY2xvc2U9eWgucHJvdG90eXBlLmNsb3NlO1xuWi5yZz1mdW5jdGlvbihhKXt2YXIgYj1LaC5wcm90b3R5cGUucHV0O0toLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYyxkLGUsZil7bihmKSYmKGY9YSgpKTtiLmNhbGwodGhpcyxjLGQsZSxmKX07cmV0dXJuIGZ1bmN0aW9uKCl7S2gucHJvdG90eXBlLnB1dD1ifX07Wi5oaWphY2tIYXNoPVoucmc7Wi5VZj16YztaLkNvbm5lY3Rpb25UYXJnZXQ9Wi5VZjtaLnZhPWZ1bmN0aW9uKGEpe3JldHVybiBhLnZhKCl9O1oucXVlcnlJZGVudGlmaWVyPVoudmE7Wi50Zz1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLlJhLiR9O1oubGlzdGVucz1aLnRnO1oudmU9ZnVuY3Rpb24oYSl7YS52ZSgpfTtaLmZvcmNlUmVzdENsaWVudD1aLnZlO2Z1bmN0aW9uIFUoYSxiKXt2YXIgYyxkLGU7aWYoYSBpbnN0YW5jZW9mIFloKWM9YSxkPWI7ZWxzZXt4KFwibmV3IEZpcmViYXNlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2Q9UGMoYXJndW1lbnRzWzBdKTtjPWQuVGc7XCJmaXJlYmFzZVwiPT09ZC5kb21haW4mJk9jKGQuaG9zdCtcIiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkXCIpO2MmJlwidW5kZWZpbmVkXCIhPWN8fE9jKFwiQ2Fubm90IHBhcnNlIEZpcmViYXNlIHVybC4gUGxlYXNlIHVzZSBodHRwczovLzxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbVwiKTtkLmtifHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93LmxvY2F0aW9uJiZ3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wmJi0xIT09d2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwczpcIikmJk8oXCJJbnNlY3VyZSBGaXJlYmFzZSBhY2Nlc3MgZnJvbSBhIHNlY3VyZSBwYWdlLiBQbGVhc2UgdXNlIGh0dHBzIGluIGNhbGxzIHRvIG5ldyBGaXJlYmFzZSgpLlwiKTtcbmM9bmV3IHpjKGQuaG9zdCxkLmtiLGMsXCJ3c1wiPT09ZC5zY2hlbWV8fFwid3NzXCI9PT1kLnNjaGVtZSk7ZD1uZXcgTChkLiRjKTtlPWQudG9TdHJpbmcoKTt2YXIgZjshKGY9IXAoYy5ob3N0KXx8MD09PWMuaG9zdC5sZW5ndGh8fCEkZihjLmhjKSkmJihmPTAhPT1lLmxlbmd0aCkmJihlJiYoZT1lLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSksZj0hKHAoZSkmJjAhPT1lLmxlbmd0aCYmIVlmLnRlc3QoZSkpKTtpZihmKXRocm93IEVycm9yKHkoXCJuZXcgRmlyZWJhc2VcIiwxLCExKSsnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgdGhlIHBhdGggY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIi4nKTtpZihiKWlmKGIgaW5zdGFuY2VvZiBXKWU9YjtlbHNlIGlmKHAoYikpZT1XLnViKCksYy5PZD1iO2Vsc2UgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBhIHZhbGlkIEZpcmViYXNlLkNvbnRleHQgZm9yIHNlY29uZCBhcmd1bWVudCB0byBuZXcgRmlyZWJhc2UoKVwiKTtcbmVsc2UgZT1XLnViKCk7Zj1jLnRvU3RyaW5nKCk7dmFyIGg9dyhlLm9jLGYpO2h8fChoPW5ldyBZaChjLGUuU2YpLGUub2NbZl09aCk7Yz1ofVkuY2FsbCh0aGlzLGMsZCxiZSwhMSl9bWEoVSxZKTt2YXIgd2k9VSx4aT1bXCJGaXJlYmFzZVwiXSx5aT1hYTt4aVswXWluIHlpfHwheWkuZXhlY1NjcmlwdHx8eWkuZXhlY1NjcmlwdChcInZhciBcIit4aVswXSk7Zm9yKHZhciB6aTt4aS5sZW5ndGgmJih6aT14aS5zaGlmdCgpKTspIXhpLmxlbmd0aCYmbih3aSk/eWlbemldPXdpOnlpPXlpW3ppXT95aVt6aV06eWlbemldPXt9O1UuZ29PZmZsaW5lPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLmdvT2ZmbGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtXLnViKCkueWIoKX07VS5nb09ubGluZT1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5nb09ubGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtXLnViKCkucmMoKX07XG5mdW5jdGlvbiBMYyhhLGIpe0soIWJ8fCEwPT09YXx8ITE9PT1hLFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpOyEwPT09YT8oXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnNvbGUubG9nP0JiPXEoY29uc29sZS5sb2csY29uc29sZSk6XCJvYmplY3RcIj09PXR5cGVvZiBjb25zb2xlLmxvZyYmKEJiPWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKGEpfSkpLGImJnljLnNldChcImxvZ2dpbmdfZW5hYmxlZFwiLCEwKSk6YT9CYj1hOihCYj1udWxsLHljLnJlbW92ZShcImxvZ2dpbmdfZW5hYmxlZFwiKSl9VS5lbmFibGVMb2dnaW5nPUxjO1UuU2VydmVyVmFsdWU9e1RJTUVTVEFNUDp7XCIuc3ZcIjpcInRpbWVzdGFtcFwifX07VS5TREtfVkVSU0lPTj1oYjtVLklOVEVSTkFMPVY7VS5Db250ZXh0PVc7VS5URVNUX0FDQ0VTUz1aO1xuVS5wcm90b3R5cGUubmFtZT1mdW5jdGlvbigpe08oXCJGaXJlYmFzZS5uYW1lKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZS5rZXkoKSBpbnN0ZWFkLlwiKTt4KFwiRmlyZWJhc2UubmFtZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rZXkoKX07VS5wcm90b3R5cGUubmFtZT1VLnByb3RvdHlwZS5uYW1lO1UucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMucGF0aC5lKCk/bnVsbDpMZCh0aGlzLnBhdGgpfTtVLnByb3RvdHlwZS5rZXk9VS5wcm90b3R5cGUua2V5O1xuVS5wcm90b3R5cGUudT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UuY2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoZ2EoYSkpYT1TdHJpbmcoYSk7ZWxzZSBpZighKGEgaW5zdGFuY2VvZiBMKSlpZihudWxsPT09RSh0aGlzLnBhdGgpKXt2YXIgYj1hO2ImJihiPWIucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKTtpZyhcIkZpcmViYXNlLmNoaWxkXCIsYil9ZWxzZSBpZyhcIkZpcmViYXNlLmNoaWxkXCIsYSk7cmV0dXJuIG5ldyBVKHRoaXMuayx0aGlzLnBhdGgudShhKSl9O1UucHJvdG90eXBlLmNoaWxkPVUucHJvdG90eXBlLnU7VS5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLnBhcmVudFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt2YXIgYT10aGlzLnBhdGgucGFyZW50KCk7cmV0dXJuIG51bGw9PT1hP251bGw6bmV3IFUodGhpcy5rLGEpfTtVLnByb3RvdHlwZS5wYXJlbnQ9VS5wcm90b3R5cGUucGFyZW50O1xuVS5wcm90b3R5cGUucm9vdD1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5yZWZcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7Zm9yKHZhciBhPXRoaXM7bnVsbCE9PWEucGFyZW50KCk7KWE9YS5wYXJlbnQoKTtyZXR1cm4gYX07VS5wcm90b3R5cGUucm9vdD1VLnByb3RvdHlwZS5yb290O1UucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5zZXRcIix0aGlzLnBhdGgpO2JnKFwiRmlyZWJhc2Uuc2V0XCIsYSx0aGlzLnBhdGgsITEpO0EoXCJGaXJlYmFzZS5zZXRcIiwyLGIsITApO3RoaXMuay5LYih0aGlzLnBhdGgsYSxudWxsLGJ8fG51bGwpfTtVLnByb3RvdHlwZS5zZXQ9VS5wcm90b3R5cGUuc2V0O1xuVS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO08oXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfWVnKFwiRmlyZWJhc2UudXBkYXRlXCIsYSx0aGlzLnBhdGgpO0EoXCJGaXJlYmFzZS51cGRhdGVcIiwyLGIsITApO3RoaXMuay51cGRhdGUodGhpcy5wYXRoLGEsYnx8bnVsbCl9O1UucHJvdG90eXBlLnVwZGF0ZT1VLnByb3RvdHlwZS51cGRhdGU7XG5VLnByb3RvdHlwZS5LYj1mdW5jdGlvbihhLGIsYyl7eChcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLHRoaXMucGF0aCk7YmcoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIixhLHRoaXMucGF0aCwhMSk7ZmcoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0EoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7dGhpcy5rLktiKHRoaXMucGF0aCxhLGIsY3x8bnVsbCl9O1UucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1VLnByb3RvdHlwZS5LYjtcblUucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UucmVtb3ZlXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2UucmVtb3ZlXCIsdGhpcy5wYXRoKTtBKFwiRmlyZWJhc2UucmVtb3ZlXCIsMSxhLCEwKTt0aGlzLnNldChudWxsLGEpfTtVLnByb3RvdHlwZS5yZW1vdmU9VS5wcm90b3R5cGUucmVtb3ZlO1xuVS5wcm90b3R5cGUudHJhbnNhY3Rpb249ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsdGhpcy5wYXRoKTtBKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwxLGEsITEpO0EoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDIsYiwhMCk7aWYobihjKSYmXCJib29sZWFuXCIhPXR5cGVvZiBjKXRocm93IEVycm9yKHkoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDMsITApK1wibXVzdCBiZSBhIGJvb2xlYW4uXCIpO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2UudHJhbnNhY3Rpb24gZmFpbGVkOiBcIit0aGlzLmtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPSEwKTtqaSh0aGlzLmssdGhpcy5wYXRoLGEsYnx8bnVsbCxjKX07VS5wcm90b3R5cGUudHJhbnNhY3Rpb249VS5wcm90b3R5cGUudHJhbnNhY3Rpb247XG5VLnByb3RvdHlwZS5PZz1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsdGhpcy5wYXRoKTtmZyhcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMSxhKTtBKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwyLGIsITApO3RoaXMuay5LYih0aGlzLnBhdGgudShcIi5wcmlvcml0eVwiKSxhLG51bGwsYil9O1UucHJvdG90eXBlLnNldFByaW9yaXR5PVUucHJvdG90eXBlLk9nO1xuVS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5wdXNoXCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2UucHVzaFwiLHRoaXMucGF0aCk7YmcoXCJGaXJlYmFzZS5wdXNoXCIsYSx0aGlzLnBhdGgsITApO0EoXCJGaXJlYmFzZS5wdXNoXCIsMixiLCEwKTt2YXIgYz0kaCh0aGlzLmspLGM9RmUoYyksYz10aGlzLnUoYyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiZudWxsIT09YSYmYy5zZXQoYSxiKTtyZXR1cm4gY307VS5wcm90b3R5cGUucHVzaD1VLnByb3RvdHlwZS5wdXNoO1UucHJvdG90eXBlLmhiPWZ1bmN0aW9uKCl7amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3RcIix0aGlzLnBhdGgpO3JldHVybiBuZXcgWCh0aGlzLmssdGhpcy5wYXRoKX07VS5wcm90b3R5cGUub25EaXNjb25uZWN0PVUucHJvdG90eXBlLmhiO1xuVS5wcm90b3R5cGUuTT1mdW5jdGlvbihhLGIsYyl7TyhcIkZpcmViYXNlUmVmLmF1dGgoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlUmVmLmF1dGhXaXRoQ3VzdG9tVG9rZW4oKSBpbnN0ZWFkLlwiKTt4KFwiRmlyZWJhc2UuYXV0aFwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTtrZyhcIkZpcmViYXNlLmF1dGhcIixhKTtBKFwiRmlyZWJhc2UuYXV0aFwiLDIsYiwhMCk7QShcIkZpcmViYXNlLmF1dGhcIiwzLGIsITApO1lnKHRoaXMuay5NLGEse30se3JlbWVtYmVyOlwibm9uZVwifSxiLGMpfTtVLnByb3RvdHlwZS5hdXRoPVUucHJvdG90eXBlLk07VS5wcm90b3R5cGUuZ2U9ZnVuY3Rpb24oYSl7eChcIkZpcmViYXNlLnVuYXV0aFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtBKFwiRmlyZWJhc2UudW5hdXRoXCIsMSxhLCEwKTtaZyh0aGlzLmsuTSxhKX07VS5wcm90b3R5cGUudW5hdXRoPVUucHJvdG90eXBlLmdlO1xuVS5wcm90b3R5cGUueGU9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuZ2V0QXV0aFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rLk0ueGUoKX07VS5wcm90b3R5cGUuZ2V0QXV0aD1VLnByb3RvdHlwZS54ZTtVLnByb3RvdHlwZS54Zz1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5vbkF1dGhcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7QShcIkZpcmViYXNlLm9uQXV0aFwiLDEsYSwhMSk7bWIoXCJGaXJlYmFzZS5vbkF1dGhcIiwyLGIpO3RoaXMuay5NLkViKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtVLnByb3RvdHlwZS5vbkF1dGg9VS5wcm90b3R5cGUueGc7VS5wcm90b3R5cGUud2c9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtBKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsYSwhMSk7bWIoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMixiKTt0aGlzLmsuTS5pYyhcImF1dGhfc3RhdHVzXCIsYSxiKX07VS5wcm90b3R5cGUub2ZmQXV0aD1VLnByb3RvdHlwZS53ZztcblUucHJvdG90eXBlLlpmPWZ1bmN0aW9uKGEsYixjKXt4KFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtrZyhcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIixhKTtBKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsYiwhMSk7bmcoXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMyxjLCEwKTtZZyh0aGlzLmsuTSxhLHt9LGN8fHt9LGIpfTtVLnByb3RvdHlwZS5hdXRoV2l0aEN1c3RvbVRva2VuPVUucHJvdG90eXBlLlpmO1UucHJvdG90eXBlLiRmPWZ1bmN0aW9uKGEsYixjKXt4KFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFBvcHVwXCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO21nKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFBvcHVwXCIsYSk7QShcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDIsYiwhMSk7bmcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwzLGMsITApO2NoKHRoaXMuay5NLGEsYyxiKX07XG5VLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUG9wdXA9VS5wcm90b3R5cGUuJGY7VS5wcm90b3R5cGUuYWc9ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7bWcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIixhKTtBKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFJlZGlyZWN0XCIsMixiLCExKTtuZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDMsYywhMCk7dmFyIGQ9dGhpcy5rLk07YWgoZCk7dmFyIGU9W0tnXSxmPXZnKGMpO1wiYW5vbnltb3VzXCI9PT1hfHxcImZpcmViYXNlXCI9PT1hP1AoYixNZyhcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSk6KHljLnNldChcInJlZGlyZWN0X2NsaWVudF9vcHRpb25zXCIsZi5vZCksYmgoZCxlLFwiL2F1dGgvXCIrYSxmLGIpKX07VS5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFJlZGlyZWN0PVUucHJvdG90eXBlLmFnO1xuVS5wcm90b3R5cGUuYmc9ZnVuY3Rpb24oYSxiLGMsZCl7eChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDMsNCxhcmd1bWVudHMubGVuZ3RoKTttZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLGEpO0EoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLGMsITEpO25nKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsNCxkLCEwKTtwKGIpPyhsZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiksJGcodGhpcy5rLk0sYStcIi90b2tlblwiLHthY2Nlc3NfdG9rZW46Yn0sZCxjKSk6KG5nKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMixiLCExKSwkZyh0aGlzLmsuTSxhK1wiL3Rva2VuXCIsYixkLGMpKX07VS5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFRva2VuPVUucHJvdG90eXBlLmJnO1xuVS5wcm90b3R5cGUuWWY9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0EoXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwxLGEsITEpO25nKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMixiLCEwKTskZyh0aGlzLmsuTSxcImFub255bW91c1wiLHt9LGIsYSl9O1UucHJvdG90eXBlLmF1dGhBbm9ueW1vdXNseT1VLnByb3RvdHlwZS5ZZjtcblUucHJvdG90eXBlLmNnPWZ1bmN0aW9uKGEsYixjKXt4KFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtuZyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwxLGEsITEpO29nKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLGEsXCJlbWFpbFwiKTtvZyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIixhLFwicGFzc3dvcmRcIik7QShcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwyLGIsITEpO25nKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDMsYywhMCk7JGcodGhpcy5rLk0sXCJwYXNzd29yZFwiLGEsYyxiKX07VS5wcm90b3R5cGUuYXV0aFdpdGhQYXNzd29yZD1VLnByb3RvdHlwZS5jZztcblUucHJvdG90eXBlLnNlPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMSxhLCExKTtvZyhcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIixhLFwiZW1haWxcIik7b2coXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0EoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMixiLCExKTt0aGlzLmsuTS5zZShhLGIpfTtVLnByb3RvdHlwZS5jcmVhdGVVc2VyPVUucHJvdG90eXBlLnNlO1UucHJvdG90eXBlLlRlPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMSxhLCExKTtvZyhcIkZpcmViYXNlLnJlbW92ZVVzZXJcIixhLFwiZW1haWxcIik7b2coXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0EoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMixiLCExKTt0aGlzLmsuTS5UZShhLGIpfTtcblUucHJvdG90eXBlLnJlbW92ZVVzZXI9VS5wcm90b3R5cGUuVGU7VS5wcm90b3R5cGUucGU9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLDEsYSwhMSk7b2coXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJlbWFpbFwiKTtvZyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcIm9sZFBhc3N3b3JkXCIpO29nKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwibmV3UGFzc3dvcmRcIik7QShcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuTS5wZShhLGIpfTtVLnByb3RvdHlwZS5jaGFuZ2VQYXNzd29yZD1VLnByb3RvdHlwZS5wZTtcblUucHJvdG90eXBlLm9lPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO25nKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwxLGEsITEpO29nKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwib2xkRW1haWxcIik7b2coXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJuZXdFbWFpbFwiKTtvZyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcInBhc3N3b3JkXCIpO0EoXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLDIsYiwhMSk7dGhpcy5rLk0ub2UoYSxiKX07VS5wcm90b3R5cGUuY2hhbmdlRW1haWw9VS5wcm90b3R5cGUub2U7XG5VLnByb3RvdHlwZS5WZT1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO25nKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDEsYSwhMSk7b2coXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0EoXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuTS5WZShhLGIpfTtVLnByb3RvdHlwZS5yZXNldFBhc3N3b3JkPVUucHJvdG90eXBlLlZlO30pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlyZWJhc2U7XG4iXX0=
