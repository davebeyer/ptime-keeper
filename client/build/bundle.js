(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/dave/lh2/angular2/study-tracker/client/app/main.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
require("firebase");
require("bootstrap");
var angular2_1 = require('angular2/angular2');
var router_1 = require('angular2/router');
var router_2 = require('angular2/router');
var router_3 = require('angular2/router');
var users_1 = require('./users');
var signin_1 = require('./signin');
var plan_1 = require('./plan');
var Firebase = require('firebase/lib/firebase-web.js');
var StudyTracker = (function () {
    function StudyTracker(router) {
        this.router = router;
        this.fbRef = new Firebase('https://study-tracker.firebaseio.com');
        console.log("main.ts: in StudyTracker constructor");
    }
    StudyTracker.prototype.registerUserBlock = function (userComp) {
        this.userBlock = userComp;
        userComp.registerParent(this, this.fbRef);
        // NOTE: here we use the router *name* not the actual route URL!
        this.router.navigate(['./Plan']); // SignIn
    };
    StudyTracker = __decorate([
        angular2_1.Component({
            selector: 'app'
        }),
        angular2_1.View({
            directives: [router_3.RouterLink, router_3.RouterOutlet, users_1.UserBlock],
            template: "\n        <user-block (initevent)=\"registerUserBlock($event)\"> </user-block>\n\n        <div class=\"container\">\n          <router-outlet></router-outlet>\n        </div>\n        "
        }),
        router_1.RouteConfig([
            { path: '/plan', as: 'Plan', component: plan_1.Plan },
            { path: '/signin', as: 'SignIn', component: signin_1.SignIn }
        ]), 
        __metadata('design:paramtypes', [router_1.Router])
    ], StudyTracker);
    return StudyTracker;
})();
// similar to jQuery(document).ready(), but doesn't work in old IE browsers
document.addEventListener('DOMContentLoaded', function () {
    angular2_1.bootstrap(StudyTracker, 
    // List of universally injectable providers
    [
        router_1.ROUTER_PROVIDERS,
        angular2_1.provide(router_2.LocationStrategy, { useClass: router_2.HashLocationStrategy })
    ]);
}, false);

},{"./plan":"/Users/dave/lh2/angular2/study-tracker/client/app/plan.ts","./signin":"/Users/dave/lh2/angular2/study-tracker/client/app/signin.ts","./users":"/Users/dave/lh2/angular2/study-tracker/client/app/users.ts","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js","bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/dist/js/npm.js","firebase":"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js","firebase/lib/firebase-web.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/plan.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
var Plan = (function () {
    function Plan() {
        console.log("plan.ts: in constructor");
        var data = [{ id: 1, color: 'blue', name: 'Science' },
            { id: 2, color: 'red', name: 'Math' },
            { id: 3, color: '#AA22BB', name: 'English' },
            { id: 4, color: '#222', name: 'Art' }];
        jQuery("#category-select").typeahead({
            source: data,
            minLength: 0,
            showHintOnFocus: true,
            addItem: { id: -1, name: '(Add class)' },
            formatter: function (item) {
                var html = this.highlighter(this.displayText(item));
                if (item.color) {
                    html = '<div class="dropdown-color-box" style="background-color:' + item.color + '"> </div>' + html;
                }
                else {
                    html = '<div class="dropdown-color-box"> </div>' + html;
                }
                return html;
            },
            afterSelect: function (item) {
                console.log("Selected", item);
                if (item.id === -2) {
                    jQuery("#category-add-name").text(item.name);
                    jQuery("#category-add").show();
                }
            },
            updater: function (item) {
                if (item.id === -1) {
                    return { id: -2, name: this.$element.val() };
                }
                else {
                    return item;
                }
            }
        });
        // Fix for bug in IOS as reported:
        // http://stackoverflow.com/questions/12190783/why-doesnt-bootstrap-button-dropdown-work-on-ios
        jQuery('body').on('touchstart.dropdown', '.dropdown-menu', function (e) {
            e.stopPropagation();
        });
    }
    Plan = __decorate([
        angular2_1.Component({
            selector: 'plan'
        }),
        angular2_1.View({
            template: "\n          <input type=\"text\" data-provide=\"typeahead\" id=\"category-select\" placeholder=\"Enter a class\">\n\n          <div class=\"collapse\" id=\"category-add\">\n  \t    Select a color for new class <b id=\"category-add-name\"></b>\n          </div>\n        "
        }), 
        __metadata('design:paramtypes', [])
    ], Plan);
    return Plan;
})();
exports.Plan = Plan;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/signin.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
/// <reference path="../../typings/requirejs/require.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
require("firebase");
var angular2_1 = require('angular2/angular2');
var router_1 = require('angular2/router');
var Firebase = require('firebase/lib/firebase-web.js');
var SignIn = (function () {
    function SignIn() {
    }
    SignIn = __decorate([
        angular2_1.Component({
            selector: 'signin'
        }),
        angular2_1.View({
            directives: [router_1.RouterLink],
            template: "\n        <h1> Please sign in </h1>\n        "
        }), 
        __metadata('design:paramtypes', [])
    ], SignIn);
    return SignIn;
})();
exports.SignIn = SignIn;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js","firebase":"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js","firebase/lib/firebase-web.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js"}],"/Users/dave/lh2/angular2/study-tracker/client/app/users.ts":[function(require,module,exports){
/// <reference path="../../node_modules/angular2/angular2.d.ts" />
/// <reference path="../../typings/firebase/firebase.d.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var angular2_1 = require('angular2/angular2');
exports.User = {};
var UserBlock = (function () {
    function UserBlock() {
        console.log("users.ts: in UserBlock constructor");
        // Only initialize locally instatiated data here 
        // (angular2-dependent data has not yet been fully initialized)
        this.initevent = new angular2_1.EventEmitter();
        this.parent = null; // will be set by the parent
        this.fbRef = null;
        this.user = exports.User;
        // Initialize
        this.updateUserData(null);
        console.log("users.ts: finished UserBlock constructor");
    }
    UserBlock.prototype.onInit = function () {
        // onInit() is a angular2 lifecycle method called 
        // automatically after angular2 has completed initialization
        console.log("onInit: for Users Component", this);
        this.initevent.next(this); // send initevent to parent component
    };
    UserBlock.prototype.registerParent = function (parent, fbRef) {
        var self = this;
        this.fbRef = fbRef;
        this.parent = parent;
        // Register the authentication callback
        this.fbRef.onAuth(function (authData) {
            self.updateUserData(authData);
        });
    };
    UserBlock.prototype.login = function (provider) {
        var self = this;
        if (provider === 'facebook') {
            alert("Sorry, Facebook signin not yet supported");
            return;
        }
        this.fbRef.authWithOAuthPopup(provider, function (error, authData) {
            if (error) {
                if (error.code === "TRANSPORT_UNAVAILABLE") {
                    // Could be due to not allowing pop-ups in this env
                    self.fbRef.authWithOAuthRedirect("google", function (error) {
                        if (error) {
                            console.log("Login Failed!", error);
                        }
                    });
                }
                else {
                    console.log("Login Failed!", error);
                }
            }
            else if (authData) {
                self.updateUserData(authData); // accelerate the process a little
                console.log("Authenticated successfully with payload:", authData);
            }
            else {
                console.log("Login apparently failed, but without error info");
            }
        });
    };
    UserBlock.prototype.logout = function () {
        this.fbRef.unauth();
        this.updateUserData(null);
    };
    UserBlock.prototype.updateUserData = function (authData) {
        this.user._authData = authData;
        var provider;
        if (authData) {
            provider = authData.provider;
        }
        else {
            provider = null;
        }
        switch (provider) {
            case 'google':
                this.user.isLoggedIn = true;
                this.user.firstName = this.user._authData.google.cachedUserProfile.given_name;
                this.user.lastName = this.user._authData.google.cachedUserProfile.family_name;
                this.user.profileImageURL = this.user._authData.google.profileImageURL;
                break;
            default:
                this.user.isLoggedIn = false;
                this.user.firstName = null;
                this.user.lastName = null;
                this.user.profileImageURL = null;
                break;
        }
    };
    UserBlock = __decorate([
        angular2_1.Component({
            selector: 'user-block',
            events: ['initevent'] // NOTE that event names must be all lower case
        }),
        angular2_1.View({
            template: "\n      <div class=\"container\">\n        <div class=\"signin-form\">\n          <div [hidden]=\"user.isLoggedIn\">\n            <h3 class=\"form-signin-heading\">Please sign in using:</h3>\n            <button class=\"btn btn-lg btn-primary btn-block\" (click)=\"login('google')\">  Google  </button>\n            <button class=\"btn btn-lg btn-primary btn-block\" (click)=\"login('facebook')\">Facebook</button>\n          </div>\n\n          <div [hidden]=\"!user.isLoggedIn\">\n            Hello {{user.firstName}} <img src=\"{{user.profileImageURL}}\"/> \n            <a class=\"btn\" (click)=\"logout()\">\n              Sign out\n            </a>\n          </div>\n        </div>\n      </div>\n      "
        }), 
        __metadata('design:paramtypes', [])
    ], UserBlock);
    return UserBlock;
})();
exports.UserBlock = UserBlock;

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./core'));
__export(require('./profile'));
__export(require('./lifecycle_hooks'));
__export(require('./bootstrap'));

},{"./bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/bootstrap.js","./core":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/core.js","./lifecycle_hooks":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/lifecycle_hooks.js","./profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/profile.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/bootstrap.js":[function(require,module,exports){
'use strict';/**
 * This file is only used for dart applications and for internal examples
 * that compile with both JavaScript and Dart.
 */
var bootstrap_1 = require('angular2/src/core/bootstrap');
exports.bootstrap = bootstrap_1.bootstrap;

},{"angular2/src/core/bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/core.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
 * @module
 * @description
 * Starting point to import all public core APIs.
 */
__export(require('./src/core/metadata'));
__export(require('./src/core/util'));
__export(require('./src/core/di'));
__export(require('./src/core/pipes'));
__export(require('./src/core/facade'));
__export(require('./src/core/application'));
__export(require('./src/core/bootstrap'));
__export(require('./src/core/services'));
__export(require('./src/core/linker'));
__export(require('./src/core/lifecycle'));
__export(require('./src/core/zone'));
__export(require('./src/core/render'));
__export(require('./src/core/directives'));
__export(require('./src/core/forms'));
__export(require('./src/core/debug'));
__export(require('./src/core/change_detection'));

},{"./src/core/application":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js","./src/core/bootstrap":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js","./src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","./src/core/debug":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug.js","./src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","./src/core/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives.js","./src/core/facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade.js","./src/core/forms":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js","./src/core/lifecycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/lifecycle.js","./src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","./src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js","./src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js","./src/core/services":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services.js","./src/core/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util.js","./src/core/zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/lifecycle_hooks.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Defines interfaces to be implemented by directives when they need to hook into the change
 * detection mechanism.
 */

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Observable.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _utilSymbol_observable = require('./util/Symbol_observable');

var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */

var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is
     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
     * of a succesful completion.
     */

    function Observable(subscribe) {
        _classCallCheck(this, Observable);

        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }

    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature.
    /**
     * @static
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @returns {Observable} a new cold observable
     * @description creates a new cold Observable by calling the Observable constructor
     */

    /**
     * @method lift
     * @param {Operator} the operator defining the operation to take on the observable
     * @returns {Observable} a new observable with the Operator applied
     * @description creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     */

    Observable.prototype.lift = function lift(operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };

    /**
     * @method Symbol.observable
     * @returns {Observable} this instance of the observable
     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     */

    Observable.prototype[_utilSymbol_observable2['default']] = function () {
        return this;
    };

    /**
     * @method subscribe
     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @returns {Subscription} a subscription reference to the registered handlers
     * @description registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     */

    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
        var subscriber = undefined;
        if (observerOrNext && typeof observerOrNext === "object") {
            if (observerOrNext instanceof _Subscriber2['default']) {
                subscriber = observerOrNext;
            } else {
                subscriber = new _Subscriber2['default'](observerOrNext);
            }
        } else {
            var next = observerOrNext;
            subscriber = _Subscriber2['default'].create(next, error, complete);
        }
        subscriber.add(this._subscribe(subscriber));
        return subscriber;
    };

    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @returns {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */

    Observable.prototype.forEach = function forEach(next) {
        var _this = this;

        return new Promise(function (resolve, reject) {
            _this.subscribe(next, reject, resolve);
        });
    };

    Observable.prototype._subscribe = function _subscribe(subscriber) {
        return this.source._subscribe(this.operator.call(subscriber));
    };

    return Observable;
})();

exports['default'] = Observable;
Observable.create = function (subscribe) {
    return new Observable(subscribe);
};
module.exports = exports['default'];
},{"./Subscriber":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js","./util/Symbol_observable":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/Symbol_observable.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subject.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('./Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _Subscription = require('./Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _subjectsSubjectSubscription = require('./subjects/SubjectSubscription');

var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);

var subscriptionAdd = _Subscription2['default'].prototype.add;
var subscriptionRemove = _Subscription2['default'].prototype.remove;
var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
var subscriberNext = _Subscriber2['default'].prototype.next;
var subscriberError = _Subscriber2['default'].prototype.error;
var subscriberComplete = _Subscriber2['default'].prototype.complete;
var _subscriberNext = _Subscriber2['default'].prototype._next;
var _subscriberError = _Subscriber2['default'].prototype._error;
var _subscriberComplete = _Subscriber2['default'].prototype._complete;
var _observableSubscribe = _Observable3['default'].prototype._subscribe;

var Subject = (function (_Observable) {
    _inherits(Subject, _Observable);

    function Subject() {
        _classCallCheck(this, Subject);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        _Observable.call.apply(_Observable, [this].concat(args));
        this.observers = [];
        this.isUnsubscribed = false;
        this.dispatching = false;
        this.errorSignal = false;
        this.completeSignal = false;
    }

    Subject.create = function create(source, destination) {
        return new BidirectionalSubject(source, destination);
    };

    Subject.prototype.lift = function lift(operator) {
        var subject = new BidirectionalSubject(this, this.destination || this);
        subject.operator = operator;
        return subject;
    };

    Subject.prototype._subscribe = function _subscribe(subscriber) {
        if (subscriber.isUnsubscribed) {
            return;
        } else if (this.errorSignal) {
            subscriber.error(this.errorInstance);
            return;
        } else if (this.completeSignal) {
            subscriber.complete();
            return;
        } else if (this.isUnsubscribed) {
            throw new Error("Cannot subscribe to a disposed Subject.");
        }
        this.observers.push(subscriber);
        return new _subjectsSubjectSubscription2['default'](this, subscriber);
    };

    Subject.prototype.add = function add(subscription) {
        subscriptionAdd.call(this, subscription);
    };

    Subject.prototype.remove = function remove(subscription) {
        subscriptionRemove.call(this, subscription);
    };

    Subject.prototype.unsubscribe = function unsubscribe() {
        this.observers = void 0;
        subscriptionUnsubscribe.call(this);
    };

    Subject.prototype.next = function next(value) {
        if (this.isUnsubscribed) {
            return;
        }
        this.dispatching = true;
        this._next(value);
        this.dispatching = false;
        if (this.errorSignal) {
            this.error(this.errorInstance);
        } else if (this.completeSignal) {
            this.complete();
        }
    };

    Subject.prototype.error = function error(_error) {
        if (this.isUnsubscribed || this.completeSignal) {
            return;
        }
        this.errorSignal = true;
        this.errorInstance = _error;
        if (this.dispatching) {
            return;
        }
        this._error(_error);
        this.unsubscribe();
    };

    Subject.prototype.complete = function complete() {
        if (this.isUnsubscribed || this.errorSignal) {
            return;
        }
        this.completeSignal = true;
        if (this.dispatching) {
            return;
        }
        this._complete();
        this.unsubscribe();
    };

    Subject.prototype._next = function _next(value) {
        var index = -1;
        var observers = this.observers.slice(0);
        var len = observers.length;
        while (++index < len) {
            observers[index].next(value);
        }
    };

    Subject.prototype._error = function _error(error) {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0;
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].error(error);
        }
        this.isUnsubscribed = false;
    };

    Subject.prototype._complete = function _complete() {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0; // optimization
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].complete();
        }
        this.isUnsubscribed = false;
    };

    return Subject;
})(_Observable3['default']);

exports['default'] = Subject;

var BidirectionalSubject = (function (_Subject) {
    _inherits(BidirectionalSubject, _Subject);

    function BidirectionalSubject(source, destination) {
        _classCallCheck(this, BidirectionalSubject);

        _Subject.call(this);
        this.source = source;
        this.destination = destination;
    }

    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
        return _observableSubscribe.call(this, subscriber);
    };

    BidirectionalSubject.prototype.next = function next(x) {
        subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype.error = function error(e) {
        subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype.complete = function complete() {
        subscriberComplete.call(this);
    };

    BidirectionalSubject.prototype._next = function _next(x) {
        _subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype._error = function _error(e) {
        _subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype._complete = function _complete() {
        _subscriberComplete.call(this);
    };

    return BidirectionalSubject;
})(Subject);

module.exports = exports['default'];
},{"./Observable":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Observable.js","./Subscriber":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js","./Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js","./subjects/SubjectSubscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/subjects/SubjectSubscription.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscriber.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilNoop = require('./util/noop');

var _utilNoop2 = _interopRequireDefault(_utilNoop);

var _utilThrowError = require('./util/throwError');

var _utilThrowError2 = _interopRequireDefault(_utilThrowError);

var _utilTryOrOnError = require('./util/tryOrOnError');

var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);

var _Subscription2 = require('./Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var Subscriber = (function (_Subscription) {
    _inherits(Subscriber, _Subscription);

    function Subscriber(destination) {
        _classCallCheck(this, Subscriber);

        _Subscription.call(this);
        this._isUnsubscribed = false;
        this.destination = destination;
        if (!destination) {
            return;
        }
        var subscription = destination._subscription;
        if (subscription) {
            this._subscription = subscription;
        } else if (destination instanceof Subscriber) {
            this._subscription = destination;
        }
    }

    Subscriber.create = function create(next, error, complete) {
        var subscriber = new Subscriber();
        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
        return subscriber;
    };

    Subscriber.prototype._next = function _next(value) {
        this.destination.next(value);
    };

    Subscriber.prototype._error = function _error(err) {
        this.destination.error(err);
    };

    Subscriber.prototype._complete = function _complete() {
        this.destination.complete();
    };

    Subscriber.prototype.add = function add(sub) {
        // route add to the shared Subscription if it exists
        var _subscription = this._subscription;
        if (_subscription) {
            _subscription.add(sub);
        } else {
            _Subscription.prototype.add.call(this, sub);
        }
    };

    Subscriber.prototype.remove = function remove(sub) {
        // route remove to the shared Subscription if it exists
        if (this._subscription) {
            this._subscription.remove(sub);
        } else {
            _Subscription.prototype.remove.call(this, sub);
        }
    };

    Subscriber.prototype.unsubscribe = function unsubscribe() {
        if (this._isUnsubscribed) {
            return;
        } else if (this._subscription) {
            this._isUnsubscribed = true;
        } else {
            _Subscription.prototype.unsubscribe.call(this);
        }
    };

    Subscriber.prototype.next = function next(value) {
        if (!this.isUnsubscribed) {
            this._next(value);
        }
    };

    Subscriber.prototype.error = function error(_error2) {
        if (!this.isUnsubscribed) {
            this._error(_error2);
            this.unsubscribe();
        }
    };

    Subscriber.prototype.complete = function complete() {
        if (!this.isUnsubscribed) {
            this._complete();
            this.unsubscribe();
        }
    };

    _createClass(Subscriber, [{
        key: 'isUnsubscribed',
        get: function get() {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                return this._isUnsubscribed || subscription.isUnsubscribed;
            } else {
                return this._isUnsubscribed;
            }
        },
        set: function set(value) {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                subscription.isUnsubscribed = Boolean(value);
            } else {
                this._isUnsubscribed = Boolean(value);
            }
        }
    }]);

    return Subscriber;
})(_Subscription3['default']);

exports['default'] = Subscriber;
module.exports = exports['default'];
},{"./Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js","./util/noop":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/noop.js","./util/throwError":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/throwError.js","./util/tryOrOnError":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/tryOrOnError.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Subscription = (function () {
    function Subscription(_unsubscribe) {
        _classCallCheck(this, Subscription);

        this.isUnsubscribed = false;
        if (_unsubscribe) {
            this._unsubscribe = _unsubscribe;
        }
    }

    Subscription.prototype._unsubscribe = function _unsubscribe() {};

    Subscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var unsubscribe = this._unsubscribe;
        var subscriptions = this._subscriptions;
        this._subscriptions = void 0;
        if (unsubscribe) {
            unsubscribe.call(this);
        }
        if (subscriptions != null) {
            var index = -1;
            var len = subscriptions.length;
            while (++index < len) {
                subscriptions[index].unsubscribe();
            }
        }
    };

    Subscription.prototype.add = function add(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to add our this
        //  3. we're attempting to add the static `empty` Subscription
        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var sub = subscription;
        switch (typeof subscription) {
            case "function":
                sub = new Subscription(subscription);
            case "object":
                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
                    break;
                } else if (this.isUnsubscribed) {
                    sub.unsubscribe();
                } else {
                    var subscriptions = this._subscriptions || (this._subscriptions = []);
                    subscriptions.push(sub);
                }
                break;
            default:
                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
        }
    };

    Subscription.prototype.remove = function remove(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to remove ourthis
        //  3. we're attempting to remove the static `empty` Subscription
        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };

    return Subscription;
})();

exports["default"] = Subscription;

Subscription.EMPTY = (function (empty) {
    empty.isUnsubscribed = true;
    return empty;
})(new Subscription());
module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/subjects/SubjectSubscription.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscription2 = require('../Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var SubjectSubscription = (function (_Subscription) {
    _inherits(SubjectSubscription, _Subscription);

    function SubjectSubscription(subject, observer) {
        _classCallCheck(this, SubjectSubscription);

        _Subscription.call(this);
        this.subject = subject;
        this.observer = observer;
        this.isUnsubscribed = false;
    }

    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = void 0;
        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.observer);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };

    return SubjectSubscription;
})(_Subscription3['default']);

exports['default'] = SubjectSubscription;
module.exports = exports['default'];
},{"../Subscription":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subscription.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/Symbol_observable.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _root = require('./root');

if (!_root.root.Symbol) {
    _root.root.Symbol = {};
}
if (!_root.root.Symbol.observable) {
    if (typeof _root.root.Symbol['for'] === 'function') {
        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
    } else {
        _root.root.Symbol.observable = '@@observable';
    }
}
exports['default'] = _root.root.Symbol.observable;
module.exports = exports['default'];
},{"./root":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/root.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/noop.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = noop;

function noop() {}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/root.js":[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
exports.root = root;
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = root = freeGlobal;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/throwError.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = throwError;

function throwError(e) {
  throw e;
}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/util/tryOrOnError.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = tryOrOnError;

function tryOrOnError(target) {
    function tryCatcher() {
        try {
            tryCatcher.target.apply(this, arguments);
        } catch (e) {
            this.error(e);
        }
    }
    tryCatcher.target = target;
    return tryCatcher;
}

module.exports = exports["default"];
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/profile.js":[function(require,module,exports){
'use strict';var profile_1 = require('./src/core/profile/profile');
exports.wtfCreateScope = profile_1.wtfCreateScope;
exports.wtfLeave = profile_1.wtfLeave;
exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;

},{"./src/core/profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/render.js":[function(require,module,exports){
'use strict';function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
 * This file is only used for dart applications and for internal examples
 * that compile with both JavaScript and Dart.
 *
 * JavaScript users should import from angular2/core.
 */
__export(require('./src/core/render'));

},{"./src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/router.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Maps application URLs into application states, to support deep-linking and navigation.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var router_1 = require('./src/router/router');
exports.Router = router_1.Router;
var router_outlet_1 = require('./src/router/router_outlet');
exports.RouterOutlet = router_outlet_1.RouterOutlet;
var router_link_1 = require('./src/router/router_link');
exports.RouterLink = router_link_1.RouterLink;
var instruction_1 = require('./src/router/instruction');
exports.RouteParams = instruction_1.RouteParams;
var route_registry_1 = require('./src/router/route_registry');
exports.RouteRegistry = route_registry_1.RouteRegistry;
var location_strategy_1 = require('./src/router/location_strategy');
exports.LocationStrategy = location_strategy_1.LocationStrategy;
var hash_location_strategy_1 = require('./src/router/hash_location_strategy');
exports.HashLocationStrategy = hash_location_strategy_1.HashLocationStrategy;
var path_location_strategy_1 = require('./src/router/path_location_strategy');
exports.PathLocationStrategy = path_location_strategy_1.PathLocationStrategy;
var location_1 = require('./src/router/location');
exports.Location = location_1.Location;
exports.APP_BASE_HREF = location_1.APP_BASE_HREF;
__export(require('./src/router/route_config_decorator'));
__export(require('./src/router/route_definition'));
var lifecycle_annotations_1 = require('./src/router/lifecycle_annotations');
exports.CanActivate = lifecycle_annotations_1.CanActivate;
var instruction_2 = require('./src/router/instruction');
exports.Instruction = instruction_2.Instruction;
exports.ComponentInstruction = instruction_2.ComponentInstruction;
var angular2_1 = require('angular2/angular2');
exports.OpaqueToken = angular2_1.OpaqueToken;
var route_data_1 = require('./src/router/route_data');
exports.ROUTE_DATA = route_data_1.ROUTE_DATA;
var location_strategy_2 = require('./src/router/location_strategy');
var path_location_strategy_2 = require('./src/router/path_location_strategy');
var router_2 = require('./src/router/router');
var router_outlet_2 = require('./src/router/router_outlet');
var router_link_2 = require('./src/router/router_link');
var route_registry_2 = require('./src/router/route_registry');
var location_2 = require('./src/router/location');
var angular2_2 = require('angular2/angular2');
var lang_1 = require('./src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Token used to bind the component with the top-level {@link RouteConfig}s for the
 * application.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_PRIMARY_COMPONENT = lang_1.CONST_EXPR(new angular2_2.OpaqueToken('RouterPrimaryComponent'));
/**
 * A list of directives. To use the router directives like {@link RouterOutlet} and
 * {@link RouterLink}, add this to your `directives` array in the {@link View} decorator of your
 * component.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *    // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_DIRECTIVES = lang_1.CONST_EXPR([router_outlet_2.RouterOutlet, router_link_2.RouterLink]);
/**
 * A list of {@link Provider}s. To use the router, you must add this to your application.
 *
 * ## Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_PROVIDERS = lang_1.CONST_EXPR([
    route_registry_2.RouteRegistry,
    lang_1.CONST_EXPR(new angular2_2.Provider(location_strategy_2.LocationStrategy, { useClass: path_location_strategy_2.PathLocationStrategy })),
    location_2.Location,
    lang_1.CONST_EXPR(new angular2_2.Provider(router_2.Router, {
        useFactory: routerFactory,
        deps: lang_1.CONST_EXPR([route_registry_2.RouteRegistry, location_2.Location, exports.ROUTER_PRIMARY_COMPONENT])
    })),
    lang_1.CONST_EXPR(new angular2_2.Provider(exports.ROUTER_PRIMARY_COMPONENT, { useFactory: routerPrimaryComponentFactory, deps: lang_1.CONST_EXPR([angular2_2.ApplicationRef]) }))
]);
/**
 * @deprecated
 */
exports.ROUTER_BINDINGS = exports.ROUTER_PROVIDERS;
function routerFactory(registry, location, primaryComponent) {
    return new router_2.RootRouter(registry, location, primaryComponent);
}
function routerPrimaryComponentFactory(app) {
    if (app.componentTypes.length == 0) {
        throw new exceptions_1.BaseException("Bootstrap at least one component before injecting Router.");
    }
    return app.componentTypes[0];
}

},{"./src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","./src/router/hash_location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/hash_location_strategy.js","./src/router/instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./src/router/lifecycle_annotations":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js","./src/router/location":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js","./src/router/location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","./src/router/path_location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_location_strategy.js","./src/router/route_config_decorator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js","./src/router/route_data":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js","./src/router/route_definition":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_definition.js","./src/router/route_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_registry.js","./src/router/router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js","./src/router/router_link":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_link.js","./src/router/router_outlet":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_outlet.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var math_1 = require('angular2/src/core/facade/math');
var util_1 = require('angular2/src/core/render/dom/util');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var Animation = (function () {
    /**
     * Stores the start time and starts the animation
     * @param element
     * @param data
     * @param browserDetails
     */
    function Animation(element, data, browserDetails) {
        var _this = this;
        this.element = element;
        this.data = data;
        this.browserDetails = browserDetails;
        /** functions to be called upon completion */
        this.callbacks = [];
        /** functions for removing event listeners */
        this.eventClearFunctions = [];
        /** flag used to track whether or not the animation has finished */
        this.completed = false;
        this._stringPrefix = '';
        this.startTime = lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        this._stringPrefix = dom_adapter_1.DOM.getAnimationPrefix();
        this.setup();
        this.wait(function (timestamp) { return _this.start(); });
    }
    Object.defineProperty(Animation.prototype, "totalTime", {
        /** total amount of time that the animation should take including delay */
        get: function () {
            var delay = this.computedDelay != null ? this.computedDelay : 0;
            var duration = this.computedDuration != null ? this.computedDuration : 0;
            return delay + duration;
        },
        enumerable: true,
        configurable: true
    });
    Animation.prototype.wait = function (callback) {
        // Firefox requires 2 frames for some reason
        this.browserDetails.raf(callback, 2);
    };
    /**
     * Sets up the initial styles before the animation is started
     */
    Animation.prototype.setup = function () {
        if (this.data.fromStyles != null)
            this.applyStyles(this.data.fromStyles);
        if (this.data.duration != null)
            this.applyStyles({ 'transitionDuration': this.data.duration.toString() + 'ms' });
        if (this.data.delay != null)
            this.applyStyles({ 'transitionDelay': this.data.delay.toString() + 'ms' });
    };
    /**
     * After the initial setup has occurred, this method adds the animation styles
     */
    Animation.prototype.start = function () {
        this.addClasses(this.data.classesToAdd);
        this.addClasses(this.data.animationClasses);
        this.removeClasses(this.data.classesToRemove);
        if (this.data.toStyles != null)
            this.applyStyles(this.data.toStyles);
        var computedStyles = dom_adapter_1.DOM.getComputedStyle(this.element);
        this.computedDelay =
            math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-delay')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-delay')));
        this.computedDuration = math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-duration')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-duration')));
        this.addEvents();
    };
    /**
     * Applies the provided styles to the element
     * @param styles
     */
    Animation.prototype.applyStyles = function (styles) {
        var _this = this;
        collection_1.StringMapWrapper.forEach(styles, function (value, key) {
            var dashCaseKey = util_1.camelCaseToDashCase(key);
            if (lang_1.isPresent(dom_adapter_1.DOM.getStyle(_this.element, dashCaseKey))) {
                dom_adapter_1.DOM.setStyle(_this.element, dashCaseKey, value.toString());
            }
            else {
                dom_adapter_1.DOM.setStyle(_this.element, _this._stringPrefix + dashCaseKey, value.toString());
            }
        });
    };
    /**
     * Adds the provided classes to the element
     * @param classes
     */
    Animation.prototype.addClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.DOM.addClass(this.element, classes[i]);
    };
    /**
     * Removes the provided classes from the element
     * @param classes
     */
    Animation.prototype.removeClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.DOM.removeClass(this.element, classes[i]);
    };
    /**
     * Adds events to track when animations have finished
     */
    Animation.prototype.addEvents = function () {
        var _this = this;
        if (this.totalTime > 0) {
            this.eventClearFunctions.push(dom_adapter_1.DOM.onAndCancel(this.element, dom_adapter_1.DOM.getTransitionEnd(), function (event) { return _this.handleAnimationEvent(event); }));
        }
        else {
            this.handleAnimationCompleted();
        }
    };
    Animation.prototype.handleAnimationEvent = function (event) {
        var elapsedTime = math_1.Math.round(event.elapsedTime * 1000);
        if (!this.browserDetails.elapsedTimeIncludesDelay)
            elapsedTime += this.computedDelay;
        event.stopPropagation();
        if (elapsedTime >= this.totalTime)
            this.handleAnimationCompleted();
    };
    /**
     * Runs all animation callbacks and removes temporary classes
     */
    Animation.prototype.handleAnimationCompleted = function () {
        this.removeClasses(this.data.animationClasses);
        this.callbacks.forEach(function (callback) { return callback(); });
        this.callbacks = [];
        this.eventClearFunctions.forEach(function (fn) { return fn(); });
        this.eventClearFunctions = [];
        this.completed = true;
    };
    /**
     * Adds animation callbacks to be called upon completion
     * @param callback
     * @returns {Animation}
     */
    Animation.prototype.onComplete = function (callback) {
        if (this.completed) {
            callback();
        }
        else {
            this.callbacks.push(callback);
        }
        return this;
    };
    /**
     * Converts the duration string to the number of milliseconds
     * @param duration
     * @returns {number}
     */
    Animation.prototype.parseDurationString = function (duration) {
        var maxValue = 0;
        // duration must have at least 2 characters to be valid. (number + type)
        if (duration == null || duration.length < 2) {
            return maxValue;
        }
        else if (duration.substring(duration.length - 2) == 'ms') {
            var value = lang_1.NumberWrapper.parseInt(this.stripLetters(duration), 10);
            if (value > maxValue)
                maxValue = value;
        }
        else if (duration.substring(duration.length - 1) == 's') {
            var ms = lang_1.NumberWrapper.parseFloat(this.stripLetters(duration)) * 1000;
            var value = math_1.Math.floor(ms);
            if (value > maxValue)
                maxValue = value;
        }
        return maxValue;
    };
    /**
     * Strips the letters from the duration string
     * @param str
     * @returns {string}
     */
    Animation.prototype.stripLetters = function (str) {
        return lang_1.StringWrapper.replaceAll(str, lang_1.RegExpWrapper.create('[^0-9]+$', ''), '');
    };
    return Animation;
})();
exports.Animation = Animation;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/facade/math":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js","angular2/src/core/render/dom/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var css_animation_builder_1 = require('./css_animation_builder');
var browser_details_1 = require('./browser_details');
var AnimationBuilder = (function () {
    /**
     * Used for DI
     * @param browserDetails
     */
    function AnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
    }
    /**
     * Creates a new CSS Animation
     * @returns {CssAnimationBuilder}
     */
    AnimationBuilder.prototype.css = function () { return new css_animation_builder_1.CssAnimationBuilder(this.browserDetails); };
    AnimationBuilder = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [browser_details_1.BrowserDetails])
    ], AnimationBuilder);
    return AnimationBuilder;
})();
exports.AnimationBuilder = AnimationBuilder;

},{"./browser_details":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js","./css_animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_builder.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var math_1 = require('angular2/src/core/facade/math');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var BrowserDetails = (function () {
    function BrowserDetails() {
        this.elapsedTimeIncludesDelay = false;
        this.doesElapsedTimeIncludesDelay();
    }
    /**
     * Determines if `event.elapsedTime` includes transition delay in the current browser.  At this
     * time, Chrome and Opera seem to be the only browsers that include this.
     */
    BrowserDetails.prototype.doesElapsedTimeIncludesDelay = function () {
        var _this = this;
        var div = dom_adapter_1.DOM.createElement('div');
        dom_adapter_1.DOM.setAttribute(div, 'style', "position: absolute; top: -9999px; left: -9999px; width: 1px;\n      height: 1px; transition: all 1ms linear 1ms;");
        // Firefox requires that we wait for 2 frames for some reason
        this.raf(function (timestamp) {
            dom_adapter_1.DOM.on(div, 'transitionend', function (event) {
                var elapsed = math_1.Math.round(event.elapsedTime * 1000);
                _this.elapsedTimeIncludesDelay = elapsed == 2;
                dom_adapter_1.DOM.remove(div);
            });
            dom_adapter_1.DOM.setStyle(div, 'width', '2px');
        }, 2);
    };
    BrowserDetails.prototype.raf = function (callback, frames) {
        if (frames === void 0) { frames = 1; }
        var queue = new RafQueue(callback, frames);
        return function () { return queue.cancel(); };
    };
    BrowserDetails = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], BrowserDetails);
    return BrowserDetails;
})();
exports.BrowserDetails = BrowserDetails;
var RafQueue = (function () {
    function RafQueue(callback, frames) {
        this.callback = callback;
        this.frames = frames;
        this._raf();
    }
    RafQueue.prototype._raf = function () {
        var _this = this;
        this.currentFrameId = dom_adapter_1.DOM.requestAnimationFrame(function (timestamp) { return _this._nextFrame(timestamp); });
    };
    RafQueue.prototype._nextFrame = function (timestamp) {
        this.frames--;
        if (this.frames > 0) {
            this._raf();
        }
        else {
            this.callback(timestamp);
        }
    };
    RafQueue.prototype.cancel = function () {
        dom_adapter_1.DOM.cancelAnimationFrame(this.currentFrameId);
        this.currentFrameId = null;
    };
    return RafQueue;
})();

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/math":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_builder.js":[function(require,module,exports){
'use strict';var css_animation_options_1 = require('./css_animation_options');
var animation_1 = require('./animation');
var CssAnimationBuilder = (function () {
    /**
     * Accepts public properties for CssAnimationBuilder
     */
    function CssAnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
        /** @type {CssAnimationOptions} */
        this.data = new css_animation_options_1.CssAnimationOptions();
    }
    /**
     * Adds a temporary class that will be removed at the end of the animation
     * @param className
     */
    CssAnimationBuilder.prototype.addAnimationClass = function (className) {
        this.data.animationClasses.push(className);
        return this;
    };
    /**
     * Adds a class that will remain on the element after the animation has finished
     * @param className
     */
    CssAnimationBuilder.prototype.addClass = function (className) {
        this.data.classesToAdd.push(className);
        return this;
    };
    /**
     * Removes a class from the element
     * @param className
     */
    CssAnimationBuilder.prototype.removeClass = function (className) {
        this.data.classesToRemove.push(className);
        return this;
    };
    /**
     * Sets the animation duration (and overrides any defined through CSS)
     * @param duration
     */
    CssAnimationBuilder.prototype.setDuration = function (duration) {
        this.data.duration = duration;
        return this;
    };
    /**
     * Sets the animation delay (and overrides any defined through CSS)
     * @param delay
     */
    CssAnimationBuilder.prototype.setDelay = function (delay) {
        this.data.delay = delay;
        return this;
    };
    /**
     * Sets styles for both the initial state and the destination state
     * @param from
     * @param to
     */
    CssAnimationBuilder.prototype.setStyles = function (from, to) {
        return this.setFromStyles(from).setToStyles(to);
    };
    /**
     * Sets the initial styles for the animation
     * @param from
     */
    CssAnimationBuilder.prototype.setFromStyles = function (from) {
        this.data.fromStyles = from;
        return this;
    };
    /**
     * Sets the destination styles for the animation
     * @param to
     */
    CssAnimationBuilder.prototype.setToStyles = function (to) {
        this.data.toStyles = to;
        return this;
    };
    /**
     * Starts the animation and returns a promise
     * @param element
     */
    CssAnimationBuilder.prototype.start = function (element) {
        return new animation_1.Animation(element, this.data, this.browserDetails);
    };
    return CssAnimationBuilder;
})();
exports.CssAnimationBuilder = CssAnimationBuilder;

},{"./animation":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation.js","./css_animation_options":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_options.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/css_animation_options.js":[function(require,module,exports){
'use strict';var CssAnimationOptions = (function () {
    function CssAnimationOptions() {
        /** classes to be added to the element */
        this.classesToAdd = [];
        /** classes to be removed from the element */
        this.classesToRemove = [];
        /** classes to be added for the duration of the animation */
        this.animationClasses = [];
    }
    return CssAnimationOptions;
})();
exports.CssAnimationOptions = CssAnimationOptions;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var compiler_1 = require('angular2/src/core/compiler/compiler');
var application_common_1 = require('./application_common');
var application_tokens_1 = require('./application_tokens');
exports.APP_COMPONENT = application_tokens_1.APP_COMPONENT;
exports.APP_ID = application_tokens_1.APP_ID;
var application_common_2 = require('./application_common');
exports.platform = application_common_2.platform;
var application_ref_1 = require('./application_ref');
exports.PlatformRef = application_ref_1.PlatformRef;
exports.ApplicationRef = application_ref_1.ApplicationRef;
exports.applicationCommonBindings = application_ref_1.applicationCommonBindings;
exports.createNgZone = application_ref_1.createNgZone;
exports.platformCommon = application_ref_1.platformCommon;
exports.platformBindings = application_ref_1.platformBindings;
/// See [commonBootstrap] for detailed documentation.
function bootstrap(appComponentType, appBindings) {
    if (appBindings === void 0) { appBindings = null; }
    var bindings = [compiler_1.compilerProviders()];
    if (lang_1.isPresent(appBindings)) {
        bindings.push(appBindings);
    }
    return application_common_1.commonBootstrap(appComponentType, bindings);
}
exports.bootstrap = bootstrap;

},{"./application_common":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_common.js","./application_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js","./application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/compiler/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/compiler.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_common.js":[function(require,module,exports){
'use strict';var forms_1 = require('angular2/src/core/forms');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var browser_adapter_1 = require('angular2/src/core/dom/browser_adapter');
var browser_testability_1 = require('angular2/src/core/testability/browser_testability');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var xhr_impl_1 = require('angular2/src/core/compiler/xhr_impl');
var event_manager_1 = require('angular2/src/core/render/dom/events/event_manager');
var key_events_1 = require('angular2/src/core/render/dom/events/key_events');
var hammer_gestures_1 = require('angular2/src/core/render/dom/events/hammer_gestures');
var testability_1 = require('angular2/src/core/testability/testability');
var api_1 = require('angular2/src/core/render/api');
var render_1 = require('angular2/src/core/render/render');
var shared_styles_host_1 = require('angular2/src/core/render/dom/shared_styles_host');
var platform_bindings_1 = require('./platform_bindings');
var animation_builder_1 = require('angular2/src/animate/animation_builder');
var browser_details_1 = require('angular2/src/animate/browser_details');
var wtf_init_1 = require('./profile/wtf_init');
var application_ref_1 = require('./application_ref');
/**
 * A default set of providers which apply only to an Angular application running on
 * the UI thread.
 */
function applicationDomBindings() {
    if (lang_1.isBlank(dom_adapter_1.DOM)) {
        throw "Must set a root DOM adapter first.";
    }
    return [
        di_1.provide(render_1.DOCUMENT, { useValue: dom_adapter_1.DOM.defaultDoc() }),
        event_manager_1.EventManager,
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: event_manager_1.DomEventsPlugin, multi: true }),
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: key_events_1.KeyEventsPlugin, multi: true }),
        new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true }),
        di_1.provide(render_1.DomRenderer, { useClass: render_1.DomRenderer_ }),
        di_1.provide(api_1.Renderer, { useExisting: render_1.DomRenderer }),
        shared_styles_host_1.DomSharedStylesHost,
        di_1.provide(shared_styles_host_1.SharedStylesHost, { useExisting: shared_styles_host_1.DomSharedStylesHost }),
        platform_bindings_1.EXCEPTION_PROVIDER,
        di_1.provide(xhr_1.XHR, { useValue: new xhr_impl_1.XHRImpl() }),
        testability_1.Testability,
        browser_details_1.BrowserDetails,
        animation_builder_1.AnimationBuilder,
        forms_1.FORM_PROVIDERS
    ];
}
exports.applicationDomBindings = applicationDomBindings;
/**
 * Initialize the Angular 'platform' on the page.
 *
 * See {@link PlatformRef} for details on the Angular platform.
 *
 * # Without specified providers
 *
 * If no providers are specified, `platform`'s behavior depends on whether an existing
 * platform exists:
 *
 * If no platform exists, a new one will be created with the default {@link platformBindings}.
 *
 * If a platform already exists, it will be returned (regardless of what providers it
 * was created with). This is a convenience feature, allowing for multiple applications
 * to be loaded into the same platform without awareness of each other.
 *
 * # With specified providers
 *
 * It is also possible to specify providers to be made in the new platform. These providers
 * will be shared between all applications on the page. For example, an abstraction for
 * the browser cookie jar should be bound at the platform level, because there is only one
 * cookie jar regardless of how many applications on the age will be accessing it.
 *
 * If providers are specified directly, `platform` will create the Angular platform with
 * them if a platform did not exist already. If it did exist, however, an error will be
 * thrown.
 *
 * # DOM Applications
 *
 * This version of `platform` initializes Angular to run in the UI thread, with direct
 * DOM access. Web-worker applications should call `platform` from
 * `src/web_workers/worker/application_common` instead.
 */
function platform(bindings) {
    return application_ref_1.platformCommon(bindings, function () {
        browser_adapter_1.BrowserDomAdapter.makeCurrent();
        wtf_init_1.wtfInit();
        browser_testability_1.BrowserGetTestability.init();
    });
}
exports.platform = platform;
/**
 * Bootstrapping for Angular applications.
 *
 * You instantiate an Angular application by explicitly specifying a component to use
 * as the root component for your application via the `bootstrap()` method.
 *
 * ## Simple Example
 *
 * Assuming this `index.html`:
 *
 * ```html
 * <html>
 *   <!-- load Angular script tags here. -->
 *   <body>
 *     <my-app>loading...</my-app>
 *   </body>
 * </html>
 * ```
 *
 * An application is bootstrapped inside an existing browser DOM, typically `index.html`.
 * Unlike Angular 1, Angular 2 does not compile/process providers in `index.html`. This is
 * mainly for security reasons, as well as architectural changes in Angular 2. This means
 * that `index.html` can safely be processed using server-side technologies such as
 * providers. Bindings can thus use double-curly `{{ syntax }}` without collision from
 * Angular 2 component double-curly `{{ syntax }}`.
 *
 * We can use this script code:
 *
 * ```
 * @Component({
 *    selector: 'my-app',
 *    template: 'Hello {{ name }}!'
 * })
 * class MyApp {
 *   name:string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 *
 * main() {
 *   return bootstrap(MyApp);
 * }
 * ```
 *
 * When the app developer invokes `bootstrap()` with the root component `MyApp` as its
 * argument, Angular performs the following tasks:
 *
 *  1. It uses the component's `selector` property to locate the DOM element which needs
 *     to be upgraded into the angular component.
 *  2. It creates a new child injector (from the platform injector). Optionally, you can
 *     also override the injector configuration for an app by invoking `bootstrap` with the
 *     `componentInjectableBindings` argument.
 *  3. It creates a new `Zone` and connects it to the angular application's change detection
 *     domain instance.
 *  4. It creates a shadow DOM on the selected component's host element and loads the
 *     template into it.
 *  5. It instantiates the specified component.
 *  6. Finally, Angular performs change detection to apply the initial data providers for the
 *     application.
 *
 *
 * ## Instantiating Multiple Applications on a Single Page
 *
 * There are two ways to do this.
 *
 * ### Isolated Applications
 *
 * Angular creates a new application each time that the `bootstrap()` method is invoked.
 * When multiple applications are created for a page, Angular treats each application as
 * independent within an isolated change detection and `Zone` domain. If you need to share
 * data between applications, use the strategy described in the next section, "Applications
 * That Share Change Detection."
 *
 *
 * ### Applications That Share Change Detection
 *
 * If you need to bootstrap multiple applications that share common data, the applications
 * must share a common change detection and zone. To do that, create a meta-component that
 * lists the application components in its template.
 *
 * By only invoking the `bootstrap()` method once, with the meta-component as its argument,
 * you ensure that only a single change detection zone is created and therefore data can be
 * shared across the applications.
 *
 *
 * ## Platform Injector
 *
 * When working within a browser window, there are many singleton resources: cookies, title,
 * location, and others. Angular services that represent these resources must likewise be
 * shared across all Angular applications that occupy the same browser window. For this
 * reason, Angular creates exactly one global platform injector which stores all shared
 * services, and each angular application injector has the platform injector as its parent.
 *
 * Each application has its own private injector as well. When there are multiple
 * applications on a page, Angular treats each application injector's services as private
 * to that application.
 *
 *
 * # API
 * - `appComponentType`: The root component which should act as the application. This is
 *   a reference to a `Type` which is annotated with `@Component(...)`.
 * - `componentInjectableBindings`: An additional set of providers that can be added to the
 *   app injector to override default injection behavior.
 * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter
 *   for unhandled exceptions.
 *
 * Returns a `Promise` of {@link ComponentRef}.
 */
function commonBootstrap(appComponentType, appBindings) {
    if (appBindings === void 0) { appBindings = null; }
    var p = platform();
    var bindings = [application_ref_1.applicationCommonBindings(), applicationDomBindings()];
    if (lang_1.isPresent(appBindings)) {
        bindings.push(appBindings);
    }
    return p.application(bindings).bootstrap(appComponentType);
}
exports.commonBootstrap = commonBootstrap;

},{"./application_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js","./platform_bindings":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/platform_bindings.js","./profile/wtf_init":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_init.js","angular2/src/animate/animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js","angular2/src/animate/browser_details":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/browser_details.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/compiler/xhr_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr_impl.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/browser_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/browser_adapter.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/forms":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","angular2/src/core/render/dom/events/event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/render/dom/events/hammer_gestures":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_gestures.js","angular2/src/core/render/dom/events/key_events":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/key_events.js","angular2/src/core/render/dom/shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js","angular2/src/core/render/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js","angular2/src/core/testability/browser_testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/browser_testability.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ng_zone_1 = require('angular2/src/core/zone/ng_zone');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var application_tokens_1 = require('./application_tokens');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var testability_1 = require('angular2/src/core/testability/testability');
var dynamic_component_loader_1 = require('angular2/src/core/linker/dynamic_component_loader');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var view_ref_1 = require('angular2/src/core/linker/view_ref');
var life_cycle_1 = require('angular2/src/core/life_cycle/life_cycle');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var view_pool_1 = require('angular2/src/core/linker/view_pool');
var view_manager_1 = require('angular2/src/core/linker/view_manager');
var view_manager_utils_1 = require('angular2/src/core/linker/view_manager_utils');
var view_listener_1 = require('angular2/src/core/linker/view_listener');
var proto_view_factory_1 = require('./linker/proto_view_factory');
var pipes_1 = require('angular2/src/core/pipes');
var view_resolver_1 = require('./linker/view_resolver');
var directive_resolver_1 = require('./linker/directive_resolver');
var pipe_resolver_1 = require('./linker/pipe_resolver');
var compiler_1 = require('angular2/src/core/linker/compiler');
var dynamic_component_loader_2 = require("./linker/dynamic_component_loader");
var view_manager_2 = require("./linker/view_manager");
var compiler_2 = require("./linker/compiler");
/**
 * Constructs the set of providers meant for use at the platform level.
 *
 * These are providers that should be singletons shared among all Angular applications
 * running on the page.
 */
function platformBindings() {
    return [di_1.provide(reflection_1.Reflector, { useValue: reflection_1.reflector }), testability_1.TestabilityRegistry];
}
exports.platformBindings = platformBindings;
/**
 * Construct providers specific to an individual root component.
 */
function _componentProviders(appComponentType) {
    return [
        di_1.provide(application_tokens_1.APP_COMPONENT, { useValue: appComponentType }),
        di_1.provide(application_tokens_1.APP_COMPONENT_REF_PROMISE, {
            useFactory: function (dynamicComponentLoader, injector) {
                // TODO(rado): investigate whether to support bindings on root component.
                return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector)
                    .then(function (componentRef) {
                    if (lang_1.isPresent(componentRef.location.nativeElement)) {
                        injector.get(testability_1.TestabilityRegistry)
                            .registerApplication(componentRef.location.nativeElement, injector.get(testability_1.Testability));
                    }
                    return componentRef;
                });
            },
            deps: [dynamic_component_loader_1.DynamicComponentLoader, di_1.Injector]
        }),
        di_1.provide(appComponentType, {
            useFactory: function (p) { return p.then(function (ref) { return ref.instance; }); },
            deps: [application_tokens_1.APP_COMPONENT_REF_PROMISE]
        }),
    ];
}
/**
 * Construct a default set of providers which should be included in any Angular
 * application, regardless of whether it runs on the UI thread or in a web worker.
 */
function applicationCommonBindings() {
    return [
        di_1.provide(compiler_1.Compiler, { useClass: compiler_2.Compiler_ }),
        application_tokens_1.APP_ID_RANDOM_PROVIDER,
        view_pool_1.AppViewPool,
        di_1.provide(view_pool_1.APP_VIEW_POOL_CAPACITY, { useValue: 10000 }),
        di_1.provide(view_manager_1.AppViewManager, { useClass: view_manager_2.AppViewManager_ }),
        view_manager_utils_1.AppViewManagerUtils,
        view_listener_1.AppViewListener,
        proto_view_factory_1.ProtoViewFactory,
        view_resolver_1.ViewResolver,
        pipes_1.DEFAULT_PIPES,
        di_1.provide(change_detection_1.IterableDiffers, { useValue: change_detection_1.defaultIterableDiffers }),
        di_1.provide(change_detection_1.KeyValueDiffers, { useValue: change_detection_1.defaultKeyValueDiffers }),
        directive_resolver_1.DirectiveResolver,
        pipe_resolver_1.PipeResolver,
        di_1.provide(dynamic_component_loader_1.DynamicComponentLoader, { useClass: dynamic_component_loader_2.DynamicComponentLoader_ }),
        di_1.provide(life_cycle_1.LifeCycle, {
            useFactory: function (exceptionHandler) { return new life_cycle_1.LifeCycle_(null, lang_1.assertionsEnabled()); },
            deps: [exceptions_1.ExceptionHandler]
        })
    ];
}
exports.applicationCommonBindings = applicationCommonBindings;
/**
 * Create an Angular zone.
 */
function createNgZone() {
    return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });
}
exports.createNgZone = createNgZone;
var _platform;
function platformCommon(bindings, initializer) {
    if (lang_1.isPresent(_platform)) {
        if (lang_1.isBlank(bindings)) {
            return _platform;
        }
        throw "platform() can only be called once per page";
    }
    if (lang_1.isPresent(initializer)) {
        initializer();
    }
    if (lang_1.isBlank(bindings)) {
        bindings = platformBindings();
    }
    _platform = new PlatformRef_(di_1.Injector.resolveAndCreate(bindings), function () { _platform = null; });
    return _platform;
}
exports.platformCommon = platformCommon;
/**
 * The Angular platform is the entry point for Angular on a web page. Each page
 * has exactly one platform, and services (such as reflection) which are common
 * to every Angular application running on the page are bound in its scope.
 *
 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
 * explicitly by calling {@link platform}().
 */
var PlatformRef = (function () {
    function PlatformRef() {
    }
    Object.defineProperty(PlatformRef.prototype, "injector", {
        /**
         * Retrieve the platform {@link Injector}, which is the parent injector for
         * every Angular application on the page and provides singleton providers.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return PlatformRef;
})();
exports.PlatformRef = PlatformRef;
var PlatformRef_ = (function (_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector, _dispose) {
        _super.call(this);
        this._injector = _injector;
        this._dispose = _dispose;
        /** @internal */
        this._applications = [];
    }
    Object.defineProperty(PlatformRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    PlatformRef_.prototype.application = function (bindings) {
        var app = this._initApp(createNgZone(), bindings);
        return app;
    };
    PlatformRef_.prototype.asyncApplication = function (bindingFn) {
        var _this = this;
        var zone = createNgZone();
        var completer = async_1.PromiseWrapper.completer();
        zone.run(function () {
            async_1.PromiseWrapper.then(bindingFn(zone), function (bindings) {
                completer.resolve(_this._initApp(zone, bindings));
            });
        });
        return completer.promise;
    };
    PlatformRef_.prototype._initApp = function (zone, providers) {
        var _this = this;
        var injector;
        var app;
        zone.run(function () {
            providers.push(di_1.provide(ng_zone_1.NgZone, { useValue: zone }));
            providers.push(di_1.provide(ApplicationRef, { useFactory: function () { return app; }, deps: [] }));
            var exceptionHandler;
            try {
                injector = _this.injector.resolveAndCreateChild(providers);
                exceptionHandler = injector.get(exceptions_1.ExceptionHandler);
                zone.overrideOnErrorHandler(function (e, s) { return exceptionHandler.call(e, s); });
            }
            catch (e) {
                if (lang_1.isPresent(exceptionHandler)) {
                    exceptionHandler.call(e, e.stack);
                }
                else {
                    dom_adapter_1.DOM.logError(e);
                }
            }
        });
        app = new ApplicationRef_(this, zone, injector);
        this._applications.push(app);
        return app;
    };
    PlatformRef_.prototype.dispose = function () {
        this._applications.forEach(function (app) { return app.dispose(); });
        this._dispose();
    };
    /** @internal */
    PlatformRef_.prototype._applicationDisposed = function (app) { collection_1.ListWrapper.remove(this._applications, app); };
    return PlatformRef_;
})(PlatformRef);
exports.PlatformRef_ = PlatformRef_;
/**
 * A reference to an Angular application running on a page.
 *
 * For more about Angular applications, see the documentation for {@link bootstrap}.
 */
var ApplicationRef = (function () {
    function ApplicationRef() {
    }
    Object.defineProperty(ApplicationRef.prototype, "injector", {
        /**
         * Retrieve the application {@link Injector}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "zone", {
        /**
         * Retrieve the application {@link NgZone}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
        /**
         * Get a list of component types registered to this application.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ApplicationRef;
})();
exports.ApplicationRef = ApplicationRef;
var ApplicationRef_ = (function (_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_platform, _zone, _injector) {
        _super.call(this);
        this._platform = _platform;
        this._zone = _zone;
        this._injector = _injector;
        this._bootstrapListeners = [];
        this._rootComponents = [];
        this._rootComponentTypes = [];
    }
    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {
        this._bootstrapListeners.push(listener);
    };
    ApplicationRef_.prototype.bootstrap = function (componentType, providers) {
        var _this = this;
        var completer = async_1.PromiseWrapper.completer();
        this._zone.run(function () {
            var componentProviders = _componentProviders(componentType);
            if (lang_1.isPresent(providers)) {
                componentProviders.push(providers);
            }
            var exceptionHandler = _this._injector.get(exceptions_1.ExceptionHandler);
            _this._rootComponentTypes.push(componentType);
            try {
                var injector = _this._injector.resolveAndCreateChild(componentProviders);
                var compRefToken = injector.get(application_tokens_1.APP_COMPONENT_REF_PROMISE);
                var tick = function (componentRef) {
                    var appChangeDetector = view_ref_1.internalView(componentRef.hostView).changeDetector;
                    var lc = injector.get(life_cycle_1.LifeCycle);
                    lc.registerWith(_this._zone, appChangeDetector);
                    lc.tick();
                    completer.resolve(componentRef);
                    _this._rootComponents.push(componentRef);
                    _this._bootstrapListeners.forEach(function (listener) { return listener(componentRef); });
                };
                var tickResult = async_1.PromiseWrapper.then(compRefToken, tick);
                async_1.PromiseWrapper.then(tickResult, function (_) { });
                async_1.PromiseWrapper.then(tickResult, null, function (err, stackTrace) { return completer.reject(err, stackTrace); });
            }
            catch (e) {
                exceptionHandler.call(e, e.stack);
                completer.reject(e, e.stack);
            }
        });
        return completer.promise;
    };
    Object.defineProperty(ApplicationRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "zone", {
        get: function () { return this._zone; },
        enumerable: true,
        configurable: true
    });
    ApplicationRef_.prototype.dispose = function () {
        // TODO(alxhub): Dispose of the NgZone.
        this._rootComponents.forEach(function (ref) { return ref.dispose(); });
        this._platform._applicationDisposed(this);
    };
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
        get: function () { return this._rootComponentTypes; },
        enumerable: true,
        configurable: true
    });
    return ApplicationRef_;
})(ApplicationRef);
exports.ApplicationRef_ = ApplicationRef_;

},{"./application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","./linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","./linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","./linker/pipe_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js","./linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","./linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","./linker/view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/life_cycle/life_cycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","angular2/src/core/linker/view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","angular2/src/core/linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","angular2/src/core/linker/view_manager_utils":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js","angular2/src/core/linker/view_pool":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js","angular2/src/core/linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js","angular2/src/core/zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 *  @internal
 */
exports.APP_COMPONENT_REF_PROMISE = lang_1.CONST_EXPR(new di_1.OpaqueToken('Promise<ComponentRef>'));
/**
 * An {@link angular2/di/OpaqueToken} representing the application root type in the {@link
 * Injector}.
 *
 * ```
 * @Component(...)
 * class MyApp {
 *   ...
 * }
 *
 * bootstrap(MyApp).then((appRef:ApplicationRef) {
 *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);
 * });
 *
 * ```
 */
exports.APP_COMPONENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppComponent'));
/**
 * A DI Token representing a unique string id assigned to the application by Angular and used
 * primarily for prefixing application attributes and CSS styles when
 * {@link ViewEncapsulation#Emulated} is being used.
 *
 * If you need to avoid randomly generated value to be used as an application id, you can provide
 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
 * using this token.
 */
exports.APP_ID = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppId'));
function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
}
/**
 * Bindings that will generate a random APP_ID_TOKEN.
 */
exports.APP_ID_RANDOM_PROVIDER = lang_1.CONST_EXPR(new di_1.Provider(exports.APP_ID, { useFactory: _appIdRandomProviderFactory, deps: [] }));
function _randomChar() {
    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
}

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/bootstrap.js":[function(require,module,exports){
'use strict';// Note: This file only exists so that Dart users can import
// bootstrap from angular2/bootstrap. JS users should import
// from angular2/core.
var application_1 = require('./application');
exports.bootstrap = application_1.bootstrap;

},{"./application":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Change detection enables data binding in Angular.
 */
var change_detection_1 = require('./change_detection/change_detection');
exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
exports.ExpressionChangedAfterItHasBeenCheckedException = change_detection_1.ExpressionChangedAfterItHasBeenCheckedException;
exports.ChangeDetectionError = change_detection_1.ChangeDetectionError;
exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
exports.WrappedValue = change_detection_1.WrappedValue;
exports.SimpleChange = change_detection_1.SimpleChange;
exports.IterableDiffers = change_detection_1.IterableDiffers;
exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;

},{"./change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_util_1 = require('./change_detection_util');
var change_detector_ref_1 = require('./change_detector_ref');
var exceptions_2 = require('./exceptions');
var constants_1 = require('./constants');
var profile_1 = require('../profile/profile');
var observable_facade_1 = require('./observable_facade');
var _scope_check = profile_1.wtfCreateScope("ChangeDetector#check(ascii id, bool throwOnChange)");
var _Context = (function () {
    function _Context(element, componentElement, context, locals, injector, expression) {
        this.element = element;
        this.componentElement = componentElement;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
        this.expression = expression;
    }
    return _Context;
})();
var AbstractChangeDetector = (function () {
    function AbstractChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, bindingTargets, directiveIndices, strategy) {
        this.id = id;
        this.dispatcher = dispatcher;
        this.numberOfPropertyProtoRecords = numberOfPropertyProtoRecords;
        this.bindingTargets = bindingTargets;
        this.directiveIndices = directiveIndices;
        this.strategy = strategy;
        this.lightDomChildren = [];
        this.shadowDomChildren = [];
        // The names of the below fields must be kept in sync with codegen_name_util.ts or
        // change detection will fail.
        this.alreadyChecked = false;
        this.locals = null;
        this.mode = null;
        this.pipes = null;
        this.ref = new change_detector_ref_1.ChangeDetectorRef_(this);
    }
    AbstractChangeDetector.prototype.addChild = function (cd) {
        this.lightDomChildren.push(cd);
        cd.parent = this;
    };
    AbstractChangeDetector.prototype.removeChild = function (cd) { collection_1.ListWrapper.remove(this.lightDomChildren, cd); };
    AbstractChangeDetector.prototype.addShadowDomChild = function (cd) {
        this.shadowDomChildren.push(cd);
        cd.parent = this;
    };
    AbstractChangeDetector.prototype.removeShadowDomChild = function (cd) { collection_1.ListWrapper.remove(this.shadowDomChildren, cd); };
    AbstractChangeDetector.prototype.remove = function () { this.parent.removeChild(this); };
    AbstractChangeDetector.prototype.handleEvent = function (eventName, elIndex, locals) {
        var res = this.handleEventInternal(eventName, elIndex, locals);
        this.markPathToRootAsCheckOnce();
        return res;
    };
    AbstractChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) { return false; };
    AbstractChangeDetector.prototype.detectChanges = function () { this.runDetectChanges(false); };
    AbstractChangeDetector.prototype.checkNoChanges = function () { throw new exceptions_1.BaseException("Not implemented"); };
    AbstractChangeDetector.prototype.runDetectChanges = function (throwOnChange) {
        if (this.mode === constants_1.ChangeDetectionStrategy.Detached ||
            this.mode === constants_1.ChangeDetectionStrategy.Checked)
            return;
        var s = _scope_check(this.id, throwOnChange);
        this.detectChangesInRecords(throwOnChange);
        this._detectChangesInLightDomChildren(throwOnChange);
        if (!throwOnChange)
            this.afterContentLifecycleCallbacks();
        this._detectChangesInShadowDomChildren(throwOnChange);
        if (!throwOnChange)
            this.afterViewLifecycleCallbacks();
        if (this.mode === constants_1.ChangeDetectionStrategy.CheckOnce)
            this.mode = constants_1.ChangeDetectionStrategy.Checked;
        this.alreadyChecked = true;
        profile_1.wtfLeave(s);
    };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `detectChangesInRecordsInternal` which does the work of detecting changes
    // and which this method will call.
    // This method expects that `detectChangesInRecordsInternal` will set the property
    // `this.propertyBindingIndex` to the propertyBindingIndex of the first proto record. This is to
    // facilitate error reporting.
    AbstractChangeDetector.prototype.detectChangesInRecords = function (throwOnChange) {
        if (!this.hydrated()) {
            this.throwDehydratedError();
        }
        try {
            this.detectChangesInRecordsInternal(throwOnChange);
        }
        catch (e) {
            this._throwError(e, e.stack);
        }
    };
    // Subclasses should override this method to perform any work necessary to detect and report
    // changes. For example, changes should be reported via `ChangeDetectionUtil.addChange`, lifecycle
    // methods should be called, etc.
    // This implementation should also set `this.propertyBindingIndex` to the propertyBindingIndex of
    // the
    // first proto record to facilitate error reporting. See {@link #detectChangesInRecords}.
    AbstractChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) { };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `hydrateDirectives`.
    AbstractChangeDetector.prototype.hydrate = function (context, locals, directives, pipes) {
        this.mode = change_detection_util_1.ChangeDetectionUtil.changeDetectionMode(this.strategy);
        this.context = context;
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            this.observeComponent(context);
        }
        this.locals = locals;
        this.pipes = pipes;
        this.hydrateDirectives(directives);
        this.alreadyChecked = false;
    };
    // Subclasses should override this method to hydrate any directives.
    AbstractChangeDetector.prototype.hydrateDirectives = function (directives) { };
    // This method is not intended to be overridden. Subclasses should instead provide an
    // implementation of `dehydrateDirectives`.
    AbstractChangeDetector.prototype.dehydrate = function () {
        this.dehydrateDirectives(true);
        // This is an experimental feature. Works only in Dart.
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            this._unsubsribeFromObservables();
        }
        this.context = null;
        this.locals = null;
        this.pipes = null;
    };
    // Subclasses should override this method to dehydrate any directives. This method should reverse
    // any work done in `hydrateDirectives`.
    AbstractChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) { };
    AbstractChangeDetector.prototype.hydrated = function () { return this.context !== null; };
    AbstractChangeDetector.prototype.afterContentLifecycleCallbacks = function () {
        this.dispatcher.notifyAfterContentChecked();
        this.afterContentLifecycleCallbacksInternal();
    };
    AbstractChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () { };
    AbstractChangeDetector.prototype.afterViewLifecycleCallbacks = function () {
        this.dispatcher.notifyAfterViewChecked();
        this.afterViewLifecycleCallbacksInternal();
    };
    AbstractChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () { };
    /** @internal */
    AbstractChangeDetector.prototype._detectChangesInLightDomChildren = function (throwOnChange) {
        var c = this.lightDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    };
    /** @internal */
    AbstractChangeDetector.prototype._detectChangesInShadowDomChildren = function (throwOnChange) {
        var c = this.shadowDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    };
    AbstractChangeDetector.prototype.markAsCheckOnce = function () { this.mode = constants_1.ChangeDetectionStrategy.CheckOnce; };
    AbstractChangeDetector.prototype.markPathToRootAsCheckOnce = function () {
        var c = this;
        while (lang_1.isPresent(c) && c.mode !== constants_1.ChangeDetectionStrategy.Detached) {
            if (c.mode === constants_1.ChangeDetectionStrategy.Checked)
                c.mode = constants_1.ChangeDetectionStrategy.CheckOnce;
            c = c.parent;
        }
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype._unsubsribeFromObservables = function () {
        if (lang_1.isPresent(this.subscriptions)) {
            for (var i = 0; i < this.subscriptions.length; ++i) {
                var s = this.subscriptions[i];
                if (lang_1.isPresent(this.subscriptions[i])) {
                    s.cancel();
                    this.subscriptions[i] = null;
                }
            }
        }
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeValue = function (value, index) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            if (lang_1.isBlank(this.subscriptions[index])) {
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
            }
            else if (this.streams[index] !== value.changes) {
                this.subscriptions[index].cancel();
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
            }
        }
        return value;
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeDirective = function (value, index) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            var arrayIndex = this.numberOfPropertyProtoRecords + index + 2; // +1 is component
            this.streams[arrayIndex] = value.changes;
            this.subscriptions[arrayIndex] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
        }
        return value;
    };
    // This is an experimental feature. Works only in Dart.
    AbstractChangeDetector.prototype.observeComponent = function (value) {
        var _this = this;
        if (observable_facade_1.isObservable(value)) {
            this._createArrayToStoreObservables();
            var index = this.numberOfPropertyProtoRecords + 1;
            this.streams[index] = value.changes;
            this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
        }
        return value;
    };
    AbstractChangeDetector.prototype._createArrayToStoreObservables = function () {
        if (lang_1.isBlank(this.subscriptions)) {
            this.subscriptions = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
                this.directiveIndices.length + 2);
            this.streams = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
                this.directiveIndices.length + 2);
        }
    };
    AbstractChangeDetector.prototype.getDirectiveFor = function (directives, index) {
        return directives.getDirectiveFor(this.directiveIndices[index]);
    };
    AbstractChangeDetector.prototype.getDetectorFor = function (directives, index) {
        return directives.getDetectorFor(this.directiveIndices[index]);
    };
    AbstractChangeDetector.prototype.notifyDispatcher = function (value) {
        this.dispatcher.notifyOnBinding(this._currentBinding(), value);
    };
    AbstractChangeDetector.prototype.logBindingUpdate = function (value) {
        this.dispatcher.logBindingUpdate(this._currentBinding(), value);
    };
    AbstractChangeDetector.prototype.addChange = function (changes, oldValue, newValue) {
        if (lang_1.isBlank(changes)) {
            changes = {};
        }
        changes[this._currentBinding().name] = change_detection_util_1.ChangeDetectionUtil.simpleChange(oldValue, newValue);
        return changes;
    };
    AbstractChangeDetector.prototype._throwError = function (exception, stack) {
        var error;
        try {
            var c = this.dispatcher.getDebugContext(this._currentBinding().elementIndex, null);
            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector, this._currentBinding().debug) :
                null;
            error = new exceptions_2.ChangeDetectionError(this._currentBinding().debug, exception, stack, context);
        }
        catch (e) {
            // if an error happens during getting the debug context, we throw a ChangeDetectionError
            // without the extra information.
            error = new exceptions_2.ChangeDetectionError(null, exception, stack, null);
        }
        throw error;
    };
    AbstractChangeDetector.prototype.throwOnChangeError = function (oldValue, newValue) {
        throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(this._currentBinding().debug, oldValue, newValue, null);
    };
    AbstractChangeDetector.prototype.throwDehydratedError = function () { throw new exceptions_2.DehydratedException(); };
    AbstractChangeDetector.prototype._currentBinding = function () {
        return this.bindingTargets[this.propertyBindingIndex];
    };
    return AbstractChangeDetector;
})();
exports.AbstractChangeDetector = AbstractChangeDetector;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./change_detector_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js","./observable_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/observable_facade.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var DIRECTIVE_LIFECYCLE = "directiveLifecycle";
var BINDING = "native";
var DIRECTIVE = "directive";
var ELEMENT_PROPERTY = "elementProperty";
var ELEMENT_ATTRIBUTE = "elementAttribute";
var ELEMENT_CLASS = "elementClass";
var ELEMENT_STYLE = "elementStyle";
var TEXT_NODE = "textNode";
var EVENT = "event";
var HOST_EVENT = "hostEvent";
var BindingTarget = (function () {
    function BindingTarget(mode, elementIndex, name, unit, debug) {
        this.mode = mode;
        this.elementIndex = elementIndex;
        this.name = name;
        this.unit = unit;
        this.debug = debug;
    }
    BindingTarget.prototype.isDirective = function () { return this.mode === DIRECTIVE; };
    BindingTarget.prototype.isElementProperty = function () { return this.mode === ELEMENT_PROPERTY; };
    BindingTarget.prototype.isElementAttribute = function () { return this.mode === ELEMENT_ATTRIBUTE; };
    BindingTarget.prototype.isElementClass = function () { return this.mode === ELEMENT_CLASS; };
    BindingTarget.prototype.isElementStyle = function () { return this.mode === ELEMENT_STYLE; };
    BindingTarget.prototype.isTextNode = function () { return this.mode === TEXT_NODE; };
    return BindingTarget;
})();
exports.BindingTarget = BindingTarget;
var BindingRecord = (function () {
    function BindingRecord(mode, target, implicitReceiver, ast, setter, lifecycleEvent, directiveRecord) {
        this.mode = mode;
        this.target = target;
        this.implicitReceiver = implicitReceiver;
        this.ast = ast;
        this.setter = setter;
        this.lifecycleEvent = lifecycleEvent;
        this.directiveRecord = directiveRecord;
    }
    BindingRecord.prototype.isDirectiveLifecycle = function () { return this.mode === DIRECTIVE_LIFECYCLE; };
    BindingRecord.prototype.callOnChanges = function () {
        return lang_1.isPresent(this.directiveRecord) && this.directiveRecord.callOnChanges;
    };
    BindingRecord.prototype.isDefaultChangeDetection = function () {
        return lang_1.isBlank(this.directiveRecord) || this.directiveRecord.isDefaultChangeDetection();
    };
    BindingRecord.createDirectiveDoCheck = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "DoCheck", directiveRecord);
    };
    BindingRecord.createDirectiveOnInit = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnInit", directiveRecord);
    };
    BindingRecord.createDirectiveOnChanges = function (directiveRecord) {
        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnChanges", directiveRecord);
    };
    BindingRecord.createForDirective = function (ast, propertyName, setter, directiveRecord) {
        var elementIndex = directiveRecord.directiveIndex.elementIndex;
        var t = new BindingTarget(DIRECTIVE, elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(DIRECTIVE, t, 0, ast, setter, null, directiveRecord);
    };
    BindingRecord.createForElementProperty = function (ast, elementIndex, propertyName) {
        var t = new BindingTarget(ELEMENT_PROPERTY, elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementAttribute = function (ast, elementIndex, attributeName) {
        var t = new BindingTarget(ELEMENT_ATTRIBUTE, elementIndex, attributeName, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementClass = function (ast, elementIndex, className) {
        var t = new BindingTarget(ELEMENT_CLASS, elementIndex, className, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForElementStyle = function (ast, elementIndex, styleName, unit) {
        var t = new BindingTarget(ELEMENT_STYLE, elementIndex, styleName, unit, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForHostProperty = function (directiveIndex, ast, propertyName) {
        var t = new BindingTarget(ELEMENT_PROPERTY, directiveIndex.elementIndex, propertyName, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostAttribute = function (directiveIndex, ast, attributeName) {
        var t = new BindingTarget(ELEMENT_ATTRIBUTE, directiveIndex.elementIndex, attributeName, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostClass = function (directiveIndex, ast, className) {
        var t = new BindingTarget(ELEMENT_CLASS, directiveIndex.elementIndex, className, null, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForHostStyle = function (directiveIndex, ast, styleName, unit) {
        var t = new BindingTarget(ELEMENT_STYLE, directiveIndex.elementIndex, styleName, unit, ast.toString());
        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
    };
    BindingRecord.createForTextNode = function (ast, elementIndex) {
        var t = new BindingTarget(TEXT_NODE, elementIndex, null, null, ast.toString());
        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
    };
    BindingRecord.createForEvent = function (ast, eventName, elementIndex) {
        var t = new BindingTarget(EVENT, elementIndex, eventName, null, ast.toString());
        return new BindingRecord(EVENT, t, 0, ast, null, null, null);
    };
    BindingRecord.createForHostEvent = function (ast, eventName, directiveRecord) {
        var directiveIndex = directiveRecord.directiveIndex;
        var t = new BindingTarget(HOST_EVENT, directiveIndex.elementIndex, eventName, null, ast.toString());
        return new BindingRecord(HOST_EVENT, t, directiveIndex, ast, null, null, directiveRecord);
    };
    return BindingRecord;
})();
exports.BindingRecord = BindingRecord;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js":[function(require,module,exports){
'use strict';var iterable_differs_1 = require('./differs/iterable_differs');
var default_iterable_differ_1 = require('./differs/default_iterable_differ');
var keyvalue_differs_1 = require('./differs/keyvalue_differs');
var default_keyvalue_differ_1 = require('./differs/default_keyvalue_differ');
var lang_1 = require('angular2/src/core/facade/lang');
var ast_1 = require('./parser/ast');
exports.ASTWithSource = ast_1.ASTWithSource;
exports.AST = ast_1.AST;
exports.AstTransformer = ast_1.AstTransformer;
exports.PropertyRead = ast_1.PropertyRead;
exports.LiteralArray = ast_1.LiteralArray;
exports.ImplicitReceiver = ast_1.ImplicitReceiver;
var lexer_1 = require('./parser/lexer');
exports.Lexer = lexer_1.Lexer;
var parser_1 = require('./parser/parser');
exports.Parser = parser_1.Parser;
var locals_1 = require('./parser/locals');
exports.Locals = locals_1.Locals;
var exceptions_1 = require('./exceptions');
exports.DehydratedException = exceptions_1.DehydratedException;
exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
exports.ChangeDetectionError = exceptions_1.ChangeDetectionError;
var interfaces_1 = require('./interfaces');
exports.ChangeDetectorDefinition = interfaces_1.ChangeDetectorDefinition;
exports.DebugContext = interfaces_1.DebugContext;
exports.ChangeDetectorGenConfig = interfaces_1.ChangeDetectorGenConfig;
var constants_1 = require('./constants');
exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
exports.CHANGE_DECTION_STRATEGY_VALUES = constants_1.CHANGE_DECTION_STRATEGY_VALUES;
var proto_change_detector_1 = require('./proto_change_detector');
exports.DynamicProtoChangeDetector = proto_change_detector_1.DynamicProtoChangeDetector;
var jit_proto_change_detector_1 = require('./jit_proto_change_detector');
exports.JitProtoChangeDetector = jit_proto_change_detector_1.JitProtoChangeDetector;
var binding_record_1 = require('./binding_record');
exports.BindingRecord = binding_record_1.BindingRecord;
exports.BindingTarget = binding_record_1.BindingTarget;
var directive_record_1 = require('./directive_record');
exports.DirectiveIndex = directive_record_1.DirectiveIndex;
exports.DirectiveRecord = directive_record_1.DirectiveRecord;
var dynamic_change_detector_1 = require('./dynamic_change_detector');
exports.DynamicChangeDetector = dynamic_change_detector_1.DynamicChangeDetector;
var change_detector_ref_1 = require('./change_detector_ref');
exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
var iterable_differs_2 = require('./differs/iterable_differs');
exports.IterableDiffers = iterable_differs_2.IterableDiffers;
var keyvalue_differs_2 = require('./differs/keyvalue_differs');
exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
var change_detection_util_1 = require('./change_detection_util');
exports.WrappedValue = change_detection_util_1.WrappedValue;
exports.SimpleChange = change_detection_util_1.SimpleChange;
/**
 * Structural diffing for `Object`s and `Map`s.
 */
exports.keyValDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_keyvalue_differ_1.DefaultKeyValueDifferFactory())]);
/**
 * Structural diffing for `Iterable` types such as `Array`s.
 */
exports.iterableDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_iterable_differ_1.DefaultIterableDifferFactory())]);
exports.defaultIterableDiffers = lang_1.CONST_EXPR(new iterable_differs_1.IterableDiffers(exports.iterableDiff));
exports.defaultKeyValueDiffers = lang_1.CONST_EXPR(new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff));

},{"./binding_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./change_detector_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./differs/default_iterable_differ":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_iterable_differ.js","./differs/default_keyvalue_differ":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_keyvalue_differ.js","./differs/iterable_differs":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/iterable_differs.js","./differs/keyvalue_differs":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/keyvalue_differs.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./dynamic_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js","./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js","./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js","./jit_proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/jit_proto_change_detector.js","./parser/ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./parser/lexer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js","./parser/locals":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/locals.js","./parser/parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/parser.js","./proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var abstract_change_detector_1 = require('./abstract_change_detector');
var change_detection_util_1 = require('./change_detection_util');
var codegen_name_util_1 = require('./codegen_name_util');
var codegen_logic_util_1 = require('./codegen_logic_util');
var codegen_facade_1 = require('./codegen_facade');
var proto_change_detector_1 = require('./proto_change_detector');
/**
 * The code generator takes a list of proto records and creates a function/class
 * that "emulates" what the developer would write by hand to implement the same
 * kind of behaviour.
 *
 * This code should be kept in sync with the Dart transformer's
 * `angular2.transform.template_compiler.change_detector_codegen` library. If you make updates
 * here, please make equivalent changes there.
*/
var IS_CHANGED_LOCAL = "isChanged";
var CHANGES_LOCAL = "changes";
var ChangeDetectorJITGenerator = (function () {
    function ChangeDetectorJITGenerator(definition, changeDetectionUtilVarName, abstractChangeDetectorVarName) {
        this.changeDetectionUtilVarName = changeDetectionUtilVarName;
        this.abstractChangeDetectorVarName = abstractChangeDetectorVarName;
        var propertyBindingRecords = proto_change_detector_1.createPropertyRecords(definition);
        var eventBindingRecords = proto_change_detector_1.createEventRecords(definition);
        var propertyBindingTargets = definition.bindingRecords.map(function (b) { return b.target; });
        this.id = definition.id;
        this.changeDetectionStrategy = definition.strategy;
        this.genConfig = definition.genConfig;
        this.records = propertyBindingRecords;
        this.propertyBindingTargets = propertyBindingTargets;
        this.eventBindings = eventBindingRecords;
        this.directiveRecords = definition.directiveRecords;
        this._names = new codegen_name_util_1.CodegenNameUtil(this.records, this.eventBindings, this.directiveRecords, this.changeDetectionUtilVarName);
        this._logic = new codegen_logic_util_1.CodegenLogicUtil(this._names, this.changeDetectionUtilVarName, this.changeDetectionStrategy);
        this.typeName = codegen_name_util_1.sanitizeName("ChangeDetector_" + this.id);
    }
    ChangeDetectorJITGenerator.prototype.generate = function () {
        var factorySource = "\n      " + this.generateSource() + "\n      return function(dispatcher) {\n        return new " + this.typeName + "(dispatcher);\n      }\n    ";
        return new Function(this.abstractChangeDetectorVarName, this.changeDetectionUtilVarName, factorySource)(abstract_change_detector_1.AbstractChangeDetector, change_detection_util_1.ChangeDetectionUtil);
    };
    ChangeDetectorJITGenerator.prototype.generateSource = function () {
        var _this = this;
        return "\n      var " + this.typeName + " = function " + this.typeName + "(dispatcher) {\n        " + this.abstractChangeDetectorVarName + ".call(\n            this, " + JSON.stringify(this.id) + ", dispatcher, " + this.records.length + ",\n            " + this.typeName + ".gen_propertyBindingTargets, " + this.typeName + ".gen_directiveIndices,\n            " + codegen_facade_1.codify(this.changeDetectionStrategy) + ");\n        this.dehydrateDirectives(false);\n      }\n\n      " + this.typeName + ".prototype = Object.create(" + this.abstractChangeDetectorVarName + ".prototype);\n\n      " + this.typeName + ".prototype.detectChangesInRecordsInternal = function(throwOnChange) {\n        " + this._names.genInitLocals() + "\n        var " + IS_CHANGED_LOCAL + " = false;\n        var " + CHANGES_LOCAL + " = null;\n\n        " + this.records.map(function (r) { return _this._genRecord(r); }).join("\n") + "\n      }\n\n      " + this._maybeGenHandleEventInternal() + "\n\n      " + this._genCheckNoChanges() + "\n\n      " + this._maybeGenAfterContentLifecycleCallbacks() + "\n\n      " + this._maybeGenAfterViewLifecycleCallbacks() + "\n\n      " + this._maybeGenHydrateDirectives() + "\n\n      " + this._maybeGenDehydrateDirectives() + "\n\n      " + this._genPropertyBindingTargets() + "\n\n      " + this._genDirectiveIndices() + "\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genPropertyBindingTargets = function () {
        var targets = this._logic.genPropertyBindingTargets(this.propertyBindingTargets, this.genConfig.genDebugInfo);
        return this.typeName + ".gen_propertyBindingTargets = " + targets + ";";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genDirectiveIndices = function () {
        var indices = this._logic.genDirectiveIndices(this.directiveRecords);
        return this.typeName + ".gen_directiveIndices = " + indices + ";";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenHandleEventInternal = function () {
        var _this = this;
        if (this.eventBindings.length > 0) {
            var handlers = this.eventBindings.map(function (eb) { return _this._genEventBinding(eb); }).join("\n");
            return "\n        " + this.typeName + ".prototype.handleEventInternal = function(eventName, elIndex, locals) {\n          var " + this._names.getPreventDefaultAccesor() + " = false;\n          " + this._names.genInitEventLocals() + "\n          " + handlers + "\n          return " + this._names.getPreventDefaultAccesor() + ";\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genEventBinding = function (eb) {
        var _this = this;
        var recs = eb.records.map(function (r) { return _this._genEventBindingEval(eb, r); }).join("\n");
        return "\n    if (eventName === \"" + eb.eventName + "\" && elIndex === " + eb.elIndex + ") {\n      " + recs + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genEventBindingEval = function (eb, r) {
        if (r.lastInBinding) {
            var evalRecord = this._logic.genEventBindingEvalValue(eb, r);
            var markPath = this._genMarkPathToRootAsCheckOnce(r);
            var prevDefault = this._genUpdatePreventDefault(eb, r);
            return evalRecord + "\n" + markPath + "\n" + prevDefault;
        }
        else {
            return this._logic.genEventBindingEvalValue(eb, r);
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genMarkPathToRootAsCheckOnce = function (r) {
        var br = r.bindingRecord;
        if (br.isDefaultChangeDetection()) {
            return "";
        }
        else {
            return this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markPathToRootAsCheckOnce();";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genUpdatePreventDefault = function (eb, r) {
        var local = this._names.getEventLocalName(eb, r.selfIndex);
        return "if (" + local + " === false) { " + this._names.getPreventDefaultAccesor() + " = true};";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenDehydrateDirectives = function () {
        var destroyPipesCode = this._names.genPipeOnDestroy();
        if (destroyPipesCode) {
            destroyPipesCode = "if (destroyPipes) { " + destroyPipesCode + " }";
        }
        var dehydrateFieldsCode = this._names.genDehydrateFields();
        if (!destroyPipesCode && !dehydrateFieldsCode)
            return '';
        return this.typeName + ".prototype.dehydrateDirectives = function(destroyPipes) {\n        " + destroyPipesCode + "\n        " + dehydrateFieldsCode + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenHydrateDirectives = function () {
        var hydrateDirectivesCode = this._logic.genHydrateDirectives(this.directiveRecords);
        var hydrateDetectorsCode = this._logic.genHydrateDetectors(this.directiveRecords);
        if (!hydrateDirectivesCode && !hydrateDetectorsCode)
            return '';
        return this.typeName + ".prototype.hydrateDirectives = function(directives) {\n      " + hydrateDirectivesCode + "\n      " + hydrateDetectorsCode + "\n    }";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenAfterContentLifecycleCallbacks = function () {
        var notifications = this._logic.genContentLifecycleCallbacks(this.directiveRecords);
        if (notifications.length > 0) {
            var directiveNotifications = notifications.join("\n");
            return "\n        " + this.typeName + ".prototype.afterContentLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenAfterViewLifecycleCallbacks = function () {
        var notifications = this._logic.genViewLifecycleCallbacks(this.directiveRecords);
        if (notifications.length > 0) {
            var directiveNotifications = notifications.join("\n");
            return "\n        " + this.typeName + ".prototype.afterViewLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genRecord = function (r) {
        var rec;
        if (r.isLifeCycleRecord()) {
            rec = this._genDirectiveLifecycle(r);
        }
        else if (r.isPipeRecord()) {
            rec = this._genPipeCheck(r);
        }
        else {
            rec = this._genReferenceCheck(r);
        }
        return "\n      " + this._maybeFirstInBinding(r) + "\n      " + rec + "\n      " + this._maybeGenLastInDirective(r) + "\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genDirectiveLifecycle = function (r) {
        if (r.name === "DoCheck") {
            return this._genOnCheck(r);
        }
        else if (r.name === "OnInit") {
            return this._genOnInit(r);
        }
        else if (r.name === "OnChanges") {
            return this._genOnChange(r);
        }
        else {
            throw new exceptions_1.BaseException("Unknown lifecycle event '" + r.name + "'");
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genPipeCheck = function (r) {
        var _this = this;
        var context = this._names.getLocalName(r.contextIndex);
        var argString = r.args.map(function (arg) { return _this._names.getLocalName(arg); }).join(", ");
        var oldValue = this._names.getFieldName(r.selfIndex);
        var newValue = this._names.getLocalName(r.selfIndex);
        var pipe = this._names.getPipeName(r.selfIndex);
        var pipeName = r.name;
        var init = "\n      if (" + pipe + " === " + this.changeDetectionUtilVarName + ".uninitialized) {\n        " + pipe + " = " + this._names.getPipesAccessorName() + ".get('" + pipeName + "');\n      }\n    ";
        var read = newValue + " = " + pipe + ".pipe.transform(" + context + ", [" + argString + "]);";
        var contexOrArgCheck = r.args.map(function (a) { return _this._names.getChangeName(a); });
        contexOrArgCheck.push(this._names.getChangeName(r.contextIndex));
        var condition = "!" + pipe + ".pure || (" + contexOrArgCheck.join(" || ") + ")";
        var check = "\n      if (" + oldValue + " !== " + newValue + ") {\n        " + newValue + " = " + this.changeDetectionUtilVarName + ".unwrapValue(" + newValue + ")\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
        var genCode = r.shouldBeChecked() ? "" + read + check : read;
        if (r.isUsedByOtherRecord()) {
            return init + " if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
        }
        else {
            return init + " if (" + condition + ") { " + genCode + " }";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genReferenceCheck = function (r) {
        var _this = this;
        var oldValue = this._names.getFieldName(r.selfIndex);
        var newValue = this._names.getLocalName(r.selfIndex);
        var read = "\n      " + this._logic.genPropertyBindingEvalValue(r) + "\n    ";
        var check = "\n      if (" + newValue + " !== " + oldValue + ") {\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
        var genCode = r.shouldBeChecked() ? "" + read + check : read;
        if (r.isPureFunction()) {
            var condition = r.args.map(function (a) { return _this._names.getChangeName(a); }).join(" || ");
            if (r.isUsedByOtherRecord()) {
                return "if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
            }
            else {
                return "if (" + condition + ") { " + genCode + " }";
            }
        }
        else {
            return genCode;
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genChangeMarker = function (r) {
        return r.argumentToPureFunction ? this._names.getChangeName(r.selfIndex) + " = true" : "";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genUpdateDirectiveOrElement = function (r) {
        if (!r.lastInBinding)
            return "";
        var newValue = this._names.getLocalName(r.selfIndex);
        var oldValue = this._names.getFieldName(r.selfIndex);
        var notifyDebug = this.genConfig.logBindingUpdate ? "this.logBindingUpdate(" + newValue + ");" : "";
        var br = r.bindingRecord;
        if (br.target.isDirective()) {
            var directiveProperty = this._names.getDirectiveName(br.directiveRecord.directiveIndex) + "." + br.target.name;
            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + directiveProperty + " = " + newValue + ";\n        " + notifyDebug + "\n        " + IS_CHANGED_LOCAL + " = true;\n      ";
        }
        else {
            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        this.notifyDispatcher(" + newValue + ");\n        " + notifyDebug + "\n      ";
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genThrowOnChangeCheck = function (oldValue, newValue) {
        if (this.genConfig.genCheckNoChanges) {
            return "\n        if(throwOnChange) {\n          this.throwOnChangeError(" + oldValue + ", " + newValue + ");\n        }\n        ";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genCheckNoChanges = function () {
        if (this.genConfig.genCheckNoChanges) {
            return this.typeName + ".prototype.checkNoChanges = function() { this.runDetectChanges(true); }";
        }
        else {
            return '';
        }
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genAddToChanges = function (r) {
        var newValue = this._names.getLocalName(r.selfIndex);
        var oldValue = this._names.getFieldName(r.selfIndex);
        if (!r.bindingRecord.callOnChanges())
            return "";
        return CHANGES_LOCAL + " = this.addChange(" + CHANGES_LOCAL + ", " + oldValue + ", " + newValue + ");";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeFirstInBinding = function (r) {
        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);
        var firstInBindng = lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
        return firstInBindng && !r.bindingRecord.isDirectiveLifecycle() ?
            this._names.getPropertyBindingIndex() + " = " + r.propertyBindingIndex + ";" :
            '';
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._maybeGenLastInDirective = function (r) {
        if (!r.lastInDirective)
            return "";
        return "\n      " + CHANGES_LOCAL + " = null;\n      " + this._genNotifyOnPushDetectors(r) + "\n      " + IS_CHANGED_LOCAL + " = false;\n    ";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnCheck = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange) " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".doCheck();";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnInit = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange && !" + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onInit();";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genOnChange = function (r) {
        var br = r.bindingRecord;
        return "if (!throwOnChange && " + CHANGES_LOCAL + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onChanges(" + CHANGES_LOCAL + ");";
    };
    /** @internal */
    ChangeDetectorJITGenerator.prototype._genNotifyOnPushDetectors = function (r) {
        var br = r.bindingRecord;
        if (!r.lastInDirective || br.isDefaultChangeDetection())
            return "";
        var retVal = "\n      if(" + IS_CHANGED_LOCAL + ") {\n        " + this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markAsCheckOnce();\n      }\n    ";
        return retVal;
    };
    return ChangeDetectorJITGenerator;
})();
exports.ChangeDetectorJITGenerator = ChangeDetectorJITGenerator;

},{"./abstract_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./codegen_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js","./codegen_logic_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_logic_util.js","./codegen_name_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_name_util.js","./proto_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var constants_1 = require('./constants');
var pipe_lifecycle_reflector_1 = require('./pipe_lifecycle_reflector');
var binding_record_1 = require('./binding_record');
var directive_record_1 = require('./directive_record');
/**
 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
 * reference
 * has not changed.
 *
 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
 *
 * Example:
 *
 * ```
 * if (this._latestValue === this._latestReturnedValue) {
 *    return this._latestReturnedValue;
 *  } else {
 *    this._latestReturnedValue = this._latestValue;
 *    return WrappedValue.wrap(this._latestValue); // this will force update
 *  }
 * ```
 */
var WrappedValue = (function () {
    function WrappedValue(wrapped) {
        this.wrapped = wrapped;
    }
    WrappedValue.wrap = function (value) {
        var w = _wrappedValues[_wrappedIndex++ % 5];
        w.wrapped = value;
        return w;
    };
    return WrappedValue;
})();
exports.WrappedValue = WrappedValue;
var _wrappedValues = [
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null)
];
var _wrappedIndex = 0;
var SimpleChange = (function () {
    function SimpleChange(previousValue, currentValue) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
    }
    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === ChangeDetectionUtil.uninitialized; };
    return SimpleChange;
})();
exports.SimpleChange = SimpleChange;
var _simpleChangesIndex = 0;
var _simpleChanges = [
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null),
    new SimpleChange(null, null)
];
function _simpleChange(previousValue, currentValue) {
    var index = _simpleChangesIndex++ % 20;
    var s = _simpleChanges[index];
    s.previousValue = previousValue;
    s.currentValue = currentValue;
    return s;
}
/* tslint:disable:requireParameterType */
var ChangeDetectionUtil = (function () {
    function ChangeDetectionUtil() {
    }
    ChangeDetectionUtil.arrayFn0 = function () { return []; };
    ChangeDetectionUtil.arrayFn1 = function (a1) { return [a1]; };
    ChangeDetectionUtil.arrayFn2 = function (a1, a2) { return [a1, a2]; };
    ChangeDetectionUtil.arrayFn3 = function (a1, a2, a3) { return [a1, a2, a3]; };
    ChangeDetectionUtil.arrayFn4 = function (a1, a2, a3, a4) { return [a1, a2, a3, a4]; };
    ChangeDetectionUtil.arrayFn5 = function (a1, a2, a3, a4, a5) { return [a1, a2, a3, a4, a5]; };
    ChangeDetectionUtil.arrayFn6 = function (a1, a2, a3, a4, a5, a6) { return [a1, a2, a3, a4, a5, a6]; };
    ChangeDetectionUtil.arrayFn7 = function (a1, a2, a3, a4, a5, a6, a7) { return [a1, a2, a3, a4, a5, a6, a7]; };
    ChangeDetectionUtil.arrayFn8 = function (a1, a2, a3, a4, a5, a6, a7, a8) {
        return [a1, a2, a3, a4, a5, a6, a7, a8];
    };
    ChangeDetectionUtil.arrayFn9 = function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
    };
    ChangeDetectionUtil.operation_negate = function (value) { return !value; };
    ChangeDetectionUtil.operation_add = function (left, right) { return left + right; };
    ChangeDetectionUtil.operation_subtract = function (left, right) { return left - right; };
    ChangeDetectionUtil.operation_multiply = function (left, right) { return left * right; };
    ChangeDetectionUtil.operation_divide = function (left, right) { return left / right; };
    ChangeDetectionUtil.operation_remainder = function (left, right) { return left % right; };
    ChangeDetectionUtil.operation_equals = function (left, right) { return left == right; };
    ChangeDetectionUtil.operation_not_equals = function (left, right) { return left != right; };
    ChangeDetectionUtil.operation_identical = function (left, right) { return left === right; };
    ChangeDetectionUtil.operation_not_identical = function (left, right) { return left !== right; };
    ChangeDetectionUtil.operation_less_then = function (left, right) { return left < right; };
    ChangeDetectionUtil.operation_greater_then = function (left, right) { return left > right; };
    ChangeDetectionUtil.operation_less_or_equals_then = function (left, right) { return left <= right; };
    ChangeDetectionUtil.operation_greater_or_equals_then = function (left, right) { return left >= right; };
    ChangeDetectionUtil.operation_logical_and = function (left, right) { return left && right; };
    ChangeDetectionUtil.operation_logical_or = function (left, right) { return left || right; };
    ChangeDetectionUtil.cond = function (cond, trueVal, falseVal) { return cond ? trueVal : falseVal; };
    ChangeDetectionUtil.mapFn = function (keys) {
        function buildMap(values) {
            var res = collection_1.StringMapWrapper.create();
            for (var i = 0; i < keys.length; ++i) {
                collection_1.StringMapWrapper.set(res, keys[i], values[i]);
            }
            return res;
        }
        switch (keys.length) {
            case 0:
                return function () { return []; };
            case 1:
                return function (a1) { return buildMap([a1]); };
            case 2:
                return function (a1, a2) { return buildMap([a1, a2]); };
            case 3:
                return function (a1, a2, a3) { return buildMap([a1, a2, a3]); };
            case 4:
                return function (a1, a2, a3, a4) { return buildMap([a1, a2, a3, a4]); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return buildMap([a1, a2, a3, a4, a5]); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) { return buildMap([a1, a2, a3, a4, a5, a6]); };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) { return buildMap([a1, a2, a3, a4, a5, a6, a7]); };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]); };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                };
            default:
                throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
        }
    };
    ChangeDetectionUtil.keyedAccess = function (obj, args) { return obj[args[0]]; };
    ChangeDetectionUtil.unwrapValue = function (value) {
        if (value instanceof WrappedValue) {
            return value.wrapped;
        }
        else {
            return value;
        }
    };
    ChangeDetectionUtil.changeDetectionMode = function (strategy) {
        return constants_1.isDefaultChangeDetectionStrategy(strategy) ? constants_1.ChangeDetectionStrategy.CheckAlways :
            constants_1.ChangeDetectionStrategy.CheckOnce;
    };
    ChangeDetectionUtil.simpleChange = function (previousValue, currentValue) {
        return _simpleChange(previousValue, currentValue);
    };
    ChangeDetectionUtil.isValueBlank = function (value) { return lang_1.isBlank(value); };
    ChangeDetectionUtil.s = function (value) { return lang_1.isPresent(value) ? "" + value : ''; };
    ChangeDetectionUtil.protoByIndex = function (protos, selfIndex) {
        return selfIndex < 1 ?
            null :
            protos[selfIndex - 1]; // self index is shifted by one because of context
    };
    ChangeDetectionUtil.callPipeOnDestroy = function (selectedPipe) {
        if (pipe_lifecycle_reflector_1.implementsOnDestroy(selectedPipe.pipe)) {
            selectedPipe.pipe.onDestroy();
        }
    };
    ChangeDetectionUtil.bindingTarget = function (mode, elementIndex, name, unit, debug) {
        return new binding_record_1.BindingTarget(mode, elementIndex, name, unit, debug);
    };
    ChangeDetectionUtil.directiveIndex = function (elementIndex, directiveIndex) {
        return new directive_record_1.DirectiveIndex(elementIndex, directiveIndex);
    };
    ChangeDetectionUtil.uninitialized = lang_1.CONST_EXPR(new Object());
    return ChangeDetectionUtil;
})();
exports.ChangeDetectionUtil = ChangeDetectionUtil;

},{"./binding_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/binding_record.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./pipe_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipe_lifecycle_reflector.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detector_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var constants_1 = require('./constants');
var ChangeDetectorRef = (function () {
    function ChangeDetectorRef() {
    }
    return ChangeDetectorRef;
})();
exports.ChangeDetectorRef = ChangeDetectorRef;
var ChangeDetectorRef_ = (function (_super) {
    __extends(ChangeDetectorRef_, _super);
    function ChangeDetectorRef_(_cd) {
        _super.call(this);
        this._cd = _cd;
    }
    ChangeDetectorRef_.prototype.markForCheck = function () { this._cd.markPathToRootAsCheckOnce(); };
    ChangeDetectorRef_.prototype.detach = function () { this._cd.mode = constants_1.ChangeDetectionStrategy.Detached; };
    ChangeDetectorRef_.prototype.detectChanges = function () { this._cd.detectChanges(); };
    ChangeDetectorRef_.prototype.reattach = function () {
        this._cd.mode = constants_1.ChangeDetectionStrategy.CheckAlways;
        this.markForCheck();
    };
    return ChangeDetectorRef_;
})(ChangeDetectorRef);
exports.ChangeDetectorRef_ = ChangeDetectorRef_;

},{"./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/coalesce.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var proto_record_1 = require('./proto_record');
/**
 * Removes "duplicate" records. It assuming that record evaluation does not
 * have side-effects.
 *
 * Records that are not last in bindings are removed and all the indices
 * of the records that depend on them are updated.
 *
 * Records that are last in bindings CANNOT be removed, and instead are
 * replaced with very cheap SELF records.
 */
function coalesce(records) {
    var res = [];
    var indexMap = new collection_1.Map();
    for (var i = 0; i < records.length; ++i) {
        var r = records[i];
        var record = _replaceIndices(r, res.length + 1, indexMap);
        var matchingRecord = _findMatching(record, res);
        if (lang_1.isPresent(matchingRecord) && record.lastInBinding) {
            res.push(_selfRecord(record, matchingRecord.selfIndex, res.length + 1));
            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
            matchingRecord.referencedBySelf = true;
        }
        else if (lang_1.isPresent(matchingRecord) && !record.lastInBinding) {
            if (record.argumentToPureFunction) {
                matchingRecord.argumentToPureFunction = true;
            }
            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
        }
        else {
            res.push(record);
            indexMap.set(r.selfIndex, record.selfIndex);
        }
    }
    return res;
}
exports.coalesce = coalesce;
function _selfRecord(r, contextIndex, selfIndex) {
    return new proto_record_1.ProtoRecord(proto_record_1.RecordType.Self, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, false, false, r.propertyBindingIndex);
}
function _findMatching(r, rs) {
    return collection_1.ListWrapper.find(rs, function (rr) { return rr.mode !== proto_record_1.RecordType.DirectiveLifecycle && _sameDirIndex(rr, r) &&
        rr.mode === r.mode && lang_1.looseIdentical(rr.funcOrValue, r.funcOrValue) &&
        rr.contextIndex === r.contextIndex && lang_1.looseIdentical(rr.name, r.name) &&
        collection_1.ListWrapper.equals(rr.args, r.args); });
}
function _sameDirIndex(a, b) {
    var di1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;
    var ei1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;
    var di2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;
    var ei2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;
    return di1 === di2 && ei1 === ei2;
}
function _replaceIndices(r, selfIndex, indexMap) {
    var args = r.args.map(function (a) { return _map(indexMap, a); });
    var contextIndex = _map(indexMap, r.contextIndex);
    return new proto_record_1.ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, r.argumentToPureFunction, r.referencedBySelf, r.propertyBindingIndex);
}
function _map(indexMap, value) {
    var r = indexMap.get(value);
    return lang_1.isPresent(r) ? r : value;
}

},{"./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js":[function(require,module,exports){
'use strict';/**
 * Converts `funcOrValue` to a string which can be used in generated code.
 */
function codify(obj) {
    return JSON.stringify(obj);
}
exports.codify = codify;
function rawString(str) {
    return "'" + str + "'";
}
exports.rawString = rawString;
/**
 * Combine the strings of generated code into a single interpolated string.
 * Each element of `vals` is expected to be a string literal or a codegen'd
 * call to a method returning a string.
 */
function combineGeneratedStrings(vals) {
    return vals.join(' + ');
}
exports.combineGeneratedStrings = combineGeneratedStrings;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_logic_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var codegen_facade_1 = require('./codegen_facade');
var proto_record_1 = require('./proto_record');
var constants_1 = require('./constants');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Class responsible for providing change detection logic for change detector classes.
 */
var CodegenLogicUtil = (function () {
    function CodegenLogicUtil(_names, _utilName, _changeDetection) {
        this._names = _names;
        this._utilName = _utilName;
        this._changeDetection = _changeDetection;
    }
    /**
     * Generates a statement which updates the local variable representing `protoRec` with the current
     * value of the record. Used by property bindings.
     */
    CodegenLogicUtil.prototype.genPropertyBindingEvalValue = function (protoRec) {
        var _this = this;
        return this._genEvalValue(protoRec, function (idx) { return _this._names.getLocalName(idx); }, this._names.getLocalsAccessorName());
    };
    /**
     * Generates a statement which updates the local variable representing `protoRec` with the current
     * value of the record. Used by event bindings.
     */
    CodegenLogicUtil.prototype.genEventBindingEvalValue = function (eventRecord, protoRec) {
        var _this = this;
        return this._genEvalValue(protoRec, function (idx) { return _this._names.getEventLocalName(eventRecord, idx); }, "locals");
    };
    CodegenLogicUtil.prototype._genEvalValue = function (protoRec, getLocalName, localsAccessor) {
        var context = (protoRec.contextIndex == -1) ?
            this._names.getDirectiveName(protoRec.directiveIndex) :
            getLocalName(protoRec.contextIndex);
        var argString = protoRec.args.map(function (arg) { return getLocalName(arg); }).join(", ");
        var rhs;
        switch (protoRec.mode) {
            case proto_record_1.RecordType.Self:
                rhs = context;
                break;
            case proto_record_1.RecordType.Const:
                rhs = codegen_facade_1.codify(protoRec.funcOrValue);
                break;
            case proto_record_1.RecordType.PropertyRead:
                rhs = this._observe(context + "." + protoRec.name, protoRec);
                break;
            case proto_record_1.RecordType.SafeProperty:
                var read = this._observe(context + "." + protoRec.name, protoRec);
                rhs =
                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(read, protoRec);
                break;
            case proto_record_1.RecordType.PropertyWrite:
                rhs = context + "." + protoRec.name + " = " + getLocalName(protoRec.args[0]);
                break;
            case proto_record_1.RecordType.Local:
                rhs = this._observe(localsAccessor + ".get(" + codegen_facade_1.rawString(protoRec.name) + ")", protoRec);
                break;
            case proto_record_1.RecordType.InvokeMethod:
                rhs = this._observe(context + "." + protoRec.name + "(" + argString + ")", protoRec);
                break;
            case proto_record_1.RecordType.SafeMethodInvoke:
                var invoke = context + "." + protoRec.name + "(" + argString + ")";
                rhs =
                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(invoke, protoRec);
                break;
            case proto_record_1.RecordType.InvokeClosure:
                rhs = context + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.PrimitiveOp:
                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.CollectionLiteral:
                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
                break;
            case proto_record_1.RecordType.Interpolate:
                rhs = this._genInterpolation(protoRec);
                break;
            case proto_record_1.RecordType.KeyedRead:
                rhs = this._observe(context + "[" + getLocalName(protoRec.args[0]) + "]", protoRec);
                break;
            case proto_record_1.RecordType.KeyedWrite:
                rhs = context + "[" + getLocalName(protoRec.args[0]) + "] = " + getLocalName(protoRec.args[1]);
                break;
            case proto_record_1.RecordType.Chain:
                rhs = 'null';
                break;
            default:
                throw new exceptions_1.BaseException("Unknown operation " + protoRec.mode);
        }
        return getLocalName(protoRec.selfIndex) + " = " + rhs + ";";
    };
    /** @internal */
    CodegenLogicUtil.prototype._observe = function (exp, rec) {
        // This is an experimental feature. Works only in Dart.
        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            return "this.observeValue(" + exp + ", " + rec.selfIndex + ")";
        }
        else {
            return exp;
        }
    };
    CodegenLogicUtil.prototype.genPropertyBindingTargets = function (propertyBindingTargets, genDebugInfo) {
        var _this = this;
        var bs = propertyBindingTargets.map(function (b) {
            if (lang_1.isBlank(b))
                return "null";
            var debug = genDebugInfo ? codegen_facade_1.codify(b.debug) : "null";
            return _this._utilName + ".bindingTarget(" + codegen_facade_1.codify(b.mode) + ", " + b.elementIndex + ", " + codegen_facade_1.codify(b.name) + ", " + codegen_facade_1.codify(b.unit) + ", " + debug + ")";
        });
        return "[" + bs.join(", ") + "]";
    };
    CodegenLogicUtil.prototype.genDirectiveIndices = function (directiveRecords) {
        var _this = this;
        var bs = directiveRecords.map(function (b) {
            return (_this._utilName + ".directiveIndex(" + b.directiveIndex.elementIndex + ", " + b.directiveIndex.directiveIndex + ")");
        });
        return "[" + bs.join(", ") + "]";
    };
    /** @internal */
    CodegenLogicUtil.prototype._genInterpolation = function (protoRec) {
        var iVals = [];
        for (var i = 0; i < protoRec.args.length; ++i) {
            iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[i]));
            iVals.push(this._utilName + ".s(" + this._names.getLocalName(protoRec.args[i]) + ")");
        }
        iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[protoRec.args.length]));
        return codegen_facade_1.combineGeneratedStrings(iVals);
    };
    CodegenLogicUtil.prototype.genHydrateDirectives = function (directiveRecords) {
        var res = [];
        for (var i = 0; i < directiveRecords.length; ++i) {
            var r = directiveRecords[i];
            res.push(this._names.getDirectiveName(r.directiveIndex) + " = " + this._genReadDirective(i) + ";");
        }
        return res.join("\n");
    };
    CodegenLogicUtil.prototype._genReadDirective = function (index) {
        // This is an experimental feature. Works only in Dart.
        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            return "this.observeDirective(this.getDirectiveFor(directives, " + index + "), " + index + ")";
        }
        else {
            return "this.getDirectiveFor(directives, " + index + ")";
        }
    };
    CodegenLogicUtil.prototype.genHydrateDetectors = function (directiveRecords) {
        var res = [];
        for (var i = 0; i < directiveRecords.length; ++i) {
            var r = directiveRecords[i];
            if (!r.isDefaultChangeDetection()) {
                res.push(this._names.getDetectorName(r.directiveIndex) + " = this.getDetectorFor(directives, " + i + ");");
            }
        }
        return res.join("\n");
    };
    CodegenLogicUtil.prototype.genContentLifecycleCallbacks = function (directiveRecords) {
        var res = [];
        // NOTE(kegluneq): Order is important!
        for (var i = directiveRecords.length - 1; i >= 0; --i) {
            var dir = directiveRecords[i];
            if (dir.callAfterContentInit) {
                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterContentInit();");
            }
            if (dir.callAfterContentChecked) {
                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterContentChecked();");
            }
        }
        return res;
    };
    CodegenLogicUtil.prototype.genViewLifecycleCallbacks = function (directiveRecords) {
        var res = [];
        // NOTE(kegluneq): Order is important!
        for (var i = directiveRecords.length - 1; i >= 0; --i) {
            var dir = directiveRecords[i];
            if (dir.callAfterViewInit) {
                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterViewInit();");
            }
            if (dir.callAfterViewChecked) {
                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterViewChecked();");
            }
        }
        return res;
    };
    return CodegenLogicUtil;
})();
exports.CodegenLogicUtil = CodegenLogicUtil;

},{"./codegen_facade":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_facade.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/codegen_name_util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
// The names of these fields must be kept in sync with abstract_change_detector.ts or change
// detection will fail.
var _ALREADY_CHECKED_ACCESSOR = "alreadyChecked";
var _CONTEXT_ACCESSOR = "context";
var _PROP_BINDING_INDEX = "propertyBindingIndex";
var _DIRECTIVES_ACCESSOR = "directiveIndices";
var _DISPATCHER_ACCESSOR = "dispatcher";
var _LOCALS_ACCESSOR = "locals";
var _MODE_ACCESSOR = "mode";
var _PIPES_ACCESSOR = "pipes";
var _PROTOS_ACCESSOR = "protos";
// `context` is always first.
exports.CONTEXT_INDEX = 0;
var _FIELD_PREFIX = 'this.';
var _whiteSpaceRegExp = lang_1.RegExpWrapper.create("\\W", "g");
/**
 * Returns `s` with all non-identifier characters removed.
 */
function sanitizeName(s) {
    return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
}
exports.sanitizeName = sanitizeName;
/**
 * Class responsible for providing field and local variable names for change detector classes.
 * Also provides some convenience functions, for example, declaring variables, destroying pipes,
 * and dehydrating the detector.
 */
var CodegenNameUtil = (function () {
    function CodegenNameUtil(_records, _eventBindings, _directiveRecords, _utilName) {
        this._records = _records;
        this._eventBindings = _eventBindings;
        this._directiveRecords = _directiveRecords;
        this._utilName = _utilName;
        /** @internal */
        this._sanitizedEventNames = new collection_1.Map();
        this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this._records.length + 1);
        this._sanitizedNames[exports.CONTEXT_INDEX] = _CONTEXT_ACCESSOR;
        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
            this._sanitizedNames[i + 1] = sanitizeName("" + this._records[i].name + i);
        }
        for (var ebIndex = 0; ebIndex < _eventBindings.length; ++ebIndex) {
            var eb = _eventBindings[ebIndex];
            var names = [_CONTEXT_ACCESSOR];
            for (var i = 0, iLen = eb.records.length; i < iLen; ++i) {
                names.push(sanitizeName("" + eb.records[i].name + i + "_" + ebIndex));
            }
            this._sanitizedEventNames.set(eb, names);
        }
    }
    /** @internal */
    CodegenNameUtil.prototype._addFieldPrefix = function (name) { return "" + _FIELD_PREFIX + name; };
    CodegenNameUtil.prototype.getDispatcherName = function () { return this._addFieldPrefix(_DISPATCHER_ACCESSOR); };
    CodegenNameUtil.prototype.getPipesAccessorName = function () { return this._addFieldPrefix(_PIPES_ACCESSOR); };
    CodegenNameUtil.prototype.getProtosName = function () { return this._addFieldPrefix(_PROTOS_ACCESSOR); };
    CodegenNameUtil.prototype.getDirectivesAccessorName = function () { return this._addFieldPrefix(_DIRECTIVES_ACCESSOR); };
    CodegenNameUtil.prototype.getLocalsAccessorName = function () { return this._addFieldPrefix(_LOCALS_ACCESSOR); };
    CodegenNameUtil.prototype.getAlreadyCheckedName = function () { return this._addFieldPrefix(_ALREADY_CHECKED_ACCESSOR); };
    CodegenNameUtil.prototype.getModeName = function () { return this._addFieldPrefix(_MODE_ACCESSOR); };
    CodegenNameUtil.prototype.getPropertyBindingIndex = function () { return this._addFieldPrefix(_PROP_BINDING_INDEX); };
    CodegenNameUtil.prototype.getLocalName = function (idx) { return "l_" + this._sanitizedNames[idx]; };
    CodegenNameUtil.prototype.getEventLocalName = function (eb, idx) {
        return "l_" + this._sanitizedEventNames.get(eb)[idx];
    };
    CodegenNameUtil.prototype.getChangeName = function (idx) { return "c_" + this._sanitizedNames[idx]; };
    /**
     * Generate a statement initializing local variables used when detecting changes.
     */
    CodegenNameUtil.prototype.genInitLocals = function () {
        var declarations = [];
        var assignments = [];
        for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {
            if (i == exports.CONTEXT_INDEX) {
                declarations.push(this.getLocalName(i) + " = " + this.getFieldName(i));
            }
            else {
                var rec = this._records[i - 1];
                if (rec.argumentToPureFunction) {
                    var changeName = this.getChangeName(i);
                    declarations.push(this.getLocalName(i) + "," + changeName);
                    assignments.push(changeName);
                }
                else {
                    declarations.push("" + this.getLocalName(i));
                }
            }
        }
        var assignmentsCode = collection_1.ListWrapper.isEmpty(assignments) ? '' : assignments.join('=') + " = false;";
        return "var " + declarations.join(',') + ";" + assignmentsCode;
    };
    /**
     * Generate a statement initializing local variables for event handlers.
     */
    CodegenNameUtil.prototype.genInitEventLocals = function () {
        var _this = this;
        var res = [(this.getLocalName(exports.CONTEXT_INDEX) + " = " + this.getFieldName(exports.CONTEXT_INDEX))];
        this._sanitizedEventNames.forEach(function (names, eb) {
            for (var i = 0; i < names.length; ++i) {
                if (i !== exports.CONTEXT_INDEX) {
                    res.push("" + _this.getEventLocalName(eb, i));
                }
            }
        });
        return res.length > 1 ? "var " + res.join(',') + ";" : '';
    };
    CodegenNameUtil.prototype.getPreventDefaultAccesor = function () { return "preventDefault"; };
    CodegenNameUtil.prototype.getFieldCount = function () { return this._sanitizedNames.length; };
    CodegenNameUtil.prototype.getFieldName = function (idx) { return this._addFieldPrefix(this._sanitizedNames[idx]); };
    CodegenNameUtil.prototype.getAllFieldNames = function () {
        var fieldList = [];
        for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {
            if (k === 0 || this._records[k - 1].shouldBeChecked()) {
                fieldList.push(this.getFieldName(k));
            }
        }
        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
            var rec = this._records[i];
            if (rec.isPipeRecord()) {
                fieldList.push(this.getPipeName(rec.selfIndex));
            }
        }
        for (var j = 0, jLen = this._directiveRecords.length; j < jLen; ++j) {
            var dRec = this._directiveRecords[j];
            fieldList.push(this.getDirectiveName(dRec.directiveIndex));
            if (!dRec.isDefaultChangeDetection()) {
                fieldList.push(this.getDetectorName(dRec.directiveIndex));
            }
        }
        return fieldList;
    };
    /**
     * Generates statements which clear all fields so that the change detector is dehydrated.
     */
    CodegenNameUtil.prototype.genDehydrateFields = function () {
        var fields = this.getAllFieldNames();
        collection_1.ListWrapper.removeAt(fields, exports.CONTEXT_INDEX);
        if (collection_1.ListWrapper.isEmpty(fields))
            return '';
        // At least one assignment.
        fields.push(this._utilName + ".uninitialized;");
        return fields.join(' = ');
    };
    /**
     * Generates statements destroying all pipe variables.
     */
    CodegenNameUtil.prototype.genPipeOnDestroy = function () {
        var _this = this;
        return collection_1.ListWrapper.filter(this._records, function (r) { return r.isPipeRecord(); })
            .map(function (r) { return (_this._utilName + ".callPipeOnDestroy(" + _this.getPipeName(r.selfIndex) + ");"); })
            .join('\n');
    };
    CodegenNameUtil.prototype.getPipeName = function (idx) {
        return this._addFieldPrefix(this._sanitizedNames[idx] + "_pipe");
    };
    CodegenNameUtil.prototype.getDirectiveName = function (d) {
        return this._addFieldPrefix("directive_" + d.name);
    };
    CodegenNameUtil.prototype.getDetectorName = function (d) { return this._addFieldPrefix("detector_" + d.name); };
    return CodegenNameUtil;
})();
exports.CodegenNameUtil = CodegenNameUtil;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
(function (ChangeDetectionStrategy) {
    /**
     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckOnce"] = 0] = "CheckOnce";
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Checked"] = 1] = "Checked";
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckAlways"] = 2] = "CheckAlways";
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Detached"] = 3] = "Detached";
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 4] = "OnPush";
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 5] = "Default";
    /**
     * This is an experimental feature. Works only in Dart.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPushObserve"] = 6] = "OnPushObserve";
})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
exports.CHANGE_DECTION_STRATEGY_VALUES = [
    ChangeDetectionStrategy.CheckOnce,
    ChangeDetectionStrategy.Checked,
    ChangeDetectionStrategy.CheckAlways,
    ChangeDetectionStrategy.Detached,
    ChangeDetectionStrategy.OnPush,
    ChangeDetectionStrategy.Default,
    ChangeDetectionStrategy.OnPushObserve
];
function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return lang_1.isBlank(changeDetectionStrategy) ||
        changeDetectionStrategy === ChangeDetectionStrategy.Default;
}
exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_iterable_differ.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_2 = require('angular2/src/core/facade/lang');
var DefaultIterableDifferFactory = (function () {
    function DefaultIterableDifferFactory() {
    }
    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
    DefaultIterableDifferFactory.prototype.create = function (cdRef) { return new DefaultIterableDiffer(); };
    DefaultIterableDifferFactory = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DefaultIterableDifferFactory);
    return DefaultIterableDifferFactory;
})();
exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
var DefaultIterableDiffer = (function () {
    function DefaultIterableDiffer() {
        this._collection = null;
        this._length = null;
        // Keeps track of the used records at any point in time (during & across `_check()` calls)
        this._linkedRecords = null;
        // Keeps track of the removed records at any point in time during `_check()` calls.
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
        get: function () { return this._collection; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
        get: function () { return this._length; },
        enumerable: true,
        configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._itHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
        var record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.diff = function (collection) {
        if (lang_2.isBlank(collection))
            collection = [];
        if (!collection_1.isListLikeIterable(collection)) {
            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
        }
        if (this.check(collection)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultIterableDiffer.prototype.onDestroy = function () { };
    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
    DefaultIterableDiffer.prototype.check = function (collection) {
        var _this = this;
        this._reset();
        var record = this._itHead;
        var mayBeDirty = false;
        var index;
        var item;
        if (lang_2.isArray(collection)) {
            var list = collection;
            this._length = collection.length;
            for (index = 0; index < this._length; index++) {
                item = list[index];
                if (record === null || !lang_2.looseIdentical(record.item, item)) {
                    record = this._mismatch(record, item, index);
                    mayBeDirty = true;
                }
                else if (mayBeDirty) {
                    // TODO(misko): can we limit this to duplicates only?
                    record = this._verifyReinsertion(record, item, index);
                }
                record = record._next;
            }
        }
        else {
            index = 0;
            collection_1.iterateListLike(collection, function (item) {
                if (record === null || !lang_2.looseIdentical(record.item, item)) {
                    record = _this._mismatch(record, item, index);
                    mayBeDirty = true;
                }
                else if (mayBeDirty) {
                    // TODO(misko): can we limit this to duplicates only?
                    record = _this._verifyReinsertion(record, item, index);
                }
                record = record._next;
                index++;
            });
            this._length = index;
        }
        this._truncate(record);
        this._collection = collection;
        return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
        // CollectionChanges is considered dirty if it has any additions, moves or removals.
        get: function () {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reset the state of the change objects to show no changes. This means set previousKey to
     * currentKey, and clear all of the queues (additions, moves, removals).
     * Set the previousIndexes of moved and added items to their currentIndexes
     * Reset the list of additions, moves and removals
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            var nextRecord;
            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
            }
            this._additionsHead = this._additionsTail = null;
            for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
            }
            this._movesHead = this._movesTail = null;
            this._removalsHead = this._removalsTail = null;
        }
    };
    /**
     * This is the core function which handles differences between collections.
     *
     * - `record` is the record which we saw at this position last time. If null then it is a new
     *   item.
     * - `item` is the current item in the collection
     * - `index` is the position of the item in the collection
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._mismatch = function (record, item, index) {
        // The previous record after which we will append the current one.
        var previousRecord;
        if (record === null) {
            previousRecord = this._itTail;
        }
        else {
            previousRecord = record._prev;
            // Remove the record from the collection since we know it does not match the item.
            this._remove(record);
        }
        // Attempt to see if we have seen the item before.
        record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
        if (record !== null) {
            // We have seen this before, we need to move it forward in the collection.
            this._moveAfter(record, previousRecord, index);
        }
        else {
            // Never seen it, check evicted list.
            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
            if (record !== null) {
                // It is an item which we have evicted earlier: reinsert it back into the list.
                this._reinsertAfter(record, previousRecord, index);
            }
            else {
                // It is a new item: add it.
                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
            }
        }
        return record;
    };
    /**
     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
     *
     * Use case: `[a, a]` => `[b, a, a]`
     *
     * If we did not have this check then the insertion of `b` would:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) leave `a` at index `1` as is. <-- this is wrong!
     *   3) reinsert `a` at index 2. <-- this is wrong!
     *
     * The correct behavior is:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) reinsert `a` at index 1.
     *   3) move `a` at from `1` to `2`.
     *
     *
     * Double check that we have not evicted a duplicate item. We need to check if the item type may
     * have already been removed:
     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
     * at the end.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, index) {
        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
        if (reinsertRecord !== null) {
            record = this._reinsertAfter(reinsertRecord, record._prev, index);
        }
        else if (record.currentIndex != index) {
            record.currentIndex = index;
            this._addToMoves(record, index);
        }
        return record;
    };
    /**
     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
     *
     * - `record` The first excess {@link CollectionChangeRecord}.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._truncate = function (record) {
        // Anything after that needs to be removed;
        while (record !== null) {
            var nextRecord = record._next;
            this._addToRemovals(this._unlink(record));
            record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
            this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
            this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
            this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
            this._removalsTail._nextRemoved = null;
        }
    };
    /** @internal */
    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.remove(record);
        }
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
            // todo(vicb)
            // assert(this._additionsHead === null);
            this._additionsTail = this._additionsHead = record;
        }
        else {
            // todo(vicb)
            // assert(_additionsTail._nextAdded === null);
            // assert(record._nextAdded === null);
            this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
        // todo(vicb)
        // assert(record != prevRecord);
        // assert(record._next === null);
        // assert(record._prev === null);
        var next = prevRecord === null ? this._itHead : prevRecord._next;
        // todo(vicb)
        // assert(next != record);
        // assert(prevRecord != record);
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
            this._itTail = record;
        }
        else {
            next._prev = record;
        }
        if (prevRecord === null) {
            this._itHead = record;
        }
        else {
            prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
            this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._remove = function (record) {
        return this._addToRemovals(this._unlink(record));
    };
    /** @internal */
    DefaultIterableDiffer.prototype._unlink = function (record) {
        if (this._linkedRecords !== null) {
            this._linkedRecords.remove(record);
        }
        var prev = record._prev;
        var next = record._next;
        // todo(vicb)
        // assert((record._prev = null) === null);
        // assert((record._next = null) === null);
        if (prev === null) {
            this._itHead = next;
        }
        else {
            prev._next = next;
        }
        if (next === null) {
            this._itTail = prev;
        }
        else {
            next._prev = prev;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
        // todo(vicb)
        // assert(record._nextMoved === null);
        if (record.previousIndex === toIndex) {
            return record;
        }
        if (this._movesTail === null) {
            // todo(vicb)
            // assert(_movesHead === null);
            this._movesTail = this._movesHead = record;
        }
        else {
            // todo(vicb)
            // assert(_movesTail._nextMoved === null);
            this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
        if (this._unlinkedRecords === null) {
            this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
            // todo(vicb)
            // assert(_removalsHead === null);
            this._removalsTail = this._removalsHead = record;
            record._prevRemoved = null;
        }
        else {
            // todo(vicb)
            // assert(_removalsTail._nextRemoved === null);
            // assert(record._nextRemoved === null);
            record._prevRemoved = this._removalsTail;
            this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
    };
    DefaultIterableDiffer.prototype.toString = function () {
        var record;
        var list = [];
        for (record = this._itHead; record !== null; record = record._next) {
            list.push(record);
        }
        var previous = [];
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            previous.push(record);
        }
        var additions = [];
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            additions.push(record);
        }
        var moves = [];
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            moves.push(record);
        }
        var removals = [];
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            removals.push(record);
        }
        return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n";
    };
    return DefaultIterableDiffer;
})();
exports.DefaultIterableDiffer = DefaultIterableDiffer;
var CollectionChangeRecord = (function () {
    function CollectionChangeRecord(item) {
        this.item = item;
        this.currentIndex = null;
        this.previousIndex = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._prev = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._prevDup = null;
        /** @internal */
        this._nextDup = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextMoved = null;
    }
    CollectionChangeRecord.prototype.toString = function () {
        return this.previousIndex === this.currentIndex ?
            lang_2.stringify(this.item) :
            lang_2.stringify(this.item) + '[' + lang_2.stringify(this.previousIndex) + '->' +
                lang_2.stringify(this.currentIndex) + ']';
    };
    return CollectionChangeRecord;
})();
exports.CollectionChangeRecord = CollectionChangeRecord;
// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
var _DuplicateItemRecordList = (function () {
    function _DuplicateItemRecordList() {
        /** @internal */
        this._head = null;
        /** @internal */
        this._tail = null;
    }
    /**
     * Append the record to the list of duplicates.
     *
     * Note: by design all records in the list of duplicates hold the same value in record.item.
     */
    _DuplicateItemRecordList.prototype.add = function (record) {
        if (this._head === null) {
            this._head = this._tail = record;
            record._nextDup = null;
            record._prevDup = null;
        }
        else {
            // todo(vicb)
            // assert(record.item ==  _head.item ||
            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
            this._tail._nextDup = record;
            record._prevDup = this._tail;
            record._nextDup = null;
            this._tail = record;
        }
    };
    // Returns a CollectionChangeRecord having CollectionChangeRecord.item == item and
    // CollectionChangeRecord.currentIndex >= afterIndex
    _DuplicateItemRecordList.prototype.get = function (item, afterIndex) {
        var record;
        for (record = this._head; record !== null; record = record._nextDup) {
            if ((afterIndex === null || afterIndex < record.currentIndex) &&
                lang_2.looseIdentical(record.item, item)) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
     *
     * Returns whether the list of duplicates is empty.
     */
    _DuplicateItemRecordList.prototype.remove = function (record) {
        // todo(vicb)
        // assert(() {
        //  // verify that the record being removed is in the list.
        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
        //    if (identical(cursor, record)) return true;
        //  }
        //  return false;
        //});
        var prev = record._prevDup;
        var next = record._nextDup;
        if (prev === null) {
            this._head = next;
        }
        else {
            prev._nextDup = next;
        }
        if (next === null) {
            this._tail = prev;
        }
        else {
            next._prevDup = prev;
        }
        return this._head === null;
    };
    return _DuplicateItemRecordList;
})();
var _DuplicateMap = (function () {
    function _DuplicateMap() {
        this.map = new Map();
    }
    _DuplicateMap.prototype.put = function (record) {
        // todo(vicb) handle corner cases
        var key = lang_2.getMapKey(record.item);
        var duplicates = this.map.get(key);
        if (!lang_2.isPresent(duplicates)) {
            duplicates = new _DuplicateItemRecordList();
            this.map.set(key, duplicates);
        }
        duplicates.add(record);
    };
    /**
     * Retrieve the `value` using key. Because the CollectionChangeRecord value maybe one which we
     * have already iterated over, we use the afterIndex to pretend it is not there.
     *
     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
     * have any more `a`s needs to return the last `a` not the first or second.
     */
    _DuplicateMap.prototype.get = function (value, afterIndex) {
        if (afterIndex === void 0) { afterIndex = null; }
        var key = lang_2.getMapKey(value);
        var recordList = this.map.get(key);
        return lang_2.isBlank(recordList) ? null : recordList.get(value, afterIndex);
    };
    /**
     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
     *
     * The list of duplicates also is removed from the map if it gets empty.
     */
    _DuplicateMap.prototype.remove = function (record) {
        var key = lang_2.getMapKey(record.item);
        // todo(vicb)
        // assert(this.map.containsKey(key));
        var recordList = this.map.get(key);
        // Remove the list of duplicates when it gets empty
        if (recordList.remove(record)) {
            this.map.delete(key);
        }
        return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
        get: function () { return this.map.size === 0; },
        enumerable: true,
        configurable: true
    });
    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_2.stringify(this.map) + ')'; };
    return _DuplicateMap;
})();

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/default_keyvalue_differ.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var DefaultKeyValueDifferFactory = (function () {
    function DefaultKeyValueDifferFactory() {
    }
    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
    DefaultKeyValueDifferFactory = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DefaultKeyValueDifferFactory);
    return DefaultKeyValueDifferFactory;
})();
exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
var DefaultKeyValueDiffer = (function () {
    function DefaultKeyValueDiffer() {
        this._records = new Map();
        this._mapHead = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
        get: function () {
            return this._additionsHead !== null || this._changesHead !== null ||
                this._removalsHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
        var record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.diff = function (map) {
        if (lang_1.isBlank(map))
            map = collection_1.MapWrapper.createFromPairs([]);
        if (!(map instanceof Map || lang_1.isJsObject(map))) {
            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
        }
        if (this.check(map)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
    DefaultKeyValueDiffer.prototype.check = function (map) {
        var _this = this;
        this._reset();
        var records = this._records;
        var oldSeqRecord = this._mapHead;
        var lastOldSeqRecord = null;
        var lastNewSeqRecord = null;
        var seqChanged = false;
        this._forEach(map, function (value, key) {
            var newSeqRecord;
            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {
                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                    oldSeqRecord.currentValue = value;
                    _this._addToChanges(oldSeqRecord);
                }
            }
            else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                    oldSeqRecord._next = null;
                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                    _this._addToRemovals(oldSeqRecord);
                }
                if (records.has(key)) {
                    newSeqRecord = records.get(key);
                }
                else {
                    newSeqRecord = new KVChangeRecord(key);
                    records.set(key, newSeqRecord);
                    newSeqRecord.currentValue = value;
                    _this._addToAdditions(newSeqRecord);
                }
            }
            if (seqChanged) {
                if (_this._isInRemovals(newSeqRecord)) {
                    _this._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                    _this._mapHead = newSeqRecord;
                }
                else {
                    lastNewSeqRecord._next = newSeqRecord;
                }
            }
            lastOldSeqRecord = oldSeqRecord;
            lastNewSeqRecord = newSeqRecord;
            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
        });
        this._truncate(lastOldSeqRecord, oldSeqRecord);
        return this.isDirty;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            // Record the state of the mapping
            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
            }
            for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
            }
            // todo(vicb) once assert is supported
            // assert(() {
            //  var r = _changesHead;
            //  while (r != null) {
            //    var nextRecord = r._nextChanged;
            //    r._nextChanged = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _additionsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextAdded;
            //    r._nextAdded = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _removalsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextRemoved;
            //    r._nextRemoved = null;
            //    r = nextRecord;
            //  }
            //
            //  return true;
            //});
            this._changesHead = this._changesTail = null;
            this._additionsHead = this._additionsTail = null;
            this._removalsHead = this._removalsTail = null;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
        while (record !== null) {
            if (lastRecord === null) {
                this._mapHead = null;
            }
            else {
                lastRecord._next = null;
            }
            var nextRecord = record._next;
            // todo(vicb) assert
            // assert((() {
            //  record._next = null;
            //  return true;
            //}));
            this._addToRemovals(record);
            lastRecord = record;
            record = nextRecord;
        }
        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
            rec.previousValue = rec.currentValue;
            rec.currentValue = null;
            this._records.delete(rec.key);
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
        return record === this._removalsHead || record._nextRemoved !== null ||
            record._prevRemoved !== null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._removalsHead === null) {
            this._removalsHead = this._removalsTail = record;
        }
        else {
            this._removalsTail._nextRemoved = record;
            record._prevRemoved = this._removalsTail;
            this._removalsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
        var next = record._next;
        if (prev === null) {
            this._mapHead = next;
        }
        else {
            prev._next = next;
        }
        // todo(vicb) assert
        // assert((() {
        //  record._next = null;
        //  return true;
        //})());
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        record._prevRemoved = record._nextRemoved = null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
        // todo(vicb): assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._additionsHead === null) {
            this._additionsHead = this._additionsTail = record;
        }
        else {
            this._additionsTail._nextAdded = record;
            this._additionsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
        // todo(vicb) assert
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._changesHead === null) {
            this._changesHead = this._changesTail = record;
        }
        else {
            this._changesTail._nextChanged = record;
            this._changesTail = record;
        }
    };
    DefaultKeyValueDiffer.prototype.toString = function () {
        var items = [];
        var previous = [];
        var changes = [];
        var additions = [];
        var removals = [];
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            items.push(lang_1.stringify(record));
        }
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            previous.push(lang_1.stringify(record));
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            changes.push(lang_1.stringify(record));
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            additions.push(lang_1.stringify(record));
        }
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            removals.push(lang_1.stringify(record));
        }
        return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n";
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
        if (obj instanceof Map) {
            obj.forEach(fn);
        }
        else {
            collection_1.StringMapWrapper.forEach(obj, fn);
        }
    };
    return DefaultKeyValueDiffer;
})();
exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
var KVChangeRecord = (function () {
    function KVChangeRecord(key) {
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextChanged = null;
    }
    KVChangeRecord.prototype.toString = function () {
        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
            lang_1.stringify(this.key) :
            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
                lang_1.stringify(this.currentValue) + ']');
    };
    return KVChangeRecord;
})();
exports.KVChangeRecord = KVChangeRecord;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/iterable_differs.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
/**
 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
 */
var IterableDiffers = (function () {
    function IterableDiffers(factories) {
        this.factories = factories;
    }
    IterableDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new IterableDiffers(factories);
        }
        else {
            return new IterableDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
     * inherited {@link IterableDiffers} instance with the provided factories and return a new
     * {@link IterableDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link IterableDiffer} available.
     *
     * # Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     IterableDiffers.extend([new ImmutableListDiffer()])
     *   ]
     * })
     * ```
     */
    IterableDiffers.extend = function (factories) {
        return new di_1.Provider(IterableDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
                }
                return IterableDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    IterableDiffers.prototype.find = function (iterable) {
        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(iterable); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "'");
        }
    };
    IterableDiffers = __decorate([
        di_1.Injectable(),
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], IterableDiffers);
    return IterableDiffers;
})();
exports.IterableDiffers = IterableDiffers;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/differs/keyvalue_differs.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
/**
 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
 */
var KeyValueDiffers = (function () {
    function KeyValueDiffers(factories) {
        this.factories = factories;
    }
    KeyValueDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new KeyValueDiffers(factories);
        }
        else {
            return new KeyValueDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
     * {@link KeyValueDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link KeyValueDiffer} available.
     *
     * # Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
     *   ]
     * })
     * ```
     */
    KeyValueDiffers.extend = function (factories) {
        return new di_1.Provider(KeyValueDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
                }
                return KeyValueDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    KeyValueDiffers.prototype.find = function (kv) {
        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(kv); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
        }
    };
    KeyValueDiffers = __decorate([
        di_1.Injectable(),
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], KeyValueDiffers);
    return KeyValueDiffers;
})();
exports.KeyValueDiffers = KeyValueDiffers;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var constants_1 = require('./constants');
var DirectiveIndex = (function () {
    function DirectiveIndex(elementIndex, directiveIndex) {
        this.elementIndex = elementIndex;
        this.directiveIndex = directiveIndex;
    }
    Object.defineProperty(DirectiveIndex.prototype, "name", {
        get: function () { return this.elementIndex + "_" + this.directiveIndex; },
        enumerable: true,
        configurable: true
    });
    return DirectiveIndex;
})();
exports.DirectiveIndex = DirectiveIndex;
var DirectiveRecord = (function () {
    function DirectiveRecord(_a) {
        var _b = _a === void 0 ? {} : _a, directiveIndex = _b.directiveIndex, callAfterContentInit = _b.callAfterContentInit, callAfterContentChecked = _b.callAfterContentChecked, callAfterViewInit = _b.callAfterViewInit, callAfterViewChecked = _b.callAfterViewChecked, callOnChanges = _b.callOnChanges, callDoCheck = _b.callDoCheck, callOnInit = _b.callOnInit, changeDetection = _b.changeDetection;
        this.directiveIndex = directiveIndex;
        this.callAfterContentInit = lang_1.normalizeBool(callAfterContentInit);
        this.callAfterContentChecked = lang_1.normalizeBool(callAfterContentChecked);
        this.callOnChanges = lang_1.normalizeBool(callOnChanges);
        this.callAfterViewInit = lang_1.normalizeBool(callAfterViewInit);
        this.callAfterViewChecked = lang_1.normalizeBool(callAfterViewChecked);
        this.callDoCheck = lang_1.normalizeBool(callDoCheck);
        this.callOnInit = lang_1.normalizeBool(callOnInit);
        this.changeDetection = changeDetection;
    }
    DirectiveRecord.prototype.isDefaultChangeDetection = function () {
        return constants_1.isDefaultChangeDetectionStrategy(this.changeDetection);
    };
    return DirectiveRecord;
})();
exports.DirectiveRecord = DirectiveRecord;

},{"./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var abstract_change_detector_1 = require('./abstract_change_detector');
var change_detection_util_1 = require('./change_detection_util');
var constants_1 = require('./constants');
var proto_record_1 = require('./proto_record');
var DynamicChangeDetector = (function (_super) {
    __extends(DynamicChangeDetector, _super);
    function DynamicChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy, _records, _eventBindings, _directiveRecords, _genConfig) {
        _super.call(this, id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);
        this._records = _records;
        this._eventBindings = _eventBindings;
        this._directiveRecords = _directiveRecords;
        this._genConfig = _genConfig;
        this.directives = null;
        var len = _records.length + 1;
        this.values = collection_1.ListWrapper.createFixedSize(len);
        this.localPipes = collection_1.ListWrapper.createFixedSize(len);
        this.prevContexts = collection_1.ListWrapper.createFixedSize(len);
        this.changes = collection_1.ListWrapper.createFixedSize(len);
        this.dehydrateDirectives(false);
    }
    DynamicChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) {
        var _this = this;
        var preventDefault = false;
        this._matchingEventBindings(eventName, elIndex)
            .forEach(function (rec) {
            var res = _this._processEventBinding(rec, locals);
            if (res === false) {
                preventDefault = true;
            }
        });
        return preventDefault;
    };
    /** @internal */
    DynamicChangeDetector.prototype._processEventBinding = function (eb, locals) {
        var values = collection_1.ListWrapper.createFixedSize(eb.records.length);
        values[0] = this.values[0];
        for (var i = 0; i < eb.records.length; ++i) {
            var proto = eb.records[i];
            var res = this._calculateCurrValue(proto, values, locals);
            if (proto.lastInBinding) {
                this._markPathAsCheckOnce(proto);
                return res;
            }
            else {
                this._writeSelf(proto, res, values);
            }
        }
        throw new exceptions_1.BaseException("Cannot be reached");
    };
    /** @internal */
    DynamicChangeDetector.prototype._markPathAsCheckOnce = function (proto) {
        if (!proto.bindingRecord.isDefaultChangeDetection()) {
            var dir = proto.bindingRecord.directiveRecord;
            this._getDetectorFor(dir.directiveIndex).markPathToRootAsCheckOnce();
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._matchingEventBindings = function (eventName, elIndex) {
        return collection_1.ListWrapper.filter(this._eventBindings, function (eb) { return eb.eventName == eventName && eb.elIndex === elIndex; });
    };
    DynamicChangeDetector.prototype.hydrateDirectives = function (directives) {
        this.values[0] = this.context;
        this.directives = directives;
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            for (var i = 0; i < this.directiveIndices.length; ++i) {
                var index = this.directiveIndices[i];
                _super.prototype.observeDirective.call(this, directives.getDirectiveFor(index), i);
            }
        }
    };
    DynamicChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) {
        if (destroyPipes) {
            this._destroyPipes();
        }
        this.values[0] = null;
        this.directives = null;
        collection_1.ListWrapper.fill(this.values, change_detection_util_1.ChangeDetectionUtil.uninitialized, 1);
        collection_1.ListWrapper.fill(this.changes, false);
        collection_1.ListWrapper.fill(this.localPipes, null);
        collection_1.ListWrapper.fill(this.prevContexts, change_detection_util_1.ChangeDetectionUtil.uninitialized);
    };
    /** @internal */
    DynamicChangeDetector.prototype._destroyPipes = function () {
        for (var i = 0; i < this.localPipes.length; ++i) {
            if (lang_1.isPresent(this.localPipes[i])) {
                change_detection_util_1.ChangeDetectionUtil.callPipeOnDestroy(this.localPipes[i]);
            }
        }
    };
    DynamicChangeDetector.prototype.checkNoChanges = function () { this.runDetectChanges(true); };
    DynamicChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) {
        var protos = this._records;
        var changes = null;
        var isChanged = false;
        for (var i = 0; i < protos.length; ++i) {
            var proto = protos[i];
            var bindingRecord = proto.bindingRecord;
            var directiveRecord = bindingRecord.directiveRecord;
            if (this._firstInBinding(proto)) {
                this.propertyBindingIndex = proto.propertyBindingIndex;
            }
            if (proto.isLifeCycleRecord()) {
                if (proto.name === "DoCheck" && !throwOnChange) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).doCheck();
                }
                else if (proto.name === "OnInit" && !throwOnChange && !this.alreadyChecked) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
                }
                else if (proto.name === "OnChanges" && lang_1.isPresent(changes) && !throwOnChange) {
                    this._getDirectiveFor(directiveRecord.directiveIndex).onChanges(changes);
                }
            }
            else {
                var change = this._check(proto, throwOnChange, this.values, this.locals);
                if (lang_1.isPresent(change)) {
                    this._updateDirectiveOrElement(change, bindingRecord);
                    isChanged = true;
                    changes = this._addChange(bindingRecord, change, changes);
                }
            }
            if (proto.lastInDirective) {
                changes = null;
                if (isChanged && !bindingRecord.isDefaultChangeDetection()) {
                    this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                }
                isChanged = false;
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._firstInBinding = function (r) {
        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this._records, r.selfIndex - 1);
        return lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
    };
    DynamicChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () {
        var dirs = this._directiveRecords;
        for (var i = dirs.length - 1; i >= 0; --i) {
            var dir = dirs[i];
            if (dir.callAfterContentInit && !this.alreadyChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterContentInit();
            }
            if (dir.callAfterContentChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterContentChecked();
            }
        }
    };
    DynamicChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () {
        var dirs = this._directiveRecords;
        for (var i = dirs.length - 1; i >= 0; --i) {
            var dir = dirs[i];
            if (dir.callAfterViewInit && !this.alreadyChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterViewInit();
            }
            if (dir.callAfterViewChecked) {
                this._getDirectiveFor(dir.directiveIndex).afterViewChecked();
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._updateDirectiveOrElement = function (change, bindingRecord) {
        if (lang_1.isBlank(bindingRecord.directiveRecord)) {
            _super.prototype.notifyDispatcher.call(this, change.currentValue);
        }
        else {
            var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
            bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
        }
        if (this._genConfig.logBindingUpdate) {
            _super.prototype.logBindingUpdate.call(this, change.currentValue);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._addChange = function (bindingRecord, change, changes) {
        if (bindingRecord.callOnChanges()) {
            return _super.prototype.addChange.call(this, changes, change.previousValue, change.currentValue);
        }
        else {
            return changes;
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._getDirectiveFor = function (directiveIndex) { return this.directives.getDirectiveFor(directiveIndex); };
    /** @internal */
    DynamicChangeDetector.prototype._getDetectorFor = function (directiveIndex) { return this.directives.getDetectorFor(directiveIndex); };
    /** @internal */
    DynamicChangeDetector.prototype._check = function (proto, throwOnChange, values, locals) {
        if (proto.isPipeRecord()) {
            return this._pipeCheck(proto, throwOnChange, values);
        }
        else {
            return this._referenceCheck(proto, throwOnChange, values, locals);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._referenceCheck = function (proto, throwOnChange, values, locals) {
        if (this._pureFuncAndArgsDidNotChange(proto)) {
            this._setChanged(proto, false);
            return null;
        }
        var currValue = this._calculateCurrValue(proto, values, locals);
        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
            _super.prototype.observeValue.call(this, currValue, proto.selfIndex);
        }
        if (proto.shouldBeChecked()) {
            var prevValue = this._readSelf(proto, values);
            if (!isSame(prevValue, currValue)) {
                if (proto.lastInBinding) {
                    var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
                    if (throwOnChange)
                        this.throwOnChangeError(prevValue, currValue);
                    this._writeSelf(proto, currValue, values);
                    this._setChanged(proto, true);
                    return change;
                }
                else {
                    this._writeSelf(proto, currValue, values);
                    this._setChanged(proto, true);
                    return null;
                }
            }
            else {
                this._setChanged(proto, false);
                return null;
            }
        }
        else {
            this._writeSelf(proto, currValue, values);
            this._setChanged(proto, true);
            return null;
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._calculateCurrValue = function (proto, values, locals) {
        switch (proto.mode) {
            case proto_record_1.RecordType.Self:
                return this._readContext(proto, values);
            case proto_record_1.RecordType.Const:
                return proto.funcOrValue;
            case proto_record_1.RecordType.PropertyRead:
                var context = this._readContext(proto, values);
                return proto.funcOrValue(context);
            case proto_record_1.RecordType.SafeProperty:
                var context = this._readContext(proto, values);
                return lang_1.isBlank(context) ? null : proto.funcOrValue(context);
            case proto_record_1.RecordType.PropertyWrite:
                var context = this._readContext(proto, values);
                var value = this._readArgs(proto, values)[0];
                proto.funcOrValue(context, value);
                return value;
            case proto_record_1.RecordType.KeyedWrite:
                var context = this._readContext(proto, values);
                var key = this._readArgs(proto, values)[0];
                var value = this._readArgs(proto, values)[1];
                context[key] = value;
                return value;
            case proto_record_1.RecordType.Local:
                return locals.get(proto.name);
            case proto_record_1.RecordType.InvokeMethod:
                var context = this._readContext(proto, values);
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
            case proto_record_1.RecordType.SafeMethodInvoke:
                var context = this._readContext(proto, values);
                if (lang_1.isBlank(context)) {
                    return null;
                }
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
            case proto_record_1.RecordType.KeyedRead:
                var arg = this._readArgs(proto, values)[0];
                return this._readContext(proto, values)[arg];
            case proto_record_1.RecordType.Chain:
                var args = this._readArgs(proto, values);
                return args[args.length - 1];
            case proto_record_1.RecordType.InvokeClosure:
                return lang_1.FunctionWrapper.apply(this._readContext(proto, values), this._readArgs(proto, values));
            case proto_record_1.RecordType.Interpolate:
            case proto_record_1.RecordType.PrimitiveOp:
            case proto_record_1.RecordType.CollectionLiteral:
                return lang_1.FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto, values));
            default:
                throw new exceptions_1.BaseException("Unknown operation " + proto.mode);
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._pipeCheck = function (proto, throwOnChange, values) {
        var context = this._readContext(proto, values);
        var selectedPipe = this._pipeFor(proto, context);
        if (!selectedPipe.pure || this._argsOrContextChanged(proto)) {
            var args = this._readArgs(proto, values);
            var currValue = selectedPipe.pipe.transform(context, args);
            if (proto.shouldBeChecked()) {
                var prevValue = this._readSelf(proto, values);
                if (!isSame(prevValue, currValue)) {
                    currValue = change_detection_util_1.ChangeDetectionUtil.unwrapValue(currValue);
                    if (proto.lastInBinding) {
                        var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
                        if (throwOnChange)
                            this.throwOnChangeError(prevValue, currValue);
                        this._writeSelf(proto, currValue, values);
                        this._setChanged(proto, true);
                        return change;
                    }
                    else {
                        this._writeSelf(proto, currValue, values);
                        this._setChanged(proto, true);
                        return null;
                    }
                }
                else {
                    this._setChanged(proto, false);
                    return null;
                }
            }
            else {
                this._writeSelf(proto, currValue, values);
                this._setChanged(proto, true);
                return null;
            }
        }
    };
    /** @internal */
    DynamicChangeDetector.prototype._pipeFor = function (proto, context) {
        var storedPipe = this._readPipe(proto);
        if (lang_1.isPresent(storedPipe))
            return storedPipe;
        var pipe = this.pipes.get(proto.name);
        this._writePipe(proto, pipe);
        return pipe;
    };
    /** @internal */
    DynamicChangeDetector.prototype._readContext = function (proto, values) {
        if (proto.contextIndex == -1) {
            return this._getDirectiveFor(proto.directiveIndex);
        }
        else {
            return values[proto.contextIndex];
        }
        return values[proto.contextIndex];
    };
    /** @internal */
    DynamicChangeDetector.prototype._readSelf = function (proto, values) { return values[proto.selfIndex]; };
    /** @internal */
    DynamicChangeDetector.prototype._writeSelf = function (proto, value, values) { values[proto.selfIndex] = value; };
    /** @internal */
    DynamicChangeDetector.prototype._readPipe = function (proto) { return this.localPipes[proto.selfIndex]; };
    /** @internal */
    DynamicChangeDetector.prototype._writePipe = function (proto, value) { this.localPipes[proto.selfIndex] = value; };
    /** @internal */
    DynamicChangeDetector.prototype._setChanged = function (proto, value) {
        if (proto.argumentToPureFunction)
            this.changes[proto.selfIndex] = value;
    };
    /** @internal */
    DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange = function (proto) {
        return proto.isPureFunction() && !this._argsChanged(proto);
    };
    /** @internal */
    DynamicChangeDetector.prototype._argsChanged = function (proto) {
        var args = proto.args;
        for (var i = 0; i < args.length; ++i) {
            if (this.changes[args[i]]) {
                return true;
            }
        }
        return false;
    };
    /** @internal */
    DynamicChangeDetector.prototype._argsOrContextChanged = function (proto) {
        return this._argsChanged(proto) || this.changes[proto.contextIndex];
    };
    /** @internal */
    DynamicChangeDetector.prototype._readArgs = function (proto, values) {
        var res = collection_1.ListWrapper.createFixedSize(proto.args.length);
        var args = proto.args;
        for (var i = 0; i < args.length; ++i) {
            res[i] = values[args[i]];
        }
        return res;
    };
    return DynamicChangeDetector;
})(abstract_change_detector_1.AbstractChangeDetector);
exports.DynamicChangeDetector = DynamicChangeDetector;
function isSame(a, b) {
    if (a === b)
        return true;
    if (a instanceof String && b instanceof String && a == b)
        return true;
    if ((a !== a) && (b !== b))
        return true;
    return false;
}

},{"./abstract_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/abstract_change_detector.js","./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./constants":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/constants.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/event_binding.js":[function(require,module,exports){
'use strict';var EventBinding = (function () {
    function EventBinding(eventName, elIndex, dirIndex, records) {
        this.eventName = eventName;
        this.elIndex = elIndex;
        this.dirIndex = dirIndex;
        this.records = records;
    }
    return EventBinding;
})();
exports.EventBinding = EventBinding;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require("angular2/src/core/facade/exceptions");
/**
 * An error thrown if application changes model breaking the top-down data flow.
 *
 * This exception is only thrown in dev mode.
 *
 * <!-- TODO: Add a link once the dev mode option is configurable -->
 *
 * ### Example
 *
 * ```typescript
 * @Component({
 *   selector: 'parent',
 *   template: `
 *     <child [prop]="parentProp"></child>
 *   `,
 *   directives: [forwardRef(() => Child)]
 * })
 * class Parent {
 *   parentProp = "init";
 * }
 *
 * @Directive({selector: 'child', inputs: ['prop']})
 * class Child {
 *   constructor(public parent: Parent) {}
 *
 *   set prop(v) {
 *     // this updates the parent property, which is disallowed during change detection
 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
 *     this.parent.parentProp = "updated";
 *   }
 * }
 * ```
 */
var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
    function ExpressionChangedAfterItHasBeenCheckedException(exp, oldValue, currValue, context) {
        _super.call(this, ("Expression '" + exp + "' has changed after it was checked. ") +
            ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
    }
    return ExpressionChangedAfterItHasBeenCheckedException;
})(exceptions_1.BaseException);
exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
/**
 * Thrown when an expression evaluation raises an exception.
 *
 * This error wraps the original exception to attach additional contextual information that can
 * be useful for debugging.
 *
 * ### Example ([live demo](http://plnkr.co/edit/2Kywoz?p=preview))
 *
 * ```typescript
 * @Directive({selector: 'child', inputs: ['prop']})
 * class Child {
 *   prop;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <child [prop]="field.first"></child>
 *   `,
 *   directives: [Child]
 * })
 * class App {
 *   field = null;
 * }
 *
 * bootstrap(App);
 * ```
 *
 * You can access the original exception and stack through the `originalException` and
 * `originalStack` properties.
 */
var ChangeDetectionError = (function (_super) {
    __extends(ChangeDetectionError, _super);
    function ChangeDetectionError(exp, originalException, originalStack, context) {
        _super.call(this, originalException + " in [" + exp + "]", originalException, originalStack, context);
        this.location = exp;
    }
    return ChangeDetectionError;
})(exceptions_1.WrappedException);
exports.ChangeDetectionError = ChangeDetectionError;
/**
 * Thrown when change detector executes on dehydrated view.
 *
 * This error indicates a bug in the framework.
 *
 * This is an internal Angular error.
 */
var DehydratedException = (function (_super) {
    __extends(DehydratedException, _super);
    function DehydratedException() {
        _super.call(this, 'Attempt to detect changes on a dehydrated detector.');
    }
    return DehydratedException;
})(exceptions_1.BaseException);
exports.DehydratedException = DehydratedException;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js":[function(require,module,exports){
'use strict';var DebugContext = (function () {
    function DebugContext(element, componentElement, directive, context, locals, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.directive = directive;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
    }
    return DebugContext;
})();
exports.DebugContext = DebugContext;
var ChangeDetectorGenConfig = (function () {
    function ChangeDetectorGenConfig(genCheckNoChanges, genDebugInfo, logBindingUpdate, useJit) {
        this.genCheckNoChanges = genCheckNoChanges;
        this.genDebugInfo = genDebugInfo;
        this.logBindingUpdate = logBindingUpdate;
        this.useJit = useJit;
    }
    return ChangeDetectorGenConfig;
})();
exports.ChangeDetectorGenConfig = ChangeDetectorGenConfig;
var ChangeDetectorDefinition = (function () {
    function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, eventRecords, directiveRecords, genConfig) {
        this.id = id;
        this.strategy = strategy;
        this.variableNames = variableNames;
        this.bindingRecords = bindingRecords;
        this.eventRecords = eventRecords;
        this.directiveRecords = directiveRecords;
        this.genConfig = genConfig;
    }
    return ChangeDetectorDefinition;
})();
exports.ChangeDetectorDefinition = ChangeDetectorDefinition;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/jit_proto_change_detector.js":[function(require,module,exports){
'use strict';var change_detection_jit_generator_1 = require('./change_detection_jit_generator');
var JitProtoChangeDetector = (function () {
    function JitProtoChangeDetector(definition) {
        this.definition = definition;
        this._factory = this._createFactory(definition);
    }
    JitProtoChangeDetector.isSupported = function () { return true; };
    JitProtoChangeDetector.prototype.instantiate = function (dispatcher) { return this._factory(dispatcher); };
    /** @internal */
    JitProtoChangeDetector.prototype._createFactory = function (definition) {
        return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, 'util', 'AbstractChangeDetector').generate();
    };
    return JitProtoChangeDetector;
})();
exports.JitProtoChangeDetector = JitProtoChangeDetector;

},{"./change_detection_jit_generator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/observable_facade.js":[function(require,module,exports){
'use strict';function isObservable(value) {
    return false;
}
exports.isObservable = isObservable;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require("angular2/src/core/facade/lang");
var collection_1 = require("angular2/src/core/facade/collection");
var AST = (function () {
    function AST() {
    }
    AST.prototype.visit = function (visitor) { return null; };
    AST.prototype.toString = function () { return "AST"; };
    return AST;
})();
exports.AST = AST;
var EmptyExpr = (function (_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
        _super.apply(this, arguments);
    }
    EmptyExpr.prototype.visit = function (visitor) {
        // do nothing
    };
    return EmptyExpr;
})(AST);
exports.EmptyExpr = EmptyExpr;
var ImplicitReceiver = (function (_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
        _super.apply(this, arguments);
    }
    ImplicitReceiver.prototype.visit = function (visitor) { return visitor.visitImplicitReceiver(this); };
    return ImplicitReceiver;
})(AST);
exports.ImplicitReceiver = ImplicitReceiver;
/**
 * Multiple expressions separated by a semicolon.
 */
var Chain = (function (_super) {
    __extends(Chain, _super);
    function Chain(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    Chain.prototype.visit = function (visitor) { return visitor.visitChain(this); };
    return Chain;
})(AST);
exports.Chain = Chain;
var Conditional = (function (_super) {
    __extends(Conditional, _super);
    function Conditional(condition, trueExp, falseExp) {
        _super.call(this);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
    }
    Conditional.prototype.visit = function (visitor) { return visitor.visitConditional(this); };
    return Conditional;
})(AST);
exports.Conditional = Conditional;
var If = (function (_super) {
    __extends(If, _super);
    function If(condition, trueExp, falseExp) {
        _super.call(this);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
    }
    If.prototype.visit = function (visitor) { return visitor.visitIf(this); };
    return If;
})(AST);
exports.If = If;
var PropertyRead = (function (_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(receiver, name, getter) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.getter = getter;
    }
    PropertyRead.prototype.visit = function (visitor) { return visitor.visitPropertyRead(this); };
    return PropertyRead;
})(AST);
exports.PropertyRead = PropertyRead;
var PropertyWrite = (function (_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(receiver, name, setter, value) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.setter = setter;
        this.value = value;
    }
    PropertyWrite.prototype.visit = function (visitor) { return visitor.visitPropertyWrite(this); };
    return PropertyWrite;
})(AST);
exports.PropertyWrite = PropertyWrite;
var SafePropertyRead = (function (_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(receiver, name, getter) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.getter = getter;
    }
    SafePropertyRead.prototype.visit = function (visitor) { return visitor.visitSafePropertyRead(this); };
    return SafePropertyRead;
})(AST);
exports.SafePropertyRead = SafePropertyRead;
var KeyedRead = (function (_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(obj, key) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
    }
    KeyedRead.prototype.visit = function (visitor) { return visitor.visitKeyedRead(this); };
    return KeyedRead;
})(AST);
exports.KeyedRead = KeyedRead;
var KeyedWrite = (function (_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(obj, key, value) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
        this.value = value;
    }
    KeyedWrite.prototype.visit = function (visitor) { return visitor.visitKeyedWrite(this); };
    return KeyedWrite;
})(AST);
exports.KeyedWrite = KeyedWrite;
var BindingPipe = (function (_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(exp, name, args) {
        _super.call(this);
        this.exp = exp;
        this.name = name;
        this.args = args;
    }
    BindingPipe.prototype.visit = function (visitor) { return visitor.visitPipe(this); };
    return BindingPipe;
})(AST);
exports.BindingPipe = BindingPipe;
var LiteralPrimitive = (function (_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(value) {
        _super.call(this);
        this.value = value;
    }
    LiteralPrimitive.prototype.visit = function (visitor) { return visitor.visitLiteralPrimitive(this); };
    return LiteralPrimitive;
})(AST);
exports.LiteralPrimitive = LiteralPrimitive;
var LiteralArray = (function (_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    LiteralArray.prototype.visit = function (visitor) { return visitor.visitLiteralArray(this); };
    return LiteralArray;
})(AST);
exports.LiteralArray = LiteralArray;
var LiteralMap = (function (_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(keys, values) {
        _super.call(this);
        this.keys = keys;
        this.values = values;
    }
    LiteralMap.prototype.visit = function (visitor) { return visitor.visitLiteralMap(this); };
    return LiteralMap;
})(AST);
exports.LiteralMap = LiteralMap;
var Interpolation = (function (_super) {
    __extends(Interpolation, _super);
    function Interpolation(strings, expressions) {
        _super.call(this);
        this.strings = strings;
        this.expressions = expressions;
    }
    Interpolation.prototype.visit = function (visitor) { visitor.visitInterpolation(this); };
    return Interpolation;
})(AST);
exports.Interpolation = Interpolation;
var Binary = (function (_super) {
    __extends(Binary, _super);
    function Binary(operation, left, right) {
        _super.call(this);
        this.operation = operation;
        this.left = left;
        this.right = right;
    }
    Binary.prototype.visit = function (visitor) { return visitor.visitBinary(this); };
    return Binary;
})(AST);
exports.Binary = Binary;
var PrefixNot = (function (_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(expression) {
        _super.call(this);
        this.expression = expression;
    }
    PrefixNot.prototype.visit = function (visitor) { return visitor.visitPrefixNot(this); };
    return PrefixNot;
})(AST);
exports.PrefixNot = PrefixNot;
var MethodCall = (function (_super) {
    __extends(MethodCall, _super);
    function MethodCall(receiver, name, fn, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.fn = fn;
        this.args = args;
    }
    MethodCall.prototype.visit = function (visitor) { return visitor.visitMethodCall(this); };
    return MethodCall;
})(AST);
exports.MethodCall = MethodCall;
var SafeMethodCall = (function (_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(receiver, name, fn, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.fn = fn;
        this.args = args;
    }
    SafeMethodCall.prototype.visit = function (visitor) { return visitor.visitSafeMethodCall(this); };
    return SafeMethodCall;
})(AST);
exports.SafeMethodCall = SafeMethodCall;
var FunctionCall = (function (_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(target, args) {
        _super.call(this);
        this.target = target;
        this.args = args;
    }
    FunctionCall.prototype.visit = function (visitor) { return visitor.visitFunctionCall(this); };
    return FunctionCall;
})(AST);
exports.FunctionCall = FunctionCall;
var ASTWithSource = (function (_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location) {
        _super.call(this);
        this.ast = ast;
        this.source = source;
        this.location = location;
    }
    ASTWithSource.prototype.visit = function (visitor) { return this.ast.visit(visitor); };
    ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
    return ASTWithSource;
})(AST);
exports.ASTWithSource = ASTWithSource;
var TemplateBinding = (function () {
    function TemplateBinding(key, keyIsVar, name, expression) {
        this.key = key;
        this.keyIsVar = keyIsVar;
        this.name = name;
        this.expression = expression;
    }
    return TemplateBinding;
})();
exports.TemplateBinding = TemplateBinding;
var RecursiveAstVisitor = (function () {
    function RecursiveAstVisitor() {
    }
    RecursiveAstVisitor.prototype.visitBinary = function (ast) {
        ast.left.visit(this);
        ast.right.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitConditional = function (ast) {
        ast.condition.visit(this);
        ast.trueExp.visit(this);
        ast.falseExp.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitIf = function (ast) {
        ast.condition.visit(this);
        ast.trueExp.visit(this);
        ast.falseExp.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function (ast) {
        ast.exp.visit(this);
        this.visitAll(ast.args);
        return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast) {
        ast.target.visit(this);
        this.visitAll(ast.args);
        return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast) { return null; };
    RecursiveAstVisitor.prototype.visitInterpolation = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast) {
        ast.obj.visit(this);
        ast.key.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast) {
        ast.obj.visit(this);
        ast.key.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast) { return this.visitAll(ast.expressions); };
    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast) { return this.visitAll(ast.values); };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast) { return null; };
    RecursiveAstVisitor.prototype.visitMethodCall = function (ast) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast) {
        ast.expression.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast) {
        ast.receiver.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args);
    };
    RecursiveAstVisitor.prototype.visitAll = function (asts) {
        var _this = this;
        asts.forEach(function (ast) { return ast.visit(_this); });
        return null;
    };
    return RecursiveAstVisitor;
})();
exports.RecursiveAstVisitor = RecursiveAstVisitor;
var AstTransformer = (function () {
    function AstTransformer() {
    }
    AstTransformer.prototype.visitImplicitReceiver = function (ast) { return ast; };
    AstTransformer.prototype.visitInterpolation = function (ast) {
        return new Interpolation(ast.strings, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralPrimitive = function (ast) {
        return new LiteralPrimitive(ast.value);
    };
    AstTransformer.prototype.visitPropertyRead = function (ast) {
        return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
    };
    AstTransformer.prototype.visitPropertyWrite = function (ast) {
        return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);
    };
    AstTransformer.prototype.visitSafePropertyRead = function (ast) {
        return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
    };
    AstTransformer.prototype.visitMethodCall = function (ast) {
        return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitSafeMethodCall = function (ast) {
        return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitFunctionCall = function (ast) {
        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitLiteralArray = function (ast) {
        return new LiteralArray(this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralMap = function (ast) {
        return new LiteralMap(ast.keys, this.visitAll(ast.values));
    };
    AstTransformer.prototype.visitBinary = function (ast) {
        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
    };
    AstTransformer.prototype.visitPrefixNot = function (ast) { return new PrefixNot(ast.expression.visit(this)); };
    AstTransformer.prototype.visitConditional = function (ast) {
        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    };
    AstTransformer.prototype.visitPipe = function (ast) {
        return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitKeyedRead = function (ast) {
        return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
    };
    AstTransformer.prototype.visitKeyedWrite = function (ast) {
        return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
    };
    AstTransformer.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    AstTransformer.prototype.visitChain = function (ast) { return new Chain(this.visitAll(ast.expressions)); };
    AstTransformer.prototype.visitIf = function (ast) {
        var falseExp = lang_1.isPresent(ast.falseExp) ? ast.falseExp.visit(this) : null;
        return new If(ast.condition.visit(this), ast.trueExp.visit(this), falseExp);
    };
    return AstTransformer;
})();
exports.AstTransformer = AstTransformer;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var decorators_1 = require('angular2/src/core/di/decorators');
var collection_1 = require("angular2/src/core/facade/collection");
var lang_1 = require("angular2/src/core/facade/lang");
var exceptions_1 = require('angular2/src/core/facade/exceptions');
(function (TokenType) {
    TokenType[TokenType["Character"] = 0] = "Character";
    TokenType[TokenType["Identifier"] = 1] = "Identifier";
    TokenType[TokenType["Keyword"] = 2] = "Keyword";
    TokenType[TokenType["String"] = 3] = "String";
    TokenType[TokenType["Operator"] = 4] = "Operator";
    TokenType[TokenType["Number"] = 5] = "Number";
})(exports.TokenType || (exports.TokenType = {}));
var TokenType = exports.TokenType;
var Lexer = (function () {
    function Lexer() {
    }
    Lexer.prototype.tokenize = function (text) {
        var scanner = new _Scanner(text);
        var tokens = [];
        var token = scanner.scanToken();
        while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
        }
        return tokens;
    };
    Lexer = __decorate([
        decorators_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], Lexer);
    return Lexer;
})();
exports.Lexer = Lexer;
var Token = (function () {
    function Token(index, type, numValue, strValue) {
        this.index = index;
        this.type = type;
        this.numValue = numValue;
        this.strValue = strValue;
    }
    Token.prototype.isCharacter = function (code) {
        return (this.type == TokenType.Character && this.numValue == code);
    };
    Token.prototype.isNumber = function () { return (this.type == TokenType.Number); };
    Token.prototype.isString = function () { return (this.type == TokenType.String); };
    Token.prototype.isOperator = function (operater) {
        return (this.type == TokenType.Operator && this.strValue == operater);
    };
    Token.prototype.isIdentifier = function () { return (this.type == TokenType.Identifier); };
    Token.prototype.isKeyword = function () { return (this.type == TokenType.Keyword); };
    Token.prototype.isKeywordVar = function () { return (this.type == TokenType.Keyword && this.strValue == "var"); };
    Token.prototype.isKeywordNull = function () { return (this.type == TokenType.Keyword && this.strValue == "null"); };
    Token.prototype.isKeywordUndefined = function () {
        return (this.type == TokenType.Keyword && this.strValue == "undefined");
    };
    Token.prototype.isKeywordTrue = function () { return (this.type == TokenType.Keyword && this.strValue == "true"); };
    Token.prototype.isKeywordIf = function () { return (this.type == TokenType.Keyword && this.strValue == "if"); };
    Token.prototype.isKeywordElse = function () { return (this.type == TokenType.Keyword && this.strValue == "else"); };
    Token.prototype.isKeywordFalse = function () { return (this.type == TokenType.Keyword && this.strValue == "false"); };
    Token.prototype.toNumber = function () {
        // -1 instead of NULL ok?
        return (this.type == TokenType.Number) ? this.numValue : -1;
    };
    Token.prototype.toString = function () {
        switch (this.type) {
            case TokenType.Character:
            case TokenType.Identifier:
            case TokenType.Keyword:
            case TokenType.Operator:
            case TokenType.String:
                return this.strValue;
            case TokenType.Number:
                return this.numValue.toString();
            default:
                return null;
        }
    };
    return Token;
})();
exports.Token = Token;
function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));
}
function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
}
function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
}
function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
}
function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
}
function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, "");
}
exports.EOF = new Token(-1, TokenType.Character, 0, "");
exports.$EOF = 0;
exports.$TAB = 9;
exports.$LF = 10;
exports.$VTAB = 11;
exports.$FF = 12;
exports.$CR = 13;
exports.$SPACE = 32;
exports.$BANG = 33;
exports.$DQ = 34;
exports.$HASH = 35;
exports.$$ = 36;
exports.$PERCENT = 37;
exports.$AMPERSAND = 38;
exports.$SQ = 39;
exports.$LPAREN = 40;
exports.$RPAREN = 41;
exports.$STAR = 42;
exports.$PLUS = 43;
exports.$COMMA = 44;
exports.$MINUS = 45;
exports.$PERIOD = 46;
exports.$SLASH = 47;
exports.$COLON = 58;
exports.$SEMICOLON = 59;
exports.$LT = 60;
exports.$EQ = 61;
exports.$GT = 62;
exports.$QUESTION = 63;
var $0 = 48;
var $9 = 57;
var $A = 65, $E = 69, $Z = 90;
exports.$LBRACKET = 91;
exports.$BACKSLASH = 92;
exports.$RBRACKET = 93;
var $CARET = 94;
var $_ = 95;
var $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
exports.$LBRACE = 123;
exports.$BAR = 124;
exports.$RBRACE = 125;
var $NBSP = 160;
var ScannerError = (function (_super) {
    __extends(ScannerError, _super);
    function ScannerError(message) {
        _super.call(this);
        this.message = message;
    }
    ScannerError.prototype.toString = function () { return this.message; };
    return ScannerError;
})(exceptions_1.BaseException);
exports.ScannerError = ScannerError;
var _Scanner = (function () {
    function _Scanner(input) {
        this.input = input;
        this.peek = 0;
        this.index = -1;
        this.length = input.length;
        this.advance();
    }
    _Scanner.prototype.advance = function () {
        this.peek =
            ++this.index >= this.length ? exports.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
    };
    _Scanner.prototype.scanToken = function () {
        var input = this.input, length = this.length, peek = this.peek, index = this.index;
        // Skip whitespace.
        while (peek <= exports.$SPACE) {
            if (++index >= length) {
                peek = exports.$EOF;
                break;
            }
            else {
                peek = lang_1.StringWrapper.charCodeAt(input, index);
            }
        }
        this.peek = peek;
        this.index = index;
        if (index >= length) {
            return null;
        }
        // Handle identifiers and numbers.
        if (isIdentifierStart(peek))
            return this.scanIdentifier();
        if (isDigit(peek))
            return this.scanNumber(index);
        var start = index;
        switch (peek) {
            case exports.$PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, exports.$PERIOD);
            case exports.$LPAREN:
            case exports.$RPAREN:
            case exports.$LBRACE:
            case exports.$RBRACE:
            case exports.$LBRACKET:
            case exports.$RBRACKET:
            case exports.$COMMA:
            case exports.$COLON:
            case exports.$SEMICOLON:
                return this.scanCharacter(start, peek);
            case exports.$SQ:
            case exports.$DQ:
                return this.scanString();
            case exports.$HASH:
            case exports.$PLUS:
            case exports.$MINUS:
            case exports.$STAR:
            case exports.$SLASH:
            case exports.$PERCENT:
            case $CARET:
                return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));
            case exports.$QUESTION:
                return this.scanComplexOperator(start, '?', exports.$PERIOD, '.');
            case exports.$LT:
            case exports.$GT:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=');
            case exports.$BANG:
            case exports.$EQ:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=', exports.$EQ, '=');
            case exports.$AMPERSAND:
                return this.scanComplexOperator(start, '&', exports.$AMPERSAND, '&');
            case exports.$BAR:
                return this.scanComplexOperator(start, '|', exports.$BAR, '|');
            case $NBSP:
                while (isWhitespace(this.peek))
                    this.advance();
                return this.scanToken();
        }
        this.error("Unexpected character [" + lang_1.StringWrapper.fromCharCode(peek) + "]", 0);
        return null;
    };
    _Scanner.prototype.scanCharacter = function (start, code) {
        assert(this.peek == code);
        this.advance();
        return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function (start, str) {
        assert(this.peek == lang_1.StringWrapper.charCodeAt(str, 0));
        assert(collection_1.SetWrapper.has(OPERATORS, str));
        this.advance();
        return newOperatorToken(start, str);
    };
    /**
     * Tokenize a 2/3 char long operator
     *
     * @param start start index in the expression
     * @param one first symbol (always part of the operator)
     * @param twoCode code point for the second symbol
     * @param two second symbol (part of the operator when the second code point matches)
     * @param threeCode code point for the third symbol
     * @param three third symbol (part of the operator when provided and matches source expression)
     * @returns {Token}
     */
    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
        assert(this.peek == lang_1.StringWrapper.charCodeAt(one, 0));
        this.advance();
        var str = one;
        if (this.peek == twoCode) {
            this.advance();
            str += two;
        }
        if (lang_1.isPresent(threeCode) && this.peek == threeCode) {
            this.advance();
            str += three;
        }
        assert(collection_1.SetWrapper.has(OPERATORS, str));
        return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function () {
        assert(isIdentifierStart(this.peek));
        var start = this.index;
        this.advance();
        while (isIdentifierPart(this.peek))
            this.advance();
        var str = this.input.substring(start, this.index);
        if (collection_1.SetWrapper.has(KEYWORDS, str)) {
            return newKeywordToken(start, str);
        }
        else {
            return newIdentifierToken(start, str);
        }
    };
    _Scanner.prototype.scanNumber = function (start) {
        assert(isDigit(this.peek));
        var simple = (this.index === start);
        this.advance(); // Skip initial digit.
        while (true) {
            if (isDigit(this.peek)) {
            }
            else if (this.peek == exports.$PERIOD) {
                simple = false;
            }
            else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                    this.advance();
                if (!isDigit(this.peek))
                    this.error('Invalid exponent', -1);
                simple = false;
            }
            else {
                break;
            }
            this.advance();
        }
        var str = this.input.substring(start, this.index);
        // TODO
        var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);
        return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function () {
        assert(this.peek == exports.$SQ || this.peek == exports.$DQ);
        var start = this.index;
        var quote = this.peek;
        this.advance(); // Skip initial quote.
        var buffer;
        var marker = this.index;
        var input = this.input;
        while (this.peek != quote) {
            if (this.peek == exports.$BACKSLASH) {
                if (buffer == null)
                    buffer = new lang_1.StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode;
                if (this.peek == $u) {
                    // 4 character hex code for unicode character.
                    var hex = input.substring(this.index + 1, this.index + 5);
                    try {
                        unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);
                    }
                    catch (e) {
                        this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                    }
                    for (var i = 0; i < 5; i++) {
                        this.advance();
                    }
                }
                else {
                    unescapedCode = unescape(this.peek);
                    this.advance();
                }
                buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
            }
            else if (this.peek == exports.$EOF) {
                this.error('Unterminated quote', 0);
            }
            else {
                this.advance();
            }
        }
        var last = input.substring(marker, this.index);
        this.advance(); // Skip terminating quote.
        // Compute the unescaped string value.
        var unescaped = last;
        if (buffer != null) {
            buffer.add(last);
            unescaped = buffer.toString();
        }
        return newStringToken(start, unescaped);
    };
    _Scanner.prototype.error = function (message, offset) {
        var position = this.index + offset;
        throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
})();
function isWhitespace(code) {
    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == $NBSP);
}
function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == exports.$$);
}
function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) ||
        (code == $_) || (code == exports.$$);
}
function isDigit(code) {
    return $0 <= code && code <= $9;
}
function isExponentStart(code) {
    return code == $e || code == $E;
}
function isExponentSign(code) {
    return code == exports.$MINUS || code == exports.$PLUS;
}
function unescape(code) {
    switch (code) {
        case $n:
            return exports.$LF;
        case $f:
            return exports.$FF;
        case $r:
            return exports.$CR;
        case $t:
            return exports.$TAB;
        case $v:
            return exports.$VTAB;
        default:
            return code;
    }
}
var OPERATORS = collection_1.SetWrapper.createFromList([
    '+',
    '-',
    '*',
    '/',
    '%',
    '^',
    '=',
    '==',
    '!=',
    '===',
    '!==',
    '<',
    '>',
    '<=',
    '>=',
    '&&',
    '||',
    '&',
    '|',
    '!',
    '?',
    '#',
    '?.'
]);
var KEYWORDS = collection_1.SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);

},{"angular2/src/core/di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/locals.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var Locals = (function () {
    function Locals(parent, current) {
        this.parent = parent;
        this.current = current;
    }
    Locals.prototype.contains = function (name) {
        if (this.current.has(name)) {
            return true;
        }
        if (lang_1.isPresent(this.parent)) {
            return this.parent.contains(name);
        }
        return false;
    };
    Locals.prototype.get = function (name) {
        if (this.current.has(name)) {
            return this.current.get(name);
        }
        if (lang_1.isPresent(this.parent)) {
            return this.parent.get(name);
        }
        throw new exceptions_1.BaseException("Cannot find '" + name + "'");
    };
    Locals.prototype.set = function (name, value) {
        // TODO(rado): consider removing this check if we can guarantee this is not
        // exposed to the public API.
        // TODO: vsavkin maybe it should check only the local map
        if (this.current.has(name)) {
            this.current.set(name, value);
        }
        else {
            throw new exceptions_1.BaseException("Setting of new keys post-construction is not supported. Key: " + name + ".");
        }
    };
    Locals.prototype.clearValues = function () { collection_1.MapWrapper.clearValues(this.current); };
    return Locals;
})();
exports.Locals = Locals;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/parser.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var decorators_1 = require('angular2/src/core/di/decorators');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lexer_1 = require('./lexer');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var ast_1 = require('./ast');
var _implicitReceiver = new ast_1.ImplicitReceiver();
// TODO(tbosch): Cannot make this const/final right now because of the transpiler...
var INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
var ParseException = (function (_super) {
    __extends(ParseException, _super);
    function ParseException(message, input, errLocation, ctxLocation) {
        _super.call(this, "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation);
    }
    return ParseException;
})(exceptions_1.BaseException);
var Parser = (function () {
    function Parser(/** @internal */ _lexer, providedReflector) {
        if (providedReflector === void 0) { providedReflector = null; }
        this._lexer = _lexer;
        this._reflector = lang_1.isPresent(providedReflector) ? providedReflector : reflection_1.reflector;
    }
    Parser.prototype.parseAction = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseBinding = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseSimpleBinding = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(input);
        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseTemplateBindings = function (input, location) {
        var tokens = this._lexer.tokenize(input);
        return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length <= 1) {
            return null;
        }
        var strings = [];
        var expressions = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i % 2 === 0) {
                // fixed string
                strings.push(part);
            }
            else if (part.trim().length > 0) {
                var tokens = this._lexer.tokenize(part);
                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                expressions.push(ast);
            }
            else {
                throw new ParseException('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i) + " in", location);
            }
        }
        return new ast_1.ASTWithSource(new ast_1.Interpolation(strings, expressions), input, location);
    };
    Parser.prototype.wrapLiteralPrimitive = function (input, location) {
        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);
    };
    Parser.prototype._checkNoInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length > 1) {
            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, "at column " + this._findInterpolationErrorColumn(parts, 1) + " in", location);
        }
    };
    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx) {
        var errLocation = '';
        for (var j = 0; j < partInErrIdx; j++) {
            errLocation += j % 2 === 0 ? parts[j] : "{{" + parts[j] + "}}";
        }
        return errLocation.length;
    };
    Parser = __decorate([
        decorators_1.Injectable(), 
        __metadata('design:paramtypes', [lexer_1.Lexer, reflection_1.Reflector])
    ], Parser);
    return Parser;
})();
exports.Parser = Parser;
var _ParseAST = (function () {
    function _ParseAST(input, location, tokens, reflector, parseAction) {
        this.input = input;
        this.location = location;
        this.tokens = tokens;
        this.reflector = reflector;
        this.parseAction = parseAction;
        this.index = 0;
    }
    _ParseAST.prototype.peek = function (offset) {
        var i = this.index + offset;
        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
        get: function () { return this.peek(0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
        get: function () {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
        },
        enumerable: true,
        configurable: true
    });
    _ParseAST.prototype.advance = function () { this.index++; };
    _ParseAST.prototype.optionalCharacter = function (code) {
        if (this.next.isCharacter(code)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.optionalKeywordVar = function () {
        if (this.peekKeywordVar()) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.peekKeywordVar = function () { return this.next.isKeywordVar() || this.next.isOperator('#'); };
    _ParseAST.prototype.expectCharacter = function (code) {
        if (this.optionalCharacter(code))
            return;
        this.error("Missing expected " + lang_1.StringWrapper.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function (op) {
        if (this.next.isOperator(op)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.expectOperator = function (operator) {
        if (this.optionalOperator(operator))
            return;
        this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword()) {
            this.error("Unexpected token " + n + ", expected identifier or keyword");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
            this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.parseChain = function () {
        var exprs = [];
        while (this.index < this.tokens.length) {
            var expr = this.parsePipe();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                if (!this.parseAction) {
                    this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
            else if (this.index < this.tokens.length) {
                this.error("Unexpected token '" + this.next + "'");
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    _ParseAST.prototype.parseSimpleBinding = function () {
        var ast = this.parseChain();
        if (!SimpleExpressionChecker.check(ast)) {
            this.error("Simple binding expression can only contain field access and constants'");
        }
        return ast;
    };
    _ParseAST.prototype.parsePipe = function () {
        var result = this.parseExpression();
        if (this.optionalOperator("|")) {
            if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
            }
            do {
                var name = this.expectIdentifierOrKeyword();
                var args = [];
                while (this.optionalCharacter(lexer_1.$COLON)) {
                    args.push(this.parsePipe());
                }
                result = new ast_1.BindingPipe(result, name, args);
            } while (this.optionalOperator("|"));
        }
        return result;
    };
    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
    _ParseAST.prototype.parseConditional = function () {
        var start = this.inputIndex;
        var result = this.parseLogicalOr();
        if (this.optionalOperator('?')) {
            var yes = this.parsePipe();
            if (!this.optionalCharacter(lexer_1.$COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error("Conditional expression " + expression + " requires all 3 expressions");
            }
            var no = this.parsePipe();
            return new ast_1.Conditional(result, yes, no);
        }
        else {
            return result;
        }
    };
    _ParseAST.prototype.parseLogicalOr = function () {
        // '||'
        var result = this.parseLogicalAnd();
        while (this.optionalOperator('||')) {
            result = new ast_1.Binary('||', result, this.parseLogicalAnd());
        }
        return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function () {
        // '&&'
        var result = this.parseEquality();
        while (this.optionalOperator('&&')) {
            result = new ast_1.Binary('&&', result, this.parseEquality());
        }
        return result;
    };
    _ParseAST.prototype.parseEquality = function () {
        // '==','!=','===','!=='
        var result = this.parseRelational();
        while (true) {
            if (this.optionalOperator('==')) {
                result = new ast_1.Binary('==', result, this.parseRelational());
            }
            else if (this.optionalOperator('===')) {
                result = new ast_1.Binary('===', result, this.parseRelational());
            }
            else if (this.optionalOperator('!=')) {
                result = new ast_1.Binary('!=', result, this.parseRelational());
            }
            else if (this.optionalOperator('!==')) {
                result = new ast_1.Binary('!==', result, this.parseRelational());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseRelational = function () {
        // '<', '>', '<=', '>='
        var result = this.parseAdditive();
        while (true) {
            if (this.optionalOperator('<')) {
                result = new ast_1.Binary('<', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>')) {
                result = new ast_1.Binary('>', result, this.parseAdditive());
            }
            else if (this.optionalOperator('<=')) {
                result = new ast_1.Binary('<=', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>=')) {
                result = new ast_1.Binary('>=', result, this.parseAdditive());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseAdditive = function () {
        // '+', '-'
        var result = this.parseMultiplicative();
        while (true) {
            if (this.optionalOperator('+')) {
                result = new ast_1.Binary('+', result, this.parseMultiplicative());
            }
            else if (this.optionalOperator('-')) {
                result = new ast_1.Binary('-', result, this.parseMultiplicative());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseMultiplicative = function () {
        // '*', '%', '/'
        var result = this.parsePrefix();
        while (true) {
            if (this.optionalOperator('*')) {
                result = new ast_1.Binary('*', result, this.parsePrefix());
            }
            else if (this.optionalOperator('%')) {
                result = new ast_1.Binary('%', result, this.parsePrefix());
            }
            else if (this.optionalOperator('/')) {
                result = new ast_1.Binary('/', result, this.parsePrefix());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrefix = function () {
        if (this.optionalOperator('+')) {
            return this.parsePrefix();
        }
        else if (this.optionalOperator('-')) {
            return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());
        }
        else if (this.optionalOperator('!')) {
            return new ast_1.PrefixNot(this.parsePrefix());
        }
        else {
            return this.parseCallChain();
        }
    };
    _ParseAST.prototype.parseCallChain = function () {
        var result = this.parsePrimary();
        while (true) {
            if (this.optionalCharacter(lexer_1.$PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result, false);
            }
            else if (this.optionalOperator('?.')) {
                result = this.parseAccessMemberOrMethodCall(result, true);
            }
            else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
                var key = this.parsePipe();
                this.expectCharacter(lexer_1.$RBRACKET);
                if (this.optionalOperator("=")) {
                    var value = this.parseConditional();
                    result = new ast_1.KeyedWrite(result, key, value);
                }
                else {
                    result = new ast_1.KeyedRead(result, key);
                }
            }
            else if (this.optionalCharacter(lexer_1.$LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter(lexer_1.$RPAREN);
                result = new ast_1.FunctionCall(result, args);
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrimary = function () {
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var result = this.parsePipe();
            this.expectCharacter(lexer_1.$RPAREN);
            return result;
        }
        else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
            this.advance();
            return new ast_1.LiteralPrimitive(null);
        }
        else if (this.next.isKeywordTrue()) {
            this.advance();
            return new ast_1.LiteralPrimitive(true);
        }
        else if (this.next.isKeywordFalse()) {
            this.advance();
            return new ast_1.LiteralPrimitive(false);
        }
        else if (this.parseAction && this.next.isKeywordIf()) {
            this.advance();
            this.expectCharacter(lexer_1.$LPAREN);
            var condition = this.parseExpression();
            this.expectCharacter(lexer_1.$RPAREN);
            var ifExp = this.parseExpressionOrBlock();
            var elseExp;
            if (this.next.isKeywordElse()) {
                this.advance();
                elseExp = this.parseExpressionOrBlock();
            }
            return new ast_1.If(condition, ifExp, elseExp);
        }
        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
            var elements = this.parseExpressionList(lexer_1.$RBRACKET);
            this.expectCharacter(lexer_1.$RBRACKET);
            return new ast_1.LiteralArray(elements);
        }
        else if (this.next.isCharacter(lexer_1.$LBRACE)) {
            return this.parseLiteralMap();
        }
        else if (this.next.isIdentifier()) {
            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
        }
        else if (this.next.isNumber()) {
            var value = this.next.toNumber();
            this.advance();
            return new ast_1.LiteralPrimitive(value);
        }
        else if (this.next.isString()) {
            var literalValue = this.next.toString();
            this.advance();
            return new ast_1.LiteralPrimitive(literalValue);
        }
        else if (this.index >= this.tokens.length) {
            this.error("Unexpected end of expression: " + this.input);
        }
        else {
            this.error("Unexpected token " + this.next);
        }
        // error() throws, so we don't reach here.
        throw new exceptions_1.BaseException("Fell through all cases in parsePrimary");
    };
    _ParseAST.prototype.parseExpressionList = function (terminator) {
        var result = [];
        if (!this.next.isCharacter(terminator)) {
            do {
                result.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
        }
        return result;
    };
    _ParseAST.prototype.parseLiteralMap = function () {
        var keys = [];
        var values = [];
        this.expectCharacter(lexer_1.$LBRACE);
        if (!this.optionalCharacter(lexer_1.$RBRACE)) {
            do {
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push(key);
                this.expectCharacter(lexer_1.$COLON);
                values.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
            this.expectCharacter(lexer_1.$RBRACE);
        }
        return new ast_1.LiteralMap(keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
        if (isSafe === void 0) { isSafe = false; }
        var id = this.expectIdentifierOrKeyword();
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var args = this.parseCallArguments();
            this.expectCharacter(lexer_1.$RPAREN);
            var fn = this.reflector.method(id);
            return isSafe ? new ast_1.SafeMethodCall(receiver, id, fn, args) :
                new ast_1.MethodCall(receiver, id, fn, args);
        }
        else {
            if (isSafe) {
                if (this.optionalOperator("=")) {
                    this.error("The '?.' operator cannot be used in the assignment");
                }
                else {
                    return new ast_1.SafePropertyRead(receiver, id, this.reflector.getter(id));
                }
            }
            else {
                if (this.optionalOperator("=")) {
                    if (!this.parseAction) {
                        this.error("Bindings cannot contain assignments");
                    }
                    var value = this.parseConditional();
                    return new ast_1.PropertyWrite(receiver, id, this.reflector.setter(id), value);
                }
                else {
                    return new ast_1.PropertyRead(receiver, id, this.reflector.getter(id));
                }
            }
        }
        return null;
    };
    _ParseAST.prototype.parseCallArguments = function () {
        if (this.next.isCharacter(lexer_1.$RPAREN))
            return [];
        var positionals = [];
        do {
            positionals.push(this.parsePipe());
        } while (this.optionalCharacter(lexer_1.$COMMA));
        return positionals;
    };
    _ParseAST.prototype.parseExpressionOrBlock = function () {
        if (this.optionalCharacter(lexer_1.$LBRACE)) {
            var block = this.parseBlockContent();
            this.expectCharacter(lexer_1.$RBRACE);
            return block;
        }
        return this.parseExpression();
    };
    _ParseAST.prototype.parseBlockContent = function () {
        if (!this.parseAction) {
            this.error("Binding expression cannot contain chained expression");
        }
        var exprs = [];
        while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {
            var expr = this.parseExpression();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    _ParseAST.prototype.expectTemplateBindingKey = function () {
        var result = '';
        var operatorFound = false;
        do {
            result += this.expectIdentifierOrKeywordOrString();
            operatorFound = this.optionalOperator('-');
            if (operatorFound) {
                result += '-';
            }
        } while (operatorFound);
        return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function () {
        var bindings = [];
        var prefix = null;
        while (this.index < this.tokens.length) {
            var keyIsVar = this.optionalKeywordVar();
            var key = this.expectTemplateBindingKey();
            if (!keyIsVar) {
                if (prefix == null) {
                    prefix = key;
                }
                else {
                    key = prefix + '-' + key;
                }
            }
            this.optionalCharacter(lexer_1.$COLON);
            var name = null;
            var expression = null;
            if (keyIsVar) {
                if (this.optionalOperator("=")) {
                    name = this.expectTemplateBindingKey();
                }
                else {
                    name = '\$implicit';
                }
            }
            else if (this.next !== lexer_1.EOF && !this.peekKeywordVar()) {
                var start = this.inputIndex;
                var ast = this.parsePipe();
                var source = this.input.substring(start, this.inputIndex);
                expression = new ast_1.ASTWithSource(ast, source, this.location);
            }
            bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
            if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {
                this.optionalCharacter(lexer_1.$COMMA);
            }
        }
        return bindings;
    };
    _ParseAST.prototype.error = function (message, index) {
        if (index === void 0) { index = null; }
        if (lang_1.isBlank(index))
            index = this.index;
        var location = (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
            "at the end of the expression";
        throw new ParseException(message, this.input, location, this.location);
    };
    return _ParseAST;
})();
exports._ParseAST = _ParseAST;
var SimpleExpressionChecker = (function () {
    function SimpleExpressionChecker() {
        this.simple = true;
    }
    SimpleExpressionChecker.check = function (ast) {
        var s = new SimpleExpressionChecker();
        ast.visit(s);
        return s.simple;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast) { };
    SimpleExpressionChecker.prototype.visitInterpolation = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast) { };
    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast) { };
    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitMethodCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast) { this.visitAll(ast.expressions); };
    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast) { this.visitAll(ast.values); };
    SimpleExpressionChecker.prototype.visitBinary = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitConditional = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPipe = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    SimpleExpressionChecker.prototype.visitChain = function (ast) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitIf = function (ast) { this.simple = false; };
    return SimpleExpressionChecker;
})();

},{"./ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./lexer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/lexer.js","angular2/src/core/di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipe_lifecycle_reflector.js":[function(require,module,exports){
'use strict';function implementsOnDestroy(pipe) {
    return pipe.constructor.prototype.onDestroy;
}
exports.implementsOnDestroy = implementsOnDestroy;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipes.js":[function(require,module,exports){
'use strict';var SelectedPipe = (function () {
    function SelectedPipe(pipe, pure) {
        this.pipe = pipe;
        this.pure = pure;
    }
    return SelectedPipe;
})();
exports.SelectedPipe = SelectedPipe;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_change_detector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ast_1 = require('./parser/ast');
var change_detection_util_1 = require('./change_detection_util');
var dynamic_change_detector_1 = require('./dynamic_change_detector');
var directive_record_1 = require('./directive_record');
var event_binding_1 = require('./event_binding');
var coalesce_1 = require('./coalesce');
var proto_record_1 = require('./proto_record');
var DynamicProtoChangeDetector = (function () {
    function DynamicProtoChangeDetector(_definition) {
        this._definition = _definition;
        this._propertyBindingRecords = createPropertyRecords(_definition);
        this._eventBindingRecords = createEventRecords(_definition);
        this._propertyBindingTargets = this._definition.bindingRecords.map(function (b) { return b.target; });
        this._directiveIndices = this._definition.directiveRecords.map(function (d) { return d.directiveIndex; });
    }
    DynamicProtoChangeDetector.prototype.instantiate = function (dispatcher) {
        return new dynamic_change_detector_1.DynamicChangeDetector(this._definition.id, dispatcher, this._propertyBindingRecords.length, this._propertyBindingTargets, this._directiveIndices, this._definition.strategy, this._propertyBindingRecords, this._eventBindingRecords, this._definition.directiveRecords, this._definition.genConfig);
    };
    return DynamicProtoChangeDetector;
})();
exports.DynamicProtoChangeDetector = DynamicProtoChangeDetector;
function createPropertyRecords(definition) {
    var recordBuilder = new ProtoRecordBuilder();
    collection_1.ListWrapper.forEachWithIndex(definition.bindingRecords, function (b, index) { return recordBuilder.add(b, definition.variableNames, index); });
    return coalesce_1.coalesce(recordBuilder.records);
}
exports.createPropertyRecords = createPropertyRecords;
function createEventRecords(definition) {
    // TODO: vsavkin: remove $event when the compiler handles render-side variables properly
    var varNames = collection_1.ListWrapper.concat(['$event'], definition.variableNames);
    return definition.eventRecords.map(function (er) {
        var records = _ConvertAstIntoProtoRecords.create(er, varNames);
        var dirIndex = er.implicitReceiver instanceof directive_record_1.DirectiveIndex ? er.implicitReceiver : null;
        return new event_binding_1.EventBinding(er.target.name, er.target.elementIndex, dirIndex, records);
    });
}
exports.createEventRecords = createEventRecords;
var ProtoRecordBuilder = (function () {
    function ProtoRecordBuilder() {
        this.records = [];
    }
    ProtoRecordBuilder.prototype.add = function (b, variableNames, bindingIndex) {
        var oldLast = collection_1.ListWrapper.last(this.records);
        if (lang_1.isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
            oldLast.lastInDirective = false;
        }
        var numberOfRecordsBefore = this.records.length;
        this._appendRecords(b, variableNames, bindingIndex);
        var newLast = collection_1.ListWrapper.last(this.records);
        if (lang_1.isPresent(newLast) && newLast !== oldLast) {
            newLast.lastInBinding = true;
            newLast.lastInDirective = true;
            this._setArgumentToPureFunction(numberOfRecordsBefore);
        }
    };
    /** @internal */
    ProtoRecordBuilder.prototype._setArgumentToPureFunction = function (startIndex) {
        var _this = this;
        for (var i = startIndex; i < this.records.length; ++i) {
            var rec = this.records[i];
            if (rec.isPureFunction()) {
                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
                    true; });
            }
            if (rec.mode === proto_record_1.RecordType.Pipe) {
                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
                    true; });
                this.records[rec.contextIndex - 1].argumentToPureFunction = true;
            }
        }
    };
    /** @internal */
    ProtoRecordBuilder.prototype._appendRecords = function (b, variableNames, bindingIndex) {
        if (b.isDirectiveLifecycle()) {
            this.records.push(new proto_record_1.ProtoRecord(proto_record_1.RecordType.DirectiveLifecycle, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, false, false, false, false, null));
        }
        else {
            _ConvertAstIntoProtoRecords.append(this.records, b, variableNames, bindingIndex);
        }
    };
    return ProtoRecordBuilder;
})();
exports.ProtoRecordBuilder = ProtoRecordBuilder;
var _ConvertAstIntoProtoRecords = (function () {
    function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _variableNames, _bindingIndex) {
        this._records = _records;
        this._bindingRecord = _bindingRecord;
        this._variableNames = _variableNames;
        this._bindingIndex = _bindingIndex;
    }
    _ConvertAstIntoProtoRecords.append = function (records, b, variableNames, bindingIndex) {
        var c = new _ConvertAstIntoProtoRecords(records, b, variableNames, bindingIndex);
        b.ast.visit(c);
    };
    _ConvertAstIntoProtoRecords.create = function (b, variableNames) {
        var rec = [];
        _ConvertAstIntoProtoRecords.append(rec, b, variableNames, null);
        rec[rec.length - 1].lastInBinding = true;
        return rec;
    };
    _ConvertAstIntoProtoRecords.prototype.visitImplicitReceiver = function (ast) { return this._bindingRecord.implicitReceiver; };
    _ConvertAstIntoProtoRecords.prototype.visitInterpolation = function (ast) {
        var args = this._visitAll(ast.expressions);
        return this._addRecord(proto_record_1.RecordType.Interpolate, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralPrimitive = function (ast) {
        return this._addRecord(proto_record_1.RecordType.Const, "literal", ast.value, [], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPropertyRead = function (ast) {
        var receiver = ast.receiver.visit(this);
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
            ast.receiver instanceof ast_1.ImplicitReceiver) {
            return this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
        }
        else {
            return this._addRecord(proto_record_1.RecordType.PropertyRead, ast.name, ast.getter, [], null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitPropertyWrite = function (ast) {
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
            ast.receiver instanceof ast_1.ImplicitReceiver) {
            throw new exceptions_1.BaseException("Cannot reassign a variable binding " + ast.name);
        }
        else {
            var receiver = ast.receiver.visit(this);
            var value = ast.value.visit(this);
            return this._addRecord(proto_record_1.RecordType.PropertyWrite, ast.name, ast.setter, [value], null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitKeyedWrite = function (ast) {
        var obj = ast.obj.visit(this);
        var key = ast.key.visit(this);
        var value = ast.value.visit(this);
        return this._addRecord(proto_record_1.RecordType.KeyedWrite, null, null, [key, value], null, obj);
    };
    _ConvertAstIntoProtoRecords.prototype.visitSafePropertyRead = function (ast) {
        var receiver = ast.receiver.visit(this);
        return this._addRecord(proto_record_1.RecordType.SafeProperty, ast.name, ast.getter, [], null, receiver);
    };
    _ConvertAstIntoProtoRecords.prototype.visitMethodCall = function (ast) {
        var receiver = ast.receiver.visit(this);
        var args = this._visitAll(ast.args);
        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name)) {
            var target = this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
            return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
        }
        else {
            return this._addRecord(proto_record_1.RecordType.InvokeMethod, ast.name, ast.fn, args, null, receiver);
        }
    };
    _ConvertAstIntoProtoRecords.prototype.visitSafeMethodCall = function (ast) {
        var receiver = ast.receiver.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.SafeMethodInvoke, ast.name, ast.fn, args, null, receiver);
    };
    _ConvertAstIntoProtoRecords.prototype.visitFunctionCall = function (ast) {
        var target = ast.target.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralArray = function (ast) {
        var primitiveName = "arrayFn" + ast.expressions.length;
        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitLiteralMap = function (ast) {
        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, _mapPrimitiveName(ast.keys), change_detection_util_1.ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitBinary = function (ast) {
        var left = ast.left.visit(this);
        var right = ast.right.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPrefixNot = function (ast) {
        var exp = ast.expression.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "operation_negate", change_detection_util_1.ChangeDetectionUtil.operation_negate, [exp], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitConditional = function (ast) {
        var c = ast.condition.visit(this);
        var t = ast.trueExp.visit(this);
        var f = ast.falseExp.visit(this);
        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "cond", change_detection_util_1.ChangeDetectionUtil.cond, [c, t, f], null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitPipe = function (ast) {
        var value = ast.exp.visit(this);
        var args = this._visitAll(ast.args);
        return this._addRecord(proto_record_1.RecordType.Pipe, ast.name, ast.name, args, null, value);
    };
    _ConvertAstIntoProtoRecords.prototype.visitKeyedRead = function (ast) {
        var obj = ast.obj.visit(this);
        var key = ast.key.visit(this);
        return this._addRecord(proto_record_1.RecordType.KeyedRead, "keyedAccess", change_detection_util_1.ChangeDetectionUtil.keyedAccess, [key], null, obj);
    };
    _ConvertAstIntoProtoRecords.prototype.visitChain = function (ast) {
        var _this = this;
        var args = ast.expressions.map(function (e) { return e.visit(_this); });
        return this._addRecord(proto_record_1.RecordType.Chain, "chain", null, args, null, 0);
    };
    _ConvertAstIntoProtoRecords.prototype.visitIf = function (ast) { throw new exceptions_1.BaseException('Not supported'); };
    _ConvertAstIntoProtoRecords.prototype._visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    _ConvertAstIntoProtoRecords.prototype._addRecord = function (type, name, funcOrValue, args, fixedArgs, context) {
        var selfIndex = this._records.length + 1;
        if (context instanceof directive_record_1.DirectiveIndex) {
            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
        }
        else {
            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
        }
        return selfIndex;
    };
    return _ConvertAstIntoProtoRecords;
})();
function _arrayFn(length) {
    switch (length) {
        case 0:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn0;
        case 1:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn1;
        case 2:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn2;
        case 3:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn3;
        case 4:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn4;
        case 5:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn5;
        case 6:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn6;
        case 7:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn7;
        case 8:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn8;
        case 9:
            return change_detection_util_1.ChangeDetectionUtil.arrayFn9;
        default:
            throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
    }
}
function _mapPrimitiveName(keys) {
    var stringifiedKeys = keys.map(function (k) { return lang_1.isString(k) ? "\"" + k + "\"" : "" + k; }).join(', ');
    return "mapFn([" + stringifiedKeys + "])";
}
function _operationToPrimitiveName(operation) {
    switch (operation) {
        case '+':
            return "operation_add";
        case '-':
            return "operation_subtract";
        case '*':
            return "operation_multiply";
        case '/':
            return "operation_divide";
        case '%':
            return "operation_remainder";
        case '==':
            return "operation_equals";
        case '!=':
            return "operation_not_equals";
        case '===':
            return "operation_identical";
        case '!==':
            return "operation_not_identical";
        case '<':
            return "operation_less_then";
        case '>':
            return "operation_greater_then";
        case '<=':
            return "operation_less_or_equals_then";
        case '>=':
            return "operation_greater_or_equals_then";
        case '&&':
            return "operation_logical_and";
        case '||':
            return "operation_logical_or";
        default:
            throw new exceptions_1.BaseException("Unsupported operation " + operation);
    }
}
function _operationToFunction(operation) {
    switch (operation) {
        case '+':
            return change_detection_util_1.ChangeDetectionUtil.operation_add;
        case '-':
            return change_detection_util_1.ChangeDetectionUtil.operation_subtract;
        case '*':
            return change_detection_util_1.ChangeDetectionUtil.operation_multiply;
        case '/':
            return change_detection_util_1.ChangeDetectionUtil.operation_divide;
        case '%':
            return change_detection_util_1.ChangeDetectionUtil.operation_remainder;
        case '==':
            return change_detection_util_1.ChangeDetectionUtil.operation_equals;
        case '!=':
            return change_detection_util_1.ChangeDetectionUtil.operation_not_equals;
        case '===':
            return change_detection_util_1.ChangeDetectionUtil.operation_identical;
        case '!==':
            return change_detection_util_1.ChangeDetectionUtil.operation_not_identical;
        case '<':
            return change_detection_util_1.ChangeDetectionUtil.operation_less_then;
        case '>':
            return change_detection_util_1.ChangeDetectionUtil.operation_greater_then;
        case '<=':
            return change_detection_util_1.ChangeDetectionUtil.operation_less_or_equals_then;
        case '>=':
            return change_detection_util_1.ChangeDetectionUtil.operation_greater_or_equals_then;
        case '&&':
            return change_detection_util_1.ChangeDetectionUtil.operation_logical_and;
        case '||':
            return change_detection_util_1.ChangeDetectionUtil.operation_logical_or;
        default:
            throw new exceptions_1.BaseException("Unsupported operation " + operation);
    }
}
function s(v) {
    return lang_1.isPresent(v) ? "" + v : '';
}
function _interpolationFn(strings) {
    var length = strings.length;
    var c0 = length > 0 ? strings[0] : null;
    var c1 = length > 1 ? strings[1] : null;
    var c2 = length > 2 ? strings[2] : null;
    var c3 = length > 3 ? strings[3] : null;
    var c4 = length > 4 ? strings[4] : null;
    var c5 = length > 5 ? strings[5] : null;
    var c6 = length > 6 ? strings[6] : null;
    var c7 = length > 7 ? strings[7] : null;
    var c8 = length > 8 ? strings[8] : null;
    var c9 = length > 9 ? strings[9] : null;
    switch (length - 1) {
        case 1:
            return function (a1) { return c0 + s(a1) + c1; };
        case 2:
            return function (a1, a2) { return c0 + s(a1) + c1 + s(a2) + c2; };
        case 3:
            return function (a1, a2, a3) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3; };
        case 4:
            return function (a1, a2, a3, a4) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4; };
        case 5:
            return function (a1, a2, a3, a4, a5) {
                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
            };
        case 6:
            return function (a1, a2, a3, a4, a5, a6) {
                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
            };
        case 7:
            return function (a1, a2, a3, a4, a5, a6, a7) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7; };
        case 8:
            return function (a1, a2, a3, a4, a5, a6, a7, a8) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) +
                c8; };
        case 9:
            return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 +
                s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) +
                c7 + s(a8) + c8 + s(a9) + c9; };
        default:
            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
    }
}

},{"./change_detection_util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_util.js","./coalesce":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/coalesce.js","./directive_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/directive_record.js","./dynamic_change_detector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/dynamic_change_detector.js","./event_binding":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/event_binding.js","./parser/ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/parser/ast.js","./proto_record":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/proto_record.js":[function(require,module,exports){
'use strict';(function (RecordType) {
    RecordType[RecordType["Self"] = 0] = "Self";
    RecordType[RecordType["Const"] = 1] = "Const";
    RecordType[RecordType["PrimitiveOp"] = 2] = "PrimitiveOp";
    RecordType[RecordType["PropertyRead"] = 3] = "PropertyRead";
    RecordType[RecordType["PropertyWrite"] = 4] = "PropertyWrite";
    RecordType[RecordType["Local"] = 5] = "Local";
    RecordType[RecordType["InvokeMethod"] = 6] = "InvokeMethod";
    RecordType[RecordType["InvokeClosure"] = 7] = "InvokeClosure";
    RecordType[RecordType["KeyedRead"] = 8] = "KeyedRead";
    RecordType[RecordType["KeyedWrite"] = 9] = "KeyedWrite";
    RecordType[RecordType["Pipe"] = 10] = "Pipe";
    RecordType[RecordType["Interpolate"] = 11] = "Interpolate";
    RecordType[RecordType["SafeProperty"] = 12] = "SafeProperty";
    RecordType[RecordType["CollectionLiteral"] = 13] = "CollectionLiteral";
    RecordType[RecordType["SafeMethodInvoke"] = 14] = "SafeMethodInvoke";
    RecordType[RecordType["DirectiveLifecycle"] = 15] = "DirectiveLifecycle";
    RecordType[RecordType["Chain"] = 16] = "Chain";
})(exports.RecordType || (exports.RecordType = {}));
var RecordType = exports.RecordType;
var ProtoRecord = (function () {
    function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, lastInBinding, lastInDirective, argumentToPureFunction, referencedBySelf, propertyBindingIndex) {
        this.mode = mode;
        this.name = name;
        this.funcOrValue = funcOrValue;
        this.args = args;
        this.fixedArgs = fixedArgs;
        this.contextIndex = contextIndex;
        this.directiveIndex = directiveIndex;
        this.selfIndex = selfIndex;
        this.bindingRecord = bindingRecord;
        this.lastInBinding = lastInBinding;
        this.lastInDirective = lastInDirective;
        this.argumentToPureFunction = argumentToPureFunction;
        this.referencedBySelf = referencedBySelf;
        this.propertyBindingIndex = propertyBindingIndex;
    }
    ProtoRecord.prototype.isPureFunction = function () {
        return this.mode === RecordType.Interpolate || this.mode === RecordType.CollectionLiteral;
    };
    ProtoRecord.prototype.isUsedByOtherRecord = function () { return !this.lastInBinding || this.referencedBySelf; };
    ProtoRecord.prototype.shouldBeChecked = function () {
        return this.argumentToPureFunction || this.lastInBinding || this.isPureFunction() ||
            this.isPipeRecord();
    };
    ProtoRecord.prototype.isPipeRecord = function () { return this.mode === RecordType.Pipe; };
    ProtoRecord.prototype.isLifeCycleRecord = function () { return this.mode === RecordType.DirectiveLifecycle; };
    return ProtoRecord;
})();
exports.ProtoRecord = ProtoRecord;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/anchor_based_app_root_url.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var app_root_url_1 = require("angular2/src/core/compiler/app_root_url");
var dom_adapter_1 = require("angular2/src/core/dom/dom_adapter");
var di_1 = require("angular2/src/core/di");
/**
 * Extension of {@link AppRootUrl} that uses a DOM anchor tag to set the root url to
 * the current page's url.
 */
var AnchorBasedAppRootUrl = (function (_super) {
    __extends(AnchorBasedAppRootUrl, _super);
    function AnchorBasedAppRootUrl() {
        _super.call(this, "");
        // compute the root url to pass to AppRootUrl
        var a = dom_adapter_1.DOM.createElement('a');
        dom_adapter_1.DOM.resolveAndSetHref(a, './', null);
        this.value = dom_adapter_1.DOM.getHref(a);
    }
    AnchorBasedAppRootUrl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AnchorBasedAppRootUrl);
    return AnchorBasedAppRootUrl;
})(app_root_url_1.AppRootUrl);
exports.AnchorBasedAppRootUrl = AnchorBasedAppRootUrl;

},{"angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
/**
 * Specifies app root url for the application.
 *
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var AppRootUrl = (function () {
    function AppRootUrl(value) {
        this.value = value;
    }
    AppRootUrl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [String])
    ], AppRootUrl);
    return AppRootUrl;
})();
exports.AppRootUrl = AppRootUrl;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_definition_factory.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var template_ast_1 = require('./template_ast');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
function createChangeDetectorDefinitions(componentType, componentStrategy, genConfig, parsedTemplate) {
    var pvVisitors = [];
    var visitor = new ProtoViewVisitor(null, pvVisitors, componentStrategy);
    template_ast_1.templateVisitAll(visitor, parsedTemplate);
    return createChangeDefinitions(pvVisitors, componentType, genConfig);
}
exports.createChangeDetectorDefinitions = createChangeDetectorDefinitions;
var ProtoViewVisitor = (function () {
    function ProtoViewVisitor(parent, allVisitors, strategy) {
        this.parent = parent;
        this.allVisitors = allVisitors;
        this.strategy = strategy;
        this.boundTextCount = 0;
        this.boundElementCount = 0;
        this.variableNames = [];
        this.bindingRecords = [];
        this.eventRecords = [];
        this.directiveRecords = [];
        this.viewIndex = allVisitors.length;
        allVisitors.push(this);
    }
    ProtoViewVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        this.boundElementCount++;
        for (var i = 0; i < ast.directives.length; i++) {
            ast.directives[i].visit(this, i);
        }
        var childVisitor = new ProtoViewVisitor(this, this.allVisitors, change_detection_1.ChangeDetectionStrategy.Default);
        // Attention: variables present on an embedded template count towards
        // the embedded template and not the template anchor!
        template_ast_1.templateVisitAll(childVisitor, ast.vars);
        template_ast_1.templateVisitAll(childVisitor, ast.children);
        return null;
    };
    ProtoViewVisitor.prototype.visitElement = function (ast, context) {
        if (ast.isBound()) {
            this.boundElementCount++;
        }
        template_ast_1.templateVisitAll(this, ast.inputs, null);
        template_ast_1.templateVisitAll(this, ast.outputs);
        template_ast_1.templateVisitAll(this, ast.exportAsVars);
        for (var i = 0; i < ast.directives.length; i++) {
            ast.directives[i].visit(this, i);
        }
        template_ast_1.templateVisitAll(this, ast.children);
        return null;
    };
    ProtoViewVisitor.prototype.visitNgContent = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitVariable = function (ast, context) {
        this.variableNames.push(ast.name);
        return null;
    };
    ProtoViewVisitor.prototype.visitEvent = function (ast, directiveRecord) {
        var bindingRecord = lang_1.isPresent(directiveRecord) ?
            change_detection_1.BindingRecord.createForHostEvent(ast.handler, ast.fullName, directiveRecord) :
            change_detection_1.BindingRecord.createForEvent(ast.handler, ast.fullName, this.boundElementCount - 1);
        this.eventRecords.push(bindingRecord);
        return null;
    };
    ProtoViewVisitor.prototype.visitElementProperty = function (ast, directiveRecord) {
        var boundElementIndex = this.boundElementCount - 1;
        var dirIndex = lang_1.isPresent(directiveRecord) ? directiveRecord.directiveIndex : null;
        var bindingRecord;
        if (ast.type === template_ast_1.PropertyBindingType.Property) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostProperty(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementProperty(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Attribute) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostAttribute(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementAttribute(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Class) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostClass(dirIndex, ast.value, ast.name) :
                    change_detection_1.BindingRecord.createForElementClass(ast.value, boundElementIndex, ast.name);
        }
        else if (ast.type === template_ast_1.PropertyBindingType.Style) {
            bindingRecord =
                lang_1.isPresent(dirIndex) ?
                    change_detection_1.BindingRecord.createForHostStyle(dirIndex, ast.value, ast.name, ast.unit) :
                    change_detection_1.BindingRecord.createForElementStyle(ast.value, boundElementIndex, ast.name, ast.unit);
        }
        this.bindingRecords.push(bindingRecord);
        return null;
    };
    ProtoViewVisitor.prototype.visitAttr = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitBoundText = function (ast, context) {
        var boundTextIndex = this.boundTextCount++;
        this.bindingRecords.push(change_detection_1.BindingRecord.createForTextNode(ast.value, boundTextIndex));
        return null;
    };
    ProtoViewVisitor.prototype.visitText = function (ast, context) { return null; };
    ProtoViewVisitor.prototype.visitDirective = function (ast, directiveIndexAsNumber) {
        var directiveIndex = new change_detection_1.DirectiveIndex(this.boundElementCount - 1, directiveIndexAsNumber);
        var directiveMetadata = ast.directive;
        var directiveRecord = new change_detection_1.DirectiveRecord({
            directiveIndex: directiveIndex,
            callAfterContentInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentInit) !== -1,
            callAfterContentChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentChecked) !== -1,
            callAfterViewInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewInit) !== -1,
            callAfterViewChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewChecked) !== -1,
            callOnChanges: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnChanges) !== -1,
            callDoCheck: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.DoCheck) !== -1,
            callOnInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnInit) !== -1,
            changeDetection: directiveMetadata.changeDetection
        });
        this.directiveRecords.push(directiveRecord);
        template_ast_1.templateVisitAll(this, ast.inputs, directiveRecord);
        var bindingRecords = this.bindingRecords;
        if (directiveRecord.callOnChanges) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnChanges(directiveRecord));
        }
        if (directiveRecord.callOnInit) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnInit(directiveRecord));
        }
        if (directiveRecord.callDoCheck) {
            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveDoCheck(directiveRecord));
        }
        template_ast_1.templateVisitAll(this, ast.hostProperties, directiveRecord);
        template_ast_1.templateVisitAll(this, ast.hostEvents, directiveRecord);
        template_ast_1.templateVisitAll(this, ast.exportAsVars);
        return null;
    };
    ProtoViewVisitor.prototype.visitDirectiveProperty = function (ast, directiveRecord) {
        // TODO: these setters should eventually be created by change detection, to make
        // it monomorphic!
        var setter = reflection_1.reflector.setter(ast.directiveName);
        this.bindingRecords.push(change_detection_1.BindingRecord.createForDirective(ast.value, ast.directiveName, setter, directiveRecord));
        return null;
    };
    return ProtoViewVisitor;
})();
function createChangeDefinitions(pvVisitors, componentType, genConfig) {
    var pvVariableNames = _collectNestedProtoViewsVariableNames(pvVisitors);
    return pvVisitors.map(function (pvVisitor) {
        var id = componentType.name + "_" + pvVisitor.viewIndex;
        return new change_detection_1.ChangeDetectorDefinition(id, pvVisitor.strategy, pvVariableNames[pvVisitor.viewIndex], pvVisitor.bindingRecords, pvVisitor.eventRecords, pvVisitor.directiveRecords, genConfig);
    });
}
function _collectNestedProtoViewsVariableNames(pvVisitors) {
    var nestedPvVariableNames = collection_1.ListWrapper.createFixedSize(pvVisitors.length);
    pvVisitors.forEach(function (pv) {
        var parentVariableNames = lang_1.isPresent(pv.parent) ? nestedPvVariableNames[pv.parent.viewIndex] : [];
        nestedPvVariableNames[pv.viewIndex] = parentVariableNames.concat(pv.variableNames);
    });
    return nestedPvVariableNames;
}

},{"./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var source_module_1 = require('./source_module');
var change_detection_jit_generator_1 = require('angular2/src/core/change_detection/change_detection_jit_generator');
var change_definition_factory_1 = require('./change_definition_factory');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var change_detector_codegen_1 = require('angular2/src/transform/template_compiler/change_detector_codegen');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
var UTIL = "ChangeDetectionUtil";
var ABSTRACT_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/abstract_change_detector" + util_1.MODULE_SUFFIX);
var UTIL_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/change_detection_util" + util_1.MODULE_SUFFIX);
var PREGEN_PROTO_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef("package:angular2/src/core/change_detection/pregen_proto_change_detector" + util_1.MODULE_SUFFIX);
var ChangeDetectionCompiler = (function () {
    function ChangeDetectionCompiler(_genConfig) {
        this._genConfig = _genConfig;
    }
    ChangeDetectionCompiler.prototype.compileComponentRuntime = function (componentType, strategy, parsedTemplate) {
        var _this = this;
        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        return changeDetectorDefinitions.map(function (definition) {
            return _this._createChangeDetectorFactory(definition);
        });
    };
    ChangeDetectionCompiler.prototype._createChangeDetectorFactory = function (definition) {
        if (util_1.IS_DART || !this._genConfig.useJit) {
            var proto = new change_detection_1.DynamicProtoChangeDetector(definition);
            return function (dispatcher) { return proto.instantiate(dispatcher); };
        }
        else {
            return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, UTIL, ABSTRACT_CHANGE_DETECTOR).generate();
        }
    };
    ChangeDetectionCompiler.prototype.compileComponentCodeGen = function (componentType, strategy, parsedTemplate) {
        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        var factories = [];
        var index = 0;
        var sourceParts = changeDetectorDefinitions.map(function (definition) {
            var codegen;
            var sourcePart;
            // TODO(tbosch): move the 2 code generators to the same place, one with .dart and one with .ts
            // suffix
            // and have the same API for calling them!
            if (util_1.IS_DART) {
                codegen = new change_detector_codegen_1.Codegen(PREGEN_PROTO_CHANGE_DETECTOR_MODULE);
                var className = definition.id;
                var typeRef = (index === 0 && componentType.isHost) ?
                    'dynamic' :
                    "" + source_module_1.moduleRef(componentType.moduleUrl) + componentType.name;
                codegen.generate(typeRef, className, definition);
                factories.push("(dispatcher) => new " + className + "(dispatcher)");
                sourcePart = codegen.toString();
            }
            else {
                codegen = new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, "" + UTIL_MODULE + UTIL, "" + ABSTRACT_CHANGE_DETECTOR_MODULE + ABSTRACT_CHANGE_DETECTOR);
                factories.push("function(dispatcher) { return new " + codegen.typeName + "(dispatcher); }");
                sourcePart = codegen.generateSource();
            }
            index++;
            return sourcePart;
        });
        return new source_module_1.SourceExpressions(sourceParts, factories);
    };
    ChangeDetectionCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorGenConfig])
    ], ChangeDetectionCompiler);
    return ChangeDetectionCompiler;
})();
exports.ChangeDetectionCompiler = ChangeDetectionCompiler;

},{"./change_definition_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_definition_factory.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/change_detection/change_detection_jit_generator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection_jit_generator.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/transform/template_compiler/change_detector_codegen":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/transform/template_compiler/change_detector_codegen.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
var template_ast_1 = require('./template_ast');
var source_module_1 = require('./source_module');
var view_1 = require('angular2/src/core/metadata/view');
var style_compiler_1 = require('./style_compiler');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
exports.TEMPLATE_COMMANDS_MODULE_REF = source_module_1.moduleRef("package:angular2/src/core/linker/template_commands" + util_1.MODULE_SUFFIX);
var IMPLICIT_TEMPLATE_VAR = '\$implicit';
var CLASS_ATTR = 'class';
var STYLE_ATTR = 'style';
var CommandCompiler = (function () {
    function CommandCompiler() {
    }
    CommandCompiler.prototype.compileComponentRuntime = function (component, appId, templateId, template, changeDetectorFactories, componentTemplateFactory) {
        var visitor = new CommandBuilderVisitor(new RuntimeCommandFactory(component, appId, templateId, componentTemplateFactory, changeDetectorFactories), 0);
        template_ast_1.templateVisitAll(visitor, template);
        return visitor.result;
    };
    CommandCompiler.prototype.compileComponentCodeGen = function (component, appIdExpr, templateIdExpr, template, changeDetectorFactoryExpressions, componentTemplateFactory) {
        var visitor = new CommandBuilderVisitor(new CodegenCommandFactory(component, appIdExpr, templateIdExpr, componentTemplateFactory, changeDetectorFactoryExpressions), 0);
        template_ast_1.templateVisitAll(visitor, template);
        var source = "[" + visitor.result.join(',') + "]";
        return new source_module_1.SourceExpression([], source);
    };
    CommandCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], CommandCompiler);
    return CommandCompiler;
})();
exports.CommandCompiler = CommandCompiler;
var RuntimeCommandFactory = (function () {
    function RuntimeCommandFactory(component, appId, templateId, componentTemplateFactory, changeDetectorFactories) {
        this.component = component;
        this.appId = appId;
        this.templateId = templateId;
        this.componentTemplateFactory = componentTemplateFactory;
        this.changeDetectorFactories = changeDetectorFactories;
    }
    RuntimeCommandFactory.prototype._mapDirectives = function (directives) {
        return directives.map(function (directive) { return directive.type.runtime; });
    };
    RuntimeCommandFactory.prototype._addStyleShimAttributes = function (attrNameAndValues, localComponent, localTemplateId) {
        var additionalStyles = [];
        if (lang_1.isPresent(localComponent) &&
            localComponent.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStyles.push(style_compiler_1.shimHostAttribute(this.appId, localTemplateId));
            additionalStyles.push('');
        }
        if (this.component.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStyles.push(style_compiler_1.shimContentAttribute(this.appId, this.templateId));
            additionalStyles.push('');
        }
        return additionalStyles.concat(attrNameAndValues);
    };
    RuntimeCommandFactory.prototype.createText = function (value, isBound, ngContentIndex) {
        return template_commands_1.text(value, isBound, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createNgContent = function (index, ngContentIndex) {
        return template_commands_1.ngContent(index, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createBeginElement = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        return template_commands_1.beginElement(name, this._addStyleShimAttributes(attrNameAndValues, null, null), eventTargetAndNames, variableNameAndValues, this._mapDirectives(directives), isBound, ngContentIndex);
    };
    RuntimeCommandFactory.prototype.createEndElement = function () { return template_commands_1.endElement(); };
    RuntimeCommandFactory.prototype.createBeginComponent = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex) {
        var nestedTemplate = this.componentTemplateFactory(directives[0]);
        return template_commands_1.beginComponent(name, this._addStyleShimAttributes(attrNameAndValues, directives[0], nestedTemplate.id), eventTargetAndNames, variableNameAndValues, this._mapDirectives(directives), nativeShadow, ngContentIndex, nestedTemplate);
    };
    RuntimeCommandFactory.prototype.createEndComponent = function () { return template_commands_1.endComponent(); };
    RuntimeCommandFactory.prototype.createEmbeddedTemplate = function (embeddedTemplateIndex, attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, children) {
        return template_commands_1.embeddedTemplate(attrNameAndValues, variableNameAndValues, this._mapDirectives(directives), isMerged, ngContentIndex, this.changeDetectorFactories[embeddedTemplateIndex], children);
    };
    return RuntimeCommandFactory;
})();
var CodegenCommandFactory = (function () {
    function CodegenCommandFactory(component, appIdExpr, templateIdExpr, componentTemplateFactory, changeDetectorFactoryExpressions) {
        this.component = component;
        this.appIdExpr = appIdExpr;
        this.templateIdExpr = templateIdExpr;
        this.componentTemplateFactory = componentTemplateFactory;
        this.changeDetectorFactoryExpressions = changeDetectorFactoryExpressions;
    }
    CodegenCommandFactory.prototype._addStyleShimAttributes = function (attrNameAndValues, localComponent, localTemplateIdExpr) {
        var additionalStlyes = [];
        if (lang_1.isPresent(localComponent) &&
            localComponent.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStlyes.push(new Expression(style_compiler_1.shimHostAttributeExpr(this.appIdExpr, localTemplateIdExpr)));
            additionalStlyes.push('');
        }
        if (this.component.template.encapsulation === view_1.ViewEncapsulation.Emulated) {
            additionalStlyes.push(new Expression(style_compiler_1.shimContentAttributeExpr(this.appIdExpr, this.templateIdExpr)));
            additionalStlyes.push('');
        }
        return additionalStlyes.concat(attrNameAndValues);
    };
    CodegenCommandFactory.prototype.createText = function (value, isBound, ngContentIndex) {
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "text(" + util_1.escapeSingleQuoteString(value) + ", " + isBound + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createNgContent = function (index, ngContentIndex) {
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "ngContent(" + index + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createBeginElement = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        var attrsExpression = codeGenArray(this._addStyleShimAttributes(attrNameAndValues, null, null));
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "beginElement(" + util_1.escapeSingleQuoteString(name) + ", " + attrsExpression + ", " + codeGenArray(eventTargetAndNames) + ", " + codeGenArray(variableNameAndValues) + ", " + codeGenDirectivesArray(directives) + ", " + isBound + ", " + ngContentIndex + ")";
    };
    CodegenCommandFactory.prototype.createEndElement = function () { return exports.TEMPLATE_COMMANDS_MODULE_REF + "endElement()"; };
    CodegenCommandFactory.prototype.createBeginComponent = function (name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex) {
        var nestedCompExpr = this.componentTemplateFactory(directives[0]);
        var attrsExpression = codeGenArray(this._addStyleShimAttributes(attrNameAndValues, directives[0], nestedCompExpr + ".id"));
        return exports.TEMPLATE_COMMANDS_MODULE_REF + "beginComponent(" + util_1.escapeSingleQuoteString(name) + ", " + attrsExpression + ", " + codeGenArray(eventTargetAndNames) + ", " + codeGenArray(variableNameAndValues) + ", " + codeGenDirectivesArray(directives) + ", " + nativeShadow + ", " + ngContentIndex + ", " + nestedCompExpr + ")";
    };
    CodegenCommandFactory.prototype.createEndComponent = function () { return exports.TEMPLATE_COMMANDS_MODULE_REF + "endComponent()"; };
    CodegenCommandFactory.prototype.createEmbeddedTemplate = function (embeddedTemplateIndex, attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, children) {
        return (exports.TEMPLATE_COMMANDS_MODULE_REF + "embeddedTemplate(" + codeGenArray(attrNameAndValues) + ", " + codeGenArray(variableNameAndValues) + ", ") +
            (codeGenDirectivesArray(directives) + ", " + isMerged + ", " + ngContentIndex + ", " + this.changeDetectorFactoryExpressions[embeddedTemplateIndex] + ", [" + children.join(',') + "])");
    };
    return CodegenCommandFactory;
})();
function visitAndReturnContext(visitor, asts, context) {
    template_ast_1.templateVisitAll(visitor, asts, context);
    return context;
}
var CommandBuilderVisitor = (function () {
    function CommandBuilderVisitor(commandFactory, embeddedTemplateIndex) {
        this.commandFactory = commandFactory;
        this.embeddedTemplateIndex = embeddedTemplateIndex;
        this.result = [];
        this.transitiveNgContentCount = 0;
    }
    CommandBuilderVisitor.prototype._readAttrNameAndValues = function (directives, attrAsts) {
        var attrs = keyValueArrayToMap(visitAndReturnContext(this, attrAsts, []));
        directives.forEach(function (directiveMeta) {
            collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, function (value, name) {
                var prevValue = attrs[name];
                attrs[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
            });
        });
        return mapToKeyValueArray(attrs);
    };
    CommandBuilderVisitor.prototype.visitNgContent = function (ast, context) {
        this.transitiveNgContentCount++;
        this.result.push(this.commandFactory.createNgContent(ast.index, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        var _this = this;
        this.embeddedTemplateIndex++;
        var childVisitor = new CommandBuilderVisitor(this.commandFactory, this.embeddedTemplateIndex);
        template_ast_1.templateVisitAll(childVisitor, ast.children);
        var isMerged = childVisitor.transitiveNgContentCount > 0;
        var variableNameAndValues = [];
        ast.vars.forEach(function (varAst) {
            variableNameAndValues.push(varAst.name);
            variableNameAndValues.push(varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR);
        });
        var directives = [];
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            directiveAst.visit(_this, new DirectiveContext(index, [], [], directives));
        });
        this.result.push(this.commandFactory.createEmbeddedTemplate(this.embeddedTemplateIndex, this._readAttrNameAndValues(directives, ast.attrs), variableNameAndValues, directives, isMerged, ast.ngContentIndex, childVisitor.result));
        this.transitiveNgContentCount += childVisitor.transitiveNgContentCount;
        this.embeddedTemplateIndex = childVisitor.embeddedTemplateIndex;
        return null;
    };
    CommandBuilderVisitor.prototype.visitElement = function (ast, context) {
        var _this = this;
        var component = ast.getComponent();
        var eventTargetAndNames = visitAndReturnContext(this, ast.outputs, []);
        var variableNameAndValues = [];
        if (lang_1.isBlank(component)) {
            ast.exportAsVars.forEach(function (varAst) {
                variableNameAndValues.push(varAst.name);
                variableNameAndValues.push(null);
            });
        }
        var directives = [];
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            directiveAst.visit(_this, new DirectiveContext(index, eventTargetAndNames, variableNameAndValues, directives));
        });
        eventTargetAndNames = removeKeyValueArrayDuplicates(eventTargetAndNames);
        var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
        if (lang_1.isPresent(component)) {
            this.result.push(this.commandFactory.createBeginComponent(ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, component.template.encapsulation === view_1.ViewEncapsulation.Native, ast.ngContentIndex));
            template_ast_1.templateVisitAll(this, ast.children);
            this.result.push(this.commandFactory.createEndComponent());
        }
        else {
            this.result.push(this.commandFactory.createBeginElement(ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, ast.isBound(), ast.ngContentIndex));
            template_ast_1.templateVisitAll(this, ast.children);
            this.result.push(this.commandFactory.createEndElement());
        }
        return null;
    };
    CommandBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
    CommandBuilderVisitor.prototype.visitAttr = function (ast, attrNameAndValues) {
        attrNameAndValues.push(ast.name);
        attrNameAndValues.push(ast.value);
        return null;
    };
    CommandBuilderVisitor.prototype.visitBoundText = function (ast, context) {
        this.result.push(this.commandFactory.createText(null, true, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitText = function (ast, context) {
        this.result.push(this.commandFactory.createText(ast.value, false, ast.ngContentIndex));
        return null;
    };
    CommandBuilderVisitor.prototype.visitDirective = function (ast, ctx) {
        ctx.targetDirectives.push(ast.directive);
        template_ast_1.templateVisitAll(this, ast.hostEvents, ctx.eventTargetAndNames);
        ast.exportAsVars.forEach(function (varAst) {
            ctx.targetVariableNameAndValues.push(varAst.name);
            ctx.targetVariableNameAndValues.push(ctx.index);
        });
        return null;
    };
    CommandBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
        eventTargetAndNames.push(ast.target);
        eventTargetAndNames.push(ast.name);
        return null;
    };
    CommandBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
    CommandBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
    return CommandBuilderVisitor;
})();
function removeKeyValueArrayDuplicates(keyValueArray) {
    var knownPairs = new Set();
    var resultKeyValueArray = [];
    for (var i = 0; i < keyValueArray.length; i += 2) {
        var key = keyValueArray[i];
        var value = keyValueArray[i + 1];
        var pairId = key + ":" + value;
        if (!collection_1.SetWrapper.has(knownPairs, pairId)) {
            resultKeyValueArray.push(key);
            resultKeyValueArray.push(value);
            knownPairs.add(pairId);
        }
    }
    return resultKeyValueArray;
}
function keyValueArrayToMap(keyValueArr) {
    var data = {};
    for (var i = 0; i < keyValueArr.length; i += 2) {
        data[keyValueArr[i]] = keyValueArr[i + 1];
    }
    return data;
}
function mapToKeyValueArray(data) {
    var entryArray = [];
    collection_1.StringMapWrapper.forEach(data, function (value, name) { entryArray.push([name, value]); });
    // We need to sort to get a defined output order
    // for tests and for caching generated artifacts...
    collection_1.ListWrapper.sort(entryArray, function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });
    var keyValueArray = [];
    entryArray.forEach(function (entry) {
        keyValueArray.push(entry[0]);
        keyValueArray.push(entry[1]);
    });
    return keyValueArray;
}
function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
        return attrValue1 + " " + attrValue2;
    }
    else {
        return attrValue2;
    }
}
var DirectiveContext = (function () {
    function DirectiveContext(index, eventTargetAndNames, targetVariableNameAndValues, targetDirectives) {
        this.index = index;
        this.eventTargetAndNames = eventTargetAndNames;
        this.targetVariableNameAndValues = targetVariableNameAndValues;
        this.targetDirectives = targetDirectives;
    }
    return DirectiveContext;
})();
var Expression = (function () {
    function Expression(value) {
        this.value = value;
    }
    return Expression;
})();
function escapeValue(value) {
    if (value instanceof Expression) {
        return value.value;
    }
    else if (lang_1.isString(value)) {
        return util_1.escapeSingleQuoteString(value);
    }
    else if (lang_1.isBlank(value)) {
        return 'null';
    }
    else {
        return "" + value;
    }
}
function codeGenArray(data) {
    return "[" + data.map(escapeValue).join(',') + "]";
}
function codeGenDirectivesArray(directives) {
    var expressions = directives.map(function (directiveType) { return ("" + source_module_1.moduleRef(directiveType.type.moduleUrl) + directiveType.type.name); });
    return "[" + expressions.join(',') + "]";
}

},{"./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/compiler.js":[function(require,module,exports){
'use strict';var runtime_compiler_1 = require("./runtime_compiler");
var template_compiler_1 = require('./template_compiler');
exports.TemplateCompiler = template_compiler_1.TemplateCompiler;
var directive_metadata_1 = require('./directive_metadata');
exports.CompileDirectiveMetadata = directive_metadata_1.CompileDirectiveMetadata;
exports.CompileTypeMetadata = directive_metadata_1.CompileTypeMetadata;
exports.CompileTemplateMetadata = directive_metadata_1.CompileTemplateMetadata;
var source_module_1 = require('./source_module');
exports.SourceModule = source_module_1.SourceModule;
exports.SourceWithImports = source_module_1.SourceWithImports;
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var template_parser_1 = require('angular2/src/core/compiler/template_parser');
var html_parser_1 = require('angular2/src/core/compiler/html_parser');
var template_normalizer_1 = require('angular2/src/core/compiler/template_normalizer');
var runtime_metadata_1 = require('angular2/src/core/compiler/runtime_metadata');
var change_detector_compiler_1 = require('angular2/src/core/compiler/change_detector_compiler');
var style_compiler_1 = require('angular2/src/core/compiler/style_compiler');
var command_compiler_1 = require('angular2/src/core/compiler/command_compiler');
var template_compiler_2 = require('angular2/src/core/compiler/template_compiler');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var compiler_1 = require('angular2/src/core/linker/compiler');
var runtime_compiler_2 = require('angular2/src/core/compiler/runtime_compiler');
var element_schema_registry_1 = require('angular2/src/core/compiler/schema/element_schema_registry');
var dom_element_schema_registry_1 = require('angular2/src/core/compiler/schema/dom_element_schema_registry');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var app_root_url_1 = require('angular2/src/core/compiler/app_root_url');
var anchor_based_app_root_url_1 = require('angular2/src/core/compiler/anchor_based_app_root_url');
var change_detection_2 = require('angular2/src/core/change_detection/change_detection');
function compilerProviders() {
    return [
        change_detection_2.Lexer,
        change_detection_2.Parser,
        html_parser_1.HtmlParser,
        template_parser_1.TemplateParser,
        template_normalizer_1.TemplateNormalizer,
        runtime_metadata_1.RuntimeMetadataResolver,
        style_compiler_1.StyleCompiler,
        command_compiler_1.CommandCompiler,
        change_detector_compiler_1.ChangeDetectionCompiler,
        di_1.provide(change_detection_1.ChangeDetectorGenConfig, {
            useValue: new change_detection_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), lang_1.assertionsEnabled(), false, true)
        }),
        template_compiler_2.TemplateCompiler,
        di_1.provide(runtime_compiler_2.RuntimeCompiler, { useClass: runtime_compiler_1.RuntimeCompiler_ }),
        di_1.provide(compiler_1.Compiler, { useExisting: runtime_compiler_2.RuntimeCompiler }),
        dom_element_schema_registry_1.DomElementSchemaRegistry,
        di_1.provide(element_schema_registry_1.ElementSchemaRegistry, { useExisting: dom_element_schema_registry_1.DomElementSchemaRegistry }),
        anchor_based_app_root_url_1.AnchorBasedAppRootUrl,
        di_1.provide(app_root_url_1.AppRootUrl, { useExisting: anchor_based_app_root_url_1.AnchorBasedAppRootUrl }),
        url_resolver_1.UrlResolver
    ];
}
exports.compilerProviders = compilerProviders;

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./runtime_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/anchor_based_app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/anchor_based_app_root_url.js","angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/compiler/change_detector_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js","angular2/src/core/compiler/command_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js","angular2/src/core/compiler/html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","angular2/src/core/compiler/runtime_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js","angular2/src/core/compiler/runtime_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js","angular2/src/core/compiler/schema/dom_element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/dom_element_schema_registry.js","angular2/src/core/compiler/schema/element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/compiler/style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","angular2/src/core/compiler/template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/compiler/template_normalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js","angular2/src/core/compiler/template_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var view_1 = require('angular2/src/core/metadata/view');
var selector_1 = require('angular2/src/core/compiler/selector');
var util_1 = require('./util');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
// group 1: "property" from "[property]"
// group 2: "event" from "(event)"
var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
var CompileTypeMetadata = (function () {
    function CompileTypeMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, runtime = _b.runtime, name = _b.name, moduleUrl = _b.moduleUrl, isHost = _b.isHost;
        this.runtime = runtime;
        this.name = name;
        this.moduleUrl = moduleUrl;
        this.isHost = lang_1.normalizeBool(isHost);
    }
    CompileTypeMetadata.fromJson = function (data) {
        return new CompileTypeMetadata({ name: data['name'], moduleUrl: data['moduleUrl'], isHost: data['isHost'] });
    };
    CompileTypeMetadata.prototype.toJson = function () {
        return {
            // Note: Runtime type can't be serialized...
            'name': this.name,
            'moduleUrl': this.moduleUrl,
            'isHost': this.isHost
        };
    };
    return CompileTypeMetadata;
})();
exports.CompileTypeMetadata = CompileTypeMetadata;
var CompileTemplateMetadata = (function () {
    function CompileTemplateMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, ngContentSelectors = _b.ngContentSelectors;
        this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : view_1.ViewEncapsulation.Emulated;
        this.template = template;
        this.templateUrl = templateUrl;
        this.styles = lang_1.isPresent(styles) ? styles : [];
        this.styleUrls = lang_1.isPresent(styleUrls) ? styleUrls : [];
        this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];
    }
    CompileTemplateMetadata.fromJson = function (data) {
        return new CompileTemplateMetadata({
            encapsulation: lang_1.isPresent(data['encapsulation']) ?
                view_1.VIEW_ENCAPSULATION_VALUES[data['encapsulation']] :
                data['encapsulation'],
            template: data['template'],
            templateUrl: data['templateUrl'],
            styles: data['styles'],
            styleUrls: data['styleUrls'],
            ngContentSelectors: data['ngContentSelectors']
        });
    };
    CompileTemplateMetadata.prototype.toJson = function () {
        return {
            'encapsulation': lang_1.isPresent(this.encapsulation) ? lang_1.serializeEnum(this.encapsulation) : this.encapsulation,
            'template': this.template,
            'templateUrl': this.templateUrl,
            'styles': this.styles,
            'styleUrls': this.styleUrls,
            'ngContentSelectors': this.ngContentSelectors
        };
    };
    return CompileTemplateMetadata;
})();
exports.CompileTemplateMetadata = CompileTemplateMetadata;
var CompileDirectiveMetadata = (function () {
    function CompileDirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, lifecycleHooks = _b.lifecycleHooks, template = _b.template;
        this.type = type;
        this.isComponent = isComponent;
        this.dynamicLoadable = dynamicLoadable;
        this.selector = selector;
        this.exportAs = exportAs;
        this.changeDetection = changeDetection;
        this.inputs = inputs;
        this.outputs = outputs;
        this.hostListeners = hostListeners;
        this.hostProperties = hostProperties;
        this.hostAttributes = hostAttributes;
        this.lifecycleHooks = lifecycleHooks;
        this.template = template;
    }
    CompileDirectiveMetadata.create = function (_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, lifecycleHooks = _b.lifecycleHooks, template = _b.template;
        var hostListeners = {};
        var hostProperties = {};
        var hostAttributes = {};
        if (lang_1.isPresent(host)) {
            collection_1.StringMapWrapper.forEach(host, function (value, key) {
                var matches = lang_1.RegExpWrapper.firstMatch(HOST_REG_EXP, key);
                if (lang_1.isBlank(matches)) {
                    hostAttributes[key] = value;
                }
                else if (lang_1.isPresent(matches[1])) {
                    hostProperties[matches[1]] = value;
                }
                else if (lang_1.isPresent(matches[2])) {
                    hostListeners[matches[2]] = value;
                }
            });
        }
        var inputsMap = {};
        if (lang_1.isPresent(inputs)) {
            inputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                inputsMap[parts[0]] = parts[1];
            });
        }
        var outputsMap = {};
        if (lang_1.isPresent(outputs)) {
            outputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                outputsMap[parts[0]] = parts[1];
            });
        }
        return new CompileDirectiveMetadata({
            type: type,
            isComponent: lang_1.normalizeBool(isComponent),
            dynamicLoadable: lang_1.normalizeBool(dynamicLoadable),
            selector: selector,
            exportAs: exportAs,
            changeDetection: changeDetection,
            inputs: inputsMap,
            outputs: outputsMap,
            hostListeners: hostListeners,
            hostProperties: hostProperties,
            hostAttributes: hostAttributes,
            lifecycleHooks: lang_1.isPresent(lifecycleHooks) ? lifecycleHooks : [], template: template
        });
    };
    CompileDirectiveMetadata.fromJson = function (data) {
        return new CompileDirectiveMetadata({
            isComponent: data['isComponent'],
            dynamicLoadable: data['dynamicLoadable'],
            selector: data['selector'],
            exportAs: data['exportAs'],
            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
            changeDetection: lang_1.isPresent(data['changeDetection']) ?
                change_detection_1.CHANGE_DECTION_STRATEGY_VALUES[data['changeDetection']] :
                data['changeDetection'],
            inputs: data['inputs'],
            outputs: data['outputs'],
            hostListeners: data['hostListeners'],
            hostProperties: data['hostProperties'],
            hostAttributes: data['hostAttributes'],
            lifecycleHooks: data['lifecycleHooks'].map(function (hookValue) { return interfaces_1.LIFECYCLE_HOOKS_VALUES[hookValue]; }),
            template: lang_1.isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) :
                data['template']
        });
    };
    CompileDirectiveMetadata.prototype.toJson = function () {
        return {
            'isComponent': this.isComponent,
            'dynamicLoadable': this.dynamicLoadable,
            'selector': this.selector,
            'exportAs': this.exportAs,
            'type': lang_1.isPresent(this.type) ? this.type.toJson() : this.type,
            'changeDetection': lang_1.isPresent(this.changeDetection) ? lang_1.serializeEnum(this.changeDetection) :
                this.changeDetection,
            'inputs': this.inputs,
            'outputs': this.outputs,
            'hostListeners': this.hostListeners,
            'hostProperties': this.hostProperties,
            'hostAttributes': this.hostAttributes,
            'lifecycleHooks': this.lifecycleHooks.map(function (hook) { return lang_1.serializeEnum(hook); }),
            'template': lang_1.isPresent(this.template) ? this.template.toJson() : this.template
        };
    };
    return CompileDirectiveMetadata;
})();
exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
function createHostComponentMeta(componentType, componentSelector) {
    var template = selector_1.CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
        type: new CompileTypeMetadata({
            runtime: Object,
            name: "Host" + componentType.name,
            moduleUrl: componentType.moduleUrl,
            isHost: true
        }),
        template: new CompileTemplateMetadata({ template: template, templateUrl: '', styles: [], styleUrls: [], ngContentSelectors: [] }),
        changeDetection: change_detection_1.ChangeDetectionStrategy.Default,
        inputs: [],
        outputs: [],
        host: {},
        lifecycleHooks: [],
        isComponent: true,
        dynamicLoadable: false,
        selector: '*'
    });
}
exports.createHostComponentMeta = createHostComponentMeta;

},{"./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/selector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var HtmlTextAst = (function () {
    function HtmlTextAst(value, sourceInfo) {
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    HtmlTextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return HtmlTextAst;
})();
exports.HtmlTextAst = HtmlTextAst;
var HtmlAttrAst = (function () {
    function HtmlAttrAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    HtmlAttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return HtmlAttrAst;
})();
exports.HtmlAttrAst = HtmlAttrAst;
var HtmlElementAst = (function () {
    function HtmlElementAst(name, attrs, children, sourceInfo) {
        this.name = name;
        this.attrs = attrs;
        this.children = children;
        this.sourceInfo = sourceInfo;
    }
    HtmlElementAst.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
    return HtmlElementAst;
})();
exports.HtmlElementAst = HtmlElementAst;
function htmlVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.htmlVisitAll = htmlVisitAll;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var html_ast_1 = require('./html_ast');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var NG_NON_BINDABLE = 'ng-non-bindable';
var HtmlParser = (function () {
    function HtmlParser() {
    }
    HtmlParser.prototype.parse = function (template, sourceInfo) {
        var root = dom_adapter_1.DOM.createTemplate(template);
        return parseChildNodes(root, sourceInfo);
    };
    HtmlParser.prototype.unparse = function (nodes) {
        var visitor = new UnparseVisitor();
        var parts = [];
        html_ast_1.htmlVisitAll(visitor, nodes, parts);
        return parts.join('');
    };
    HtmlParser = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HtmlParser);
    return HtmlParser;
})();
exports.HtmlParser = HtmlParser;
function parseText(text, indexInParent, parentSourceInfo) {
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    var value = dom_adapter_1.DOM.getText(text);
    return new html_ast_1.HtmlTextAst(value, parentSourceInfo + " > #text(" + value + "):nth-child(" + indexInParent + ")");
}
function parseAttr(element, parentSourceInfo, attrName, attrValue) {
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    return new html_ast_1.HtmlAttrAst(attrName, attrValue, parentSourceInfo + "[" + attrName + "=" + attrValue + "]");
}
function parseElement(element, indexInParent, parentSourceInfo) {
    // normalize nodename always as lower case so that following build steps
    // can rely on this
    var nodeName = dom_adapter_1.DOM.nodeName(element).toLowerCase();
    // TODO(tbosch): add source row/column source info from parse5 / package:html
    var sourceInfo = parentSourceInfo + " > " + nodeName + ":nth-child(" + indexInParent + ")";
    var attrs = parseAttrs(element, sourceInfo);
    var childNodes = parseChildNodes(element, sourceInfo);
    return new html_ast_1.HtmlElementAst(nodeName, attrs, childNodes, sourceInfo);
}
function parseAttrs(element, elementSourceInfo) {
    // Note: sort the attributes early in the pipeline to get
    // consistent results throughout the pipeline, as attribute order is not defined
    // in DOM parsers!
    var attrMap = dom_adapter_1.DOM.attributeMap(element);
    var attrList = [];
    attrMap.forEach(function (value, name) { return attrList.push([name, value]); });
    attrList.sort(function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });
    return attrList.map(function (entry) { return parseAttr(element, elementSourceInfo, entry[0], entry[1]); });
}
function parseChildNodes(element, parentSourceInfo) {
    var root = dom_adapter_1.DOM.templateAwareRoot(element);
    var childNodes = dom_adapter_1.DOM.childNodesAsList(root);
    var result = [];
    var index = 0;
    childNodes.forEach(function (childNode) {
        var childResult = null;
        if (dom_adapter_1.DOM.isTextNode(childNode)) {
            var text = childNode;
            childResult = parseText(text, index, parentSourceInfo);
        }
        else if (dom_adapter_1.DOM.isElementNode(childNode)) {
            var el = childNode;
            childResult = parseElement(el, index, parentSourceInfo);
        }
        if (lang_1.isPresent(childResult)) {
            // Won't have a childResult for e.g. comment nodes
            result.push(childResult);
        }
        index++;
    });
    return result;
}
var UnparseVisitor = (function () {
    function UnparseVisitor() {
    }
    UnparseVisitor.prototype.visitElement = function (ast, parts) {
        parts.push("<" + ast.name);
        var attrs = [];
        html_ast_1.htmlVisitAll(this, ast.attrs, attrs);
        if (ast.attrs.length > 0) {
            parts.push(' ');
            parts.push(attrs.join(' '));
        }
        parts.push(">");
        html_ast_1.htmlVisitAll(this, ast.children, parts);
        parts.push("</" + ast.name + ">");
        return null;
    };
    UnparseVisitor.prototype.visitAttr = function (ast, parts) {
        parts.push(ast.name + "=" + util_1.escapeDoubleQuoteString(ast.value));
        return null;
    };
    UnparseVisitor.prototype.visitText = function (ast, parts) {
        parts.push(ast.value);
        return null;
    };
    return UnparseVisitor;
})();

},{"./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_compiler.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var compiler_1 = require('angular2/src/core/linker/compiler');
var proto_view_factory_1 = require('angular2/src/core/linker/proto_view_factory');
var template_compiler_1 = require('./template_compiler');
var di_1 = require('angular2/src/core/di');
var RuntimeCompiler = (function (_super) {
    __extends(RuntimeCompiler, _super);
    function RuntimeCompiler() {
        _super.apply(this, arguments);
    }
    return RuntimeCompiler;
})(compiler_1.Compiler);
exports.RuntimeCompiler = RuntimeCompiler;
var RuntimeCompiler_ = (function (_super) {
    __extends(RuntimeCompiler_, _super);
    function RuntimeCompiler_(_protoViewFactory, _templateCompiler) {
        _super.call(this, _protoViewFactory);
        this._templateCompiler = _templateCompiler;
    }
    RuntimeCompiler_.prototype.compileInHost = function (componentType) {
        var _this = this;
        return this._templateCompiler.compileHostComponentRuntime(componentType)
            .then(function (compiledHostTemplate) { return compiler_1.internalCreateProtoView(_this, compiledHostTemplate); });
    };
    RuntimeCompiler_.prototype.clearCache = function () {
        _super.prototype.clearCache.call(this);
        this._templateCompiler.clearCache();
    };
    RuntimeCompiler_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [proto_view_factory_1.ProtoViewFactory, template_compiler_1.TemplateCompiler])
    ], RuntimeCompiler_);
    return RuntimeCompiler_;
})(compiler_1.Compiler_);
exports.RuntimeCompiler_ = RuntimeCompiler_;

},{"./template_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var cpl = require('./directive_metadata');
var dirAnn = require('angular2/src/core/metadata/directives');
var directive_resolver_1 = require('angular2/src/core/linker/directive_resolver');
var view_resolver_1 = require('angular2/src/core/linker/view_resolver');
var directive_lifecycle_reflector_1 = require('angular2/src/core/linker/directive_lifecycle_reflector');
var interfaces_1 = require('angular2/src/core/linker/interfaces');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var di_2 = require('angular2/src/core/di');
var util_1 = require('./util');
// group 1: "property" from "[property]"
// group 2: "event" from "(event)"
var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
var RuntimeMetadataResolver = (function () {
    function RuntimeMetadataResolver(_directiveResolver, _viewResolver) {
        this._directiveResolver = _directiveResolver;
        this._viewResolver = _viewResolver;
        this._cache = new Map();
    }
    RuntimeMetadataResolver.prototype.getMetadata = function (directiveType) {
        var meta = this._cache.get(directiveType);
        if (lang_1.isBlank(meta)) {
            var directiveAnnotation = this._directiveResolver.resolve(directiveType);
            var moduleUrl = calcModuleUrl(directiveType, directiveAnnotation);
            var templateMeta = null;
            var changeDetectionStrategy = null;
            if (directiveAnnotation instanceof dirAnn.ComponentMetadata) {
                var compAnnotation = directiveAnnotation;
                var viewAnnotation = this._viewResolver.resolve(directiveType);
                templateMeta = new cpl.CompileTemplateMetadata({
                    encapsulation: viewAnnotation.encapsulation,
                    template: viewAnnotation.template,
                    templateUrl: viewAnnotation.templateUrl,
                    styles: viewAnnotation.styles,
                    styleUrls: viewAnnotation.styleUrls
                });
                changeDetectionStrategy = compAnnotation.changeDetection;
            }
            meta = cpl.CompileDirectiveMetadata.create({
                selector: directiveAnnotation.selector,
                exportAs: directiveAnnotation.exportAs,
                isComponent: lang_1.isPresent(templateMeta),
                dynamicLoadable: true,
                type: new cpl.CompileTypeMetadata({ name: lang_1.stringify(directiveType), moduleUrl: moduleUrl, runtime: directiveType }),
                template: templateMeta,
                changeDetection: changeDetectionStrategy,
                inputs: directiveAnnotation.inputs,
                outputs: directiveAnnotation.outputs,
                host: directiveAnnotation.host,
                lifecycleHooks: collection_1.ListWrapper.filter(interfaces_1.LIFECYCLE_HOOKS_VALUES, function (hook) { return directive_lifecycle_reflector_1.hasLifecycleHook(hook, directiveType); })
            });
            this._cache.set(directiveType, meta);
        }
        return meta;
    };
    RuntimeMetadataResolver.prototype.getViewDirectivesMetadata = function (component) {
        var _this = this;
        var view = this._viewResolver.resolve(component);
        var directives = flattenDirectives(view);
        for (var i = 0; i < directives.length; i++) {
            if (!isValidDirective(directives[i])) {
                throw new exceptions_1.BaseException("Unexpected directive value '" + lang_1.stringify(directives[i]) + "' on the View of component '" + lang_1.stringify(component) + "'");
            }
        }
        return removeDuplicatedDirectives(directives.map(function (type) { return _this.getMetadata(type); }));
    };
    RuntimeMetadataResolver = __decorate([
        di_2.Injectable(), 
        __metadata('design:paramtypes', [directive_resolver_1.DirectiveResolver, view_resolver_1.ViewResolver])
    ], RuntimeMetadataResolver);
    return RuntimeMetadataResolver;
})();
exports.RuntimeMetadataResolver = RuntimeMetadataResolver;
function removeDuplicatedDirectives(directives) {
    var directivesMap = new Map();
    directives.forEach(function (dirMeta) { directivesMap.set(dirMeta.type.runtime, dirMeta); });
    return collection_1.MapWrapper.values(directivesMap);
}
function flattenDirectives(view) {
    if (lang_1.isBlank(view.directives))
        return [];
    var directives = [];
    flattenList(view.directives, directives);
    return directives;
}
function flattenList(tree, out) {
    for (var i = 0; i < tree.length; i++) {
        var item = di_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
            flattenList(item, out);
        }
        else {
            out.push(item);
        }
    }
}
function isValidDirective(value) {
    return lang_1.isPresent(value) && (value instanceof lang_1.Type);
}
function calcModuleUrl(type, directiveAnnotation) {
    if (lang_1.isPresent(directiveAnnotation.moduleId)) {
        return "package:" + directiveAnnotation.moduleId + util_1.MODULE_SUFFIX;
    }
    else {
        return reflection_1.reflector.importUri(type);
    }
}

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/directive_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js","angular2/src/core/linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","angular2/src/core/linker/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/linker/view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/src/core/metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/dom_element_schema_registry.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var element_schema_registry_1 = require('./element_schema_registry');
var DomElementSchemaRegistry = (function (_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
        _super.apply(this, arguments);
        this._protoElements = new Map();
    }
    DomElementSchemaRegistry.prototype._getProtoElement = function (tagName) {
        var element = this._protoElements.get(tagName);
        if (lang_1.isBlank(element)) {
            element = dom_adapter_1.DOM.createElement(tagName);
            this._protoElements.set(tagName, element);
        }
        return element;
    };
    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) {
        if (tagName.indexOf('-') !== -1) {
            // can't tell now as we don't know which properties a custom element will get
            // once it is instantiated
            return true;
        }
        else {
            var elm = this._getProtoElement(tagName);
            return dom_adapter_1.DOM.hasProperty(elm, propName);
        }
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {
        var mappedPropName = collection_1.StringMapWrapper.get(dom_adapter_1.DOM.attrToPropMap, propName);
        return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;
    };
    DomElementSchemaRegistry = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DomElementSchemaRegistry);
    return DomElementSchemaRegistry;
})(element_schema_registry_1.ElementSchemaRegistry);
exports.DomElementSchemaRegistry = DomElementSchemaRegistry;

},{"./element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js":[function(require,module,exports){
'use strict';var ElementSchemaRegistry = (function () {
    function ElementSchemaRegistry() {
    }
    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) { return true; };
    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return propName; };
    return ElementSchemaRegistry;
})();
exports.ElementSchemaRegistry = ElementSchemaRegistry;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var _EMPTY_ATTR_VALUE = '';
// TODO: Can't use `const` here as
// in Dart this is not transpiled into `final` yet...
var _SELECTOR_REGEXP = lang_1.RegExpWrapper.create('(\\:not\\()|' +
    '([-\\w]+)|' +
    '(?:\\.([-\\w]+))|' +
    '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
    '(\\))|' +
    '(\\s*,\\s*)'); // ","
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
var CssSelector = (function () {
    function CssSelector() {
        this.element = null;
        this.classNames = [];
        this.attrs = [];
        this.notSelectors = [];
    }
    CssSelector.parse = function (selector) {
        var results = [];
        var _addResult = function (res, cssSel) {
            if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) &&
                collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
            }
            res.push(cssSel);
        };
        var cssSelector = new CssSelector();
        var matcher = lang_1.RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
        var match;
        var current = cssSelector;
        var inNot = false;
        while (lang_1.isPresent(match = lang_1.RegExpMatcherWrapper.next(matcher))) {
            if (lang_1.isPresent(match[1])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');
                }
                inNot = true;
                current = new CssSelector();
                cssSelector.notSelectors.push(current);
            }
            if (lang_1.isPresent(match[2])) {
                current.setElement(match[2]);
            }
            if (lang_1.isPresent(match[3])) {
                current.addClassName(match[3]);
            }
            if (lang_1.isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
            }
            if (lang_1.isPresent(match[6])) {
                inNot = false;
                current = cssSelector;
            }
            if (lang_1.isPresent(match[7])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');
                }
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
            }
        }
        _addResult(results, cssSelector);
        return results;
    };
    CssSelector.prototype.isElementSelector = function () {
        return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) &&
            collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
    };
    CssSelector.prototype.setElement = function (element) {
        if (element === void 0) { element = null; }
        if (lang_1.isPresent(element)) {
            element = element.toLowerCase();
        }
        this.element = element;
    };
    /** Gets a template string for an element that matches the selector. */
    CssSelector.prototype.getMatchingElementTemplate = function () {
        var tagName = lang_1.isPresent(this.element) ? this.element : 'div';
        var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
        var attrs = '';
        for (var i = 0; i < this.attrs.length; i += 2) {
            var attrName = this.attrs[i];
            var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
            attrs += " " + attrName + attrValue;
        }
        return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function (name, value) {
        if (value === void 0) { value = _EMPTY_ATTR_VALUE; }
        this.attrs.push(name.toLowerCase());
        if (lang_1.isPresent(value)) {
            value = value.toLowerCase();
        }
        else {
            value = _EMPTY_ATTR_VALUE;
        }
        this.attrs.push(value);
    };
    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
    CssSelector.prototype.toString = function () {
        var res = '';
        if (lang_1.isPresent(this.element)) {
            res += this.element;
        }
        if (lang_1.isPresent(this.classNames)) {
            for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
            }
        }
        if (lang_1.isPresent(this.attrs)) {
            for (var i = 0; i < this.attrs.length;) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                    res += '=' + attrValue;
                }
                res += ']';
            }
        }
        this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
        return res;
    };
    return CssSelector;
})();
exports.CssSelector = CssSelector;
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
var SelectorMatcher = (function () {
    function SelectorMatcher() {
        this._elementMap = new collection_1.Map();
        this._elementPartialMap = new collection_1.Map();
        this._classMap = new collection_1.Map();
        this._classPartialMap = new collection_1.Map();
        this._attrValueMap = new collection_1.Map();
        this._attrValuePartialMap = new collection_1.Map();
        this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function (notSelectors) {
        var notMatcher = new SelectorMatcher();
        notMatcher.addSelectables(notSelectors, null);
        return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
        var listContext = null;
        if (cssSelectors.length > 1) {
            listContext = new SelectorListContext(cssSelectors);
            this._listContexts.push(listContext);
        }
        for (var i = 0; i < cssSelectors.length; i++) {
            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
        }
    };
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
        var matcher = this;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
        if (lang_1.isPresent(element)) {
            var isTerminal = attrs.length === 0 && classNames.length === 0;
            if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
            }
            else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
            }
        }
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                    this._addTerminal(matcher._classMap, className, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._classPartialMap, className);
                }
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                if (isTerminal) {
                    var terminalMap = matcher._attrValueMap;
                    var terminalValuesMap = terminalMap.get(attrName);
                    if (lang_1.isBlank(terminalValuesMap)) {
                        terminalValuesMap = new collection_1.Map();
                        terminalMap.set(attrName, terminalValuesMap);
                    }
                    this._addTerminal(terminalValuesMap, attrValue, selectable);
                }
                else {
                    var parttialMap = matcher._attrValuePartialMap;
                    var partialValuesMap = parttialMap.get(attrName);
                    if (lang_1.isBlank(partialValuesMap)) {
                        partialValuesMap = new collection_1.Map();
                        parttialMap.set(attrName, partialValuesMap);
                    }
                    matcher = this._addPartial(partialValuesMap, attrValue);
                }
            }
        }
    };
    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
        var terminalList = map.get(name);
        if (lang_1.isBlank(terminalList)) {
            terminalList = [];
            map.set(name, terminalList);
        }
        terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function (map, name) {
        var matcher = map.get(name);
        if (lang_1.isBlank(matcher)) {
            matcher = new SelectorMatcher();
            map.set(name, matcher);
        }
        return matcher;
    };
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
        var result = false;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        for (var i = 0; i < this._listContexts.length; i++) {
            this._listContexts[i].alreadyMatched = false;
        }
        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
            result;
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result =
                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result =
                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                        result;
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var terminalValuesMap = this._attrValueMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) ||
                    result;
                var partialValuesMap = this._attrValuePartialMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result =
                    this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
            }
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var selectables = map.get(name);
        var starSelectables = map.get("*");
        if (lang_1.isPresent(starSelectables)) {
            selectables = selectables.concat(starSelectables);
        }
        if (lang_1.isBlank(selectables)) {
            return false;
        }
        var selectable;
        var result = false;
        for (var index = 0; index < selectables.length; index++) {
            selectable = selectables[index];
            result = selectable.finalize(cssSelector, matchedCallback) || result;
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback /*: (c: CssSelector, a: any) => void*/) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var nestedSelector = map.get(name);
        if (lang_1.isBlank(nestedSelector)) {
            return false;
        }
        // TODO(perf): get rid of recursion and measure again
        // TODO(perf): don't pass the whole selector into the recursion,
        // but only the not processed parts
        return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
})();
exports.SelectorMatcher = SelectorMatcher;
var SelectorListContext = (function () {
    function SelectorListContext(selectors) {
        this.selectors = selectors;
        this.alreadyMatched = false;
    }
    return SelectorListContext;
})();
exports.SelectorListContext = SelectorListContext;
// Store context to pass back selector and context when a selector is matched
var SelectorContext = (function () {
    function SelectorContext(selector, cbContext, listContext) {
        this.selector = selector;
        this.cbContext = cbContext;
        this.listContext = listContext;
        this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function (cssSelector, callback) {
        var result = true;
        if (this.notSelectors.length > 0 &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
            result = !notMatcher.match(cssSelector, null);
        }
        if (result && lang_1.isPresent(callback) &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            if (lang_1.isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
            }
            callback(this.selector, this.cbContext);
        }
        return result;
    };
    return SelectorContext;
})();
exports.SelectorContext = SelectorContext;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/shadow_css.js":[function(require,module,exports){
'use strict';var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */
/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsultion: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to imlement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/
var ShadowCss = (function () {
    function ShadowCss() {
        this.strictStyling = true;
    }
    /*
    * Shim a style element with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    */
    ShadowCss.prototype.shimStyle = function (style, selector, hostSelector) {
        if (hostSelector === void 0) { hostSelector = ''; }
        var cssText = dom_adapter_1.DOM.getText(style);
        return this.shimCssText(cssText, selector, hostSelector);
    };
    /*
    * Shim some cssText with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    *
    * When strictStyling is true:
    * - selector is the attribute added to all elements inside the host,
    * - hostSelector is the attribute added to the host itself.
    */
    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
        if (hostSelector === void 0) { hostSelector = ''; }
        cssText = this._insertDirectives(cssText);
        return this._scopeCssText(cssText, selector, hostSelector);
    };
    /** @internal */
    ShadowCss.prototype._insertDirectives = function (cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
    };
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
    **/
    /** @internal */
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) { return m[1] + '{'; });
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
    **/
    /** @internal */
    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[1], '');
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            return m[3] + rule;
        });
    };
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
    */
    /** @internal */
    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
        var _this = this;
        var unscoped = this._extractUnscopedRulesFromCssText(cssText);
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (lang_1.isPresent(scopeSelector)) {
            _withCssRules(cssText, function (rules) { cssText = _this._scopeRules(rules, scopeSelector, hostSelector); });
        }
        cssText = cssText + '\n' + unscoped;
        return cssText.trim();
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
    **/
    /** @internal */
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        var r = '', m;
        var matcher = lang_1.RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
        while (lang_1.isPresent(m = lang_1.RegExpMatcherWrapper.next(matcher))) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);
            r += rule + '\n\n';
        }
        return r;
    };
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar
    */
    /** @internal */
    ShadowCss.prototype._convertColonHost = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar, .foo scopeName > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * scopeName.foo .bar { ... }
    */
    /** @internal */
    ShadowCss.prototype._convertColonHostContext = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    /** @internal */
    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
        // p1 = :host, p2 = contents of (), p3 rest of rule
        return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function (m) {
            if (lang_1.isPresent(m[2])) {
                var parts = m[2].split(','), r = [];
                for (var i = 0; i < parts.length; i++) {
                    var p = parts[i];
                    if (lang_1.isBlank(p))
                        break;
                    p = p.trim();
                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    };
    /** @internal */
    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
        if (lang_1.StringWrapper.contains(part, _polyfillHost)) {
            return this._colonHostPartReplacer(host, part, suffix);
        }
        else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
        }
    };
    /** @internal */
    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
        return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;
    };
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
    */
    /** @internal */
    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
            cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
        }
        return cssText;
    };
    // change a selector like 'div' to 'name div'
    /** @internal */
    ShadowCss.prototype._scopeRules = function (cssRules, scopeSelector, hostSelector) {
        var cssText = '';
        if (lang_1.isPresent(cssRules)) {
            for (var i = 0; i < cssRules.length; i++) {
                var rule = cssRules[i];
                if (dom_adapter_1.DOM.isStyleRule(rule) || dom_adapter_1.DOM.isPageRule(rule)) {
                    cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) +
                        ' {\n';
                    cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                }
                else if (dom_adapter_1.DOM.isMediaRule(rule)) {
                    cssText += '@media ' + rule.media.mediaText + ' {\n';
                    cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                    cssText += '\n}\n\n';
                }
                else {
                    // KEYFRAMES_RULE in IE throws when we query cssText
                    // when it contains a -webkit- property.
                    // if this happens, we fallback to constructing the rule
                    // from the CSSRuleSet
                    // https://connect.microsoft.com/IE/feedbackdetail/view/955703/accessing-csstext-of-a-keyframe-rule-that-contains-a-webkit-property-via-cssom-generates-exception
                    try {
                        if (lang_1.isPresent(rule.cssText)) {
                            cssText += rule.cssText + '\n\n';
                        }
                    }
                    catch (x) {
                        if (dom_adapter_1.DOM.isKeyframesRule(rule) && lang_1.isPresent(rule.cssRules)) {
                            cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                        }
                    }
                }
            }
        }
        return cssText;
    };
    /** @internal */
    ShadowCss.prototype._ieSafeCssTextFromKeyFrameRule = function (rule) {
        var cssText = '@keyframes ' + rule.name + ' {';
        for (var i = 0; i < rule.cssRules.length; i++) {
            var r = rule.cssRules[i];
            cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
        }
        cssText += ' }';
        return cssText;
    };
    /** @internal */
    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
        var r = [], parts = selector.split(',');
        for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            p = p.trim();
            if (this._selectorNeedsScoping(p, scopeSelector)) {
                p = strict && !lang_1.StringWrapper.contains(p, _polyfillHostNoCombinator) ?
                    this._applyStrictSelectorScope(p, scopeSelector) :
                    this._applySelectorScope(p, scopeSelector, hostSelector);
            }
            r.push(p);
        }
        return r.join(', ');
    };
    /** @internal */
    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
        var re = this._makeScopeMatcher(scopeSelector);
        return !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(re, selector));
    };
    /** @internal */
    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
        var lre = /\[/g;
        var rre = /\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\[');
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\]');
        return lang_1.RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    /** @internal */
    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
        // Difference from webcomponentsjs: scopeSelector could not be an array
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    // scope via name and [is=name]
    /** @internal */
    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
        if (lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
            var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
            selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
            return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
        }
        else {
            return scopeSelector + ' ' + selector;
        }
    };
    // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]
    /** @internal */
    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector) {
        var isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) { return m[1]; });
        var splits = [' ', '>', '+', '~'], scoped = selector, attrName = '[' + scopeSelector + ']';
        for (var i = 0; i < splits.length; i++) {
            var sep = splits[i];
            var parts = scoped.split(sep);
            scoped = parts.map(function (p) {
                // remove :host since it should be unnecessary
                var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) &&
                    !lang_1.StringWrapper.contains(t, attrName)) {
                    var re = /([^:]*)(:*)(.*)/g;
                    var m = lang_1.RegExpWrapper.firstMatch(re, t);
                    if (lang_1.isPresent(m)) {
                        p = m[1] + attrName + m[2] + m[3];
                    }
                }
                return p;
            })
                .join(sep);
        }
        return scoped;
    };
    /** @internal */
    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
        return selector;
    };
    /** @internal */
    ShadowCss.prototype._propertiesFromRule = function (rule) {
        var cssText = rule.style.cssText;
        // TODO(sorvell): Safari cssom incorrectly removes quotes from the content
        // property. (https://bugs.webkit.org/show_bug.cgi?id=118045)
        // don't replace attr rules
        var attrRe = /['"]+|attr/g;
        if (rule.style.content.length > 0 &&
            !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
            var contentRe = /content:[^;]*;/g;
            cssText =
                lang_1.StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
        }
        // TODO(sorvell): we can workaround this issue here, but we need a list
        // of troublesome properties to fix https://github.com/Polymer/platform/issues/53
        //
        // inherit rules can be omitted from cssText
        // TODO(sorvell): remove when Blink bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=358273
        // var style = rule.style;
        // for (var i = 0; i < style.length; i++) {
        //  var name = style.item(i);
        //  var value = style.getPropertyValue(name);
        //  if (value == 'initial') {
        //    cssText += name + ': initial; ';
        //  }
        //}
        return cssText;
    };
    return ShadowCss;
})();
exports.ShadowCss = ShadowCss;
var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _polyfillHost = '-shadowcsshost';
// note: :host-context pre-processed to -shadowcsshostcontext.
var _polyfillHostContext = '-shadowcsscontext';
var _parenSuffix = ')(?:\\((' +
    '(?:\\([^)(]*\\)|[^)(]*)+?' +
    ')\\))?([^,{]*)';
var _cssColonHostRe = lang_1.RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
var _cssColonHostContextRe = lang_1.RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
var _shadowDOMSelectorsRe = [
    />>>/g,
    /::shadow/g,
    /::content/g,
    // Deprecated selectors
    // TODO(vicb): see https://github.com/angular/clang-format/issues/16
    // clang-format off
    /\/deep\//g,
    /\/shadow-deep\//g,
    /\/shadow\//g,
];
var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
var _polyfillHostRe = lang_1.RegExpWrapper.create(_polyfillHost, 'im');
var _colonHostRe = /:host/gim;
var _colonHostContextRe = /:host-context/gim;
function _cssToRules(cssText) {
    return dom_adapter_1.DOM.cssToRules(cssText);
}
function _withCssRules(cssText, callback) {
    // Difference from webcomponentjs: remove the workaround for an old bug in Chrome
    if (lang_1.isBlank(callback))
        return;
    var rules = _cssToRules(cssText);
    callback(rules);
}

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var MODULE_REGEXP = /#MODULE\[([^\]]*)\]/g;
function moduleRef(moduleUrl) {
    return "#MODULE[" + moduleUrl + "]";
}
exports.moduleRef = moduleRef;
var SourceModule = (function () {
    function SourceModule(moduleUrl, sourceWithModuleRefs) {
        this.moduleUrl = moduleUrl;
        this.sourceWithModuleRefs = sourceWithModuleRefs;
    }
    SourceModule.prototype.getSourceWithImports = function () {
        var _this = this;
        var moduleAliases = {};
        var imports = [];
        var newSource = lang_1.StringWrapper.replaceAllMapped(this.sourceWithModuleRefs, MODULE_REGEXP, function (match) {
            var moduleUrl = match[1];
            var alias = moduleAliases[moduleUrl];
            if (lang_1.isBlank(alias)) {
                if (moduleUrl == _this.moduleUrl) {
                    alias = '';
                }
                else {
                    alias = "import" + imports.length;
                    imports.push([moduleUrl, alias]);
                }
                moduleAliases[moduleUrl] = alias;
            }
            return alias.length > 0 ? alias + "." : '';
        });
        return new SourceWithImports(newSource, imports);
    };
    return SourceModule;
})();
exports.SourceModule = SourceModule;
var SourceExpression = (function () {
    function SourceExpression(declarations, expression) {
        this.declarations = declarations;
        this.expression = expression;
    }
    return SourceExpression;
})();
exports.SourceExpression = SourceExpression;
var SourceExpressions = (function () {
    function SourceExpressions(declarations, expressions) {
        this.declarations = declarations;
        this.expressions = expressions;
    }
    return SourceExpressions;
})();
exports.SourceExpressions = SourceExpressions;
var SourceWithImports = (function () {
    function SourceWithImports(source, imports) {
        this.source = source;
        this.imports = imports;
    }
    return SourceWithImports;
})();
exports.SourceWithImports = SourceWithImports;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var source_module_1 = require('./source_module');
var view_1 = require('angular2/src/core/metadata/view');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var shadow_css_1 = require('angular2/src/core/compiler/shadow_css');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var util_1 = require('./util');
var di_1 = require('angular2/src/core/di');
var COMPONENT_VARIABLE = '%COMP%';
var COMPONENT_REGEX = /%COMP%/g;
var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
var HOST_ATTR_EXPR = "'_nghost-'+" + COMPONENT_VARIABLE;
var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
var CONTENT_ATTR_EXPR = "'_ngcontent-'+" + COMPONENT_VARIABLE;
var StyleCompiler = (function () {
    function StyleCompiler(_xhr, _urlResolver) {
        this._xhr = _xhr;
        this._urlResolver = _urlResolver;
        this._styleCache = new Map();
        this._shadowCss = new shadow_css_1.ShadowCss();
    }
    StyleCompiler.prototype.compileComponentRuntime = function (appId, templateId, template) {
        var styles = template.styles;
        var styleAbsUrls = template.styleUrls;
        return this._loadStyles(styles, styleAbsUrls, template.encapsulation === view_1.ViewEncapsulation.Emulated)
            .then(function (styles) { return styles.map(function (style) { return lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, componentId(appId, templateId)); }); });
    };
    StyleCompiler.prototype.compileComponentCodeGen = function (appIdExpression, templateIdExpression, template) {
        var shim = template.encapsulation === view_1.ViewEncapsulation.Emulated;
        var suffix;
        if (shim) {
            suffix = util_1.codeGenMapArray(['style'], "style" + util_1.codeGenReplaceAll(COMPONENT_VARIABLE, componentIdExpression(appIdExpression, templateIdExpression)));
        }
        else {
            suffix = '';
        }
        return this._styleCodeGen(template.styles, template.styleUrls, shim, suffix);
    };
    StyleCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {
        var styleWithImports = style_url_resolver_1.resolveStyleUrls(this._urlResolver, stylesheetUrl, cssText);
        return [
            this._styleModule(stylesheetUrl, false, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, false, '')),
            this._styleModule(stylesheetUrl, true, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, true, ''))
        ];
    };
    StyleCompiler.prototype.clearCache = function () { this._styleCache.clear(); };
    StyleCompiler.prototype._loadStyles = function (plainStyles, absUrls, encapsulate) {
        var _this = this;
        var promises = absUrls.map(function (absUrl) {
            var cacheKey = "" + absUrl + (encapsulate ? '.shim' : '');
            var result = _this._styleCache.get(cacheKey);
            if (lang_1.isBlank(result)) {
                result = _this._xhr.get(absUrl).then(function (style) {
                    var styleWithImports = style_url_resolver_1.resolveStyleUrls(_this._urlResolver, absUrl, style);
                    return _this._loadStyles([styleWithImports.style], styleWithImports.styleUrls, encapsulate);
                });
                _this._styleCache.set(cacheKey, result);
            }
            return result;
        });
        return async_1.PromiseWrapper.all(promises).then(function (nestedStyles) {
            var result = plainStyles.map(function (plainStyle) { return _this._shimIfNeeded(plainStyle, encapsulate); });
            nestedStyles.forEach(function (styles) { return styles.forEach(function (style) { return result.push(style); }); });
            return result;
        });
    };
    StyleCompiler.prototype._styleCodeGen = function (plainStyles, absUrls, shim, suffix) {
        var _this = this;
        var expressionSource = "(";
        expressionSource +=
            "[" + plainStyles.map(function (plainStyle) { return util_1.escapeSingleQuoteString(_this._shimIfNeeded(plainStyle, shim)); }).join(',') + "]";
        for (var i = 0; i < absUrls.length; i++) {
            var moduleUrl = this._createModuleUrl(absUrls[i], shim);
            expressionSource += util_1.codeGenConcatArray(source_module_1.moduleRef(moduleUrl) + "STYLES");
        }
        expressionSource += ")" + suffix;
        return new source_module_1.SourceExpression([], expressionSource);
    };
    StyleCompiler.prototype._styleModule = function (stylesheetUrl, shim, expression) {
        var moduleSource = "\n      " + expression.declarations.join('\n') + "\n      " + util_1.codeGenExportVariable('STYLES') + expression.expression + ";\n    ";
        return new source_module_1.SourceModule(this._createModuleUrl(stylesheetUrl, shim), moduleSource);
    };
    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
    };
    StyleCompiler.prototype._createModuleUrl = function (stylesheetUrl, shim) {
        return shim ? stylesheetUrl + ".shim" + util_1.MODULE_SUFFIX : "" + stylesheetUrl + util_1.MODULE_SUFFIX;
    };
    StyleCompiler = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver])
    ], StyleCompiler);
    return StyleCompiler;
})();
exports.StyleCompiler = StyleCompiler;
function shimContentAttribute(appId, templateId) {
    return lang_1.StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentId(appId, templateId));
}
exports.shimContentAttribute = shimContentAttribute;
function shimContentAttributeExpr(appIdExpr, templateIdExpr) {
    return lang_1.StringWrapper.replaceAll(CONTENT_ATTR_EXPR, COMPONENT_REGEX, componentIdExpression(appIdExpr, templateIdExpr));
}
exports.shimContentAttributeExpr = shimContentAttributeExpr;
function shimHostAttribute(appId, templateId) {
    return lang_1.StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentId(appId, templateId));
}
exports.shimHostAttribute = shimHostAttribute;
function shimHostAttributeExpr(appIdExpr, templateIdExpr) {
    return lang_1.StringWrapper.replaceAll(HOST_ATTR_EXPR, COMPONENT_REGEX, componentIdExpression(appIdExpr, templateIdExpr));
}
exports.shimHostAttributeExpr = shimHostAttributeExpr;
function componentId(appId, templateId) {
    return appId + "-" + templateId;
}
function componentIdExpression(appIdExpression, templateIdExpression) {
    return appIdExpression + "+'-'+" + util_1.codeGenToString(templateIdExpression);
}

},{"./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/compiler/shadow_css":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/shadow_css.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js":[function(require,module,exports){
'use strict';// Some of the code comes from WebComponents.JS
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Rewrites URLs by resolving '@import' and 'url()' URLs from the given base URL,
 * removes and returns the @import urls
 */
function resolveStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    cssText = extractUrls(resolver, baseUrl, cssText, foundUrls);
    cssText = replaceUrls(resolver, baseUrl, cssText);
    return new StyleWithImports(cssText, foundUrls);
}
exports.resolveStyleUrls = resolveStyleUrls;
var StyleWithImports = (function () {
    function StyleWithImports(style, styleUrls) {
        this.style = style;
        this.styleUrls = styleUrls;
    }
    return StyleWithImports;
})();
exports.StyleWithImports = StyleWithImports;
function extractUrls(resolver, baseUrl, cssText, foundUrls) {
    return lang_1.StringWrapper.replaceAllMapped(cssText, _cssImportRe, function (m) {
        var url = lang_1.isPresent(m[1]) ? m[1] : m[2];
        var schemeMatch = lang_1.RegExpWrapper.firstMatch(_urlWithSchemaRe, url);
        if (lang_1.isPresent(schemeMatch) && schemeMatch[1] != 'package') {
            // Do not attempt to resolve non-package absolute URLs with URI scheme
            return m[0];
        }
        foundUrls.push(resolver.resolve(baseUrl, url));
        return '';
    });
}
function replaceUrls(resolver, baseUrl, cssText) {
    return lang_1.StringWrapper.replaceAllMapped(cssText, _cssUrlRe, function (m) {
        var pre = m[1];
        var originalUrl = m[2];
        if (lang_1.RegExpWrapper.test(_dataUrlRe, originalUrl)) {
            // Do not attempt to resolve data: URLs
            return m[0];
        }
        var url = lang_1.StringWrapper.replaceAll(originalUrl, _quoteRe, '');
        var post = m[3];
        var resolvedUrl = resolver.resolve(baseUrl, url);
        return pre + "'" + resolvedUrl + "'" + post;
    });
}
var _cssUrlRe = /(url\()([^)]*)(\))/g;
var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
var _quoteRe = /['"]/g;
var _dataUrlRe = /^['"]?data:/g;
// TODO: can't use /^[^:/?#.]+:/g due to clang-format bug:
//       https://github.com/angular/angular/issues/4596
var _urlWithSchemaRe = /^['"]?([a-zA-Z\-\+\.]+):/g;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var TextAst = (function () {
    function TextAst(value, ngContentIndex, sourceInfo) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return TextAst;
})();
exports.TextAst = TextAst;
var BoundTextAst = (function () {
    function BoundTextAst(value, ngContentIndex, sourceInfo) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    BoundTextAst.prototype.visit = function (visitor, context) {
        return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
})();
exports.BoundTextAst = BoundTextAst;
var AttrAst = (function () {
    function AttrAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return AttrAst;
})();
exports.AttrAst = AttrAst;
var BoundElementPropertyAst = (function () {
    function BoundElementPropertyAst(name, type, value, unit, sourceInfo) {
        this.name = name;
        this.type = type;
        this.value = value;
        this.unit = unit;
        this.sourceInfo = sourceInfo;
    }
    BoundElementPropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitElementProperty(this, context);
    };
    return BoundElementPropertyAst;
})();
exports.BoundElementPropertyAst = BoundElementPropertyAst;
var BoundEventAst = (function () {
    function BoundEventAst(name, target, handler, sourceInfo) {
        this.name = name;
        this.target = target;
        this.handler = handler;
        this.sourceInfo = sourceInfo;
    }
    BoundEventAst.prototype.visit = function (visitor, context) {
        return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
        get: function () {
            if (lang_1.isPresent(this.target)) {
                return this.target + ":" + this.name;
            }
            else {
                return this.name;
            }
        },
        enumerable: true,
        configurable: true
    });
    return BoundEventAst;
})();
exports.BoundEventAst = BoundEventAst;
var VariableAst = (function () {
    function VariableAst(name, value, sourceInfo) {
        this.name = name;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    VariableAst.prototype.visit = function (visitor, context) {
        return visitor.visitVariable(this, context);
    };
    return VariableAst;
})();
exports.VariableAst = VariableAst;
var ElementAst = (function () {
    function ElementAst(name, attrs, inputs, outputs, exportAsVars, directives, children, ngContentIndex, sourceInfo) {
        this.name = name;
        this.attrs = attrs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.exportAsVars = exportAsVars;
        this.directives = directives;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    ElementAst.prototype.visit = function (visitor, context) {
        return visitor.visitElement(this, context);
    };
    ElementAst.prototype.isBound = function () {
        return (this.inputs.length > 0 || this.outputs.length > 0 || this.exportAsVars.length > 0 ||
            this.directives.length > 0);
    };
    ElementAst.prototype.getComponent = function () {
        return this.directives.length > 0 && this.directives[0].directive.isComponent ?
            this.directives[0].directive :
            null;
    };
    return ElementAst;
})();
exports.ElementAst = ElementAst;
var EmbeddedTemplateAst = (function () {
    function EmbeddedTemplateAst(attrs, vars, directives, children, ngContentIndex, sourceInfo) {
        this.attrs = attrs;
        this.vars = vars;
        this.directives = directives;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
        return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
})();
exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
var BoundDirectivePropertyAst = (function () {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceInfo) {
        this.directiveName = directiveName;
        this.templateName = templateName;
        this.value = value;
        this.sourceInfo = sourceInfo;
    }
    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
})();
exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
var DirectiveAst = (function () {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, exportAsVars, sourceInfo) {
        this.directive = directive;
        this.inputs = inputs;
        this.hostProperties = hostProperties;
        this.hostEvents = hostEvents;
        this.exportAsVars = exportAsVars;
        this.sourceInfo = sourceInfo;
    }
    DirectiveAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
})();
exports.DirectiveAst = DirectiveAst;
var NgContentAst = (function () {
    function NgContentAst(index, ngContentIndex, sourceInfo) {
        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.sourceInfo = sourceInfo;
    }
    NgContentAst.prototype.visit = function (visitor, context) {
        return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
})();
exports.NgContentAst = NgContentAst;
(function (PropertyBindingType) {
    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
})(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
var PropertyBindingType = exports.PropertyBindingType;
function templateVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.templateVisitAll = templateVisitAll;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_compiler.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
var directive_metadata_1 = require('./directive_metadata');
var di_1 = require('angular2/src/core/di');
var source_module_1 = require('./source_module');
var change_detector_compiler_1 = require('./change_detector_compiler');
var style_compiler_1 = require('./style_compiler');
var command_compiler_1 = require('./command_compiler');
var template_parser_1 = require('./template_parser');
var template_normalizer_1 = require('./template_normalizer');
var runtime_metadata_1 = require('./runtime_metadata');
var application_tokens_1 = require('angular2/src/core/application_tokens');
var command_compiler_2 = require('./command_compiler');
var util_1 = require('./util');
var di_2 = require('angular2/src/core/di');
var TemplateCompiler = (function () {
    function TemplateCompiler(_runtimeMetadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _commandCompiler, _cdCompiler, appId) {
        this._runtimeMetadataResolver = _runtimeMetadataResolver;
        this._templateNormalizer = _templateNormalizer;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._commandCompiler = _commandCompiler;
        this._cdCompiler = _cdCompiler;
        this._hostCacheKeys = new Map();
        this._compiledTemplateCache = new Map();
        this._compiledTemplateDone = new Map();
        this._appId = appId;
    }
    TemplateCompiler.prototype.normalizeDirectiveMetadata = function (directive) {
        if (!directive.isComponent) {
            // For non components there is nothing to be normalized yet.
            return async_1.PromiseWrapper.resolve(directive);
        }
        var normalizedTemplatePromise;
        if (directive.isComponent) {
            normalizedTemplatePromise =
                this._templateNormalizer.normalizeTemplate(directive.type, directive.template);
        }
        else {
            normalizedTemplatePromise = async_1.PromiseWrapper.resolve(null);
        }
        return normalizedTemplatePromise.then(function (normalizedTemplate) { return new directive_metadata_1.CompileDirectiveMetadata({
            type: directive.type,
            isComponent: directive.isComponent,
            dynamicLoadable: directive.dynamicLoadable,
            selector: directive.selector,
            exportAs: directive.exportAs,
            changeDetection: directive.changeDetection,
            inputs: directive.inputs,
            outputs: directive.outputs,
            hostListeners: directive.hostListeners,
            hostProperties: directive.hostProperties,
            hostAttributes: directive.hostAttributes,
            lifecycleHooks: directive.lifecycleHooks, template: normalizedTemplate
        }); });
    };
    TemplateCompiler.prototype.compileHostComponentRuntime = function (type) {
        var hostCacheKey = this._hostCacheKeys.get(type);
        if (lang_1.isBlank(hostCacheKey)) {
            hostCacheKey = new Object();
            this._hostCacheKeys.set(type, hostCacheKey);
            var compMeta = this._runtimeMetadataResolver.getMetadata(type);
            assertComponent(compMeta);
            var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
            this._compileComponentRuntime(hostCacheKey, hostMeta, [compMeta], new Set());
        }
        return this._compiledTemplateDone.get(hostCacheKey)
            .then(function (compiledTemplate) { return new template_commands_1.CompiledHostTemplate(function () { return compiledTemplate; }); });
    };
    TemplateCompiler.prototype.clearCache = function () {
        this._hostCacheKeys.clear();
        this._styleCompiler.clearCache();
        this._compiledTemplateCache.clear();
        this._compiledTemplateDone.clear();
    };
    TemplateCompiler.prototype._compileComponentRuntime = function (cacheKey, compMeta, viewDirectives, compilingComponentCacheKeys) {
        var _this = this;
        var compiledTemplate = this._compiledTemplateCache.get(cacheKey);
        var done = this._compiledTemplateDone.get(cacheKey);
        if (lang_1.isBlank(compiledTemplate)) {
            var styles;
            var changeDetectorFactory;
            var commands;
            var templateId = template_commands_1.nextTemplateId();
            compiledTemplate =
                new template_commands_1.CompiledTemplate(templateId, function (_a, _b) { return [changeDetectorFactory, commands, styles]; });
            this._compiledTemplateCache.set(cacheKey, compiledTemplate);
            compilingComponentCacheKeys.add(cacheKey);
            done =
                async_1.PromiseWrapper.all([
                    this._styleCompiler.compileComponentRuntime(this._appId, templateId, compMeta.template)
                ].concat(viewDirectives.map(function (dirMeta) {
                    return _this.normalizeDirectiveMetadata(dirMeta);
                })))
                    .then(function (stylesAndNormalizedViewDirMetas) {
                    var childPromises = [];
                    var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);
                    var parsedTemplate = _this._templateParser.parse(compMeta.template.template, normalizedViewDirMetas, compMeta.type.name);
                    var changeDetectorFactories = _this._cdCompiler.compileComponentRuntime(compMeta.type, compMeta.changeDetection, parsedTemplate);
                    changeDetectorFactory = changeDetectorFactories[0];
                    styles = stylesAndNormalizedViewDirMetas[0];
                    commands = _this._compileCommandsRuntime(compMeta, templateId, parsedTemplate, changeDetectorFactories, compilingComponentCacheKeys, childPromises);
                    return async_1.PromiseWrapper.all(childPromises);
                })
                    .then(function (_) {
                    collection_1.SetWrapper.delete(compilingComponentCacheKeys, cacheKey);
                    return compiledTemplate;
                });
            this._compiledTemplateDone.set(cacheKey, done);
        }
        return compiledTemplate;
    };
    TemplateCompiler.prototype._compileCommandsRuntime = function (compMeta, templateId, parsedTemplate, changeDetectorFactories, compilingComponentCacheKeys, childPromises) {
        var _this = this;
        return this._commandCompiler.compileComponentRuntime(compMeta, this._appId, templateId, parsedTemplate, changeDetectorFactories, function (childComponentDir) {
            var childCacheKey = childComponentDir.type.runtime;
            var childViewDirectives = _this._runtimeMetadataResolver.getViewDirectivesMetadata(childComponentDir.type.runtime);
            var childIsRecursive = collection_1.SetWrapper.has(compilingComponentCacheKeys, childCacheKey);
            var childTemplate = _this._compileComponentRuntime(childCacheKey, childComponentDir, childViewDirectives, compilingComponentCacheKeys);
            if (!childIsRecursive) {
                // Only wait for a child if it is not a cycle
                childPromises.push(_this._compiledTemplateDone.get(childCacheKey));
            }
            return childTemplate;
        });
    };
    TemplateCompiler.prototype.compileTemplatesCodeGen = function (components) {
        var _this = this;
        if (components.length === 0) {
            throw new exceptions_1.BaseException('No components given');
        }
        var declarations = [];
        var templateArguments = [];
        var componentMetas = [];
        var templateIdVariable = 'templateId';
        var appIdVariable = 'appId';
        components.forEach(function (componentWithDirs) {
            var compMeta = componentWithDirs.component;
            assertComponent(compMeta);
            componentMetas.push(compMeta);
            _this._processTemplateCodeGen(compMeta, appIdVariable, templateIdVariable, componentWithDirs.directives, declarations, templateArguments);
            if (compMeta.dynamicLoadable) {
                var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
                componentMetas.push(hostMeta);
                _this._processTemplateCodeGen(hostMeta, appIdVariable, templateIdVariable, [compMeta], declarations, templateArguments);
            }
        });
        collection_1.ListWrapper.forEachWithIndex(componentMetas, function (compMeta, index) {
            var templateDataFn = util_1.codeGenValueFn([appIdVariable, templateIdVariable], "[" + templateArguments[index].join(',') + "]");
            var compiledTemplateExpr = "new " + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "CompiledTemplate(" + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "nextTemplateId()," + templateDataFn + ")";
            var variableValueExpr;
            if (compMeta.type.isHost) {
                var factoryName = "_hostTemplateFactory" + index;
                declarations.push(util_1.codeGenValueFn([], compiledTemplateExpr, factoryName) + ";");
                var constructionKeyword = util_1.IS_DART ? 'const' : 'new';
                variableValueExpr =
                    constructionKeyword + " " + command_compiler_2.TEMPLATE_COMMANDS_MODULE_REF + "CompiledHostTemplate(" + factoryName + ")";
            }
            else {
                variableValueExpr = compiledTemplateExpr;
            }
            declarations.push("" + util_1.codeGenExportVariable(templateVariableName(compMeta.type), compMeta.type.isHost) + variableValueExpr + ";");
        });
        var moduleUrl = components[0].component.type.moduleUrl;
        return new source_module_1.SourceModule("" + templateModuleUrl(moduleUrl), declarations.join('\n'));
    };
    TemplateCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {
        return this._styleCompiler.compileStylesheetCodeGen(stylesheetUrl, cssText);
    };
    TemplateCompiler.prototype._processTemplateCodeGen = function (compMeta, appIdExpr, templateIdExpr, directives, targetDeclarations, targetTemplateArguments) {
        var styleExpr = this._styleCompiler.compileComponentCodeGen(appIdExpr, templateIdExpr, compMeta.template);
        var parsedTemplate = this._templateParser.parse(compMeta.template.template, directives, compMeta.type.name);
        var changeDetectorsExprs = this._cdCompiler.compileComponentCodeGen(compMeta.type, compMeta.changeDetection, parsedTemplate);
        var commandsExpr = this._commandCompiler.compileComponentCodeGen(compMeta, appIdExpr, templateIdExpr, parsedTemplate, changeDetectorsExprs.expressions, codeGenComponentTemplateFactory);
        addAll(styleExpr.declarations, targetDeclarations);
        addAll(changeDetectorsExprs.declarations, targetDeclarations);
        addAll(commandsExpr.declarations, targetDeclarations);
        targetTemplateArguments.push([changeDetectorsExprs.expressions[0], commandsExpr.expression, styleExpr.expression]);
    };
    TemplateCompiler = __decorate([
        di_1.Injectable(),
        __param(6, di_2.Inject(application_tokens_1.APP_ID)), 
        __metadata('design:paramtypes', [runtime_metadata_1.RuntimeMetadataResolver, template_normalizer_1.TemplateNormalizer, template_parser_1.TemplateParser, style_compiler_1.StyleCompiler, command_compiler_1.CommandCompiler, change_detector_compiler_1.ChangeDetectionCompiler, String])
    ], TemplateCompiler);
    return TemplateCompiler;
})();
exports.TemplateCompiler = TemplateCompiler;
var NormalizedComponentWithViewDirectives = (function () {
    function NormalizedComponentWithViewDirectives(component, directives) {
        this.component = component;
        this.directives = directives;
    }
    return NormalizedComponentWithViewDirectives;
})();
exports.NormalizedComponentWithViewDirectives = NormalizedComponentWithViewDirectives;
function assertComponent(meta) {
    if (!meta.isComponent) {
        throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
}
function templateVariableName(type) {
    return type.name + "Template";
}
function templateModuleUrl(moduleUrl) {
    var urlWithoutSuffix = moduleUrl.substring(0, moduleUrl.length - util_1.MODULE_SUFFIX.length);
    return urlWithoutSuffix + ".template" + util_1.MODULE_SUFFIX;
}
function addAll(source, target) {
    for (var i = 0; i < source.length; i++) {
        target.push(source[i]);
    }
}
function codeGenComponentTemplateFactory(nestedCompType) {
    return "" + source_module_1.moduleRef(templateModuleUrl(nestedCompType.type.moduleUrl)) + templateVariableName(nestedCompType.type);
}

},{"./change_detector_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/change_detector_compiler.js","./command_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/command_compiler.js","./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./runtime_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/runtime_metadata.js","./source_module":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/source_module.js","./style_compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_compiler.js","./template_normalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js","./template_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_normalizer.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var directive_metadata_1 = require('./directive_metadata');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var xhr_1 = require('angular2/src/core/compiler/xhr');
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var di_1 = require('angular2/src/core/di');
var view_1 = require('angular2/src/core/metadata/view');
var html_ast_1 = require('./html_ast');
var html_parser_1 = require('./html_parser');
var template_preparser_1 = require('./template_preparser');
var TemplateNormalizer = (function () {
    function TemplateNormalizer(_xhr, _urlResolver, _domParser) {
        this._xhr = _xhr;
        this._urlResolver = _urlResolver;
        this._domParser = _domParser;
    }
    TemplateNormalizer.prototype.normalizeTemplate = function (directiveType, template) {
        var _this = this;
        if (lang_1.isPresent(template.template)) {
            return async_1.PromiseWrapper.resolve(this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl));
        }
        else if (lang_1.isPresent(template.templateUrl)) {
            var sourceAbsUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
            return this._xhr.get(sourceAbsUrl)
                .then(function (templateContent) { return _this.normalizeLoadedTemplate(directiveType, template, templateContent, sourceAbsUrl); });
        }
        else {
            throw new exceptions_1.BaseException("No template specified for component " + directiveType.name);
        }
    };
    TemplateNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
        var _this = this;
        var domNodes = this._domParser.parse(template, directiveType.name);
        var visitor = new TemplatePreparseVisitor();
        html_ast_1.htmlVisitAll(visitor, domNodes);
        var allStyles = templateMeta.styles.concat(visitor.styles);
        var allStyleAbsUrls = visitor.styleUrls.map(function (url) { return _this._urlResolver.resolve(templateAbsUrl, url); })
            .concat(templateMeta.styleUrls.map(function (url) { return _this._urlResolver.resolve(directiveType.moduleUrl, url); }));
        var allResolvedStyles = allStyles.map(function (style) {
            var styleWithImports = style_url_resolver_1.resolveStyleUrls(_this._urlResolver, templateAbsUrl, style);
            styleWithImports.styleUrls.forEach(function (styleUrl) { return allStyleAbsUrls.push(styleUrl); });
            return styleWithImports.style;
        });
        var encapsulation = templateMeta.encapsulation;
        if (encapsulation === view_1.ViewEncapsulation.Emulated && allResolvedStyles.length === 0 &&
            allStyleAbsUrls.length === 0) {
            encapsulation = view_1.ViewEncapsulation.None;
        }
        return new directive_metadata_1.CompileTemplateMetadata({
            encapsulation: encapsulation,
            template: template,
            templateUrl: templateAbsUrl,
            styles: allResolvedStyles,
            styleUrls: allStyleAbsUrls,
            ngContentSelectors: visitor.ngContentSelectors
        });
    };
    TemplateNormalizer = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver, html_parser_1.HtmlParser])
    ], TemplateNormalizer);
    return TemplateNormalizer;
})();
exports.TemplateNormalizer = TemplateNormalizer;
var TemplatePreparseVisitor = (function () {
    function TemplatePreparseVisitor() {
        this.ngContentSelectors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        switch (preparsedElement.type) {
            case template_preparser_1.PreparsedElementType.NG_CONTENT:
                if (this.ngNonBindableStackCount === 0) {
                    this.ngContentSelectors.push(preparsedElement.selectAttr);
                }
                break;
            case template_preparser_1.PreparsedElementType.STYLE:
                var textContent = '';
                ast.children.forEach(function (child) {
                    if (child instanceof html_ast_1.HtmlTextAst) {
                        textContent += child.value;
                    }
                });
                this.styles.push(textContent);
                break;
            case template_preparser_1.PreparsedElementType.STYLESHEET:
                this.styleUrls.push(preparsedElement.hrefAttr);
                break;
        }
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount++;
        }
        html_ast_1.htmlVisitAll(this, ast.children);
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount--;
        }
        return null;
    };
    TemplatePreparseVisitor.prototype.visitAttr = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
    return TemplatePreparseVisitor;
})();

},{"./directive_metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/directive_metadata.js","./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","./style_url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/style_url_resolver.js","./template_preparser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/compiler/xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_parser.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var html_parser_1 = require('./html_parser');
var template_ast_1 = require('./template_ast');
var selector_1 = require('angular2/src/core/compiler/selector');
var element_schema_registry_1 = require('angular2/src/core/compiler/schema/element_schema_registry');
var template_preparser_1 = require('./template_preparser');
var html_ast_1 = require('./html_ast');
var util_1 = require('./util');
// Group 1 = "bind-"
// Group 2 = "var-" or "#"
// Group 3 = "on-"
// Group 4 = "bindon-"
// Group 5 = the identifier after "bind-", "var-/#", or "on-"
// Group 6 = idenitifer inside [()]
// Group 7 = idenitifer inside []
// Group 8 = identifier inside ()
var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
var TEMPLATE_ELEMENT = 'template';
var TEMPLATE_ATTR = 'template';
var TEMPLATE_ATTR_PREFIX = '*';
var CLASS_ATTR = 'class';
var PROPERTY_PARTS_SEPARATOR = new RegExp('\\.');
var ATTRIBUTE_PREFIX = 'attr';
var CLASS_PREFIX = 'class';
var STYLE_PREFIX = 'style';
var TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];
var TemplateParser = (function () {
    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser) {
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this._htmlParser = _htmlParser;
    }
    TemplateParser.prototype.parse = function (template, directives, sourceInfo) {
        var parseVisitor = new TemplateParseVisitor(directives, this._exprParser, this._schemaRegistry);
        var result = html_ast_1.htmlVisitAll(parseVisitor, this._htmlParser.parse(template, sourceInfo), EMPTY_COMPONENT);
        if (parseVisitor.errors.length > 0) {
            var errorString = parseVisitor.errors.join('\n');
            throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
        }
        return result;
    };
    TemplateParser = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.Parser, element_schema_registry_1.ElementSchemaRegistry, html_parser_1.HtmlParser])
    ], TemplateParser);
    return TemplateParser;
})();
exports.TemplateParser = TemplateParser;
var TemplateParseVisitor = (function () {
    function TemplateParseVisitor(directives, _exprParser, _schemaRegistry) {
        var _this = this;
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this.errors = [];
        this.directivesIndex = new Map();
        this.ngContentCount = 0;
        this.selectorMatcher = new selector_1.SelectorMatcher();
        collection_1.ListWrapper.forEachWithIndex(directives, function (directive, index) {
            var selector = selector_1.CssSelector.parse(directive.selector);
            _this.selectorMatcher.addSelectables(selector, directive);
            _this.directivesIndex.set(directive, index);
        });
    }
    TemplateParseVisitor.prototype._reportError = function (message) { this.errors.push(message); };
    TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceInfo) {
        try {
            return this._exprParser.parseInterpolation(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseAction = function (value, sourceInfo) {
        try {
            return this._exprParser.parseAction(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseBinding = function (value, sourceInfo) {
        try {
            return this._exprParser.parseBinding(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceInfo) {
        try {
            return this._exprParser.parseTemplateBindings(value, sourceInfo);
        }
        catch (e) {
            this._reportError("" + e); // sourceInfo is already contained in the AST
            return [];
        }
    };
    TemplateParseVisitor.prototype.visitText = function (ast, component) {
        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);
        var expr = this._parseInterpolation(ast.value, ast.sourceInfo);
        if (lang_1.isPresent(expr)) {
            return new template_ast_1.BoundTextAst(expr, ngContentIndex, ast.sourceInfo);
        }
        else {
            return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceInfo);
        }
    };
    TemplateParseVisitor.prototype.visitAttr = function (ast, contex) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceInfo);
    };
    TemplateParseVisitor.prototype.visitElement = function (element, component) {
        var _this = this;
        var nodeName = element.name;
        var preparsedElement = template_preparser_1.preparseElement(element);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
        }
        var matchableAttrs = [];
        var elementOrDirectiveProps = [];
        var vars = [];
        var events = [];
        var templateElementOrDirectiveProps = [];
        var templateVars = [];
        var templateMatchableAttrs = [];
        var hasInlineTemplates = false;
        var attrs = [];
        element.attrs.forEach(function (attr) {
            matchableAttrs.push([attr.name, attr.value]);
            var hasBinding = _this._parseAttr(attr, matchableAttrs, elementOrDirectiveProps, events, vars);
            var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateVars);
            if (!hasBinding && !hasTemplateBinding) {
                // don't include the bindings as attributes as well in the AST
                attrs.push(_this.visitAttr(attr, null));
            }
            if (hasTemplateBinding) {
                hasInlineTemplates = true;
            }
        });
        var isTemplateElement = nodeName == TEMPLATE_ELEMENT;
        var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
        var directives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, elementCssSelector), elementOrDirectiveProps, isTemplateElement ? [] : vars, element.sourceInfo);
        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directives);
        var children = html_ast_1.htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, Component.create(directives));
        var elementNgContentIndex = hasInlineTemplates ? null : component.findNgContentIndex(elementCssSelector);
        var parsedElement;
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {
            parsedElement =
                new template_ast_1.NgContentAst(this.ngContentCount++, elementNgContentIndex, element.sourceInfo);
        }
        else if (isTemplateElement) {
            this._assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, events, element.sourceInfo);
            parsedElement = new template_ast_1.EmbeddedTemplateAst(attrs, vars, directives, children, elementNgContentIndex, element.sourceInfo);
        }
        else {
            this._assertOnlyOneComponent(directives, element.sourceInfo);
            var elementExportAsVars = collection_1.ListWrapper.filter(vars, function (varAst) { return varAst.value.length === 0; });
            parsedElement =
                new template_ast_1.ElementAst(nodeName, attrs, elementProps, events, elementExportAsVars, directives, children, elementNgContentIndex, element.sourceInfo);
        }
        if (hasInlineTemplates) {
            var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
            var templateDirectives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, templateCssSelector), templateElementOrDirectiveProps, [], element.sourceInfo);
            var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectives);
            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectives, templateElementProps, [], element.sourceInfo);
            parsedElement = new template_ast_1.EmbeddedTemplateAst([], templateVars, templateDirectives, [parsedElement], component.findNgContentIndex(templateCssSelector), element.sourceInfo);
        }
        return parsedElement;
    };
    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {
        var templateBindingsSource = null;
        if (attr.name == TEMPLATE_ATTR) {
            templateBindingsSource = attr.value;
        }
        else if (lang_1.StringWrapper.startsWith(attr.name, TEMPLATE_ATTR_PREFIX)) {
            var key = lang_1.StringWrapper.substring(attr.name, TEMPLATE_ATTR_PREFIX.length); // remove the star
            templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
        }
        if (lang_1.isPresent(templateBindingsSource)) {
            var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceInfo);
            for (var i = 0; i < bindings.length; i++) {
                var binding = bindings[i];
                var dashCaseKey = util_1.camelCaseToDashCase(binding.key);
                if (binding.keyIsVar) {
                    targetVars.push(new template_ast_1.VariableAst(util_1.dashCaseToCamelCase(binding.key), binding.name, attr.sourceInfo));
                    targetMatchableAttrs.push([dashCaseKey, binding.name]);
                }
                else if (lang_1.isPresent(binding.expression)) {
                    this._parsePropertyAst(dashCaseKey, binding.expression, attr.sourceInfo, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([dashCaseKey, '']);
                }
            }
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parseAttr = function (attr, targetMatchableAttrs, targetProps, targetEvents, targetVars) {
        var attrName = this._normalizeAttributeName(attr.name);
        var attrValue = attr.value;
        var bindParts = lang_1.RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
        var hasBinding = false;
        if (lang_1.isPresent(bindParts)) {
            hasBinding = true;
            if (lang_1.isPresent(bindParts[1])) {
                this._parseProperty(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[2])) {
                var identifier = bindParts[5];
                this._parseVariable(identifier, attrValue, attr.sourceInfo, targetMatchableAttrs, targetVars);
            }
            else if (lang_1.isPresent(bindParts[3])) {
                this._parseEvent(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[4])) {
                this._parseProperty(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[5], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[6])) {
                this._parseProperty(bindParts[6], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[6], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[7])) {
                this._parseProperty(bindParts[7], attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[8])) {
                this._parseEvent(bindParts[8], attrValue, attr.sourceInfo, targetMatchableAttrs, targetEvents);
            }
        }
        else {
            hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceInfo, targetMatchableAttrs, targetProps);
        }
        if (!hasBinding) {
            this._parseLiteralAttr(attrName, attrValue, attr.sourceInfo, targetProps);
        }
        return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
        return lang_1.StringWrapper.startsWith(attrName, 'data-') ? lang_1.StringWrapper.substring(attrName, 5) :
            attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceInfo, targetMatchableAttrs, targetVars) {
        targetVars.push(new template_ast_1.VariableAst(util_1.dashCaseToCamelCase(identifier), value, sourceInfo));
        targetMatchableAttrs.push([identifier, value]);
    };
    TemplateParseVisitor.prototype._parseProperty = function (name, expression, sourceInfo, targetMatchableAttrs, targetProps) {
        this._parsePropertyAst(name, this._parseBinding(expression, sourceInfo), sourceInfo, targetMatchableAttrs, targetProps);
    };
    TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceInfo, targetMatchableAttrs, targetProps) {
        var expr = this._parseInterpolation(value, sourceInfo);
        if (lang_1.isPresent(expr)) {
            this._parsePropertyAst(name, expr, sourceInfo, targetMatchableAttrs, targetProps);
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceInfo, targetMatchableAttrs, targetProps) {
        targetMatchableAttrs.push([name, ast.source]);
        targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceInfo));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceInfo, targetMatchableAttrs, targetEvents) {
        this._parseEvent(name + "-change", expression + "=$event", sourceInfo, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceInfo, targetMatchableAttrs, targetEvents) {
        // long format: 'target: eventName'
        var parts = util_1.splitAtColon(name, [null, name]);
        var target = parts[0];
        var eventName = parts[1];
        targetEvents.push(new template_ast_1.BoundEventAst(util_1.dashCaseToCamelCase(eventName), target, this._parseAction(expression, sourceInfo), sourceInfo));
        // Don't detect directives for event names for now,
        // so don't add the event name to the matchableAttrs
    };
    TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceInfo, targetProps) {
        targetProps.push(new BoundElementOrDirectiveProperty(util_1.dashCaseToCamelCase(name), this._exprParser.wrapLiteralPrimitive(value, sourceInfo), true, sourceInfo));
    };
    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
        var _this = this;
        var directives = [];
        selectorMatcher.match(elementCssSelector, function (selector, directive) { directives.push(directive); });
        // Need to sort the directives so that we get consistent results throughout,
        // as selectorMatcher uses Maps inside.
        // Also need to make components the first directive in the array
        collection_1.ListWrapper.sort(directives, function (dir1, dir2) {
            var dir1Comp = dir1.isComponent;
            var dir2Comp = dir2.isComponent;
            if (dir1Comp && !dir2Comp) {
                return -1;
            }
            else if (!dir1Comp && dir2Comp) {
                return 1;
            }
            else {
                return _this.directivesIndex.get(dir1) - _this.directivesIndex.get(dir2);
            }
        });
        return directives;
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function (elementName, directives, props, possibleExportAsVars, sourceInfo) {
        var _this = this;
        var matchedVariables = new Set();
        var directiveAsts = directives.map(function (directive) {
            var hostProperties = [];
            var hostEvents = [];
            var directiveProperties = [];
            _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceInfo, hostProperties);
            _this._createDirectiveHostEventAsts(directive.hostListeners, sourceInfo, hostEvents);
            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
            var exportAsVars = [];
            possibleExportAsVars.forEach(function (varAst) {
                if ((varAst.value.length === 0 && directive.isComponent) ||
                    (directive.exportAs == varAst.value)) {
                    exportAsVars.push(varAst);
                    matchedVariables.add(varAst.name);
                }
            });
            return new template_ast_1.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, exportAsVars, sourceInfo);
        });
        possibleExportAsVars.forEach(function (varAst) {
            if (varAst.value.length > 0 && !collection_1.SetWrapper.has(matchedVariables, varAst.name)) {
                _this._reportError("There is no directive with \"exportAs\" set to \"" + varAst.value + "\" at " + varAst.sourceInfo);
            }
        });
        return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceInfo, targetPropertyAsts) {
        var _this = this;
        if (lang_1.isPresent(hostProps)) {
            collection_1.StringMapWrapper.forEach(hostProps, function (expression, propName) {
                var exprAst = _this._parseBinding(expression, sourceInfo);
                targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceInfo));
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceInfo, targetEventAsts) {
        var _this = this;
        if (lang_1.isPresent(hostListeners)) {
            collection_1.StringMapWrapper.forEach(hostListeners, function (expression, propName) {
                _this._parseEvent(propName, expression, sourceInfo, [], targetEventAsts);
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
        if (lang_1.isPresent(directiveProperties)) {
            var boundPropsByName = new Map();
            boundProps.forEach(function (boundProp) {
                var key = util_1.dashCaseToCamelCase(boundProp.name);
                var prevValue = boundPropsByName.get(boundProp.name);
                if (lang_1.isBlank(prevValue) || prevValue.isLiteral) {
                    // give [a]="b" a higher precedence thatn a="b" on the same element
                    boundPropsByName.set(key, boundProp);
                }
            });
            collection_1.StringMapWrapper.forEach(directiveProperties, function (elProp, dirProp) {
                elProp = util_1.dashCaseToCamelCase(elProp);
                var boundProp = boundPropsByName.get(elProp);
                // Bindings are optional, so this binding only needs to be set up if an expression is given.
                if (lang_1.isPresent(boundProp)) {
                    targetBoundDirectiveProps.push(new template_ast_1.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceInfo));
                }
            });
        }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
        var _this = this;
        var boundElementProps = [];
        var boundDirectivePropsIndex = new Map();
        directives.forEach(function (directive) {
            directive.inputs.forEach(function (prop) {
                boundDirectivePropsIndex.set(prop.templateName, prop);
            });
        });
        props.forEach(function (prop) {
            if (!prop.isLiteral && lang_1.isBlank(boundDirectivePropsIndex.get(prop.name))) {
                boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceInfo));
            }
        });
        return boundElementProps;
    };
    TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceInfo) {
        var unit = null;
        var bindingType;
        var boundPropertyName;
        var parts = lang_1.StringWrapper.split(name, PROPERTY_PARTS_SEPARATOR);
        if (parts.length === 1) {
            boundPropertyName = this._schemaRegistry.getMappedPropName(util_1.dashCaseToCamelCase(parts[0]));
            bindingType = template_ast_1.PropertyBindingType.Property;
            if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {
                this._reportError("Can't bind to '" + boundPropertyName + "' since it isn't a known native property in " + sourceInfo);
            }
        }
        else if (parts[0] == ATTRIBUTE_PREFIX) {
            boundPropertyName = util_1.dashCaseToCamelCase(parts[1]);
            bindingType = template_ast_1.PropertyBindingType.Attribute;
        }
        else if (parts[0] == CLASS_PREFIX) {
            // keep original case!
            boundPropertyName = parts[1];
            bindingType = template_ast_1.PropertyBindingType.Class;
        }
        else if (parts[0] == STYLE_PREFIX) {
            unit = parts.length > 2 ? parts[2] : null;
            boundPropertyName = util_1.dashCaseToCamelCase(parts[1]);
            bindingType = template_ast_1.PropertyBindingType.Style;
        }
        else {
            this._reportError("Invalid property name " + name + " in " + sourceInfo);
            bindingType = null;
        }
        return new template_ast_1.BoundElementPropertyAst(boundPropertyName, bindingType, ast, unit, sourceInfo);
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
        var componentTypeNames = [];
        directives.forEach(function (directive) {
            var typeName = directive.directive.type.name;
            if (directive.directive.isComponent) {
                componentTypeNames.push(typeName);
            }
        });
        return componentTypeNames;
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceInfo) {
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 1) {
            this._reportError("More than one component: " + componentTypeNames.join(',') + " in " + sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, events, sourceInfo) {
        var _this = this;
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 0) {
            this._reportError("Components on an embedded template: " + componentTypeNames.join(',') + " in " + sourceInfo);
        }
        elementProps.forEach(function (prop) {
            _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template in " + prop.sourceInfo);
        });
        events.forEach(function (event) {
            _this._reportError("Event binding " + event.name + " on an embedded template in " + event.sourceInfo);
        });
    };
    return TemplateParseVisitor;
})();
var NonBindableVisitor = (function () {
    function NonBindableVisitor() {
    }
    NonBindableVisitor.prototype.visitElement = function (ast, component) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
        }
        var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
        var selector = createElementCssSelector(ast.name, attrNameAndValues);
        var ngContentIndex = component.findNgContentIndex(selector);
        var children = html_ast_1.htmlVisitAll(this, ast.children, EMPTY_COMPONENT);
        return new template_ast_1.ElementAst(ast.name, html_ast_1.htmlVisitAll(this, ast.attrs), [], [], [], [], children, ngContentIndex, ast.sourceInfo);
    };
    NonBindableVisitor.prototype.visitAttr = function (ast, context) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceInfo);
    };
    NonBindableVisitor.prototype.visitText = function (ast, component) {
        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);
        return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceInfo);
    };
    return NonBindableVisitor;
})();
var BoundElementOrDirectiveProperty = (function () {
    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceInfo) {
        this.name = name;
        this.expression = expression;
        this.isLiteral = isLiteral;
        this.sourceInfo = sourceInfo;
    }
    return BoundElementOrDirectiveProperty;
})();
var ParseError = (function () {
    function ParseError(message, sourceInfo) {
        this.message = message;
        this.sourceInfo = sourceInfo;
    }
    return ParseError;
})();
function splitClasses(classAttrValue) {
    return lang_1.StringWrapper.split(classAttrValue.trim(), /\s+/g);
}
exports.splitClasses = splitClasses;
var Component = (function () {
    function Component(ngContentIndexMatcher, wildcardNgContentIndex) {
        this.ngContentIndexMatcher = ngContentIndexMatcher;
        this.wildcardNgContentIndex = wildcardNgContentIndex;
    }
    Component.create = function (directives) {
        if (directives.length === 0 || !directives[0].directive.isComponent) {
            return EMPTY_COMPONENT;
        }
        var matcher = new selector_1.SelectorMatcher();
        var ngContentSelectors = directives[0].directive.template.ngContentSelectors;
        var wildcardNgContentIndex = null;
        for (var i = 0; i < ngContentSelectors.length; i++) {
            var selector = ngContentSelectors[i];
            if (lang_1.StringWrapper.equals(selector, '*')) {
                wildcardNgContentIndex = i;
            }
            else {
                matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);
            }
        }
        return new Component(matcher, wildcardNgContentIndex);
    };
    Component.prototype.findNgContentIndex = function (selector) {
        var ngContentIndices = [];
        if (lang_1.isPresent(this.wildcardNgContentIndex)) {
            ngContentIndices.push(this.wildcardNgContentIndex);
        }
        this.ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
        collection_1.ListWrapper.sort(ngContentIndices);
        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return Component;
})();
function createElementCssSelector(elementName, matchableAttrs) {
    var cssSelector = new selector_1.CssSelector();
    cssSelector.setElement(elementName);
    for (var i = 0; i < matchableAttrs.length; i++) {
        var attrName = matchableAttrs[i][0].toLowerCase();
        var attrValue = matchableAttrs[i][1];
        cssSelector.addAttribute(attrName, attrValue);
        if (attrName == CLASS_ATTR) {
            var classes = splitClasses(attrValue);
            classes.forEach(function (className) { return cssSelector.addClassName(className); });
        }
    }
    return cssSelector;
}
var EMPTY_COMPONENT = new Component(new selector_1.SelectorMatcher(), null);
var NON_BINDABLE_VISITOR = new NonBindableVisitor();

},{"./html_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_ast.js","./html_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/html_parser.js","./template_ast":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_ast.js","./template_preparser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/compiler/schema/element_schema_registry":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/schema/element_schema_registry.js","angular2/src/core/compiler/selector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/selector.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/template_preparser.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var NG_CONTENT_SELECT_ATTR = 'select';
var NG_CONTENT_ELEMENT = 'ng-content';
var LINK_ELEMENT = 'link';
var LINK_STYLE_REL_ATTR = 'rel';
var LINK_STYLE_HREF_ATTR = 'href';
var LINK_STYLE_REL_VALUE = 'stylesheet';
var STYLE_ELEMENT = 'style';
var SCRIPT_ELEMENT = 'script';
var NG_NON_BINDABLE_ATTR = 'ng-non-bindable';
function preparseElement(ast) {
    var selectAttr = null;
    var hrefAttr = null;
    var relAttr = null;
    var nonBindable = false;
    ast.attrs.forEach(function (attr) {
        if (attr.name == NG_CONTENT_SELECT_ATTR) {
            selectAttr = attr.value;
        }
        else if (attr.name == LINK_STYLE_HREF_ATTR) {
            hrefAttr = attr.value;
        }
        else if (attr.name == LINK_STYLE_REL_ATTR) {
            relAttr = attr.value;
        }
        else if (attr.name == NG_NON_BINDABLE_ATTR) {
            nonBindable = true;
        }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name;
    var type = PreparsedElementType.OTHER;
    if (nodeName == NG_CONTENT_ELEMENT) {
        type = PreparsedElementType.NG_CONTENT;
    }
    else if (nodeName == STYLE_ELEMENT) {
        type = PreparsedElementType.STYLE;
    }
    else if (nodeName == SCRIPT_ELEMENT) {
        type = PreparsedElementType.SCRIPT;
    }
    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
        type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable);
}
exports.preparseElement = preparseElement;
(function (PreparsedElementType) {
    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
})(exports.PreparsedElementType || (exports.PreparsedElementType = {}));
var PreparsedElementType = exports.PreparsedElementType;
var PreparsedElement = (function () {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable) {
        this.type = type;
        this.selectAttr = selectAttr;
        this.hrefAttr = hrefAttr;
        this.nonBindable = nonBindable;
    }
    return PreparsedElement;
})();
exports.PreparsedElement = PreparsedElement;
function normalizeNgContentSelect(selectAttr) {
    if (lang_1.isBlank(selectAttr) || selectAttr.length === 0) {
        return '*';
    }
    return selectAttr;
}

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var UrlResolver = (function () {
    function UrlResolver() {
    }
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     *
     * @param {string} baseUrl
     * @param {string} url
     * @returns {string} the resolved URL
     */
    UrlResolver.prototype.resolve = function (baseUrl, url) { return _resolveUrl(baseUrl, url); };
    UrlResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], UrlResolver);
    return UrlResolver;
})();
exports.UrlResolver = UrlResolver;
// The code below is adapted from Traceur:
// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (lang_1.isPresent(opt_scheme)) {
        out.push(opt_scheme + ':');
    }
    if (lang_1.isPresent(opt_domain)) {
        out.push('//');
        if (lang_1.isPresent(opt_userInfo)) {
            out.push(opt_userInfo + '@');
        }
        out.push(opt_domain);
        if (lang_1.isPresent(opt_port)) {
            out.push(':' + opt_port);
        }
    }
    if (lang_1.isPresent(opt_path)) {
        out.push(opt_path);
    }
    if (lang_1.isPresent(opt_queryData)) {
        out.push('?' + opt_queryData);
    }
    if (lang_1.isPresent(opt_fragment)) {
        out.push('#' + opt_fragment);
    }
    return out.join('');
}
/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @internal
 */
var _splitRe = lang_1.RegExpWrapper.create('^' +
    '(?:' +
    '([^:/?#.]+)' +
    // used by other URL parts such as :,
    // ?, /, #, and .
    ':)?' +
    '(?://' +
    '(?:([^/?#]*)@)?' +
    '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
    // digits, dashes, dots, percent
    // escapes, and unicode characters.
    '(?::([0-9]+))?' +
    ')?' +
    '([^?#]+)?' +
    '(?:\\?([^#]*))?' +
    '(?:#(.*))?' +
    '$');
/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
var _ComponentIndex;
(function (_ComponentIndex) {
    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
})(_ComponentIndex || (_ComponentIndex = {}));
/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
function _split(uri) {
    return lang_1.RegExpWrapper.firstMatch(_splitRe, uri);
}
/**
  * Removes dot segments in given path component, as described in
  * RFC 3986, section 5.2.4.
  *
  * @param {string} path A non-empty path component.
  * @return {string} Path component with removed dot segments.
  */
function _removeDotSegments(path) {
    if (path == '/')
        return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
        var segment = segments[pos];
        switch (segment) {
            case '':
            case '.':
                break;
            case '..':
                if (out.length > 0) {
                    out.pop();
                }
                else {
                    up++;
                }
                break;
            default:
                out.push(segment);
        }
    }
    if (leadingSlash == '') {
        while (up-- > 0) {
            out.unshift('..');
        }
        if (out.length === 0)
            out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
}
/**
 * Takes an array of the parts from split and canonicalizes the path part
 * and then joins all the parts.
 * @param {Array.<string?>} parts
 * @return {string}
 */
function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
}
/**
 * Resolves a URL.
 * @param {string} base The URL acting as the base URL.
 * @param {string} to The URL to resolve.
 * @return {string}
 */
function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {
        return _joinAndCanonicalizePath(parts);
    }
    else {
        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
        if (lang_1.isBlank(parts[i])) {
            parts[i] = baseParts[i];
        }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
        return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (lang_1.isBlank(path))
        path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
}

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
var SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\$/g;
var DOUBLE_QUOTE_ESCAPE_STRING_RE = /"|\\|\n|\$/g;
exports.IS_DART = !lang_1.isJsObject({});
exports.MODULE_SUFFIX = exports.IS_DART ? '.dart' : '.js';
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;
function escapeSingleQuoteString(input) {
    if (lang_1.isBlank(input)) {
        return null;
    }
    return "'" + escapeString(input, SINGLE_QUOTE_ESCAPE_STRING_RE) + "'";
}
exports.escapeSingleQuoteString = escapeSingleQuoteString;
function escapeDoubleQuoteString(input) {
    if (lang_1.isBlank(input)) {
        return null;
    }
    return "\"" + escapeString(input, DOUBLE_QUOTE_ESCAPE_STRING_RE) + "\"";
}
exports.escapeDoubleQuoteString = escapeDoubleQuoteString;
function escapeString(input, re) {
    return lang_1.StringWrapper.replaceAllMapped(input, re, function (match) {
        if (match[0] == '$') {
            return exports.IS_DART ? '\\$' : '$';
        }
        else if (match[0] == '\n') {
            return '\\n';
        }
        else {
            return "\\" + match[0];
        }
    });
}
function codeGenExportVariable(name, isConst) {
    if (isConst === void 0) { isConst = false; }
    var declaration = exports.IS_DART && isConst ? "const " + name : "var " + name;
    return exports.IS_DART ? declaration + " = " : declaration + " = exports['" + name + "'] = ";
}
exports.codeGenExportVariable = codeGenExportVariable;
function codeGenConcatArray(expression) {
    return (exports.IS_DART ? '..addAll' : '.concat') + "(" + expression + ")";
}
exports.codeGenConcatArray = codeGenConcatArray;
function codeGenMapArray(argNames, callback) {
    if (exports.IS_DART) {
        return ".map( (" + argNames.join(',') + ") => " + callback + " ).toList()";
    }
    else {
        return ".map(function(" + argNames.join(',') + ") { return " + callback + "; })";
    }
}
exports.codeGenMapArray = codeGenMapArray;
function codeGenReplaceAll(pattern, expression) {
    if (exports.IS_DART) {
        return ".replaceAll('" + pattern + "', " + expression + ")";
    }
    else {
        return ".replace(/" + pattern + "/g, " + expression + ")";
    }
}
exports.codeGenReplaceAll = codeGenReplaceAll;
function codeGenValueFn(params, value, fnName) {
    if (fnName === void 0) { fnName = ''; }
    if (exports.IS_DART) {
        return fnName + "(" + params.join(',') + ") => " + value;
    }
    else {
        return "function " + fnName + "(" + params.join(',') + ") { return " + value + "; }";
    }
}
exports.codeGenValueFn = codeGenValueFn;
function codeGenToString(expr) {
    if (exports.IS_DART) {
        return "'${" + expr + "}'";
    }
    else {
        // JS automatically convets to string...
        return expr;
    }
}
exports.codeGenToString = codeGenToString;
function splitAtColon(input, defaultValues) {
    var parts = lang_1.StringWrapper.split(input.trim(), /\s*:\s*/g);
    if (parts.length > 1) {
        return parts;
    }
    else {
        return defaultValues;
    }
}
exports.splitAtColon = splitAtColon;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js":[function(require,module,exports){
'use strict';var XHR = (function () {
    function XHR() {
    }
    XHR.prototype.get = function (url) { return null; };
    return XHR;
})();
exports.XHR = XHR;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr_impl.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var async_1 = require('angular2/src/core/facade/async');
var lang_1 = require('angular2/src/core/facade/lang');
var xhr_1 = require('./xhr');
var XHRImpl = (function (_super) {
    __extends(XHRImpl, _super);
    function XHRImpl() {
        _super.apply(this, arguments);
    }
    XHRImpl.prototype.get = function (url) {
        var completer = async_1.PromiseWrapper.completer();
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'text';
        xhr.onload = function () {
            // responseText is the old-school way of retrieving response (supported by IE8 & 9)
            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
            var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;
            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
            var status = xhr.status === 1223 ? 204 : xhr.status;
            // fix status code when it is 0 (0 status is undocumented).
            // Occurs when accessing file resources or on Android 4.1 stock browser
            // while retrieving files from application cache.
            if (status === 0) {
                status = response ? 200 : 0;
            }
            if (200 <= status && status <= 300) {
                completer.resolve(response);
            }
            else {
                completer.reject("Failed to load " + url, null);
            }
        };
        xhr.onerror = function () { completer.reject("Failed to load " + url, null); };
        xhr.send();
        return completer.promise;
    };
    XHRImpl = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], XHRImpl);
    return XHRImpl;
})(xhr_1.XHR);
exports.XHRImpl = XHRImpl;

},{"./xhr":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/xhr.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug.js":[function(require,module,exports){
'use strict';var debug_element_1 = require('./debug/debug_element');
exports.DebugElement = debug_element_1.DebugElement;
exports.asNativeElements = debug_element_1.asNativeElements;
exports.By = debug_element_1.By;
exports.Scope = debug_element_1.Scope;
exports.inspectElement = debug_element_1.inspectElement;
var debug_element_view_listener_1 = require('./debug/debug_element_view_listener');
exports.inspectNativeElement = debug_element_view_listener_1.inspectNativeElement;
exports.ELEMENT_PROBE_PROVIDERS = debug_element_view_listener_1.ELEMENT_PROBE_PROVIDERS;
exports.ELEMENT_PROBE_BINDINGS = debug_element_view_listener_1.ELEMENT_PROBE_BINDINGS;

},{"./debug/debug_element":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js","./debug/debug_element_view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element_view_listener.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var view_ref_1 = require('angular2/src/core/linker/view_ref');
/**
 * A DebugElement contains information from the Angular compiler about an
 * element and provides access to the corresponding ElementInjector and
 * underlying DOM Element, as well as a way to query for children.
 */
var DebugElement = (function () {
    function DebugElement() {
    }
    Object.defineProperty(DebugElement.prototype, "componentInstance", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "nativeElement", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "elementRef", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "children", {
        /**
         * Get child DebugElements from within the Light DOM.
         *
         * @return {DebugElement[]}
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DebugElement.prototype, "componentViewChildren", {
        /**
         * Get the root DebugElement children of a component. Returns an empty
         * list if the current DebugElement is not a component root.
         *
         * @return {DebugElement[]}
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * Return the first descendant TestElement matching the given predicate
     * and scope.
     *
     * @param {Function: boolean} predicate
     * @param {Scope} scope
     *
     * @return {DebugElement}
     */
    DebugElement.prototype.query = function (predicate, scope) {
        if (scope === void 0) { scope = Scope.all; }
        var results = this.queryAll(predicate, scope);
        return results.length > 0 ? results[0] : null;
    };
    /**
     * Return descendant TestElememts matching the given predicate
     * and scope.
     *
     * @param {Function: boolean} predicate
     * @param {Scope} scope
     *
     * @return {DebugElement[]}
     */
    DebugElement.prototype.queryAll = function (predicate, scope) {
        if (scope === void 0) { scope = Scope.all; }
        var elementsInScope = scope(this);
        return collection_1.ListWrapper.filter(elementsInScope, predicate);
    };
    return DebugElement;
})();
exports.DebugElement = DebugElement;
var DebugElement_ = (function (_super) {
    __extends(DebugElement_, _super);
    function DebugElement_(_parentView, _boundElementIndex) {
        _super.call(this);
        this._parentView = _parentView;
        this._boundElementIndex = _boundElementIndex;
        this._elementInjector = this._parentView.elementInjectors[this._boundElementIndex];
    }
    Object.defineProperty(DebugElement_.prototype, "componentInstance", {
        get: function () {
            if (!lang_1.isPresent(this._elementInjector)) {
                return null;
            }
            return this._elementInjector.getComponent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "nativeElement", {
        get: function () { return this.elementRef.nativeElement; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "elementRef", {
        get: function () { return this._parentView.elementRefs[this._boundElementIndex]; },
        enumerable: true,
        configurable: true
    });
    DebugElement_.prototype.getDirectiveInstance = function (directiveIndex) {
        return this._elementInjector.getDirectiveAtIndex(directiveIndex);
    };
    Object.defineProperty(DebugElement_.prototype, "children", {
        get: function () {
            return this._getChildElements(this._parentView, this._boundElementIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugElement_.prototype, "componentViewChildren", {
        get: function () {
            var shadowView = this._parentView.getNestedView(this._boundElementIndex);
            if (!lang_1.isPresent(shadowView)) {
                // The current element is not a component.
                return [];
            }
            return this._getChildElements(shadowView, null);
        },
        enumerable: true,
        configurable: true
    });
    DebugElement_.prototype.triggerEventHandler = function (eventName, eventObj) {
        this._parentView.triggerEventHandlers(eventName, eventObj, this._boundElementIndex);
    };
    DebugElement_.prototype.hasDirective = function (type) {
        if (!lang_1.isPresent(this._elementInjector)) {
            return false;
        }
        return this._elementInjector.hasDirective(type);
    };
    DebugElement_.prototype.inject = function (type) {
        if (!lang_1.isPresent(this._elementInjector)) {
            return null;
        }
        return this._elementInjector.get(type);
    };
    DebugElement_.prototype.getLocal = function (name) { return this._parentView.locals.get(name); };
    /** @internal */
    DebugElement_.prototype._getChildElements = function (view, parentBoundElementIndex) {
        var _this = this;
        var els = [];
        var parentElementBinder = null;
        if (lang_1.isPresent(parentBoundElementIndex)) {
            parentElementBinder = view.proto.elementBinders[parentBoundElementIndex - view.elementOffset];
        }
        for (var i = 0; i < view.proto.elementBinders.length; ++i) {
            var binder = view.proto.elementBinders[i];
            if (binder.parent == parentElementBinder) {
                els.push(new DebugElement_(view, view.elementOffset + i));
                var views = view.viewContainers[view.elementOffset + i];
                if (lang_1.isPresent(views)) {
                    views.views.forEach(function (nextView) { els = els.concat(_this._getChildElements(nextView, null)); });
                }
            }
        }
        return els;
    };
    return DebugElement_;
})(DebugElement);
exports.DebugElement_ = DebugElement_;
/**
 * Returns a DebugElement for a ElementRef.
 *
 * @param {ElementRef}: elementRef
 * @return {DebugElement}
 */
function inspectElement(elementRef) {
    return new DebugElement_(view_ref_1.internalView(elementRef.parentView), elementRef.boundElementIndex);
}
exports.inspectElement = inspectElement;
function asNativeElements(arr) {
    return arr.map(function (debugEl) { return debugEl.nativeElement; });
}
exports.asNativeElements = asNativeElements;
var Scope = (function () {
    function Scope() {
    }
    Scope.all = function (debugElement) {
        var scope = [];
        scope.push(debugElement);
        debugElement.children.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });
        debugElement.componentViewChildren.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });
        return scope;
    };
    Scope.light = function (debugElement) {
        var scope = [];
        debugElement.children.forEach(function (child) {
            scope.push(child);
            scope = scope.concat(Scope.light(child));
        });
        return scope;
    };
    Scope.view = function (debugElement) {
        var scope = [];
        debugElement.componentViewChildren.forEach(function (child) {
            scope.push(child);
            scope = scope.concat(Scope.light(child));
        });
        return scope;
    };
    return Scope;
})();
exports.Scope = Scope;
var By = (function () {
    function By() {
    }
    By.all = function () { return function (debugElement) { return true; }; };
    By.css = function (selector) {
        return function (debugElement) {
            return lang_1.isPresent(debugElement.nativeElement) ?
                dom_adapter_1.DOM.elementMatches(debugElement.nativeElement, selector) :
                false;
        };
    };
    By.directive = function (type) {
        return function (debugElement) { return debugElement.hasDirective(type); };
    };
    return By;
})();
exports.By = By;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element_view_listener.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var view_listener_1 = require('angular2/src/core/linker/view_listener');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var api_1 = require('angular2/src/core/render/api');
var debug_element_1 = require('./debug_element');
var NG_ID_PROPERTY = 'ngid';
var INSPECT_GLOBAL_NAME = 'ng.probe';
var NG_ID_SEPARATOR = '#';
// Need to keep the views in a global Map so that multiple angular apps are supported
var _allIdsByView = new collection_1.Map();
var _allViewsById = new collection_1.Map();
var _nextId = 0;
function _setElementId(element, indices) {
    if (lang_1.isPresent(element)) {
        dom_adapter_1.DOM.setData(element, NG_ID_PROPERTY, indices.join(NG_ID_SEPARATOR));
    }
}
function _getElementId(element) {
    var elId = dom_adapter_1.DOM.getData(element, NG_ID_PROPERTY);
    if (lang_1.isPresent(elId)) {
        return elId.split(NG_ID_SEPARATOR).map(function (partStr) { return lang_1.NumberWrapper.parseInt(partStr, 10); });
    }
    else {
        return null;
    }
}
function inspectNativeElement(element) {
    var elId = _getElementId(element);
    if (lang_1.isPresent(elId)) {
        var view = _allViewsById.get(elId[0]);
        if (lang_1.isPresent(view)) {
            return new debug_element_1.DebugElement_(view, elId[1]);
        }
    }
    return null;
}
exports.inspectNativeElement = inspectNativeElement;
var DebugElementViewListener = (function () {
    function DebugElementViewListener(_renderer) {
        this._renderer = _renderer;
        dom_adapter_1.DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    }
    DebugElementViewListener.prototype.viewCreated = function (view) {
        var viewId = _nextId++;
        _allViewsById.set(viewId, view);
        _allIdsByView.set(view, viewId);
        for (var i = 0; i < view.elementRefs.length; i++) {
            var el = view.elementRefs[i];
            _setElementId(this._renderer.getNativeElementSync(el), [viewId, i]);
        }
    };
    DebugElementViewListener.prototype.viewDestroyed = function (view) {
        var viewId = _allIdsByView.get(view);
        _allIdsByView.delete(view);
        _allViewsById.delete(viewId);
    };
    DebugElementViewListener = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [api_1.Renderer])
    ], DebugElementViewListener);
    return DebugElementViewListener;
})();
exports.DebugElementViewListener = DebugElementViewListener;
exports.ELEMENT_PROBE_PROVIDERS = lang_1.CONST_EXPR([
    DebugElementViewListener,
    lang_1.CONST_EXPR(new di_1.Provider(view_listener_1.AppViewListener, { useExisting: DebugElementViewListener })),
]);
exports.ELEMENT_PROBE_BINDINGS = exports.ELEMENT_PROBE_PROVIDERS;

},{"./debug_element":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/debug/debug_element.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * The `di` module provides dependency injection container services.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var metadata_1 = require('./di/metadata');
exports.InjectMetadata = metadata_1.InjectMetadata;
exports.OptionalMetadata = metadata_1.OptionalMetadata;
exports.InjectableMetadata = metadata_1.InjectableMetadata;
exports.SelfMetadata = metadata_1.SelfMetadata;
exports.HostMetadata = metadata_1.HostMetadata;
exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
exports.DependencyMetadata = metadata_1.DependencyMetadata;
// we have to reexport * because Dart and TS export two different sets of types
__export(require('./di/decorators'));
var forward_ref_1 = require('./di/forward_ref');
exports.forwardRef = forward_ref_1.forwardRef;
exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
var injector_1 = require('./di/injector');
exports.Injector = injector_1.Injector;
var provider_1 = require('./di/provider');
exports.Binding = provider_1.Binding;
exports.ProviderBuilder = provider_1.ProviderBuilder;
exports.ResolvedFactory = provider_1.ResolvedFactory;
exports.Dependency = provider_1.Dependency;
exports.bind = provider_1.bind;
exports.Provider = provider_1.Provider;
exports.provide = provider_1.provide;
var key_1 = require('./di/key');
exports.Key = key_1.Key;
exports.TypeLiteral = key_1.TypeLiteral;
var exceptions_1 = require('./di/exceptions');
exports.NoProviderError = exceptions_1.NoProviderError;
exports.AbstractProviderError = exceptions_1.AbstractProviderError;
exports.CyclicDependencyError = exceptions_1.CyclicDependencyError;
exports.InstantiationError = exceptions_1.InstantiationError;
exports.InvalidProviderError = exceptions_1.InvalidProviderError;
exports.NoAnnotationError = exceptions_1.NoAnnotationError;
exports.OutOfBoundsError = exceptions_1.OutOfBoundsError;
var opaque_token_1 = require('./di/opaque_token');
exports.OpaqueToken = opaque_token_1.OpaqueToken;

},{"./di/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js","./di/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./di/forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./di/injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js","./di/key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","./di/opaque_token":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/opaque_token.js","./di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/decorators.js":[function(require,module,exports){
'use strict';var metadata_1 = require('./metadata');
var decorators_1 = require('../util/decorators');
/**
 * Factory for creating {@link InjectMetadata}.
 */
exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
/**
 * Factory for creating {@link OptionalMetadata}.
 */
exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
/**
 * Factory for creating {@link InjectableMetadata}.
 */
exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
/**
 * Factory for creating {@link SelfMetadata}.
 */
exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
/**
 * Factory for creating {@link HostMetadata}.
 */
exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
/**
 * Factory for creating {@link SkipSelfMetadata}.
 */
exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);

},{"../util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
        if (collection_1.ListWrapper.contains(res, keys[i])) {
            res.push(keys[i]);
            return res;
        }
        else {
            res.push(keys[i]);
        }
    }
    return res;
}
function constructResolvingPath(keys) {
    if (keys.length > 1) {
        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });
        return " (" + tokenStrs.join(' -> ') + ")";
    }
    else {
        return "";
    }
}
/**
 * Base class for all errors arising from misconfigured providers.
 */
var AbstractProviderError = (function (_super) {
    __extends(AbstractProviderError, _super);
    function AbstractProviderError(injector, key, constructResolvingMessage) {
        _super.call(this, "DI Exception");
        this.keys = [key];
        this.injectors = [injector];
        this.constructResolvingMessage = constructResolvingMessage;
        this.message = this.constructResolvingMessage(this.keys);
    }
    AbstractProviderError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
        this.message = this.constructResolvingMessage(this.keys);
    };
    Object.defineProperty(AbstractProviderError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return AbstractProviderError;
})(exceptions_1.BaseException);
exports.AbstractProviderError = AbstractProviderError;
/**
 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
 * {@link Injector} does not have a {@link Provider} for {@link Key}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b:B) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 */
var NoProviderError = (function (_super) {
    __extends(NoProviderError, _super);
    function NoProviderError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
            return "No provider for " + first + "!" + constructResolvingPath(keys);
        });
    }
    return NoProviderError;
})(AbstractProviderError);
exports.NoProviderError = NoProviderError;
/**
 * Thrown when dependencies form a cycle.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
 *
 * ```typescript
 * var injector = Injector.resolveAndCreate([
 *   provide("one", {useFactory: (two) => "two", deps: [[new Inject("two")]]}),
 *   provide("two", {useFactory: (one) => "one", deps: [[new Inject("one")]]})
 * ]);
 *
 * expect(() => injector.get("one")).toThrowError();
 * ```
 *
 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
 */
var CyclicDependencyError = (function (_super) {
    __extends(CyclicDependencyError, _super);
    function CyclicDependencyError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
        });
    }
    return CyclicDependencyError;
})(AbstractProviderError);
exports.CyclicDependencyError = CyclicDependencyError;
/**
 * Thrown when a constructing type returns with an Error.
 *
 * The `InstantiationError` class contains the original error plus the dependency graph which caused
 * this object to be instantiated.
 *
 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor() {
 *     throw new Error('message');
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([A]);

 * try {
 *   injector.get(A);
 * } catch (e) {
 *   expect(e instanceof InstantiationError).toBe(true);
 *   expect(e.originalException.message).toEqual("message");
 *   expect(e.originalStack).toBeDefined();
 * }
 * ```
 */
var InstantiationError = (function (_super) {
    __extends(InstantiationError, _super);
    function InstantiationError(injector, originalException, originalStack, key) {
        _super.call(this, "DI Exception", originalException, originalStack, null);
        this.keys = [key];
        this.injectors = [injector];
    }
    InstantiationError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
    };
    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
        get: function () {
            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "causeKey", {
        get: function () { return this.keys[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return InstantiationError;
})(exceptions_1.WrappedException);
exports.InstantiationError = InstantiationError;
/**
 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
 * creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
 * ```
 */
var InvalidProviderError = (function (_super) {
    __extends(InvalidProviderError, _super);
    function InvalidProviderError(provider) {
        _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " +
            provider.toString());
    }
    return InvalidProviderError;
})(exceptions_1.BaseException);
exports.InvalidProviderError = InvalidProviderError;
/**
 * Thrown when the class has no annotation information.
 *
 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
 * need to be injected into the constructor.
 *
 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 *
 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
 *
 * ```typescript
 * class B {}
 *
 * class A {
 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
 * }
 *
 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
 * ```
 */
var NoAnnotationError = (function (_super) {
    __extends(NoAnnotationError, _super);
    function NoAnnotationError(typeOrFunc, params) {
        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
    }
    NoAnnotationError._genMessage = function (typeOrFunc, params) {
        var signature = [];
        for (var i = 0, ii = params.length; i < ii; i++) {
            var parameter = params[i];
            if (lang_1.isBlank(parameter) || parameter.length == 0) {
                signature.push('?');
            }
            else {
                signature.push(parameter.map(lang_1.stringify).join(' '));
            }
        }
        return "Cannot resolve all parameters for " + lang_1.stringify(typeOrFunc) + "(" +
            signature.join(', ') + "). " + 'Make sure they all have valid type or annotations.';
    };
    return NoAnnotationError;
})(exceptions_1.BaseException);
exports.NoAnnotationError = NoAnnotationError;
/**
 * Thrown when getting an object by index.
 *
 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
 *
 * ```typescript
 * class A {}
 *
 * var injector = Injector.resolveAndCreate([A]);
 *
 * expect(() => injector.getAt(100)).toThrowError();
 * ```
 */
var OutOfBoundsError = (function (_super) {
    __extends(OutOfBoundsError, _super);
    function OutOfBoundsError(index) {
        _super.call(this, "Index " + index + " is out-of-bounds.");
    }
    return OutOfBoundsError;
})(exceptions_1.BaseException);
exports.OutOfBoundsError = OutOfBoundsError;
// TODO: add a working example after alpha38 is released
/**
 * Thrown when a multi provider and a regular provider are bound to the same token.
 *
 * ### Example
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate([
 *   new Provider("Strings", {useValue: "string1", multi: true}),
 *   new Provider("Strings", {useValue: "string2", multi: false})
 * ])).toThrowError();
 * ```
 */
var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
        _super.call(this, "Cannot mix multi providers and regular providers, got: " + provider1.toString() + " " +
            provider2.toString());
    }
    return MixingMultiProvidersWithRegularProvidersError;
})(exceptions_1.BaseException);
exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
 *
 * ```typescript
 * class Door {
 *   lock: Lock;
 *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) {
 *     this.lock = lock;
 *   }
 * }
 *
 * // Only at this point Lock is defined.
 * class Lock {
 * }
 *
 * var injector = Injector.resolveAndCreate([Door, Lock]);
 * var door = injector.get(Door);
 * expect(door instanceof Door).toBe(true);
 * expect(door.lock instanceof Lock).toBe(true);
 * ```
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
    return forwardRefFn;
}
exports.forwardRef = forwardRef;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * ```typescript
 * var ref = forwardRef(() => "refValue");
 * expect(resolveForwardRef(ref)).toEqual("refValue");
 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
 * ```
 *
 * See: {@link forwardRef}
 */
function resolveForwardRef(type) {
    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
        type.__forward_ref__ === forwardRef) {
        return type();
    }
    else {
        return type;
    }
}
exports.resolveForwardRef = resolveForwardRef;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var provider_1 = require('./provider');
var exceptions_1 = require('./exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
var key_1 = require('./key');
var metadata_1 = require('./metadata');
// Threshold for the dynamic version
var _MAX_CONSTRUCTION_COUNTER = 10;
exports.UNDEFINED = lang_1.CONST_EXPR(new Object());
/**
 * Visibility of a {@link Provider}.
 */
(function (Visibility) {
    /**
     * A `Public` {@link Provider} is only visible to regular (as opposed to host) child injectors.
     */
    Visibility[Visibility["Public"] = 0] = "Public";
    /**
     * A `Private` {@link Provider} is only visible to host (as opposed to regular) child injectors.
     */
    Visibility[Visibility["Private"] = 1] = "Private";
    /**
     * A `PublicAndPrivate` {@link Provider} is visible to both host and regular child injectors.
     */
    Visibility[Visibility["PublicAndPrivate"] = 2] = "PublicAndPrivate";
})(exports.Visibility || (exports.Visibility = {}));
var Visibility = exports.Visibility;
function canSee(src, dst) {
    return (src === dst) ||
        (dst === Visibility.PublicAndPrivate || src === Visibility.PublicAndPrivate);
}
var ProtoInjectorInlineStrategy = (function () {
    function ProtoInjectorInlineStrategy(protoEI, bwv) {
        this.provider0 = null;
        this.provider1 = null;
        this.provider2 = null;
        this.provider3 = null;
        this.provider4 = null;
        this.provider5 = null;
        this.provider6 = null;
        this.provider7 = null;
        this.provider8 = null;
        this.provider9 = null;
        this.keyId0 = null;
        this.keyId1 = null;
        this.keyId2 = null;
        this.keyId3 = null;
        this.keyId4 = null;
        this.keyId5 = null;
        this.keyId6 = null;
        this.keyId7 = null;
        this.keyId8 = null;
        this.keyId9 = null;
        this.visibility0 = null;
        this.visibility1 = null;
        this.visibility2 = null;
        this.visibility3 = null;
        this.visibility4 = null;
        this.visibility5 = null;
        this.visibility6 = null;
        this.visibility7 = null;
        this.visibility8 = null;
        this.visibility9 = null;
        var length = bwv.length;
        if (length > 0) {
            this.provider0 = bwv[0].provider;
            this.keyId0 = bwv[0].getKeyId();
            this.visibility0 = bwv[0].visibility;
        }
        if (length > 1) {
            this.provider1 = bwv[1].provider;
            this.keyId1 = bwv[1].getKeyId();
            this.visibility1 = bwv[1].visibility;
        }
        if (length > 2) {
            this.provider2 = bwv[2].provider;
            this.keyId2 = bwv[2].getKeyId();
            this.visibility2 = bwv[2].visibility;
        }
        if (length > 3) {
            this.provider3 = bwv[3].provider;
            this.keyId3 = bwv[3].getKeyId();
            this.visibility3 = bwv[3].visibility;
        }
        if (length > 4) {
            this.provider4 = bwv[4].provider;
            this.keyId4 = bwv[4].getKeyId();
            this.visibility4 = bwv[4].visibility;
        }
        if (length > 5) {
            this.provider5 = bwv[5].provider;
            this.keyId5 = bwv[5].getKeyId();
            this.visibility5 = bwv[5].visibility;
        }
        if (length > 6) {
            this.provider6 = bwv[6].provider;
            this.keyId6 = bwv[6].getKeyId();
            this.visibility6 = bwv[6].visibility;
        }
        if (length > 7) {
            this.provider7 = bwv[7].provider;
            this.keyId7 = bwv[7].getKeyId();
            this.visibility7 = bwv[7].visibility;
        }
        if (length > 8) {
            this.provider8 = bwv[8].provider;
            this.keyId8 = bwv[8].getKeyId();
            this.visibility8 = bwv[8].visibility;
        }
        if (length > 9) {
            this.provider9 = bwv[9].provider;
            this.keyId9 = bwv[9].getKeyId();
            this.visibility9 = bwv[9].visibility;
        }
    }
    ProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
        if (index == 0)
            return this.provider0;
        if (index == 1)
            return this.provider1;
        if (index == 2)
            return this.provider2;
        if (index == 3)
            return this.provider3;
        if (index == 4)
            return this.provider4;
        if (index == 5)
            return this.provider5;
        if (index == 6)
            return this.provider6;
        if (index == 7)
            return this.provider7;
        if (index == 8)
            return this.provider8;
        if (index == 9)
            return this.provider9;
        throw new exceptions_1.OutOfBoundsError(index);
    };
    ProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
        return new InjectorInlineStrategy(injector, this);
    };
    return ProtoInjectorInlineStrategy;
})();
exports.ProtoInjectorInlineStrategy = ProtoInjectorInlineStrategy;
var ProtoInjectorDynamicStrategy = (function () {
    function ProtoInjectorDynamicStrategy(protoInj, bwv) {
        var len = bwv.length;
        this.providers = collection_1.ListWrapper.createFixedSize(len);
        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
        this.visibilities = collection_1.ListWrapper.createFixedSize(len);
        for (var i = 0; i < len; i++) {
            this.providers[i] = bwv[i].provider;
            this.keyIds[i] = bwv[i].getKeyId();
            this.visibilities[i] = bwv[i].visibility;
        }
    }
    ProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
        if (index < 0 || index >= this.providers.length) {
            throw new exceptions_1.OutOfBoundsError(index);
        }
        return this.providers[index];
    };
    ProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
        return new InjectorDynamicStrategy(this, ei);
    };
    return ProtoInjectorDynamicStrategy;
})();
exports.ProtoInjectorDynamicStrategy = ProtoInjectorDynamicStrategy;
var ProtoInjector = (function () {
    function ProtoInjector(bwv) {
        this.numberOfProviders = bwv.length;
        this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ?
            new ProtoInjectorDynamicStrategy(this, bwv) :
            new ProtoInjectorInlineStrategy(this, bwv);
    }
    ProtoInjector.prototype.getProviderAtIndex = function (index) { return this._strategy.getProviderAtIndex(index); };
    return ProtoInjector;
})();
exports.ProtoInjector = ProtoInjector;
var InjectorInlineStrategy = (function () {
    function InjectorInlineStrategy(injector, protoStrategy) {
        this.injector = injector;
        this.protoStrategy = protoStrategy;
        this.obj0 = exports.UNDEFINED;
        this.obj1 = exports.UNDEFINED;
        this.obj2 = exports.UNDEFINED;
        this.obj3 = exports.UNDEFINED;
        this.obj4 = exports.UNDEFINED;
        this.obj5 = exports.UNDEFINED;
        this.obj6 = exports.UNDEFINED;
        this.obj7 = exports.UNDEFINED;
        this.obj8 = exports.UNDEFINED;
        this.obj9 = exports.UNDEFINED;
    }
    InjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    InjectorInlineStrategy.prototype.instantiateProvider = function (provider, visibility) {
        return this.injector._new(provider, visibility);
    };
    InjectorInlineStrategy.prototype.attach = function (parent, isHost) {
        var inj = this.injector;
        inj._parent = parent;
        inj._isHost = isHost;
    };
    InjectorInlineStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
        var p = this.protoStrategy;
        var inj = this.injector;
        if (p.keyId0 === keyId && canSee(p.visibility0, visibility)) {
            if (this.obj0 === exports.UNDEFINED) {
                this.obj0 = inj._new(p.provider0, p.visibility0);
            }
            return this.obj0;
        }
        if (p.keyId1 === keyId && canSee(p.visibility1, visibility)) {
            if (this.obj1 === exports.UNDEFINED) {
                this.obj1 = inj._new(p.provider1, p.visibility1);
            }
            return this.obj1;
        }
        if (p.keyId2 === keyId && canSee(p.visibility2, visibility)) {
            if (this.obj2 === exports.UNDEFINED) {
                this.obj2 = inj._new(p.provider2, p.visibility2);
            }
            return this.obj2;
        }
        if (p.keyId3 === keyId && canSee(p.visibility3, visibility)) {
            if (this.obj3 === exports.UNDEFINED) {
                this.obj3 = inj._new(p.provider3, p.visibility3);
            }
            return this.obj3;
        }
        if (p.keyId4 === keyId && canSee(p.visibility4, visibility)) {
            if (this.obj4 === exports.UNDEFINED) {
                this.obj4 = inj._new(p.provider4, p.visibility4);
            }
            return this.obj4;
        }
        if (p.keyId5 === keyId && canSee(p.visibility5, visibility)) {
            if (this.obj5 === exports.UNDEFINED) {
                this.obj5 = inj._new(p.provider5, p.visibility5);
            }
            return this.obj5;
        }
        if (p.keyId6 === keyId && canSee(p.visibility6, visibility)) {
            if (this.obj6 === exports.UNDEFINED) {
                this.obj6 = inj._new(p.provider6, p.visibility6);
            }
            return this.obj6;
        }
        if (p.keyId7 === keyId && canSee(p.visibility7, visibility)) {
            if (this.obj7 === exports.UNDEFINED) {
                this.obj7 = inj._new(p.provider7, p.visibility7);
            }
            return this.obj7;
        }
        if (p.keyId8 === keyId && canSee(p.visibility8, visibility)) {
            if (this.obj8 === exports.UNDEFINED) {
                this.obj8 = inj._new(p.provider8, p.visibility8);
            }
            return this.obj8;
        }
        if (p.keyId9 === keyId && canSee(p.visibility9, visibility)) {
            if (this.obj9 === exports.UNDEFINED) {
                this.obj9 = inj._new(p.provider9, p.visibility9);
            }
            return this.obj9;
        }
        return exports.UNDEFINED;
    };
    InjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
        if (index == 0)
            return this.obj0;
        if (index == 1)
            return this.obj1;
        if (index == 2)
            return this.obj2;
        if (index == 3)
            return this.obj3;
        if (index == 4)
            return this.obj4;
        if (index == 5)
            return this.obj5;
        if (index == 6)
            return this.obj6;
        if (index == 7)
            return this.obj7;
        if (index == 8)
            return this.obj8;
        if (index == 9)
            return this.obj9;
        throw new exceptions_1.OutOfBoundsError(index);
    };
    InjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
    return InjectorInlineStrategy;
})();
exports.InjectorInlineStrategy = InjectorInlineStrategy;
var InjectorDynamicStrategy = (function () {
    function InjectorDynamicStrategy(protoStrategy, injector) {
        this.protoStrategy = protoStrategy;
        this.injector = injector;
        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
        collection_1.ListWrapper.fill(this.objs, exports.UNDEFINED);
    }
    InjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    InjectorDynamicStrategy.prototype.instantiateProvider = function (provider, visibility) {
        return this.injector._new(provider, visibility);
    };
    InjectorDynamicStrategy.prototype.attach = function (parent, isHost) {
        var inj = this.injector;
        inj._parent = parent;
        inj._isHost = isHost;
    };
    InjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
        var p = this.protoStrategy;
        for (var i = 0; i < p.keyIds.length; i++) {
            if (p.keyIds[i] === keyId && canSee(p.visibilities[i], visibility)) {
                if (this.objs[i] === exports.UNDEFINED) {
                    this.objs[i] = this.injector._new(p.providers[i], p.visibilities[i]);
                }
                return this.objs[i];
            }
        }
        return exports.UNDEFINED;
    };
    InjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
        if (index < 0 || index >= this.objs.length) {
            throw new exceptions_1.OutOfBoundsError(index);
        }
        return this.objs[index];
    };
    InjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
    return InjectorDynamicStrategy;
})();
exports.InjectorDynamicStrategy = InjectorDynamicStrategy;
var ProviderWithVisibility = (function () {
    function ProviderWithVisibility(provider, visibility) {
        this.provider = provider;
        this.visibility = visibility;
    }
    ;
    ProviderWithVisibility.prototype.getKeyId = function () { return this.provider.key.id; };
    return ProviderWithVisibility;
})();
exports.ProviderWithVisibility = ProviderWithVisibility;
/**
 * A dependency injection container used for instantiating objects and resolving dependencies.
 *
 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
 * constructor dependencies.
 *
 * In typical use, application code asks for the dependencies in the constructor and they are
 * resolved by the `Injector`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
 *
 * The following example creates an `Injector` configured to create `Engine` and `Car`.
 *
 * ```typescript
 * @Injectable()
 * class Engine {
 * }
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine:Engine) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([Car, Engine]);
 * var car = injector.get(Car);
 * expect(car instanceof Car).toBe(true);
 * expect(car.engine instanceof Engine).toBe(true);
 * ```
 *
 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
 * resolve all of the object's dependencies automatically.
 */
var Injector = (function () {
    /**
     * Private
     */
    function Injector(_proto /* ProtoInjector */, _parent, _depProvider, _debugContext) {
        if (_parent === void 0) { _parent = null; }
        if (_depProvider === void 0) { _depProvider = null; }
        if (_debugContext === void 0) { _debugContext = null; }
        this._depProvider = _depProvider;
        this._debugContext = _debugContext;
        /** @internal */
        this._isHost = false;
        /** @internal */
        this._constructionCounter = 0;
        this._proto = _proto;
        this._parent = _parent;
        this._strategy = _proto._strategy.createInjectorStrategy(this);
    }
    /**
     * Turns an array of provider definitions into an array of resolved providers.
     *
     * A resolution is a process of flattening multiple nested arrays and converting individual
     * providers into an array of {@link ResolvedProvider}s.
     *
     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = Injector.resolve([Car, [[Engine]]]);
     *
     * expect(providers.length).toEqual(2);
     *
     * expect(providers[0] instanceof ResolvedProvider).toBe(true);
     * expect(providers[0].key.displayName).toBe("Car");
     * expect(providers[0].dependencies.length).toEqual(1);
     * expect(providers[0].factory).toBeDefined();
     *
     * expect(providers[1].key.displayName).toBe("Engine");
     * });
     * ```
     *
     * See {@link Injector#fromResolvedProviders} for more info.
     */
    Injector.resolve = function (providers) {
        return provider_1.resolveProviders(providers);
    };
    /**
     * Resolves an array of providers and creates an injector from those providers.
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Car, Engine]);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     *
     * This function is slower than the corresponding `fromResolvedProviders`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
     */
    Injector.resolveAndCreate = function (providers) {
        var resolvedProviders = Injector.resolve(providers);
        return Injector.fromResolvedProviders(resolvedProviders);
    };
    /**
     * Creates an injector from previously resolved providers.
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = Injector.resolve([Car, Engine]);
     * var injector = Injector.fromResolvedProviders(providers);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     */
    Injector.fromResolvedProviders = function (providers) {
        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });
        var proto = new ProtoInjector(bd);
        return new Injector(proto, null, null);
    };
    /**
     * @deprecated
     */
    Injector.fromResolvedBindings = function (providers) {
        return Injector.fromResolvedProviders(providers);
    };
    /**
     * @internal
     */
    Injector.prototype.debugContext = function () { return this._debugContext(); };
    /**
     * Retrieves an instance from the injector based on the provided token.
     * Throws {@link NoProviderError} if not found.
     *
     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide("validToken", {useValue: "Value"})
     * ]);
     * expect(injector.get("validToken")).toEqual("Value");
     * expect(() => injector.get("invalidToken")).toThrowError();
     * ```
     *
     * `Injector` returns itself when given `Injector` as a token.
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([]);
     * expect(injector.get(Injector)).toBe(injector);
     * ```
     */
    Injector.prototype.get = function (token) {
        return this._getByKey(key_1.Key.get(token), null, null, false, Visibility.PublicAndPrivate);
    };
    /**
     * Retrieves an instance from the injector based on the provided token.
     * Returns null if not found.
     *
     * ### Example ([live demo](http://plnkr.co/edit/tpEbEy?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide("validToken", {useValue: "Value"})
     * ]);
     * expect(injector.getOptional("validToken")).toEqual("Value");
     * expect(injector.getOptional("invalidToken")).toBe(null);
     * ```
     *
     * `Injector` returns itself when given `Injector` as a token.
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([]);
     * expect(injector.getOptional(Injector)).toBe(injector);
     * ```
     */
    Injector.prototype.getOptional = function (token) {
        return this._getByKey(key_1.Key.get(token), null, null, true, Visibility.PublicAndPrivate);
    };
    /**
     * @internal
     */
    Injector.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
    Object.defineProperty(Injector.prototype, "parent", {
        /**
         * Parent of this injector.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
         *
         * ```typescript
         * var parent = Injector.resolveAndCreate([]);
         * var child = parent.resolveAndCreateChild([]);
         * expect(child.parent).toBe(parent);
         * ```
         */
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Injector.prototype, "internalStrategy", {
        /**
         * @internal
         * Internal. Do not use.
         * We return `any` not to export the InjectorStrategy type.
         */
        get: function () { return this._strategy; },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolves an array of providers and creates a child injector from those providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parent = Injector.resolveAndCreate([ParentProvider]);
     * var child = parent.resolveAndCreateChild([ChildProvider]);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     *
     * This function is slower than the corresponding `createChildFromResolved`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
     */
    Injector.prototype.resolveAndCreateChild = function (providers) {
        var resolvedProviders = Injector.resolve(providers);
        return this.createChildFromResolved(resolvedProviders);
    };
    /**
     * Creates a child injector from previously resolved providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parentProviders = Injector.resolve([ParentProvider]);
     * var childProviders = Injector.resolve([ChildProvider]);
     *
     * var parent = Injector.fromResolvedProviders(parentProviders);
     * var child = parent.createChildFromResolved(childProviders);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     */
    Injector.prototype.createChildFromResolved = function (providers) {
        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });
        var proto = new ProtoInjector(bd);
        var inj = new Injector(proto, null, null);
        inj._parent = this;
        return inj;
    };
    /**
     * Resolves a provider and instantiates an object in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Engine]);
     *
     * var car = injector.resolveAndInstantiate(Car);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
     * ```
     */
    Injector.prototype.resolveAndInstantiate = function (provider) {
        return this.instantiateResolved(Injector.resolve([provider])[0]);
    };
    /**
     * Instantiates an object using a resolved provider in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = Injector.resolveAndCreate([Engine]);
     * var carProvider = Injector.resolve([Car])[0];
     * var car = injector.instantiateResolved(carProvider);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
     * ```
     */
    Injector.prototype.instantiateResolved = function (provider) {
        return this._instantiateProvider(provider, Visibility.PublicAndPrivate);
    };
    /** @internal */
    Injector.prototype._new = function (provider, visibility) {
        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
            throw new exceptions_1.CyclicDependencyError(this, provider.key);
        }
        return this._instantiateProvider(provider, visibility);
    };
    Injector.prototype._instantiateProvider = function (provider, visibility) {
        if (provider.multiProvider) {
            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
            for (var i = 0; i < provider.resolvedFactories.length; ++i) {
                res[i] = this._instantiate(provider, provider.resolvedFactories[i], visibility);
            }
            return res;
        }
        else {
            return this._instantiate(provider, provider.resolvedFactories[0], visibility);
        }
    };
    Injector.prototype._instantiate = function (provider, resolvedFactory, visibility) {
        var factory = resolvedFactory.factory;
        var deps = resolvedFactory.dependencies;
        var length = deps.length;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19;
        try {
            d0 = length > 0 ? this._getByDependency(provider, deps[0], visibility) : null;
            d1 = length > 1 ? this._getByDependency(provider, deps[1], visibility) : null;
            d2 = length > 2 ? this._getByDependency(provider, deps[2], visibility) : null;
            d3 = length > 3 ? this._getByDependency(provider, deps[3], visibility) : null;
            d4 = length > 4 ? this._getByDependency(provider, deps[4], visibility) : null;
            d5 = length > 5 ? this._getByDependency(provider, deps[5], visibility) : null;
            d6 = length > 6 ? this._getByDependency(provider, deps[6], visibility) : null;
            d7 = length > 7 ? this._getByDependency(provider, deps[7], visibility) : null;
            d8 = length > 8 ? this._getByDependency(provider, deps[8], visibility) : null;
            d9 = length > 9 ? this._getByDependency(provider, deps[9], visibility) : null;
            d10 = length > 10 ? this._getByDependency(provider, deps[10], visibility) : null;
            d11 = length > 11 ? this._getByDependency(provider, deps[11], visibility) : null;
            d12 = length > 12 ? this._getByDependency(provider, deps[12], visibility) : null;
            d13 = length > 13 ? this._getByDependency(provider, deps[13], visibility) : null;
            d14 = length > 14 ? this._getByDependency(provider, deps[14], visibility) : null;
            d15 = length > 15 ? this._getByDependency(provider, deps[15], visibility) : null;
            d16 = length > 16 ? this._getByDependency(provider, deps[16], visibility) : null;
            d17 = length > 17 ? this._getByDependency(provider, deps[17], visibility) : null;
            d18 = length > 18 ? this._getByDependency(provider, deps[18], visibility) : null;
            d19 = length > 19 ? this._getByDependency(provider, deps[19], visibility) : null;
        }
        catch (e) {
            if (e instanceof exceptions_1.AbstractProviderError || e instanceof exceptions_1.InstantiationError) {
                e.addKey(this, provider.key);
            }
            throw e;
        }
        var obj;
        try {
            switch (length) {
                case 0:
                    obj = factory();
                    break;
                case 1:
                    obj = factory(d0);
                    break;
                case 2:
                    obj = factory(d0, d1);
                    break;
                case 3:
                    obj = factory(d0, d1, d2);
                    break;
                case 4:
                    obj = factory(d0, d1, d2, d3);
                    break;
                case 5:
                    obj = factory(d0, d1, d2, d3, d4);
                    break;
                case 6:
                    obj = factory(d0, d1, d2, d3, d4, d5);
                    break;
                case 7:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
                    break;
                case 8:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                    break;
                case 9:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                    break;
                case 10:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                    break;
                case 11:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                    break;
                case 12:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                    break;
                case 13:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                    break;
                case 14:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                    break;
                case 15:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                    break;
                case 16:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                    break;
                case 17:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                    break;
                case 18:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                    break;
                case 19:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                    break;
                case 20:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                    break;
            }
        }
        catch (e) {
            throw new exceptions_1.InstantiationError(this, e, e.stack, provider.key);
        }
        return obj;
    };
    Injector.prototype._getByDependency = function (provider, dep, providerVisibility) {
        var special = lang_1.isPresent(this._depProvider) ?
            this._depProvider.getDependency(this, provider, dep) :
            exports.UNDEFINED;
        if (special !== exports.UNDEFINED) {
            return special;
        }
        else {
            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional, providerVisibility);
        }
    };
    Injector.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, optional, providerVisibility) {
        if (key === INJECTOR_KEY) {
            return this;
        }
        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
            return this._getByKeySelf(key, optional, providerVisibility);
        }
        else if (upperBoundVisibility instanceof metadata_1.HostMetadata) {
            return this._getByKeyHost(key, optional, providerVisibility, lowerBoundVisibility);
        }
        else {
            return this._getByKeyDefault(key, optional, providerVisibility, lowerBoundVisibility);
        }
    };
    /** @internal */
    Injector.prototype._throwOrNull = function (key, optional) {
        if (optional) {
            return null;
        }
        else {
            throw new exceptions_1.NoProviderError(this, key);
        }
    };
    /** @internal */
    Injector.prototype._getByKeySelf = function (key, optional, providerVisibility) {
        var obj = this._strategy.getObjByKeyId(key.id, providerVisibility);
        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getByKeyHost = function (key, optional, providerVisibility, lowerBoundVisibility) {
        var inj = this;
        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
            if (inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
            }
            else {
                inj = inj._parent;
            }
        }
        while (inj != null) {
            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
            if (obj !== exports.UNDEFINED)
                return obj;
            if (lang_1.isPresent(inj._parent) && inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
            }
            else {
                inj = inj._parent;
            }
        }
        return this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getPrivateDependency = function (key, optional, inj) {
        var obj = inj._parent._strategy.getObjByKeyId(key.id, Visibility.Private);
        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
    };
    /** @internal */
    Injector.prototype._getByKeyDefault = function (key, optional, providerVisibility, lowerBoundVisibility) {
        var inj = this;
        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
            providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
            inj = inj._parent;
        }
        while (inj != null) {
            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
            if (obj !== exports.UNDEFINED)
                return obj;
            providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
            inj = inj._parent;
        }
        return this._throwOrNull(key, optional);
    };
    Object.defineProperty(Injector.prototype, "displayName", {
        get: function () {
            return "Injector(providers: [" + _mapProviders(this, function (b) { return (" \"" + b.key.displayName + "\" "); }).join(", ") + "])";
        },
        enumerable: true,
        configurable: true
    });
    Injector.prototype.toString = function () { return this.displayName; };
    return Injector;
})();
exports.Injector = Injector;
var INJECTOR_KEY = key_1.Key.get(Injector);
function _mapProviders(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
        res.push(fn(injector._proto.getProviderAtIndex(i)));
    }
    return res;
}

},{"./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","./provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var type_literal_1 = require('./type_literal');
var forward_ref_1 = require('./forward_ref');
var type_literal_2 = require('./type_literal');
exports.TypeLiteral = type_literal_2.TypeLiteral;
/**
 * A unique object used for retrieving items from the {@link Injector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link Injector} because its system-wide unique `id` allows the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link Injector} creates keys automatically when resolving
 * providers.
 */
var Key = (function () {
    /**
     * Private
     */
    function Key(token, id) {
        this.token = token;
        this.id = id;
        if (lang_1.isBlank(token)) {
            throw new exceptions_1.BaseException('Token must be defined!');
        }
    }
    Object.defineProperty(Key.prototype, "displayName", {
        /**
         * Returns a stringified token.
         */
        get: function () { return lang_1.stringify(this.token); },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves a `Key` for a token.
     */
    Key.get = function (token) { return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token)); };
    Object.defineProperty(Key, "numberOfKeys", {
        /**
         * @returns the number of keys registered in the system.
         */
        get: function () { return _globalKeyRegistry.numberOfKeys; },
        enumerable: true,
        configurable: true
    });
    return Key;
})();
exports.Key = Key;
/**
 * @internal
 */
var KeyRegistry = (function () {
    function KeyRegistry() {
        this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function (token) {
        if (token instanceof Key)
            return token;
        // TODO: workaround for https://github.com/Microsoft/TypeScript/issues/3123
        var theToken = token;
        if (token instanceof type_literal_1.TypeLiteral) {
            theToken = token.type;
        }
        token = theToken;
        if (this._allKeys.has(token)) {
            return this._allKeys.get(token);
        }
        var newKey = new Key(token, Key.numberOfKeys);
        this._allKeys.set(token, newKey);
        return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
        get: function () { return this._allKeys.size; },
        enumerable: true,
        configurable: true
    });
    return KeyRegistry;
})();
exports.KeyRegistry = KeyRegistry;
var _globalKeyRegistry = new KeyRegistry();

},{"./forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./type_literal":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/type_literal.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require("angular2/src/core/facade/lang");
/**
 * A parameter metadata that specifies a dependency.
 *
 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Inject("MyEngine") engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([
 *  provide("MyEngine", {useClass: Engine}),
 *  Car
 * ]);
 *
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 *
 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
 *
 * ### Example
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
 * }
 *
 * var injector = Injector.resolveAndCreate([Engine, Car]);
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 */
var InjectMetadata = (function () {
    function InjectMetadata(token) {
        this.token = token;
    }
    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
    InjectMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], InjectMetadata);
    return InjectMetadata;
})();
exports.InjectMetadata = InjectMetadata;
/**
 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
 * the dependency is not found.
 *
 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Optional() engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([Car]);
 * expect(injector.get(Car).engine).toBeNull();
 * ```
 */
var OptionalMetadata = (function () {
    function OptionalMetadata() {
    }
    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
    OptionalMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], OptionalMetadata);
    return OptionalMetadata;
})();
exports.OptionalMetadata = OptionalMetadata;
/**
 * `DependencyMetadata` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
var DependencyMetadata = (function () {
    function DependencyMetadata() {
    }
    Object.defineProperty(DependencyMetadata.prototype, "token", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    DependencyMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], DependencyMetadata);
    return DependencyMetadata;
})();
exports.DependencyMetadata = DependencyMetadata;
/**
 * A marker metadata that marks a class as available to {@link Injector} for creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
 *
 * ```typescript
 * @Injectable()
 * class UsefulService {}
 *
 * @Injectable()
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
 * ```
 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
 * does not have `@Injectable` marker, as shown in the example below.
 *
 * ```typescript
 * class UsefulService {}
 *
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(() => injector.get(NeedsService)).toThrowError();
 * ```
 */
var InjectableMetadata = (function () {
    function InjectableMetadata() {
    }
    InjectableMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], InjectableMetadata);
    return InjectableMetadata;
})();
exports.InjectableMetadata = InjectableMetadata;
/**
 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
 *
 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;

 *   dependency;
 *   constructor(@Self() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * var nd = inj.get(NeedsDependency);
 *
 * expect(nd.dependency instanceof Dependency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency]);
 * var child = inj.resolveAndCreateChild([NeedsDependency]);
 * expect(() => child.get(NeedsDependency)).toThrowError();
 * ```
 */
var SelfMetadata = (function () {
    function SelfMetadata() {
    }
    SelfMetadata.prototype.toString = function () { return "@Self()"; };
    SelfMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], SelfMetadata);
    return SelfMetadata;
})();
exports.SelfMetadata = SelfMetadata;
/**
 * Specifies that the dependency resolution should start from the parent injector.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@SkipSelf() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var parent = Injector.resolveAndCreate([Dependency]);
 * var child = parent.resolveAndCreateChild([NeedsDependency]);
 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * expect(() => inj.get(NeedsDependency)).toThrowError();
 * ```
 */
var SkipSelfMetadata = (function () {
    function SkipSelfMetadata() {
    }
    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
    SkipSelfMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], SkipSelfMetadata);
    return SkipSelfMetadata;
})();
exports.SkipSelfMetadata = SkipSelfMetadata;
/**
 * Specifies that an injector should retrieve a dependency from any injector until reaching the
 * closest host.
 *
 * In Angular, a component element is automatically declared as a host for all the injectors in
 * its view.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
 *
 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
 * So `ParentCmp` is the host of `ChildDirective`.
 *
 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
 *
 *```typescript
 * class OtherService {}
 * class HostService {}
 *
 * @Directive({
 *   selector: 'child-directive'
 * })
 * class ChildDirective {
 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
 *     console.log("os is null", os);
 *     console.log("hs is NOT null", hs);
 *   }
 * }
 *
 * @Component({
 *   selector: 'parent-cmp',
 *   providers: [HostService],
 *   template: `
 *     Dir: <child-directive></child-directive>
 *   `,
 *   directives: [ChildDirective]
 * })
 * class ParentCmp {
 * }
 *
 * @Component({
 *   selector: 'app',
 *   providers: [OtherService],
 *   template: `
 *     Parent: <parent-cmp></parent-cmp>
 *   `,
 *   directives: [ParentCmp]
 * })
 * class App {
 * }
 *
 * bootstrap(App);
 *```
 */
var HostMetadata = (function () {
    function HostMetadata() {
    }
    HostMetadata.prototype.toString = function () { return "@Host()"; };
    HostMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], HostMetadata);
    return HostMetadata;
})();
exports.HostMetadata = HostMetadata;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/opaque_token.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Creates a token that can be used in a DI Provider.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
 *
 * ```typescript
 * var t = new OpaqueToken("value");
 *
 * var injector = Injector.resolveAndCreate([
 *   provide(t, {useValue: "providedValue"})
 * ]);
 *
 * expect(injector.get(t)).toEqual("bindingValue");
 * ```
 *
 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
 * caused by multiple providers using the same string as two different tokens.
 *
 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
 * error messages.
 */
var OpaqueToken = (function () {
    function OpaqueToken(_desc) {
        this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
    OpaqueToken = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], OpaqueToken);
    return OpaqueToken;
})();
exports.OpaqueToken = OpaqueToken;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var key_1 = require('./key');
var metadata_1 = require('./metadata');
var exceptions_2 = require('./exceptions');
var forward_ref_1 = require('./forward_ref');
var Dependency = (function () {
    function Dependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
        this.key = key;
        this.optional = optional;
        this.lowerBoundVisibility = lowerBoundVisibility;
        this.upperBoundVisibility = upperBoundVisibility;
        this.properties = properties;
    }
    Dependency.fromKey = function (key) { return new Dependency(key, false, null, null, []); };
    return Dependency;
})();
exports.Dependency = Dependency;
var _EMPTY_LIST = lang_1.CONST_EXPR([]);
/**
 * Describes how the {@link Injector} should instantiate a given token.
 *
 * See {@link provide}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
 *
 * ```javascript
 * var injector = Injector.resolveAndCreate([
 *   new Provider("message", { useValue: 'Hello' })
 * ]);
 *
 * expect(injector.get("message")).toEqual('Hello');
 * ```
 */
var Provider = (function () {
    function Provider(token, _a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        this.token = token;
        this.useClass = useClass;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory;
        this.dependencies = deps;
        this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
        // TODO: Provide a full working example after alpha38 is released.
        /**
         * Creates multiple providers matching the same token (a multi-provider).
         *
         * Multi-providers are used for creating pluggable service, where the system comes
         * with some default providers, and the user can register additonal providers.
         * The combination of the default providers and the additional providers will be
         * used to drive the behavior of the system.
         *
         * ### Example
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true}),
         *   new Provider("Strings", { useValue: "String2", multi: true})
         * ]);
         *
         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
         * ```
         *
         * Multi-providers and regular providers cannot be mixed. The following
         * will throw an exception:
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true }),
         *   new Provider("Strings", { useValue: "String2"})
         * ]);
         * ```
         */
        get: function () { return lang_1.normalizeBool(this._multi); },
        enumerable: true,
        configurable: true
    });
    Provider = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], Provider);
    return Provider;
})();
exports.Provider = Provider;
/**
 * @deprecated
 */
var Binding = (function (_super) {
    __extends(Binding, _super);
    function Binding(token, _a) {
        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
        _super.call(this, token, {
            useClass: toClass,
            useValue: toValue,
            useExisting: toAlias,
            useFactory: toFactory,
            deps: deps,
            multi: multi
        });
    }
    Object.defineProperty(Binding.prototype, "toClass", {
        /**
         * @deprecated
         */
        get: function () { return this.useClass; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toAlias", {
        /**
         * @deprecated
         */
        get: function () { return this.useExisting; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toFactory", {
        /**
         * @deprecated
         */
        get: function () { return this.useFactory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toValue", {
        /**
         * @deprecated
         */
        get: function () { return this.useValue; },
        enumerable: true,
        configurable: true
    });
    Binding = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], Binding);
    return Binding;
})(Provider);
exports.Binding = Binding;
var ResolvedProvider_ = (function () {
    function ResolvedProvider_(key, resolvedFactories, multiProvider) {
        this.key = key;
        this.resolvedFactories = resolvedFactories;
        this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedProvider_.prototype, "resolvedFactory", {
        get: function () { return this.resolvedFactories[0]; },
        enumerable: true,
        configurable: true
    });
    return ResolvedProvider_;
})();
exports.ResolvedProvider_ = ResolvedProvider_;
/**
 * An internal resolved representation of a factory function created by resolving {@link Provider}.
 */
var ResolvedFactory = (function () {
    function ResolvedFactory(
        /**
         * Factory function which can return an instance of an object represented by a key.
         */
        factory, 
        /**
         * Arguments (dependencies) to the `factory` function.
         */
        dependencies) {
        this.factory = factory;
        this.dependencies = dependencies;
    }
    return ResolvedFactory;
})();
exports.ResolvedFactory = ResolvedFactory;
/**
 * @deprecated
 * Creates a {@link Provider}.
 *
 * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,
 * or
 * to an existing `token`.
 * See {@link ProviderBuilder} for more details.
 *
 * The `token` is most commonly a class or {@link angular2/di/OpaqueToken}.
 */
function bind(token) {
    return new ProviderBuilder(token);
}
exports.bind = bind;
/**
 * Creates a {@link Provider}.
 *
 * See {@link Provider} for more details.
 *
 * <!-- TODO: improve the docs -->
 */
function provide(token, _a) {
    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
    return new Provider(token, {
        useClass: useClass,
        useValue: useValue,
        useExisting: useExisting,
        useFactory: useFactory,
        deps: deps,
        multi: multi
    });
}
exports.provide = provide;
/**
 * Helper class for the {@link bind} function.
 */
var ProviderBuilder = (function () {
    function ProviderBuilder(token) {
        this.token = token;
    }
    /**
     * Binds a DI token to a class.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
     * easy comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toClass = function (type) {
        if (!lang_1.isType(type)) {
            throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
        }
        return new Provider(this.token, { useClass: type });
    };
    /**
     * Binds a DI token to a value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide('message', {useValue: 'Hello'})
     * ]);
     *
     * expect(injector.get('message')).toEqual('Hello');
     * ```
     */
    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };
    /**
     * Binds a DI token to an existing token.
     *
     * Angular will return the same instance as if the provided token was used. (This is
     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
     *
     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
     * easy
     * comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toAlias = function (aliasToken) {
        if (lang_1.isBlank(aliasToken)) {
            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
        }
        return new Provider(this.token, { useExisting: aliasToken });
    };
    /**
     * Binds a DI token to a function which computes the value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide(Number, {useFactory: () => { return 1+2; }}),
     *   provide(String, {useFactory: (v) => { return "Value: " + v; }, deps: [Number]})
     * ]);
     *
     * expect(injector.get(Number)).toEqual(3);
     * expect(injector.get(String)).toEqual('Value: 3');
     * ```
     */
    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {
        if (!lang_1.isFunction(factory)) {
            throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
        }
        return new Provider(this.token, { useFactory: factory, deps: dependencies });
    };
    return ProviderBuilder;
})();
exports.ProviderBuilder = ProviderBuilder;
/**
 * Resolve a single provider.
 */
function resolveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (lang_1.isPresent(provider.useClass)) {
        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
        factoryFn = reflection_1.reflector.factory(useClass);
        resolvedDeps = _dependenciesFor(useClass);
    }
    else if (lang_1.isPresent(provider.useExisting)) {
        factoryFn = function (aliasInstance) { return aliasInstance; };
        resolvedDeps = [Dependency.fromKey(key_1.Key.get(provider.useExisting))];
    }
    else if (lang_1.isPresent(provider.useFactory)) {
        factoryFn = provider.useFactory;
        resolvedDeps = _constructDependencies(provider.useFactory, provider.dependencies);
    }
    else {
        factoryFn = function () { return provider.useValue; };
        resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedFactory(factoryFn, resolvedDeps);
}
exports.resolveFactory = resolveFactory;
/**
 * Converts the {@link Provider} into {@link ResolvedProvider}.
 *
 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
 * convenience provider syntax.
 */
function resolveProvider(provider) {
    return new ResolvedProvider_(key_1.Key.get(provider.token), [resolveFactory(provider)], false);
}
exports.resolveProvider = resolveProvider;
/**
 * Resolve a list of Providers.
 */
function resolveProviders(providers) {
    var normalized = _createListOfProviders(_normalizeProviders(providers, new Map()));
    return normalized.map(function (b) {
        if (b instanceof _NormalizedProvider) {
            return new ResolvedProvider_(b.key, [b.resolvedFactory], false);
        }
        else {
            var arr = b;
            return new ResolvedProvider_(arr[0].key, arr.map(function (_) { return _.resolvedFactory; }), true);
        }
    });
}
exports.resolveProviders = resolveProviders;
/**
 * The algorithm works as follows:
 *
 * [Provider] -> [_NormalizedProvider|[_NormalizedProvider]] -> [ResolvedProvider]
 *
 * _NormalizedProvider is essentially a resolved provider before it was grouped by key.
 */
var _NormalizedProvider = (function () {
    function _NormalizedProvider(key, resolvedFactory) {
        this.key = key;
        this.resolvedFactory = resolvedFactory;
    }
    return _NormalizedProvider;
})();
function _createListOfProviders(flattenedProviders) {
    return collection_1.MapWrapper.values(flattenedProviders);
}
function _normalizeProviders(providers, res) {
    providers.forEach(function (b) {
        if (b instanceof lang_1.Type) {
            _normalizeProvider(provide(b, { useClass: b }), res);
        }
        else if (b instanceof Provider) {
            _normalizeProvider(b, res);
        }
        else if (b instanceof Array) {
            _normalizeProviders(b, res);
        }
        else if (b instanceof ProviderBuilder) {
            throw new exceptions_2.InvalidProviderError(b.token);
        }
        else {
            throw new exceptions_2.InvalidProviderError(b);
        }
    });
    return res;
}
function _normalizeProvider(b, res) {
    var key = key_1.Key.get(b.token);
    var factory = resolveFactory(b);
    var normalized = new _NormalizedProvider(key, factory);
    if (b.multi) {
        var existingProvider = res.get(key.id);
        if (existingProvider instanceof Array) {
            existingProvider.push(normalized);
        }
        else if (lang_1.isBlank(existingProvider)) {
            res.set(key.id, [normalized]);
        }
        else {
            throw new exceptions_2.MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
        }
    }
    else {
        var existingProvider = res.get(key.id);
        if (existingProvider instanceof Array) {
            throw new exceptions_2.MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
        }
        res.set(key.id, normalized);
    }
}
function _constructDependencies(factoryFunction, dependencies) {
    if (lang_1.isBlank(dependencies)) {
        return _dependenciesFor(factoryFunction);
    }
    else {
        var params = dependencies.map(function (t) { return [t]; });
        return dependencies.map(function (t) { return _extractToken(factoryFunction, t, params); });
    }
}
function _dependenciesFor(typeOrFunc) {
    var params = reflection_1.reflector.parameters(typeOrFunc);
    if (lang_1.isBlank(params))
        return [];
    if (collection_1.ListWrapper.any(params, function (p) { return lang_1.isBlank(p); })) {
        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
    }
    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
}
function _extractToken(typeOrFunc, metadata /*any[] | any*/, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!lang_1.isArray(metadata)) {
        return _createDependency(metadata, optional, null, null, depProps);
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
        var paramMetadata = metadata[i];
        if (paramMetadata instanceof lang_1.Type) {
            token = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
            token = paramMetadata.token;
        }
        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
            optional = true;
        }
        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.HostMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
            lowerBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
            if (lang_1.isPresent(paramMetadata.token)) {
                token = paramMetadata.token;
            }
            depProps.push(paramMetadata);
        }
    }
    token = forward_ref_1.resolveForwardRef(token);
    if (lang_1.isPresent(token)) {
        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }
    else {
        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
    }
}
function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new Dependency(key_1.Key.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
}

},{"./exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/exceptions.js","./forward_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/forward_ref.js","./key":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/key.js","./metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/type_literal.js":[function(require,module,exports){
'use strict';/**
 * Type literals is a Dart-only feature. This is here only so we can x-compile
 * to multiple languages.
 */
var TypeLiteral = (function () {
    function TypeLiteral() {
    }
    Object.defineProperty(TypeLiteral.prototype, "type", {
        get: function () { throw new Error("Type literals are only supported in Dart"); },
        enumerable: true,
        configurable: true
    });
    return TypeLiteral;
})();
exports.TypeLiteral = TypeLiteral;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * Common directives shipped with Angular.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var lang_1 = require('./facade/lang');
var ng_class_1 = require('./directives/ng_class');
var ng_for_1 = require('./directives/ng_for');
var ng_if_1 = require('./directives/ng_if');
var ng_style_1 = require('./directives/ng_style');
var ng_switch_1 = require('./directives/ng_switch');
var ng_class_2 = require('./directives/ng_class');
exports.NgClass = ng_class_2.NgClass;
var ng_for_2 = require('./directives/ng_for');
exports.NgFor = ng_for_2.NgFor;
var ng_if_2 = require('./directives/ng_if');
exports.NgIf = ng_if_2.NgIf;
var ng_style_2 = require('./directives/ng_style');
exports.NgStyle = ng_style_2.NgStyle;
var ng_switch_2 = require('./directives/ng_switch');
exports.NgSwitch = ng_switch_2.NgSwitch;
exports.NgSwitchWhen = ng_switch_2.NgSwitchWhen;
exports.NgSwitchDefault = ng_switch_2.NgSwitchDefault;
__export(require('./directives/observable_list_diff'));
/**
 * A collection of Angular core directives that are likely to be used in each and every Angular
 * application.
 *
 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
 * property of the `@View` annotation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
 *
 * Instead of writing:
 *
 * ```typescript
 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 * one could import all the core directives at once:
 *
 * ```typescript
 * import {CORE_DIRECTIVES} from 'angular2/angular2';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [CORE_DIRECTIVES, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 */
exports.CORE_DIRECTIVES = lang_1.CONST_EXPR([ng_class_1.NgClass, ng_for_1.NgFor, ng_if_1.NgIf, ng_style_1.NgStyle, ng_switch_1.NgSwitch, ng_switch_1.NgSwitchWhen, ng_switch_1.NgSwitchDefault]);

},{"./directives/ng_class":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_class.js","./directives/ng_for":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_for.js","./directives/ng_if":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_if.js","./directives/ng_style":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_style.js","./directives/ng_switch":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_switch.js","./directives/observable_list_diff":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/observable_list_diff.js","./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_class.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var change_detection_1 = require('angular2/src/core/change_detection');
var render_1 = require('angular2/src/core/render');
var collection_1 = require('angular2/src/core/facade/collection');
/**
 * The `NgClass` directive conditionally adds and removes CSS classes on an HTML element based on
 * an expression's evaluation result.
 *
 * The result of an expression evaluation is interpreted differently depending on type of
 * the expression evaluation result:
 * - `string` - all the CSS classes listed in a string (space delimited) are added
 * - `Array` - all the CSS classes (Array elements) are added
 * - `Object` - each key corresponds to a CSS class name while values are interpreted as expressions
 * evaluating to `Boolean`. If a given expression evaluates to `true` a corresponding CSS class
 * is added - otherwise it is removed.
 *
 * While the `NgClass` directive can interpret expressions evaluating to `string`, `Array`
 * or `Object`, the `Object`-based version is the most often used and has an advantage of keeping
 * all the CSS class names in a template.
 *
 * ### Example ([live demo](http://plnkr.co/edit/a4YdtmWywhJ33uqfpPPn?p=preview)):
 *
 * ```
 * import {Component, NgClass} from 'angular2/angular2';
 *
 * @Component({
 *   selector: 'toggle-button',
 *   inputs: ['isDisabled'],
 *   template: `
 *      <div class="button" [ng-class]="{active: isOn, disabled: isDisabled}"
 *          (click)="toggle(!isOn)">
 *          Click me!
 *      </div>`,
 *   styles: [`
 *     .button {
 *       width: 120px;
 *       border: medium solid black;
 *     }
 *
 *     .active {
 *       background-color: red;
 *    }
 *
 *     .disabled {
 *       color: gray;
 *       border: medium solid gray;
 *     }
 *   `]
 *   directives: [NgClass]
 * })
 * class ToggleButton {
 *   isOn = false;
 *   isDisabled = false;
 *
 *   toggle(newState) {
 *     if (!this.isDisabled) {
 *       this.isOn = newState;
 *     }
 *   }
 * }
 * ```
 */
var NgClass = (function () {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "initialClasses", {
        set: function (v) {
            this._applyInitialClasses(true);
            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
            this._applyInitialClasses(false);
            this._applyClasses(this._rawClass, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgClass.prototype, "rawClass", {
        set: function (v) {
            this._cleanupClasses(this._rawClass);
            if (lang_1.isString(v)) {
                v = v.split(' ');
            }
            this._rawClass = v;
            if (lang_1.isPresent(v)) {
                if (collection_1.isListLikeIterable(v)) {
                    this._differ = this._iterableDiffers.find(v).create(null);
                    this._mode = 'iterable';
                }
                else {
                    this._differ = this._keyValueDiffers.find(v).create(null);
                    this._mode = 'keyValue';
                }
            }
            else {
                this._differ = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    NgClass.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawClass);
            if (lang_1.isPresent(changes)) {
                if (this._mode == 'iterable') {
                    this._applyIterableChanges(changes);
                }
                else {
                    this._applyKeyValueChanges(changes);
                }
            }
        }
    };
    NgClass.prototype.onDestroy = function () { this._cleanupClasses(this._rawClass); };
    NgClass.prototype._cleanupClasses = function (rawClassVal) {
        this._applyClasses(rawClassVal, true);
        this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    NgClass.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });
        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });
    };
    NgClass.prototype._applyInitialClasses = function (isCleanup) {
        var _this = this;
        this._initialClasses.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
    };
    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
        var _this = this;
        if (lang_1.isPresent(rawClassVal)) {
            if (collection_1.isListLikeIterable(rawClassVal)) {
                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
            }
            else {
                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {
                    if (expVal)
                        _this._toggleClass(className, !isCleanup);
                });
            }
        }
    };
    NgClass.prototype._toggleClass = function (className, enabled) {
        className = className.trim();
        if (className.length > 0) {
            this._renderer.setElementClass(this._ngEl, className, enabled);
        }
    };
    NgClass = __decorate([
        metadata_1.Directive({ selector: '[ng-class]', inputs: ['rawClass: ng-class', 'initialClasses: class'] }), 
        __metadata('design:paramtypes', [change_detection_1.IterableDiffers, change_detection_1.KeyValueDiffers, linker_1.ElementRef, render_1.Renderer])
    ], NgClass);
    return NgClass;
})();
exports.NgClass = NgClass;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_for.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var change_detection_1 = require('angular2/src/core/change_detection');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `NgFor` directive instantiates a template once per item from an iterable. The context for
 * each instantiated template inherits from the outer context with the given loop variable set
 * to the current item from the iterable.
 *
 * It is possible to alias the `index` to a local variable that will be set to the current loop
 * iteration in the template context, and also to alias the 'last' to a local variable that will
 * be set to a boolean indicating if the item is the last one in the iteration
 *
 * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
 *
 * * When an item is added, a new instance of the template is added to the DOM.
 * * When an item is removed, its template instance is removed from the DOM.
 * * When items are reordered, their respective templates are reordered in the DOM.
 *
 * # Example
 *
 * ```
 * <ul>
 *   <li *ng-for="#error of errors; #i = index">
 *     Error {{i}} of {{errors.length}}: {{error.message}}
 *   </li>
 * </ul>
 * ```
 *
 * # Syntax
 *
 * - `<li *ng-for="#item of items; #i = index">...</li>`
 * - `<li template="ng-for #item of items; #i = index">...</li>`
 * - `<template ng-for #item [ng-for-of]="items" #i="index"><li>...</li></template>`
 */
var NgFor = (function () {
    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._iterableDiffers = _iterableDiffers;
        this._cdr = _cdr;
    }
    Object.defineProperty(NgFor.prototype, "ngForOf", {
        set: function (value) {
            this._ngForOf = value;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
                this._differ = this._iterableDiffers.find(value).create(this._cdr);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
        set: function (value) { this._templateRef = value; },
        enumerable: true,
        configurable: true
    });
    NgFor.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._ngForOf);
            if (lang_1.isPresent(changes))
                this._applyChanges(changes);
        }
    };
    NgFor.prototype._applyChanges = function (changes) {
        // TODO(rado): check if change detection can produce a change record that is
        // easier to consume than current.
        var recordViewTuples = [];
        changes.forEachRemovedItem(function (removedRecord) {
            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
        });
        changes.forEachMovedItem(function (movedRecord) {
            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
        });
        var insertTuples = this._bulkRemove(recordViewTuples);
        changes.forEachAddedItem(function (addedRecord) {
            return insertTuples.push(new RecordViewTuple(addedRecord, null));
        });
        this._bulkInsert(insertTuples);
        for (var i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
        }
        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
            this._viewContainer.get(i).setLocal('last', i === ilen - 1);
        }
    };
    NgFor.prototype._perViewChange = function (view, record) {
        view.setLocal('\$implicit', record.item);
        view.setLocal('index', record.currentIndex);
        view.setLocal('even', (record.currentIndex % 2 == 0));
        view.setLocal('odd', (record.currentIndex % 2 == 1));
    };
    NgFor.prototype._bulkRemove = function (tuples) {
        tuples.sort(function (a, b) { return a.record.previousIndex - b.record.previousIndex; });
        var movedTuples = [];
        for (var i = tuples.length - 1; i >= 0; i--) {
            var tuple = tuples[i];
            // separate moved views from removed views.
            if (lang_1.isPresent(tuple.record.currentIndex)) {
                tuple.view = this._viewContainer.detach(tuple.record.previousIndex);
                movedTuples.push(tuple);
            }
            else {
                this._viewContainer.remove(tuple.record.previousIndex);
            }
        }
        return movedTuples;
    };
    NgFor.prototype._bulkInsert = function (tuples) {
        tuples.sort(function (a, b) { return a.record.currentIndex - b.record.currentIndex; });
        for (var i = 0; i < tuples.length; i++) {
            var tuple = tuples[i];
            if (lang_1.isPresent(tuple.view)) {
                this._viewContainer.insert(tuple.view, tuple.record.currentIndex);
            }
            else {
                tuple.view =
                    this._viewContainer.createEmbeddedView(this._templateRef, tuple.record.currentIndex);
            }
        }
        return tuples;
    };
    NgFor = __decorate([
        metadata_1.Directive({ selector: '[ng-for][ng-for-of]', inputs: ['ngForOf', 'ngForTemplate'] }), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, change_detection_1.IterableDiffers, change_detection_1.ChangeDetectorRef])
    ], NgFor);
    return NgFor;
})();
exports.NgFor = NgFor;
var RecordViewTuple = (function () {
    function RecordViewTuple(record, view) {
        this.record = record;
        this.view = view;
    }
    return RecordViewTuple;
})();

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_if.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Removes or recreates a portion of the DOM tree based on an {expression}.
 *
 * If the expression assigned to `ng-if` evaluates to a false value then the element
 * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
 *
 * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
 *
 * ```
 * <div *ng-if="errorCount > 0" class="error">
 *   <!-- Error message displayed when the errorCount property on the current context is greater
 * than 0. -->
 *   {{errorCount}} errors detected
 * </div>
 * ```
 *
 * # Syntax
 *
 * - `<div *ng-if="condition">...</div>`
 * - `<div template="ng-if condition">...</div>`
 * - `<template [ng-if]="condition"><div>...</div></template>`
 */
var NgIf = (function () {
    function NgIf(_viewContainer, _templateRef) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._prevCondition = null;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
        set: function (newCondition /* boolean */) {
            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
                this._prevCondition = true;
                this._viewContainer.createEmbeddedView(this._templateRef);
            }
            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
                this._prevCondition = false;
                this._viewContainer.clear();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgIf = __decorate([
        metadata_1.Directive({ selector: '[ng-if]', inputs: ['ngIf'] }), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef])
    ], NgIf);
    return NgIf;
})();
exports.NgIf = NgIf;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_style.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var change_detection_1 = require('angular2/src/core/change_detection');
var linker_1 = require('angular2/src/core/linker');
var metadata_1 = require('angular2/src/core/metadata');
var render_1 = require('angular2/src/core/render');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `NgStyle` directive changes styles based on a result of expression evaluation.
 *
 * An expression assigned to the `ng-style` property must evaluate to an object and the
 * corresponding element styles are updated based on changes to this object. Style names to update
 * are taken from the object's keys, and values - from the corresponding object's values.
 *
 * # Syntax
 *
 * - `<div [ng-style]="{'font-style': style}"></div>`
 * - `<div [ng-style]="styleExp"></div>` - here the `styleExp` must evaluate to an object
 *
 * ### Example ([live demo](http://plnkr.co/edit/YamGS6GkUh9GqWNQhCyM?p=preview)):
 *
 * ```
 * import {Component, NgStyle} from 'angular2/angular2';
 *
 * @Component({
 *  selector: 'ng-style-example',
 *  template: `
 *    <h1 [ng-style]="{'font-style': style, 'font-size': size, 'font-weight': weight}">
 *      Change style of this text!
 *    </h1>
 *
 *    <hr>
 *
 *    <label>Italic: <input type="checkbox" (change)="changeStyle($event)"></label>
 *    <label>Bold: <input type="checkbox" (change)="changeWeight($event)"></label>
 *    <label>Size: <input type="text" [value]="size" (change)="size = $event.target.value"></label>
 *  `,
 *  directives: [NgStyle]
 * })
 * export class NgStyleExample {
 *    style = 'normal';
 *    weight = 'normal';
 *    size = '20px';
 *
 *    changeStyle($event: any) {
 *      this.style = $event.target.checked ? 'italic' : 'normal';
 *    }
 *
 *    changeWeight($event: any) {
 *      this.weight = $event.target.checked ? 'bold' : 'normal';
 *    }
 * }
 * ```
 *
 * In this example the `font-style`, `font-size` and `font-weight` styles will be updated
 * based on the `style` property's value changes.
 */
var NgStyle = (function () {
    function NgStyle(_differs, _ngEl, _renderer) {
        this._differs = _differs;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "rawStyle", {
        set: function (v) {
            this._rawStyle = v;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
                this._differ = this._differs.find(this._rawStyle).create(null);
            }
        },
        enumerable: true,
        configurable: true
    });
    NgStyle.prototype.doCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawStyle);
            if (lang_1.isPresent(changes)) {
                this._applyChanges(changes);
            }
        }
    };
    NgStyle.prototype._applyChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });
    };
    NgStyle.prototype._setStyle = function (name, val) {
        this._renderer.setElementStyle(this._ngEl, name, val);
    };
    NgStyle = __decorate([
        metadata_1.Directive({ selector: '[ng-style]', inputs: ['rawStyle: ng-style'] }), 
        __metadata('design:paramtypes', [change_detection_1.KeyValueDiffers, linker_1.ElementRef, render_1.Renderer])
    ], NgStyle);
    return NgStyle;
})();
exports.NgStyle = NgStyle;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/ng_switch.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var linker_1 = require('angular2/src/core/linker');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var _WHEN_DEFAULT = lang_1.CONST_EXPR(new Object());
var SwitchView = (function () {
    function SwitchView(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
    }
    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
    return SwitchView;
})();
exports.SwitchView = SwitchView;
/**
 * The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a
 * scope expression.
 * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
 * preserved at the location as specified in the template.
 *
 * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches
 * the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **`[ng-switch]="..."` attribute**),
 * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per
 * element.
 * The when attribute is used to inform NgSwitch which element to display when the expression is
 * evaluated. If a matching expression is not found via a when attribute then an element with the
 * default attribute is displayed.
 *
 * # Example:
 *
 * ```
 * <ANY [ng-switch]="expression">
 *   <template [ng-switch-when]="whenExpression1">...</template>
 *   <template [ng-switch-when]="whenExpression1">...</template>
 *   <template ng-switch-default>...</template>
 * </ANY>
 * ```
 */
var NgSwitch = (function () {
    function NgSwitch() {
        this._useDefault = false;
        this._valueViews = new collection_1.Map();
        this._activeViews = [];
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
        set: function (value) {
            // Empty the currently active ViewContainers
            this._emptyAllActiveViews();
            // Add the ViewContainers matching the value (with a fallback to default)
            this._useDefault = false;
            var views = this._valueViews.get(value);
            if (lang_1.isBlank(views)) {
                this._useDefault = true;
                views = lang_1.normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
            }
            this._activateViews(views);
            this._switchValue = value;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    NgSwitch.prototype._onWhenValueChanged = function (oldWhen, newWhen, view) {
        this._deregisterView(oldWhen, view);
        this._registerView(newWhen, view);
        if (oldWhen === this._switchValue) {
            view.destroy();
            collection_1.ListWrapper.remove(this._activeViews, view);
        }
        else if (newWhen === this._switchValue) {
            if (this._useDefault) {
                this._useDefault = false;
                this._emptyAllActiveViews();
            }
            view.create();
            this._activeViews.push(view);
        }
        // Switch to default when there is no more active ViewContainers
        if (this._activeViews.length === 0 && !this._useDefault) {
            this._useDefault = true;
            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
        }
    };
    /** @internal */
    NgSwitch.prototype._emptyAllActiveViews = function () {
        var activeContainers = this._activeViews;
        for (var i = 0; i < activeContainers.length; i++) {
            activeContainers[i].destroy();
        }
        this._activeViews = [];
    };
    /** @internal */
    NgSwitch.prototype._activateViews = function (views) {
        // TODO(vicb): assert(this._activeViews.length === 0);
        if (lang_1.isPresent(views)) {
            for (var i = 0; i < views.length; i++) {
                views[i].create();
            }
            this._activeViews = views;
        }
    };
    /** @internal */
    NgSwitch.prototype._registerView = function (value, view) {
        var views = this._valueViews.get(value);
        if (lang_1.isBlank(views)) {
            views = [];
            this._valueViews.set(value, views);
        }
        views.push(view);
    };
    /** @internal */
    NgSwitch.prototype._deregisterView = function (value, view) {
        // `_WHEN_DEFAULT` is used a marker for non-registered whens
        if (value === _WHEN_DEFAULT)
            return;
        var views = this._valueViews.get(value);
        if (views.length == 1) {
            this._valueViews.delete(value);
        }
        else {
            collection_1.ListWrapper.remove(views, view);
        }
    };
    NgSwitch = __decorate([
        metadata_1.Directive({ selector: '[ng-switch]', inputs: ['ngSwitch'] }), 
        __metadata('design:paramtypes', [])
    ], NgSwitch);
    return NgSwitch;
})();
exports.NgSwitch = NgSwitch;
/**
 * Defines a case statement as an expression.
 *
 * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.
 *
 * Example:
 *
 * ```
 * // match against a context variable
 * <template [ng-switch-when]="contextVariable">...</template>
 *
 * // match against a constant string
 * <template ng-switch-when="stringValue">...</template>
 * ```
 */
var NgSwitchWhen = (function () {
    function NgSwitchWhen(viewContainer, templateRef, _switch) {
        this._switch = _switch;
        // `_WHEN_DEFAULT` is used as a marker for a not yet initialized value
        /** @internal */
        this._value = _WHEN_DEFAULT;
        this._view = new SwitchView(viewContainer, templateRef);
    }
    Object.defineProperty(NgSwitchWhen.prototype, "ngSwitchWhen", {
        set: function (value) {
            this._switch._onWhenValueChanged(this._value, value, this._view);
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    NgSwitchWhen = __decorate([
        metadata_1.Directive({ selector: '[ng-switch-when]', inputs: ['ngSwitchWhen'] }),
        __param(2, di_1.Host()), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, NgSwitch])
    ], NgSwitchWhen);
    return NgSwitchWhen;
})();
exports.NgSwitchWhen = NgSwitchWhen;
/**
 * Defines a default case statement.
 *
 * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.
 *
 * Example:
 *
 * ```
 * <template ng-switch-default>...</template>
 * ```
 */
var NgSwitchDefault = (function () {
    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
    }
    NgSwitchDefault = __decorate([
        metadata_1.Directive({ selector: '[ng-switch-default]' }),
        __param(2, di_1.Host()), 
        __metadata('design:paramtypes', [linker_1.ViewContainerRef, linker_1.TemplateRef, NgSwitch])
    ], NgSwitchDefault);
    return NgSwitchDefault;
})();
exports.NgSwitchDefault = NgSwitchDefault;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/directives/observable_list_diff.js":[function(require,module,exports){
'use strict';// TS does not have Observables

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/browser_adapter.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('./dom_adapter');
var generic_browser_adapter_1 = require('./generic_browser_adapter');
var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
};
var DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
var _keyMap = {
    // The following values are here for cross-browser compatibility and to match the W3C standard
    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
};
/* tslint:disable:requireParameterType */
var BrowserDomAdapter = (function (_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
        _super.apply(this, arguments);
    }
    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error("parse not implemented"); };
    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };
    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {
        el[methodName].apply(el, args);
    };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.logError = function (error) {
        if (window.console.error) {
            window.console.error(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
    BrowserDomAdapter.prototype.logGroup = function (error) {
        if (window.console.group) {
            window.console.group(error);
            this.logError(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function () {
        if (window.console.groupEnd) {
            window.console.groupEnd();
        }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
        get: function () { return _attrToPropMap; },
        enumerable: true,
        configurable: true
    });
    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
        el.addEventListener(evt, listener, false);
        // Needed to follow Dart's subscription semantic, until fix of
        // https://code.google.com/p/dart/issues/detail?id=17406
        return function () { el.removeEventListener(evt, listener, false); };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
        var evt = document.createEvent('MouseEvent');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function (eventType) {
        var evt = document.createEvent('Event');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function (evt) {
        evt.preventDefault();
        evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function (evt) {
        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
    BrowserDomAdapter.prototype.content = function (node) {
        if (this.hasProperty(node, "content")) {
            return node.content;
        }
        else {
            return node;
        }
    };
    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
        var childNodes = el.childNodes;
        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
        for (var i = 0; i < childNodes.length; i++) {
            res[i] = childNodes[i];
        }
        return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function (el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
    };
    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
    BrowserDomAdapter.prototype.remove = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
    BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) { nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); }); };
    BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
    // TODO(vicb): removed Element type because it does not support StyleElement
    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
    BrowserDomAdapter.prototype.createTemplate = function (html) {
        var t = document.createElement('template');
        t.innerHTML = html;
        return t;
    };
    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
        if (doc === void 0) { doc = document; }
        var el = doc.createElement('SCRIPT');
        el.setAttribute(attrName, attrValue);
        return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
        if (doc === void 0) { doc = document; }
        var style = doc.createElement('style');
        this.appendChild(style, this.createTextNode(css));
        return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
        return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
        return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
    BrowserDomAdapter.prototype.addClass = function (element, classname) { element.classList.add(classname); };
    BrowserDomAdapter.prototype.removeClass = function (element, classname) { element.classList.remove(classname); };
    BrowserDomAdapter.prototype.hasClass = function (element, classname) { return element.classList.contains(classname); };
    BrowserDomAdapter.prototype.setStyle = function (element, stylename, stylevalue) {
        element.style[stylename] = stylevalue;
    };
    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) { element.style[stylename] = null; };
    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
    BrowserDomAdapter.prototype.attributeMap = function (element) {
        var res = new Map();
        var elAttrs = element.attributes;
        for (var i = 0; i < elAttrs.length; i++) {
            var attrib = elAttrs[i];
            res.set(attrib.name, attrib.value);
        }
        return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) { return element.hasAttribute(attribute); };
    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) { return element.getAttribute(attribute); };
    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
    BrowserDomAdapter.prototype.createHtmlDocument = function () {
        return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
        try {
            return el.getBoundingClientRect();
        }
        catch (e) {
            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
        }
    };
    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
        var matches = false;
        if (n instanceof HTMLElement) {
            if (n.matches) {
                matches = n.matches(selector);
            }
            else if (n.msMatchesSelector) {
                matches = n.msMatchesSelector(selector);
            }
            else if (n.webkitMatchesSelector) {
                matches = n.webkitMatchesSelector(selector);
            }
        }
        return matches;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
        return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
    };
    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
    BrowserDomAdapter.prototype.hasShadowRoot = function (node) { return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot); };
    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
    BrowserDomAdapter.prototype.importIntoDoc = function (node) {
        var toImport = node;
        if (this.isTemplateElement(node)) {
            toImport = this.content(node);
        }
        return document.importNode(toImport, true);
    };
    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
    BrowserDomAdapter.prototype.isPageRule = function (rule) { return rule.type === CSSRule.PAGE_RULE; };
    BrowserDomAdapter.prototype.isStyleRule = function (rule) { return rule.type === CSSRule.STYLE_RULE; };
    BrowserDomAdapter.prototype.isMediaRule = function (rule) { return rule.type === CSSRule.MEDIA_RULE; };
    BrowserDomAdapter.prototype.isKeyframesRule = function (rule) { return rule.type === CSSRule.KEYFRAMES_RULE; };
    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
    BrowserDomAdapter.prototype.getEventKey = function (event) {
        var key = event.key;
        if (lang_1.isBlank(key)) {
            key = event.keyIdentifier;
            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
            // Safari
            // cf
            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
            if (lang_1.isBlank(key)) {
                return 'Unidentified';
            }
            if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                    // There is a bug in Chrome for numeric keypad keys:
                    // https://code.google.com/p/chromium/issues/detail?id=155654
                    // 1, 2, 3 ... are reported as A, B, C ...
                    key = _chromeNumKeyPadMap[key];
                }
            }
        }
        if (_keyMap.hasOwnProperty(key)) {
            key = _keyMap[key];
        }
        return key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
        if (target == "window") {
            return window;
        }
        else if (target == "document") {
            return document;
        }
        else if (target == "body") {
            return document.body;
        }
    };
    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
    BrowserDomAdapter.prototype.getBaseHref = function () {
        var href = getBaseElementHref();
        if (lang_1.isBlank(href)) {
            return null;
        }
        return relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
    BrowserDomAdapter.prototype.setData = function (element, name, value) {
        this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function (element, name) { return this.getAttribute(element, 'data-' + name); };
    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };
    BrowserDomAdapter.prototype.requestAnimationFrame = function (callback) { return window.requestAnimationFrame(callback); };
    BrowserDomAdapter.prototype.cancelAnimationFrame = function (id) { window.cancelAnimationFrame(id); };
    BrowserDomAdapter.prototype.performanceNow = function () {
        // performance.now() is not available in all browsers, see
        // http://caniuse.com/#search=performance.now
        if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {
            return window.performance.now();
        }
        else {
            return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        }
    };
    return BrowserDomAdapter;
})(generic_browser_adapter_1.GenericBrowserDomAdapter);
exports.BrowserDomAdapter = BrowserDomAdapter;
var baseElement = null;
function getBaseElementHref() {
    if (lang_1.isBlank(baseElement)) {
        baseElement = document.querySelector('base');
        if (lang_1.isBlank(baseElement)) {
            return null;
        }
    }
    return baseElement.getAttribute('href');
}
// based on urlUtils.js in AngularJS 1
var urlParsingNode = null;
function relativePath(url) {
    if (lang_1.isBlank(urlParsingNode)) {
        urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
        '/' + urlParsingNode.pathname;
}

},{"./dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","./generic_browser_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/generic_browser_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
function setRootDomAdapter(adapter) {
    if (lang_1.isBlank(exports.DOM)) {
        exports.DOM = adapter;
    }
}
exports.setRootDomAdapter = setRootDomAdapter;
/* tslint:disable:requireParameterType */
/**
 * Provides DOM operations in an environment-agnostic way.
 */
var DomAdapter = (function () {
    function DomAdapter() {
    }
    return DomAdapter;
})();
exports.DomAdapter = DomAdapter;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/generic_browser_adapter.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('./dom_adapter');
/**
 * Provides DOM operations in any browser environment.
 */
var GenericBrowserDomAdapter = (function (_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
        var _this = this;
        _super.call(this);
        this._animationPrefix = null;
        this._transitionEnd = null;
        try {
            var element = this.createElement('div', this.defaultDoc());
            if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {
                this._animationPrefix = '';
            }
            else {
                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                for (var i = 0; i < domPrefixes.length; i++) {
                    if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
                        this._animationPrefix = '-' + lang_1.StringWrapper.toLowerCase(domPrefixes[i]) + '-';
                        break;
                    }
                }
            }
            var transEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend',
                transition: 'transitionend'
            };
            collection_1.StringMapWrapper.forEach(transEndEventNames, function (value, key) {
                if (lang_1.isPresent(_this.getStyle(element, key))) {
                    _this._transitionEnd = value;
                }
            });
        }
        catch (e) {
            this._animationPrefix = null;
            this._transitionEnd = null;
        }
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.cssToRules = function (css) {
        var style = this.createStyleElement(css);
        this.appendChild(this.defaultDoc().head, style);
        var rules = [];
        if (lang_1.isPresent(style.sheet)) {
            // TODO(sorvell): Firefox throws when accessing the rules of a stylesheet
            // with an @import
            // https://bugzilla.mozilla.org/show_bug.cgi?id=625013
            try {
                var rawRules = style.sheet.cssRules;
                rules = collection_1.ListWrapper.createFixedSize(rawRules.length);
                for (var i = 0; i < rawRules.length; i++) {
                    rules[i] = rawRules[i];
                }
            }
            catch (e) {
            }
        }
        else {
        }
        this.remove(style);
        return rules;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
    };
    GenericBrowserDomAdapter.prototype.supportsUnprefixedCssAnimation = function () {
        return lang_1.isPresent(this.defaultDoc().body.style) &&
            lang_1.isPresent(this.defaultDoc().body.style.animationName);
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {
        return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : "";
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : ""; };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
        return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);
    };
    return GenericBrowserDomAdapter;
})(dom_adapter_1.DomAdapter);
exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;

},{"./dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade.js":[function(require,module,exports){
'use strict';// Public API for Facade
var lang_1 = require('./facade/lang');
exports.Type = lang_1.Type;
var async_1 = require('./facade/async');
exports.Observable = async_1.Observable;
exports.EventEmitter = async_1.EventEmitter;
var exceptions_1 = require('./facade/exceptions');
exports.WrappedException = exceptions_1.WrappedException;

},{"./facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","./facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
// TODO(jeffbcross): use ES6 import once typings are available
var Subject = require('@reactivex/rxjs/dist/cjs/Subject');
var PromiseWrapper = (function () {
    function PromiseWrapper() {
    }
    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };
    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };
    // Note: We can't rename this method into `catch`, as this is not a valid
    // method name in Dart.
    PromiseWrapper.catchError = function (promise, onError) {
        return promise.catch(onError);
    };
    PromiseWrapper.all = function (promises) {
        if (promises.length == 0)
            return Promise.resolve([]);
        return Promise.all(promises);
    };
    PromiseWrapper.then = function (promise, success, rejection) {
        return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function (computation) {
        return new Promise(function (res, rej) {
            try {
                res(computation());
            }
            catch (e) {
                rej(e);
            }
        });
    };
    PromiseWrapper.completer = function () {
        var resolve;
        var reject;
        var p = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        return { promise: p, resolve: resolve, reject: reject };
    };
    return PromiseWrapper;
})();
exports.PromiseWrapper = PromiseWrapper;
var TimerWrapper = (function () {
    function TimerWrapper() {
    }
    TimerWrapper.setTimeout = function (fn, millis) {
        return lang_1.global.setTimeout(fn, millis);
    };
    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };
    TimerWrapper.setInterval = function (fn, millis) {
        return lang_1.global.setInterval(fn, millis);
    };
    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };
    return TimerWrapper;
})();
exports.TimerWrapper = TimerWrapper;
var ObservableWrapper = (function () {
    function ObservableWrapper() {
    }
    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
    ObservableWrapper.subscribe = function (emitter, onNext, onThrow, onReturn) {
        if (onThrow === void 0) { onThrow = null; }
        if (onReturn === void 0) { onReturn = null; }
        return emitter.observer({ next: onNext, throw: onThrow, return: onReturn });
    };
    ObservableWrapper.isObservable = function (obs) { return obs instanceof Observable; };
    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };
    ObservableWrapper.callNext = function (emitter, value) { emitter.next(value); };
    ObservableWrapper.callThrow = function (emitter, error) { emitter.throw(error); };
    ObservableWrapper.callReturn = function (emitter) { emitter.return(null); };
    return ObservableWrapper;
})();
exports.ObservableWrapper = ObservableWrapper;
// TODO: vsavkin change to interface
var Observable = (function () {
    function Observable() {
    }
    Observable.prototype.observer = function (generator) { return null; };
    return Observable;
})();
exports.Observable = Observable;
/**
 * Use by directives and components to emit custom Events.
 *
 * ## Examples
 *
 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter = new EventEmitter();
 *   @Output() close: EventEmitter = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.next(null);
 *     } else {
 *       this.close.next(null);
 *     }
 *   }
 * }
 * ```
 *
 * Use Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 */
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    function EventEmitter() {
        _super.apply(this, arguments);
        /** @internal */
        this._subject = new Subject();
    }
    EventEmitter.prototype.observer = function (generator) {
        return this._subject.subscribe(function (value) { setTimeout(function () { return generator.next(value); }); }, function (error) { return generator.throw ? generator.throw(error) : null; }, function () { return generator.return ? generator.return() : null; });
    };
    EventEmitter.prototype.toRx = function () { return this._subject; };
    EventEmitter.prototype.next = function (value) { this._subject.next(value); };
    EventEmitter.prototype.throw = function (error) { this._subject.error(error); };
    EventEmitter.prototype.return = function (value) { this._subject.complete(); };
    return EventEmitter;
})(Observable);
exports.EventEmitter = EventEmitter;

},{"@reactivex/rxjs/dist/cjs/Subject":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/node_modules/@reactivex/rxjs/dist/cjs/Subject.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.Map = lang_1.global.Map;
exports.Set = lang_1.global.Set;
// Safari and Internet Explorer do not support the iterable parameter to the
// Map constructor.  We work around that by manually adding the items.
var createMapFromPairs = (function () {
    try {
        if (new exports.Map([[1, 2]]).size === 1) {
            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromPairs(pairs) {
        var map = new exports.Map();
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            map.set(pair[0], pair[1]);
        }
        return map;
    };
})();
var createMapFromMap = (function () {
    try {
        if (new exports.Map(new exports.Map())) {
            return function createMapFromMap(m) { return new exports.Map(m); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromMap(m) {
        var map = new exports.Map();
        m.forEach(function (v, k) { map.set(k, v); });
        return map;
    };
})();
var _clearValues = (function () {
    if ((new exports.Map()).keys().next) {
        return function _clearValues(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
                m.set(k.value, null);
            }
        };
    }
    else {
        return function _clearValuesWithForeEach(m) {
            m.forEach(function (v, k) { m.set(k, null); });
        };
    }
})();
// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
var _arrayFromMap = (function () {
    try {
        if ((new exports.Map()).values().next) {
            return function createArrayFromMap(m, getValues) { return getValues ? Array.from(m.values()) : Array.from(m.keys()); };
        }
    }
    catch (e) {
    }
    return function createArrayFromMapWithForeach(m, getValues) {
        var res = ListWrapper.createFixedSize(m.size), i = 0;
        m.forEach(function (v, k) {
            res[i] = getValues ? v : k;
            i++;
        });
        return res;
    };
})();
var MapWrapper = (function () {
    function MapWrapper() {
    }
    MapWrapper.clone = function (m) { return createMapFromMap(m); };
    MapWrapper.createFromStringMap = function (stringMap) {
        var result = new exports.Map();
        for (var prop in stringMap) {
            result.set(prop, stringMap[prop]);
        }
        return result;
    };
    MapWrapper.toStringMap = function (m) {
        var r = {};
        m.forEach(function (v, k) { return r[k] = v; });
        return r;
    };
    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
    MapWrapper.clearValues = function (m) { _clearValues(m); };
    MapWrapper.iterable = function (m) { return m; };
    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
    return MapWrapper;
})();
exports.MapWrapper = MapWrapper;
/**
 * Wraps Javascript Objects
 */
var StringMapWrapper = (function () {
    function StringMapWrapper() {
    }
    StringMapWrapper.create = function () {
        // Note: We are not using Object.create(null) here due to
        // performance!
        // http://jsperf.com/ng2-object-create-null
        return {};
    };
    StringMapWrapper.contains = function (map, key) {
        return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function (map, key) {
        return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
    StringMapWrapper.keys = function (map) { return Object.keys(map); };
    StringMapWrapper.isEmpty = function (map) {
        for (var prop in map) {
            return false;
        }
        return true;
    };
    StringMapWrapper.delete = function (map, key) { delete map[key]; };
    StringMapWrapper.forEach = function (map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    };
    StringMapWrapper.merge = function (m1, m2) {
        var m = {};
        for (var attr in m1) {
            if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
            }
        }
        for (var attr in m2) {
            if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
            }
        }
        return m;
    };
    StringMapWrapper.equals = function (m1, m2) {
        var k1 = Object.keys(m1);
        var k2 = Object.keys(m2);
        if (k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (m1[key] !== m2[key]) {
                return false;
            }
        }
        return true;
    };
    return StringMapWrapper;
})();
exports.StringMapWrapper = StringMapWrapper;
var ListWrapper = (function () {
    function ListWrapper() {
    }
    // JS has no way to express a statically fixed size list, but dart does so we
    // keep both methods.
    ListWrapper.createFixedSize = function (size) { return new Array(size); };
    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
    ListWrapper.clone = function (array) { return array.slice(0); };
    ListWrapper.forEachWithIndex = function (array, fn) {
        for (var i = 0; i < array.length; i++) {
            fn(array[i], i);
        }
    };
    ListWrapper.first = function (array) {
        if (!array)
            return null;
        return array[0];
    };
    ListWrapper.last = function (array) {
        if (!array || array.length == 0)
            return null;
        return array[array.length - 1];
    };
    ListWrapper.find = function (list, pred) {
        for (var i = 0; i < list.length; ++i) {
            if (pred(list[i]))
                return list[i];
        }
        return null;
    };
    ListWrapper.indexOf = function (array, value, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        return array.indexOf(value, startIndex);
    };
    ListWrapper.reduce = function (list, fn, init) {
        return list.reduce(fn, init);
    };
    ListWrapper.filter = function (array, pred) { return array.filter(pred); };
    ListWrapper.any = function (list, pred) {
        for (var i = 0; i < list.length; ++i) {
            if (pred(list[i]))
                return true;
        }
        return false;
    };
    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
    ListWrapper.reversed = function (array) {
        var a = ListWrapper.clone(array);
        return a.reverse();
    };
    ListWrapper.concat = function (a, b) { return a.concat(b); };
    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
    ListWrapper.removeAt = function (list, index) {
        var res = list[index];
        list.splice(index, 1);
        return res;
    };
    ListWrapper.removeAll = function (list, items) {
        for (var i = 0; i < items.length; ++i) {
            var index = list.indexOf(items[i]);
            list.splice(index, 1);
        }
    };
    ListWrapper.remove = function (list, el) {
        var index = list.indexOf(el);
        if (index > -1) {
            list.splice(index, 1);
            return true;
        }
        return false;
    };
    ListWrapper.clear = function (list) { list.length = 0; };
    ListWrapper.isEmpty = function (list) { return list.length == 0; };
    ListWrapper.fill = function (list, value, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = null; }
        list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function (a, b) {
        if (a.length != b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    };
    ListWrapper.slice = function (l, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
    ListWrapper.sort = function (l, compareFn) {
        if (lang_1.isPresent(compareFn)) {
            l.sort(compareFn);
        }
        else {
            l.sort();
        }
    };
    ListWrapper.toString = function (l) { return l.toString(); };
    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
    ListWrapper.maximum = function (list, predicate) {
        if (list.length == 0) {
            return null;
        }
        var solution = null;
        var maxValue = -Infinity;
        for (var index = 0; index < list.length; index++) {
            var candidate = list[index];
            if (lang_1.isBlank(candidate)) {
                continue;
            }
            var candidateValue = predicate(candidate);
            if (candidateValue > maxValue) {
                solution = candidate;
                maxValue = candidateValue;
            }
        }
        return solution;
    };
    return ListWrapper;
})();
exports.ListWrapper = ListWrapper;
function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
        return false;
    return lang_1.isArray(obj) ||
        (!(obj instanceof exports.Map) &&
            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
}
exports.isListLikeIterable = isListLikeIterable;
function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
            fn(obj[i]);
        }
    }
    else {
        var iterator = obj[lang_1.getSymbolIterator()]();
        var item;
        while (!((item = iterator.next()).done)) {
            fn(item.value);
        }
    }
}
exports.iterateListLike = iterateListLike;
// Safari and Internet Explorer do not support the iterable parameter to the
// Set constructor.  We work around that by manually adding the items.
var createSetFromList = (function () {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
        return function createSetFromList(lst) { return new exports.Set(lst); };
    }
    else {
        return function createSetAndPopulateFromList(lst) {
            var res = new exports.Set(lst);
            if (res.size !== lst.length) {
                for (var i = 0; i < lst.length; i++) {
                    res.add(lst[i]);
                }
            }
            return res;
        };
    }
})();
var SetWrapper = (function () {
    function SetWrapper() {
    }
    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
    SetWrapper.has = function (s, key) { return s.has(key); };
    SetWrapper.delete = function (m, k) { m.delete(k); };
    return SetWrapper;
})();
exports.SetWrapper = SetWrapper;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exception_handler.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var _ArrayLogger = (function () {
    function _ArrayLogger() {
        this.res = [];
    }
    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroupEnd = function () { };
    ;
    return _ArrayLogger;
})();
/**
 * Provides a hook for centralized exception handling.
 *
 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
 * intercept error handling,
 * write a custom exception handler that replaces this default as appropriate for your app.
 *
 * # Example
 *
 * ```javascript
 *
 * class MyExceptionHandler implements ExceptionHandler {
 *   call(error, stackTrace = null, reason = null) {
 *     // do something with the exception
 *   }
 * }
 *
 * bootstrap(MyApp, [provide(ExceptionHandler, {useClass: MyExceptionHandler})])
 *
 * ```
 */
var ExceptionHandler = (function () {
    function ExceptionHandler(_logger, _rethrowException) {
        if (_rethrowException === void 0) { _rethrowException = true; }
        this._logger = _logger;
        this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var l = new _ArrayLogger();
        var e = new ExceptionHandler(l, false);
        e.call(exception, stackTrace, reason);
        return l.res.join("\n");
    };
    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var originalException = this._findOriginalException(exception);
        var originalStack = this._findOriginalStack(exception);
        var context = this._findContext(exception);
        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
            this._logger.logError("STACKTRACE:");
            this._logger.logError(this._longStackTrace(stackTrace));
        }
        if (lang_1.isPresent(reason)) {
            this._logger.logError("REASON: " + reason);
        }
        if (lang_1.isPresent(originalException)) {
            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
        }
        if (lang_1.isPresent(originalStack)) {
            this._logger.logError("ORIGINAL STACKTRACE:");
            this._logger.logError(this._longStackTrace(originalStack));
        }
        if (lang_1.isPresent(context)) {
            this._logger.logError("ERROR CONTEXT:");
            this._logger.logError(context);
        }
        this._logger.logGroupEnd();
        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
        if (this._rethrowException)
            throw exception;
    };
    /** @internal */
    ExceptionHandler.prototype._extractMessage = function (exception) {
        return exception instanceof exceptions_1.WrappedException ? exception.wrapperMessage : exception.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") :
            stackTrace.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._findContext = function (exception) {
        try {
            if (!(exception instanceof exceptions_1.WrappedException))
                return null;
            return lang_1.isPresent(exception.context) ? exception.context :
                this._findContext(exception.originalException);
        }
        catch (e) {
            // exception.context can throw an exception. if it happens, we ignore the context.
            return null;
        }
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalException = function (exception) {
        if (!(exception instanceof exceptions_1.WrappedException))
            return null;
        var e = exception.originalException;
        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
        }
        return e;
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalStack = function (exception) {
        if (!(exception instanceof exceptions_1.WrappedException))
            return null;
        var e = exception;
        var stack = exception.originalStack;
        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
            if (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
                stack = e.originalStack;
            }
        }
        return stack;
    };
    return ExceptionHandler;
})();
exports.ExceptionHandler = ExceptionHandler;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exception_handler_1 = require('./exception_handler');
var exception_handler_2 = require('./exception_handler');
exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
var BaseException = (function (_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
        if (message === void 0) { message = "--"; }
        _super.call(this, message);
        this.message = message;
        this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function () { return this.message; };
    return BaseException;
})(Error);
exports.BaseException = BaseException;
var WrappedException = (function (_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
        _super.call(this, _wrapperMessage);
        this._wrapperMessage = _wrapperMessage;
        this._originalException = _originalException;
        this._originalStack = _originalStack;
        this._context = _context;
        this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
        get: function () { return this._wrapperMessage; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
        get: function () { return this._wrapperStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
        get: function () { return this._originalException; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
        get: function () { return this._originalStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
        get: function () { return this._context; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
        enumerable: true,
        configurable: true
    });
    WrappedException.prototype.toString = function () { return this.message; };
    return WrappedException;
})(Error);
exports.WrappedException = WrappedException;
function makeTypeError(message) {
    return new TypeError(message);
}
exports.makeTypeError = makeTypeError;
function unimplemented() {
    throw new BaseException('unimplemented');
}
exports.unimplemented = unimplemented;

},{"./exception_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exception_handler.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js":[function(require,module,exports){
'use strict';(function (NumberFormatStyle) {
    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
var NumberFormatStyle = exports.NumberFormatStyle;
var NumberFormatter = (function () {
    function NumberFormatter() {
    }
    NumberFormatter.format = function (number, locale, style, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;
        var intlOptions = {
            minimumIntegerDigits: minimumIntegerDigits,
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits
        };
        intlOptions.style = NumberFormatStyle[style].toLowerCase();
        if (style == NumberFormatStyle.Currency) {
            intlOptions.currency = currency;
            intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
        }
        return new Intl.NumberFormat(locale, intlOptions).format(number);
    };
    return NumberFormatter;
})();
exports.NumberFormatter = NumberFormatter;
function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
}
function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
}
function extractComponents(pattern) {
    var ret = {};
    var i = 0, j;
    while (i < pattern.length) {
        j = i;
        while (j < pattern.length && pattern[j] == pattern[i])
            j++;
        var len = j - i;
        switch (pattern[i]) {
            case 'G':
                ret.era = nameCondition(len);
                break;
            case 'y':
                ret.year = digitCondition(len);
                break;
            case 'M':
                if (len >= 3)
                    ret.month = nameCondition(len);
                else
                    ret.month = digitCondition(len);
                break;
            case 'd':
                ret.day = digitCondition(len);
                break;
            case 'E':
                ret.weekday = nameCondition(len);
                break;
            case 'j':
                ret.hour = digitCondition(len);
                break;
            case 'h':
                ret.hour = digitCondition(len);
                ret.hour12 = true;
                break;
            case 'H':
                ret.hour = digitCondition(len);
                ret.hour12 = false;
                break;
            case 'm':
                ret.minute = digitCondition(len);
                break;
            case 's':
                ret.second = digitCondition(len);
                break;
            case 'z':
                ret.timeZoneName = 'long';
                break;
            case 'Z':
                ret.timeZoneName = 'short';
                break;
        }
        i = j;
    }
    return ret;
}
var dateFormatterCache = new Map();
var DateFormatter = (function () {
    function DateFormatter() {
    }
    DateFormatter.format = function (date, locale, pattern) {
        var key = locale + pattern;
        if (dateFormatterCache.has(key)) {
            return dateFormatterCache.get(key).format(date);
        }
        var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
        dateFormatterCache.set(key, formatter);
        return formatter.format(date);
    };
    return DateFormatter;
})();
exports.DateFormatter = DateFormatter;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js":[function(require,module,exports){
(function (global){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    return type['name'];
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var assertionsEnabled_ = typeof _global['assert'] !== 'undefined';
function assertionsEnabled() {
    return assertionsEnabled_;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    if (assertionsEnabled_) {
        _global['assert'].call(condition);
    }
};
// This function is needed only to properly support Dart's const expressions
// see https://github.com/angular/ts2dart/pull/151 for more info
function CONST_EXPR(expr) {
    return expr;
}
exports.CONST_EXPR = CONST_EXPR;
function CONST() {
    return function (target) { return target; };
}
exports.CONST = CONST;
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isNumber(obj) {
    return typeof obj === 'number';
}
exports.isNumber = isNumber;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.toUpperCase = function (s) { return s.toUpperCase(); };
    StringWrapper.toLowerCase = function (s) { return s.toLowerCase(); };
    StringWrapper.startsWith = function (s, start) { return s.startsWith(start); };
    StringWrapper.substring = function (s, start, end) {
        if (end === void 0) { end = null; }
        return s.substring(start, end === null ? undefined : end);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
})();
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
})();
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
})(Error);
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
})();
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    return RegExpWrapper;
})();
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
})();
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
})();
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
})();
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
})();
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name)) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/math.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.Math = lang_1.global.Math;
exports.NaN = typeof exports.NaN;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module is used for handling user input, by defining and building a {@link ControlGroup} that
 * consists of
 * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
 * to read information
 * from the form DOM elements.
 *
 * This module is not included in the `angular2` module; you must import the forms module
 * explicitly.
 *
 */
var model_1 = require('./forms/model');
exports.AbstractControl = model_1.AbstractControl;
exports.Control = model_1.Control;
exports.ControlGroup = model_1.ControlGroup;
exports.ControlArray = model_1.ControlArray;
var abstract_control_directive_1 = require('./forms/directives/abstract_control_directive');
exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
var control_container_1 = require('./forms/directives/control_container');
exports.ControlContainer = control_container_1.ControlContainer;
var ng_control_name_1 = require('./forms/directives/ng_control_name');
exports.NgControlName = ng_control_name_1.NgControlName;
var ng_form_control_1 = require('./forms/directives/ng_form_control');
exports.NgFormControl = ng_form_control_1.NgFormControl;
var ng_model_1 = require('./forms/directives/ng_model');
exports.NgModel = ng_model_1.NgModel;
var ng_control_1 = require('./forms/directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
var ng_control_group_1 = require('./forms/directives/ng_control_group');
exports.NgControlGroup = ng_control_group_1.NgControlGroup;
var ng_form_model_1 = require('./forms/directives/ng_form_model');
exports.NgFormModel = ng_form_model_1.NgFormModel;
var ng_form_1 = require('./forms/directives/ng_form');
exports.NgForm = ng_form_1.NgForm;
var default_value_accessor_1 = require('./forms/directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
var ng_control_status_1 = require('./forms/directives/ng_control_status');
exports.NgControlStatus = ng_control_status_1.NgControlStatus;
var checkbox_value_accessor_1 = require('./forms/directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
var select_control_value_accessor_1 = require('./forms/directives/select_control_value_accessor');
exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
var directives_1 = require('./forms/directives');
exports.FORM_DIRECTIVES = directives_1.FORM_DIRECTIVES;
var validators_1 = require('./forms/validators');
exports.NG_VALIDATORS = validators_1.NG_VALIDATORS;
exports.Validators = validators_1.Validators;
var validators_2 = require('./forms/directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
var form_builder_1 = require('./forms/form_builder');
exports.FormBuilder = form_builder_1.FormBuilder;
var form_builder_2 = require('./forms/form_builder');
var lang_1 = require('./facade/lang');
/**
 * Shorthand set of providers used for building Angular forms.
 *
 * ### Example:
 *
 * ```typescript
 * bootstrap(MyApp, [FORM_PROVIDERS]);
 * ```
 */
exports.FORM_PROVIDERS = lang_1.CONST_EXPR([form_builder_2.FormBuilder]);
/**
 * @deprecated
 */
exports.FORM_BINDINGS = exports.FORM_PROVIDERS;

},{"./facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","./forms/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives.js","./forms/directives/abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js","./forms/directives/checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./forms/directives/control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./forms/directives/default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./forms/directives/ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./forms/directives/ng_control_group":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js","./forms/directives/ng_control_name":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js","./forms/directives/ng_control_status":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js","./forms/directives/ng_form":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js","./forms/directives/ng_form_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js","./forms/directives/ng_form_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js","./forms/directives/ng_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js","./forms/directives/select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","./forms/directives/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js","./forms/form_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/form_builder.js","./forms/model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","./forms/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var ng_control_name_1 = require('./directives/ng_control_name');
var ng_form_control_1 = require('./directives/ng_form_control');
var ng_model_1 = require('./directives/ng_model');
var ng_control_group_1 = require('./directives/ng_control_group');
var ng_form_model_1 = require('./directives/ng_form_model');
var ng_form_1 = require('./directives/ng_form');
var default_value_accessor_1 = require('./directives/default_value_accessor');
var checkbox_value_accessor_1 = require('./directives/checkbox_value_accessor');
var ng_control_status_1 = require('./directives/ng_control_status');
var select_control_value_accessor_1 = require('./directives/select_control_value_accessor');
var validators_1 = require('./directives/validators');
var ng_control_name_2 = require('./directives/ng_control_name');
exports.NgControlName = ng_control_name_2.NgControlName;
var ng_form_control_2 = require('./directives/ng_form_control');
exports.NgFormControl = ng_form_control_2.NgFormControl;
var ng_model_2 = require('./directives/ng_model');
exports.NgModel = ng_model_2.NgModel;
var ng_control_1 = require('./directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
var ng_control_group_2 = require('./directives/ng_control_group');
exports.NgControlGroup = ng_control_group_2.NgControlGroup;
var ng_form_model_2 = require('./directives/ng_form_model');
exports.NgFormModel = ng_form_model_2.NgFormModel;
var ng_form_2 = require('./directives/ng_form');
exports.NgForm = ng_form_2.NgForm;
var default_value_accessor_2 = require('./directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
var checkbox_value_accessor_2 = require('./directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
var select_control_value_accessor_2 = require('./directives/select_control_value_accessor');
exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
var validators_2 = require('./directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
var ng_control_status_2 = require('./directives/ng_control_status');
exports.NgControlStatus = ng_control_status_2.NgControlStatus;
/**
 *
 * A list of all the form directives used as part of a `@View` annotation.
 *
 *  This is a shorthand for importing them each individually.
 *
 * ### Example:
 *
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   directives: [FORM_DIRECTIVES]
 * })
 * class MyApp {}
 * ```
 */
exports.FORM_DIRECTIVES = lang_1.CONST_EXPR([
    ng_control_name_1.NgControlName,
    ng_control_group_1.NgControlGroup,
    ng_form_control_1.NgFormControl,
    ng_model_1.NgModel,
    ng_form_model_1.NgFormModel,
    ng_form_1.NgForm,
    select_control_value_accessor_1.NgSelectOption,
    default_value_accessor_1.DefaultValueAccessor,
    checkbox_value_accessor_1.CheckboxControlValueAccessor,
    select_control_value_accessor_1.SelectControlValueAccessor,
    ng_control_status_1.NgControlStatus,
    validators_1.RequiredValidator,
    validators_1.MinLengthValidator,
    validators_1.MaxLengthValidator
]);

},{"./directives/checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./directives/default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./directives/ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./directives/ng_control_group":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js","./directives/ng_control_name":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js","./directives/ng_control_status":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js","./directives/ng_form":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js","./directives/ng_form_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js","./directives/ng_form_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js","./directives/ng_model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js","./directives/select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","./directives/validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var AbstractControlDirective = (function () {
    function AbstractControlDirective() {
    }
    Object.defineProperty(AbstractControlDirective.prototype, "control", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "value", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.value : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.valid : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
        get: function () {
            return lang_1.isPresent(this.control) ? this.control.errors : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.pristine : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.dirty : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.touched : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.untouched : null; },
        enumerable: true,
        configurable: true
    });
    return AbstractControlDirective;
})();
exports.AbstractControlDirective = AbstractControlDirective;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var render_1 = require('angular2/src/core/render');
var linker_1 = require('angular2/src/core/linker');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var CHECKBOX_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return CheckboxControlValueAccessor; }), multi: true }));
/**
 * The accessor for writing a value and listening to changes on a checkbox input element.
 *
 *  # Example
 *  ```
 *  <input type="checkbox" [ng-control]="rememberLogin">
 *  ```
 */
var CheckboxControlValueAccessor = (function () {
    function CheckboxControlValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    CheckboxControlValueAccessor.prototype.writeValue = function (value) { shared_1.setProperty(this._renderer, this._elementRef, "checked", value); };
    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    CheckboxControlValueAccessor = __decorate([
        metadata_1.Directive({
            selector: 'input[type=checkbox][ng-control],input[type=checkbox][ng-form-control],input[type=checkbox][ng-model]',
            host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
            bindings: [CHECKBOX_VALUE_ACCESSOR]
        }), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef])
    ], CheckboxControlValueAccessor);
    return CheckboxControlValueAccessor;
})();
exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A directive that contains multiple {@link NgControl}.
 *
 * Only used by the forms module.
 */
var ControlContainer = (function (_super) {
    __extends(ControlContainer, _super);
    function ControlContainer() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(ControlContainer.prototype, "formDirective", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlContainer.prototype, "path", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return ControlContainer;
})(abstract_control_directive_1.AbstractControlDirective);
exports.ControlContainer = ControlContainer;

},{"./abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
exports.NG_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.OpaqueToken("NgValueAccessor"));

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('angular2/src/core/metadata');
var linker_1 = require('angular2/src/core/linker');
var render_1 = require('angular2/src/core/render');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var DEFAULT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return DefaultValueAccessor; }), multi: true }));
/**
 * The default accessor for writing a value and listening to changes that is used by the
 * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
 *
 *  # Example
 *  ```
 *  <input type="text" [(ng-model)]="searchQuery">
 *  ```
 */
var DefaultValueAccessor = (function () {
    function DefaultValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    DefaultValueAccessor.prototype.writeValue = function (value) {
        var normalizedValue = lang_1.isBlank(value) ? '' : value;
        shared_1.setProperty(this._renderer, this._elementRef, 'value', normalizedValue);
    };
    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    DefaultValueAccessor = __decorate([
        metadata_1.Directive({
            selector: '[ng-control],[ng-model],[ng-form-control]',
            host: {
                '(change)': 'onChange($event.target.value)',
                '(input)': 'onChange($event.target.value)',
                '(blur)': 'onTouched()'
            },
            bindings: [DEFAULT_VALUE_ACCESSOR]
        }), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef])
    ], DefaultValueAccessor);
    return DefaultValueAccessor;
})();
exports.DefaultValueAccessor = DefaultValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A base class that all control directive extend.
 * It binds a {@link Control} object to a DOM element.
 */
// Cannot currently be abstract because it would contain
// an abstract method in the public API, and we cannot reflect
// on that in Dart due to https://github.com/dart-lang/sdk/issues/18721
// Also we don't have abstract setters, see https://github.com/Microsoft/TypeScript/issues/4669
var NgControl = (function (_super) {
    __extends(NgControl, _super);
    function NgControl() {
        _super.apply(this, arguments);
        this.name = null;
        this.valueAccessor = null;
    }
    Object.defineProperty(NgControl.prototype, "validator", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControl.prototype, "path", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    NgControl.prototype.viewToModelUpdate = function (newValue) { };
    return NgControl;
})(abstract_control_directive_1.AbstractControlDirective);
exports.NgControl = NgControl;

},{"./abstract_control_directive":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/abstract_control_directive.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_group.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var controlGroupBinding = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgControlGroup; }) }));
/**
 * Creates and binds a control group to a DOM element.
 *
 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
 *
 * # Example
 *
 * In this example, we create the credentials and personal control groups.
 * We can work with each group separately: check its validity, get its value, listen to its changes.
 *
 *  ```
 * @Component({
 *      selector: "signup-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *              <form #f="form" (submit)='onSignUp(f.value)'>
 *                <div ng-control-group='credentials' #credentials="form">
 *                  Login <input type='text' ng-control='login'>
 *                  Password <input type='password' ng-control='password'>
 *                </div>
 *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
 *
 *                <div ng-control-group='personal'>
 *                  Name <input type='text' ng-control='name'>
 *                </div>
 *                <button type='submit'>Sign Up!</button>
 *              </form>
 *      `})
 * class SignupComp {
 *  onSignUp(value) {
 *    // value === {
 *    //  personal: {name: 'some name'},
 *    //  credentials: {login: 'some login', password: 'some password'}}
 *  }
 * }
 *
 *  ```
 */
var NgControlGroup = (function (_super) {
    __extends(NgControlGroup, _super);
    function NgControlGroup(_parent) {
        _super.call(this);
        this._parent = _parent;
    }
    NgControlGroup.prototype.onInit = function () { this.formDirective.addControlGroup(this); };
    NgControlGroup.prototype.onDestroy = function () { this.formDirective.removeControlGroup(this); };
    Object.defineProperty(NgControlGroup.prototype, "control", {
        get: function () { return this.formDirective.getControlGroup(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "path", {
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    NgControlGroup = __decorate([
        metadata_1.Directive({
            selector: '[ng-control-group]',
            bindings: [controlGroupBinding],
            inputs: ['name: ng-control-group'],
            exportAs: 'form'
        }),
        __param(0, di_1.Host()),
        __param(0, di_1.SkipSelf()), 
        __metadata('design:paramtypes', [control_container_1.ControlContainer])
    ], NgControlGroup);
    return NgControlGroup;
})(control_container_1.ControlContainer);
exports.NgControlGroup = NgControlGroup;

},{"./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_name.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var ng_control_1 = require('./ng_control');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
var controlNameBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgControlName; }) }));
/**
 * Creates and binds a control with a specified name to a DOM element.
 *
 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.

 * # Example
 *
 * In this example, we create the login and password controls.
 * We can work with each control separately: check its validity, get its value, listen to its
 * changes.
 *
 *  ```
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form #f="form" (submit)='onLogIn(f.value)'>
 *          Login <input type='text' ng-control='login' #l="form">
 *          <div *ng-if="!l.valid">Login is invalid</div>
 *
 *          Password <input type='password' ng-control='password'>
 *          <button type='submit'>Log in!</button>
 *        </form>
 *      `})
 * class LoginComp {
 *  onLogIn(value): void {
 *    // value === {login: 'some login', password: 'some password'}
 *  }
 * }
 *  ```
 *
 * We can also use ng-model to bind a domain model to the form.
 *
 *  ```
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form (submit)='onLogIn()'>
 *          Login <input type='text' ng-control='login' [(ng-model)]="credentials.login">
 *          Password <input type='password' ng-control='password'
 *                          [(ng-model)]="credentials.password">
 *          <button type='submit'>Log in!</button>
 *        </form>
 *      `})
 * class LoginComp {
 *  credentials: {login:string, password:string};
 *
 *  onLogIn(): void {
 *    // this.credentials.login === "some login"
 *    // this.credentials.password === "some password"
 *  }
 * }
 *  ```
 */
var NgControlName = (function (_super) {
    __extends(NgControlName, _super);
    function NgControlName(parent, validators, valueAccessors) {
        _super.call(this);
        this.update = new async_1.EventEmitter();
        /** @internal */
        this._added = false;
        this._parent = parent;
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgControlName.prototype.onChanges = function (changes) {
        if (!this._added) {
            this.formDirective.addControl(this);
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    };
    NgControlName.prototype.onDestroy = function () { this.formDirective.removeControl(this); };
    NgControlName.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    Object.defineProperty(NgControlName.prototype, "path", {
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "formDirective", {
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "control", {
        get: function () { return this.formDirective.getControl(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgControlName = __decorate([
        metadata_1.Directive({
            selector: '[ng-control]',
            bindings: [controlNameBinding],
            inputs: ['name: ngControl', 'model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Host()),
        __param(0, di_1.SkipSelf()),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(2, di_1.Optional()),
        __param(2, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [control_container_1.ControlContainer, Array, Array])
    ], NgControlName);
    return NgControlName;
})(ng_control_1.NgControl);
exports.NgControlName = NgControlName;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control_status.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var ng_control_1 = require('./ng_control');
var lang_1 = require('angular2/src/core/facade/lang');
var NgControlStatus = (function () {
    function NgControlStatus(cd) {
        this._cd = cd;
    }
    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    NgControlStatus = __decorate([
        metadata_1.Directive({
            selector: '[ng-control],[ng-model],[ng-form-control]',
            host: {
                '[class.ng-untouched]': 'ngClassUntouched',
                '[class.ng-touched]': 'ngClassTouched',
                '[class.ng-pristine]': 'ngClassPristine',
                '[class.ng-dirty]': 'ngClassDirty',
                '[class.ng-valid]': 'ngClassValid',
                '[class.ng-invalid]': 'ngClassInvalid'
            }
        }),
        __param(0, di_1.Self()), 
        __metadata('design:paramtypes', [ng_control_1.NgControl])
    ], NgControlStatus);
    return NgControlStatus;
})();
exports.NgControlStatus = NgControlStatus;

},{"./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var model_1 = require('../model');
var shared_1 = require('./shared');
var formDirectiveProvider = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgForm; }) }));
/**
 * If `NgForm` is bound in a component, `<form>` elements in that component will be
 * upgraded to use the Angular form system.
 *
 * # Typical Use
 *
 * Include `FORM_DIRECTIVES` in the `directives` section of a {@link View} annotation
 * to use `NgForm` and its associated controls.
 *
 * # Structure
 *
 * An Angular form is a collection of `Control`s in some hierarchy.
 * `Control`s can be at the top level or can be organized in `ControlGroup`s
 * or `ControlArray`s. This hierarchy is reflected in the form's `value`, a
 * JSON object that mirrors the form structure.
 *
 * # Submission
 *
 * The `ng-submit` event signals when the user triggers a form submission.
 *
 * ### Example ([live demo](http://plnkr.co/edit/ltdgYj4P0iY64AR71EpL?p=preview))
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <p>Submit the form to see the data object Angular builds</p>
 *       <h2>NgForm demo</h2>
 *       <form #f="form" (ng-submit)="onSubmit(f.value)">
 *         <h3>Control group: credentials</h3>
 *         <div ng-control-group="credentials">
 *           <p>Login: <input type="text" ng-control="login"></p>
 *           <p>Password: <input type="password" ng-control="password"></p>
 *         </div>
 *         <h3>Control group: person</h3>
 *         <div ng-control-group="person">
 *           <p>First name: <input type="text" ng-control="firstName"></p>
 *           <p>Last name: <input type="text" ng-control="lastName"></p>
 *         </div>
 *         <button type="submit">Submit Form</button>
 *       <p>Form data submitted:</p>
 *       </form>
 *       <pre>{{data}}</pre>
 *     </div>
 * `,
 *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
 * })
 * export class App {
 *   constructor() {}
 *
 *   data: string;
 *
 *   onSubmit(data) {
 *     this.data = JSON.stringify(data, null, 2);
 *   }
 * }
 *  ```
 */
var NgForm = (function (_super) {
    __extends(NgForm, _super);
    function NgForm() {
        _super.apply(this, arguments);
        this.form = new model_1.ControlGroup({});
        this.ngSubmit = new async_1.EventEmitter();
    }
    Object.defineProperty(NgForm.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
        get: function () { return this.form.controls; },
        enumerable: true,
        configurable: true
    });
    NgForm.prototype.addControl = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            var ctrl = new model_1.Control();
            shared_1.setUpControl(ctrl, dir);
            container.addControl(dir.name, ctrl);
            ctrl.updateValidity();
        });
    };
    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgForm.prototype.removeControl = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
            }
        });
    };
    NgForm.prototype.addControlGroup = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            var group = new model_1.ControlGroup({});
            container.addControl(dir.name, group);
            group.updateValidity();
        });
    };
    NgForm.prototype.removeControlGroup = function (dir) {
        var _this = this;
        this._later(function (_) {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
            }
        });
    };
    NgForm.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgForm.prototype.updateModel = function (dir, value) {
        var _this = this;
        this._later(function (_) {
            var ctrl = _this.form.find(dir.path);
            ctrl.updateValue(value);
        });
    };
    NgForm.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgForm.prototype._findContainer = function (path) {
        path.pop();
        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
    };
    /** @internal */
    NgForm.prototype._later = function (fn) { async_1.PromiseWrapper.then(async_1.PromiseWrapper.resolve(null), fn, function (_) { }); };
    NgForm = __decorate([
        metadata_1.Directive({
            selector: 'form:not([ng-no-form]):not([ng-form-model]),ng-form,[ng-form]',
            bindings: [formDirectiveProvider],
            host: {
                '(submit)': 'onSubmit()',
            },
            outputs: ['ngSubmit'],
            exportAs: 'form'
        }), 
        __metadata('design:paramtypes', [])
    ], NgForm);
    return NgForm;
})(control_container_1.ControlContainer);
exports.NgForm = NgForm;

},{"../model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_control.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var ng_control_1 = require('./ng_control');
var validators_1 = require('../validators');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
var formControlBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgFormControl; }) }));
/**
 * Binds an existing {@link Control} to a DOM element.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jcQlZ2tTh22BZZ2ucNAT?p=preview))
 *
 * In this example, we bind the control to an input element. When the value of the input element
 * changes, the value of the control will reflect that change. Likewise, if the value of the
 * control changes, the input element reflects that change.
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <h2>NgFormControl Example</h2>
 *       <form>
 *         <p>Element with existing control: <input type="text"
 * [ng-form-control]="loginControl"></p>
 *         <p>Value of existing control: {{loginControl.value}}</p>
 *       </form>
 *     </div>
 *   `,
 *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
 * })
 * export class App {
 *   loginControl: Control = new Control('');
 * }
 *  ```
 *
 * # ng-model
 *
 * We can also use `ng-model` to bind a domain model to the form.
 *
 * ### Example ([live demo](http://plnkr.co/edit/yHMLuHO7DNgT8XvtjTDH?p=preview))
 *
 *  ```typescript
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: "<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>"
 *      })
 * class LoginComp {
 *  loginControl: Control = new Control('');
 *  login:string;
 * }
 *  ```
 */
var NgFormControl = (function (_super) {
    __extends(NgFormControl, _super);
    function NgFormControl(validators, valueAccessors) {
        _super.call(this);
        this.update = new async_1.EventEmitter();
        /** @internal */
        this._added = false;
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgFormControl.prototype.onChanges = function (changes) {
        if (!this._added) {
            shared_1.setUpControl(this.form, this);
            this.form.updateValidity();
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.form.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgFormControl.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgFormControl.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    NgFormControl = __decorate([
        metadata_1.Directive({
            selector: '[ng-form-control]',
            bindings: [formControlBinding],
            inputs: ['form: ngFormControl', 'model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Optional()),
        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [Array, Array])
    ], NgFormControl);
    return NgFormControl;
})(ng_control_1.NgControl);
exports.NgFormControl = NgFormControl;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_form_model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var formDirectiveProvider = lang_1.CONST_EXPR(new di_1.Provider(control_container_1.ControlContainer, { useExisting: di_1.forwardRef(function () { return NgFormModel; }) }));
/**
 * Binds an existing control group to a DOM element.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jqrVirudY8anJxTMUjTP?p=preview))
 *
 * In this example, we bind the control group to the form element, and we bind the login and
 * password controls to the login and password elements.
 *
 *  ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <div>
 *       <h2>NgFormModel Example</h2>
 *       <form [ng-form-model]="loginForm">
 *         <p>Login: <input type="text" ng-control="login"></p>
 *         <p>Password: <input type="password" ng-control="password"></p>
 *       </form>
 *       <p>Value:</p>
 *       <pre>{{value}}</pre>
 *     </div>
 *   `,
 *   directives: [FORM_DIRECTIVES]
 * })
 * export class App {
 *   loginForm: ControlGroup;
 *
 *   constructor() {
 *     this.loginForm = new ControlGroup({
 *       login: new Control(""),
 *       password: new Control("")
 *     });
 *   }
 *
 *   get value(): string {
 *     return JSON.stringify(this.loginForm.value, null, 2);
 *   }
 * }
 *  ```
 *
 * We can also use ng-model to bind a domain model to the form.
 *
 *  ```typescript
 * @Component({
 *      selector: "login-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `
 *        <form [ng-form-model]='loginForm'>
 *          Login <input type='text' ng-control='login' [(ng-model)]='credentials.login'>
 *          Password <input type='password' ng-control='password'
 *                          [(ng-model)]='credentials.password'>
 *          <button (click)="onLogin()">Login</button>
 *        </form>`
 *      })
 * class LoginComp {
 *  credentials: {login: string, password: string};
 *  loginForm: ControlGroup;
 *
 *  constructor() {
 *    this.loginForm = new ControlGroup({
 *      login: new Control(""),
 *      password: new Control("")
 *    });
 *  }
 *
 *  onLogin(): void {
 *    // this.credentials.login === 'some login'
 *    // this.credentials.password === 'some password'
 *  }
 * }
 *  ```
 */
var NgFormModel = (function (_super) {
    __extends(NgFormModel, _super);
    function NgFormModel() {
        _super.apply(this, arguments);
        this.form = null;
        this.directives = [];
        this.ngSubmit = new async_1.EventEmitter();
    }
    NgFormModel.prototype.onChanges = function (_) { this._updateDomValue(); };
    Object.defineProperty(NgFormModel.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    NgFormModel.prototype.addControl = function (dir) {
        var ctrl = this.form.find(dir.path);
        shared_1.setUpControl(ctrl, dir);
        ctrl.updateValidity();
        this.directives.push(dir);
    };
    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };
    NgFormModel.prototype.addControlGroup = function (dir) { };
    NgFormModel.prototype.removeControlGroup = function (dir) { };
    NgFormModel.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgFormModel.prototype.updateModel = function (dir, value) {
        var ctrl = this.form.find(dir.path);
        ctrl.updateValue(value);
    };
    NgFormModel.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgFormModel.prototype._updateDomValue = function () {
        var _this = this;
        this.directives.forEach(function (dir) {
            var ctrl = _this.form.find(dir.path);
            dir.valueAccessor.writeValue(ctrl.value);
        });
    };
    NgFormModel = __decorate([
        metadata_1.Directive({
            selector: '[ng-form-model]',
            bindings: [formDirectiveProvider],
            inputs: ['form: ng-form-model'],
            host: { '(submit)': 'onSubmit()' },
            outputs: ['ngSubmit'],
            exportAs: 'form'
        }), 
        __metadata('design:paramtypes', [])
    ], NgFormModel);
    return NgFormModel;
})(control_container_1.ControlContainer);
exports.NgFormModel = NgFormModel;

},{"./control_container":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_container.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var control_value_accessor_1 = require('./control_value_accessor');
var ng_control_1 = require('./ng_control');
var model_1 = require('../model');
var validators_1 = require('../validators');
var shared_1 = require('./shared');
var formControlBinding = lang_1.CONST_EXPR(new di_1.Provider(ng_control_1.NgControl, { useExisting: di_1.forwardRef(function () { return NgModel; }) }));
/**
 * Binds a domain model to a form control.
 *
 * # Usage
 *
 * `ng-model` binds an existing domain model to a form control. For a
 * two-way binding, use `[(ng-model)]` to ensure the model updates in
 * both directions.
 *
 * ### Example ([live demo](http://plnkr.co/edit/R3UX5qDaUqFO2VYR0UzH?p=preview))
 *  ```typescript
 * @Component({
 *      selector: "search-comp",
 *      directives: [FORM_DIRECTIVES],
 *      template: `<input type='text' [(ng-model)]="searchQuery">`
 *      })
 * class SearchComp {
 *  searchQuery: string;
 * }
 *  ```
 */
var NgModel = (function (_super) {
    __extends(NgModel, _super);
    function NgModel(validators, valueAccessors) {
        _super.call(this);
        /** @internal */
        this._control = new model_1.Control();
        /** @internal */
        this._added = false;
        this.update = new async_1.EventEmitter();
        this.validators = validators;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgModel.prototype.onChanges = function (changes) {
        if (!this._added) {
            shared_1.setUpControl(this._control, this);
            this._control.updateValidity();
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this._control.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgModel.prototype, "control", {
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
        get: function () { return validators_1.Validators.compose(this.validators); },
        enumerable: true,
        configurable: true
    });
    NgModel.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callNext(this.update, newValue);
    };
    NgModel = __decorate([
        metadata_1.Directive({
            selector: '[ng-model]:not([ng-control]):not([ng-form-control])',
            bindings: [formControlBinding],
            inputs: ['model: ngModel'],
            outputs: ['update: ngModelChange'],
            exportAs: 'form'
        }),
        __param(0, di_1.Optional()),
        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)),
        __param(1, di_1.Optional()),
        __param(1, di_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), 
        __metadata('design:paramtypes', [Array, Array])
    ], NgModel);
    return NgModel;
})(ng_control_1.NgControl);
exports.NgModel = NgModel;

},{"../model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./ng_control":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/ng_control.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var render_1 = require('angular2/src/core/render');
var linker_1 = require('angular2/src/core/linker');
var metadata_1 = require('angular2/src/core/metadata');
var async_1 = require('angular2/src/core/facade/async');
var control_value_accessor_1 = require('./control_value_accessor');
var lang_1 = require('angular2/src/core/facade/lang');
var shared_1 = require('./shared');
var SELECT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new di_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: di_1.forwardRef(function () { return SelectControlValueAccessor; }), multi: true }));
/**
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * #Example:
 *
 * ```
 * <select ng-control="city">
 *   <option *ng-for="#c of cities" [value]="c"></option>
 * </select>
 * ```
 */
var NgSelectOption = (function () {
    function NgSelectOption() {
    }
    NgSelectOption = __decorate([
        metadata_1.Directive({ selector: 'option' }), 
        __metadata('design:paramtypes', [])
    ], NgSelectOption);
    return NgSelectOption;
})();
exports.NgSelectOption = NgSelectOption;
/**
 * The accessor for writing a value and listening to changes on a select element.
 */
var SelectControlValueAccessor = (function () {
    function SelectControlValueAccessor(_renderer, _elementRef, query) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
        this._updateValueWhenListOfOptionsChanges(query);
    }
    SelectControlValueAccessor.prototype.writeValue = function (value) {
        this.value = value;
        shared_1.setProperty(this._renderer, this._elementRef, "value", value);
    };
    SelectControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    SelectControlValueAccessor.prototype._updateValueWhenListOfOptionsChanges = function (query) {
        var _this = this;
        async_1.ObservableWrapper.subscribe(query.changes, function (_) { return _this.writeValue(_this.value); });
    };
    SelectControlValueAccessor = __decorate([
        metadata_1.Directive({
            selector: 'select[ng-control],select[ng-form-control],select[ng-model]',
            host: {
                '(change)': 'onChange($event.target.value)',
                '(input)': 'onChange($event.target.value)',
                '(blur)': 'onTouched()'
            },
            bindings: [SELECT_VALUE_ACCESSOR]
        }),
        __param(2, metadata_1.Query(NgSelectOption, { descendants: true })), 
        __metadata('design:paramtypes', [render_1.Renderer, linker_1.ElementRef, linker_1.QueryList])
    ], SelectControlValueAccessor);
    return SelectControlValueAccessor;
})();
exports.SelectControlValueAccessor = SelectControlValueAccessor;

},{"./control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/control_value_accessor.js","./shared":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/shared.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var validators_1 = require('../validators');
var default_value_accessor_1 = require('./default_value_accessor');
var checkbox_value_accessor_1 = require('./checkbox_value_accessor');
var select_control_value_accessor_1 = require('./select_control_value_accessor');
function controlPath(name, parent) {
    var p = collection_1.ListWrapper.clone(parent.path);
    p.push(name);
    return p;
}
exports.controlPath = controlPath;
function setUpControl(control, dir) {
    if (lang_1.isBlank(control))
        _throwError(dir, "Cannot find control");
    if (lang_1.isBlank(dir.valueAccessor))
        _throwError(dir, "No value accessor for");
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    dir.valueAccessor.writeValue(control.value);
    // view -> model
    dir.valueAccessor.registerOnChange(function (newValue) {
        dir.viewToModelUpdate(newValue);
        control.updateValue(newValue, { emitModelToViewChange: false });
        control.markAsDirty();
    });
    // model -> view
    control.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });
    // touched
    dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
}
exports.setUpControl = setUpControl;
function _throwError(dir, message) {
    var path = dir.path.join(" -> ");
    throw new exceptions_1.BaseException(message + " '" + path + "'");
}
function setProperty(renderer, elementRef, propName, propValue) {
    renderer.setElementProperty(elementRef, propName, propValue);
}
exports.setProperty = setProperty;
function isPropertyUpdated(changes, viewModel) {
    if (!collection_1.StringMapWrapper.contains(changes, "model"))
        return false;
    var change = changes["model"];
    if (change.isFirstChange())
        return true;
    return !lang_1.looseIdentical(viewModel, change.currentValue);
}
exports.isPropertyUpdated = isPropertyUpdated;
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
    if (lang_1.isBlank(valueAccessors))
        return null;
    var defaultAccessor;
    var builtinAccessor;
    var customAccessor;
    valueAccessors.forEach(function (v) {
        if (v instanceof default_value_accessor_1.DefaultValueAccessor) {
            defaultAccessor = v;
        }
        else if (v instanceof checkbox_value_accessor_1.CheckboxControlValueAccessor ||
            v instanceof select_control_value_accessor_1.SelectControlValueAccessor) {
            if (lang_1.isPresent(builtinAccessor))
                _throwError(dir, "More than one built-in value accessor matches");
            builtinAccessor = v;
        }
        else {
            if (lang_1.isPresent(customAccessor))
                _throwError(dir, "More than one custom value accessor matches");
            customAccessor = v;
        }
    });
    if (lang_1.isPresent(customAccessor))
        return customAccessor;
    if (lang_1.isPresent(builtinAccessor))
        return builtinAccessor;
    if (lang_1.isPresent(defaultAccessor))
        return defaultAccessor;
    _throwError(dir, "No valid value accessor for");
    return null;
}
exports.selectValueAccessor = selectValueAccessor;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","./checkbox_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/checkbox_value_accessor.js","./default_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/default_value_accessor.js","./select_control_value_accessor":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/select_control_value_accessor.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/directives/validators.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var validators_1 = require('../validators');
var lang_2 = require("angular2/src/core/facade/lang");
var REQUIRED_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, { useValue: validators_1.Validators.required, multi: true }));
var RequiredValidator = (function () {
    function RequiredValidator() {
    }
    RequiredValidator = __decorate([
        metadata_1.Directive({
            selector: '[required][ng-control],[required][ng-form-control],[required][ng-model]',
            providers: [REQUIRED_VALIDATOR]
        }), 
        __metadata('design:paramtypes', [])
    ], RequiredValidator);
    return RequiredValidator;
})();
exports.RequiredValidator = RequiredValidator;
function createMinLengthValidator(dir) {
    return validators_1.Validators.minLength(dir.minLength);
}
var MIN_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, {
    useFactory: createMinLengthValidator,
    deps: [di_1.forwardRef(function () { return MinLengthValidator; })],
    multi: true
}));
var MinLengthValidator = (function () {
    function MinLengthValidator(minLength) {
        this.minLength = lang_2.NumberWrapper.parseInt(minLength, 10);
    }
    MinLengthValidator = __decorate([
        metadata_1.Directive({
            selector: '[minlength][ng-control],[minlength][ng-form-control],[minlength][ng-model]',
            providers: [MIN_LENGTH_VALIDATOR]
        }),
        __param(0, metadata_1.Attribute("minlength")), 
        __metadata('design:paramtypes', [String])
    ], MinLengthValidator);
    return MinLengthValidator;
})();
exports.MinLengthValidator = MinLengthValidator;
function createMaxLengthValidator(dir) {
    return validators_1.Validators.maxLength(dir.maxLength);
}
var MAX_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new di_1.Provider(validators_1.NG_VALIDATORS, {
    useFactory: createMaxLengthValidator,
    deps: [di_1.forwardRef(function () { return MaxLengthValidator; })],
    multi: true
}));
var MaxLengthValidator = (function () {
    function MaxLengthValidator(maxLength) {
        this.maxLength = lang_2.NumberWrapper.parseInt(maxLength, 10);
    }
    MaxLengthValidator = __decorate([
        metadata_1.Directive({
            selector: '[maxlength][ng-control],[maxlength][ng-form-control],[maxlength][ng-model]',
            providers: [MAX_LENGTH_VALIDATOR]
        }),
        __param(0, metadata_1.Attribute("maxlength")), 
        __metadata('design:paramtypes', [String])
    ], MaxLengthValidator);
    return MaxLengthValidator;
})();
exports.MaxLengthValidator = MaxLengthValidator;

},{"../validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/form_builder.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var modelModule = require('./model');
/**
 * Creates a form object from a user-specified configuration.
 *
 * # Example
 *
 * ```
 * import {Component, bootstrap} from 'angular2/angular2';
 * import {FormBuilder, Validators, FORM_DIRECTIVES, ControlGroup} from 'angular2/core';
 *
 * @Component({
 *   selector: 'login-comp',
 *   viewProviders: [FormBuilder],
 *   template: `
 *     <form [control-group]="loginForm">
 *       Login <input control="login">
 *
 *       <div control-group="passwordRetry">
 *         Password <input type="password" control="password">
 *         Confirm password <input type="password" control="passwordConfirmation">
 *       </div>
 *     </form>
 *   `,
 *   directives: [FORM_DIRECTIVES]
 * })
 * class LoginComp {
 *   loginForm: ControlGroup;
 *
 *   constructor(builder: FormBuilder) {
 *     this.loginForm = builder.group({
 *       login: ["", Validators.required],
 *
 *       passwordRetry: builder.group({
 *         password: ["", Validators.required],
 *         passwordConfirmation: ["", Validators.required]
 *       })
 *     });
 *   }
 * }
 *
 * bootstrap(LoginComp);
 * ```
 *
 * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a
 * nested {@link ControlGroup} that defines a `password` and a `passwordConfirmation`
 * {@link Control}:
 *
 * ```
 *  var loginForm = builder.group({
 *    login: ["", Validators.required],
 *
 *    passwordRetry: builder.group({
 *      password: ["", Validators.required],
 *      passwordConfirmation: ["", Validators.required]
 *    })
 *  });
 *
 *  ```
 */
var FormBuilder = (function () {
    function FormBuilder() {
    }
    FormBuilder.prototype.group = function (controlsConfig, extra) {
        if (extra === void 0) { extra = null; }
        var controls = this._reduceControls(controlsConfig);
        var optionals = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "optionals") : null;
        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "validator") : null;
        if (lang_1.isPresent(validator)) {
            return new modelModule.ControlGroup(controls, optionals, validator);
        }
        else {
            return new modelModule.ControlGroup(controls, optionals);
        }
    };
    FormBuilder.prototype.control = function (value, validator) {
        if (validator === void 0) { validator = null; }
        if (lang_1.isPresent(validator)) {
            return new modelModule.Control(value, validator);
        }
        else {
            return new modelModule.Control(value);
        }
    };
    FormBuilder.prototype.array = function (controlsConfig, validator) {
        var _this = this;
        if (validator === void 0) { validator = null; }
        var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
        if (lang_1.isPresent(validator)) {
            return new modelModule.ControlArray(controls, validator);
        }
        else {
            return new modelModule.ControlArray(controls);
        }
    };
    /** @internal */
    FormBuilder.prototype._reduceControls = function (controlsConfig) {
        var _this = this;
        var controls = {};
        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
            controls[controlName] = _this._createControl(controlConfig);
        });
        return controls;
    };
    /** @internal */
    FormBuilder.prototype._createControl = function (controlConfig) {
        if (controlConfig instanceof modelModule.Control ||
            controlConfig instanceof modelModule.ControlGroup ||
            controlConfig instanceof modelModule.ControlArray) {
            return controlConfig;
        }
        else if (lang_1.isArray(controlConfig)) {
            var value = controlConfig[0];
            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
            return this.control(value, validator);
        }
        else {
            return this.control(controlConfig);
        }
    };
    FormBuilder = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], FormBuilder);
    return FormBuilder;
})();
exports.FormBuilder = FormBuilder;

},{"./model":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/model.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var validators_1 = require('./validators');
/**
 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
 */
exports.VALID = "VALID";
/**
 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
 */
exports.INVALID = "INVALID";
function isControl(control) {
    return control instanceof AbstractControl;
}
exports.isControl = isControl;
function _find(control, path) {
    if (lang_1.isBlank(path))
        return null;
    if (!(path instanceof Array)) {
        path = path.split("/");
    }
    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
        return null;
    return collection_1.ListWrapper.reduce(path, function (v, name) {
        if (v instanceof ControlGroup) {
            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
        }
        else if (v instanceof ControlArray) {
            var index = name;
            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
        }
        else {
            return null;
        }
    }, control);
}
/**
 * Omitting from external API doc as this is really an abstract internal concept.
 */
var AbstractControl = (function () {
    function AbstractControl(validator) {
        this.validator = validator;
        /** @internal */
        this._pristine = true;
        /** @internal */
        this._touched = false;
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
        get: function () { return this._value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
        get: function () { return this._status; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
        get: function () { return this._status === exports.VALID; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
        get: function () { return this._errors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
        get: function () { return this._pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
        get: function () { return !this.pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
        get: function () { return this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
        get: function () { return !this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
        get: function () { return this._valueChanges; },
        enumerable: true,
        configurable: true
    });
    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };
    AbstractControl.prototype.markAsDirty = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._pristine = false;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.markAsDirty({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
    AbstractControl.prototype.updateValidity = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._errors = this.validator(this);
        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.updateValidity({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.updateValueAndValidity = function (_a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
        onlySelf = lang_1.normalizeBool(onlySelf);
        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
        this._updateValue();
        if (emitEvent) {
            async_1.ObservableWrapper.callNext(this._valueChanges, this._value);
        }
        this._errors = this.validator(this);
        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
        }
    };
    AbstractControl.prototype.find = function (path) { return _find(this, path); };
    AbstractControl.prototype.getError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
        if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
            return collection_1.StringMapWrapper.get(control._errors, errorCode);
        }
        else {
            return null;
        }
    };
    AbstractControl.prototype.hasError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        return lang_1.isPresent(this.getError(errorCode, path));
    };
    /** @internal */
    AbstractControl.prototype._updateValue = function () { };
    return AbstractControl;
})();
exports.AbstractControl = AbstractControl;
/**
 * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
 * validation state, which is determined by an optional validation function.
 *
 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
 * with {@link ControlGroup} and {@link ControlArray}.
 *
 * # Usage
 *
 * By default, a `Control` is created for every `<input>` or other form component.
 * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
 * bound to a DOM element instead. This `Control` can be configured with a custom
 * validation function.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var Control = (function (_super) {
    __extends(Control, _super);
    function Control(value, validator) {
        if (value === void 0) { value = null; }
        if (validator === void 0) { validator = validators_1.Validators.nullValidator; }
        _super.call(this, validator);
        this._value = value;
        this.updateValidity({ onlySelf: true });
        this._valueChanges = new async_1.EventEmitter();
    }
    /**
     * Set the value of the control to `value`.
     *
     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
     * and not its parent component. If `emitEvent` is `true`, this change will cause a
     * `valueChanges` event on the `Control` to be emitted. Both of these options default to
     * `false`.
     *
     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
     * specified.
     */
    Control.prototype.updateValue = function (value, _a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;
        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
        this._value = value;
        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
            this._onChange(this._value);
        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
    };
    /**
     * Register a listener for change events.
     */
    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };
    return Control;
})(AbstractControl);
exports.Control = Control;
/**
 * Defines a part of a form, of fixed length, that can contain other controls.
 *
 * A `ControlGroup` aggregates the values and errors of each {@link Control} in the group. Thus, if
 * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
 * changes its value, the entire group changes as well.
 *
 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
 * controls, but is of variable length.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlGroup = (function (_super) {
    __extends(ControlGroup, _super);
    function ControlGroup(controls, optionals, validator) {
        if (optionals === void 0) { optionals = null; }
        if (validator === void 0) { validator = validators_1.Validators.group; }
        _super.call(this, validator);
        this.controls = controls;
        this._optionals = lang_1.isPresent(optionals) ? optionals : {};
        this._valueChanges = new async_1.EventEmitter();
        this._setParentForControls();
        this._value = this._reduceValue();
        this.updateValidity({ onlySelf: true });
    }
    ControlGroup.prototype.addControl = function (name, control) {
        this.controls[name] = control;
        control.setParent(this);
    };
    ControlGroup.prototype.removeControl = function (name) { collection_1.StringMapWrapper.delete(this.controls, name); };
    ControlGroup.prototype.include = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, true);
        this.updateValueAndValidity();
    };
    ControlGroup.prototype.exclude = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, false);
        this.updateValueAndValidity();
    };
    ControlGroup.prototype.contains = function (controlName) {
        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
        return c && this._included(controlName);
    };
    /** @internal */
    ControlGroup.prototype._setParentForControls = function () {
        var _this = this;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });
    };
    /** @internal */
    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
    /** @internal */
    ControlGroup.prototype._reduceValue = function () {
        return this._reduceChildren({}, function (acc, control, name) {
            acc[name] = control.value;
            return acc;
        });
    };
    /** @internal */
    ControlGroup.prototype._reduceChildren = function (initValue, fn) {
        var _this = this;
        var res = initValue;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
            if (_this._included(name)) {
                res = fn(res, control, name);
            }
        });
        return res;
    };
    /** @internal */
    ControlGroup.prototype._included = function (controlName) {
        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
    };
    return ControlGroup;
})(AbstractControl);
exports.ControlGroup = ControlGroup;
/**
 * Defines a part of a form, of variable length, that can contain other controls.
 *
 * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
 * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control
 * changes its value, the entire group changes as well.
 *
 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
 * other controls, but is of fixed length.
 *
 * # Adding or removing controls
 *
 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
 * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `ControlArray` directly, as that will result in strange and unexpected behavior such
 * as broken change detection.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlArray = (function (_super) {
    __extends(ControlArray, _super);
    function ControlArray(controls, validator) {
        if (validator === void 0) { validator = validators_1.Validators.array; }
        _super.call(this, validator);
        this.controls = controls;
        this._valueChanges = new async_1.EventEmitter();
        this._setParentForControls();
        this._updateValue();
        this.updateValidity({ onlySelf: true });
    }
    /**
     * Get the {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.at = function (index) { return this.controls[index]; };
    /**
     * Insert a new {@link AbstractControl} at the end of the array.
     */
    ControlArray.prototype.push = function (control) {
        this.controls.push(control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Insert a new {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.insert = function (index, control) {
        collection_1.ListWrapper.insert(this.controls, index, control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Remove the control at the given `index` in the array.
     */
    ControlArray.prototype.removeAt = function (index) {
        collection_1.ListWrapper.removeAt(this.controls, index);
        this.updateValueAndValidity();
    };
    Object.defineProperty(ControlArray.prototype, "length", {
        /**
         * Get the length of the control array.
         */
        get: function () { return this.controls.length; },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ControlArray.prototype._updateValue = function () { this._value = this.controls.map(function (control) { return control.value; }); };
    /** @internal */
    ControlArray.prototype._setParentForControls = function () {
        var _this = this;
        this.controls.forEach(function (control) { control.setParent(_this); });
    };
    return ControlArray;
})(AbstractControl);
exports.ControlArray = ControlArray;

},{"./validators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/forms/validators.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var lang_2 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
exports.NG_VALIDATORS = lang_2.CONST_EXPR(new di_1.OpaqueToken("NgValidators"));
/**
 * Provides a set of validators used by form controls.
 *
 * # Example
 *
 * ```
 * var loginControl = new Control("", Validators.required)
 * ```
 */
var Validators = (function () {
    function Validators() {
    }
    Validators.required = function (control) {
        return lang_1.isBlank(control.value) || control.value == "" ? { "required": true } : null;
    };
    Validators.minLength = function (minLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length < minLength ?
                { "minlength": { "requiredLength": minLength, "actualLength": v.length } } :
                null;
        };
    };
    Validators.maxLength = function (maxLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length > maxLength ?
                { "maxlength": { "requiredLength": maxLength, "actualLength": v.length } } :
                null;
        };
    };
    Validators.nullValidator = function (c) { return null; };
    Validators.compose = function (validators) {
        if (lang_1.isBlank(validators))
            return Validators.nullValidator;
        return function (control) {
            var res = collection_1.ListWrapper.reduce(validators, function (res, validator) {
                var errors = validator(control);
                return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
            }, {});
            return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
        };
    };
    Validators.group = function (group) {
        var res = {};
        collection_1.StringMapWrapper.forEach(group.controls, function (control, name) {
            if (group.contains(name) && lang_1.isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
            }
        });
        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
    };
    Validators.array = function (array) {
        var res = {};
        array.controls.forEach(function (control) {
            if (lang_1.isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
            }
        });
        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
    };
    Validators._mergeErrors = function (control, res) {
        collection_1.StringMapWrapper.forEach(control.errors, function (value, error) {
            if (!collection_1.StringMapWrapper.contains(res, error)) {
                res[error] = [];
            }
            var current = res[error];
            current.push(control);
        });
    };
    return Validators;
})();
exports.Validators = Validators;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var profile_1 = require('../profile/profile');
/**
 * Provides access to explicitly trigger change detection in an application.
 *
 * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When
 * testing, or in some
 * limited application use cases, a developer can also trigger change detection with the
 * `lifecycle.tick()` method.
 *
 * Each Angular application has a single `LifeCycle` instance.
 *
 * # Example
 *
 * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which
 * invokes
 * `lifecycle.tick()` on your behalf.
 *
 * ```javascript
 * bootstrap(MyApp).then((ref:ComponentRef) => {
 *   var lifeCycle = ref.injector.get(LifeCycle);
 *   var myApp = ref.instance;
 *
 *   ref.doSomething();
 *   lifecycle.tick();
 * });
 * ```
 */
var LifeCycle = (function () {
    function LifeCycle() {
    }
    return LifeCycle;
})();
exports.LifeCycle = LifeCycle;
var LifeCycle_ = (function (_super) {
    __extends(LifeCycle_, _super);
    function LifeCycle_(changeDetector, enforceNoNewChanges) {
        if (changeDetector === void 0) { changeDetector = null; }
        if (enforceNoNewChanges === void 0) { enforceNoNewChanges = false; }
        _super.call(this);
        /** @internal */
        this._runningTick = false;
        this._changeDetectors = [];
        if (lang_1.isPresent(changeDetector)) {
            this._changeDetectors.push(changeDetector);
        }
        this._enforceNoNewChanges = enforceNoNewChanges;
    }
    LifeCycle_.prototype.registerWith = function (zone, changeDetector) {
        var _this = this;
        if (changeDetector === void 0) { changeDetector = null; }
        if (lang_1.isPresent(changeDetector)) {
            this._changeDetectors.push(changeDetector);
        }
        zone.overrideOnTurnDone(function () { return _this.tick(); });
    };
    LifeCycle_.prototype.tick = function () {
        if (this._runningTick) {
            throw new exceptions_1.BaseException("LifeCycle.tick is called recursively");
        }
        var s = LifeCycle_._tickScope();
        try {
            this._runningTick = true;
            this._changeDetectors.forEach(function (detector) { return detector.detectChanges(); });
            if (this._enforceNoNewChanges) {
                this._changeDetectors.forEach(function (detector) { return detector.checkNoChanges(); });
            }
        }
        finally {
            this._runningTick = false;
            profile_1.wtfLeave(s);
        }
    };
    LifeCycle_._tickScope = profile_1.wtfCreateScope('LifeCycle#tick()');
    LifeCycle_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [Object, Boolean])
    ], LifeCycle_);
    return LifeCycle_;
})(LifeCycle);
exports.LifeCycle_ = LifeCycle_;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/lifecycle.js":[function(require,module,exports){
'use strict';// Public API for LifeCycle
var life_cycle_1 = require('./life_cycle/life_cycle');
exports.LifeCycle = life_cycle_1.LifeCycle;

},{"./life_cycle/life_cycle":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/life_cycle/life_cycle.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker.js":[function(require,module,exports){
'use strict';// Public API for compiler
var directive_resolver_1 = require('./linker/directive_resolver');
exports.DirectiveResolver = directive_resolver_1.DirectiveResolver;
var compiler_1 = require('./linker/compiler');
exports.Compiler = compiler_1.Compiler;
var view_manager_1 = require('./linker/view_manager');
exports.AppViewManager = view_manager_1.AppViewManager;
var query_list_1 = require('./linker/query_list');
exports.QueryList = query_list_1.QueryList;
var dynamic_component_loader_1 = require('./linker/dynamic_component_loader');
exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
var element_ref_1 = require('./linker/element_ref');
exports.ElementRef = element_ref_1.ElementRef;
var template_ref_1 = require('./linker/template_ref');
exports.TemplateRef = template_ref_1.TemplateRef;
var view_ref_1 = require('./linker/view_ref');
exports.ViewRef = view_ref_1.ViewRef;
exports.ProtoViewRef = view_ref_1.ProtoViewRef;
var view_container_ref_1 = require('./linker/view_container_ref');
exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
var dynamic_component_loader_2 = require('./linker/dynamic_component_loader');
exports.ComponentRef = dynamic_component_loader_2.ComponentRef;

},{"./linker/compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","./linker/directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./linker/dynamic_component_loader":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js","./linker/element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./linker/query_list":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js","./linker/template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./linker/view_container_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js","./linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","./linker/view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var proto_view_factory_1 = require('angular2/src/core/linker/proto_view_factory');
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var template_commands_1 = require('angular2/src/core/linker/template_commands');
/**
 * Low-level service for compiling {@link Component}s into {@link ProtoViewRef ProtoViews}s, which
 * can later be used to create and render a Component instance.
 *
 * Most applications should instead use higher-level {@link DynamicComponentLoader} service, which
 * both compiles and instantiates a Component.
 */
var Compiler = (function () {
    function Compiler() {
    }
    return Compiler;
})();
exports.Compiler = Compiler;
var Compiler_ = (function (_super) {
    __extends(Compiler_, _super);
    function Compiler_(_protoViewFactory) {
        _super.call(this);
        this._protoViewFactory = _protoViewFactory;
    }
    Compiler_.prototype.compileInHost = function (componentType) {
        var metadatas = reflection_1.reflector.annotations(componentType);
        var compiledHostTemplate = null;
        for (var i = 0; i < metadatas.length; i++) {
            var metadata = metadatas[i];
            if (metadata instanceof template_commands_1.CompiledHostTemplate) {
                compiledHostTemplate = metadata;
                break;
            }
        }
        if (lang_1.isBlank(compiledHostTemplate)) {
            throw new exceptions_1.BaseException("No precompiled template for component " + lang_1.stringify(componentType) + " found");
        }
        return async_1.PromiseWrapper.resolve(this._createProtoView(compiledHostTemplate));
    };
    Compiler_.prototype._createProtoView = function (compiledHostTemplate) {
        return this._protoViewFactory.createHost(compiledHostTemplate).ref;
    };
    Compiler_.prototype.clearCache = function () { this._protoViewFactory.clearCache(); };
    Compiler_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [proto_view_factory_1.ProtoViewFactory])
    ], Compiler_);
    return Compiler_;
})(Compiler);
exports.Compiler_ = Compiler_;
function internalCreateProtoView(compiler, compiledHostTemplate) {
    return compiler._createProtoView(compiledHostTemplate);
}
exports.internalCreateProtoView = internalCreateProtoView;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","angular2/src/core/linker/template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var interfaces_1 = require('./interfaces');
function hasLifecycleHook(lcInterface, token) {
    if (!(token instanceof lang_1.Type))
        return false;
    var proto = token.prototype;
    switch (lcInterface) {
        case interfaces_1.LifecycleHooks.AfterContentInit:
            return !!proto.afterContentInit;
        case interfaces_1.LifecycleHooks.AfterContentChecked:
            return !!proto.afterContentChecked;
        case interfaces_1.LifecycleHooks.AfterViewInit:
            return !!proto.afterViewInit;
        case interfaces_1.LifecycleHooks.AfterViewChecked:
            return !!proto.afterViewChecked;
        case interfaces_1.LifecycleHooks.OnChanges:
            return !!proto.onChanges;
        case interfaces_1.LifecycleHooks.DoCheck:
            return !!proto.doCheck;
        case interfaces_1.LifecycleHooks.OnDestroy:
            return !!proto.onDestroy;
        case interfaces_1.LifecycleHooks.OnInit:
            return !!proto.onInit;
        default:
            return false;
    }
}
exports.hasLifecycleHook = hasLifecycleHook;

},{"./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var metadata_1 = require('angular2/src/core/metadata');
var reflection_1 = require('angular2/src/core/reflection/reflection');
/*
 * Resolve a `Type` for {@link DirectiveMetadata}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var DirectiveResolver = (function () {
    function DirectiveResolver() {
    }
    /**
     * Return {@link DirectiveMetadata} for a given `Type`.
     */
    DirectiveResolver.prototype.resolve = function (type) {
        var typeMetadata = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
        if (lang_1.isPresent(typeMetadata)) {
            for (var i = 0; i < typeMetadata.length; i++) {
                var metadata = typeMetadata[i];
                if (metadata instanceof metadata_1.DirectiveMetadata) {
                    var propertyMetadata = reflection_1.reflector.propMetadata(type);
                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata);
                }
            }
        }
        throw new exceptions_1.BaseException("No Directive annotation found on " + lang_1.stringify(type));
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata) {
        var inputs = [];
        var outputs = [];
        var host = {};
        var queries = {};
        collection_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {
            metadata.forEach(function (a) {
                if (a instanceof metadata_1.InputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        inputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        inputs.push(propName);
                    }
                }
                if (a instanceof metadata_1.OutputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        outputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        outputs.push(propName);
                    }
                }
                if (a instanceof metadata_1.HostBindingMetadata) {
                    if (lang_1.isPresent(a.hostPropertyName)) {
                        host[("[" + a.hostPropertyName + "]")] = propName;
                    }
                    else {
                        host[("[" + propName + "]")] = propName;
                    }
                }
                if (a instanceof metadata_1.HostListenerMetadata) {
                    var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';
                    host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
                }
                if (a instanceof metadata_1.ContentChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ViewChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ContentChildMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof metadata_1.ViewChildMetadata) {
                    queries[propName] = a;
                }
            });
        });
        return this._merge(dm, inputs, outputs, host, queries);
    };
    DirectiveResolver.prototype._merge = function (dm, inputs, outputs, host, queries) {
        var mergedInputs = lang_1.isPresent(dm.inputs) ? collection_1.ListWrapper.concat(dm.inputs, inputs) : inputs;
        var mergedOutputs = lang_1.isPresent(dm.outputs) ? collection_1.ListWrapper.concat(dm.outputs, outputs) : outputs;
        var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;
        var mergedQueries = lang_1.isPresent(dm.queries) ? collection_1.StringMapWrapper.merge(dm.queries, queries) : queries;
        if (dm instanceof metadata_1.ComponentMetadata) {
            return new metadata_1.ComponentMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                moduleId: dm.moduleId,
                queries: mergedQueries,
                changeDetection: dm.changeDetection,
                providers: dm.providers,
                viewProviders: dm.viewProviders
            });
        }
        else {
            return new metadata_1.DirectiveMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                moduleId: dm.moduleId,
                queries: mergedQueries,
                providers: dm.providers
            });
        }
    };
    DirectiveResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DirectiveResolver);
    return DirectiveResolver;
})();
exports.DirectiveResolver = DirectiveResolver;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/dynamic_component_loader.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var compiler_1 = require('./compiler');
var lang_1 = require('angular2/src/core/facade/lang');
var view_manager_1 = require('angular2/src/core/linker/view_manager');
/**
 * Represents an instance of a Component created via {@link DynamicComponentLoader}.
 *
 * `ComponentRef` provides access to the Component Instance as well other objects related to this
 * Component Instance and allows you to destroy the Component Instance via the {@link #dispose}
 * method.
 */
var ComponentRef = (function () {
    function ComponentRef() {
    }
    Object.defineProperty(ComponentRef.prototype, "hostView", {
        /**
         * The {@link ViewRef} of the Host View of this Component instance.
         */
        get: function () { return this.location.parentView; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "hostComponent", {
        /**
         * @internal
         *
         * The instance of the component.
         *
         * TODO(i): this api should be removed
         */
        get: function () { return this.instance; },
        enumerable: true,
        configurable: true
    });
    return ComponentRef;
})();
exports.ComponentRef = ComponentRef;
var ComponentRef_ = (function (_super) {
    __extends(ComponentRef_, _super);
    /**
     * TODO(i): refactor into public/private fields
     */
    function ComponentRef_(location, instance, componentType, injector, _dispose) {
        _super.call(this);
        this._dispose = _dispose;
        this.location = location;
        this.instance = instance;
        this.componentType = componentType;
        this.injector = injector;
    }
    Object.defineProperty(ComponentRef_.prototype, "hostComponentType", {
        /**
         * @internal
         *
         * Returns the type of this Component instance.
         *
         * TODO(i): this api should be removed
         */
        get: function () { return this.componentType; },
        enumerable: true,
        configurable: true
    });
    ComponentRef_.prototype.dispose = function () { this._dispose(); };
    return ComponentRef_;
})(ComponentRef);
exports.ComponentRef_ = ComponentRef_;
/**
 * Service for instantiating a Component and attaching it to a View at a specified location.
 */
var DynamicComponentLoader = (function () {
    function DynamicComponentLoader() {
    }
    return DynamicComponentLoader;
})();
exports.DynamicComponentLoader = DynamicComponentLoader;
var DynamicComponentLoader_ = (function (_super) {
    __extends(DynamicComponentLoader_, _super);
    function DynamicComponentLoader_(_compiler, _viewManager) {
        _super.call(this);
        this._compiler = _compiler;
        this._viewManager = _viewManager;
    }
    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelector, injector, onDispose) {
        var _this = this;
        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {
            var hostViewRef = _this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
            var newLocation = _this._viewManager.getHostElement(hostViewRef);
            var component = _this._viewManager.getComponent(newLocation);
            var dispose = function () {
                _this._viewManager.destroyRootHostView(hostViewRef);
                if (lang_1.isPresent(onDispose)) {
                    onDispose();
                }
            };
            return new ComponentRef_(newLocation, component, type, injector, dispose);
        });
    };
    DynamicComponentLoader_.prototype.loadIntoLocation = function (type, hostLocation, anchorName, providers) {
        if (providers === void 0) { providers = null; }
        return this.loadNextToLocation(type, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), providers);
    };
    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers) {
        var _this = this;
        if (providers === void 0) { providers = null; }
        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {
            var viewContainer = _this._viewManager.getViewContainer(location);
            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, providers);
            var newLocation = _this._viewManager.getHostElement(hostViewRef);
            var component = _this._viewManager.getComponent(newLocation);
            var dispose = function () {
                var index = viewContainer.indexOf(hostViewRef);
                if (index !== -1) {
                    viewContainer.remove(index);
                }
            };
            return new ComponentRef_(newLocation, component, type, null, dispose);
        });
    };
    DynamicComponentLoader_ = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [compiler_1.Compiler, view_manager_1.AppViewManager])
    ], DynamicComponentLoader_);
    return DynamicComponentLoader_;
})(DynamicComponentLoader);
exports.DynamicComponentLoader_ = DynamicComponentLoader_;

},{"./compiler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/compiler.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_binder.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var ElementBinder = (function () {
    function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective, nestedProtoView) {
        this.index = index;
        this.parent = parent;
        this.distanceToParent = distanceToParent;
        this.protoElementInjector = protoElementInjector;
        this.componentDirective = componentDirective;
        this.nestedProtoView = nestedProtoView;
        if (lang_1.isBlank(index)) {
            throw new exceptions_1.BaseException('null index not allowed.');
        }
    }
    return ElementBinder;
})();
exports.ElementBinder = ElementBinder;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var injector_1 = require('angular2/src/core/di/injector');
var provider_1 = require('angular2/src/core/di/provider');
var di_2 = require('../metadata/di');
var avmModule = require('./view_manager');
var view_container_ref_1 = require('./view_container_ref');
var element_ref_1 = require('./element_ref');
var template_ref_1 = require('./template_ref');
var directives_1 = require('../metadata/directives');
var directive_lifecycle_reflector_1 = require('./directive_lifecycle_reflector');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var query_list_1 = require('./query_list');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var event_config_1 = require('angular2/src/core/linker/event_config');
var pipe_provider_1 = require('angular2/src/core/pipes/pipe_provider');
var interfaces_1 = require('./interfaces');
var view_container_ref_2 = require("./view_container_ref");
var _staticKeys;
var StaticKeys = (function () {
    function StaticKeys() {
        this.viewManagerId = di_1.Key.get(avmModule.AppViewManager).id;
        this.templateRefId = di_1.Key.get(template_ref_1.TemplateRef).id;
        this.viewContainerId = di_1.Key.get(view_container_ref_1.ViewContainerRef).id;
        this.changeDetectorRefId = di_1.Key.get(change_detection_1.ChangeDetectorRef).id;
        this.elementRefId = di_1.Key.get(element_ref_1.ElementRef).id;
    }
    StaticKeys.instance = function () {
        if (lang_1.isBlank(_staticKeys))
            _staticKeys = new StaticKeys();
        return _staticKeys;
    };
    return StaticKeys;
})();
exports.StaticKeys = StaticKeys;
var TreeNode = (function () {
    function TreeNode(parent) {
        if (lang_1.isPresent(parent)) {
            parent.addChild(this);
        }
        else {
            this._parent = null;
        }
    }
    TreeNode.prototype.addChild = function (child) { child._parent = this; };
    TreeNode.prototype.remove = function () { this._parent = null; };
    Object.defineProperty(TreeNode.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    return TreeNode;
})();
exports.TreeNode = TreeNode;
var DirectiveDependency = (function (_super) {
    __extends(DirectiveDependency, _super);
    function DirectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties, attributeName, queryDecorator) {
        _super.call(this, key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
        this.attributeName = attributeName;
        this.queryDecorator = queryDecorator;
        this._verify();
    }
    /** @internal */
    DirectiveDependency.prototype._verify = function () {
        var count = 0;
        if (lang_1.isPresent(this.queryDecorator))
            count++;
        if (lang_1.isPresent(this.attributeName))
            count++;
        if (count > 1)
            throw new exceptions_1.BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
    };
    DirectiveDependency.createFrom = function (d) {
        return new DirectiveDependency(d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
    };
    DirectiveDependency._attributeName = function (properties) {
        var p = collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.AttributeMetadata; });
        return lang_1.isPresent(p) ? p.attributeName : null;
    };
    DirectiveDependency._query = function (properties) {
        return collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.QueryMetadata; });
    };
    return DirectiveDependency;
})(di_1.Dependency);
exports.DirectiveDependency = DirectiveDependency;
var DirectiveProvider = (function (_super) {
    __extends(DirectiveProvider, _super);
    function DirectiveProvider(key, factory, deps, metadata, providers, viewProviders) {
        _super.call(this, key, [new provider_1.ResolvedFactory(factory, deps)], false);
        this.metadata = metadata;
        this.providers = providers;
        this.viewProviders = viewProviders;
        this.callOnDestroy = directive_lifecycle_reflector_1.hasLifecycleHook(interfaces_1.LifecycleHooks.OnDestroy, key.token);
    }
    Object.defineProperty(DirectiveProvider.prototype, "displayName", {
        get: function () { return this.key.displayName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveProvider.prototype, "queries", {
        get: function () {
            if (lang_1.isBlank(this.metadata.queries))
                return [];
            var res = [];
            collection_1.StringMapWrapper.forEach(this.metadata.queries, function (meta, fieldName) {
                var setter = reflection_1.reflector.setter(fieldName);
                res.push(new QueryMetadataWithSetter(setter, meta));
            });
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveProvider.prototype, "eventEmitters", {
        get: function () {
            return lang_1.isPresent(this.metadata) && lang_1.isPresent(this.metadata.outputs) ? this.metadata.outputs :
                [];
        },
        enumerable: true,
        configurable: true
    });
    DirectiveProvider.createFromProvider = function (provider, meta) {
        if (lang_1.isBlank(meta)) {
            meta = new directives_1.DirectiveMetadata();
        }
        var rb = provider_1.resolveProvider(provider);
        var rf = rb.resolvedFactories[0];
        var deps = rf.dependencies.map(DirectiveDependency.createFrom);
        var providers = lang_1.isPresent(meta.providers) ? meta.providers : [];
        var viewBindigs = meta instanceof directives_1.ComponentMetadata && lang_1.isPresent(meta.viewProviders) ?
            meta.viewProviders :
            [];
        return new DirectiveProvider(rb.key, rf.factory, deps, meta, providers, viewBindigs);
    };
    DirectiveProvider.createFromType = function (type, annotation) {
        var provider = new di_1.Provider(type, { useClass: type });
        return DirectiveProvider.createFromProvider(provider, annotation);
    };
    return DirectiveProvider;
})(provider_1.ResolvedProvider_);
exports.DirectiveProvider = DirectiveProvider;
// TODO(rado): benchmark and consider rolling in as ElementInjector fields.
var PreBuiltObjects = (function () {
    function PreBuiltObjects(viewManager, view, elementRef, templateRef) {
        this.viewManager = viewManager;
        this.view = view;
        this.elementRef = elementRef;
        this.templateRef = templateRef;
        this.nestedView = null;
    }
    return PreBuiltObjects;
})();
exports.PreBuiltObjects = PreBuiltObjects;
var QueryMetadataWithSetter = (function () {
    function QueryMetadataWithSetter(setter, metadata) {
        this.setter = setter;
        this.metadata = metadata;
    }
    return QueryMetadataWithSetter;
})();
exports.QueryMetadataWithSetter = QueryMetadataWithSetter;
var EventEmitterAccessor = (function () {
    function EventEmitterAccessor(eventName, getter) {
        this.eventName = eventName;
        this.getter = getter;
    }
    EventEmitterAccessor.prototype.subscribe = function (view, boundElementIndex, directive) {
        var _this = this;
        var eventEmitter = this.getter(directive);
        return async_1.ObservableWrapper.subscribe(eventEmitter, function (eventObj) { return view.triggerEventHandlers(_this.eventName, eventObj, boundElementIndex); });
    };
    return EventEmitterAccessor;
})();
exports.EventEmitterAccessor = EventEmitterAccessor;
function _createEventEmitterAccessors(bwv) {
    var provider = bwv.provider;
    if (!(provider instanceof DirectiveProvider))
        return [];
    var db = provider;
    return db.eventEmitters.map(function (eventConfig) {
        var parsedEvent = event_config_1.EventConfig.parse(eventConfig);
        return new EventEmitterAccessor(parsedEvent.eventName, reflection_1.reflector.getter(parsedEvent.fieldName));
    });
}
function _createProtoQueryRefs(providers) {
    var res = [];
    collection_1.ListWrapper.forEachWithIndex(providers, function (b, i) {
        if (b.provider instanceof DirectiveProvider) {
            var directiveProvider = b.provider;
            // field queries
            var queries = directiveProvider.queries;
            queries.forEach(function (q) { return res.push(new ProtoQueryRef(i, q.setter, q.metadata)); });
            // queries passed into the constructor.
            // TODO: remove this after constructor queries are no longer supported
            var deps = directiveProvider.resolvedFactory.dependencies;
            deps.forEach(function (d) {
                if (lang_1.isPresent(d.queryDecorator))
                    res.push(new ProtoQueryRef(i, null, d.queryDecorator));
            });
        }
    });
    return res;
}
var ProtoElementInjector = (function () {
    function ProtoElementInjector(parent, index, bwv, distanceToParent, _firstProviderIsComponent, directiveVariableBindings) {
        this.parent = parent;
        this.index = index;
        this.distanceToParent = distanceToParent;
        this.directiveVariableBindings = directiveVariableBindings;
        this._firstProviderIsComponent = _firstProviderIsComponent;
        var length = bwv.length;
        this.protoInjector = new injector_1.ProtoInjector(bwv);
        this.eventEmitterAccessors = collection_1.ListWrapper.createFixedSize(length);
        for (var i = 0; i < length; ++i) {
            this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
        }
        this.protoQueryRefs = _createProtoQueryRefs(bwv);
    }
    ProtoElementInjector.create = function (parent, index, providers, firstProviderIsComponent, distanceToParent, directiveVariableBindings) {
        var bd = [];
        ProtoElementInjector._createDirectiveProviderWithVisibility(providers, bd, firstProviderIsComponent);
        if (firstProviderIsComponent) {
            ProtoElementInjector._createViewProvidersWithVisibility(providers, bd);
        }
        ProtoElementInjector._createProvidersWithVisibility(providers, bd);
        return new ProtoElementInjector(parent, index, bd, distanceToParent, firstProviderIsComponent, directiveVariableBindings);
    };
    ProtoElementInjector._createDirectiveProviderWithVisibility = function (dirProviders, bd, firstProviderIsComponent) {
        dirProviders.forEach(function (dirProvider) {
            bd.push(ProtoElementInjector._createProviderWithVisibility(firstProviderIsComponent, dirProvider, dirProviders, dirProvider));
        });
    };
    ProtoElementInjector._createProvidersWithVisibility = function (dirProviders, bd) {
        var providersFromAllDirectives = [];
        dirProviders.forEach(function (dirProvider) {
            providersFromAllDirectives =
                collection_1.ListWrapper.concat(providersFromAllDirectives, dirProvider.providers);
        });
        var resolved = di_1.Injector.resolve(providersFromAllDirectives);
        resolved.forEach(function (b) { return bd.push(new injector_1.ProviderWithVisibility(b, injector_1.Visibility.Public)); });
    };
    ProtoElementInjector._createProviderWithVisibility = function (firstProviderIsComponent, dirProvider, dirProviders, provider) {
        var isComponent = firstProviderIsComponent && dirProviders[0] === dirProvider;
        return new injector_1.ProviderWithVisibility(provider, isComponent ? injector_1.Visibility.PublicAndPrivate : injector_1.Visibility.Public);
    };
    ProtoElementInjector._createViewProvidersWithVisibility = function (dirProviders, bd) {
        var resolvedViewProviders = di_1.Injector.resolve(dirProviders[0].viewProviders);
        resolvedViewProviders.forEach(function (b) { return bd.push(new injector_1.ProviderWithVisibility(b, injector_1.Visibility.Private)); });
    };
    ProtoElementInjector.prototype.instantiate = function (parent) {
        return new ElementInjector(this, parent);
    };
    ProtoElementInjector.prototype.directParent = function () { return this.distanceToParent < 2 ? this.parent : null; };
    Object.defineProperty(ProtoElementInjector.prototype, "hasBindings", {
        get: function () { return this.eventEmitterAccessors.length > 0; },
        enumerable: true,
        configurable: true
    });
    ProtoElementInjector.prototype.getProviderAtIndex = function (index) { return this.protoInjector.getProviderAtIndex(index); };
    return ProtoElementInjector;
})();
exports.ProtoElementInjector = ProtoElementInjector;
var _Context = (function () {
    function _Context(element, componentElement, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.injector = injector;
    }
    return _Context;
})();
var ElementInjector = (function (_super) {
    __extends(ElementInjector, _super);
    function ElementInjector(_proto, parent) {
        var _this = this;
        _super.call(this, parent);
        this._preBuiltObjects = null;
        this._proto = _proto;
        this._injector =
            new di_1.Injector(this._proto.protoInjector, null, this, function () { return _this._debugContext(); });
        // we couple ourselves to the injector strategy to avoid polymoprhic calls
        var injectorStrategy = this._injector.internalStrategy;
        this._strategy = injectorStrategy instanceof injector_1.InjectorInlineStrategy ?
            new ElementInjectorInlineStrategy(injectorStrategy, this) :
            new ElementInjectorDynamicStrategy(injectorStrategy, this);
        this.hydrated = false;
        this._queryStrategy = this._buildQueryStrategy();
    }
    ElementInjector.prototype.dehydrate = function () {
        this.hydrated = false;
        this._host = null;
        this._preBuiltObjects = null;
        this._strategy.callOnDestroy();
        this._strategy.dehydrate();
        this._queryStrategy.dehydrate();
    };
    ElementInjector.prototype.hydrate = function (imperativelyCreatedInjector, host, preBuiltObjects) {
        this._host = host;
        this._preBuiltObjects = preBuiltObjects;
        this._reattachInjectors(imperativelyCreatedInjector);
        this._queryStrategy.hydrate();
        this._strategy.hydrate();
        this.hydrated = true;
    };
    ElementInjector.prototype._debugContext = function () {
        var p = this._preBuiltObjects;
        var index = p.elementRef.boundElementIndex - p.view.elementOffset;
        var c = this._preBuiltObjects.view.getDebugContext(index, null);
        return lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
    };
    ElementInjector.prototype._reattachInjectors = function (imperativelyCreatedInjector) {
        // Dynamically-loaded component in the template. Not a root ElementInjector.
        if (lang_1.isPresent(this._parent)) {
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                // The imperative injector is similar to having an element between
                // the dynamic-loaded component and its parent => no boundaries.
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
            }
            else {
                this._reattachInjector(this._injector, this._parent._injector, false);
            }
        }
        else if (lang_1.isPresent(this._host)) {
            // The imperative injector is similar to having an element between
            // the dynamic-loaded component and its parent => no boundary between
            // the component and imperativelyCreatedInjector.
            // But since it is a root ElementInjector, we need to create a boundary
            // between imperativelyCreatedInjector and _host.
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
            }
            else {
                this._reattachInjector(this._injector, this._host._injector, true);
            }
        }
        else {
            if (lang_1.isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
            }
        }
    };
    ElementInjector.prototype._reattachInjector = function (injector, parentInjector, isBoundary) {
        injector.internalStrategy.attach(parentInjector, isBoundary);
    };
    ElementInjector.prototype.hasVariableBinding = function (name) {
        var vb = this._proto.directiveVariableBindings;
        return lang_1.isPresent(vb) && vb.has(name);
    };
    ElementInjector.prototype.getVariableBinding = function (name) {
        var index = this._proto.directiveVariableBindings.get(name);
        return lang_1.isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();
    };
    ElementInjector.prototype.get = function (token) { return this._injector.get(token); };
    ElementInjector.prototype.hasDirective = function (type) { return lang_1.isPresent(this._injector.getOptional(type)); };
    ElementInjector.prototype.getEventEmitterAccessors = function () { return this._proto.eventEmitterAccessors; };
    ElementInjector.prototype.getDirectiveVariableBindings = function () {
        return this._proto.directiveVariableBindings;
    };
    ElementInjector.prototype.getComponent = function () { return this._strategy.getComponent(); };
    ElementInjector.prototype.getInjector = function () { return this._injector; };
    ElementInjector.prototype.getElementRef = function () { return this._preBuiltObjects.elementRef; };
    ElementInjector.prototype.getViewContainerRef = function () {
        return new view_container_ref_2.ViewContainerRef_(this._preBuiltObjects.viewManager, this.getElementRef());
    };
    ElementInjector.prototype.getNestedView = function () { return this._preBuiltObjects.nestedView; };
    ElementInjector.prototype.getView = function () { return this._preBuiltObjects.view; };
    ElementInjector.prototype.directParent = function () { return this._proto.distanceToParent < 2 ? this.parent : null; };
    ElementInjector.prototype.isComponentKey = function (key) { return this._strategy.isComponentKey(key); };
    ElementInjector.prototype.getDependency = function (injector, provider, dep) {
        var key = dep.key;
        if (provider instanceof DirectiveProvider) {
            var dirDep = dep;
            var dirProvider = provider;
            var staticKeys = StaticKeys.instance();
            if (key.id === staticKeys.viewManagerId)
                return this._preBuiltObjects.viewManager;
            if (lang_1.isPresent(dirDep.attributeName))
                return this._buildAttribute(dirDep);
            if (lang_1.isPresent(dirDep.queryDecorator))
                return this._queryStrategy.findQuery(dirDep.queryDecorator).list;
            if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
                // We provide the component's view change detector to components and
                // the surrounding component's change detector to directives.
                if (dirProvider.metadata instanceof directives_1.ComponentMetadata) {
                    var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                    return componentView.changeDetector.ref;
                }
                else {
                    return this._preBuiltObjects.view.changeDetector.ref;
                }
            }
            if (dirDep.key.id === StaticKeys.instance().elementRefId) {
                return this.getElementRef();
            }
            if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
                return this.getViewContainerRef();
            }
            if (dirDep.key.id === StaticKeys.instance().templateRefId) {
                if (lang_1.isBlank(this._preBuiltObjects.templateRef)) {
                    if (dirDep.optional) {
                        return null;
                    }
                    throw new di_1.NoProviderError(null, dirDep.key);
                }
                return this._preBuiltObjects.templateRef;
            }
        }
        else if (provider instanceof pipe_provider_1.PipeProvider) {
            if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
                var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                return componentView.changeDetector.ref;
            }
        }
        return injector_1.UNDEFINED;
    };
    ElementInjector.prototype._buildAttribute = function (dep) {
        var attributes = this._proto.attributes;
        if (lang_1.isPresent(attributes) && attributes.has(dep.attributeName)) {
            return attributes.get(dep.attributeName);
        }
        else {
            return null;
        }
    };
    ElementInjector.prototype.addDirectivesMatchingQuery = function (query, list) {
        var templateRef = lang_1.isBlank(this._preBuiltObjects) ? null : this._preBuiltObjects.templateRef;
        if (query.selector === template_ref_1.TemplateRef && lang_1.isPresent(templateRef)) {
            list.push(templateRef);
        }
        this._strategy.addDirectivesMatchingQuery(query, list);
    };
    ElementInjector.prototype._buildQueryStrategy = function () {
        if (this._proto.protoQueryRefs.length === 0) {
            return _emptyQueryStrategy;
        }
        else if (this._proto.protoQueryRefs.length <=
            InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES) {
            return new InlineQueryStrategy(this);
        }
        else {
            return new DynamicQueryStrategy(this);
        }
    };
    ElementInjector.prototype.link = function (parent) { parent.addChild(this); };
    ElementInjector.prototype.unlink = function () { this.remove(); };
    ElementInjector.prototype.getDirectiveAtIndex = function (index) { return this._injector.getAt(index); };
    ElementInjector.prototype.hasInstances = function () { return this._proto.hasBindings && this.hydrated; };
    ElementInjector.prototype.getHost = function () { return this._host; };
    ElementInjector.prototype.getBoundElementIndex = function () { return this._proto.index; };
    ElementInjector.prototype.getRootViewInjectors = function () {
        if (!this.hydrated)
            return [];
        var view = this._preBuiltObjects.view;
        var nestedView = view.getNestedView(view.elementOffset + this.getBoundElementIndex());
        return lang_1.isPresent(nestedView) ? nestedView.rootElementInjectors : [];
    };
    ElementInjector.prototype.afterViewChecked = function () { this._queryStrategy.updateViewQueries(); };
    ElementInjector.prototype.afterContentChecked = function () { this._queryStrategy.updateContentQueries(); };
    ElementInjector.prototype.traverseAndSetQueriesAsDirty = function () {
        var inj = this;
        while (lang_1.isPresent(inj)) {
            inj._setQueriesAsDirty();
            inj = inj.parent;
        }
    };
    ElementInjector.prototype._setQueriesAsDirty = function () {
        this._queryStrategy.setContentQueriesAsDirty();
        if (lang_1.isPresent(this._host))
            this._host._queryStrategy.setViewQueriesAsDirty();
    };
    return ElementInjector;
})(TreeNode);
exports.ElementInjector = ElementInjector;
var _EmptyQueryStrategy = (function () {
    function _EmptyQueryStrategy() {
    }
    _EmptyQueryStrategy.prototype.setContentQueriesAsDirty = function () { };
    _EmptyQueryStrategy.prototype.setViewQueriesAsDirty = function () { };
    _EmptyQueryStrategy.prototype.hydrate = function () { };
    _EmptyQueryStrategy.prototype.dehydrate = function () { };
    _EmptyQueryStrategy.prototype.updateContentQueries = function () { };
    _EmptyQueryStrategy.prototype.updateViewQueries = function () { };
    _EmptyQueryStrategy.prototype.findQuery = function (query) {
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    return _EmptyQueryStrategy;
})();
var _emptyQueryStrategy = new _EmptyQueryStrategy();
var InlineQueryStrategy = (function () {
    function InlineQueryStrategy(ei) {
        var protoRefs = ei._proto.protoQueryRefs;
        if (protoRefs.length > 0)
            this.query0 = new QueryRef(protoRefs[0], ei);
        if (protoRefs.length > 1)
            this.query1 = new QueryRef(protoRefs[1], ei);
        if (protoRefs.length > 2)
            this.query2 = new QueryRef(protoRefs[2], ei);
    }
    InlineQueryStrategy.prototype.setContentQueriesAsDirty = function () {
        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery)
            this.query0.dirty = true;
        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery)
            this.query1.dirty = true;
        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery)
            this.query2.dirty = true;
    };
    InlineQueryStrategy.prototype.setViewQueriesAsDirty = function () {
        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery)
            this.query0.dirty = true;
        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery)
            this.query1.dirty = true;
        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery)
            this.query2.dirty = true;
    };
    InlineQueryStrategy.prototype.hydrate = function () {
        if (lang_1.isPresent(this.query0))
            this.query0.hydrate();
        if (lang_1.isPresent(this.query1))
            this.query1.hydrate();
        if (lang_1.isPresent(this.query2))
            this.query2.hydrate();
    };
    InlineQueryStrategy.prototype.dehydrate = function () {
        if (lang_1.isPresent(this.query0))
            this.query0.dehydrate();
        if (lang_1.isPresent(this.query1))
            this.query1.dehydrate();
        if (lang_1.isPresent(this.query2))
            this.query2.dehydrate();
    };
    InlineQueryStrategy.prototype.updateContentQueries = function () {
        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery) {
            this.query0.update();
        }
        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery) {
            this.query1.update();
        }
        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery) {
            this.query2.update();
        }
    };
    InlineQueryStrategy.prototype.updateViewQueries = function () {
        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery) {
            this.query0.update();
        }
        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery) {
            this.query1.update();
        }
        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery) {
            this.query2.update();
        }
    };
    InlineQueryStrategy.prototype.findQuery = function (query) {
        if (lang_1.isPresent(this.query0) && this.query0.protoQueryRef.query === query) {
            return this.query0;
        }
        if (lang_1.isPresent(this.query1) && this.query1.protoQueryRef.query === query) {
            return this.query1;
        }
        if (lang_1.isPresent(this.query2) && this.query2.protoQueryRef.query === query) {
            return this.query2;
        }
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES = 3;
    return InlineQueryStrategy;
})();
var DynamicQueryStrategy = (function () {
    function DynamicQueryStrategy(ei) {
        this.queries = ei._proto.protoQueryRefs.map(function (p) { return new QueryRef(p, ei); });
    }
    DynamicQueryStrategy.prototype.setContentQueriesAsDirty = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (!q.isViewQuery)
                q.dirty = true;
        }
    };
    DynamicQueryStrategy.prototype.setViewQueriesAsDirty = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.isViewQuery)
                q.dirty = true;
        }
    };
    DynamicQueryStrategy.prototype.hydrate = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            q.hydrate();
        }
    };
    DynamicQueryStrategy.prototype.dehydrate = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            q.dehydrate();
        }
    };
    DynamicQueryStrategy.prototype.updateContentQueries = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (!q.isViewQuery) {
                q.update();
            }
        }
    };
    DynamicQueryStrategy.prototype.updateViewQueries = function () {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.isViewQuery) {
                q.update();
            }
        }
    };
    DynamicQueryStrategy.prototype.findQuery = function (query) {
        for (var i = 0; i < this.queries.length; ++i) {
            var q = this.queries[i];
            if (q.protoQueryRef.query === query) {
                return q;
            }
        }
        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
    };
    return DynamicQueryStrategy;
})();
/**
 * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
 * In such a case, inlining fields is beneficial for performances.
 */
var ElementInjectorInlineStrategy = (function () {
    function ElementInjectorInlineStrategy(injectorStrategy, _ei) {
        this.injectorStrategy = injectorStrategy;
        this._ei = _ei;
    }
    ElementInjectorInlineStrategy.prototype.hydrate = function () {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        i.resetConstructionCounter();
        if (p.provider0 instanceof DirectiveProvider && lang_1.isPresent(p.keyId0) && i.obj0 === injector_1.UNDEFINED)
            i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
        if (p.provider1 instanceof DirectiveProvider && lang_1.isPresent(p.keyId1) && i.obj1 === injector_1.UNDEFINED)
            i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
        if (p.provider2 instanceof DirectiveProvider && lang_1.isPresent(p.keyId2) && i.obj2 === injector_1.UNDEFINED)
            i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
        if (p.provider3 instanceof DirectiveProvider && lang_1.isPresent(p.keyId3) && i.obj3 === injector_1.UNDEFINED)
            i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
        if (p.provider4 instanceof DirectiveProvider && lang_1.isPresent(p.keyId4) && i.obj4 === injector_1.UNDEFINED)
            i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
        if (p.provider5 instanceof DirectiveProvider && lang_1.isPresent(p.keyId5) && i.obj5 === injector_1.UNDEFINED)
            i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
        if (p.provider6 instanceof DirectiveProvider && lang_1.isPresent(p.keyId6) && i.obj6 === injector_1.UNDEFINED)
            i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
        if (p.provider7 instanceof DirectiveProvider && lang_1.isPresent(p.keyId7) && i.obj7 === injector_1.UNDEFINED)
            i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
        if (p.provider8 instanceof DirectiveProvider && lang_1.isPresent(p.keyId8) && i.obj8 === injector_1.UNDEFINED)
            i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
        if (p.provider9 instanceof DirectiveProvider && lang_1.isPresent(p.keyId9) && i.obj9 === injector_1.UNDEFINED)
            i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
    };
    ElementInjectorInlineStrategy.prototype.dehydrate = function () {
        var i = this.injectorStrategy;
        i.obj0 = injector_1.UNDEFINED;
        i.obj1 = injector_1.UNDEFINED;
        i.obj2 = injector_1.UNDEFINED;
        i.obj3 = injector_1.UNDEFINED;
        i.obj4 = injector_1.UNDEFINED;
        i.obj5 = injector_1.UNDEFINED;
        i.obj6 = injector_1.UNDEFINED;
        i.obj7 = injector_1.UNDEFINED;
        i.obj8 = injector_1.UNDEFINED;
        i.obj9 = injector_1.UNDEFINED;
    };
    ElementInjectorInlineStrategy.prototype.callOnDestroy = function () {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        if (p.provider0 instanceof DirectiveProvider &&
            p.provider0.callOnDestroy) {
            i.obj0.onDestroy();
        }
        if (p.provider1 instanceof DirectiveProvider &&
            p.provider1.callOnDestroy) {
            i.obj1.onDestroy();
        }
        if (p.provider2 instanceof DirectiveProvider &&
            p.provider2.callOnDestroy) {
            i.obj2.onDestroy();
        }
        if (p.provider3 instanceof DirectiveProvider &&
            p.provider3.callOnDestroy) {
            i.obj3.onDestroy();
        }
        if (p.provider4 instanceof DirectiveProvider &&
            p.provider4.callOnDestroy) {
            i.obj4.onDestroy();
        }
        if (p.provider5 instanceof DirectiveProvider &&
            p.provider5.callOnDestroy) {
            i.obj5.onDestroy();
        }
        if (p.provider6 instanceof DirectiveProvider &&
            p.provider6.callOnDestroy) {
            i.obj6.onDestroy();
        }
        if (p.provider7 instanceof DirectiveProvider &&
            p.provider7.callOnDestroy) {
            i.obj7.onDestroy();
        }
        if (p.provider8 instanceof DirectiveProvider &&
            p.provider8.callOnDestroy) {
            i.obj8.onDestroy();
        }
        if (p.provider9 instanceof DirectiveProvider &&
            p.provider9.callOnDestroy) {
            i.obj9.onDestroy();
        }
    };
    ElementInjectorInlineStrategy.prototype.getComponent = function () { return this.injectorStrategy.obj0; };
    ElementInjectorInlineStrategy.prototype.isComponentKey = function (key) {
        return this._ei._proto._firstProviderIsComponent && lang_1.isPresent(key) &&
            key.id === this.injectorStrategy.protoStrategy.keyId0;
    };
    ElementInjectorInlineStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
        var i = this.injectorStrategy;
        var p = i.protoStrategy;
        if (lang_1.isPresent(p.provider0) && p.provider0.key.token === query.selector) {
            if (i.obj0 === injector_1.UNDEFINED)
                i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
            list.push(i.obj0);
        }
        if (lang_1.isPresent(p.provider1) && p.provider1.key.token === query.selector) {
            if (i.obj1 === injector_1.UNDEFINED)
                i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
            list.push(i.obj1);
        }
        if (lang_1.isPresent(p.provider2) && p.provider2.key.token === query.selector) {
            if (i.obj2 === injector_1.UNDEFINED)
                i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
            list.push(i.obj2);
        }
        if (lang_1.isPresent(p.provider3) && p.provider3.key.token === query.selector) {
            if (i.obj3 === injector_1.UNDEFINED)
                i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
            list.push(i.obj3);
        }
        if (lang_1.isPresent(p.provider4) && p.provider4.key.token === query.selector) {
            if (i.obj4 === injector_1.UNDEFINED)
                i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
            list.push(i.obj4);
        }
        if (lang_1.isPresent(p.provider5) && p.provider5.key.token === query.selector) {
            if (i.obj5 === injector_1.UNDEFINED)
                i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
            list.push(i.obj5);
        }
        if (lang_1.isPresent(p.provider6) && p.provider6.key.token === query.selector) {
            if (i.obj6 === injector_1.UNDEFINED)
                i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
            list.push(i.obj6);
        }
        if (lang_1.isPresent(p.provider7) && p.provider7.key.token === query.selector) {
            if (i.obj7 === injector_1.UNDEFINED)
                i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
            list.push(i.obj7);
        }
        if (lang_1.isPresent(p.provider8) && p.provider8.key.token === query.selector) {
            if (i.obj8 === injector_1.UNDEFINED)
                i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
            list.push(i.obj8);
        }
        if (lang_1.isPresent(p.provider9) && p.provider9.key.token === query.selector) {
            if (i.obj9 === injector_1.UNDEFINED)
                i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
            list.push(i.obj9);
        }
    };
    return ElementInjectorInlineStrategy;
})();
/**
 * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
 * In such a case, inlining fields is beneficial for performances.
 */
var ElementInjectorDynamicStrategy = (function () {
    function ElementInjectorDynamicStrategy(injectorStrategy, _ei) {
        this.injectorStrategy = injectorStrategy;
        this._ei = _ei;
    }
    ElementInjectorDynamicStrategy.prototype.hydrate = function () {
        var inj = this.injectorStrategy;
        var p = inj.protoStrategy;
        inj.resetConstructionCounter();
        for (var i = 0; i < p.keyIds.length; i++) {
            if (p.providers[i] instanceof DirectiveProvider && lang_1.isPresent(p.keyIds[i]) &&
                inj.objs[i] === injector_1.UNDEFINED) {
                inj.objs[i] = inj.instantiateProvider(p.providers[i], p.visibilities[i]);
            }
        }
    };
    ElementInjectorDynamicStrategy.prototype.dehydrate = function () {
        var inj = this.injectorStrategy;
        collection_1.ListWrapper.fill(inj.objs, injector_1.UNDEFINED);
    };
    ElementInjectorDynamicStrategy.prototype.callOnDestroy = function () {
        var ist = this.injectorStrategy;
        var p = ist.protoStrategy;
        for (var i = 0; i < p.providers.length; i++) {
            if (p.providers[i] instanceof DirectiveProvider &&
                p.providers[i].callOnDestroy) {
                ist.objs[i].onDestroy();
            }
        }
    };
    ElementInjectorDynamicStrategy.prototype.getComponent = function () { return this.injectorStrategy.objs[0]; };
    ElementInjectorDynamicStrategy.prototype.isComponentKey = function (key) {
        var p = this.injectorStrategy.protoStrategy;
        return this._ei._proto._firstProviderIsComponent && lang_1.isPresent(key) && key.id === p.keyIds[0];
    };
    ElementInjectorDynamicStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
        var ist = this.injectorStrategy;
        var p = ist.protoStrategy;
        for (var i = 0; i < p.providers.length; i++) {
            if (p.providers[i].key.token === query.selector) {
                if (ist.objs[i] === injector_1.UNDEFINED) {
                    ist.objs[i] = ist.instantiateProvider(p.providers[i], p.visibilities[i]);
                }
                list.push(ist.objs[i]);
            }
        }
    };
    return ElementInjectorDynamicStrategy;
})();
var ProtoQueryRef = (function () {
    function ProtoQueryRef(dirIndex, setter, query) {
        this.dirIndex = dirIndex;
        this.setter = setter;
        this.query = query;
    }
    Object.defineProperty(ProtoQueryRef.prototype, "usesPropertySyntax", {
        get: function () { return lang_1.isPresent(this.setter); },
        enumerable: true,
        configurable: true
    });
    return ProtoQueryRef;
})();
exports.ProtoQueryRef = ProtoQueryRef;
var QueryRef = (function () {
    function QueryRef(protoQueryRef, originator) {
        this.protoQueryRef = protoQueryRef;
        this.originator = originator;
    }
    Object.defineProperty(QueryRef.prototype, "isViewQuery", {
        get: function () { return this.protoQueryRef.query.isViewQuery; },
        enumerable: true,
        configurable: true
    });
    QueryRef.prototype.update = function () {
        if (!this.dirty)
            return;
        this._update();
        this.dirty = false;
        // TODO delete the check once only field queries are supported
        if (this.protoQueryRef.usesPropertySyntax) {
            var dir = this.originator.getDirectiveAtIndex(this.protoQueryRef.dirIndex);
            if (this.protoQueryRef.query.first) {
                this.protoQueryRef.setter(dir, this.list.length > 0 ? this.list.first : null);
            }
            else {
                this.protoQueryRef.setter(dir, this.list);
            }
        }
        this.list.notifyOnChanges();
    };
    QueryRef.prototype._update = function () {
        var aggregator = [];
        if (this.protoQueryRef.query.isViewQuery) {
            var view = this.originator.getView();
            // intentionally skipping originator for view queries.
            var nestedView = view.getNestedView(view.elementOffset + this.originator.getBoundElementIndex());
            if (lang_1.isPresent(nestedView))
                this._visitView(nestedView, aggregator);
        }
        else {
            this._visit(this.originator, aggregator);
        }
        this.list.reset(aggregator);
    };
    ;
    QueryRef.prototype._visit = function (inj, aggregator) {
        var view = inj.getView();
        var startIdx = view.elementOffset + inj._proto.index;
        for (var i = startIdx; i < view.elementOffset + view.ownBindersCount; i++) {
            var curInj = view.elementInjectors[i];
            if (lang_1.isBlank(curInj))
                continue;
            // The first injector after inj, that is outside the subtree rooted at
            // inj has to have a null parent or a parent that is an ancestor of inj.
            if (i > startIdx && (lang_1.isBlank(curInj) || lang_1.isBlank(curInj.parent) ||
                view.elementOffset + curInj.parent._proto.index < startIdx)) {
                break;
            }
            if (!this.protoQueryRef.query.descendants &&
                !(curInj.parent == this.originator || curInj == this.originator))
                continue;
            // We visit the view container(VC) views right after the injector that contains
            // the VC. Theoretically, that might not be the right order if there are
            // child injectors of said injector. Not clear whether if such case can
            // even be constructed with the current apis.
            this._visitInjector(curInj, aggregator);
            var vc = view.viewContainers[i];
            if (lang_1.isPresent(vc))
                this._visitViewContainer(vc, aggregator);
        }
    };
    QueryRef.prototype._visitInjector = function (inj, aggregator) {
        if (this.protoQueryRef.query.isVarBindingQuery) {
            this._aggregateVariableBinding(inj, aggregator);
        }
        else {
            this._aggregateDirective(inj, aggregator);
        }
    };
    QueryRef.prototype._visitViewContainer = function (vc, aggregator) {
        for (var j = 0; j < vc.views.length; j++) {
            this._visitView(vc.views[j], aggregator);
        }
    };
    QueryRef.prototype._visitView = function (view, aggregator) {
        for (var i = view.elementOffset; i < view.elementOffset + view.ownBindersCount; i++) {
            var inj = view.elementInjectors[i];
            if (lang_1.isBlank(inj))
                continue;
            this._visitInjector(inj, aggregator);
            var vc = view.viewContainers[i];
            if (lang_1.isPresent(vc))
                this._visitViewContainer(vc, aggregator);
        }
    };
    QueryRef.prototype._aggregateVariableBinding = function (inj, aggregator) {
        var vb = this.protoQueryRef.query.varBindings;
        for (var i = 0; i < vb.length; ++i) {
            if (inj.hasVariableBinding(vb[i])) {
                aggregator.push(inj.getVariableBinding(vb[i]));
            }
        }
    };
    QueryRef.prototype._aggregateDirective = function (inj, aggregator) {
        inj.addDirectivesMatchingQuery(this.protoQueryRef.query, aggregator);
    };
    QueryRef.prototype.dehydrate = function () { this.list = null; };
    QueryRef.prototype.hydrate = function () {
        this.list = new query_list_1.QueryList();
        this.dirty = true;
    };
    return QueryRef;
})();
exports.QueryRef = QueryRef;

},{"../metadata/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js","../metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","./directive_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_lifecycle_reflector.js","./element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js","./query_list":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js","./template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./view_container_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js","./view_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/injector.js","angular2/src/core/di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/linker/event_config":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/event_config.js","angular2/src/core/pipes/pipe_provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Represents a location in a View that has an injection, change-detection and render context
 * associated with it.
 *
 * An `ElementRef` is created for each element in the Template that contains a Directive, Component
 * or data-binding.
 *
 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
 * element.
 */
var ElementRef = (function () {
    function ElementRef() {
    }
    Object.defineProperty(ElementRef.prototype, "nativeElement", {
        /**
         * The underlying native element or `null` if direct access to native elements is not supported
         * (e.g. when the application runs in a web worker).
         *
         * <div class="callout is-critical">
         *   <header>Use with caution</header>
         *   <p>
         *    Use this API as the last resort when direct access to DOM is needed. Use templating and
         *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}
         *    which provides API that can safely be used even when direct access to native elements is not
         *    supported.
         *   </p>
         *   <p>
         *    Relying on direct DOM access creates tight coupling between your application and rendering
         *    layers which will make it impossible to separate the two and deploy your application into a
         *    web worker.
         *   </p>
         * </div>
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ElementRef.prototype, "renderView", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return ElementRef;
})();
exports.ElementRef = ElementRef;
var ElementRef_ = (function (_super) {
    __extends(ElementRef_, _super);
    function ElementRef_(parentView, 
        /**
         * Index of the element inside the {@link ViewRef}.
         *
         * This is used internally by the Angular framework to locate elements.
         */
        boundElementIndex, _renderer) {
        _super.call(this);
        this.parentView = parentView;
        this.boundElementIndex = boundElementIndex;
        this._renderer = _renderer;
    }
    Object.defineProperty(ElementRef_.prototype, "renderView", {
        get: function () { return this.parentView.render; },
        set: function (value) { exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementRef_.prototype, "nativeElement", {
        get: function () { return this._renderer.getNativeElementSync(this); },
        enumerable: true,
        configurable: true
    });
    return ElementRef_;
})(ElementRef);
exports.ElementRef_ = ElementRef_;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/event_config.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
exports.EVENT_TARGET_SEPARATOR = ':';
var EventConfig = (function () {
    function EventConfig(fieldName, eventName, isLongForm) {
        this.fieldName = fieldName;
        this.eventName = eventName;
        this.isLongForm = isLongForm;
    }
    EventConfig.parse = function (eventConfig) {
        var fieldName = eventConfig, eventName = eventConfig, isLongForm = false;
        var separatorIdx = eventConfig.indexOf(exports.EVENT_TARGET_SEPARATOR);
        if (separatorIdx > -1) {
            // long format: 'fieldName: eventName'
            fieldName = lang_1.StringWrapper.substring(eventConfig, 0, separatorIdx).trim();
            eventName = lang_1.StringWrapper.substring(eventConfig, separatorIdx + 1).trim();
            isLongForm = true;
        }
        return new EventConfig(fieldName, eventName, isLongForm);
    };
    EventConfig.prototype.getFullName = function () {
        return this.isLongForm ? "" + this.fieldName + exports.EVENT_TARGET_SEPARATOR + this.eventName :
            this.eventName;
    };
    return EventConfig;
})();
exports.EventConfig = EventConfig;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/interfaces.js":[function(require,module,exports){
'use strict';(function (LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
var LifecycleHooks = exports.LifecycleHooks;
/**
 * @internal
 */
exports.LIFECYCLE_HOOKS_VALUES = [
    LifecycleHooks.OnInit,
    LifecycleHooks.OnDestroy,
    LifecycleHooks.DoCheck,
    LifecycleHooks.OnChanges,
    LifecycleHooks.AfterContentInit,
    LifecycleHooks.AfterContentChecked,
    LifecycleHooks.AfterViewInit,
    LifecycleHooks.AfterViewChecked
];

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var metadata_1 = require('angular2/src/core/metadata');
var reflection_1 = require('angular2/src/core/reflection/reflection');
/**
 * Resolve a `Type` for {@link PipeMetadata}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
var PipeResolver = (function () {
    function PipeResolver() {
    }
    /**
     * Return {@link PipeMetadata} for a given `Type`.
     */
    PipeResolver.prototype.resolve = function (type) {
        var metas = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
        if (lang_1.isPresent(metas)) {
            for (var i = 0; i < metas.length; i++) {
                var annotation = metas[i];
                if (annotation instanceof metadata_1.PipeMetadata) {
                    return annotation;
                }
            }
        }
        throw new exceptions_1.BaseException("No Pipe decorator found on " + lang_1.stringify(type));
    };
    PipeResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PipeResolver);
    return PipeResolver;
})();
exports.PipeResolver = PipeResolver;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var pipe_provider_1 = require('../pipes/pipe_provider');
var pipes_1 = require('../pipes/pipes');
var view_1 = require('./view');
var element_binder_1 = require('./element_binder');
var element_injector_1 = require('./element_injector');
var directive_resolver_1 = require('./directive_resolver');
var view_resolver_1 = require('./view_resolver');
var pipe_resolver_1 = require('./pipe_resolver');
var pipes_2 = require('angular2/src/core/pipes');
var template_commands_1 = require('./template_commands');
var render_1 = require('angular2/render');
var application_tokens_1 = require('angular2/src/core/application_tokens');
var ProtoViewFactory = (function () {
    function ProtoViewFactory(_renderer, defaultPipes, _directiveResolver, _viewResolver, _pipeResolver, appId) {
        this._renderer = _renderer;
        this._directiveResolver = _directiveResolver;
        this._viewResolver = _viewResolver;
        this._pipeResolver = _pipeResolver;
        this._cache = new Map();
        this._defaultPipes = defaultPipes;
        this._appId = appId;
    }
    ProtoViewFactory.prototype.clearCache = function () { this._cache.clear(); };
    ProtoViewFactory.prototype.createHost = function (compiledHostTemplate) {
        var compiledTemplate = compiledHostTemplate.getTemplate();
        var result = this._cache.get(compiledTemplate.id);
        if (lang_1.isBlank(result)) {
            var templateData = compiledTemplate.getData(this._appId);
            var emptyMap = {};
            result = new view_1.AppProtoView(templateData.commands, view_1.ViewType.HOST, true, templateData.changeDetectorFactory, null, new pipes_1.ProtoPipes(emptyMap));
            this._cache.set(compiledTemplate.id, result);
        }
        return result;
    };
    ProtoViewFactory.prototype._createComponent = function (cmd) {
        var _this = this;
        var nestedProtoView = this._cache.get(cmd.templateId);
        if (lang_1.isBlank(nestedProtoView)) {
            var component = cmd.directives[0];
            var view = this._viewResolver.resolve(component);
            var compiledTemplateData = cmd.template.getData(this._appId);
            this._renderer.registerComponentTemplate(cmd.templateId, compiledTemplateData.commands, compiledTemplateData.styles, cmd.nativeShadow);
            var boundPipes = this._flattenPipes(view).map(function (pipe) { return _this._bindPipe(pipe); });
            nestedProtoView = new view_1.AppProtoView(compiledTemplateData.commands, view_1.ViewType.COMPONENT, true, compiledTemplateData.changeDetectorFactory, null, pipes_1.ProtoPipes.fromProviders(boundPipes));
            // Note: The cache is updated before recursing
            // to be able to resolve cycles
            this._cache.set(cmd.template.id, nestedProtoView);
            this._initializeProtoView(nestedProtoView, null);
        }
        return nestedProtoView;
    };
    ProtoViewFactory.prototype._createEmbeddedTemplate = function (cmd, parent) {
        var nestedProtoView = new view_1.AppProtoView(cmd.children, view_1.ViewType.EMBEDDED, cmd.isMerged, cmd.changeDetectorFactory, arrayToMap(cmd.variableNameAndValues, true), new pipes_1.ProtoPipes(parent.pipes.config));
        if (cmd.isMerged) {
            this.initializeProtoViewIfNeeded(nestedProtoView);
        }
        return nestedProtoView;
    };
    ProtoViewFactory.prototype.initializeProtoViewIfNeeded = function (protoView) {
        if (!protoView.isInitialized()) {
            var render = this._renderer.createProtoView(protoView.templateCmds);
            this._initializeProtoView(protoView, render);
        }
    };
    ProtoViewFactory.prototype._initializeProtoView = function (protoView, render) {
        var initializer = new _ProtoViewInitializer(protoView, this._directiveResolver, this);
        template_commands_1.visitAllCommands(initializer, protoView.templateCmds);
        var mergeInfo = new view_1.AppProtoViewMergeInfo(initializer.mergeEmbeddedViewCount, initializer.mergeElementCount, initializer.mergeViewCount);
        protoView.init(render, initializer.elementBinders, initializer.boundTextCount, mergeInfo, initializer.variableLocations);
    };
    ProtoViewFactory.prototype._bindPipe = function (typeOrProvider) {
        var meta = this._pipeResolver.resolve(typeOrProvider);
        return pipe_provider_1.PipeProvider.createFromType(typeOrProvider, meta);
    };
    ProtoViewFactory.prototype._flattenPipes = function (view) {
        if (lang_1.isBlank(view.pipes))
            return this._defaultPipes;
        var pipes = collection_1.ListWrapper.clone(this._defaultPipes);
        _flattenList(view.pipes, pipes);
        return pipes;
    };
    ProtoViewFactory = __decorate([
        di_1.Injectable(),
        __param(1, di_1.Inject(pipes_2.DEFAULT_PIPES_TOKEN)),
        __param(5, di_1.Inject(application_tokens_1.APP_ID)), 
        __metadata('design:paramtypes', [render_1.Renderer, Array, directive_resolver_1.DirectiveResolver, view_resolver_1.ViewResolver, pipe_resolver_1.PipeResolver, String])
    ], ProtoViewFactory);
    return ProtoViewFactory;
})();
exports.ProtoViewFactory = ProtoViewFactory;
function createComponent(protoViewFactory, cmd) {
    return protoViewFactory._createComponent(cmd);
}
function createEmbeddedTemplate(protoViewFactory, cmd, parent) {
    return protoViewFactory._createEmbeddedTemplate(cmd, parent);
}
var _ProtoViewInitializer = (function () {
    function _ProtoViewInitializer(_protoView, _directiveResolver, _protoViewFactory) {
        this._protoView = _protoView;
        this._directiveResolver = _directiveResolver;
        this._protoViewFactory = _protoViewFactory;
        this.variableLocations = new Map();
        this.boundTextCount = 0;
        this.boundElementIndex = 0;
        this.elementBinderStack = [];
        this.distanceToParentElementBinder = 0;
        this.distanceToParentProtoElementInjector = 0;
        this.elementBinders = [];
        this.mergeEmbeddedViewCount = 0;
        this.mergeElementCount = 0;
        this.mergeViewCount = 1;
    }
    _ProtoViewInitializer.prototype.visitText = function (cmd, context) {
        if (cmd.isBound) {
            this.boundTextCount++;
        }
        return null;
    };
    _ProtoViewInitializer.prototype.visitNgContent = function (cmd, context) { return null; };
    _ProtoViewInitializer.prototype.visitBeginElement = function (cmd, context) {
        if (cmd.isBound) {
            this._visitBeginBoundElement(cmd, null);
        }
        else {
            this._visitBeginElement(cmd, null, null);
        }
        return null;
    };
    _ProtoViewInitializer.prototype.visitEndElement = function (context) { return this._visitEndElement(); };
    _ProtoViewInitializer.prototype.visitBeginComponent = function (cmd, context) {
        var nestedProtoView = createComponent(this._protoViewFactory, cmd);
        return this._visitBeginBoundElement(cmd, nestedProtoView);
    };
    _ProtoViewInitializer.prototype.visitEndComponent = function (context) { return this._visitEndElement(); };
    _ProtoViewInitializer.prototype.visitEmbeddedTemplate = function (cmd, context) {
        var nestedProtoView = createEmbeddedTemplate(this._protoViewFactory, cmd, this._protoView);
        if (cmd.isMerged) {
            this.mergeEmbeddedViewCount++;
        }
        this._visitBeginBoundElement(cmd, nestedProtoView);
        return this._visitEndElement();
    };
    _ProtoViewInitializer.prototype._visitBeginBoundElement = function (cmd, nestedProtoView) {
        if (lang_1.isPresent(nestedProtoView) && nestedProtoView.isMergable) {
            this.mergeElementCount += nestedProtoView.mergeInfo.elementCount;
            this.mergeViewCount += nestedProtoView.mergeInfo.viewCount;
            this.mergeEmbeddedViewCount += nestedProtoView.mergeInfo.embeddedViewCount;
        }
        var elementBinder = _createElementBinder(this._directiveResolver, nestedProtoView, this.elementBinderStack, this.boundElementIndex, this.distanceToParentElementBinder, this.distanceToParentProtoElementInjector, cmd);
        this.elementBinders.push(elementBinder);
        var protoElementInjector = elementBinder.protoElementInjector;
        for (var i = 0; i < cmd.variableNameAndValues.length; i += 2) {
            this.variableLocations.set(cmd.variableNameAndValues[i], this.boundElementIndex);
        }
        this.boundElementIndex++;
        this.mergeElementCount++;
        return this._visitBeginElement(cmd, elementBinder, protoElementInjector);
    };
    _ProtoViewInitializer.prototype._visitBeginElement = function (cmd, elementBinder, protoElementInjector) {
        this.distanceToParentElementBinder =
            lang_1.isPresent(elementBinder) ? 1 : this.distanceToParentElementBinder + 1;
        this.distanceToParentProtoElementInjector =
            lang_1.isPresent(protoElementInjector) ? 1 : this.distanceToParentProtoElementInjector + 1;
        this.elementBinderStack.push(elementBinder);
        return null;
    };
    _ProtoViewInitializer.prototype._visitEndElement = function () {
        var parentElementBinder = this.elementBinderStack.pop();
        var parentProtoElementInjector = lang_1.isPresent(parentElementBinder) ? parentElementBinder.protoElementInjector : null;
        this.distanceToParentElementBinder = lang_1.isPresent(parentElementBinder) ?
            parentElementBinder.distanceToParent :
            this.distanceToParentElementBinder - 1;
        this.distanceToParentProtoElementInjector = lang_1.isPresent(parentProtoElementInjector) ?
            parentProtoElementInjector.distanceToParent :
            this.distanceToParentProtoElementInjector - 1;
        return null;
    };
    return _ProtoViewInitializer;
})();
function _createElementBinder(directiveResolver, nestedProtoView, elementBinderStack, boundElementIndex, distanceToParentBinder, distanceToParentPei, beginElementCmd) {
    var parentElementBinder = null;
    var parentProtoElementInjector = null;
    if (distanceToParentBinder > 0) {
        parentElementBinder = elementBinderStack[elementBinderStack.length - distanceToParentBinder];
    }
    if (lang_1.isBlank(parentElementBinder)) {
        distanceToParentBinder = -1;
    }
    if (distanceToParentPei > 0) {
        var peiBinder = elementBinderStack[elementBinderStack.length - distanceToParentPei];
        if (lang_1.isPresent(peiBinder)) {
            parentProtoElementInjector = peiBinder.protoElementInjector;
        }
    }
    if (lang_1.isBlank(parentProtoElementInjector)) {
        distanceToParentPei = -1;
    }
    var componentDirectiveProvider = null;
    var isEmbeddedTemplate = false;
    var directiveProviders = beginElementCmd.directives.map(function (type) { return provideDirective(directiveResolver, type); });
    if (beginElementCmd instanceof template_commands_1.BeginComponentCmd) {
        componentDirectiveProvider = directiveProviders[0];
    }
    else if (beginElementCmd instanceof template_commands_1.EmbeddedTemplateCmd) {
        isEmbeddedTemplate = true;
    }
    var protoElementInjector = null;
    // Create a protoElementInjector for any element that either has bindings *or* has one
    // or more var- defined *or* for <template> elements:
    // - Elements with a var- defined need a their own element injector
    //   so that, when hydrating, $implicit can be set to the element.
    // - <template> elements need their own ElementInjector so that we can query their TemplateRef
    var hasVariables = beginElementCmd.variableNameAndValues.length > 0;
    if (directiveProviders.length > 0 || hasVariables || isEmbeddedTemplate) {
        var directiveVariableBindings = new Map();
        if (!isEmbeddedTemplate) {
            directiveVariableBindings = createDirectiveVariableBindings(beginElementCmd.variableNameAndValues, directiveProviders);
        }
        protoElementInjector = element_injector_1.ProtoElementInjector.create(parentProtoElementInjector, boundElementIndex, directiveProviders, lang_1.isPresent(componentDirectiveProvider), distanceToParentPei, directiveVariableBindings);
        protoElementInjector.attributes = arrayToMap(beginElementCmd.attrNameAndValues, false);
    }
    return new element_binder_1.ElementBinder(boundElementIndex, parentElementBinder, distanceToParentBinder, protoElementInjector, componentDirectiveProvider, nestedProtoView);
}
function provideDirective(directiveResolver, type) {
    var annotation = directiveResolver.resolve(type);
    return element_injector_1.DirectiveProvider.createFromType(type, annotation);
}
function createDirectiveVariableBindings(variableNameAndValues, directiveProviders) {
    var directiveVariableBindings = new Map();
    for (var i = 0; i < variableNameAndValues.length; i += 2) {
        var templateName = variableNameAndValues[i];
        var dirIndex = variableNameAndValues[i + 1];
        if (lang_1.isNumber(dirIndex)) {
            directiveVariableBindings.set(templateName, dirIndex);
        }
        else {
            // a variable without a directive index -> reference the element
            directiveVariableBindings.set(templateName, null);
        }
    }
    return directiveVariableBindings;
}
exports.createDirectiveVariableBindings = createDirectiveVariableBindings;
function arrayToMap(arr, inverse) {
    var result = new Map();
    for (var i = 0; i < arr.length; i += 2) {
        if (inverse) {
            result.set(arr[i + 1], arr[i]);
        }
        else {
            result.set(arr[i], arr[i + 1]);
        }
    }
    return result;
}
function _flattenList(tree, out) {
    for (var i = 0; i < tree.length; i++) {
        var item = di_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
            _flattenList(item, out);
        }
        else {
            out.push(item);
        }
    }
}

},{"../pipes/pipe_provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js","../pipes/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js","./directive_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/directive_resolver.js","./element_binder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_binder.js","./element_injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js","./pipe_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/pipe_resolver.js","./template_commands":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","./view_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js","angular2/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/render.js","angular2/src/core/application_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/application_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/query_list.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
/**
 * An unmodifiable list of items that Angular keeps up to date when the state
 * of the application changes.
 *
 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
 *
 * Implements an iterable interface, therefore it can be used in both ES6
 * javascript `for (var i of items)` loops as well as in Angular templates with
 * `*ng-for="#i of myList"`.
 *
 * Changes can be observed by subscribing to the changes `Observable`.
 *
 * NOTE: In the future this class will implement an `Observable` interface.
 *
 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
 * ```javascript
 * @Component({...})
 * class Container {
 *   constructor(@Query(Item) items: QueryList<Item>) {
 *     items.changes.subscribe(_ => console.log(items.length));
 *   }
 * }
 * ```
 */
var QueryList = (function () {
    function QueryList() {
        this._results = [];
        this._emitter = new async_1.EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
        get: function () { return this._emitter; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
        get: function () { return this._results.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
        get: function () { return collection_1.ListWrapper.first(this._results); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
        get: function () { return collection_1.ListWrapper.last(this._results); },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new list with the passsed in function applied to each element.
     */
    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };
    QueryList.prototype.toString = function () { return this._results.toString(); };
    /**
     * @internal
     */
    QueryList.prototype.reset = function (res) { this._results = res; };
    /** @internal */
    QueryList.prototype.notifyOnChanges = function () { this._emitter.next(this); };
    return QueryList;
})();
exports.QueryList = QueryList;

},{"angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_commands.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var _nextTemplateId = 0;
function nextTemplateId() {
    return _nextTemplateId++;
}
exports.nextTemplateId = nextTemplateId;
/**
 * A compiled host template.
 *
 * This is const as we are storing it as annotation
 * for the compiled component type.
 */
var CompiledHostTemplate = (function () {
    // Note: _templateGetter is a function so that CompiledHostTemplate can be
    // a const!
    function CompiledHostTemplate(_templateGetter) {
        this._templateGetter = _templateGetter;
    }
    CompiledHostTemplate.prototype.getTemplate = function () { return this._templateGetter(); };
    CompiledHostTemplate = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Function])
    ], CompiledHostTemplate);
    return CompiledHostTemplate;
})();
exports.CompiledHostTemplate = CompiledHostTemplate;
/**
 * A compiled template.
 */
var CompiledTemplate = (function () {
    // Note: paramGetter is a function so that we can have cycles between templates!
    // paramGetter returns a tuple with:
    // - ChangeDetector factory function
    // - TemplateCmd[]
    // - styles
    function CompiledTemplate(id, _dataGetter) {
        this.id = id;
        this._dataGetter = _dataGetter;
    }
    CompiledTemplate.prototype.getData = function (appId) {
        var data = this._dataGetter(appId, this.id);
        return new CompiledTemplateData(data[0], data[1], data[2]);
    };
    return CompiledTemplate;
})();
exports.CompiledTemplate = CompiledTemplate;
var CompiledTemplateData = (function () {
    function CompiledTemplateData(changeDetectorFactory, commands, styles) {
        this.changeDetectorFactory = changeDetectorFactory;
        this.commands = commands;
        this.styles = styles;
    }
    return CompiledTemplateData;
})();
exports.CompiledTemplateData = CompiledTemplateData;
var EMPTY_ARR = lang_1.CONST_EXPR([]);
var TextCmd = (function () {
    function TextCmd(value, isBound, ngContentIndex) {
        this.value = value;
        this.isBound = isBound;
        this.ngContentIndex = ngContentIndex;
    }
    TextCmd.prototype.visit = function (visitor, context) {
        return visitor.visitText(this, context);
    };
    return TextCmd;
})();
exports.TextCmd = TextCmd;
function text(value, isBound, ngContentIndex) {
    return new TextCmd(value, isBound, ngContentIndex);
}
exports.text = text;
var NgContentCmd = (function () {
    function NgContentCmd(index, ngContentIndex) {
        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.isBound = false;
    }
    NgContentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitNgContent(this, context);
    };
    return NgContentCmd;
})();
exports.NgContentCmd = NgContentCmd;
function ngContent(index, ngContentIndex) {
    return new NgContentCmd(index, ngContentIndex);
}
exports.ngContent = ngContent;
var BeginElementCmd = (function () {
    function BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
        this.name = name;
        this.attrNameAndValues = attrNameAndValues;
        this.eventTargetAndNames = eventTargetAndNames;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.isBound = isBound;
        this.ngContentIndex = ngContentIndex;
    }
    BeginElementCmd.prototype.visit = function (visitor, context) {
        return visitor.visitBeginElement(this, context);
    };
    return BeginElementCmd;
})();
exports.BeginElementCmd = BeginElementCmd;
function beginElement(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex) {
    return new BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, isBound, ngContentIndex);
}
exports.beginElement = beginElement;
var EndElementCmd = (function () {
    function EndElementCmd() {
    }
    EndElementCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEndElement(context);
    };
    return EndElementCmd;
})();
exports.EndElementCmd = EndElementCmd;
function endElement() {
    return new EndElementCmd();
}
exports.endElement = endElement;
var BeginComponentCmd = (function () {
    function BeginComponentCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template) {
        this.name = name;
        this.attrNameAndValues = attrNameAndValues;
        this.eventTargetAndNames = eventTargetAndNames;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.nativeShadow = nativeShadow;
        this.ngContentIndex = ngContentIndex;
        this.template = template;
        this.isBound = true;
        this.templateId = template.id;
    }
    BeginComponentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitBeginComponent(this, context);
    };
    return BeginComponentCmd;
})();
exports.BeginComponentCmd = BeginComponentCmd;
function beginComponent(name, attrNameAnsValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template) {
    return new BeginComponentCmd(name, attrNameAnsValues, eventTargetAndNames, variableNameAndValues, directives, nativeShadow, ngContentIndex, template);
}
exports.beginComponent = beginComponent;
var EndComponentCmd = (function () {
    function EndComponentCmd() {
    }
    EndComponentCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEndComponent(context);
    };
    return EndComponentCmd;
})();
exports.EndComponentCmd = EndComponentCmd;
function endComponent() {
    return new EndComponentCmd();
}
exports.endComponent = endComponent;
var EmbeddedTemplateCmd = (function () {
    function EmbeddedTemplateCmd(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children) {
        this.attrNameAndValues = attrNameAndValues;
        this.variableNameAndValues = variableNameAndValues;
        this.directives = directives;
        this.isMerged = isMerged;
        this.ngContentIndex = ngContentIndex;
        this.changeDetectorFactory = changeDetectorFactory;
        this.children = children;
        this.isBound = true;
        this.name = null;
        this.eventTargetAndNames = EMPTY_ARR;
    }
    EmbeddedTemplateCmd.prototype.visit = function (visitor, context) {
        return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateCmd;
})();
exports.EmbeddedTemplateCmd = EmbeddedTemplateCmd;
function embeddedTemplate(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children) {
    return new EmbeddedTemplateCmd(attrNameAndValues, variableNameAndValues, directives, isMerged, ngContentIndex, changeDetectorFactory, children);
}
exports.embeddedTemplate = embeddedTemplate;
function visitAllCommands(visitor, cmds, context) {
    if (context === void 0) { context = null; }
    for (var i = 0; i < cmds.length; i++) {
        cmds[i].visit(visitor, context);
    }
}
exports.visitAllCommands = visitAllCommands;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var view_ref_1 = require('./view_ref');
/**
 * Represents an Embedded Template that can be used to instantiate Embedded Views.
 *
 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
 * `TemplateRef` from a Component or a Directive via {@link Query}.
 *
 * To instantiate Embedded Views based on a Template, use
 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
 * View Container.
 */
var TemplateRef = (function () {
    function TemplateRef() {
    }
    return TemplateRef;
})();
exports.TemplateRef = TemplateRef;
var TemplateRef_ = (function (_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(elementRef) {
        _super.call(this);
        this.elementRef = elementRef;
    }
    TemplateRef_.prototype._getProtoView = function () {
        var elementRef = this.elementRef;
        var parentView = view_ref_1.internalView(elementRef.parentView);
        return parentView.proto.elementBinders[elementRef.boundElementIndex - parentView.elementOffset]
            .nestedProtoView;
    };
    Object.defineProperty(TemplateRef_.prototype, "protoViewRef", {
        /**
         * Reference to the ProtoView used for creating Embedded Views that are based on the compiled
         * Embedded Template.
         */
        get: function () { return this._getProtoView().ref; },
        enumerable: true,
        configurable: true
    });
    TemplateRef_.prototype.hasLocal = function (name) {
        return this._getProtoView().templateVariableBindings.has(name);
    };
    return TemplateRef_;
})(TemplateRef);
exports.TemplateRef_ = TemplateRef_;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var change_detection_1 = require('angular2/src/core/change_detection/change_detection');
var interfaces_1 = require('angular2/src/core/change_detection/interfaces');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var view_ref_1 = require('./view_ref');
var util_1 = require('angular2/src/core/render/dom/util');
var view_ref_2 = require("./view_ref");
var interfaces_2 = require('angular2/src/core/change_detection/interfaces');
exports.DebugContext = interfaces_2.DebugContext;
var REFLECT_PREFIX = 'ng-reflect-';
(function (ViewType) {
    // A view that contains the host element with bound component directive.
    // Contains a COMPONENT view
    ViewType[ViewType["HOST"] = 0] = "HOST";
    // The view of the component
    // Can contain 0 to n EMBEDDED views
    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
    // A view that is embedded into another View via a <template> element
    // inside of a COMPONENT view
    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
})(exports.ViewType || (exports.ViewType = {}));
var ViewType = exports.ViewType;
var AppViewContainer = (function () {
    function AppViewContainer() {
        // The order in this list matches the DOM order.
        this.views = [];
    }
    return AppViewContainer;
})();
exports.AppViewContainer = AppViewContainer;
/**
 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
 *
 */
var AppView = (function () {
    function AppView(renderer, proto, viewOffset, elementOffset, textOffset, protoLocals, render, renderFragment, containerElementInjector) {
        this.renderer = renderer;
        this.proto = proto;
        this.viewOffset = viewOffset;
        this.elementOffset = elementOffset;
        this.textOffset = textOffset;
        this.render = render;
        this.renderFragment = renderFragment;
        this.containerElementInjector = containerElementInjector;
        // AppViews that have been merged in depth first order.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.views = null;
        // ElementInjectors of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.elementInjectors = null;
        // ViewContainers of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.viewContainers = null;
        // PreBuiltObjects of all AppViews in views grouped by view.
        // This list is shared between all merged views. Use this.elementOffset to get the local
        // entries.
        this.preBuiltObjects = null;
        this.changeDetector = null;
        /**
         * The context against which data-binding expressions in this view are evaluated against.
         * This is always a component instance.
         */
        this.context = null;
        this.ref = new view_ref_2.ViewRef_(this);
        this.locals = new change_detection_1.Locals(null, collection_1.MapWrapper.clone(protoLocals)); // TODO optimize this
    }
    AppView.prototype.init = function (changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers) {
        this.changeDetector = changeDetector;
        this.elementInjectors = elementInjectors;
        this.rootElementInjectors = rootElementInjectors;
        this.preBuiltObjects = preBuiltObjects;
        this.views = views;
        this.elementRefs = elementRefs;
        this.viewContainers = viewContainers;
    };
    AppView.prototype.setLocal = function (contextName, value) {
        if (!this.hydrated())
            throw new exceptions_1.BaseException('Cannot set locals on dehydrated view.');
        if (!this.proto.templateVariableBindings.has(contextName)) {
            return;
        }
        var templateName = this.proto.templateVariableBindings.get(contextName);
        this.locals.set(templateName, value);
    };
    AppView.prototype.hydrated = function () { return lang_1.isPresent(this.context); };
    /**
     * Triggers the event handlers for the element and the directives.
     *
     * This method is intended to be called from directive EventEmitters.
     *
     * @param {string} eventName
     * @param {*} eventObj
     * @param {number} boundElementIndex
     */
    AppView.prototype.triggerEventHandlers = function (eventName, eventObj, boundElementIndex) {
        var locals = new collection_1.Map();
        locals.set('$event', eventObj);
        this.dispatchEvent(boundElementIndex, eventName, locals);
    };
    // dispatch to element injector or text nodes based on context
    AppView.prototype.notifyOnBinding = function (b, currentValue) {
        if (b.isTextNode()) {
            this.renderer.setText(this.render, b.elementIndex + this.textOffset, currentValue);
        }
        else {
            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
            if (b.isElementProperty()) {
                this.renderer.setElementProperty(elementRef, b.name, currentValue);
            }
            else if (b.isElementAttribute()) {
                this.renderer.setElementAttribute(elementRef, b.name, lang_1.isPresent(currentValue) ? "" + currentValue : null);
            }
            else if (b.isElementClass()) {
                this.renderer.setElementClass(elementRef, b.name, currentValue);
            }
            else if (b.isElementStyle()) {
                var unit = lang_1.isPresent(b.unit) ? b.unit : '';
                this.renderer.setElementStyle(elementRef, b.name, "" + currentValue + unit);
            }
            else {
                throw new exceptions_1.BaseException('Unsupported directive record');
            }
        }
    };
    AppView.prototype.logBindingUpdate = function (b, value) {
        if (b.isDirective() || b.isElementProperty()) {
            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
            this.renderer.setElementAttribute(elementRef, "" + REFLECT_PREFIX + util_1.camelCaseToDashCase(b.name), "" + value);
        }
    };
    AppView.prototype.notifyAfterContentChecked = function () {
        var eiCount = this.proto.elementBinders.length;
        var ei = this.elementInjectors;
        for (var i = eiCount - 1; i >= 0; i--) {
            if (lang_1.isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].afterContentChecked();
        }
    };
    AppView.prototype.notifyAfterViewChecked = function () {
        var eiCount = this.proto.elementBinders.length;
        var ei = this.elementInjectors;
        for (var i = eiCount - 1; i >= 0; i--) {
            if (lang_1.isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].afterViewChecked();
        }
    };
    AppView.prototype.getDirectiveFor = function (directive) {
        var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
        return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
    };
    AppView.prototype.getNestedView = function (boundElementIndex) {
        var eli = this.elementInjectors[boundElementIndex];
        return lang_1.isPresent(eli) ? eli.getNestedView() : null;
    };
    AppView.prototype.getContainerElement = function () {
        return lang_1.isPresent(this.containerElementInjector) ?
            this.containerElementInjector.getElementRef() :
            null;
    };
    AppView.prototype.getDebugContext = function (elementIndex, directiveIndex) {
        try {
            var offsettedIndex = this.elementOffset + elementIndex;
            var hasRefForIndex = offsettedIndex < this.elementRefs.length;
            var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
            var container = this.getContainerElement();
            var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
            var element = lang_1.isPresent(elementRef) ? elementRef.nativeElement : null;
            var componentElement = lang_1.isPresent(container) ? container.nativeElement : null;
            var directive = lang_1.isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
            var injector = lang_1.isPresent(ei) ? ei.getInjector() : null;
            return new interfaces_1.DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);
        }
        catch (e) {
            // TODO: vsavkin log the exception once we have a good way to log errors and warnings
            // if an error happens during getting the debug context, we return null.
            return null;
        }
    };
    AppView.prototype.getDetectorFor = function (directive) {
        var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
        return lang_1.isPresent(childView) ? childView.changeDetector : null;
    };
    AppView.prototype.invokeElementMethod = function (elementIndex, methodName, args) {
        this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
    };
    // implementation of RenderEventDispatcher#dispatchRenderEvent
    AppView.prototype.dispatchRenderEvent = function (boundElementIndex, eventName, locals) {
        var elementRef = this.elementRefs[boundElementIndex];
        var view = view_ref_1.internalView(elementRef.parentView);
        return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
    };
    // returns false if preventDefault must be applied to the DOM event
    AppView.prototype.dispatchEvent = function (boundElementIndex, eventName, locals) {
        try {
            if (this.hydrated()) {
                return !this.changeDetector.handleEvent(eventName, boundElementIndex - this.elementOffset, new change_detection_1.Locals(this.locals, locals));
            }
            else {
                return true;
            }
        }
        catch (e) {
            var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector) :
                null;
            throw new EventEvaluationError(eventName, e, e.stack, context);
        }
    };
    Object.defineProperty(AppView.prototype, "ownBindersCount", {
        get: function () { return this.proto.elementBinders.length; },
        enumerable: true,
        configurable: true
    });
    return AppView;
})();
exports.AppView = AppView;
function _localsToStringMap(locals) {
    var res = {};
    var c = locals;
    while (lang_1.isPresent(c)) {
        res = collection_1.StringMapWrapper.merge(res, collection_1.MapWrapper.toStringMap(c.current));
        c = c.parent;
    }
    return res;
}
/**
 * Error context included when an event handler throws an exception.
 */
var _Context = (function () {
    function _Context(element, componentElement, context, locals, injector) {
        this.element = element;
        this.componentElement = componentElement;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
    }
    return _Context;
})();
/**
 * Wraps an exception thrown by an event handler.
 */
var EventEvaluationError = (function (_super) {
    __extends(EventEvaluationError, _super);
    function EventEvaluationError(eventName, originalException, originalStack, context) {
        _super.call(this, "Error during evaluation of \"" + eventName + "\"", originalException, originalStack, context);
    }
    return EventEvaluationError;
})(exceptions_1.WrappedException);
var AppProtoViewMergeInfo = (function () {
    function AppProtoViewMergeInfo(embeddedViewCount, elementCount, viewCount) {
        this.embeddedViewCount = embeddedViewCount;
        this.elementCount = elementCount;
        this.viewCount = viewCount;
    }
    return AppProtoViewMergeInfo;
})();
exports.AppProtoViewMergeInfo = AppProtoViewMergeInfo;
/**
 *
 */
var AppProtoView = (function () {
    function AppProtoView(templateCmds, type, isMergable, changeDetectorFactory, templateVariableBindings, pipes) {
        this.templateCmds = templateCmds;
        this.type = type;
        this.isMergable = isMergable;
        this.changeDetectorFactory = changeDetectorFactory;
        this.templateVariableBindings = templateVariableBindings;
        this.pipes = pipes;
        this.elementBinders = null;
        this.mergeInfo = null;
        this.variableLocations = null;
        this.textBindingCount = null;
        this.render = null;
        this.ref = new view_ref_2.ProtoViewRef_(this);
    }
    AppProtoView.prototype.init = function (render, elementBinders, textBindingCount, mergeInfo, variableLocations) {
        var _this = this;
        this.render = render;
        this.elementBinders = elementBinders;
        this.textBindingCount = textBindingCount;
        this.mergeInfo = mergeInfo;
        this.variableLocations = variableLocations;
        this.protoLocals = new collection_1.Map();
        if (lang_1.isPresent(this.templateVariableBindings)) {
            this.templateVariableBindings.forEach(function (templateName, _) { _this.protoLocals.set(templateName, null); });
        }
        if (lang_1.isPresent(variableLocations)) {
            // The view's locals needs to have a full set of variable names at construction time
            // in order to prevent new variables from being set later in the lifecycle. Since we don't
            // want
            // to actually create variable bindings for the $implicit bindings, add to the
            // protoLocals manually.
            variableLocations.forEach(function (_, templateName) { _this.protoLocals.set(templateName, null); });
        }
    };
    AppProtoView.prototype.isInitialized = function () { return lang_1.isPresent(this.elementBinders); };
    return AppProtoView;
})();
exports.AppProtoView = AppProtoView;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/change_detection/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/change_detection.js","angular2/src/core/change_detection/interfaces":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/interfaces.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/render/dom/util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_container_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
var view_ref_1 = require('./view_ref');
/**
 * Represents a container where one or more Views can be attached.
 *
 * The container can contain two kinds of Views. Host Views, created by instantiating a
 * {@link Component} via {@link #createHostView}, and Embedded Views, created by instantiating an
 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
 *
 * The location of the View Container within the containing View is specified by the Anchor
 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
 * have a single View Container.
 *
 * Root elements of Views attached to this container become siblings of the Anchor Element in
 * the Rendered View.
 *
 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
 * with `ViewContainerRef` on the Element, or you obtain it via
 * {@link AppViewManager#getViewContainer}.
 *
 * <!-- TODO(i): we are also considering ElementRef#viewContainer api -->
 */
var ViewContainerRef = (function () {
    function ViewContainerRef() {
    }
    /**
     * Destroys all Views in this container.
     */
    ViewContainerRef.prototype.clear = function () {
        for (var i = this.length - 1; i >= 0; i--) {
            this.remove(i);
        }
    };
    Object.defineProperty(ViewContainerRef.prototype, "length", {
        /**
         * Returns the number of Views currently attached to this container.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ViewContainerRef;
})();
exports.ViewContainerRef = ViewContainerRef;
var ViewContainerRef_ = (function (_super) {
    __extends(ViewContainerRef_, _super);
    function ViewContainerRef_(viewManager, element) {
        _super.call(this);
        this.viewManager = viewManager;
        this.element = element;
    }
    ViewContainerRef_.prototype._getViews = function () {
        var element = this.element;
        var vc = view_ref_1.internalView(element.parentView).viewContainers[element.boundElementIndex];
        return lang_1.isPresent(vc) ? vc.views : [];
    };
    ViewContainerRef_.prototype.get = function (index) { return this._getViews()[index].ref; };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
        get: function () { return this._getViews().length; },
        enumerable: true,
        configurable: true
    });
    // TODO(rado): profile and decide whether bounds checks should be added
    // to the methods below.
    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length;
        return this.viewManager.createEmbeddedViewInContainer(this.element, index, templateRef);
    };
    ViewContainerRef_.prototype.createHostView = function (protoViewRef, index, dynamicallyCreatedProviders) {
        if (protoViewRef === void 0) { protoViewRef = null; }
        if (index === void 0) { index = -1; }
        if (dynamicallyCreatedProviders === void 0) { dynamicallyCreatedProviders = null; }
        if (index == -1)
            index = this.length;
        return this.viewManager.createHostViewInContainer(this.element, index, protoViewRef, dynamicallyCreatedProviders);
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.insert = function (viewRef, index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length;
        return this.viewManager.attachViewInContainer(this.element, index, viewRef);
    };
    ViewContainerRef_.prototype.indexOf = function (viewRef) {
        return collection_1.ListWrapper.indexOf(this._getViews(), view_ref_1.internalView(viewRef));
    };
    // TODO(i): rename to destroy
    ViewContainerRef_.prototype.remove = function (index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length - 1;
        this.viewManager.destroyViewInContainer(this.element, index);
        // view is intentionally not returned to the client.
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.detach = function (index) {
        if (index === void 0) { index = -1; }
        if (index == -1)
            index = this.length - 1;
        return this.viewManager.detachViewInContainer(this.element, index);
    };
    return ViewContainerRef_;
})(ViewContainerRef);
exports.ViewContainerRef_ = ViewContainerRef_;

},{"./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
/**
 * Listener for view creation / destruction.
 */
var AppViewListener = (function () {
    function AppViewListener() {
    }
    AppViewListener.prototype.viewCreated = function (view) { };
    AppViewListener.prototype.viewDestroyed = function (view) { };
    AppViewListener = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AppViewListener);
    return AppViewListener;
})();
exports.AppViewListener = AppViewListener;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var viewModule = require('./view');
var view_ref_1 = require('./view_ref');
var api_1 = require('angular2/src/core/render/api');
var view_manager_utils_1 = require('./view_manager_utils');
var view_pool_1 = require('./view_pool');
var view_listener_1 = require('./view_listener');
var profile_1 = require('../profile/profile');
var proto_view_factory_1 = require('./proto_view_factory');
/**
 * Service exposing low level API for creating, moving and destroying Views.
 *
 * Most applications should use higher-level abstractions like {@link DynamicComponentLoader} and
 * {@link ViewContainerRef} instead.
 */
var AppViewManager = (function () {
    function AppViewManager() {
    }
    /**
     * Returns the {@link ElementRef} that makes up the specified Host View.
     */
    AppViewManager.prototype.getHostElement = function (hostViewRef) {
        var hostView = view_ref_1.internalView(hostViewRef);
        if (hostView.proto.type !== viewModule.ViewType.HOST) {
            throw new exceptions_1.BaseException('This operation is only allowed on host views');
        }
        return hostView.elementRefs[hostView.elementOffset];
    };
    return AppViewManager;
})();
exports.AppViewManager = AppViewManager;
var AppViewManager_ = (function (_super) {
    __extends(AppViewManager_, _super);
    function AppViewManager_(_viewPool, _viewListener, _utils, _renderer, _protoViewFactory) {
        _super.call(this);
        this._viewPool = _viewPool;
        this._viewListener = _viewListener;
        this._utils = _utils;
        this._renderer = _renderer;
        /** @internal */
        this._createRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#createRootHostView()');
        /** @internal */
        this._destroyRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#destroyRootHostView()');
        /** @internal */
        this._createEmbeddedViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');
        /** @internal */
        this._createHostViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createHostViewInContainer()');
        /** @internal */
        this._destroyViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#destroyViewInContainer()');
        /** @internal */
        this._attachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#attachViewInContainer()');
        /** @internal */
        this._detachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#detachViewInContainer()');
        this._protoViewFactory = _protoViewFactory;
    }
    AppViewManager_.prototype.getViewContainer = function (location) {
        var hostView = view_ref_1.internalView(location.parentView);
        return hostView.elementInjectors[location.boundElementIndex]
            .getViewContainerRef();
    };
    AppViewManager_.prototype.getNamedElementInComponentView = function (hostLocation, variableName) {
        var hostView = view_ref_1.internalView(hostLocation.parentView);
        var boundElementIndex = hostLocation.boundElementIndex;
        var componentView = hostView.getNestedView(boundElementIndex);
        if (lang_1.isBlank(componentView)) {
            throw new exceptions_1.BaseException("There is no component directive at element " + boundElementIndex);
        }
        var binderIdx = componentView.proto.variableLocations.get(variableName);
        if (lang_1.isBlank(binderIdx)) {
            throw new exceptions_1.BaseException("Could not find variable " + variableName);
        }
        return componentView.elementRefs[componentView.elementOffset + binderIdx];
    };
    AppViewManager_.prototype.getComponent = function (hostLocation) {
        var hostView = view_ref_1.internalView(hostLocation.parentView);
        var boundElementIndex = hostLocation.boundElementIndex;
        return this._utils.getComponentInstance(hostView, boundElementIndex);
    };
    AppViewManager_.prototype.createRootHostView = function (hostProtoViewRef, overrideSelector, injector) {
        var s = this._createRootHostViewScope();
        var hostProtoView = view_ref_1.internalProtoView(hostProtoViewRef);
        this._protoViewFactory.initializeProtoViewIfNeeded(hostProtoView);
        var hostElementSelector = overrideSelector;
        if (lang_1.isBlank(hostElementSelector)) {
            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
        }
        var renderViewWithFragments = this._renderer.createRootHostView(hostProtoView.render, hostProtoView.mergeInfo.embeddedViewCount + 1, hostElementSelector);
        var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
        this._renderer.hydrateView(hostView.render);
        this._utils.hydrateRootHostView(hostView, injector);
        return profile_1.wtfLeave(s, hostView.ref);
    };
    AppViewManager_.prototype.destroyRootHostView = function (hostViewRef) {
        // Note: Don't put the hostView into the view pool
        // as it is depending on the element for which it was created.
        var s = this._destroyRootHostViewScope();
        var hostView = view_ref_1.internalView(hostViewRef);
        this._renderer.detachFragment(hostView.renderFragment);
        this._renderer.dehydrateView(hostView.render);
        this._viewDehydrateRecurse(hostView);
        this._viewListener.viewDestroyed(hostView);
        this._renderer.destroyView(hostView.render);
        profile_1.wtfLeave(s);
    };
    AppViewManager_.prototype.createEmbeddedViewInContainer = function (viewContainerLocation, index, templateRef) {
        var s = this._createEmbeddedViewInContainerScope();
        var protoView = view_ref_1.internalProtoView(templateRef.protoViewRef);
        if (protoView.type !== viewModule.ViewType.EMBEDDED) {
            throw new exceptions_1.BaseException('This method can only be called with embedded ProtoViews!');
        }
        this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, index, protoView, templateRef.elementRef, null));
    };
    AppViewManager_.prototype.createHostViewInContainer = function (viewContainerLocation, index, protoViewRef, imperativelyCreatedInjector) {
        var s = this._createHostViewInContainerScope();
        var protoView = view_ref_1.internalProtoView(protoViewRef);
        if (protoView.type !== viewModule.ViewType.HOST) {
            throw new exceptions_1.BaseException('This method can only be called with host ProtoViews!');
        }
        this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, index, protoView, viewContainerLocation, imperativelyCreatedInjector));
    };
    /**
     *
     * See {@link AppViewManager#destroyViewInContainer}.
     * @internal
     */
    AppViewManager_.prototype._createViewInContainer = function (viewContainerLocation, index, protoView, context, imperativelyCreatedInjector) {
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        var contextView = view_ref_1.internalView(context.parentView);
        var contextBoundElementIndex = context.boundElementIndex;
        var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
        var view;
        if (protoView.type === viewModule.ViewType.EMBEDDED && lang_1.isPresent(embeddedFragmentView) &&
            !embeddedFragmentView.hydrated()) {
            // Case 1: instantiate the first view of a template that has been merged into a parent
            view = embeddedFragmentView;
            this._attachRenderView(parentView, boundElementIndex, index, view);
        }
        else {
            // Case 2: instantiate another copy of the template or a host ProtoView.
            // This is a separate case
            // as we only inline one copy of the template into the parent view.
            view = this._createPooledView(protoView);
            this._attachRenderView(parentView, boundElementIndex, index, view);
            this._renderer.hydrateView(view.render);
        }
        this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, index, view);
        this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, index, imperativelyCreatedInjector);
        return view.ref;
    };
    /** @internal */
    AppViewManager_.prototype._attachRenderView = function (parentView, boundElementIndex, index, view) {
        var elementRef = parentView.elementRefs[boundElementIndex];
        if (index === 0) {
            this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
        }
        else {
            var prevView = parentView.viewContainers[boundElementIndex].views[index - 1];
            this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
        }
    };
    AppViewManager_.prototype.destroyViewInContainer = function (viewContainerLocation, index) {
        var s = this._destroyViewInContainerScope();
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        this._destroyViewInContainer(parentView, boundElementIndex, index);
        profile_1.wtfLeave(s);
    };
    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
    AppViewManager_.prototype.attachViewInContainer = function (viewContainerLocation, index, viewRef) {
        var s = this._attachViewInContainerScope();
        var view = view_ref_1.internalView(viewRef);
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        // TODO(tbosch): the public methods attachViewInContainer/detachViewInContainer
        // are used for moving elements without the same container.
        // We will change this into an atomic `move` operation, which should preserve the
        // previous parent injector (see https://github.com/angular/angular/issues/1377).
        // Right now we are destroying any special
        // context view that might have been used.
        this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, index, view);
        this._attachRenderView(parentView, boundElementIndex, index, view);
        return profile_1.wtfLeave(s, viewRef);
    };
    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
    AppViewManager_.prototype.detachViewInContainer = function (viewContainerLocation, index) {
        var s = this._detachViewInContainerScope();
        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
        var boundElementIndex = viewContainerLocation.boundElementIndex;
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        this._utils.detachViewInContainer(parentView, boundElementIndex, index);
        this._renderer.detachFragment(view.renderFragment);
        return profile_1.wtfLeave(s, view.ref);
    };
    /** @internal */
    AppViewManager_.prototype._createMainView = function (protoView, renderViewWithFragments) {
        var mergedParentView = this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
        this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
        this._viewListener.viewCreated(mergedParentView);
        return mergedParentView;
    };
    /** @internal */
    AppViewManager_.prototype._createPooledView = function (protoView) {
        var view = this._viewPool.getView(protoView);
        if (lang_1.isBlank(view)) {
            view = this._createMainView(protoView, this._renderer.createView(protoView.render, protoView.mergeInfo.embeddedViewCount + 1));
        }
        return view;
    };
    /** @internal */
    AppViewManager_.prototype._destroyPooledView = function (view) {
        var wasReturned = this._viewPool.returnView(view);
        if (!wasReturned) {
            this._viewListener.viewDestroyed(view);
            this._renderer.destroyView(view.render);
        }
    };
    /** @internal */
    AppViewManager_.prototype._destroyViewInContainer = function (parentView, boundElementIndex, index) {
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        this._viewDehydrateRecurse(view);
        this._utils.detachViewInContainer(parentView, boundElementIndex, index);
        if (view.viewOffset > 0) {
            // Case 1: a view that is part of another view.
            // Just detach the fragment
            this._renderer.detachFragment(view.renderFragment);
        }
        else {
            // Case 2: a view that is not part of another view.
            // dehydrate and destroy it.
            this._renderer.dehydrateView(view.render);
            this._renderer.detachFragment(view.renderFragment);
            this._destroyPooledView(view);
        }
    };
    /** @internal */
    AppViewManager_.prototype._viewDehydrateRecurse = function (view) {
        if (view.hydrated()) {
            this._utils.dehydrateView(view);
        }
        var viewContainers = view.viewContainers;
        var startViewOffset = view.viewOffset;
        var endViewOffset = view.viewOffset + view.proto.mergeInfo.viewCount - 1;
        var elementOffset = view.elementOffset;
        for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = view.views[viewIdx];
            for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length; binderIdx++, elementOffset++) {
                var vc = viewContainers[elementOffset];
                if (lang_1.isPresent(vc)) {
                    for (var j = vc.views.length - 1; j >= 0; j--) {
                        this._destroyViewInContainer(currView, elementOffset, j);
                    }
                }
            }
        }
    };
    AppViewManager_ = __decorate([
        di_1.Injectable(),
        __param(4, di_1.Inject(di_1.forwardRef(function () { return proto_view_factory_1.ProtoViewFactory; }))), 
        __metadata('design:paramtypes', [view_pool_1.AppViewPool, view_listener_1.AppViewListener, view_manager_utils_1.AppViewManagerUtils, api_1.Renderer, Object])
    ], AppViewManager_);
    return AppViewManager_;
})(AppViewManager);
exports.AppViewManager_ = AppViewManager_;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","./proto_view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/proto_view_factory.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","./view_listener":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_listener.js","./view_manager_utils":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js","./view_pool":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js","./view_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/render/api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_manager_utils.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var eli = require('./element_injector');
var lang_1 = require('angular2/src/core/facade/lang');
var viewModule = require('./view');
var element_ref_1 = require('./element_ref');
var template_ref_1 = require('./template_ref');
var pipes_1 = require('angular2/src/core/pipes/pipes');
var AppViewManagerUtils = (function () {
    function AppViewManagerUtils() {
    }
    AppViewManagerUtils.prototype.getComponentInstance = function (parentView, boundElementIndex) {
        var eli = parentView.elementInjectors[boundElementIndex];
        return eli.getComponent();
    };
    AppViewManagerUtils.prototype.createView = function (mergedParentViewProto, renderViewWithFragments, viewManager, renderer) {
        var renderFragments = renderViewWithFragments.fragmentRefs;
        var renderView = renderViewWithFragments.viewRef;
        var elementCount = mergedParentViewProto.mergeInfo.elementCount;
        var viewCount = mergedParentViewProto.mergeInfo.viewCount;
        var elementRefs = collection_1.ListWrapper.createFixedSize(elementCount);
        var viewContainers = collection_1.ListWrapper.createFixedSize(elementCount);
        var preBuiltObjects = collection_1.ListWrapper.createFixedSize(elementCount);
        var elementInjectors = collection_1.ListWrapper.createFixedSize(elementCount);
        var views = collection_1.ListWrapper.createFixedSize(viewCount);
        var elementOffset = 0;
        var textOffset = 0;
        var fragmentIdx = 0;
        var containerElementIndicesByViewIndex = collection_1.ListWrapper.createFixedSize(viewCount);
        for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
            var containerElementIndex = containerElementIndicesByViewIndex[viewOffset];
            var containerElementInjector = lang_1.isPresent(containerElementIndex) ? elementInjectors[containerElementIndex] : null;
            var parentView = lang_1.isPresent(containerElementInjector) ? preBuiltObjects[containerElementIndex].view : null;
            var protoView = lang_1.isPresent(containerElementIndex) ?
                parentView.proto.elementBinders[containerElementIndex - parentView.elementOffset]
                    .nestedProtoView :
                mergedParentViewProto;
            var renderFragment = null;
            if (viewOffset === 0 || protoView.type === viewModule.ViewType.EMBEDDED) {
                renderFragment = renderFragments[fragmentIdx++];
            }
            var currentView = new viewModule.AppView(renderer, protoView, viewOffset, elementOffset, textOffset, protoView.protoLocals, renderView, renderFragment, containerElementInjector);
            views[viewOffset] = currentView;
            if (lang_1.isPresent(containerElementIndex)) {
                preBuiltObjects[containerElementIndex].nestedView = currentView;
            }
            var rootElementInjectors = [];
            var nestedViewOffset = viewOffset + 1;
            for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
                var binder = protoView.elementBinders[binderIdx];
                var boundElementIndex = elementOffset + binderIdx;
                var elementInjector = null;
                if (lang_1.isPresent(binder.nestedProtoView) && binder.nestedProtoView.isMergable) {
                    containerElementIndicesByViewIndex[nestedViewOffset] = boundElementIndex;
                    nestedViewOffset += binder.nestedProtoView.mergeInfo.viewCount;
                }
                // elementInjectors and rootElementInjectors
                var protoElementInjector = binder.protoElementInjector;
                if (lang_1.isPresent(protoElementInjector)) {
                    if (lang_1.isPresent(protoElementInjector.parent)) {
                        var parentElementInjector = elementInjectors[elementOffset + protoElementInjector.parent.index];
                        elementInjector = protoElementInjector.instantiate(parentElementInjector);
                    }
                    else {
                        elementInjector = protoElementInjector.instantiate(null);
                        rootElementInjectors.push(elementInjector);
                    }
                }
                elementInjectors[boundElementIndex] = elementInjector;
                // elementRefs
                var el = new element_ref_1.ElementRef_(currentView.ref, boundElementIndex, renderer);
                elementRefs[el.boundElementIndex] = el;
                // preBuiltObjects
                if (lang_1.isPresent(elementInjector)) {
                    var templateRef = lang_1.isPresent(binder.nestedProtoView) &&
                        binder.nestedProtoView.type === viewModule.ViewType.EMBEDDED ?
                        new template_ref_1.TemplateRef_(el) :
                        null;
                    preBuiltObjects[boundElementIndex] =
                        new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
                }
            }
            currentView.init(protoView.changeDetectorFactory(currentView), elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
            if (lang_1.isPresent(parentView) && protoView.type === viewModule.ViewType.COMPONENT) {
                parentView.changeDetector.addShadowDomChild(currentView.changeDetector);
            }
            elementOffset += protoView.elementBinders.length;
            textOffset += protoView.textBindingCount;
        }
        return views[0];
    };
    AppViewManagerUtils.prototype.hydrateRootHostView = function (hostView, injector) {
        this._hydrateView(hostView, injector, null, new Object(), null);
    };
    // Misnomer: this method is attaching next to the view container.
    AppViewManagerUtils.prototype.attachViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, index, view) {
        if (lang_1.isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
        }
        parentView.changeDetector.addChild(view.changeDetector);
        var viewContainer = parentView.viewContainers[boundElementIndex];
        if (lang_1.isBlank(viewContainer)) {
            viewContainer = new viewModule.AppViewContainer();
            parentView.viewContainers[boundElementIndex] = viewContainer;
        }
        collection_1.ListWrapper.insert(viewContainer.views, index, view);
        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
        for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
            if (lang_1.isPresent(elementInjector.parent)) {
                view.rootElementInjectors[i].link(elementInjector.parent);
            }
        }
        elementInjector.traverseAndSetQueriesAsDirty();
    };
    AppViewManagerUtils.prototype.detachViewInContainer = function (parentView, boundElementIndex, index) {
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        parentView.elementInjectors[boundElementIndex].traverseAndSetQueriesAsDirty();
        view.changeDetector.remove();
        collection_1.ListWrapper.removeAt(viewContainer.views, index);
        for (var i = 0; i < view.rootElementInjectors.length; ++i) {
            var inj = view.rootElementInjectors[i];
            inj.unlink();
        }
    };
    AppViewManagerUtils.prototype.hydrateViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, index, imperativelyCreatedProviders) {
        if (lang_1.isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
        }
        var viewContainer = parentView.viewContainers[boundElementIndex];
        var view = viewContainer.views[index];
        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
        var injector = lang_1.isPresent(imperativelyCreatedProviders) ?
            di_1.Injector.fromResolvedProviders(imperativelyCreatedProviders) :
            null;
        this._hydrateView(view, injector, elementInjector.getHost(), contextView.context, contextView.locals);
    };
    /** @internal */
    AppViewManagerUtils.prototype._hydrateView = function (initView, imperativelyCreatedInjector, hostElementInjector, context, parentLocals) {
        var viewIdx = initView.viewOffset;
        var endViewOffset = viewIdx + initView.proto.mergeInfo.viewCount - 1;
        while (viewIdx <= endViewOffset) {
            var currView = initView.views[viewIdx];
            var currProtoView = currView.proto;
            if (currView !== initView && currView.proto.type === viewModule.ViewType.EMBEDDED) {
                // Don't hydrate components of embedded fragment views.
                viewIdx += currView.proto.mergeInfo.viewCount;
            }
            else {
                if (currView !== initView) {
                    // hydrate a nested component view
                    imperativelyCreatedInjector = null;
                    parentLocals = null;
                    hostElementInjector = currView.containerElementInjector;
                    context = hostElementInjector.getComponent();
                }
                currView.context = context;
                currView.locals.parent = parentLocals;
                var binders = currProtoView.elementBinders;
                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                    var boundElementIndex = binderIdx + currView.elementOffset;
                    var elementInjector = initView.elementInjectors[boundElementIndex];
                    if (lang_1.isPresent(elementInjector)) {
                        elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector, currView.preBuiltObjects[boundElementIndex]);
                        this._populateViewLocals(currView, elementInjector, boundElementIndex);
                        this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
                    }
                }
                var pipes = lang_1.isPresent(hostElementInjector) ?
                    new pipes_1.Pipes(currView.proto.pipes, hostElementInjector.getInjector()) :
                    null;
                currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
                viewIdx++;
            }
        }
    };
    /** @internal */
    AppViewManagerUtils.prototype._populateViewLocals = function (view, elementInjector, boundElementIdx) {
        if (lang_1.isPresent(elementInjector.getDirectiveVariableBindings())) {
            elementInjector.getDirectiveVariableBindings().forEach(function (directiveIndex, name) {
                if (lang_1.isBlank(directiveIndex)) {
                    view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
                }
                else {
                    view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
                }
            });
        }
    };
    /** @internal */
    AppViewManagerUtils.prototype._setUpEventEmitters = function (view, elementInjector, boundElementIndex) {
        var emitters = elementInjector.getEventEmitterAccessors();
        for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
            var directiveEmitters = emitters[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
                var eventEmitterAccessor = directiveEmitters[eventIndex];
                eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
            }
        }
    };
    AppViewManagerUtils.prototype.dehydrateView = function (initView) {
        var endViewOffset = initView.viewOffset + initView.proto.mergeInfo.viewCount - 1;
        for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = initView.views[viewIdx];
            if (currView.hydrated()) {
                if (lang_1.isPresent(currView.locals)) {
                    currView.locals.clearValues();
                }
                currView.context = null;
                currView.changeDetector.dehydrate();
                var binders = currView.proto.elementBinders;
                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                    var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
                    if (lang_1.isPresent(eli)) {
                        eli.dehydrate();
                    }
                }
            }
        }
    };
    AppViewManagerUtils = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], AppViewManagerUtils);
    return AppViewManagerUtils;
})();
exports.AppViewManagerUtils = AppViewManagerUtils;

},{"./element_injector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_injector.js","./element_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/element_ref.js","./template_ref":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/template_ref.js","./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/pipes/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_pool.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
exports.APP_VIEW_POOL_CAPACITY = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppViewPool.viewPoolCapacity'));
var AppViewPool = (function () {
    function AppViewPool(poolCapacityPerProtoView) {
        /** @internal */
        this._pooledViewsPerProtoView = new collection_1.Map();
        this._poolCapacityPerProtoView = poolCapacityPerProtoView;
    }
    AppViewPool.prototype.getView = function (protoView) {
        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
        if (lang_1.isPresent(pooledViews) && pooledViews.length > 0) {
            return pooledViews.pop();
        }
        return null;
    };
    AppViewPool.prototype.returnView = function (view) {
        var protoView = view.proto;
        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
        if (lang_1.isBlank(pooledViews)) {
            pooledViews = [];
            this._pooledViewsPerProtoView.set(protoView, pooledViews);
        }
        var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
        if (haveRemainingCapacity) {
            pooledViews.push(view);
        }
        return haveRemainingCapacity;
    };
    AppViewPool = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(exports.APP_VIEW_POOL_CAPACITY)), 
        __metadata('design:paramtypes', [Object])
    ], AppViewPool);
    return AppViewPool;
})();
exports.AppViewPool = AppViewPool;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_ref.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
// This is a workaround for privacy in Dart as we don't have library parts
function internalView(viewRef) {
    return viewRef._view;
}
exports.internalView = internalView;
// This is a workaround for privacy in Dart as we don't have library parts
function internalProtoView(protoViewRef) {
    return lang_1.isPresent(protoViewRef) ? protoViewRef._protoView : null;
}
exports.internalProtoView = internalProtoView;
/**
 * Represents an Angular View.
 *
 * <!-- TODO: move the next two paragraphs to the dev guide -->
 * A View is a fundamental building block of the application UI. It is the smallest grouping of
 * Elements which are created and destroyed together.
 *
 * Properties of elements in a View can change, but the structure (number and order) of elements in
 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
 * removing nested Views via a {@link ViewContainer}. Each View can contain many View Containers.
 * <!-- /TODO -->
 *
 * ## Example
 *
 * Given this template...
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ng-for="var item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * ... we have two {@link ProtoViewRef}s:
 *
 * Outer {@link ProtoViewRef}:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ng-for var-item [ng-for-of]="items"></template>
 * </ul>
 * ```
 *
 * Inner {@link ProtoViewRef}:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
 *
 * The outer/inner {@link ProtoViewRef}s are then assembled into views like so:
 *
 * ```
 * <!-- ViewRef: outer-0 -->
 * Count: 2
 * <ul>
 *   <template view-container-ref></template>
 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
 * </ul>
 * <!-- /ViewRef: outer-0 -->
 * ```
 */
var ViewRef = (function () {
    function ViewRef() {
    }
    Object.defineProperty(ViewRef.prototype, "changeDetectorRef", {
        get: function () { return exceptions_1.unimplemented(); },
        set: function (value) {
            exceptions_1.unimplemented(); // TODO: https://github.com/Microsoft/TypeScript/issues/12
        },
        enumerable: true,
        configurable: true
    });
    return ViewRef;
})();
exports.ViewRef = ViewRef;
var ViewRef_ = (function (_super) {
    __extends(ViewRef_, _super);
    function ViewRef_(_view) {
        _super.call(this);
        this._changeDetectorRef = null;
        this._view = _view;
    }
    Object.defineProperty(ViewRef_.prototype, "render", {
        /**
         * Return `RenderViewRef`
         */
        get: function () { return this._view.render; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "renderFragment", {
        /**
         * Return `RenderFragmentRef`
         */
        get: function () { return this._view.renderFragment; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "changeDetectorRef", {
        /**
         * Return `ChangeDetectorRef`
         */
        get: function () {
            if (this._changeDetectorRef === null) {
                this._changeDetectorRef = this._view.changeDetector.ref;
            }
            return this._changeDetectorRef;
        },
        enumerable: true,
        configurable: true
    });
    ViewRef_.prototype.setLocal = function (variableName, value) { this._view.setLocal(variableName, value); };
    return ViewRef_;
})(ViewRef);
exports.ViewRef_ = ViewRef_;
/**
 * Represents an Angular ProtoView.
 *
 * A ProtoView is a prototypical {@link ViewRef View} that is the result of Template compilation and
 * is used by Angular to efficiently create an instance of this View based on the compiled Template.
 *
 * Most ProtoViews are created and used internally by Angular and you don't need to know about them,
 * except in advanced use-cases where you compile components yourself via the low-level
 * {@link Compiler#compileInHost} API.
 *
 *
 * ## Example
 *
 * Given this template:
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ng-for="var item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * Angular desugars and compiles the template into two ProtoViews:
 *
 * Outer ProtoView:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ng-for var-item [ng-for-of]="items"></template>
 * </ul>
 * ```
 *
 * Inner ProtoView:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate ProtoViews.
 */
var ProtoViewRef = (function () {
    function ProtoViewRef() {
    }
    return ProtoViewRef;
})();
exports.ProtoViewRef = ProtoViewRef;
var ProtoViewRef_ = (function (_super) {
    __extends(ProtoViewRef_, _super);
    function ProtoViewRef_(_protoView) {
        _super.call(this);
        this._protoView = _protoView;
    }
    return ProtoViewRef_;
})(ProtoViewRef);
exports.ProtoViewRef_ = ProtoViewRef_;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/linker/view_resolver.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var view_1 = require('../metadata/view');
var directives_1 = require('../metadata/directives');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var ViewResolver = (function () {
    function ViewResolver() {
        /** @internal */
        this._cache = new collection_1.Map();
    }
    ViewResolver.prototype.resolve = function (component) {
        var view = this._cache.get(component);
        if (lang_1.isBlank(view)) {
            view = this._resolve(component);
            this._cache.set(component, view);
        }
        return view;
    };
    /** @internal */
    ViewResolver.prototype._resolve = function (component) {
        var compMeta;
        var viewMeta;
        reflection_1.reflector.annotations(component).forEach(function (m) {
            if (m instanceof view_1.ViewMetadata) {
                viewMeta = m;
            }
            if (m instanceof directives_1.ComponentMetadata) {
                compMeta = m;
            }
        });
        if (lang_1.isPresent(compMeta)) {
            if (lang_1.isBlank(compMeta.template) && lang_1.isBlank(compMeta.templateUrl) && lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' must have either 'template', 'templateUrl', or '@View' set.");
            }
            else if (lang_1.isPresent(compMeta.template) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("template", component);
            }
            else if (lang_1.isPresent(compMeta.templateUrl) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("templateUrl", component);
            }
            else if (lang_1.isPresent(compMeta.directives) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("directives", component);
            }
            else if (lang_1.isPresent(compMeta.pipes) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("pipes", component);
            }
            else if (lang_1.isPresent(compMeta.encapsulation) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("encapsulation", component);
            }
            else if (lang_1.isPresent(compMeta.styles) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styles", component);
            }
            else if (lang_1.isPresent(compMeta.styleUrls) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styleUrls", component);
            }
            else if (lang_1.isPresent(viewMeta)) {
                return viewMeta;
            }
            else {
                return new view_1.ViewMetadata({
                    templateUrl: compMeta.templateUrl,
                    template: compMeta.template,
                    directives: compMeta.directives,
                    pipes: compMeta.pipes,
                    encapsulation: compMeta.encapsulation,
                    styles: compMeta.styles,
                    styleUrls: compMeta.styleUrls
                });
            }
        }
        else {
            if (lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("No View decorator found on component '" + lang_1.stringify(component) + "'");
            }
            else {
                return viewMeta;
            }
        }
        return null;
    };
    /** @internal */
    ViewResolver.prototype._throwMixingViewAndComponent = function (propertyName, component) {
        throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' cannot have both '" + propertyName + "' and '@View' set at the same time\"");
    };
    ViewResolver = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], ViewResolver);
    return ViewResolver;
})();
exports.ViewResolver = ViewResolver;

},{"../metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","../metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js":[function(require,module,exports){
'use strict';/**
 * This indirection is needed to free up Component, etc symbols in the public API
 * to be used by the decorator versions of these annotations.
 */
var di_1 = require('./metadata/di');
exports.QueryMetadata = di_1.QueryMetadata;
exports.ContentChildrenMetadata = di_1.ContentChildrenMetadata;
exports.ContentChildMetadata = di_1.ContentChildMetadata;
exports.ViewChildrenMetadata = di_1.ViewChildrenMetadata;
exports.ViewQueryMetadata = di_1.ViewQueryMetadata;
exports.ViewChildMetadata = di_1.ViewChildMetadata;
exports.AttributeMetadata = di_1.AttributeMetadata;
var directives_1 = require('./metadata/directives');
exports.ComponentMetadata = directives_1.ComponentMetadata;
exports.DirectiveMetadata = directives_1.DirectiveMetadata;
exports.PipeMetadata = directives_1.PipeMetadata;
exports.InputMetadata = directives_1.InputMetadata;
exports.OutputMetadata = directives_1.OutputMetadata;
exports.HostBindingMetadata = directives_1.HostBindingMetadata;
exports.HostListenerMetadata = directives_1.HostListenerMetadata;
var view_1 = require('./metadata/view');
exports.ViewMetadata = view_1.ViewMetadata;
exports.ViewEncapsulation = view_1.ViewEncapsulation;
var di_2 = require('./metadata/di');
var directives_2 = require('./metadata/directives');
var view_2 = require('./metadata/view');
var decorators_1 = require('./util/decorators');
// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * For details on the `@View` annotation, see {@link ViewMetadata}.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the component.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!'
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 */
exports.Component = decorators_1.makeDecorator(directives_2.ComponentMetadata, function (fn) { return fn.View = exports.View; });
// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ## Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
 * `ng-if`, or an `ng-switch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ## Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the directive.
 *
 * ## Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
exports.Directive = decorators_1.makeDecorator(directives_2.DirectiveMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
exports.View = decorators_1.makeDecorator(view_2.ViewMetadata, function (fn) { return fn.View = exports.View; });
// TODO(alexeagle): remove the duplication of this doc. It is copied from AttributeMetadata.
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
exports.Attribute = decorators_1.makeParamDecorator(di_2.AttributeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ng-for="#pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <content></content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
 *     this.panes = panes;
 *   }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'foo' })
 * class seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'foo'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
exports.Query = decorators_1.makeParamDecorator(di_2.QueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   afterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
exports.ContentChildren = decorators_1.makePropDecorator(di_2.ContentChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   afterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
exports.ContentChild = decorators_1.makePropDecorator(di_2.ContentChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;
 *
 *   afterViewInit() {
 *     // viewChildren is set
 *   }
 * }
 * ```
 */
exports.ViewChildren = decorators_1.makePropDecorator(di_2.ViewChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChild(ItemDirective) viewChild:ItemDirective;
 *
 *   afterViewInit() {
 *     // viewChild is set
 *   }
 * }
 * ```
 */
exports.ViewChild = decorators_1.makePropDecorator(di_2.ViewChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({...})
 * @View({
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.onChange(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
exports.ViewQuery = decorators_1.makeParamDecorator(di_2.ViewQueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
/**
 * Declare reusable pipe function.
 *
 * ## Example
 *
 * ```
 * @Pipe({
 *   name: 'lowercase'
 * })
 * class Lowercase {
 *   transform(v, args) { return v.toLowerCase(); }
 * }
 * ```
 */
exports.Pipe = decorators_1.makeDecorator(directives_2.PipeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.Input = decorators_1.makePropDecorator(directives_2.InputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.next("event"), 1000);
 *     setInterval(() => this.five5Secs.next("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
exports.Output = decorators_1.makePropDecorator(directives_2.OutputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ng-model directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ng-model]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ng-model)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
exports.HostBinding = decorators_1.makePropDecorator(directives_2.HostBindingMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.HostListener = decorators_1.makePropDecorator(directives_2.HostListenerMetadata);

},{"./metadata/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js","./metadata/directives":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js","./metadata/view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js","./util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/di.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/di/metadata');
/**
 * Specifies that a constant attribute value should be injected.
 *
 * The directive can inject constant string literals of host element attributes.
 *
 * ## Example
 *
 * Suppose we have an `<input>` element and want to know its `type`.
 *
 * ```html
 * <input type="text">
 * ```
 *
 * A decorator can inject string literal `text` like so:
 *
 * ```javascript
 * @Directive({
 *   selector: `input'
 * })
 * class InputDirective {
 *   constructor(@Attribute('type') type) {
 *     // type would be `text` in this example
 *   }
 * }
 * ```
 */
var AttributeMetadata = (function (_super) {
    __extends(AttributeMetadata, _super);
    function AttributeMetadata(attributeName) {
        _super.call(this);
        this.attributeName = attributeName;
    }
    Object.defineProperty(AttributeMetadata.prototype, "token", {
        get: function () {
            // Normally one would default a token to a type of an injected value but here
            // the type of a variable is "string" and we can't use primitive type as a return value
            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
            // account.
            return this;
        },
        enumerable: true,
        configurable: true
    });
    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
    AttributeMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], AttributeMetadata);
    return AttributeMetadata;
})(metadata_1.DependencyMetadata);
exports.AttributeMetadata = AttributeMetadata;
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ng-for="#pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <content></content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
  *    this.panes = panes;
  *  }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'foo' })
 * class seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'foo'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
var QueryMetadata = (function (_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        _super.call(this);
        this._selector = _selector;
        this.descendants = descendants;
        this.first = first;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
        /**
         * always `false` to differentiate it with {@link ViewQueryMetadata}.
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
        /**
         * what this is querying for.
         */
        get: function () { return di_1.resolveForwardRef(this._selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
        /**
         * whether this is querying for a variable binding or a directive.
         */
        get: function () { return lang_1.isString(this.selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
        /**
         * returns a list of variable bindings this is querying for.
         * Only applicable if this is a variable bindings query.
         */
        get: function () { return lang_1.StringWrapper.split(this.selector, new RegExp(",")); },
        enumerable: true,
        configurable: true
    });
    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
    QueryMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], QueryMetadata);
    return QueryMetadata;
})(metadata_1.DependencyMetadata);
exports.QueryMetadata = QueryMetadata;
// TODO: add an example after ContentChildren and ViewChildren are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   afterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
var ContentChildrenMetadata = (function (_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;
        _super.call(this, _selector, { descendants: descendants });
    }
    ContentChildrenMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], ContentChildrenMetadata);
    return ContentChildrenMetadata;
})(QueryMetadata);
exports.ContentChildrenMetadata = ContentChildrenMetadata;
// TODO: add an example after ContentChild and ViewChild are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `afterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   afterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
var ContentChildMetadata = (function (_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector) {
        _super.call(this, _selector, { descendants: true, first: true });
    }
    ContentChildMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ContentChildMetadata);
    return ContentChildMetadata;
})(QueryMetadata);
exports.ContentChildMetadata = ContentChildMetadata;
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({...})
 * @View({
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.onChange(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
var ViewQueryMetadata = (function (_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;
        _super.call(this, _selector, { descendants: descendants, first: first });
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
        /**
         * always `true` to differentiate it with {@link QueryMetadata}.
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
    ViewQueryMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object, Object])
    ], ViewQueryMetadata);
    return ViewQueryMetadata;
})(QueryMetadata);
exports.ViewQueryMetadata = ViewQueryMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;
 *
 *   afterViewInit() {
 *     // viewChildren is set
 *   }
 * }
 * ```
 */
var ViewChildrenMetadata = (function (_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector) {
        _super.call(this, _selector, { descendants: true });
    }
    ViewChildrenMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewChildrenMetadata);
    return ViewChildrenMetadata;
})(ViewQueryMetadata);
exports.ViewChildrenMetadata = ViewChildrenMetadata;
/**
 * Configures a view query.
 *
 * View queries are set before the `afterViewInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'someDir',
 *   templateUrl: 'someTemplate',
 *   directives: [ItemDirective]
 * })
 * class SomeDir {
 *   @ViewChild(ItemDirective) viewChild:ItemDirective;
 *
 *   afterViewInit() {
 *     // viewChild is set
 *   }
 * }
 * ```
 */
var ViewChildMetadata = (function (_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector) {
        _super.call(this, _selector, { descendants: true, first: true });
    }
    ViewChildMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewChildMetadata);
    return ViewChildMetadata;
})(ViewQueryMetadata);
exports.ViewChildMetadata = ViewChildMetadata;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/directives.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/di/metadata');
var change_detection_1 = require('angular2/src/core/change_detection');
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ## Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
 * `ng-if`, or an `ng-switch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ## Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the directive.
 *
 * ## Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
var DirectiveMetadata = (function (_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, bindings = _b.bindings, providers = _b.providers, exportAs = _b.exportAs, moduleId = _b.moduleId, queries = _b.queries;
        _super.call(this);
        this.selector = selector;
        this._inputs = inputs;
        this._properties = properties;
        this._outputs = outputs;
        this._events = events;
        this.host = host;
        this.exportAs = exportAs;
        this.moduleId = moduleId;
        this.queries = queries;
        this._providers = providers;
        this._bindings = bindings;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
        /**
         * Enumerates the set of data-bound input properties for a directive
         *
         * Angular automatically updates input properties during change detection.
         *
         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property where the value is written.
         * - `bindingProperty` specifies the DOM property where the value is read from.
         *
         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
         *
         * The following example creates a component with two data-bound properties.
         *
         * ```typescript
         * @Component({
         *   selector: 'bank-account',
         *   inputs: ['bankName', 'id: account-id'],
         *   template: `
         *     Bank Name: {{bankName}}
         *     Account Id: {{id}}
         *   `
         * })
         * class BankAccount {
         *   bankName: string;
         *   id: string;
         *
         *   // this property is not bound, and won't be automatically updated by Angular
         *   normalizedBankName: string;
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
         *   `,
         *   directives: [BankAccount]
         * })
         * class App {}
         *
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :
                this._inputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
        get: function () { return this.inputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
        /**
         * Enumerates the set of event-bound output properties.
         *
         * When an output property emits an event, an event handler attached to that event
         * the template is invoked.
         *
         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property that emits events.
         * - `bindingProperty` specifies the DOM property the event handler is attached to.
         *
         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
         *
         * ```typescript
         * @Directive({
         *   selector: 'interval-dir',
         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
         * })
         * class IntervalDir {
         *   everySecond = new EventEmitter();
         *   five5Secs = new EventEmitter();
         *
         *   constructor() {
         *     setInterval(() => this.everySecond.next("event"), 1000);
         *     setInterval(() => this.five5Secs.next("event"), 5000);
         *   }
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
         *     </interval-dir>
         *   `,
         *   directives: [IntervalDir]
         * })
         * class App {
         *   everySecond() { console.log('second'); }
         *   everyFiveSeconds() { console.log('five seconds'); }
         * }
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "events", {
        get: function () { return this.outputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
        /**
         * Defines the set of injectable objects that are visible to a Directive and its light DOM
         * children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'greet',
         *   bindings: [
         *     Greeter
         *   ]
         * })
         * class HelloWorld {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._bindings) && this._bindings.length > 0 ? this._bindings :
                this._providers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "bindings", {
        /** @deprecated */
        get: function () { return this.providers; },
        enumerable: true,
        configurable: true
    });
    DirectiveMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], DirectiveMetadata);
    return DirectiveMetadata;
})(metadata_1.InjectableMetadata);
exports.DirectiveMetadata = DirectiveMetadata;
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * For details on the `@View` annotation, see {@link ViewMetadata}.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
 * called by the change detection at defined points in time during the life of the component.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!'
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 */
var ComponentMetadata = (function (_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, bindings = _b.bindings, providers = _b.providers, viewBindings = _b.viewBindings, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? change_detection_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation;
        _super.call(this, {
            selector: selector,
            inputs: inputs,
            outputs: outputs,
            properties: properties,
            events: events,
            host: host,
            exportAs: exportAs,
            moduleId: moduleId,
            bindings: bindings,
            providers: providers,
            queries: queries
        });
        this.changeDetection = changeDetection;
        this._viewProviders = viewProviders;
        this._viewBindings = viewBindings;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
        /**
         * Defines the set of injectable objects that are visible to its view DOM children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'needs-greeter'
         * })
         * class NeedsGreeter {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         *
         * @Component({
         *   selector: 'greet',
         *   viewProviders: [
         *     Greeter
         *   ],
         *   template: `<needs-greeter></needs-greeter>`,
         *   directives: [NeedsGreeter]
         * })
         * class HelloWorld {
         * }
         *
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._viewBindings) && this._viewBindings.length > 0 ? this._viewBindings :
                this._viewProviders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentMetadata.prototype, "viewBindings", {
        get: function () { return this.viewProviders; },
        enumerable: true,
        configurable: true
    });
    ComponentMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ComponentMetadata);
    return ComponentMetadata;
})(DirectiveMetadata);
exports.ComponentMetadata = ComponentMetadata;
/**
 * Declare reusable pipe function.
 *
 * ## Example
 *
 * ```
 * @Pipe({
 *   name: 'lowercase'
 * })
 * class Lowercase {
 *   transform(v, args) { return v.toLowerCase(); }
 * }
 * ```
 */
var PipeMetadata = (function (_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
        var name = _a.name, pure = _a.pure;
        _super.call(this);
        this.name = name;
        this._pure = pure;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
        enumerable: true,
        configurable: true
    });
    PipeMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], PipeMetadata);
    return PipeMetadata;
})(metadata_1.InjectableMetadata);
exports.PipeMetadata = PipeMetadata;
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var InputMetadata = (function () {
    function InputMetadata(
        /**
         * Name used when instantiating a component in the temlate.
         */
        bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    InputMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], InputMetadata);
    return InputMetadata;
})();
exports.InputMetadata = InputMetadata;
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.next("event"), 1000);
 *     setInterval(() => this.five5Secs.next("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (every-second)="everySecond()" (every-five-seconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
var OutputMetadata = (function () {
    function OutputMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    OutputMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], OutputMetadata);
    return OutputMetadata;
})();
exports.OutputMetadata = OutputMetadata;
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ng-model directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ng-model]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ng-model)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
var HostBindingMetadata = (function () {
    function HostBindingMetadata(hostPropertyName) {
        this.hostPropertyName = hostPropertyName;
    }
    HostBindingMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], HostBindingMetadata);
    return HostBindingMetadata;
})();
exports.HostBindingMetadata = HostBindingMetadata;
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
var HostListenerMetadata = (function () {
    function HostListenerMetadata(eventName, args) {
        this.eventName = eventName;
        this.args = args;
    }
    HostListenerMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String, Array])
    ], HostListenerMetadata);
    return HostListenerMetadata;
})();
exports.HostListenerMetadata = HostListenerMetadata;

},{"angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/di/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/metadata.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata/view.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * Defines template and style encapsulation options available for Component's {@link View}.
 *
 * See {@link ViewMetadata#encapsulation}.
 */
(function (ViewEncapsulation) {
    /**
     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
     * Element and pre-processing the style rules provided via
     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
     * attribute to all selectors.
     *
     * This is the default option.
     */
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    /**
     * Use the native encapsulation mechanism of the renderer.
     *
     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
     * creating a ShadowRoot for Component's Host Element.
     */
    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
    /**
     * Don't provide any template or style encapsulation.
     */
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
var ViewEncapsulation = exports.ViewEncapsulation;
exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ## Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
var ViewMetadata = (function () {
    function ViewMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
    }
    ViewMetadata = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], ViewMetadata);
    return ViewMetadata;
})();
exports.ViewMetadata = ViewMetadata;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module provides a set of common Pipes.
 */
var async_pipe_1 = require('./pipes/async_pipe');
exports.AsyncPipe = async_pipe_1.AsyncPipe;
var date_pipe_1 = require('./pipes/date_pipe');
exports.DatePipe = date_pipe_1.DatePipe;
var default_pipes_1 = require('./pipes/default_pipes');
exports.DEFAULT_PIPES = default_pipes_1.DEFAULT_PIPES;
exports.DEFAULT_PIPES_TOKEN = default_pipes_1.DEFAULT_PIPES_TOKEN;
var json_pipe_1 = require('./pipes/json_pipe');
exports.JsonPipe = json_pipe_1.JsonPipe;
var slice_pipe_1 = require('./pipes/slice_pipe');
exports.SlicePipe = slice_pipe_1.SlicePipe;
var lowercase_pipe_1 = require('./pipes/lowercase_pipe');
exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
var number_pipe_1 = require('./pipes/number_pipe');
exports.NumberPipe = number_pipe_1.NumberPipe;
exports.DecimalPipe = number_pipe_1.DecimalPipe;
exports.PercentPipe = number_pipe_1.PercentPipe;
exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
var uppercase_pipe_1 = require('./pipes/uppercase_pipe');
exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;

},{"./pipes/async_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js","./pipes/date_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js","./pipes/default_pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/default_pipes.js","./pipes/json_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js","./pipes/lowercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js","./pipes/number_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js","./pipes/slice_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js","./pipes/uppercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var change_detection_1 = require('angular2/src/core/change_detection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var ObservableStrategy = (function () {
    function ObservableStrategy() {
    }
    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async_1.ObservableWrapper.subscribe(async, updateLatestValue, function (e) { throw e; });
    };
    ObservableStrategy.prototype.dispose = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    ObservableStrategy.prototype.onDestroy = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    return ObservableStrategy;
})();
var PromiseStrategy = (function () {
    function PromiseStrategy() {
    }
    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.then(updateLatestValue);
    };
    PromiseStrategy.prototype.dispose = function (subscription) { };
    PromiseStrategy.prototype.onDestroy = function (subscription) { };
    return PromiseStrategy;
})();
var _promiseStrategy = new PromiseStrategy();
var _observableStrategy = new ObservableStrategy();
/**
 * The `async` pipe subscribes to an Observable or Promise and returns the latest value it has
 * emitted.
 * When a new value is emitted, the `async` pipe marks the component to be checked for changes.
 *
 * # Example
 * The example below binds the `time` Observable to the view. Every 500ms, the `time` Observable
 * updates the view with the current time.
 *
 * ```
 * import {Observable} from 'angular2/core';
 * @Component({
 *   selector: "task-cmp",
 *   template: "Time: {{ time | async }}"
 * })
 * class Task {
 *   time = new Observable<number>(observer => {
 *     setInterval(_ =>
 *       observer.next(new Date().getTime()), 500);
 *   });
 * }
 * ```
 */
var AsyncPipe = (function () {
    function AsyncPipe(_ref) {
        /** @internal */
        this._latestValue = null;
        /** @internal */
        this._latestReturnedValue = null;
        /** @internal */
        this._subscription = null;
        /** @internal */
        this._obj = null;
        this._strategy = null;
        this._ref = _ref;
    }
    AsyncPipe.prototype.onDestroy = function () {
        if (lang_1.isPresent(this._subscription)) {
            this._dispose();
        }
    };
    AsyncPipe.prototype.transform = function (obj, args) {
        if (lang_1.isBlank(this._obj)) {
            if (lang_1.isPresent(obj)) {
                this._subscribe(obj);
            }
            return null;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform(obj);
        }
        if (this._latestValue === this._latestReturnedValue) {
            return this._latestReturnedValue;
        }
        else {
            this._latestReturnedValue = this._latestValue;
            return change_detection_1.WrappedValue.wrap(this._latestValue);
        }
    };
    /** @internal */
    AsyncPipe.prototype._subscribe = function (obj) {
        var _this = this;
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription =
            this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
    };
    /** @internal */
    AsyncPipe.prototype._selectStrategy = function (obj) {
        if (lang_1.isPromise(obj)) {
            return _promiseStrategy;
        }
        else if (async_1.ObservableWrapper.isObservable(obj)) {
            return _observableStrategy;
        }
        else {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
        }
    };
    /** @internal */
    AsyncPipe.prototype._dispose = function () {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    };
    /** @internal */
    AsyncPipe.prototype._updateLatestValue = function (async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    };
    AsyncPipe = __decorate([
        metadata_1.Pipe({ name: 'async', pure: false }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorRef])
    ], AsyncPipe);
    return AsyncPipe;
})();
exports.AsyncPipe = AsyncPipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/change_detection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var intl_1 = require('angular2/src/core/facade/intl');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var collection_1 = require('angular2/src/core/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
// TODO: move to a global configurable location along with other i18n components.
var defaultLocale = 'en-US';
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a date value to a string based on the requested format.
 *
 * # Usage
 *
 *     expression | date[:format]
 *
 * where `expression` is a date object or a number (milliseconds since UTC epoch) and
 * `format` indicates which date/time components to include:
 *
 *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
 *  |-----------|:------:|--------------|-------------------|-----------|-----------|
 *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
 *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
 *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
 *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
 *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
 *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
 *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
 *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
 *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
 *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
 *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
 *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
 *
 * In javascript, only the components specified will be respected (not the ordering,
 * punctuations, ...) and details of the formatting will be dependent on the locale.
 * On the other hand in Dart version, you can also include quoted text as well as some extra
 * date/time components such as quarter. For more information see:
 * https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/intl/intl.DateFormat.
 *
 * `format` can also be one of the following predefined formats:
 *
 *  - `'medium'`: equivalent to `'yMMMdjms'` (e.g. Sep 3, 2010, 12:05:08 PM for en-US)
 *  - `'short'`: equivalent to `'yMdjm'` (e.g. 9/3/2010, 12:05 PM for en-US)
 *  - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. Friday, September 3, 2010 for en-US)
 *  - `'longDate'`: equivalent to `'yMMMMd'` (e.g. September 3, 2010)
 *  - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. Sep 3, 2010 for en-US)
 *  - `'shortDate'`: equivalent to `'yMd'` (e.g. 9/3/2010 for en-US)
 *  - `'mediumTime'`: equivalent to `'jms'` (e.g. 12:05:08 PM for en-US)
 *  - `'shortTime'`: equivalent to `'jm'` (e.g. 12:05 PM for en-US)
 *
 * Timezone of the formatted text will be the local system timezone of the end-users machine.
 *
 * # Examples
 *
 * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
 * in the _local_ time and locale is 'en-US':
 *
 *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
 *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
 *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
 *     {{ dateObj | date:'mmss' }}        // output is '43:11'
 */
var DatePipe = (function () {
    function DatePipe() {
    }
    DatePipe.prototype.transform = function (value, args) {
        if (lang_1.isBlank(value))
            return null;
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
        }
        var pattern = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';
        if (lang_1.isNumber(value)) {
            value = lang_1.DateWrapper.fromMillis(value);
        }
        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
        }
        return intl_1.DateFormatter.format(value, defaultLocale, pattern);
    };
    DatePipe.prototype.supports = function (obj) { return lang_1.isDate(obj) || lang_1.isNumber(obj); };
    DatePipe._ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
    };
    DatePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'date' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DatePipe);
    return DatePipe;
})();
exports.DatePipe = DatePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/intl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/default_pipes.js":[function(require,module,exports){
'use strict';var async_pipe_1 = require('./async_pipe');
var uppercase_pipe_1 = require('./uppercase_pipe');
var lowercase_pipe_1 = require('./lowercase_pipe');
var json_pipe_1 = require('./json_pipe');
var slice_pipe_1 = require('./slice_pipe');
var date_pipe_1 = require('./date_pipe');
var number_pipe_1 = require('./number_pipe');
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var DEFAULT_PIPES_LIST = lang_1.CONST_EXPR([
    async_pipe_1.AsyncPipe,
    uppercase_pipe_1.UpperCasePipe,
    lowercase_pipe_1.LowerCasePipe,
    json_pipe_1.JsonPipe,
    slice_pipe_1.SlicePipe,
    number_pipe_1.DecimalPipe,
    number_pipe_1.PercentPipe,
    number_pipe_1.CurrencyPipe,
    date_pipe_1.DatePipe
]);
exports.DEFAULT_PIPES_TOKEN = lang_1.CONST_EXPR(new di_1.OpaqueToken("Default Pipes"));
exports.DEFAULT_PIPES = lang_1.CONST_EXPR(new di_1.Provider(exports.DEFAULT_PIPES_TOKEN, { useValue: DEFAULT_PIPES_LIST }));

},{"./async_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/async_pipe.js","./date_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/date_pipe.js","./json_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js","./lowercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js","./number_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js","./slice_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js","./uppercase_pipe":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var InvalidPipeArgumentException = (function (_super) {
    __extends(InvalidPipeArgumentException, _super);
    function InvalidPipeArgumentException(type, value) {
        _super.call(this, "Invalid argument '" + value + "' for pipe '" + type + "'");
    }
    return InvalidPipeArgumentException;
})(exceptions_1.BaseException);
exports.InvalidPipeArgumentException = InvalidPipeArgumentException;

},{"angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/json_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
/**
 * Implements json transforms to any object.
 *
 * # Example
 *
 * In this example we transform the user object to json.
 *
 *  ```
 * @Component({
 *   selector: "user-cmp",
 *   template: "User: {{ user | json }}"
 * })
 * class Username {
 *  user:Object
 *  constructor() {
 *    this.user = { name: "PatrickJS" };
 *  }
 * }
 *
 * ```
 */
var JsonPipe = (function () {
    function JsonPipe() {
    }
    JsonPipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        return lang_1.Json.stringify(value);
    };
    JsonPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'json' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], JsonPipe);
    return JsonPipe;
})();
exports.JsonPipe = JsonPipe;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/lowercase_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
/**
 * Implements lowercase transforms to text.
 *
 * # Example
 *
 * In this example we transform the user text lowercase.
 *
 *  ```
 * @Component({
 *   selector: "username-cmp",
 *   template: "Username: {{ user | lowercase }}"
 * })
 * class Username {
 *   user:string;
 * }
 *
 * ```
 */
var LowerCasePipe = (function () {
    function LowerCasePipe() {
    }
    LowerCasePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
        }
        return lang_1.StringWrapper.toLowerCase(value);
    };
    LowerCasePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'lowercase' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], LowerCasePipe);
    return LowerCasePipe;
})();
exports.LowerCasePipe = LowerCasePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/number_pipe.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var intl_1 = require('angular2/src/core/facade/intl');
var di_1 = require('angular2/src/core/di');
var metadata_1 = require('angular2/src/core/metadata');
var collection_1 = require('angular2/src/core/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var defaultLocale = 'en-US';
var _re = lang_1.RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
var NumberPipe = (function () {
    function NumberPipe() {
    }
    NumberPipe._format = function (value, style, digits, currency, currencyAsSymbol) {
        if (currency === void 0) { currency = null; }
        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
        if (lang_1.isBlank(value))
            return null;
        if (!lang_1.isNumber(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(NumberPipe, value);
        }
        var minInt = 1, minFraction = 0, maxFraction = 3;
        if (lang_1.isPresent(digits)) {
            var parts = lang_1.RegExpWrapper.firstMatch(_re, digits);
            if (lang_1.isBlank(parts)) {
                throw new exceptions_1.BaseException(digits + " is not a valid digit info for number pipes");
            }
            if (lang_1.isPresent(parts[1])) {
                minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (lang_1.isPresent(parts[3])) {
                minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (lang_1.isPresent(parts[5])) {
                maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        return intl_1.NumberFormatter.format(value, defaultLocale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol
        });
    };
    NumberPipe = __decorate([
        lang_1.CONST(),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], NumberPipe);
    return NumberPipe;
})();
exports.NumberPipe = NumberPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local text. i.e. group sizing and separator and other locale-specific
 * configurations are based on the active locale.
 *
 * # Usage
 *
 *     expression | number[:digitInfo]
 *
 * where `expression` is a number and `digitInfo` has the following format:
 *
 *     {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
 *
 * - minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.
 * - minFractionDigits is the minimum number of digits after fraction. Defaults to 0.
 * - maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.
 *
 * For more information on the acceptable range for each of these numbers and other
 * details see your native internationalization library.
 *
 * # Examples
 *
 *     {{ 123 | number }}              // output is 123
 *     {{ 123.1 | number: '.2-3' }}    // output is 123.10
 *     {{ 1 | number: '2.2' }}         // output is 01.00
 */
var DecimalPipe = (function (_super) {
    __extends(DecimalPipe, _super);
    function DecimalPipe() {
        _super.apply(this, arguments);
    }
    DecimalPipe.prototype.transform = function (value, args) {
        var digits = collection_1.ListWrapper.first(args);
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Decimal, digits);
    };
    DecimalPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'number' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DecimalPipe);
    return DecimalPipe;
})(NumberPipe);
exports.DecimalPipe = DecimalPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local percent.
 *
 * # Usage
 *
 *     expression | percent[:digitInfo]
 *
 * For more information about `digitInfo` see {@link DecimalPipe}
 */
var PercentPipe = (function (_super) {
    __extends(PercentPipe, _super);
    function PercentPipe() {
        _super.apply(this, arguments);
    }
    PercentPipe.prototype.transform = function (value, args) {
        var digits = collection_1.ListWrapper.first(args);
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Percent, digits);
    };
    PercentPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'percent' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PercentPipe);
    return PercentPipe;
})(NumberPipe);
exports.PercentPipe = PercentPipe;
/**
 * WARNING: this pipe uses the Internationalization API.
 * Therefore it is only reliable in Chrome and Opera browsers.
 *
 * Formats a number as local currency.
 *
 * # Usage
 *
 *     expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
 *
 * where `currencyCode` is the ISO 4217 currency code, such as "USD" for the US dollar and
 * "EUR" for the euro. `symbolDisplay` is a boolean indicating whether to use the currency
 * symbol (e.g. $) or the currency code (e.g. USD) in the output. The default for this value
 * is `false`.
 * For more information about `digitInfo` see {@link DecimalPipe}
 */
var CurrencyPipe = (function (_super) {
    __extends(CurrencyPipe, _super);
    function CurrencyPipe() {
        _super.apply(this, arguments);
    }
    CurrencyPipe.prototype.transform = function (value, args) {
        var currencyCode = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'USD';
        var symbolDisplay = lang_1.isPresent(args) && args.length > 1 ? args[1] : false;
        var digits = lang_1.isPresent(args) && args.length > 2 ? args[2] : null;
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    CurrencyPipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'currency' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], CurrencyPipe);
    return CurrencyPipe;
})(NumberPipe);
exports.CurrencyPipe = CurrencyPipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/intl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/intl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipe_provider.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var provider_1 = require('angular2/src/core/di/provider');
var di_1 = require('angular2/src/core/di');
var PipeProvider = (function (_super) {
    __extends(PipeProvider, _super);
    function PipeProvider(name, pure, key, resolvedFactories, multiBinding) {
        _super.call(this, key, resolvedFactories, multiBinding);
        this.name = name;
        this.pure = pure;
    }
    PipeProvider.createFromType = function (type, metadata) {
        var provider = new di_1.Provider(type, { useClass: type });
        var rb = provider_1.resolveProvider(provider);
        return new PipeProvider(metadata.name, metadata.pure, rb.key, rb.resolvedFactories, rb.multiProvider);
    };
    return PipeProvider;
})(provider_1.ResolvedProvider_);
exports.PipeProvider = PipeProvider;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/di/provider":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di/provider.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/pipes.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var cd = require('angular2/src/core/change_detection/pipes');
var ProtoPipes = (function () {
    function ProtoPipes(
        /**
        * Map of {@link PipeMetadata} names to {@link PipeMetadata} implementations.
        */
        config) {
        this.config = config;
        this.config = config;
    }
    ProtoPipes.fromProviders = function (providers) {
        var config = {};
        providers.forEach(function (b) { return config[b.name] = b; });
        return new ProtoPipes(config);
    };
    ProtoPipes.prototype.get = function (name) {
        var provider = this.config[name];
        if (lang_1.isBlank(provider))
            throw new exceptions_1.BaseException("Cannot find pipe '" + name + "'.");
        return provider;
    };
    return ProtoPipes;
})();
exports.ProtoPipes = ProtoPipes;
var Pipes = (function () {
    function Pipes(proto, injector) {
        this.proto = proto;
        this.injector = injector;
        /** @internal */
        this._config = {};
    }
    Pipes.prototype.get = function (name) {
        var cached = collection_1.StringMapWrapper.get(this._config, name);
        if (lang_1.isPresent(cached))
            return cached;
        var p = this.proto.get(name);
        var transform = this.injector.instantiateResolved(p);
        var res = new cd.SelectedPipe(transform, p.pure);
        if (p.pure) {
            collection_1.StringMapWrapper.set(this._config, name, res);
        }
        return res;
    };
    return Pipes;
})();
exports.Pipes = Pipes;

},{"angular2/src/core/change_detection/pipes":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/change_detection/pipes.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/slice_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var di_1 = require('angular2/src/core/di');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var metadata_1 = require('../metadata');
/**
 * Creates a new List or String containing only a subset (slice) of the
 * elements.
 *
 * The starting index of the subset to return is specified by the `start` parameter.
 *
 * The ending index of the subset to return is specified by the optional `end` parameter.
 *
 * # Usage
 *
 *     expression | slice:start[:end]
 *
 * All behavior is based on the expected behavior of the JavaScript API
 * Array.prototype.slice() and String.prototype.slice()
 *
 * Where the input expression is a [List] or [String], and `start` is:
 *
 * - **a positive integer**: return the item at _start_ index and all items after
 * in the list or string expression.
 * - **a negative integer**: return the item at _start_ index from the end and all items after
 * in the list or string expression.
 * - **`|start|` greater than the size of the expression**: return an empty list or string.
 * - **`|start|` negative greater than the size of the expression**: return entire list or
 * string expression.
 *
 * and where `end` is:
 *
 * - **omitted**: return all items until the end of the input
 * - **a positive integer**: return all items before _end_ index of the list or string
 * expression.
 * - **a negative integer**: return all items before _end_ index from the end of the list
 * or string expression.
 *
 * When operating on a [List], the returned list is always a copy even when all
 * the elements are being returned.
 *
 * # Examples
 *
 * ## List Example
 *
 * Assuming `var collection = ['a', 'b', 'c', 'd']`, this `ng-for` directive:
 *
 *     <li *ng-for="var i in collection | slice:1:3">{{i}}</li>
 *
 * produces the following:
 *
 *     <li>b</li>
 *     <li>c</li>
 *
 * ## String Examples
 *
 *     {{ 'abcdefghij' | slice:0:4 }}       // output is 'abcd'
 *     {{ 'abcdefghij' | slice:4:0 }}       // output is ''
 *     {{ 'abcdefghij' | slice:-4 }}      // output is 'ghij'
 *     {{ 'abcdefghij' | slice:-4,-2 }}      // output is 'gh'
 *     {{ 'abcdefghij' | slice: -100 }}    // output is 'abcdefghij'
 *     {{ 'abcdefghij' | slice: 100 }}    // output is ''
 */
var SlicePipe = (function () {
    function SlicePipe() {
    }
    SlicePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(args) || args.length == 0) {
            throw new exceptions_1.BaseException('Slice pipe requires one argument');
        }
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);
        }
        if (lang_1.isBlank(value))
            return value;
        var start = args[0];
        var end = args.length > 1 ? args[1] : null;
        if (lang_1.isString(value)) {
            return lang_1.StringWrapper.slice(value, start, end);
        }
        return collection_1.ListWrapper.slice(value, start, end);
    };
    SlicePipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };
    SlicePipe = __decorate([
        metadata_1.Pipe({ name: 'slice' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], SlicePipe);
    return SlicePipe;
})();
exports.SlicePipe = SlicePipe;

},{"../metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/uppercase_pipe.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var metadata_1 = require('angular2/src/core/metadata');
var di_1 = require('angular2/src/core/di');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
/**
 * Implements uppercase transforms to text.
 *
 * # Example
 *
 * In this example we transform the user text uppercase.
 *
 *  ```
 * @Component({
 *   selector: "username-cmp",
 *   template: "Username: {{ user | uppercase }}"
 * })
 * class Username {
 *   user:string;
 * }
 *
 * ```
 */
var UpperCasePipe = (function () {
    function UpperCasePipe() {
    }
    UpperCasePipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = null; }
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
        }
        return lang_1.StringWrapper.toUpperCase(value);
    };
    UpperCasePipe = __decorate([
        lang_1.CONST(),
        metadata_1.Pipe({ name: 'uppercase' }),
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], UpperCasePipe);
    return UpperCasePipe;
})();
exports.UpperCasePipe = UpperCasePipe;

},{"./invalid_pipe_argument_exception":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/pipes/invalid_pipe_argument_exception.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/platform_bindings.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
exports.EXCEPTION_PROVIDER = di_1.provide(exceptions_1.ExceptionHandler, { useFactory: function () { return new exceptions_1.ExceptionHandler(dom_adapter_1.DOM, false); }, deps: [] });
exports.EXCEPTION_BINDING = exports.EXCEPTION_PROVIDER;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js":[function(require,module,exports){
'use strict';var impl = require("./wtf_impl");
// Change exports to const once https://github.com/angular/ts2dart/issues/150
/**
 * True if WTF is enabled.
 */
exports.wtfEnabled = impl.detectWTF();
function noopScope(arg0, arg1) {
    return null;
}
/**
 * Create trace scope.
 *
 * Scopes must be strictly nested and are analogous to stack frames, but
 * do not have to follow the stack frames. Instead it is recommended that they follow logical
 * nesting. You may want to use
 * [Event
 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
 * as they are defined in WTF.
 *
 * Used to mark scope entry. The return value is used to leave the scope.
 *
 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
 *
 *     someMethod() {
 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
 *        // DO SOME WORK HERE
 *        return wtfLeave(s, 123); // Return value 123
 *     }
 *
 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
 * negatively impact the performance of your application. For this reason we recommend that
 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
 * exception, will produce incorrect trace, but presence of exception signifies logic error which
 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
 * an exception is expected during normal execution while profiling.
 *
 */
exports.wtfCreateScope = exports.wtfEnabled ? impl.createScope : function (signature, flags) { return noopScope; };
/**
 * Used to mark end of Scope.
 *
 * - `scope` to end.
 * - `returnValue` (optional) to be passed to the WTF.
 *
 * Returns the `returnValue for easy chaining.
 */
exports.wtfLeave = exports.wtfEnabled ? impl.leave : function (s, r) { return r; };
/**
 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
 * enabled.
 *
 *     someMethod() {
 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
 *        var future = new Future.delay(5).then((_) {
 *          wtfEndTimeRange(s);
 *        });
 *     }
 */
exports.wtfStartTimeRange = exports.wtfEnabled ? impl.startTimeRange : function (rangeType, action) { return null; };
/**
 * Ends a async time range operation.
 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
 * enabled.
 */
exports.wtfEndTimeRange = exports.wtfEnabled ? impl.endTimeRange : function (r) {
    return null;
};

},{"./wtf_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_impl.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_impl.js":[function(require,module,exports){
'use strict';var lang_1 = require('../facade/lang');
var trace;
var events;
function detectWTF() {
    var wtf = lang_1.global['wtf'];
    if (wtf) {
        trace = wtf['trace'];
        if (trace) {
            events = trace['events'];
            return true;
        }
    }
    return false;
}
exports.detectWTF = detectWTF;
function createScope(signature, flags) {
    if (flags === void 0) { flags = null; }
    return events.createScope(signature, flags);
}
exports.createScope = createScope;
function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
}
exports.leave = leave;
function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
}
exports.startTimeRange = startTimeRange;
function endTimeRange(range) {
    trace.endTimeRange(range);
}
exports.endTimeRange = endTimeRange;

},{"../facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/wtf_init.js":[function(require,module,exports){
'use strict';/**
 * This is here because DART requires it. It is noop in JS.
 */
function wtfInit() { }
exports.wtfInit = wtfInit;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js":[function(require,module,exports){
'use strict';var reflector_1 = require('./reflector');
var reflector_2 = require('./reflector');
exports.Reflector = reflector_2.Reflector;
exports.ReflectionInfo = reflector_2.ReflectionInfo;
var reflection_capabilities_1 = require('./reflection_capabilities');
exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());

},{"./reflection_capabilities":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection_capabilities.js","./reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflector.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection_capabilities.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ReflectionCapabilities = (function () {
    function ReflectionCapabilities(reflect) {
        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
    ReflectionCapabilities.prototype.factory = function (t) {
        switch (t.length) {
            case 0:
                return function () { return new t(); };
            case 1:
                return function (a1) { return new t(a1); };
            case 2:
                return function (a1, a2) { return new t(a1, a2); };
            case 3:
                return function (a1, a2, a3) { return new t(a1, a2, a3); };
            case 4:
                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) { return new t(a1, a2, a3, a4, a5, a6); };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) { return new t(a1, a2, a3, a4, a5, a6, a7); };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return new t(a1, a2, a3, a4, a5, a6, a7, a8); };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9); };
            case 10:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                };
            case 11:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                };
            case 12:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                };
            case 13:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                };
            case 14:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                };
            case 15:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                };
            case 16:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                };
            case 17:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                };
            case 18:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
                };
            case 19:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                };
            case 20:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                };
        }
        ;
        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
    };
    /** @internal */
    ReflectionCapabilities.prototype._zipTypesAndAnnotaions = function (paramTypes, paramAnnotations) {
        var result;
        if (typeof paramTypes === 'undefined') {
            result = collection_1.ListWrapper.createFixedSize(paramAnnotations.length);
        }
        else {
            result = collection_1.ListWrapper.createFixedSize(paramTypes.length);
        }
        for (var i = 0; i < result.length; i++) {
            // TS outputs Object for parameters without types, while Traceur omits
            // the annotations. For now we preserve the Traceur behavior to aid
            // migration, but this can be revisited.
            if (typeof paramTypes === 'undefined') {
                result[i] = [];
            }
            else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
            }
            else {
                result[i] = [];
            }
            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
            }
        }
        return result;
    };
    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.parameters)) {
            return typeOrFunc.parameters;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
            }
        }
        return collection_1.ListWrapper.createFixedSize(typeOrFunc.length);
    };
    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.annotations)) {
            var annotations = typeOrFunc.annotations;
            if (lang_1.isFunction(annotations) && annotations.annotations) {
                annotations = annotations.annotations;
            }
            return annotations;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
            if (lang_1.isPresent(annotations))
                return annotations;
        }
        return [];
    };
    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
            var propMetadata = typeOrFunc.propMetadata;
            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
                propMetadata = propMetadata.propMetadata;
            }
            return propMetadata;
        }
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
            if (lang_1.isPresent(propMetadata))
                return propMetadata;
        }
        return {};
    };
    ReflectionCapabilities.prototype.interfaces = function (type) {
        throw new exceptions_1.BaseException("JavaScript does not support interfaces");
    };
    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
    ReflectionCapabilities.prototype.setter = function (name) {
        return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function (name) {
        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
        return new Function('o', 'args', functionBody);
    };
    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
    ReflectionCapabilities.prototype.importUri = function (type) { return './'; };
    return ReflectionCapabilities;
})();
exports.ReflectionCapabilities = ReflectionCapabilities;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var ReflectionInfo = (function () {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
        this.annotations = annotations;
        this.parameters = parameters;
        this.factory = factory;
        this.interfaces = interfaces;
        this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
})();
exports.ReflectionInfo = ReflectionInfo;
var Reflector = (function () {
    function Reflector(reflectionCapabilities) {
        /** @internal */
        this._injectableInfo = new collection_1.Map();
        /** @internal */
        this._getters = new collection_1.Map();
        /** @internal */
        this._setters = new collection_1.Map();
        /** @internal */
        this._methods = new collection_1.Map();
        this._usedKeys = null;
        this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
    /**
     * Causes `this` reflector to track keys used to access
     * {@link ReflectionInfo} objects.
     */
    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
    /**
     * Lists types for which reflection information was not requested since
     * {@link #trackUsage} was called. This list could later be audited as
     * potential dead code.
     */
    Reflector.prototype.listUnusedKeys = function () {
        var _this = this;
        if (this._usedKeys == null) {
            throw new exceptions_1.BaseException('Usage tracking is disabled');
        }
        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
        return collection_1.ListWrapper.filter(allTypes, function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
    };
    Reflector.prototype.registerFunction = function (func, funcInfo) {
        this._injectableInfo.set(func, funcInfo);
    };
    Reflector.prototype.registerType = function (type, typeInfo) {
        this._injectableInfo.set(type, typeInfo);
    };
    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
    Reflector.prototype.factory = function (type) {
        if (this._containsReflectionInfo(type)) {
            var res = this._getReflectionInfo(type).factory;
            return lang_1.isPresent(res) ? res : null;
        }
        else {
            return this.reflectionCapabilities.factory(type);
        }
    };
    Reflector.prototype.parameters = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).parameters;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.parameters(typeOrFunc);
        }
    };
    Reflector.prototype.annotations = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).annotations;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.annotations(typeOrFunc);
        }
    };
    Reflector.prototype.propMetadata = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
            return lang_1.isPresent(res) ? res : {};
        }
        else {
            return this.reflectionCapabilities.propMetadata(typeOrFunc);
        }
    };
    Reflector.prototype.interfaces = function (type) {
        if (this._injectableInfo.has(type)) {
            var res = this._getReflectionInfo(type).interfaces;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.interfaces(type);
        }
    };
    Reflector.prototype.getter = function (name) {
        if (this._getters.has(name)) {
            return this._getters.get(name);
        }
        else {
            return this.reflectionCapabilities.getter(name);
        }
    };
    Reflector.prototype.setter = function (name) {
        if (this._setters.has(name)) {
            return this._setters.get(name);
        }
        else {
            return this.reflectionCapabilities.setter(name);
        }
    };
    Reflector.prototype.method = function (name) {
        if (this._methods.has(name)) {
            return this._methods.get(name);
        }
        else {
            return this.reflectionCapabilities.method(name);
        }
    };
    /** @internal */
    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
        if (lang_1.isPresent(this._usedKeys)) {
            this._usedKeys.add(typeOrFunc);
        }
        return this._injectableInfo.get(typeOrFunc);
    };
    /** @internal */
    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
    return Reflector;
})();
exports.Reflector = Reflector;
function _mergeMaps(target, config) {
    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
}

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render.js":[function(require,module,exports){
'use strict';// Public API for render
var render_1 = require('./render/render');
exports.Renderer = render_1.Renderer;
exports.RenderViewRef = render_1.RenderViewRef;
exports.RenderProtoViewRef = render_1.RenderProtoViewRef;
exports.RenderFragmentRef = render_1.RenderFragmentRef;
exports.RenderViewWithFragments = render_1.RenderViewWithFragments;
exports.DOCUMENT = render_1.DOCUMENT;

},{"./render/render":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js":[function(require,module,exports){
'use strict';/**
 * Represents an Angular ProtoView in the Rendering Context.
 *
 * When you implement a custom {@link Renderer}, `RenderProtoViewRef` specifies what Render View
 * your renderer should create.
 *
 * `RenderProtoViewRef` is a counterpart to {@link ProtoViewRef} available in the Application
 * Context. But unlike `ProtoViewRef`, `RenderProtoViewRef` contains all static nested Proto Views
 * that are recursively merged into a single Render Proto View.

 *
 * <!-- TODO: this is created by Renderer#createProtoView in the new compiler -->
 */
var RenderProtoViewRef = (function () {
    function RenderProtoViewRef() {
    }
    return RenderProtoViewRef;
})();
exports.RenderProtoViewRef = RenderProtoViewRef;
/**
 * Represents a list of sibling Nodes that can be moved by the {@link Renderer} independently of
 * other Render Fragments.
 *
 * Any {@link RenderView} has one Render Fragment.
 *
 * Additionally any View with an Embedded View that contains a {@link NgContent View Projection}
 * results in additional Render Fragment.
 */
/*
  <div>foo</div>
  {{bar}}


  <div>foo</div> -> view 1 / fragment 1
  <ul>
    <template ng-for>
      <li>{{fg}}</li> -> view 2 / fragment 1
    </template>
  </ul>
  {{bar}}


  <div>foo</div> -> view 1 / fragment 1
  <ul>
    <template ng-if>
      <li><ng-content></></li> -> view 1 / fragment 2
    </template>
    <template ng-for>
      <li><ng-content></></li> ->
      <li></li>                -> view 1 / fragment 2 + view 2 / fragment 1..n-1
    </template>
  </ul>
  {{bar}}
 */
// TODO(i): refactor into an interface
var RenderFragmentRef = (function () {
    function RenderFragmentRef() {
    }
    return RenderFragmentRef;
})();
exports.RenderFragmentRef = RenderFragmentRef;
/**
 * Represents an Angular View in the Rendering Context.
 *
 * `RenderViewRef` specifies to the {@link Renderer} what View to update or destroy.
 *
 * Unlike a {@link ViewRef} available in the Application Context, Render View contains all the
 * static Component Views that have been recursively merged into a single Render View.
 *
 * Each `RenderViewRef` contains one or more {@link RenderFragmentRef Render Fragments}, these
 * Fragments are created, hydrated, dehydrated and destroyed as a single unit together with the
 * View.
 */
// TODO(i): refactor into an interface
var RenderViewRef = (function () {
    function RenderViewRef() {
    }
    return RenderViewRef;
})();
exports.RenderViewRef = RenderViewRef;
/**
 * Container class produced by a {@link Renderer} when creating a Render View.
 *
 * An instance of `RenderViewWithFragments` contains a {@link RenderViewRef} and an array of
 * {@link RenderFragmentRef}s belonging to this Render View.
 */
// TODO(i): refactor this by RenderViewWithFragments and adding fragments directly to RenderViewRef
var RenderViewWithFragments = (function () {
    function RenderViewWithFragments(
        /**
         * Reference to the {@link RenderViewRef}.
         */
        viewRef, 
        /**
         * Array of {@link RenderFragmentRef}s ordered in the depth-first order.
         */
        fragmentRefs) {
        this.viewRef = viewRef;
        this.fragmentRefs = fragmentRefs;
    }
    return RenderViewWithFragments;
})();
exports.RenderViewWithFragments = RenderViewWithFragments;
/**
 * Injectable service that provides a low-level interface for modifying the UI.
 *
 * Use this service to bypass Angular's templating and make custom UI changes that can't be
 * expressed declaratively. For example if you need to set a property or an attribute whose name is
 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
 * respectively.
 *
 * If you are implementing a custom renderer, you must implement this interface.
 *
 * The default Renderer implementation is {@link DomRenderer}. Also see {@link WebWorkerRenderer}.
 */
var Renderer = (function () {
    function Renderer() {
    }
    return Renderer;
})();
exports.Renderer = Renderer;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_renderer.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var di_1 = require('angular2/src/core/di');
var animation_builder_1 = require('angular2/src/animate/animation_builder');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var event_manager_1 = require('./events/event_manager');
var shared_styles_host_1 = require('./shared_styles_host');
var profile_1 = require('../../profile/profile');
var api_1 = require('../api');
var dom_tokens_1 = require('./dom_tokens');
var view_factory_1 = require('../view_factory');
var view_1 = require('../view');
var util_1 = require('./util');
var DomRenderer = (function (_super) {
    __extends(DomRenderer, _super);
    function DomRenderer() {
        _super.apply(this, arguments);
    }
    DomRenderer.prototype.createProtoView = function (cmds) {
        return new view_1.DefaultProtoViewRef(cmds);
    };
    DomRenderer.prototype.getNativeElementSync = function (location) {
        return resolveInternalDomView(location.renderView).boundElements[location.boundElementIndex];
    };
    DomRenderer.prototype.getRootNodes = function (fragment) { return resolveInternalDomFragment(fragment); };
    DomRenderer.prototype.attachFragmentAfterFragment = function (previousFragmentRef, fragmentRef) {
        var previousFragmentNodes = resolveInternalDomFragment(previousFragmentRef);
        if (previousFragmentNodes.length > 0) {
            var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
            var nodes = resolveInternalDomFragment(fragmentRef);
            moveNodesAfterSibling(sibling, nodes);
            this.animateNodesEnter(nodes);
        }
    };
    /**
     * Iterates through all nodes being added to the DOM and animates them if necessary
     * @param nodes
     */
    DomRenderer.prototype.animateNodesEnter = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            this.animateNodeEnter(nodes[i]);
    };
    DomRenderer.prototype.attachFragmentAfterElement = function (elementRef, fragmentRef) {
        var parentView = resolveInternalDomView(elementRef.renderView);
        var element = parentView.boundElements[elementRef.boundElementIndex];
        var nodes = resolveInternalDomFragment(fragmentRef);
        moveNodesAfterSibling(element, nodes);
        this.animateNodesEnter(nodes);
    };
    DomRenderer.prototype.hydrateView = function (viewRef) { resolveInternalDomView(viewRef).hydrate(); };
    DomRenderer.prototype.dehydrateView = function (viewRef) { resolveInternalDomView(viewRef).dehydrate(); };
    DomRenderer.prototype.createTemplateAnchor = function (attrNameAndValues) {
        return this.createElement('script', attrNameAndValues);
    };
    DomRenderer.prototype.createText = function (value) { return dom_adapter_1.DOM.createTextNode(lang_1.isPresent(value) ? value : ''); };
    DomRenderer.prototype.appendChild = function (parent, child) { dom_adapter_1.DOM.appendChild(parent, child); };
    DomRenderer.prototype.setElementProperty = function (location, propertyName, propertyValue) {
        var view = resolveInternalDomView(location.renderView);
        dom_adapter_1.DOM.setProperty(view.boundElements[location.boundElementIndex], propertyName, propertyValue);
    };
    DomRenderer.prototype.setElementAttribute = function (location, attributeName, attributeValue) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        var dashCasedAttributeName = util_1.camelCaseToDashCase(attributeName);
        if (lang_1.isPresent(attributeValue)) {
            dom_adapter_1.DOM.setAttribute(element, dashCasedAttributeName, lang_1.stringify(attributeValue));
        }
        else {
            dom_adapter_1.DOM.removeAttribute(element, dashCasedAttributeName);
        }
    };
    DomRenderer.prototype.setElementClass = function (location, className, isAdd) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        if (isAdd) {
            dom_adapter_1.DOM.addClass(element, className);
        }
        else {
            dom_adapter_1.DOM.removeClass(element, className);
        }
    };
    DomRenderer.prototype.setElementStyle = function (location, styleName, styleValue) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        var dashCasedStyleName = util_1.camelCaseToDashCase(styleName);
        if (lang_1.isPresent(styleValue)) {
            dom_adapter_1.DOM.setStyle(element, dashCasedStyleName, lang_1.stringify(styleValue));
        }
        else {
            dom_adapter_1.DOM.removeStyle(element, dashCasedStyleName);
        }
    };
    DomRenderer.prototype.invokeElementMethod = function (location, methodName, args) {
        var view = resolveInternalDomView(location.renderView);
        var element = view.boundElements[location.boundElementIndex];
        dom_adapter_1.DOM.invoke(element, methodName, args);
    };
    DomRenderer.prototype.setText = function (viewRef, textNodeIndex, text) {
        var view = resolveInternalDomView(viewRef);
        dom_adapter_1.DOM.setText(view.boundTextNodes[textNodeIndex], text);
    };
    DomRenderer.prototype.setEventDispatcher = function (viewRef, dispatcher) {
        resolveInternalDomView(viewRef).setEventDispatcher(dispatcher);
    };
    return DomRenderer;
})(api_1.Renderer);
exports.DomRenderer = DomRenderer;
var DomRenderer_ = (function (_super) {
    __extends(DomRenderer_, _super);
    function DomRenderer_(_eventManager, _domSharedStylesHost, _animate, document) {
        _super.call(this);
        this._eventManager = _eventManager;
        this._domSharedStylesHost = _domSharedStylesHost;
        this._animate = _animate;
        this._componentCmds = new Map();
        this._nativeShadowStyles = new Map();
        /** @internal */
        this._createRootHostViewScope = profile_1.wtfCreateScope('DomRenderer#createRootHostView()');
        /** @internal */
        this._createViewScope = profile_1.wtfCreateScope('DomRenderer#createView()');
        /** @internal */
        this._detachFragmentScope = profile_1.wtfCreateScope('DomRenderer#detachFragment()');
        this._document = document;
    }
    DomRenderer_.prototype.registerComponentTemplate = function (templateId, commands, styles, nativeShadow) {
        this._componentCmds.set(templateId, commands);
        if (nativeShadow) {
            this._nativeShadowStyles.set(templateId, styles);
        }
        else {
            this._domSharedStylesHost.addStyles(styles);
        }
    };
    DomRenderer_.prototype.resolveComponentTemplate = function (templateId) {
        return this._componentCmds.get(templateId);
    };
    DomRenderer_.prototype.createRootHostView = function (hostProtoViewRef, fragmentCount, hostElementSelector) {
        var s = this._createRootHostViewScope();
        var element = dom_adapter_1.DOM.querySelector(this._document, hostElementSelector);
        if (lang_1.isBlank(element)) {
            profile_1.wtfLeave(s);
            throw new exceptions_1.BaseException("The selector \"" + hostElementSelector + "\" did not match any elements");
        }
        return profile_1.wtfLeave(s, this._createView(hostProtoViewRef, element));
    };
    DomRenderer_.prototype.createView = function (protoViewRef, fragmentCount) {
        var s = this._createViewScope();
        return profile_1.wtfLeave(s, this._createView(protoViewRef, null));
    };
    DomRenderer_.prototype._createView = function (protoViewRef, inplaceElement) {
        var view = view_factory_1.createRenderView(protoViewRef.cmds, inplaceElement, this);
        var sdRoots = view.nativeShadowRoots;
        for (var i = 0; i < sdRoots.length; i++) {
            this._domSharedStylesHost.addHost(sdRoots[i]);
        }
        return new api_1.RenderViewWithFragments(view, view.fragments);
    };
    DomRenderer_.prototype.destroyView = function (viewRef) {
        var view = viewRef;
        var sdRoots = view.nativeShadowRoots;
        for (var i = 0; i < sdRoots.length; i++) {
            this._domSharedStylesHost.removeHost(sdRoots[i]);
        }
    };
    DomRenderer_.prototype.animateNodeEnter = function (node) {
        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {
            dom_adapter_1.DOM.addClass(node, 'ng-enter');
            this._animate.css()
                .addAnimationClass('ng-enter-active')
                .start(node)
                .onComplete(function () { dom_adapter_1.DOM.removeClass(node, 'ng-enter'); });
        }
    };
    DomRenderer_.prototype.animateNodeLeave = function (node) {
        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {
            dom_adapter_1.DOM.addClass(node, 'ng-leave');
            this._animate.css()
                .addAnimationClass('ng-leave-active')
                .start(node)
                .onComplete(function () {
                dom_adapter_1.DOM.removeClass(node, 'ng-leave');
                dom_adapter_1.DOM.remove(node);
            });
        }
        else {
            dom_adapter_1.DOM.remove(node);
        }
    };
    DomRenderer_.prototype.detachFragment = function (fragmentRef) {
        var s = this._detachFragmentScope();
        var fragmentNodes = resolveInternalDomFragment(fragmentRef);
        for (var i = 0; i < fragmentNodes.length; i++) {
            this.animateNodeLeave(fragmentNodes[i]);
        }
        profile_1.wtfLeave(s);
    };
    DomRenderer_.prototype.createElement = function (name, attrNameAndValues) {
        var el = dom_adapter_1.DOM.createElement(name);
        this._setAttributes(el, attrNameAndValues);
        return el;
    };
    DomRenderer_.prototype.mergeElement = function (existing, attrNameAndValues) {
        dom_adapter_1.DOM.clearNodes(existing);
        this._setAttributes(existing, attrNameAndValues);
    };
    DomRenderer_.prototype._setAttributes = function (node, attrNameAndValues) {
        for (var attrIdx = 0; attrIdx < attrNameAndValues.length; attrIdx += 2) {
            dom_adapter_1.DOM.setAttribute(node, attrNameAndValues[attrIdx], attrNameAndValues[attrIdx + 1]);
        }
    };
    DomRenderer_.prototype.createRootContentInsertionPoint = function () {
        return dom_adapter_1.DOM.createComment('root-content-insertion-point');
    };
    DomRenderer_.prototype.createShadowRoot = function (host, templateId) {
        var sr = dom_adapter_1.DOM.createShadowRoot(host);
        var styles = this._nativeShadowStyles.get(templateId);
        for (var i = 0; i < styles.length; i++) {
            dom_adapter_1.DOM.appendChild(sr, dom_adapter_1.DOM.createStyleElement(styles[i]));
        }
        return sr;
    };
    DomRenderer_.prototype.on = function (element, eventName, callback) {
        this._eventManager.addEventListener(element, eventName, decoratePreventDefault(callback));
    };
    DomRenderer_.prototype.globalOn = function (target, eventName, callback) {
        return this._eventManager.addGlobalEventListener(target, eventName, decoratePreventDefault(callback));
    };
    DomRenderer_ = __decorate([
        di_1.Injectable(),
        __param(3, di_1.Inject(dom_tokens_1.DOCUMENT)), 
        __metadata('design:paramtypes', [event_manager_1.EventManager, shared_styles_host_1.DomSharedStylesHost, animation_builder_1.AnimationBuilder, Object])
    ], DomRenderer_);
    return DomRenderer_;
})(DomRenderer);
exports.DomRenderer_ = DomRenderer_;
function resolveInternalDomView(viewRef) {
    return viewRef;
}
function resolveInternalDomFragment(fragmentRef) {
    return fragmentRef.nodes;
}
function moveNodesAfterSibling(sibling, nodes) {
    if (nodes.length > 0 && lang_1.isPresent(dom_adapter_1.DOM.parentElement(sibling))) {
        for (var i = 0; i < nodes.length; i++) {
            dom_adapter_1.DOM.insertBefore(sibling, nodes[i]);
        }
        dom_adapter_1.DOM.insertBefore(nodes[0], sibling);
    }
}
function moveChildNodes(source, target) {
    var currChild = dom_adapter_1.DOM.firstChild(source);
    while (lang_1.isPresent(currChild)) {
        var nextChild = dom_adapter_1.DOM.nextSibling(currChild);
        dom_adapter_1.DOM.appendChild(target, currChild);
        currChild = nextChild;
    }
}
function decoratePreventDefault(eventHandler) {
    return function (event) {
        var allowDefaultBehavior = eventHandler(event);
        if (!allowDefaultBehavior) {
            // TODO(tbosch): move preventDefault into event plugins...
            dom_adapter_1.DOM.preventDefault(event);
        }
    };
}

},{"../../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","../api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","../view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js","../view_factory":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view_factory.js","./dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","./events/event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","./shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js","./util":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js","angular2/src/animate/animation_builder":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/animate/animation_builder.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js":[function(require,module,exports){
'use strict';var di_1 = require('angular2/src/core/di');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
 *
 * Note: Document might not be available in the Application Context when Application and Rendering
 * Contexts are not the same (e.g. when running the application into a Web Worker).
 */
exports.DOCUMENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('DocumentToken'));

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var ng_zone_1 = require('angular2/src/core/zone/ng_zone');
var di_1 = require('angular2/src/core/di');
exports.EVENT_MANAGER_PLUGINS = lang_1.CONST_EXPR(new di_1.OpaqueToken("EventManagerPlugins"));
var EventManager = (function () {
    function EventManager(plugins, _zone) {
        var _this = this;
        this._zone = _zone;
        plugins.forEach(function (p) { return p.manager = _this; });
        this._plugins = collection_1.ListWrapper.reversed(plugins);
    }
    EventManager.prototype.addEventListener = function (element, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function () { return this._zone; };
    /** @internal */
    EventManager.prototype._findPluginFor = function (eventName) {
        var plugins = this._plugins;
        for (var i = 0; i < plugins.length; i++) {
            var plugin = plugins[i];
            if (plugin.supports(eventName)) {
                return plugin;
            }
        }
        throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
    };
    EventManager = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(exports.EVENT_MANAGER_PLUGINS)), 
        __metadata('design:paramtypes', [Array, ng_zone_1.NgZone])
    ], EventManager);
    return EventManager;
})();
exports.EventManager = EventManager;
var EventManagerPlugin = (function () {
    function EventManagerPlugin() {
    }
    // That is equivalent to having supporting $event.target
    EventManagerPlugin.prototype.supports = function (eventName) { return false; };
    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    return EventManagerPlugin;
})();
exports.EventManagerPlugin = EventManagerPlugin;
var DomEventsPlugin = (function (_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin() {
        _super.apply(this, arguments);
    }
    // This plugin should come last in the list of plugins, because it accepts all
    // events.
    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
        this.manager.getZone().runOutsideAngular(function () { dom_adapter_1.DOM.on(element, eventName, outsideHandler); });
    };
    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var element = dom_adapter_1.DOM.getGlobalEventTarget(target);
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.DOM.onAndCancel(element, eventName, outsideHandler); });
    };
    DomEventsPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], DomEventsPlugin);
    return DomEventsPlugin;
})(EventManagerPlugin);
exports.DomEventsPlugin = DomEventsPlugin;

},{"angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_common.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var event_manager_1 = require('./event_manager');
var collection_1 = require('angular2/src/core/facade/collection');
var _eventNames = {
    // pan
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    // pinch
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    // press
    'press': true,
    'pressup': true,
    // rotate
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    // swipe
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    // tap
    'tap': true,
};
var HammerGesturesPluginCommon = (function (_super) {
    __extends(HammerGesturesPluginCommon, _super);
    function HammerGesturesPluginCommon() {
        _super.call(this);
    }
    HammerGesturesPluginCommon.prototype.supports = function (eventName) {
        eventName = eventName.toLowerCase();
        return collection_1.StringMapWrapper.contains(_eventNames, eventName);
    };
    return HammerGesturesPluginCommon;
})(event_manager_1.EventManagerPlugin);
exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;

},{"./event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_gestures.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var hammer_common_1 = require('./hammer_common');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var di_1 = require('angular2/src/core/di');
var HammerGesturesPlugin = (function (_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin() {
        _super.apply(this, arguments);
    }
    HammerGesturesPlugin.prototype.supports = function (eventName) {
        if (!_super.prototype.supports.call(this, eventName))
            return false;
        if (!lang_1.isPresent(window['Hammer'])) {
            throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
        }
        return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        zone.runOutsideAngular(function () {
            // Creating the manager bind events, must be done outside of angular
            var mc = new Hammer(element);
            mc.get('pinch').set({ enable: true });
            mc.get('rotate').set({ enable: true });
            mc.on(eventName, function (eventObj) { zone.run(function () { handler(eventObj); }); });
        });
    };
    HammerGesturesPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HammerGesturesPlugin);
    return HammerGesturesPlugin;
})(hammer_common_1.HammerGesturesPluginCommon);
exports.HammerGesturesPlugin = HammerGesturesPlugin;

},{"./hammer_common":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/hammer_common.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/key_events.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var lang_1 = require('angular2/src/core/facade/lang');
var collection_1 = require('angular2/src/core/facade/collection');
var event_manager_1 = require('./event_manager');
var di_1 = require('angular2/src/core/di');
var modifierKeys = ['alt', 'control', 'meta', 'shift'];
var modifierKeyGetters = {
    'alt': function (event) { return event.altKey; },
    'control': function (event) { return event.ctrlKey; },
    'meta': function (event) { return event.metaKey; },
    'shift': function (event) { return event.shiftKey; }
};
var KeyEventsPlugin = (function (_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin() {
        _super.call(this);
    }
    KeyEventsPlugin.prototype.supports = function (eventName) {
        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
    };
    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
        this.manager.getZone().runOutsideAngular(function () {
            dom_adapter_1.DOM.on(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
        });
    };
    KeyEventsPlugin.parseEventName = function (eventName) {
        var parts = eventName.toLowerCase().split('.');
        var domEventName = parts.shift();
        if ((parts.length === 0) ||
            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||
                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
            return null;
        }
        var key = KeyEventsPlugin._normalizeKey(parts.pop());
        var fullKey = '';
        modifierKeys.forEach(function (modifierName) {
            if (collection_1.ListWrapper.contains(parts, modifierName)) {
                collection_1.ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
            }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
            // returning null instead of throwing to let another plugin process the event
            return null;
        }
        var result = collection_1.StringMapWrapper.create();
        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
        return result;
    };
    KeyEventsPlugin.getEventFullKey = function (event) {
        var fullKey = '';
        var key = dom_adapter_1.DOM.getEventKey(event);
        key = key.toLowerCase();
        if (lang_1.StringWrapper.equals(key, ' ')) {
            key = 'space'; // for readability
        }
        else if (lang_1.StringWrapper.equals(key, '.')) {
            key = 'dot'; // because '.' is used as a separator in event names
        }
        modifierKeys.forEach(function (modifierName) {
            if (modifierName != key) {
                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                    fullKey += modifierName + '.';
                }
            }
        });
        fullKey += key;
        return fullKey;
    };
    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
        return function (event) {
            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                zone.run(function () { return handler(event); });
            }
        };
    };
    KeyEventsPlugin._normalizeKey = function (keyName) {
        // TODO: switch to a StringMap if the mapping grows too much
        switch (keyName) {
            case 'esc':
                return 'escape';
            default:
                return keyName;
        }
    };
    KeyEventsPlugin = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], KeyEventsPlugin);
    return KeyEventsPlugin;
})(event_manager_1.EventManagerPlugin);
exports.KeyEventsPlugin = KeyEventsPlugin;

},{"./event_manager":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/events/event_manager.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var di_1 = require('angular2/src/core/di');
var collection_1 = require('angular2/src/core/facade/collection');
var dom_tokens_1 = require('./dom_tokens');
var SharedStylesHost = (function () {
    function SharedStylesHost() {
        /** @internal */
        this._styles = [];
        /** @internal */
        this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function (styles) {
        var _this = this;
        var additions = [];
        styles.forEach(function (style) {
            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
                _this._stylesSet.add(style);
                _this._styles.push(style);
                additions.push(style);
            }
        });
        this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
    SharedStylesHost = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], SharedStylesHost);
    return SharedStylesHost;
})();
exports.SharedStylesHost = SharedStylesHost;
var DomSharedStylesHost = (function (_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(doc) {
        _super.call(this);
        this._hostNodes = new Set();
        this._hostNodes.add(doc.head);
    }
    /** @internal */
    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
        for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            dom_adapter_1.DOM.appendChild(host, dom_adapter_1.DOM.createStyleElement(style));
        }
    };
    DomSharedStylesHost.prototype.addHost = function (hostNode) {
        this._addStylesToHost(this._styles, hostNode);
        this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };
    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
        var _this = this;
        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
    };
    DomSharedStylesHost = __decorate([
        di_1.Injectable(),
        __param(0, di_1.Inject(dom_tokens_1.DOCUMENT)), 
        __metadata('design:paramtypes', [Object])
    ], DomSharedStylesHost);
    return DomSharedStylesHost;
})(SharedStylesHost);
exports.DomSharedStylesHost = DomSharedStylesHost;

},{"./dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/util.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/render.js":[function(require,module,exports){
'use strict';/**
 * @module
 * @description
 * This module provides advanced support for extending dom strategy.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./dom/shared_styles_host'));
__export(require('./dom/dom_renderer'));
__export(require('./dom/dom_tokens'));
__export(require('./api'));

},{"./api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","./dom/dom_renderer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_renderer.js","./dom/dom_tokens":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/dom_tokens.js","./dom/shared_styles_host":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/dom/shared_styles_host.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var api_1 = require('./api');
var DefaultProtoViewRef = (function (_super) {
    __extends(DefaultProtoViewRef, _super);
    function DefaultProtoViewRef(cmds) {
        _super.call(this);
        this.cmds = cmds;
    }
    return DefaultProtoViewRef;
})(api_1.RenderProtoViewRef);
exports.DefaultProtoViewRef = DefaultProtoViewRef;
var DefaultRenderFragmentRef = (function (_super) {
    __extends(DefaultRenderFragmentRef, _super);
    function DefaultRenderFragmentRef(nodes) {
        _super.call(this);
        this.nodes = nodes;
    }
    return DefaultRenderFragmentRef;
})(api_1.RenderFragmentRef);
exports.DefaultRenderFragmentRef = DefaultRenderFragmentRef;
var DefaultRenderView = (function (_super) {
    __extends(DefaultRenderView, _super);
    function DefaultRenderView(fragments, boundTextNodes, boundElements, nativeShadowRoots, globalEventAdders, rootContentInsertionPoints) {
        _super.call(this);
        this.fragments = fragments;
        this.boundTextNodes = boundTextNodes;
        this.boundElements = boundElements;
        this.nativeShadowRoots = nativeShadowRoots;
        this.globalEventAdders = globalEventAdders;
        this.rootContentInsertionPoints = rootContentInsertionPoints;
        this.hydrated = false;
        this.eventDispatcher = null;
        this.globalEventRemovers = null;
    }
    DefaultRenderView.prototype.hydrate = function () {
        if (this.hydrated)
            throw new exceptions_1.BaseException('The view is already hydrated.');
        this.hydrated = true;
        this.globalEventRemovers = collection_1.ListWrapper.createFixedSize(this.globalEventAdders.length);
        for (var i = 0; i < this.globalEventAdders.length; i++) {
            this.globalEventRemovers[i] = this.globalEventAdders[i]();
        }
    };
    DefaultRenderView.prototype.dehydrate = function () {
        if (!this.hydrated)
            throw new exceptions_1.BaseException('The view is already dehydrated.');
        for (var i = 0; i < this.globalEventRemovers.length; i++) {
            this.globalEventRemovers[i]();
        }
        this.globalEventRemovers = null;
        this.hydrated = false;
    };
    DefaultRenderView.prototype.setEventDispatcher = function (dispatcher) { this.eventDispatcher = dispatcher; };
    DefaultRenderView.prototype.dispatchRenderEvent = function (boundElementIndex, eventName, event) {
        var allowDefaultBehavior = true;
        if (lang_1.isPresent(this.eventDispatcher)) {
            var locals = new collection_1.Map();
            locals.set('$event', event);
            allowDefaultBehavior =
                this.eventDispatcher.dispatchRenderEvent(boundElementIndex, eventName, locals);
        }
        return allowDefaultBehavior;
    };
    return DefaultRenderView;
})(api_1.RenderViewRef);
exports.DefaultRenderView = DefaultRenderView;

},{"./api":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/api.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view_factory.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var view_1 = require('./view');
function createRenderView(fragmentCmds, inplaceElement, nodeFactory) {
    var view;
    var eventDispatcher = function (boundElementIndex, eventName, event) {
        return view.dispatchRenderEvent(boundElementIndex, eventName, event);
    };
    var context = new BuildContext(eventDispatcher, nodeFactory, inplaceElement);
    context.build(fragmentCmds);
    var fragments = [];
    for (var i = 0; i < context.fragments.length; i++) {
        fragments.push(new view_1.DefaultRenderFragmentRef(context.fragments[i]));
    }
    view = new view_1.DefaultRenderView(fragments, context.boundTextNodes, context.boundElements, context.nativeShadowRoots, context.globalEventAdders, context.rootContentInsertionPoints);
    return view;
}
exports.createRenderView = createRenderView;
var BuildContext = (function () {
    function BuildContext(_eventDispatcher, factory, _inplaceElement) {
        this._eventDispatcher = _eventDispatcher;
        this.factory = factory;
        this._inplaceElement = _inplaceElement;
        this._builders = [];
        this.globalEventAdders = [];
        this.boundElements = [];
        this.boundTextNodes = [];
        this.nativeShadowRoots = [];
        this.fragments = [];
        this.rootContentInsertionPoints = [];
        this.componentCount = 0;
        this.isHost = lang_1.isPresent((_inplaceElement));
    }
    BuildContext.prototype.build = function (fragmentCmds) {
        this.enqueueFragmentBuilder(null, fragmentCmds);
        this._build(this._builders[0]);
    };
    BuildContext.prototype._build = function (builder) {
        this._builders = [];
        builder.build(this);
        var enqueuedBuilders = this._builders;
        for (var i = 0; i < enqueuedBuilders.length; i++) {
            this._build(enqueuedBuilders[i]);
        }
    };
    BuildContext.prototype.enqueueComponentBuilder = function (component) {
        this.componentCount++;
        this._builders.push(new RenderViewBuilder(component, null, this.factory.resolveComponentTemplate(component.cmd.templateId)));
    };
    BuildContext.prototype.enqueueFragmentBuilder = function (parentComponent, commands) {
        var rootNodes = [];
        this.fragments.push(rootNodes);
        this._builders.push(new RenderViewBuilder(parentComponent, rootNodes, commands));
    };
    BuildContext.prototype.consumeInplaceElement = function () {
        var result = this._inplaceElement;
        this._inplaceElement = null;
        return result;
    };
    BuildContext.prototype.addEventListener = function (boundElementIndex, target, eventName) {
        if (lang_1.isPresent(target)) {
            var handler = createEventHandler(boundElementIndex, target + ":" + eventName, this._eventDispatcher);
            this.globalEventAdders.push(createGlobalEventAdder(target, eventName, handler, this.factory));
        }
        else {
            var handler = createEventHandler(boundElementIndex, eventName, this._eventDispatcher);
            this.factory.on(this.boundElements[boundElementIndex], eventName, handler);
        }
    };
    return BuildContext;
})();
function createEventHandler(boundElementIndex, eventName, eventDispatcher) {
    return function ($event) { return eventDispatcher(boundElementIndex, eventName, $event); };
}
function createGlobalEventAdder(target, eventName, eventHandler, nodeFactory) {
    return function () { return nodeFactory.globalOn(target, eventName, eventHandler); };
}
var RenderViewBuilder = (function () {
    function RenderViewBuilder(parentComponent, fragmentRootNodes, commands) {
        this.parentComponent = parentComponent;
        this.fragmentRootNodes = fragmentRootNodes;
        this.commands = commands;
        var rootNodesParent = lang_1.isPresent(fragmentRootNodes) ? null : parentComponent.shadowRoot;
        this.parentStack = [rootNodesParent];
    }
    RenderViewBuilder.prototype.build = function (context) {
        for (var i = 0; i < this.commands.length; i++) {
            this.commands[i].visit(this, context);
        }
    };
    Object.defineProperty(RenderViewBuilder.prototype, "parent", {
        get: function () { return this.parentStack[this.parentStack.length - 1]; },
        enumerable: true,
        configurable: true
    });
    RenderViewBuilder.prototype.visitText = function (cmd, context) {
        var text = context.factory.createText(cmd.value);
        this._addChild(text, cmd.ngContentIndex, context);
        if (cmd.isBound) {
            context.boundTextNodes.push(text);
        }
        return null;
    };
    RenderViewBuilder.prototype.visitNgContent = function (cmd, context) {
        if (lang_1.isPresent(this.parentComponent)) {
            if (this.parentComponent.isRoot) {
                var insertionPoint = context.factory.createRootContentInsertionPoint();
                if (this.parent instanceof Component) {
                    context.factory.appendChild(this.parent.shadowRoot, insertionPoint);
                }
                else {
                    context.factory.appendChild(this.parent, insertionPoint);
                }
                context.rootContentInsertionPoints.push(insertionPoint);
            }
            else {
                var projectedNodes = this.parentComponent.project(cmd.index);
                for (var i = 0; i < projectedNodes.length; i++) {
                    var node = projectedNodes[i];
                    this._addChild(node, cmd.ngContentIndex, context);
                }
            }
        }
        return null;
    };
    RenderViewBuilder.prototype.visitBeginElement = function (cmd, context) {
        this.parentStack.push(this._beginElement(cmd, context));
        return null;
    };
    RenderViewBuilder.prototype.visitEndElement = function (context) {
        this._endElement();
        return null;
    };
    RenderViewBuilder.prototype.visitBeginComponent = function (cmd, context) {
        var el = this._beginElement(cmd, context);
        var root = el;
        if (cmd.nativeShadow) {
            root = context.factory.createShadowRoot(el, cmd.templateId);
            context.nativeShadowRoots.push(root);
        }
        var isRoot = context.componentCount === 0 && context.isHost;
        var component = new Component(el, root, cmd, isRoot);
        context.enqueueComponentBuilder(component);
        this.parentStack.push(component);
        return null;
    };
    RenderViewBuilder.prototype.visitEndComponent = function (context) {
        this._endElement();
        return null;
    };
    RenderViewBuilder.prototype.visitEmbeddedTemplate = function (cmd, context) {
        var el = context.factory.createTemplateAnchor(cmd.attrNameAndValues);
        this._addChild(el, cmd.ngContentIndex, context);
        context.boundElements.push(el);
        if (cmd.isMerged) {
            context.enqueueFragmentBuilder(this.parentComponent, cmd.children);
        }
        return null;
    };
    RenderViewBuilder.prototype._beginElement = function (cmd, context) {
        var el = context.consumeInplaceElement();
        if (lang_1.isPresent(el)) {
            context.factory.mergeElement(el, cmd.attrNameAndValues);
            this.fragmentRootNodes.push(el);
        }
        else {
            el = context.factory.createElement(cmd.name, cmd.attrNameAndValues);
            this._addChild(el, cmd.ngContentIndex, context);
        }
        if (cmd.isBound) {
            var boundElementIndex = context.boundElements.length;
            context.boundElements.push(el);
            for (var i = 0; i < cmd.eventTargetAndNames.length; i += 2) {
                var target = cmd.eventTargetAndNames[i];
                var eventName = cmd.eventTargetAndNames[i + 1];
                context.addEventListener(boundElementIndex, target, eventName);
            }
        }
        return el;
    };
    RenderViewBuilder.prototype._endElement = function () { this.parentStack.pop(); };
    RenderViewBuilder.prototype._addChild = function (node, ngContentIndex, context) {
        var parent = this.parent;
        if (lang_1.isPresent(parent)) {
            if (parent instanceof Component) {
                parent.addContentNode(ngContentIndex, node, context);
            }
            else {
                context.factory.appendChild(parent, node);
            }
        }
        else {
            this.fragmentRootNodes.push(node);
        }
    };
    return RenderViewBuilder;
})();
var Component = (function () {
    function Component(hostElement, shadowRoot, cmd, isRoot) {
        this.hostElement = hostElement;
        this.shadowRoot = shadowRoot;
        this.cmd = cmd;
        this.isRoot = isRoot;
        this.contentNodesByNgContentIndex = [];
    }
    Component.prototype.addContentNode = function (ngContentIndex, node, context) {
        if (lang_1.isBlank(ngContentIndex)) {
            if (this.cmd.nativeShadow) {
                context.factory.appendChild(this.hostElement, node);
            }
        }
        else {
            while (this.contentNodesByNgContentIndex.length <= ngContentIndex) {
                this.contentNodesByNgContentIndex.push([]);
            }
            this.contentNodesByNgContentIndex[ngContentIndex].push(node);
        }
    };
    Component.prototype.project = function (ngContentIndex) {
        return ngContentIndex < this.contentNodesByNgContentIndex.length ?
            this.contentNodesByNgContentIndex[ngContentIndex] :
            [];
    };
    return Component;
})();
function addAll(source, target) {
    for (var i = 0; i < source.length; i++) {
        target.push(source[i]);
    }
}

},{"./view":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/render/view.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services.js":[function(require,module,exports){
'use strict';// Public API for Services
var app_root_url_1 = require('angular2/src/core/compiler/app_root_url');
exports.AppRootUrl = app_root_url_1.AppRootUrl;
var url_resolver_1 = require('angular2/src/core/compiler/url_resolver');
exports.UrlResolver = url_resolver_1.UrlResolver;
var title_1 = require('angular2/src/core/services/title');
exports.Title = title_1.Title;

},{"angular2/src/core/compiler/app_root_url":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/app_root_url.js","angular2/src/core/compiler/url_resolver":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/compiler/url_resolver.js","angular2/src/core/services/title":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services/title.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/services/title.js":[function(require,module,exports){
'use strict';var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 */
var Title = (function () {
    function Title() {
    }
    /**
     * Get the title of the current HTML document.
     * @returns {string}
     */
    Title.prototype.getTitle = function () { return dom_adapter_1.DOM.getTitle(); };
    /**
     * Set the title of the current HTML document.
     * @param newTitle
     */
    Title.prototype.setTitle = function (newTitle) { dom_adapter_1.DOM.setTitle(newTitle); };
    return Title;
})();
exports.Title = Title;

},{"angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/browser_testability.js":[function(require,module,exports){
'use strict';var testability_1 = require('angular2/src/core/testability/testability');
var lang_1 = require('angular2/src/core/facade/lang');
var PublicTestability = (function () {
    function PublicTestability(testability) {
        this._testability = testability;
    }
    PublicTestability.prototype.isStable = function () { return this._testability.isStable(); };
    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };
    PublicTestability.prototype.findBindings = function (using, provider, exactMatch) {
        return this.findProviders(using, provider, exactMatch);
    };
    PublicTestability.prototype.findProviders = function (using, provider, exactMatch) {
        return this._testability.findBindings(using, provider, exactMatch);
    };
    return PublicTestability;
})();
var BrowserGetTestability = (function () {
    function BrowserGetTestability() {
    }
    BrowserGetTestability.init = function () { testability_1.setTestabilityGetter(new BrowserGetTestability()); };
    BrowserGetTestability.prototype.addToWindow = function (registry) {
        lang_1.global.getAngularTestability = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            var testability = registry.findTestabilityInTree(elem, findInAncestors);
            if (testability == null) {
                throw new Error('Could not find testability for element.');
            }
            return new PublicTestability(testability);
        };
        lang_1.global.getAllAngularTestabilities = function () {
            var testabilities = registry.getAllTestabilities();
            return testabilities.map(function (testability) { return new PublicTestability(testability); });
        };
    };
    return BrowserGetTestability;
})();
exports.BrowserGetTestability = BrowserGetTestability;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/testability/testability":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/testability/testability.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var di_1 = require('angular2/src/core/di');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var ng_zone_1 = require('../zone/ng_zone');
var async_1 = require('angular2/src/core/facade/async');
/**
 * The Testability service provides testing hooks that can be accessed from
 * the browser and by services such as Protractor. Each bootstrapped Angular
 * application on the page will have an instance of Testability.
 */
var Testability = (function () {
    function Testability(_ngZone) {
        /** @internal */
        this._pendingCount = 0;
        /** @internal */
        this._callbacks = [];
        /** @internal */
        this._isAngularEventPending = false;
        this._watchAngularEvents(_ngZone);
    }
    /** @internal */
    Testability.prototype._watchAngularEvents = function (_ngZone) {
        var _this = this;
        _ngZone.overrideOnTurnStart(function () { _this._isAngularEventPending = true; });
        _ngZone.overrideOnEventDone(function () {
            _this._isAngularEventPending = false;
            _this._runCallbacksIfReady();
        }, true);
    };
    Testability.prototype.increasePendingRequestCount = function () {
        this._pendingCount += 1;
        return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function () {
        this._pendingCount -= 1;
        if (this._pendingCount < 0) {
            throw new exceptions_1.BaseException('pending async requests below zero');
        }
        this._runCallbacksIfReady();
        return this._pendingCount;
    };
    Testability.prototype.isStable = function () { return this._pendingCount == 0 && !this._isAngularEventPending; };
    /** @internal */
    Testability.prototype._runCallbacksIfReady = function () {
        var _this = this;
        if (!this.isStable()) {
            return; // Not ready
        }
        // Schedules the call backs in a new frame so that it is always async.
        async_1.PromiseWrapper.resolve(null).then(function (_) {
            while (_this._callbacks.length !== 0) {
                (_this._callbacks.pop())();
            }
        });
    };
    Testability.prototype.whenStable = function (callback) {
        this._callbacks.push(callback);
        this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
    // This only accounts for ngZone, and not pending counts. Use `whenStable` to
    // check for stability.
    Testability.prototype.isAngularEventPending = function () { return this._isAngularEventPending; };
    Testability.prototype.findBindings = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability.prototype.findProviders = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [ng_zone_1.NgZone])
    ], Testability);
    return Testability;
})();
exports.Testability = Testability;
var TestabilityRegistry = (function () {
    function TestabilityRegistry() {
        /** @internal */
        this._applications = new collection_1.Map();
        testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
        this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
        if (findInAncestors === void 0) { findInAncestors = true; }
        if (elem == null) {
            return null;
        }
        if (this._applications.has(elem)) {
            return this._applications.get(elem);
        }
        else if (!findInAncestors) {
            return null;
        }
        if (dom_adapter_1.DOM.isShadowRoot(elem)) {
            return this.findTestabilityInTree(dom_adapter_1.DOM.getHost(elem));
        }
        return this.findTestabilityInTree(dom_adapter_1.DOM.parentElement(elem));
    };
    TestabilityRegistry = __decorate([
        di_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], TestabilityRegistry);
    return TestabilityRegistry;
})();
exports.TestabilityRegistry = TestabilityRegistry;
var NoopGetTestability = (function () {
    function NoopGetTestability() {
    }
    NoopGetTestability.prototype.addToWindow = function (registry) { };
    NoopGetTestability = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [])
    ], NoopGetTestability);
    return NoopGetTestability;
})();
function setTestabilityGetter(getter) {
    testabilityGetter = getter;
}
exports.setTestabilityGetter = setTestabilityGetter;
var testabilityGetter = lang_1.CONST_EXPR(new NoopGetTestability());

},{"../zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js","angular2/src/core/di":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/di.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util.js":[function(require,module,exports){
'use strict';// Public API for util
var decorators_1 = require('./util/decorators');
exports.Class = decorators_1.Class;

},{"./util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
function extractAnnotation(annotation) {
    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
        // it is a decorator, extract annotation
        annotation = annotation.annotation;
    }
    return annotation;
}
function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
        fnOrArray === Number || fnOrArray === Array) {
        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
    }
    if (lang_1.isFunction(fnOrArray)) {
        return fnOrArray;
    }
    else if (fnOrArray instanceof Array) {
        var annotations = fnOrArray;
        var fn = fnOrArray[fnOrArray.length - 1];
        if (!lang_1.isFunction(fn)) {
            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
        }
        var annoLength = annotations.length - 1;
        if (annoLength != fn.length) {
            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
        }
        var paramsAnnotations = [];
        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
            var paramAnnotations = [];
            paramsAnnotations.push(paramAnnotations);
            var annotation = annotations[i];
            if (annotation instanceof Array) {
                for (var j = 0; j < annotation.length; j++) {
                    paramAnnotations.push(extractAnnotation(annotation[j]));
                }
            }
            else if (lang_1.isFunction(annotation)) {
                paramAnnotations.push(extractAnnotation(annotation));
            }
            else {
                paramAnnotations.push(annotation);
            }
        }
        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
        return fn;
    }
    else {
        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
    }
}
/**
 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
 *
 * ## Basic Example
 *
 * ```
 * var Greeter = ng.Class({
 *   constructor: function(name) {
 *     this.name = name;
 *   },
 *
 *   greet: function() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class Greeter {
 *   constructor(name) {
 *     this.name = name;
 *   }
 *
 *   greet() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * }
 * ```
 *
 * or equivalent to ES5:
 *
 * ```
 * var Greeter = function (name) {
 *   this.name = name;
 * }
 *
 * Greeter.prototype.greet = function () {
 *   alert('Hello ' + this.name + '!');
 * }
 * ```
 *
 * ## Example with parameter annotations
 *
 * ```
 * var MyService = ng.Class({
 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
 *     ...
 *   }]
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class MyService {
 *   constructor(name: string, @Query() queryList: QueryList) {
 *     ...
 *   }
 * }
 * ```
 *
 * ## Example with inheritance
 *
 * ```
 * var Shape = ng.Class({
 *   constructor: (color) {
 *     this.color = color;
 *   }
 * });
 *
 * var Square = ng.Class({
 *   extends: Shape,
 *   constructor: function(color, size) {
 *     Shape.call(this, color);
 *     this.size = size;
 *   }
 * });
 * ```
 */
function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
        if (lang_1.isFunction(clsDef.extends)) {
            constructor.prototype = proto =
                Object.create(clsDef.extends.prototype);
        }
        else {
            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
        }
    }
    for (var key in clsDef) {
        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
            proto[key] = applyParams(clsDef[key], key);
        }
    }
    if (this && this.annotations instanceof Array) {
        Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    return constructor;
}
exports.Class = Class;
var Reflect = lang_1.global.Reflect;
if (!(Reflect && Reflect.getMetadata)) {
    throw 'reflect-metadata shim is required when using class decorators';
}
function makeDecorator(annotationCls, chainFn) {
    if (chainFn === void 0) { chainFn = null; }
    function DecoratorFactory(objOrType) {
        var annotationInstance = new annotationCls(objOrType);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
            chainAnnotation.push(annotationInstance);
            var TypeDecorator = function TypeDecorator(cls) {
                var annotations = Reflect.getOwnMetadata('annotations', cls);
                annotations = annotations || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            };
            TypeDecorator.annotations = chainAnnotation;
            TypeDecorator.Class = Class;
            if (chainFn)
                chainFn(TypeDecorator);
            return TypeDecorator;
        }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return DecoratorFactory;
}
exports.makeDecorator = makeDecorator;
function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var annotationInstance = Object.create(annotationCls.prototype);
        annotationCls.apply(annotationInstance, args);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
        }
        function ParamDecorator(cls, unusedKey, index) {
            var parameters = Reflect.getMetadata('parameters', cls);
            parameters = parameters || [];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            parameters[index] = parameters[index] || [];
            var annotationsForParam = parameters[index];
            annotationsForParam.push(annotationInstance);
            Reflect.defineMetadata('parameters', parameters, cls);
            return cls;
        }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return ParamDecoratorFactory;
}
exports.makeParamDecorator = makeParamDecorator;
function makePropDecorator(decoratorCls) {
    function PropDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var decoratorInstance = Object.create(decoratorCls.prototype);
        decoratorCls.apply(decoratorInstance, args);
        if (this instanceof decoratorCls) {
            return decoratorInstance;
        }
        else {
            return function PropDecorator(target, name) {
                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
                meta = meta || {};
                meta[name] = meta[name] || [];
                meta[name].unshift(decoratorInstance);
                Reflect.defineMetadata('propMetadata', meta, target.constructor);
            };
        }
    }
    PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);
    return PropDecoratorFactory;
}
exports.makePropDecorator = makePropDecorator;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone.js":[function(require,module,exports){
'use strict';// Public API for Zone
var ng_zone_1 = require('./zone/ng_zone');
exports.NgZone = ng_zone_1.NgZone;

},{"./zone/ng_zone":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/zone/ng_zone.js":[function(require,module,exports){
'use strict';var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var profile_1 = require('../profile/profile');
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link #run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 * ```
 * import {Component, View, NgIf, NgZone} from 'angular2/angular2';
 *
 * @Component({
 *   selector: 'ng-zone-demo'.
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ng-if="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 *   directives: [NgIf]
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *       // reenter the Angular zone and display done
 *       this._ngZone.run(() => {console.log('Outside Done!') });
 *     }}));
 *   }
 *
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 */
var NgZone = (function () {
    /**
     * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be
     *               enabled in development mode as they significantly impact perf.
     */
    function NgZone(_a) {
        var enableLongStackTrace = _a.enableLongStackTrace;
        /** @internal */
        this._runScope = profile_1.wtfCreateScope("NgZone#run()");
        /** @internal */
        this._microtaskScope = profile_1.wtfCreateScope("NgZone#microtask()");
        // Number of microtasks pending from _innerZone (& descendants)
        /** @internal */
        this._pendingMicrotasks = 0;
        // Whether some code has been executed in the _innerZone (& descendants) in the current turn
        /** @internal */
        this._hasExecutedCodeInInnerZone = false;
        // run() call depth in _mountZone. 0 at the end of a macrotask
        // zone.run(() => {         // top-level call
        //   zone.run(() => {});    // nested call -> in-turn
        // });
        /** @internal */
        this._nestedRun = 0;
        /** @internal */
        this._inVmTurnDone = false;
        /** @internal */
        this._pendingTimeouts = [];
        if (lang_1.global.zone) {
            this._disabled = false;
            this._mountZone = lang_1.global.zone;
            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
        }
        else {
            this._disabled = true;
            this._mountZone = null;
        }
    }
    /**
     * Sets the zone hook that is called just before a browser task that is handled by Angular
     * executes.
     *
     * The hook is called once per browser task that is handled by Angular.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnTurnStart = function (onTurnStartHook) {
        this._onTurnStart = lang_1.normalizeBlank(onTurnStartHook);
    };
    /**
     * Sets the zone hook that is called immediately after Angular zone is done processing the current
     * task and any microtasks scheduled from that task.
     *
     * This is where we typically do change-detection.
     *
     * The hook is called once per browser task that is handled by Angular.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnTurnDone = function (onTurnDoneHook) {
        this._onTurnDone = lang_1.normalizeBlank(onTurnDoneHook);
    };
    /**
     * Sets the zone hook that is called immediately after the `onTurnDone` callback is called and any
     * microstasks scheduled from within that callback are drained.
     *
     * `onEventDoneFn` is executed outside Angular zone, which means that we will no longer attempt to
     * sync the UI with any model changes that occur within this callback.
     *
     * This hook is useful for validating application state (e.g. in a test).
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnEventDone = function (onEventDoneFn, opt_waitForAsync) {
        var _this = this;
        if (opt_waitForAsync === void 0) { opt_waitForAsync = false; }
        var normalizedOnEventDone = lang_1.normalizeBlank(onEventDoneFn);
        if (opt_waitForAsync) {
            this._onEventDone = function () {
                if (!_this._pendingTimeouts.length) {
                    normalizedOnEventDone();
                }
            };
        }
        else {
            this._onEventDone = normalizedOnEventDone;
        }
    };
    /**
     * Sets the zone hook that is called when an error is thrown in the Angular zone.
     *
     * Setting the hook overrides any previously set hook.
     */
    NgZone.prototype.overrideOnErrorHandler = function (errorHandler) {
        this._onErrorHandler = lang_1.normalizeBlank(errorHandler);
    };
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     */
    NgZone.prototype.run = function (fn) {
        if (this._disabled) {
            return fn();
        }
        else {
            var s = this._runScope();
            try {
                return this._innerZone.run(fn);
            }
            finally {
                profile_1.wtfLeave(s);
            }
        }
    };
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
     */
    NgZone.prototype.runOutsideAngular = function (fn) {
        if (this._disabled) {
            return fn();
        }
        else {
            return this._mountZone.run(fn);
        }
    };
    /** @internal */
    NgZone.prototype._createInnerZone = function (zone, enableLongStackTrace) {
        var microtaskScope = this._microtaskScope;
        var ngZone = this;
        var errorHandling;
        if (enableLongStackTrace) {
            errorHandling = collection_1.StringMapWrapper.merge(Zone.longStackTraceZone, { onError: function (e) { ngZone._onError(this, e); } });
        }
        else {
            errorHandling = { onError: function (e) { ngZone._onError(this, e); } };
        }
        return zone.fork(errorHandling)
            .fork({
            '$run': function (parentRun) {
                return function () {
                    try {
                        ngZone._nestedRun++;
                        if (!ngZone._hasExecutedCodeInInnerZone) {
                            ngZone._hasExecutedCodeInInnerZone = true;
                            if (ngZone._onTurnStart) {
                                parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
                            }
                        }
                        return parentRun.apply(this, arguments);
                    }
                    finally {
                        ngZone._nestedRun--;
                        // If there are no more pending microtasks, we are at the end of a VM turn (or in
                        // onTurnStart)
                        // _nestedRun will be 0 at the end of a macrotasks (it could be > 0 when there are
                        // nested calls
                        // to run()).
                        if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 &&
                            !this._inVmTurnDone) {
                            if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
                                try {
                                    this._inVmTurnDone = true;
                                    parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
                                }
                                finally {
                                    this._inVmTurnDone = false;
                                    ngZone._hasExecutedCodeInInnerZone = false;
                                }
                            }
                            if (ngZone._pendingMicrotasks === 0 && lang_1.isPresent(ngZone._onEventDone)) {
                                ngZone.runOutsideAngular(ngZone._onEventDone);
                            }
                        }
                    }
                };
            },
            '$scheduleMicrotask': function (parentScheduleMicrotask) {
                return function (fn) {
                    ngZone._pendingMicrotasks++;
                    var microtask = function () {
                        var s = microtaskScope();
                        try {
                            fn();
                        }
                        finally {
                            ngZone._pendingMicrotasks--;
                            profile_1.wtfLeave(s);
                        }
                    };
                    parentScheduleMicrotask.call(this, microtask);
                };
            },
            '$setTimeout': function (parentSetTimeout) {
                return function (fn, delay) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    var id;
                    var cb = function () {
                        fn();
                        collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
                    };
                    id = parentSetTimeout(cb, delay, args);
                    ngZone._pendingTimeouts.push(id);
                    return id;
                };
            },
            '$clearTimeout': function (parentClearTimeout) {
                return function (id) {
                    parentClearTimeout(id);
                    collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
                };
            },
            _innerZone: true
        });
    };
    /** @internal */
    NgZone.prototype._onError = function (zone, e) {
        if (lang_1.isPresent(this._onErrorHandler)) {
            var trace = [lang_1.normalizeBlank(e.stack)];
            while (zone && zone.constructedAtException) {
                trace.push(zone.constructedAtException.get());
                zone = zone.parent;
            }
            this._onErrorHandler(e, trace);
        }
        else {
            console.log('## _onError ##');
            console.log(e.stack);
            throw e;
        }
    };
    return NgZone;
})();
exports.NgZone = NgZone;

},{"../profile/profile":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/profile/profile.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/async_route_handler.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var AsyncRouteHandler = (function () {
    function AsyncRouteHandler(_loader, data) {
        this._loader = _loader;
        this.data = data;
        /** @internal */
        this._resolvedComponent = null;
    }
    AsyncRouteHandler.prototype.resolveComponentType = function () {
        var _this = this;
        if (lang_1.isPresent(this._resolvedComponent)) {
            return this._resolvedComponent;
        }
        return this._resolvedComponent = this._loader().then(function (componentType) {
            _this.componentType = componentType;
            return componentType;
        });
    };
    return AsyncRouteHandler;
})();
exports.AsyncRouteHandler = AsyncRouteHandler;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/hash_location_strategy.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var angular2_1 = require('angular2/angular2');
var location_strategy_1 = require('./location_strategy');
/**
 * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
 * {@link Location} service to represent its state in the
 * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
 * of the browser's URL.
 *
 * For instance, if you call `location.go('/foo')`, the browser's URL will become
 * `example.com#/foo`.
 *
 * ## Example
 *
 * ```
 * import {Component, View} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
var HashLocationStrategy = (function (_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy() {
        _super.call(this);
        this._location = dom_adapter_1.DOM.getLocation();
        this._history = dom_adapter_1.DOM.getHistory();
    }
    HashLocationStrategy.prototype.onPopState = function (fn) {
        dom_adapter_1.DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    HashLocationStrategy.prototype.getBaseHref = function () { return ''; };
    HashLocationStrategy.prototype.path = function () {
        // the hash value is always prefixed with a `#`
        // and if it is empty then it will stay empty
        var path = this._location.hash;
        // Dart will complain if a call to substring is
        // executed with a position value that extends the
        // length of string.
        return (path.length > 0 ? path.substring(1) : path) +
            location_strategy_1.normalizeQueryParams(this._location.search);
    };
    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
        var url = path + location_strategy_1.normalizeQueryParams(queryParams);
        if (url.length == 0) {
            url = this._location.pathname;
        }
        else {
            url = '#' + url;
        }
        this._history.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function () { this._history.forward(); };
    HashLocationStrategy.prototype.back = function () { this._history.back(); };
    HashLocationStrategy = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], HashLocationStrategy);
    return HashLocationStrategy;
})(location_strategy_1.LocationStrategy);
exports.HashLocationStrategy = HashLocationStrategy;

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * `RouteParams` is an immutable map of parameters for the given route
 * based on the url matcher and optional parameters for that route.
 *
 * You can inject `RouteParams` into the constructor of a component to use it.
 *
 * ## Example
 *
 * ```
 * import {bootstrap, Component} from 'angular2/angular2';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {path: '/user/:id', component: UserCmp, as: 'UserCmp'},
 * ])
 * class AppCmp {}
 *
 * @Component({ template: 'user: {{id}}' })
 * class UserCmp {
 *   string: id;
 *   constructor(params: RouteParams) {
 *     this.id = params.get('id');
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var RouteParams = (function () {
    function RouteParams(params) {
        this.params = params;
    }
    RouteParams.prototype.get = function (param) { return lang_1.normalizeBlank(collection_1.StringMapWrapper.get(this.params, param)); };
    return RouteParams;
})();
exports.RouteParams = RouteParams;
/**
 * `Instruction` is a tree of {@link ComponentInstruction}s with all the information needed
 * to transition each component in the app to a given route, including all auxiliary routes.
 *
 * `Instruction`s can be created using {@link Router#generate}, and can be used to
 * perform route changes with {@link Router#navigateByInstruction}.
 *
 * ## Example
 *
 * ```
 * import {bootstrap, Component} from 'angular2/angular2';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(router: Router) {
 *     var instruction = router.generate(['/MyRoute']);
 *     router.navigateByInstruction(instruction);
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var Instruction = (function () {
    function Instruction(component, child, auxInstruction) {
        this.component = component;
        this.child = child;
        this.auxInstruction = auxInstruction;
    }
    /**
     * Returns a new instruction that shares the state of the existing instruction, but with
     * the given child {@link Instruction} replacing the existing child.
     */
    Instruction.prototype.replaceChild = function (child) {
        return new Instruction(this.component, child, this.auxInstruction);
    };
    return Instruction;
})();
exports.Instruction = Instruction;
/**
 * Represents a partially completed instruction during recognition that only has the
 * primary (non-aux) route instructions matched.
 *
 * `PrimaryInstruction` is an internal class used by `RouteRecognizer` while it's
 * figuring out where to navigate.
 */
var PrimaryInstruction = (function () {
    function PrimaryInstruction(component, child, auxUrls) {
        this.component = component;
        this.child = child;
        this.auxUrls = auxUrls;
    }
    return PrimaryInstruction;
})();
exports.PrimaryInstruction = PrimaryInstruction;
function stringifyInstruction(instruction) {
    return stringifyInstructionPath(instruction) + stringifyInstructionQuery(instruction);
}
exports.stringifyInstruction = stringifyInstruction;
function stringifyInstructionPath(instruction) {
    return instruction.component.urlPath + stringifyAux(instruction) +
        stringifyPrimary(instruction.child);
}
exports.stringifyInstructionPath = stringifyInstructionPath;
function stringifyInstructionQuery(instruction) {
    return instruction.component.urlParams.length > 0 ?
        ('?' + instruction.component.urlParams.join('&')) :
        '';
}
exports.stringifyInstructionQuery = stringifyInstructionQuery;
function stringifyPrimary(instruction) {
    if (lang_1.isBlank(instruction)) {
        return '';
    }
    var params = instruction.component.urlParams.length > 0 ?
        (';' + instruction.component.urlParams.join(';')) :
        '';
    return '/' + instruction.component.urlPath + params + stringifyAux(instruction) +
        stringifyPrimary(instruction.child);
}
function stringifyAux(instruction) {
    var routes = [];
    collection_1.StringMapWrapper.forEach(instruction.auxInstruction, function (auxInstruction, _) {
        routes.push(stringifyPrimary(auxInstruction));
    });
    if (routes.length > 0) {
        return '(' + routes.join('//') + ')';
    }
    return '';
}
/**
 * A `ComponentInstruction` represents the route state for a single component. An `Instruction` is
 * composed of a tree of these `ComponentInstruction`s.
 *
 * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed
 * to route lifecycle hooks, like {@link CanActivate}.
 *
 * `ComponentInstruction`s are [https://en.wikipedia.org/wiki/Hash_consing](hash consed). You should
 * never construct one yourself with "new." Instead, rely on {@link Router/PathRecognizer} to
 * construct `ComponentInstruction`s.
 *
 * You should not modify this object. It should be treated as immutable.
 */
var ComponentInstruction = (function () {
    function ComponentInstruction() {
        this.reuse = false;
    }
    Object.defineProperty(ComponentInstruction.prototype, "componentType", {
        /**
         * Returns the component type of the represented route, or `null` if this instruction
         * hasn't been resolved.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentInstruction.prototype, "specificity", {
        /**
         * Returns the specificity of the route associated with this `Instruction`.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentInstruction.prototype, "terminal", {
        /**
         * Returns `true` if the component type of this instruction has no child {@link RouteConfig},
         * or `false` if it does.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ComponentInstruction;
})();
exports.ComponentInstruction = ComponentInstruction;
var ComponentInstruction_ = (function (_super) {
    __extends(ComponentInstruction_, _super);
    function ComponentInstruction_(urlPath, urlParams, _recognizer, params) {
        if (params === void 0) { params = null; }
        _super.call(this);
        this._recognizer = _recognizer;
        this.urlPath = urlPath;
        this.urlParams = urlParams;
        this.params = params;
    }
    Object.defineProperty(ComponentInstruction_.prototype, "componentType", {
        get: function () { return this._recognizer.handler.componentType; },
        enumerable: true,
        configurable: true
    });
    ComponentInstruction_.prototype.resolveComponentType = function () { return this._recognizer.handler.resolveComponentType(); };
    Object.defineProperty(ComponentInstruction_.prototype, "specificity", {
        get: function () { return this._recognizer.specificity; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentInstruction_.prototype, "terminal", {
        get: function () { return this._recognizer.terminal; },
        enumerable: true,
        configurable: true
    });
    ComponentInstruction_.prototype.routeData = function () { return this._recognizer.handler.data; };
    return ComponentInstruction_;
})(ComponentInstruction);
exports.ComponentInstruction_ = ComponentInstruction_;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js":[function(require,module,exports){
'use strict';/**
 * This indirection is needed to free up Component, etc symbols in the public API
 * to be used by the decorator versions of these annotations.
 */
var decorators_1 = require('angular2/src/core/util/decorators');
var lifecycle_annotations_impl_1 = require('./lifecycle_annotations_impl');
var lifecycle_annotations_impl_2 = require('./lifecycle_annotations_impl');
exports.canReuse = lifecycle_annotations_impl_2.canReuse;
exports.canDeactivate = lifecycle_annotations_impl_2.canDeactivate;
exports.onActivate = lifecycle_annotations_impl_2.onActivate;
exports.onReuse = lifecycle_annotations_impl_2.onReuse;
exports.onDeactivate = lifecycle_annotations_impl_2.onDeactivate;
/**
 * Defines route lifecycle hook `CanActivate`, which is called by the router to determine
 * if a component can be instantiated as part of a navigation.
 *
 * The `CanActivate` hook is called with two {@link ComponentInstruction}s as parameters, the first
 * representing
 * the current route being navigated to, and the second parameter representing the previous route or
 * `null`.
 *
 * Note that unlike other lifecycle hooks, this one uses an annotation rather than an interface.
 * This is because the `CanActivate` function is called before the component is instantiated.
 *
 * If `CanActivate` returns or resolves to `false`, the navigation is cancelled.
 * If `CanActivate` throws or rejects, the navigation is also cancelled.
 * If `CanActivate` returns or resolves to `true`, navigation continues, the component is
 * instantiated, and the {@link OnActivate} hook of that component is called if implemented.
 *
 * ## Example
 * ```
 * import {Component} from 'angular2/angular2';
 * import {CanActivate} from 'angular2/router';
 *
 * @Component({
 *   selector: 'control-panel-cmp',
 *   template: '<div>Control Panel: ...</div>'
 * })
 * @CanActivate(() => checkIfUserIsLoggedIn())
 * class ControlPanelCmp {
 *   // ...
 * }
 *  ```
 */
exports.CanActivate = decorators_1.makeDecorator(lifecycle_annotations_impl_1.CanActivate);

},{"./lifecycle_annotations_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js","angular2/src/core/util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
var RouteLifecycleHook = (function () {
    function RouteLifecycleHook(name) {
        this.name = name;
    }
    RouteLifecycleHook = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [String])
    ], RouteLifecycleHook);
    return RouteLifecycleHook;
})();
exports.RouteLifecycleHook = RouteLifecycleHook;
var CanActivate = (function () {
    function CanActivate(fn) {
        this.fn = fn;
    }
    CanActivate = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Function])
    ], CanActivate);
    return CanActivate;
})();
exports.CanActivate = CanActivate;
exports.canReuse = lang_1.CONST_EXPR(new RouteLifecycleHook("canReuse"));
exports.canDeactivate = lang_1.CONST_EXPR(new RouteLifecycleHook("canDeactivate"));
exports.onActivate = lang_1.CONST_EXPR(new RouteLifecycleHook("onActivate"));
exports.onReuse = lang_1.CONST_EXPR(new RouteLifecycleHook("onReuse"));
exports.onDeactivate = lang_1.CONST_EXPR(new RouteLifecycleHook("onDeactivate"));

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var location_strategy_1 = require('./location_strategy');
var lang_1 = require('angular2/src/core/facade/lang');
var async_1 = require('angular2/src/core/facade/async');
var lang_2 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var angular2_1 = require('angular2/angular2');
/**
 * The `APP_BASE_HREF` token represents the base href to be used with the
 * {@link PathLocationStrategy}.
 *
 * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
 * representing the URL prefix that should be preserved when generating and recognizing
 * URLs.
 *
 * ## Example
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [
 *   ROUTER_PROVIDERS,
 *   PathLocationStrategy,
 *   provide(APP_BASE_HREF, {useValue: '/my/app'})
 * ]);
 * ```
 */
exports.APP_BASE_HREF = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('appBaseHref'));
/**
 * `Location` is a service that applications can use to interact with a browser's URL.
 * Depending on which {@link LocationStrategy} is used, `Location` will either persist
 * to the URL's path or the URL's hash segment.
 *
 * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
 * `Location` only if you need to interact with or create normalized URLs outside of
 * routing.
 *
 * `Location` is responsible for normalizing the URL against the application's base href.
 * A normalized URL is absolute from the URL host, includes the application's base href, and has no
 * trailing slash:
 * - `/my/app/user/123` is normalized
 * - `my/app/user/123` **is not** normalized
 * - `/my/app/user/123/` **is not** normalized
 *
 * ## Example
 *
 * ```
 * import {Component} from 'angular2/angular2';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
var Location = (function () {
    function Location(platformStrategy, href) {
        var _this = this;
        this.platformStrategy = platformStrategy;
        /** @internal */
        this._subject = new async_1.EventEmitter();
        var browserBaseHref = lang_1.isPresent(href) ? href : this.platformStrategy.getBaseHref();
        if (lang_2.isBlank(browserBaseHref)) {
            throw new exceptions_1.BaseException("No base href set. Either provide a provider for the APP_BASE_HREF token or add a base element to the document.");
        }
        this._baseHref = stripTrailingSlash(stripIndexHtml(browserBaseHref));
        this.platformStrategy.onPopState(function (_) { async_1.ObservableWrapper.callNext(_this._subject, { 'url': _this.path(), 'pop': true }); });
    }
    /**
     * Returns the normalized URL path.
     */
    Location.prototype.path = function () { return this.normalize(this.platformStrategy.path()); };
    /**
     * Given a string representing a URL, returns the normalized URL path.
     */
    Location.prototype.normalize = function (url) {
        return stripTrailingSlash(_stripBaseHref(this._baseHref, stripIndexHtml(url)));
    };
    /**
     * Given a string representing a URL, returns the normalized URL path.
     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
     * before normalizing.
     */
    Location.prototype.normalizeAbsolutely = function (url) {
        if (!url.startsWith('/')) {
            url = '/' + url;
        }
        return stripTrailingSlash(_addBaseHref(this._baseHref, url));
    };
    /**
     * Changes the browsers URL to the normalized version of the given URL, and pushes a
     * new item onto the platform's history.
     */
    Location.prototype.go = function (path, query) {
        if (query === void 0) { query = ''; }
        var absolutePath = this.normalizeAbsolutely(path);
        this.platformStrategy.pushState(null, '', absolutePath, query);
    };
    /**
     * Navigates forward in the platform's history.
     */
    Location.prototype.forward = function () { this.platformStrategy.forward(); };
    /**
     * Navigates back in the platform's history.
     */
    Location.prototype.back = function () { this.platformStrategy.back(); };
    /**
     * Subscribe to the platform's `popState` events.
     */
    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
        if (onThrow === void 0) { onThrow = null; }
        if (onReturn === void 0) { onReturn = null; }
        async_1.ObservableWrapper.subscribe(this._subject, onNext, onThrow, onReturn);
    };
    Location = __decorate([
        angular2_1.Injectable(),
        __param(1, angular2_1.Optional()),
        __param(1, angular2_1.Inject(exports.APP_BASE_HREF)), 
        __metadata('design:paramtypes', [location_strategy_1.LocationStrategy, String])
    ], Location);
    return Location;
})();
exports.Location = Location;
function _stripBaseHref(baseHref, url) {
    if (baseHref.length > 0 && url.startsWith(baseHref)) {
        return url.substring(baseHref.length);
    }
    return url;
}
function _addBaseHref(baseHref, url) {
    if (!url.startsWith(baseHref)) {
        return baseHref + url;
    }
    return url;
}
function stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
        // '/index.html'.length == 11
        return url.substring(0, url.length - 11);
    }
    return url;
}
function stripTrailingSlash(url) {
    if (/\/$/g.test(url)) {
        url = url.substring(0, url.length - 1);
    }
    return url;
}

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js":[function(require,module,exports){
'use strict';/**
 * `LocationStrategy` is responsible for representing and reading route state
 * from the the browser's URL. Angular provides two strategies:
 * {@link HashLocationStrategy} (default) and {@link PathLocationStrategy}.
 *
 * This is used under the hood of the {@link Location} service.
 *
 * Applications should use the {@link Router} or {@link Location} services to
 * interact with application route state.
 *
 * For instance, {@link HashLocationStrategy} produces URLs like
 * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
 * `http://example.com/foo` as an equivalent URL.
 *
 * See these two classes for more.
 */
var LocationStrategy = (function () {
    function LocationStrategy() {
    }
    return LocationStrategy;
})();
exports.LocationStrategy = LocationStrategy;
function normalizeQueryParams(params) {
    return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
}
exports.normalizeQueryParams = normalizeQueryParams;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_location_strategy.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var angular2_1 = require('angular2/angular2');
var location_strategy_1 = require('./location_strategy');
/**
 * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
 * {@link Location} service to represent its state in the
 * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
 * browser's URL.
 *
 * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
 * provided in {@link ROUTER_PROVIDERS}.
 *
 * If you're using `PathLocationStrategy`, you must provide a provider for
 * {@link APP_BASE_HREF} to a string representing the URL prefix that should
 * be preserved when generating and recognizing URLs.
 *
 * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
 * `location.go('/foo')`, the browser's URL will become
 * `example.com/my/app/foo`.
 *
 * ## Example
 *
 * ```
 * import {Component, provide} from 'angular2/angular2';
 * import {
 *   APP_BASE_HREF
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig,
 *   Location
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(location: Location) {
 *     location.go('/foo');
 *   }
 * }
 *
 * bootstrap(AppCmp, [
 *   ROUTER_PROVIDERS, // includes binding to PathLocationStrategy
 *   provide(APP_BASE_HREF, {useValue: '/my/app'})
 * ]);
 * ```
 */
var PathLocationStrategy = (function (_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy() {
        _super.call(this);
        this._location = dom_adapter_1.DOM.getLocation();
        this._history = dom_adapter_1.DOM.getHistory();
        this._baseHref = dom_adapter_1.DOM.getBaseHref();
    }
    PathLocationStrategy.prototype.onPopState = function (fn) {
        dom_adapter_1.DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    PathLocationStrategy.prototype.path = function () { return this._location.pathname + location_strategy_1.normalizeQueryParams(this._location.search); };
    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
        this._history.pushState(state, title, (url + location_strategy_1.normalizeQueryParams(queryParams)));
    };
    PathLocationStrategy.prototype.forward = function () { this._history.forward(); };
    PathLocationStrategy.prototype.back = function () { this._history.back(); };
    PathLocationStrategy = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], PathLocationStrategy);
    return PathLocationStrategy;
})(location_strategy_1.LocationStrategy);
exports.PathLocationStrategy = PathLocationStrategy;

},{"./location_strategy":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location_strategy.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/dom/dom_adapter":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/dom/dom_adapter.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_recognizer.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var url_parser_1 = require('./url_parser');
var instruction_1 = require('./instruction');
var TouchMap = (function () {
    function TouchMap(map) {
        var _this = this;
        this.map = {};
        this.keys = {};
        if (lang_1.isPresent(map)) {
            collection_1.StringMapWrapper.forEach(map, function (value, key) {
                _this.map[key] = lang_1.isPresent(value) ? value.toString() : null;
                _this.keys[key] = true;
            });
        }
    }
    TouchMap.prototype.get = function (key) {
        collection_1.StringMapWrapper.delete(this.keys, key);
        return this.map[key];
    };
    TouchMap.prototype.getUnused = function () {
        var _this = this;
        var unused = collection_1.StringMapWrapper.create();
        var keys = collection_1.StringMapWrapper.keys(this.keys);
        keys.forEach(function (key) { return unused[key] = collection_1.StringMapWrapper.get(_this.map, key); });
        return unused;
    };
    return TouchMap;
})();
function normalizeString(obj) {
    if (lang_1.isBlank(obj)) {
        return null;
    }
    else {
        return obj.toString();
    }
}
var ContinuationSegment = (function () {
    function ContinuationSegment() {
        this.name = '';
    }
    ContinuationSegment.prototype.generate = function (params) { return ''; };
    ContinuationSegment.prototype.match = function (path) { return true; };
    return ContinuationSegment;
})();
var StaticSegment = (function () {
    function StaticSegment(path) {
        this.path = path;
        this.name = '';
    }
    StaticSegment.prototype.match = function (path) { return path == this.path; };
    StaticSegment.prototype.generate = function (params) { return this.path; };
    return StaticSegment;
})();
var DynamicSegment = (function () {
    function DynamicSegment(name) {
        this.name = name;
    }
    DynamicSegment.prototype.match = function (path) { return path.length > 0; };
    DynamicSegment.prototype.generate = function (params) {
        if (!collection_1.StringMapWrapper.contains(params.map, this.name)) {
            throw new exceptions_1.BaseException("Route generator for '" + this.name + "' was not included in parameters passed.");
        }
        return normalizeString(params.get(this.name));
    };
    return DynamicSegment;
})();
var StarSegment = (function () {
    function StarSegment(name) {
        this.name = name;
    }
    StarSegment.prototype.match = function (path) { return true; };
    StarSegment.prototype.generate = function (params) { return normalizeString(params.get(this.name)); };
    return StarSegment;
})();
var paramMatcher = /^:([^\/]+)$/g;
var wildcardMatcher = /^\*([^\/]+)$/g;
function parsePathString(route) {
    // normalize route as not starting with a "/". Recognition will
    // also normalize.
    if (lang_1.StringWrapper.startsWith(route, "/")) {
        route = lang_1.StringWrapper.substring(route, 1);
    }
    var segments = splitBySlash(route);
    var results = [];
    var specificity = 0;
    // The "specificity" of a path is used to determine which route is used when multiple routes match
    // a URL.
    // Static segments (like "/foo") are the most specific, followed by dynamic segments (like
    // "/:id"). Star segments
    // add no specificity. Segments at the start of the path are more specific than proceeding ones.
    // The code below uses place values to combine the different types of segments into a single
    // integer that we can
    // sort later. Each static segment is worth hundreds of points of specificity (10000, 9900, ...,
    // 200), and each
    // dynamic segment is worth single points of specificity (100, 99, ... 2).
    if (segments.length > 98) {
        throw new exceptions_1.BaseException("'" + route + "' has more than the maximum supported number of segments.");
    }
    var limit = segments.length - 1;
    for (var i = 0; i <= limit; i++) {
        var segment = segments[i], match;
        if (lang_1.isPresent(match = lang_1.RegExpWrapper.firstMatch(paramMatcher, segment))) {
            results.push(new DynamicSegment(match[1]));
            specificity += (100 - i);
        }
        else if (lang_1.isPresent(match = lang_1.RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
            results.push(new StarSegment(match[1]));
        }
        else if (segment == '...') {
            if (i < limit) {
                // TODO (matsko): setup a proper error here `
                throw new exceptions_1.BaseException("Unexpected \"...\" before the end of the path for \"" + route + "\".");
            }
            results.push(new ContinuationSegment());
        }
        else {
            results.push(new StaticSegment(segment));
            specificity += 100 * (100 - i);
        }
    }
    var result = collection_1.StringMapWrapper.create();
    collection_1.StringMapWrapper.set(result, 'segments', results);
    collection_1.StringMapWrapper.set(result, 'specificity', specificity);
    return result;
}
// this function is used to determine whether a route config path like `/foo/:id` collides with
// `/foo/:name`
function pathDslHash(segments) {
    return segments.map(function (segment) {
        if (segment instanceof StarSegment) {
            return '*';
        }
        else if (segment instanceof ContinuationSegment) {
            return '...';
        }
        else if (segment instanceof DynamicSegment) {
            return ':';
        }
        else if (segment instanceof StaticSegment) {
            return segment.path;
        }
    })
        .join('/');
}
function splitBySlash(url) {
    return url.split('/');
}
var RESERVED_CHARS = lang_1.RegExpWrapper.create('//|\\(|\\)|;|\\?|=');
function assertPath(path) {
    if (lang_1.StringWrapper.contains(path, '#')) {
        throw new exceptions_1.BaseException("Path \"" + path + "\" should not include \"#\". Use \"HashLocationStrategy\" instead.");
    }
    var illegalCharacter = lang_1.RegExpWrapper.firstMatch(RESERVED_CHARS, path);
    if (lang_1.isPresent(illegalCharacter)) {
        throw new exceptions_1.BaseException("Path \"" + path + "\" contains \"" + illegalCharacter[0] + "\" which is not allowed in a route config.");
    }
}
var PathMatch = (function () {
    function PathMatch(instruction, remaining, remainingAux) {
        this.instruction = instruction;
        this.remaining = remaining;
        this.remainingAux = remainingAux;
    }
    return PathMatch;
})();
exports.PathMatch = PathMatch;
// represents something like '/foo/:bar'
var PathRecognizer = (function () {
    // TODO: cache component instruction instances by params and by ParsedUrl instance
    function PathRecognizer(path, handler) {
        this.path = path;
        this.handler = handler;
        this.terminal = true;
        this._cache = new collection_1.Map();
        assertPath(path);
        var parsed = parsePathString(path);
        this._segments = parsed['segments'];
        this.specificity = parsed['specificity'];
        this.hash = pathDslHash(this._segments);
        var lastSegment = this._segments[this._segments.length - 1];
        this.terminal = !(lastSegment instanceof ContinuationSegment);
    }
    PathRecognizer.prototype.recognize = function (beginningSegment) {
        var nextSegment = beginningSegment;
        var currentSegment;
        var positionalParams = {};
        var captured = [];
        for (var i = 0; i < this._segments.length; i += 1) {
            var segment = this._segments[i];
            currentSegment = nextSegment;
            if (segment instanceof ContinuationSegment) {
                break;
            }
            if (lang_1.isPresent(currentSegment)) {
                captured.push(currentSegment.path);
                // the star segment consumes all of the remaining URL, including matrix params
                if (segment instanceof StarSegment) {
                    positionalParams[segment.name] = currentSegment.toString();
                    nextSegment = null;
                    break;
                }
                if (segment instanceof DynamicSegment) {
                    positionalParams[segment.name] = currentSegment.path;
                }
                else if (!segment.match(currentSegment.path)) {
                    return null;
                }
                nextSegment = currentSegment.child;
            }
            else if (!segment.match('')) {
                return null;
            }
        }
        if (this.terminal && lang_1.isPresent(nextSegment)) {
            return null;
        }
        var urlPath = captured.join('/');
        var auxiliary;
        var instruction;
        var urlParams;
        var allParams;
        if (lang_1.isPresent(currentSegment)) {
            // If this is the root component, read query params. Otherwise, read matrix params.
            var paramsSegment = beginningSegment instanceof url_parser_1.RootUrl ? beginningSegment : currentSegment;
            allParams = lang_1.isPresent(paramsSegment.params) ?
                collection_1.StringMapWrapper.merge(paramsSegment.params, positionalParams) :
                positionalParams;
            urlParams = url_parser_1.serializeParams(paramsSegment.params);
            auxiliary = currentSegment.auxiliary;
        }
        else {
            allParams = positionalParams;
            auxiliary = [];
            urlParams = [];
        }
        instruction = this._getInstruction(urlPath, urlParams, this, allParams);
        return new PathMatch(instruction, nextSegment, auxiliary);
    };
    PathRecognizer.prototype.generate = function (params) {
        var paramTokens = new TouchMap(params);
        var path = [];
        for (var i = 0; i < this._segments.length; i++) {
            var segment = this._segments[i];
            if (!(segment instanceof ContinuationSegment)) {
                path.push(segment.generate(paramTokens));
            }
        }
        var urlPath = path.join('/');
        var nonPositionalParams = paramTokens.getUnused();
        var urlParams = url_parser_1.serializeParams(nonPositionalParams);
        return this._getInstruction(urlPath, urlParams, this, params);
    };
    PathRecognizer.prototype._getInstruction = function (urlPath, urlParams, _recognizer, params) {
        var hashKey = urlPath + '?' + urlParams.join('?');
        if (this._cache.has(hashKey)) {
            return this._cache.get(hashKey);
        }
        var instruction = new instruction_1.ComponentInstruction_(urlPath, urlParams, _recognizer, params);
        this._cache.set(hashKey, instruction);
        return instruction;
    };
    return PathRecognizer;
})();
exports.PathRecognizer = PathRecognizer;

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js":[function(require,module,exports){
'use strict';var route_config_impl_1 = require('./route_config_impl');
var decorators_1 = require('angular2/src/core/util/decorators');
var route_config_impl_2 = require('./route_config_impl');
exports.Route = route_config_impl_2.Route;
exports.Redirect = route_config_impl_2.Redirect;
exports.AuxRoute = route_config_impl_2.AuxRoute;
exports.AsyncRoute = route_config_impl_2.AsyncRoute;
exports.RouteConfig = decorators_1.makeDecorator(route_config_impl_1.RouteConfig);

},{"./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","angular2/src/core/util/decorators":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/util/decorators.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var lang_1 = require('angular2/src/core/facade/lang');
/**
 * The `RouteConfig` decorator defines routes for a given component.
 *
 * It takes an array of {@link RouteDefinition}s.
 */
var RouteConfig = (function () {
    function RouteConfig(configs) {
        this.configs = configs;
    }
    RouteConfig = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Array])
    ], RouteConfig);
    return RouteConfig;
})();
exports.RouteConfig = RouteConfig;
/**
 * `Route` is a type of {@link RouteDefinition} used to route a path to a component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/home', component: HomeCmp, as: 'HomeCmp' }
 * ])
 * class MyApp {}
 * ```
 */
var Route = (function () {
    function Route(_a) {
        var path = _a.path, component = _a.component, as = _a.as, data = _a.data;
        this.path = path;
        this.component = component;
        this.as = as;
        this.loader = null;
        this.redirectTo = null;
        this.data = data;
    }
    Route = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], Route);
    return Route;
})();
exports.Route = Route;
/**
 * `AuxRoute` is a type of {@link RouteDefinition} used to define an auxiliary route.
 *
 * It takes an object with the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig, AuxRoute} from 'angular2/router';
 *
 * @RouteConfig([
 *   new AuxRoute({path: '/home', component: HomeCmp})
 * ])
 * class MyApp {}
 * ```
 */
var AuxRoute = (function () {
    function AuxRoute(_a) {
        var path = _a.path, component = _a.component, as = _a.as;
        this.data = null;
        // added next two properties to work around https://github.com/Microsoft/TypeScript/issues/4107
        this.loader = null;
        this.redirectTo = null;
        this.path = path;
        this.component = component;
        this.as = as;
    }
    AuxRoute = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], AuxRoute);
    return AuxRoute;
})();
exports.AuxRoute = AuxRoute;
/**
 * `AsyncRoute` is a type of {@link RouteDefinition} used to route a path to an asynchronously
 * loaded component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `loader` is a function that returns a promise that resolves to a component.
 * - `as` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via the {@link ROUTE_DATA} token.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/home', loader: () => Promise.resolve(MyLoadedCmp), as: 'MyLoadedCmp'}
 * ])
 * class MyApp {}
 * ```
 */
var AsyncRoute = (function () {
    function AsyncRoute(_a) {
        var path = _a.path, loader = _a.loader, as = _a.as, data = _a.data;
        this.path = path;
        this.loader = loader;
        this.as = as;
        this.data = data;
    }
    AsyncRoute = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], AsyncRoute);
    return AsyncRoute;
})();
exports.AsyncRoute = AsyncRoute;
/**
 * `Redirect` is a type of {@link RouteDefinition} used to route a path to an asynchronously loaded
 * component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `redirectTo` is a string representing the new URL to be matched against.
 *
 * ## Example
 * ```
 * import {RouteConfig} from 'angular2/router';
 *
 * @RouteConfig([
 *   {path: '/', redirectTo: '/home'},
 *   {path: '/home', component: HomeCmp}
 * ])
 * class MyApp {}
 * ```
 */
var Redirect = (function () {
    function Redirect(_a) {
        var path = _a.path, redirectTo = _a.redirectTo;
        this.as = null;
        // added next property to work around https://github.com/Microsoft/TypeScript/issues/4107
        this.loader = null;
        this.data = null;
        this.path = path;
        this.redirectTo = redirectTo;
    }
    Redirect = __decorate([
        lang_1.CONST(), 
        __metadata('design:paramtypes', [Object])
    ], Redirect);
    return Redirect;
})();
exports.Redirect = Redirect;

},{"angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_nomalizer.js":[function(require,module,exports){
'use strict';var route_config_decorator_1 = require('./route_config_decorator');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * Given a JS Object that represents... returns a corresponding Route, AsyncRoute, or Redirect
 */
function normalizeRouteConfig(config) {
    if (config instanceof route_config_decorator_1.Route || config instanceof route_config_decorator_1.Redirect || config instanceof route_config_decorator_1.AsyncRoute ||
        config instanceof route_config_decorator_1.AuxRoute) {
        return config;
    }
    if ((+!!config.component) + (+!!config.redirectTo) + (+!!config.loader) != 1) {
        throw new exceptions_1.BaseException("Route config should contain exactly one \"component\", \"loader\", or \"redirectTo\" property.");
    }
    if (config.loader) {
        return new route_config_decorator_1.AsyncRoute({ path: config.path, loader: config.loader, as: config.as });
    }
    if (config.component) {
        if (typeof config.component == 'object') {
            var componentDefinitionObject = config.component;
            if (componentDefinitionObject.type == 'constructor') {
                return new route_config_decorator_1.Route({
                    path: config.path,
                    component: componentDefinitionObject.constructor,
                    as: config.as
                });
            }
            else if (componentDefinitionObject.type == 'loader') {
                return new route_config_decorator_1.AsyncRoute({ path: config.path, loader: componentDefinitionObject.loader, as: config.as });
            }
            else {
                throw new exceptions_1.BaseException("Invalid component type \"" + componentDefinitionObject.type + "\". Valid types are \"constructor\" and \"loader\".");
            }
        }
        return new route_config_decorator_1.Route(config);
    }
    if (config.redirectTo) {
        return new route_config_decorator_1.Redirect({ path: config.path, redirectTo: config.redirectTo });
    }
    return config;
}
exports.normalizeRouteConfig = normalizeRouteConfig;
function assertComponentExists(component, path) {
    if (!lang_1.isType(component)) {
        throw new exceptions_1.BaseException("Component for route \"" + path + "\" is not defined, or is not a class.");
    }
}
exports.assertComponentExists = assertComponentExists;

},{"./route_config_decorator":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_decorator.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js":[function(require,module,exports){
'use strict';var angular2_1 = require('angular2/angular2');
var lang_1 = require('angular2/src/core/facade/lang');
exports.ROUTE_DATA = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('routeData'));

},{"angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_definition.js":[function(require,module,exports){
'use strict';
},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var lifecycle_annotations_impl_1 = require('./lifecycle_annotations_impl');
var reflection_1 = require('angular2/src/core/reflection/reflection');
function hasLifecycleHook(e, type) {
    if (!(type instanceof lang_1.Type))
        return false;
    return e.name in type.prototype;
}
exports.hasLifecycleHook = hasLifecycleHook;
function getCanActivateHook(type) {
    var annotations = reflection_1.reflector.annotations(type);
    for (var i = 0; i < annotations.length; i += 1) {
        var annotation = annotations[i];
        if (annotation instanceof lifecycle_annotations_impl_1.CanActivate) {
            return annotation.fn;
        }
    }
    return null;
}
exports.getCanActivateHook = getCanActivateHook;

},{"./lifecycle_annotations_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations_impl.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_recognizer.js":[function(require,module,exports){
'use strict';var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var collection_1 = require('angular2/src/core/facade/collection');
var path_recognizer_1 = require('./path_recognizer');
var route_config_impl_1 = require('./route_config_impl');
var async_route_handler_1 = require('./async_route_handler');
var sync_route_handler_1 = require('./sync_route_handler');
var url_parser_1 = require('./url_parser');
/**
 * `RouteRecognizer` is responsible for recognizing routes for a single component.
 * It is consumed by `RouteRegistry`, which knows how to recognize an entire hierarchy of
 * components.
 */
var RouteRecognizer = (function () {
    function RouteRecognizer() {
        this.names = new collection_1.Map();
        this.auxRoutes = new collection_1.Map();
        // TODO: optimize this into a trie
        this.matchers = [];
        // TODO: optimize this into a trie
        this.redirects = [];
    }
    RouteRecognizer.prototype.config = function (config) {
        var handler;
        if (lang_1.isPresent(config.as) && config.as[0].toUpperCase() != config.as[0]) {
            var suggestedAlias = config.as[0].toUpperCase() + config.as.substring(1);
            throw new exceptions_1.BaseException("Route '" + config.path + "' with alias '" + config.as + "' does not begin with an uppercase letter. Route aliases should be CamelCase like '" + suggestedAlias + "'.");
        }
        if (config instanceof route_config_impl_1.AuxRoute) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
            var path = lang_1.StringWrapper.startsWith(config.path, '/') ? config.path.substring(1) : config.path;
            var recognizer = new path_recognizer_1.PathRecognizer(config.path, handler);
            this.auxRoutes.set(path, recognizer);
            return recognizer.terminal;
        }
        if (config instanceof route_config_impl_1.Redirect) {
            this.redirects.push(new Redirector(config.path, config.redirectTo));
            return true;
        }
        if (config instanceof route_config_impl_1.Route) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
        }
        else if (config instanceof route_config_impl_1.AsyncRoute) {
            handler = new async_route_handler_1.AsyncRouteHandler(config.loader, config.data);
        }
        var recognizer = new path_recognizer_1.PathRecognizer(config.path, handler);
        this.matchers.forEach(function (matcher) {
            if (recognizer.hash == matcher.hash) {
                throw new exceptions_1.BaseException("Configuration '" + config.path + "' conflicts with existing route '" + matcher.path + "'");
            }
        });
        this.matchers.push(recognizer);
        if (lang_1.isPresent(config.as)) {
            this.names.set(config.as, recognizer);
        }
        return recognizer.terminal;
    };
    /**
     * Given a URL, returns a list of `RouteMatch`es, which are partial recognitions for some route.
     *
     */
    RouteRecognizer.prototype.recognize = function (urlParse) {
        var solutions = [];
        urlParse = this._redirect(urlParse);
        this.matchers.forEach(function (pathRecognizer) {
            var pathMatch = pathRecognizer.recognize(urlParse);
            if (lang_1.isPresent(pathMatch)) {
                solutions.push(pathMatch);
            }
        });
        return solutions;
    };
    /** @internal */
    RouteRecognizer.prototype._redirect = function (urlParse) {
        for (var i = 0; i < this.redirects.length; i += 1) {
            var redirector = this.redirects[i];
            var redirectedUrl = redirector.redirect(urlParse);
            if (lang_1.isPresent(redirectedUrl)) {
                return redirectedUrl;
            }
        }
        return urlParse;
    };
    RouteRecognizer.prototype.recognizeAuxiliary = function (urlParse) {
        var pathRecognizer = this.auxRoutes.get(urlParse.path);
        if (lang_1.isBlank(pathRecognizer)) {
            return null;
        }
        return pathRecognizer.recognize(urlParse);
    };
    RouteRecognizer.prototype.hasRoute = function (name) { return this.names.has(name); };
    RouteRecognizer.prototype.generate = function (name, params) {
        var pathRecognizer = this.names.get(name);
        if (lang_1.isBlank(pathRecognizer)) {
            return null;
        }
        return pathRecognizer.generate(params);
    };
    return RouteRecognizer;
})();
exports.RouteRecognizer = RouteRecognizer;
var Redirector = (function () {
    function Redirector(path, redirectTo) {
        this.segments = [];
        this.toSegments = [];
        if (lang_1.StringWrapper.startsWith(path, '/')) {
            path = path.substring(1);
        }
        this.segments = path.split('/');
        if (lang_1.StringWrapper.startsWith(redirectTo, '/')) {
            redirectTo = redirectTo.substring(1);
        }
        this.toSegments = redirectTo.split('/');
    }
    /**
     * Returns `null` or a `ParsedUrl` representing the new path to match
     */
    Redirector.prototype.redirect = function (urlParse) {
        for (var i = 0; i < this.segments.length; i += 1) {
            if (lang_1.isBlank(urlParse)) {
                return null;
            }
            var segment = this.segments[i];
            if (segment != urlParse.path) {
                return null;
            }
            urlParse = urlParse.child;
        }
        for (var i = this.toSegments.length - 1; i >= 0; i -= 1) {
            var segment = this.toSegments[i];
            urlParse = new url_parser_1.Url(segment, urlParse);
        }
        return urlParse;
    };
    return Redirector;
})();
exports.Redirector = Redirector;

},{"./async_route_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/async_route_handler.js","./path_recognizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/path_recognizer.js","./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","./sync_route_handler":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/sync_route_handler.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_registry.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var route_recognizer_1 = require('./route_recognizer');
var instruction_1 = require('./instruction');
var collection_1 = require('angular2/src/core/facade/collection');
var async_1 = require('angular2/src/core/facade/async');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var route_config_impl_1 = require('./route_config_impl');
var reflection_1 = require('angular2/src/core/reflection/reflection');
var angular2_1 = require('angular2/angular2');
var route_config_nomalizer_1 = require('./route_config_nomalizer');
var url_parser_1 = require('./url_parser');
var _resolveToNull = async_1.PromiseWrapper.resolve(null);
/**
 * The RouteRegistry holds route configurations for each component in an Angular app.
 * It is responsible for creating Instructions from URLs, and generating URLs based on route and
 * parameters.
 */
var RouteRegistry = (function () {
    function RouteRegistry() {
        this._rules = new collection_1.Map();
    }
    /**
     * Given a component and a configuration object, add the route to this registry
     */
    RouteRegistry.prototype.config = function (parentComponent, config) {
        config = route_config_nomalizer_1.normalizeRouteConfig(config);
        // this is here because Dart type guard reasons
        if (config instanceof route_config_impl_1.Route) {
            route_config_nomalizer_1.assertComponentExists(config.component, config.path);
        }
        else if (config instanceof route_config_impl_1.AuxRoute) {
            route_config_nomalizer_1.assertComponentExists(config.component, config.path);
        }
        var recognizer = this._rules.get(parentComponent);
        if (lang_1.isBlank(recognizer)) {
            recognizer = new route_recognizer_1.RouteRecognizer();
            this._rules.set(parentComponent, recognizer);
        }
        var terminal = recognizer.config(config);
        if (config instanceof route_config_impl_1.Route) {
            if (terminal) {
                assertTerminalComponent(config.component, config.path);
            }
            else {
                this.configFromComponent(config.component);
            }
        }
    };
    /**
     * Reads the annotations of a component and configures the registry based on them
     */
    RouteRegistry.prototype.configFromComponent = function (component) {
        var _this = this;
        if (!lang_1.isType(component)) {
            return;
        }
        // Don't read the annotations from a type more than once 
        // this prevents an infinite loop if a component routes recursively.
        if (this._rules.has(component)) {
            return;
        }
        var annotations = reflection_1.reflector.annotations(component);
        if (lang_1.isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                if (annotation instanceof route_config_impl_1.RouteConfig) {
                    var routeCfgs = annotation.configs;
                    routeCfgs.forEach(function (config) { return _this.config(component, config); });
                }
            }
        }
    };
    /**
     * Given a URL and a parent component, return the most specific instruction for navigating
     * the application into the state specified by the url
     */
    RouteRegistry.prototype.recognize = function (url, parentComponent) {
        var parsedUrl = url_parser_1.parser.parse(url);
        return this._recognize(parsedUrl, parentComponent);
    };
    RouteRegistry.prototype._recognize = function (parsedUrl, parentComponent) {
        var _this = this;
        return this._recognizePrimaryRoute(parsedUrl, parentComponent)
            .then(function (instruction) {
            return _this._completeAuxiliaryRouteMatches(instruction, parentComponent);
        });
    };
    RouteRegistry.prototype._recognizePrimaryRoute = function (parsedUrl, parentComponent) {
        var _this = this;
        var componentRecognizer = this._rules.get(parentComponent);
        if (lang_1.isBlank(componentRecognizer)) {
            return _resolveToNull;
        }
        // Matches some beginning part of the given URL
        var possibleMatches = componentRecognizer.recognize(parsedUrl);
        var matchPromises = possibleMatches.map(function (candidate) { return _this._completePrimaryRouteMatch(candidate); });
        return async_1.PromiseWrapper.all(matchPromises).then(mostSpecific);
    };
    RouteRegistry.prototype._completePrimaryRouteMatch = function (partialMatch) {
        var _this = this;
        var instruction = partialMatch.instruction;
        return instruction.resolveComponentType().then(function (componentType) {
            _this.configFromComponent(componentType);
            if (instruction.terminal) {
                return new instruction_1.PrimaryInstruction(instruction, null, partialMatch.remainingAux);
            }
            return _this._recognizePrimaryRoute(partialMatch.remaining, componentType)
                .then(function (childInstruction) {
                if (lang_1.isBlank(childInstruction)) {
                    return null;
                }
                else {
                    return new instruction_1.PrimaryInstruction(instruction, childInstruction, partialMatch.remainingAux);
                }
            });
        });
    };
    RouteRegistry.prototype._completeAuxiliaryRouteMatches = function (instruction, parentComponent) {
        var _this = this;
        if (lang_1.isBlank(instruction)) {
            return _resolveToNull;
        }
        var componentRecognizer = this._rules.get(parentComponent);
        var auxInstructions = {};
        var promises = instruction.auxUrls.map(function (auxSegment) {
            var match = componentRecognizer.recognizeAuxiliary(auxSegment);
            if (lang_1.isBlank(match)) {
                return _resolveToNull;
            }
            return _this._completePrimaryRouteMatch(match).then(function (auxInstruction) {
                if (lang_1.isPresent(auxInstruction)) {
                    return _this._completeAuxiliaryRouteMatches(auxInstruction, parentComponent)
                        .then(function (finishedAuxRoute) {
                        auxInstructions[auxSegment.path] = finishedAuxRoute;
                    });
                }
            });
        });
        return async_1.PromiseWrapper.all(promises).then(function (_) {
            if (lang_1.isBlank(instruction.child)) {
                return new instruction_1.Instruction(instruction.component, null, auxInstructions);
            }
            return _this._completeAuxiliaryRouteMatches(instruction.child, instruction.component.componentType)
                .then(function (completeChild) {
                return new instruction_1.Instruction(instruction.component, completeChild, auxInstructions);
            });
        });
    };
    /**
     * Given a normalized list with component names and params like: `['user', {id: 3 }]`
     * generates a url with a leading slash relative to the provided `parentComponent`.
     */
    RouteRegistry.prototype.generate = function (linkParams, parentComponent) {
        var segments = [];
        var componentCursor = parentComponent;
        var lastInstructionIsTerminal = false;
        for (var i = 0; i < linkParams.length; i += 1) {
            var segment = linkParams[i];
            if (lang_1.isBlank(componentCursor)) {
                throw new exceptions_1.BaseException("Could not find route named \"" + segment + "\".");
            }
            if (!lang_1.isString(segment)) {
                throw new exceptions_1.BaseException("Unexpected segment \"" + segment + "\" in link DSL. Expected a string.");
            }
            else if (segment == '' || segment == '.' || segment == '..') {
                throw new exceptions_1.BaseException("\"" + segment + "/\" is only allowed at the beginning of a link DSL.");
            }
            var params = {};
            if (i + 1 < linkParams.length) {
                var nextSegment = linkParams[i + 1];
                if (lang_1.isStringMap(nextSegment)) {
                    params = nextSegment;
                    i += 1;
                }
            }
            var componentRecognizer = this._rules.get(componentCursor);
            if (lang_1.isBlank(componentRecognizer)) {
                throw new exceptions_1.BaseException("Component \"" + lang_1.getTypeNameForDebugging(componentCursor) + "\" has no route config.");
            }
            var response = componentRecognizer.generate(segment, params);
            if (lang_1.isBlank(response)) {
                throw new exceptions_1.BaseException("Component \"" + lang_1.getTypeNameForDebugging(componentCursor) + "\" has no route named \"" + segment + "\".");
            }
            segments.push(response);
            componentCursor = response.componentType;
            lastInstructionIsTerminal = response.terminal;
        }
        var instruction = null;
        if (!lastInstructionIsTerminal) {
            instruction = this._generateRedirects(componentCursor);
            if (lang_1.isPresent(instruction)) {
                var lastInstruction = instruction;
                while (lang_1.isPresent(lastInstruction.child)) {
                    lastInstruction = lastInstruction.child;
                }
                lastInstructionIsTerminal = lastInstruction.component.terminal;
            }
            if (lang_1.isPresent(componentCursor) && !lastInstructionIsTerminal) {
                throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" does not resolve to a terminal or async instruction.");
            }
        }
        while (segments.length > 0) {
            instruction = new instruction_1.Instruction(segments.pop(), instruction, {});
        }
        return instruction;
    };
    // if the child includes a redirect like : "/" -> "/something",
    // we want to honor that redirection when creating the link
    RouteRegistry.prototype._generateRedirects = function (componentCursor) {
        if (lang_1.isBlank(componentCursor)) {
            return null;
        }
        var componentRecognizer = this._rules.get(componentCursor);
        if (lang_1.isBlank(componentRecognizer)) {
            return null;
        }
        for (var i = 0; i < componentRecognizer.redirects.length; i += 1) {
            var redirect = componentRecognizer.redirects[i];
            // we only handle redirecting from an empty segment
            if (redirect.segments.length == 1 && redirect.segments[0] == '') {
                var toSegments = url_parser_1.pathSegmentsToUrl(redirect.toSegments);
                var matches = componentRecognizer.recognize(toSegments);
                var primaryInstruction = collection_1.ListWrapper.maximum(matches, function (match) { return match.instruction.specificity; });
                if (lang_1.isPresent(primaryInstruction)) {
                    var child = this._generateRedirects(primaryInstruction.instruction.componentType);
                    return new instruction_1.Instruction(primaryInstruction.instruction, child, {});
                }
                return null;
            }
        }
        return null;
    };
    RouteRegistry = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], RouteRegistry);
    return RouteRegistry;
})();
exports.RouteRegistry = RouteRegistry;
/*
 * Given a list of instructions, returns the most specific instruction
 */
function mostSpecific(instructions) {
    return collection_1.ListWrapper.maximum(instructions, function (instruction) { return instruction.component.specificity; });
}
function assertTerminalComponent(component, path) {
    if (!lang_1.isType(component)) {
        return;
    }
    var annotations = reflection_1.reflector.annotations(component);
    if (lang_1.isPresent(annotations)) {
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            if (annotation instanceof route_config_impl_1.RouteConfig) {
                throw new exceptions_1.BaseException("Child routes are not allowed for \"" + path + "\". Use \"...\" on the parent's route path.");
            }
        }
    }
}

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./route_config_impl":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_impl.js","./route_config_nomalizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_config_nomalizer.js","./route_recognizer":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_recognizer.js","./url_parser":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js","angular2/src/core/reflection/reflection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/reflection/reflection.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var instruction_1 = require('./instruction');
var route_lifecycle_reflector_1 = require('./route_lifecycle_reflector');
var _resolveToTrue = async_1.PromiseWrapper.resolve(true);
var _resolveToFalse = async_1.PromiseWrapper.resolve(false);
/**
 * The `Router` is responsible for mapping URLs to components.
 *
 * You can see the state of the router by inspecting the read-only field `router.navigating`.
 * This may be useful for showing a spinner, for instance.
 *
 * ## Concepts
 *
 * Routers and component instances have a 1:1 correspondence.
 *
 * The router holds reference to a number of {@link RouterOutlet}.
 * An outlet is a placeholder that the router dynamically fills in depending on the current URL.
 *
 * When the router navigates from a URL, it must first recognize it and serialize it into an
 * `Instruction`.
 * The router uses the `RouteRegistry` to get an `Instruction`.
 */
var Router = (function () {
    function Router(registry, parent, hostComponent) {
        this.registry = registry;
        this.parent = parent;
        this.hostComponent = hostComponent;
        this.navigating = false;
        this._currentInstruction = null;
        this._currentNavigation = _resolveToTrue;
        this._outlet = null;
        this._auxRouters = new collection_1.Map();
        this._subject = new async_1.EventEmitter();
    }
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.childRouter = function (hostComponent) {
        return this._childRouter = new ChildRouter(this, hostComponent);
    };
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.auxRouter = function (hostComponent) { return new ChildRouter(this, hostComponent); };
    /**
     * Register an outlet to notified of primary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerPrimaryOutlet = function (outlet) {
        if (lang_1.isPresent(outlet.name)) {
            throw new exceptions_1.BaseException("registerAuxOutlet expects to be called with an unnamed outlet.");
        }
        this._outlet = outlet;
        if (lang_1.isPresent(this._currentInstruction)) {
            return this.commit(this._currentInstruction, false);
        }
        return _resolveToTrue;
    };
    /**
     * Register an outlet to notified of auxiliary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerAuxOutlet = function (outlet) {
        var outletName = outlet.name;
        if (lang_1.isBlank(outletName)) {
            throw new exceptions_1.BaseException("registerAuxOutlet expects to be called with an outlet with a name.");
        }
        // TODO...
        // what is the host of an aux route???
        var router = this.auxRouter(this.hostComponent);
        this._auxRouters.set(outletName, router);
        router._outlet = outlet;
        var auxInstruction;
        if (lang_1.isPresent(this._currentInstruction) &&
            lang_1.isPresent(auxInstruction = this._currentInstruction.auxInstruction[outletName])) {
            return router.commit(auxInstruction);
        }
        return _resolveToTrue;
    };
    /**
     * Given an instruction, returns `true` if the instruction is currently active,
     * otherwise `false`.
     */
    Router.prototype.isRouteActive = function (instruction) {
        var router = this;
        while (lang_1.isPresent(router.parent) && lang_1.isPresent(instruction.child)) {
            router = router.parent;
            instruction = instruction.child;
        }
        return lang_1.isPresent(this._currentInstruction) &&
            this._currentInstruction.component == instruction.component;
    };
    /**
     * Dynamically update the routing configuration and trigger a navigation.
     *
     * # Usage
     *
     * ```
     * router.config([
     *   { 'path': '/', 'component': IndexComp },
     *   { 'path': '/user/:id', 'component': UserComp },
     * ]);
     * ```
     */
    Router.prototype.config = function (definitions) {
        var _this = this;
        definitions.forEach(function (routeDefinition) { _this.registry.config(_this.hostComponent, routeDefinition); });
        return this.renavigate();
    };
    /**
     * Navigate based on the provided Route Link DSL. It's preferred to navigate with this method
     * over `navigateByUrl`.
     *
     * # Usage
     *
     * This method takes an array representing the Route Link DSL:
     * ```
     * ['./MyCmp', {param: 3}]
     * ```
     * See the {@link RouterLink} directive for more.
     */
    Router.prototype.navigate = function (linkParams) {
        var instruction = this.generate(linkParams);
        return this.navigateByInstruction(instruction, false);
    };
    /**
     * Navigate to a URL. Returns a promise that resolves when navigation is complete.
     * It's preferred to navigate with `navigate` instead of this method, since URLs are more brittle.
     *
     * If the given URL begins with a `/`, router will navigate absolutely.
     * If the given URL does not begin with `/`, the router will navigate relative to this component.
     */
    Router.prototype.navigateByUrl = function (url, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this.lastNavigationAttempt = url;
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this.recognize(url).then(function (instruction) {
                if (lang_1.isBlank(instruction)) {
                    return false;
                }
                return _this._navigate(instruction, _skipLocationChange);
            }));
        });
    };
    /**
     * Navigate via the provided instruction. Returns a promise that resolves when navigation is
     * complete.
     */
    Router.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        if (lang_1.isBlank(instruction)) {
            return _resolveToFalse;
        }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this._navigate(instruction, _skipLocationChange));
        });
    };
    /** @internal */
    Router.prototype._navigate = function (instruction, _skipLocationChange) {
        var _this = this;
        return this._settleInstruction(instruction)
            .then(function (_) { return _this._canReuse(instruction); })
            .then(function (_) { return _this._canActivate(instruction); })
            .then(function (result) {
            if (!result) {
                return false;
            }
            return _this._canDeactivate(instruction)
                .then(function (result) {
                if (result) {
                    return _this.commit(instruction, _skipLocationChange)
                        .then(function (_) {
                        _this._emitNavigationFinish(instruction_1.stringifyInstruction(instruction));
                        return true;
                    });
                }
            });
        });
    };
    // TODO(btford): it'd be nice to remove this method as part of cleaning up the traversal logic
    // Since refactoring `Router.generate` to return an instruction rather than a string, it's not
    // guaranteed that the `componentType`s for the terminal async routes have been loaded by the time
    // we begin navigation. The method below simply traverses instructions and resolves any components
    // for which `componentType` is not present
    /** @internal */
    Router.prototype._settleInstruction = function (instruction) {
        var _this = this;
        var unsettledInstructions = [];
        if (lang_1.isBlank(instruction.component.componentType)) {
            unsettledInstructions.push(instruction.component.resolveComponentType().then(function (type) { _this.registry.configFromComponent(type); }));
        }
        if (lang_1.isPresent(instruction.child)) {
            unsettledInstructions.push(this._settleInstruction(instruction.child));
        }
        collection_1.StringMapWrapper.forEach(instruction.auxInstruction, function (instruction, _) {
            unsettledInstructions.push(_this._settleInstruction(instruction));
        });
        return async_1.PromiseWrapper.all(unsettledInstructions);
    };
    Router.prototype._emitNavigationFinish = function (url) { async_1.ObservableWrapper.callNext(this._subject, url); };
    Router.prototype._afterPromiseFinishNavigating = function (promise) {
        var _this = this;
        return async_1.PromiseWrapper.catchError(promise.then(function (_) { return _this._finishNavigating(); }), function (err) {
            _this._finishNavigating();
            throw err;
        });
    };
    /*
     * Recursively set reuse flags
     */
    /** @internal */
    Router.prototype._canReuse = function (instruction) {
        var _this = this;
        if (lang_1.isBlank(this._outlet)) {
            return _resolveToFalse;
        }
        return this._outlet.canReuse(instruction.component)
            .then(function (result) {
            instruction.component.reuse = result;
            if (result && lang_1.isPresent(_this._childRouter) && lang_1.isPresent(instruction.child)) {
                return _this._childRouter._canReuse(instruction.child);
            }
        });
    };
    Router.prototype._canActivate = function (nextInstruction) {
        return canActivateOne(nextInstruction, this._currentInstruction);
    };
    Router.prototype._canDeactivate = function (instruction) {
        var _this = this;
        if (lang_1.isBlank(this._outlet)) {
            return _resolveToTrue;
        }
        var next;
        var childInstruction = null;
        var reuse = false;
        var componentInstruction = null;
        if (lang_1.isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
            reuse = instruction.component.reuse;
        }
        if (reuse) {
            next = _resolveToTrue;
        }
        else {
            next = this._outlet.canDeactivate(componentInstruction);
        }
        // TODO: aux route lifecycle hooks
        return next.then(function (result) {
            if (result == false) {
                return false;
            }
            if (lang_1.isPresent(_this._childRouter)) {
                return _this._childRouter._canDeactivate(childInstruction);
            }
            return true;
        });
    };
    /**
     * Updates this router and all descendant routers according to the given instruction
     */
    Router.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        this._currentInstruction = instruction;
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._outlet)) {
            var componentInstruction = instruction.component;
            if (componentInstruction.reuse) {
                next = this._outlet.reuse(componentInstruction);
            }
            else {
                next =
                    this.deactivate(instruction).then(function (_) { return _this._outlet.activate(componentInstruction); });
            }
            if (lang_1.isPresent(instruction.child)) {
                next = next.then(function (_) {
                    if (lang_1.isPresent(_this._childRouter)) {
                        return _this._childRouter.commit(instruction.child);
                    }
                });
            }
        }
        var promises = [];
        this._auxRouters.forEach(function (router, name) { promises.push(router.commit(instruction.auxInstruction[name])); });
        return next.then(function (_) { return async_1.PromiseWrapper.all(promises); });
    };
    /** @internal */
    Router.prototype._startNavigating = function () { this.navigating = true; };
    /** @internal */
    Router.prototype._finishNavigating = function () { this.navigating = false; };
    /**
     * Subscribe to URL updates from the router
     */
    Router.prototype.subscribe = function (onNext) {
        return async_1.ObservableWrapper.subscribe(this._subject, onNext);
    };
    /**
     * Removes the contents of this router's outlet and all descendant outlets
     */
    Router.prototype.deactivate = function (instruction) {
        var _this = this;
        var childInstruction = null;
        var componentInstruction = null;
        if (lang_1.isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
        }
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._childRouter)) {
            next = this._childRouter.deactivate(childInstruction);
        }
        if (lang_1.isPresent(this._outlet)) {
            next = next.then(function (_) { return _this._outlet.deactivate(componentInstruction); });
        }
        // TODO: handle aux routes
        return next;
    };
    /**
     * Given a URL, returns an instruction representing the component graph
     */
    Router.prototype.recognize = function (url) {
        return this.registry.recognize(url, this.hostComponent);
    };
    /**
     * Navigates to either the last URL successfully navigated to, or the last URL requested if the
     * router has yet to successfully navigate.
     */
    Router.prototype.renavigate = function () {
        if (lang_1.isBlank(this.lastNavigationAttempt)) {
            return this._currentNavigation;
        }
        return this.navigateByUrl(this.lastNavigationAttempt);
    };
    /**
     * Generate a URL from a component name and optional map of parameters. The URL is relative to the
     * app's base href.
     */
    Router.prototype.generate = function (linkParams) {
        var normalizedLinkParams = splitAndFlattenLinkParams(linkParams);
        var first = collection_1.ListWrapper.first(normalizedLinkParams);
        var rest = collection_1.ListWrapper.slice(normalizedLinkParams, 1);
        var router = this;
        // The first segment should be either '.' (generate from parent) or '' (generate from root).
        // When we normalize above, we strip all the slashes, './' becomes '.' and '/' becomes ''.
        if (first == '') {
            while (lang_1.isPresent(router.parent)) {
                router = router.parent;
            }
        }
        else if (first == '..') {
            router = router.parent;
            while (collection_1.ListWrapper.first(rest) == '..') {
                rest = collection_1.ListWrapper.slice(rest, 1);
                router = router.parent;
                if (lang_1.isBlank(router)) {
                    throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" has too many \"../\" segments.");
                }
            }
        }
        else if (first != '.') {
            throw new exceptions_1.BaseException("Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" must start with \"/\", \"./\", or \"../\"");
        }
        if (rest[rest.length - 1] == '') {
            rest.pop();
        }
        if (rest.length < 1) {
            var msg = "Link \"" + collection_1.ListWrapper.toJSON(linkParams) + "\" must include a route name.";
            throw new exceptions_1.BaseException(msg);
        }
        // TODO: structural cloning and whatnot
        var url = [];
        var parent = router.parent;
        while (lang_1.isPresent(parent)) {
            url.unshift(parent._currentInstruction);
            parent = parent.parent;
        }
        var nextInstruction = this.registry.generate(rest, router.hostComponent);
        while (url.length > 0) {
            nextInstruction = url.pop().replaceChild(nextInstruction);
        }
        return nextInstruction;
    };
    return Router;
})();
exports.Router = Router;
var RootRouter = (function (_super) {
    __extends(RootRouter, _super);
    function RootRouter(registry, location, primaryComponent) {
        var _this = this;
        _super.call(this, registry, null, primaryComponent);
        this._location = location;
        this._location.subscribe(function (change) {
            return _this.navigateByUrl(change['url'], lang_1.isPresent(change['pop']));
        });
        this.registry.configFromComponent(primaryComponent);
        this.navigateByUrl(location.path());
    }
    RootRouter.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        var emitPath = instruction_1.stringifyInstructionPath(instruction);
        var emitQuery = instruction_1.stringifyInstructionQuery(instruction);
        if (emitPath.length > 0) {
            emitPath = '/' + emitPath;
        }
        var promise = _super.prototype.commit.call(this, instruction);
        if (!_skipLocationChange) {
            promise = promise.then(function (_) { _this._location.go(emitPath, emitQuery); });
        }
        return promise;
    };
    return RootRouter;
})(Router);
exports.RootRouter = RootRouter;
var ChildRouter = (function (_super) {
    __extends(ChildRouter, _super);
    function ChildRouter(parent, hostComponent) {
        _super.call(this, parent.registry, parent, hostComponent);
        this.parent = parent;
    }
    ChildRouter.prototype.navigateByUrl = function (url, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByUrl(url, _skipLocationChange);
    };
    ChildRouter.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByInstruction(instruction, _skipLocationChange);
    };
    return ChildRouter;
})(Router);
/*
 * Given: ['/a/b', {c: 2}]
 * Returns: ['', 'a', 'b', {c: 2}]
 */
var SLASH = new RegExp('/');
function splitAndFlattenLinkParams(linkParams) {
    return collection_1.ListWrapper.reduce(linkParams, function (accumulation, item) {
        if (lang_1.isString(item)) {
            return accumulation.concat(lang_1.StringWrapper.split(item, SLASH));
        }
        accumulation.push(item);
        return accumulation;
    }, []);
}
function canActivateOne(nextInstruction, prevInstruction) {
    var next = _resolveToTrue;
    if (lang_1.isPresent(nextInstruction.child)) {
        next = canActivateOne(nextInstruction.child, lang_1.isPresent(prevInstruction) ? prevInstruction.child : null);
    }
    return next.then(function (result) {
        if (result == false) {
            return false;
        }
        if (nextInstruction.component.reuse) {
            return true;
        }
        var hook = route_lifecycle_reflector_1.getCanActivateHook(nextInstruction.component.componentType);
        if (lang_1.isPresent(hook)) {
            return hook(nextInstruction.component, lang_1.isPresent(prevInstruction) ? prevInstruction.component : null);
        }
        return true;
    });
}

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./route_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_link.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var metadata_1 = require('../core/metadata');
var router_1 = require('./router');
var location_1 = require('./location');
var instruction_1 = require('./instruction');
/**
 * The RouterLink directive lets you link to specific parts of your app.
 *
 * Consider the following route configuration:

 * ```
 * @RouteConfig([
 *   { path: '/user', component: UserCmp, as: 'User' }
 * ]);
 * class MyComp {}
 * ```
 *
 * When linking to this `User` route, you can write:
 *
 * ```
 * <a [router-link]="['./User']">link to user component</a>
 * ```
 *
 * RouterLink expects the value to be an array of route names, followed by the params
 * for that level of routing. For instance `['/Team', {teamId: 1}, 'User', {userId: 2}]`
 * means that we want to generate a link for the `Team` route with params `{teamId: 1}`,
 * and with a child route `User` with params `{userId: 2}`.
 *
 * The first route name should be prepended with `/`, `./`, or `../`.
 * If the route begins with `/`, the router will look up the route from the root of the app.
 * If the route begins with `./`, the router will instead look in the current component's
 * children for the route. And if the route begins with `../`, the router will look at the
 * current component's parent.
 */
var RouterLink = (function () {
    function RouterLink(_router, _location) {
        this._router = _router;
        this._location = _location;
    }
    Object.defineProperty(RouterLink.prototype, "isRouteActive", {
        get: function () { return this._router.isRouteActive(this._navigationInstruction); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLink.prototype, "routeParams", {
        set: function (changes) {
            this._routeParams = changes;
            this._navigationInstruction = this._router.generate(this._routeParams);
            // TODO: is this the right spot for this?
            var navigationHref = '/' + instruction_1.stringifyInstruction(this._navigationInstruction);
            this.visibleHref = this._location.normalizeAbsolutely(navigationHref);
        },
        enumerable: true,
        configurable: true
    });
    RouterLink.prototype.onClick = function () {
        this._router.navigateByInstruction(this._navigationInstruction);
        return false;
    };
    RouterLink = __decorate([
        metadata_1.Directive({
            selector: '[router-link]',
            inputs: ['routeParams: routerLink'],
            host: {
                '(click)': 'onClick()',
                '[attr.href]': 'visibleHref',
                '[class.router-link-active]': 'isRouteActive'
            }
        }), 
        __metadata('design:paramtypes', [router_1.Router, location_1.Location])
    ], RouterLink);
    return RouterLink;
})();
exports.RouterLink = RouterLink;

},{"../core/metadata":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/metadata.js","./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./location":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/location.js","./router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router_outlet.js":[function(require,module,exports){
'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var async_1 = require('angular2/src/core/facade/async');
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
var angular2_1 = require('angular2/angular2');
var routerMod = require('./router');
var instruction_1 = require('./instruction');
var route_data_1 = require('./route_data');
var hookMod = require('./lifecycle_annotations');
var route_lifecycle_reflector_1 = require('./route_lifecycle_reflector');
var _resolveToTrue = async_1.PromiseWrapper.resolve(true);
/**
 * A router outlet is a placeholder that Angular dynamically fills based on the application's route.
 *
 * ## Use
 *
 * ```
 * <router-outlet></router-outlet>
 * ```
 */
var RouterOutlet = (function () {
    function RouterOutlet(_elementRef, _loader, _parentRouter, nameAttr) {
        this._elementRef = _elementRef;
        this._loader = _loader;
        this._parentRouter = _parentRouter;
        this.name = null;
        this._componentRef = null;
        this._currentInstruction = null;
        if (lang_1.isPresent(nameAttr)) {
            this.name = nameAttr;
            this._parentRouter.registerAuxOutlet(this);
        }
        else {
            this._parentRouter.registerPrimaryOutlet(this);
        }
    }
    /**
     * Called by the Router to instantiate a new component during the commit phase of a navigation.
     * This method in turn is responsible for calling the `onActivate` hook of its child.
     */
    RouterOutlet.prototype.activate = function (nextInstruction) {
        var _this = this;
        var previousInstruction = this._currentInstruction;
        this._currentInstruction = nextInstruction;
        var componentType = nextInstruction.componentType;
        var childRouter = this._parentRouter.childRouter(componentType);
        var providers = angular2_1.Injector.resolve([
            angular2_1.provide(route_data_1.ROUTE_DATA, { useValue: nextInstruction.routeData() }),
            angular2_1.provide(instruction_1.RouteParams, { useValue: new instruction_1.RouteParams(nextInstruction.params) }),
            angular2_1.provide(routerMod.Router, { useValue: childRouter })
        ]);
        return this._loader.loadNextToLocation(componentType, this._elementRef, providers)
            .then(function (componentRef) {
            _this._componentRef = componentRef;
            if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onActivate, componentType)) {
                return _this._componentRef.instance.onActivate(nextInstruction, previousInstruction);
            }
        });
    };
    /**
     * Called by the {@link Router} during the commit phase of a navigation when an outlet
     * reuses a component between different routes.
     * This method in turn is responsible for calling the `onReuse` hook of its child.
     */
    RouterOutlet.prototype.reuse = function (nextInstruction) {
        var previousInstruction = this._currentInstruction;
        this._currentInstruction = nextInstruction;
        if (lang_1.isBlank(this._componentRef)) {
            throw new exceptions_1.BaseException("Cannot reuse an outlet that does not contain a component.");
        }
        return async_1.PromiseWrapper.resolve(route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onReuse, this._currentInstruction.componentType) ?
            this._componentRef.instance.onReuse(nextInstruction, previousInstruction) :
            true);
    };
    /**
     * Called by the {@link Router} when an outlet reuses a component across navigations.
     * This method in turn is responsible for calling the `onReuse` hook of its child.
     */
    RouterOutlet.prototype.deactivate = function (nextInstruction) {
        var _this = this;
        var next = _resolveToTrue;
        if (lang_1.isPresent(this._componentRef) && lang_1.isPresent(this._currentInstruction) &&
            route_lifecycle_reflector_1.hasLifecycleHook(hookMod.onDeactivate, this._currentInstruction.componentType)) {
            next = async_1.PromiseWrapper.resolve(this._componentRef.instance.onDeactivate(nextInstruction, this._currentInstruction));
        }
        return next.then(function (_) {
            if (lang_1.isPresent(_this._componentRef)) {
                _this._componentRef.dispose();
                _this._componentRef = null;
            }
        });
    };
    /**
     * Called by the {@link Router} during recognition phase of a navigation.
     *
     * If this resolves to `false`, the given navigation is cancelled.
     *
     * This method delegates to the child component's `canDeactivate` hook if it exists,
     * and otherwise resolves to true.
     */
    RouterOutlet.prototype.canDeactivate = function (nextInstruction) {
        if (lang_1.isBlank(this._currentInstruction)) {
            return _resolveToTrue;
        }
        if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.canDeactivate, this._currentInstruction.componentType)) {
            return async_1.PromiseWrapper.resolve(this._componentRef.instance.canDeactivate(nextInstruction, this._currentInstruction));
        }
        return _resolveToTrue;
    };
    /**
     * Called by the {@link Router} during recognition phase of a navigation.
     *
     * If the new child component has a different Type than the existing child component,
     * this will resolve to `false`. You can't reuse an old component when the new component
     * is of a different Type.
     *
     * Otherwise, this method delegates to the child component's `canReuse` hook if it exists,
     * or resolves to true if the hook is not present.
     */
    RouterOutlet.prototype.canReuse = function (nextInstruction) {
        var result;
        if (lang_1.isBlank(this._currentInstruction) ||
            this._currentInstruction.componentType != nextInstruction.componentType) {
            result = false;
        }
        else if (route_lifecycle_reflector_1.hasLifecycleHook(hookMod.canReuse, this._currentInstruction.componentType)) {
            result = this._componentRef.instance.canReuse(nextInstruction, this._currentInstruction);
        }
        else {
            result = nextInstruction == this._currentInstruction ||
                (lang_1.isPresent(nextInstruction.params) && lang_1.isPresent(this._currentInstruction.params) &&
                    collection_1.StringMapWrapper.equals(nextInstruction.params, this._currentInstruction.params));
        }
        return async_1.PromiseWrapper.resolve(result);
    };
    RouterOutlet = __decorate([
        angular2_1.Directive({ selector: 'router-outlet' }),
        __param(3, angular2_1.Attribute('name')), 
        __metadata('design:paramtypes', [angular2_1.ElementRef, angular2_1.DynamicComponentLoader, routerMod.Router, String])
    ], RouterOutlet);
    return RouterOutlet;
})();
exports.RouterOutlet = RouterOutlet;

},{"./instruction":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/instruction.js","./lifecycle_annotations":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/lifecycle_annotations.js","./route_data":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_data.js","./route_lifecycle_reflector":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/route_lifecycle_reflector.js","./router":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/router.js","angular2/angular2":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/angular2.js","angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js","angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/sync_route_handler.js":[function(require,module,exports){
'use strict';var async_1 = require('angular2/src/core/facade/async');
var SyncRouteHandler = (function () {
    function SyncRouteHandler(componentType, data) {
        this.componentType = componentType;
        this.data = data;
        /** @internal */
        this._resolvedComponent = null;
        this._resolvedComponent = async_1.PromiseWrapper.resolve(componentType);
    }
    SyncRouteHandler.prototype.resolveComponentType = function () { return this._resolvedComponent; };
    return SyncRouteHandler;
})();
exports.SyncRouteHandler = SyncRouteHandler;

},{"angular2/src/core/facade/async":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/async.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/router/url_parser.js":[function(require,module,exports){
'use strict';var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('angular2/src/core/facade/collection');
var lang_1 = require('angular2/src/core/facade/lang');
var exceptions_1 = require('angular2/src/core/facade/exceptions');
/**
 * This class represents a parsed URL
 */
var Url = (function () {
    function Url(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = lang_1.CONST_EXPR([]); }
        if (params === void 0) { params = null; }
        this.path = path;
        this.child = child;
        this.auxiliary = auxiliary;
        this.params = params;
    }
    Url.prototype.toString = function () {
        return this.path + this._matrixParamsToString() + this._auxToString() + this._childString();
    };
    Url.prototype.segmentToString = function () { return this.path + this._matrixParamsToString(); };
    /** @internal */
    Url.prototype._auxToString = function () {
        return this.auxiliary.length > 0 ?
            ('(' + this.auxiliary.map(function (sibling) { return sibling.toString(); }).join('//') + ')') :
            '';
    };
    Url.prototype._matrixParamsToString = function () {
        if (lang_1.isBlank(this.params)) {
            return '';
        }
        return ';' + serializeParams(this.params).join(';');
    };
    /** @internal */
    Url.prototype._childString = function () { return lang_1.isPresent(this.child) ? ('/' + this.child.toString()) : ''; };
    return Url;
})();
exports.Url = Url;
var RootUrl = (function (_super) {
    __extends(RootUrl, _super);
    function RootUrl(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = lang_1.CONST_EXPR([]); }
        if (params === void 0) { params = null; }
        _super.call(this, path, child, auxiliary, params);
    }
    RootUrl.prototype.toString = function () {
        return this.path + this._auxToString() + this._childString() + this._queryParamsToString();
    };
    RootUrl.prototype.segmentToString = function () { return this.path + this._queryParamsToString(); };
    RootUrl.prototype._queryParamsToString = function () {
        if (lang_1.isBlank(this.params)) {
            return '';
        }
        return '?' + serializeParams(this.params).join('&');
    };
    return RootUrl;
})(Url);
exports.RootUrl = RootUrl;
function pathSegmentsToUrl(pathSegments) {
    var url = new Url(pathSegments[pathSegments.length - 1]);
    for (var i = pathSegments.length - 2; i >= 0; i -= 1) {
        url = new Url(pathSegments[i], url);
    }
    return url;
}
exports.pathSegmentsToUrl = pathSegmentsToUrl;
var SEGMENT_RE = lang_1.RegExpWrapper.create('^[^\\/\\(\\)\\?;=&#]+');
function matchUrlSegment(str) {
    var match = lang_1.RegExpWrapper.firstMatch(SEGMENT_RE, str);
    return lang_1.isPresent(match) ? match[0] : '';
}
var UrlParser = (function () {
    function UrlParser() {
    }
    UrlParser.prototype.peekStartsWith = function (str) { return lang_1.StringWrapper.startsWith(this._remaining, str); };
    UrlParser.prototype.capture = function (str) {
        if (!lang_1.StringWrapper.startsWith(this._remaining, str)) {
            throw new exceptions_1.BaseException("Expected \"" + str + "\".");
        }
        this._remaining = this._remaining.substring(str.length);
    };
    UrlParser.prototype.parse = function (url) {
        this._remaining = url;
        if (url == '' || url == '/') {
            return new Url('');
        }
        return this.parseRoot();
    };
    // segment + (aux segments) + (query params)
    UrlParser.prototype.parseRoot = function () {
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        if (this.peekStartsWith(';')) {
            // TODO: should these params just be dropped?
            this.parseMatrixParams();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        var queryParams = null;
        if (this.peekStartsWith('?')) {
            queryParams = this.parseQueryParams();
        }
        return new RootUrl(path, child, aux, queryParams);
    };
    // segment + (matrix params) + (aux segments)
    UrlParser.prototype.parseSegment = function () {
        if (this._remaining.length == 0) {
            return null;
        }
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var matrixParams = null;
        if (this.peekStartsWith(';')) {
            matrixParams = this.parseMatrixParams();
        }
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        return new Url(path, child, aux, matrixParams);
    };
    UrlParser.prototype.parseQueryParams = function () {
        var params = {};
        this.capture('?');
        this.parseParam(params);
        while (this._remaining.length > 0 && this.peekStartsWith('&')) {
            this.capture('&');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseMatrixParams = function () {
        var params = {};
        while (this._remaining.length > 0 && this.peekStartsWith(';')) {
            this.capture(';');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseParam = function (params) {
        var key = matchUrlSegment(this._remaining);
        if (lang_1.isBlank(key)) {
            return;
        }
        this.capture(key);
        var value = true;
        if (this.peekStartsWith('=')) {
            this.capture('=');
            var valueMatch = matchUrlSegment(this._remaining);
            if (lang_1.isPresent(valueMatch)) {
                value = valueMatch;
                this.capture(value);
            }
        }
        params[key] = value;
    };
    UrlParser.prototype.parseAuxiliaryRoutes = function () {
        var routes = [];
        this.capture('(');
        while (!this.peekStartsWith(')') && this._remaining.length > 0) {
            routes.push(this.parseSegment());
            if (this.peekStartsWith('//')) {
                this.capture('//');
            }
        }
        this.capture(')');
        return routes;
    };
    return UrlParser;
})();
exports.UrlParser = UrlParser;
exports.parser = new UrlParser();
function serializeParams(paramMap) {
    var params = [];
    if (lang_1.isPresent(paramMap)) {
        collection_1.StringMapWrapper.forEach(paramMap, function (value, key) {
            if (value == true) {
                params.push(key);
            }
            else {
                params.push(key + '=' + value);
            }
        });
    }
    return params;
}
exports.serializeParams = serializeParams;

},{"angular2/src/core/facade/collection":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/collection.js","angular2/src/core/facade/exceptions":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/exceptions.js","angular2/src/core/facade/lang":"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/core/facade/lang.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/angular2/src/transform/template_compiler/change_detector_codegen.js":[function(require,module,exports){
'use strict';// Note: This class is only here so that we can reference it from TypeScript code.
// The actual implementation lives under modules_dart.
// TODO(tbosch): Move the corresponding code into angular2/src/core/compiler once
// the new compiler is done.
var Codegen = (function () {
    function Codegen(moduleAlias) {
    }
    Codegen.prototype.generate = function (typeName, changeDetectorTypeName, def) {
        throw "Not implemented in JS";
    };
    Codegen.prototype.toString = function () { throw "Not implemented in JS"; };
    return Codegen;
})();
exports.Codegen = Codegen;

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/dist/js/npm.js":[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/affix.js","../../js/alert.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/alert.js","../../js/button.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/button.js","../../js/carousel.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/carousel.js","../../js/collapse.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/collapse.js","../../js/dropdown.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/dropdown.js","../../js/modal.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/modal.js","../../js/popover.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/popover.js","../../js/scrollspy.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/scrollspy.js","../../js/tab.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tab.js","../../js/tooltip.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tooltip.js","../../js/transition.js":"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/transition.js"}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/affix.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.5
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.5'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/alert.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.5
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.5'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/button.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.5
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.5'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/carousel.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.5
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.5'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/collapse.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.5
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.5'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/dropdown.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.5
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.5'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/modal.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.5
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.5'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/popover.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.5
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.5'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/scrollspy.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.5
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.5'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tab.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.5
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.5'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/tooltip.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.5
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.5'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/bootstrap/js/transition.js":[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.5
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],"/Users/dave/lh2/angular2/study-tracker/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.3.1
    License: https://www.firebase.com/terms/terms-of-service.html */
(function() {var g,aa=this;function n(a){return void 0!==a}function ba(){}function ca(a){a.ub=function(){return a.uf?a.uf:a.uf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.bh=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Yg=function(a,c,f){for(var h=Array(arguments.length-2),k=2;k<arguments.length;k++)h[k-2]=arguments[k];return b.prototype[c].apply(a,h)}};function r(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function na(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function oa(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function pa(a){var b=0,c;for(c in a)b++;return b}function qa(a){for(var b in a)return b}function ra(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function sa(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function ta(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function ua(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function va(a,b){var c=ua(a,b,void 0);return c&&a[c]}function wa(a){for(var b in a)return!1;return!0}function xa(a){var b={},c;for(c in a)b[c]=a[c];return b}var ya="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function za(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<ya.length;f++)c=ya[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Aa(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function Ba(){this.Sd=void 0}
function Ca(a,b,c){switch(typeof b){case "string":Da(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],Ca(a,a.Sd?a.Sd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),Da(f,c),
c.push(":"),Ca(a,a.Sd?a.Sd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var Ea={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Fa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Da(a,b){b.push('"',a.replace(Fa,function(a){if(a in Ea)return Ea[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return Ea[a]=e+b.toString(16)}),'"')};function Ga(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var Ha;a:{var Ia=aa.navigator;if(Ia){var Ja=Ia.userAgent;if(Ja){Ha=Ja;break a}}Ha=""};function Ka(){this.Va=-1};function La(){this.Va=-1;this.Va=64;this.N=[];this.me=[];this.Wf=[];this.Ld=[];this.Ld[0]=128;for(var a=1;a<this.Va;++a)this.Ld[a]=0;this.de=this.ac=0;this.reset()}ma(La,Ka);La.prototype.reset=function(){this.N[0]=1732584193;this.N[1]=4023233417;this.N[2]=2562383102;this.N[3]=271733878;this.N[4]=3285377520;this.de=this.ac=0};
function Ma(a,b,c){c||(c=0);var d=a.Wf;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.N[0];c=a.N[1];for(var h=a.N[2],k=a.N[3],l=a.N[4],m,e=0;80>e;e++)40>e?20>e?(f=k^c&(h^k),m=1518500249):(f=c^h^k,m=1859775393):60>e?(f=c&h|k&(c|h),m=2400959708):(f=c^h^k,m=3395469782),f=(b<<
5|b>>>27)+f+l+m+d[e]&4294967295,l=k,k=h,h=(c<<30|c>>>2)&4294967295,c=b,b=f;a.N[0]=a.N[0]+b&4294967295;a.N[1]=a.N[1]+c&4294967295;a.N[2]=a.N[2]+h&4294967295;a.N[3]=a.N[3]+k&4294967295;a.N[4]=a.N[4]+l&4294967295}
La.prototype.update=function(a,b){if(null!=a){n(b)||(b=a.length);for(var c=b-this.Va,d=0,e=this.me,f=this.ac;d<b;){if(0==f)for(;d<=c;)Ma(this,a,d),d+=this.Va;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Va){Ma(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Va){Ma(this,e);f=0;break}}this.ac=f;this.de+=b}};var u=Array.prototype,Na=u.indexOf?function(a,b,c){return u.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Oa=u.forEach?function(a,b,c){u.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Pa=u.filter?function(a,b,c){return u.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,h=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in h){var l=h[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Qa=u.map?function(a,b,c){return u.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,h=0;h<d;h++)h in f&&(e[h]=b.call(c,f[h],h,a));return e},Ra=u.reduce?function(a,b,c,d){for(var e=[],f=1,h=arguments.length;f<h;f++)e.push(arguments[f]);d&&(e[0]=q(b,d));return u.reduce.apply(a,e)}:function(a,b,c,d){var e=c;Oa(a,function(c,h){e=b.call(d,e,c,h,a)});return e},Sa=u.every?function(a,b,
c){return u.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ta(a,b){var c=Ua(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Ua(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Va(a,b){var c=Na(a,b);0<=c&&u.splice.call(a,c,1)}function Wa(a,b,c){return 2>=arguments.length?u.slice.call(a,b):u.slice.call(a,b,c)}
function Xa(a,b){a.sort(b||Ya)}function Ya(a,b){return a>b?1:a<b?-1:0};var Za=-1!=Ha.indexOf("Opera")||-1!=Ha.indexOf("OPR"),$a=-1!=Ha.indexOf("Trident")||-1!=Ha.indexOf("MSIE"),ab=-1!=Ha.indexOf("Gecko")&&-1==Ha.toLowerCase().indexOf("webkit")&&!(-1!=Ha.indexOf("Trident")||-1!=Ha.indexOf("MSIE")),bb=-1!=Ha.toLowerCase().indexOf("webkit");
(function(){var a="",b;if(Za&&aa.opera)return a=aa.opera.version,ha(a)?a():a;ab?b=/rv\:([^\);]+)(\)|;)/:$a?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:bb&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Ha))?a[1]:"");return $a&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var cb=null,db=null,eb=null;function fb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");gb();for(var c=b?db:cb,d=[],e=0;e<a.length;e+=3){var f=a[e],h=e+1<a.length,k=h?a[e+1]:0,l=e+2<a.length,m=l?a[e+2]:0,t=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|m>>6,m=m&63;l||(m=64,h||(k=64));d.push(c[t],c[f],c[k],c[m])}return d.join("")}
function gb(){if(!cb){cb={};db={};eb={};for(var a=0;65>a;a++)cb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),db[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),eb[db[a]]=a,62<=a&&(eb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)]=a)}};var hb=hb||"2.3.1";function v(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function w(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ib(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function jb(a){var b={};ib(a,function(a,d){b[a]=d});return b};function kb(a){var b=[];ib(a,function(a,d){ea(d)?Oa(d,function(d){b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))}):b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))});return b.length?"&"+b.join("&"):""}function lb(a){var b={};a=a.replace(/^\?/,"").split("&");Oa(a,function(a){a&&(a=a.split("="),b[a[0]]=a[1])});return b};function x(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function y(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function A(a,b,c,d){if((!d||n(c))&&!ha(c))throw Error(y(a,b,d)+"must be a valid function.");}function mb(a,b,c){if(n(c)&&(!ia(c)||null===c))throw Error(y(a,b,!0)+"must be a valid context object.");};function nb(a){return"undefined"!==typeof JSON&&n(JSON.parse)?JSON.parse(a):Aa(a)}function B(a){if("undefined"!==typeof JSON&&n(JSON.stringify))a=JSON.stringify(a);else{var b=[];Ca(new Ba,a,b);a=b.join("")}return a};function ob(){this.Wd=C}ob.prototype.j=function(a){return this.Wd.Q(a)};ob.prototype.toString=function(){return this.Wd.toString()};function pb(){}pb.prototype.qf=function(){return null};pb.prototype.ye=function(){return null};var qb=new pb;function rb(a,b,c){this.Tf=a;this.Ka=b;this.Kd=c}rb.prototype.qf=function(a){var b=this.Ka.O;if(sb(b,a))return b.j().R(a);b=null!=this.Kd?new tb(this.Kd,!0,!1):this.Ka.w();return this.Tf.xc(a,b)};rb.prototype.ye=function(a,b,c){var d=null!=this.Kd?this.Kd:ub(this.Ka);a=this.Tf.ne(d,b,1,c,a);return 0===a.length?null:a[0]};function vb(){this.tb=[]}function wb(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Zb();null===c||f.ca(c.Zb())||(a.tb.push(c),c=null);null===c&&(c=new xb(f));c.add(e)}c&&a.tb.push(c)}function yb(a,b,c){wb(a,c);zb(a,function(a){return a.ca(b)})}function Ab(a,b,c){wb(a,c);zb(a,function(a){return a.contains(b)||b.contains(a)})}
function zb(a,b){for(var c=!0,d=0;d<a.tb.length;d++){var e=a.tb[d];if(e)if(e=e.Zb(),b(e)){for(var e=a.tb[d],f=0;f<e.vd.length;f++){var h=e.vd[f];if(null!==h){e.vd[f]=null;var k=h.Vb();Bb&&Cb("event: "+h.toString());Db(k)}}a.tb[d]=null}else c=!1}c&&(a.tb=[])}function xb(a){this.ra=a;this.vd=[]}xb.prototype.add=function(a){this.vd.push(a)};xb.prototype.Zb=function(){return this.ra};function D(a,b,c,d){this.type=a;this.Ja=b;this.Wa=c;this.Ke=d;this.Qd=void 0}function Eb(a){return new D(Fb,a)}var Fb="value";function Gb(a,b,c,d){this.ue=b;this.Zd=c;this.Qd=d;this.ud=a}Gb.prototype.Zb=function(){var a=this.Zd.Ib();return"value"===this.ud?a.path:a.parent().path};Gb.prototype.ze=function(){return this.ud};Gb.prototype.Vb=function(){return this.ue.Vb(this)};Gb.prototype.toString=function(){return this.Zb().toString()+":"+this.ud+":"+B(this.Zd.mf())};function Hb(a,b,c){this.ue=a;this.error=b;this.path=c}Hb.prototype.Zb=function(){return this.path};Hb.prototype.ze=function(){return"cancel"};
Hb.prototype.Vb=function(){return this.ue.Vb(this)};Hb.prototype.toString=function(){return this.path.toString()+":cancel"};function tb(a,b,c){this.A=a;this.ea=b;this.Ub=c}function Ib(a){return a.ea}function Jb(a){return a.Ub}function Kb(a,b){return b.e()?a.ea&&!a.Ub:sb(a,E(b))}function sb(a,b){return a.ea&&!a.Ub||a.A.Da(b)}tb.prototype.j=function(){return this.A};function Lb(a){this.gg=a;this.Dd=null}Lb.prototype.get=function(){var a=this.gg.get(),b=xa(a);if(this.Dd)for(var c in this.Dd)b[c]-=this.Dd[c];this.Dd=a;return b};function Mb(a,b){this.Of={};this.fd=new Lb(a);this.ba=b;var c=1E4+2E4*Math.random();setTimeout(q(this.If,this),Math.floor(c))}Mb.prototype.If=function(){var a=this.fd.get(),b={},c=!1,d;for(d in a)0<a[d]&&v(this.Of,d)&&(b[d]=a[d],c=!0);c&&this.ba.Ue(b);setTimeout(q(this.If,this),Math.floor(6E5*Math.random()))};function Nb(){this.Ec={}}function Ob(a,b,c){n(c)||(c=1);v(a.Ec,b)||(a.Ec[b]=0);a.Ec[b]+=c}Nb.prototype.get=function(){return xa(this.Ec)};var Pb={},Qb={};function Rb(a){a=a.toString();Pb[a]||(Pb[a]=new Nb);return Pb[a]}function Sb(a,b){var c=a.toString();Qb[c]||(Qb[c]=b());return Qb[c]};function F(a,b){this.name=a;this.S=b}function Tb(a,b){return new F(a,b)};function Ub(a,b){return Vb(a.name,b.name)}function Wb(a,b){return Vb(a,b)};function Xb(a,b,c){this.type=Yb;this.source=a;this.path=b;this.Ga=c}Xb.prototype.Xc=function(a){return this.path.e()?new Xb(this.source,G,this.Ga.R(a)):new Xb(this.source,H(this.path),this.Ga)};Xb.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function Zb(a,b){this.type=$b;this.source=a;this.path=b}Zb.prototype.Xc=function(){return this.path.e()?new Zb(this.source,G):new Zb(this.source,H(this.path))};Zb.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function ac(a,b){this.La=a;this.wa=b?b:bc}g=ac.prototype;g.Oa=function(a,b){return new ac(this.La,this.wa.Oa(a,b,this.La).Y(null,null,!1,null,null))};g.remove=function(a){return new ac(this.La,this.wa.remove(a,this.La).Y(null,null,!1,null,null))};g.get=function(a){for(var b,c=this.wa;!c.e();){b=this.La(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function cc(a,b){for(var c,d=a.wa,e=null;!d.e();){c=a.La(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}g.e=function(){return this.wa.e()};g.count=function(){return this.wa.count()};g.Sc=function(){return this.wa.Sc()};g.fc=function(){return this.wa.fc()};g.ia=function(a){return this.wa.ia(a)};
g.Xb=function(a){return new dc(this.wa,null,this.La,!1,a)};g.Yb=function(a,b){return new dc(this.wa,a,this.La,!1,b)};g.$b=function(a,b){return new dc(this.wa,a,this.La,!0,b)};g.sf=function(a){return new dc(this.wa,null,this.La,!0,a)};function dc(a,b,c,d,e){this.Ud=e||null;this.Fe=d;this.Pa=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.Fe?a.left:a.right;else if(0===e){this.Pa.push(a);break}else this.Pa.push(a),a=this.Fe?a.right:a.left}
function J(a){if(0===a.Pa.length)return null;var b=a.Pa.pop(),c;c=a.Ud?a.Ud(b.key,b.value):{key:b.key,value:b.value};if(a.Fe)for(b=b.left;!b.e();)a.Pa.push(b),b=b.right;else for(b=b.right;!b.e();)a.Pa.push(b),b=b.left;return c}function ec(a){if(0===a.Pa.length)return null;var b;b=a.Pa;b=b[b.length-1];return a.Ud?a.Ud(b.key,b.value):{key:b.key,value:b.value}}function fc(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:bc;this.right=null!=e?e:bc}g=fc.prototype;
g.Y=function(a,b,c,d,e){return new fc(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};g.count=function(){return this.left.count()+1+this.right.count()};g.e=function(){return!1};g.ia=function(a){return this.left.ia(a)||a(this.key,this.value)||this.right.ia(a)};function gc(a){return a.left.e()?a:gc(a.left)}g.Sc=function(){return gc(this).key};g.fc=function(){return this.right.e()?this.key:this.right.fc()};
g.Oa=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.Y(null,null,null,e.left.Oa(a,b,c),null):0===d?e.Y(null,b,null,null,null):e.Y(null,null,null,null,e.right.Oa(a,b,c));return hc(e)};function ic(a){if(a.left.e())return bc;a.left.fa()||a.left.left.fa()||(a=jc(a));a=a.Y(null,null,null,ic(a.left),null);return hc(a)}
g.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.fa()||c.left.left.fa()||(c=jc(c)),c=c.Y(null,null,null,c.left.remove(a,b),null);else{c.left.fa()&&(c=kc(c));c.right.e()||c.right.fa()||c.right.left.fa()||(c=lc(c),c.left.left.fa()&&(c=kc(c),c=lc(c)));if(0===b(a,c.key)){if(c.right.e())return bc;d=gc(c.right);c=c.Y(d.key,d.value,null,null,ic(c.right))}c=c.Y(null,null,null,null,c.right.remove(a,b))}return hc(c)};g.fa=function(){return this.color};
function hc(a){a.right.fa()&&!a.left.fa()&&(a=mc(a));a.left.fa()&&a.left.left.fa()&&(a=kc(a));a.left.fa()&&a.right.fa()&&(a=lc(a));return a}function jc(a){a=lc(a);a.right.left.fa()&&(a=a.Y(null,null,null,null,kc(a.right)),a=mc(a),a=lc(a));return a}function mc(a){return a.right.Y(null,null,a.color,a.Y(null,null,!0,null,a.right.left),null)}function kc(a){return a.left.Y(null,null,a.color,null,a.Y(null,null,!0,a.left.right,null))}
function lc(a){return a.Y(null,null,!a.color,a.left.Y(null,null,!a.left.color,null,null),a.right.Y(null,null,!a.right.color,null,null))}function nc(){}g=nc.prototype;g.Y=function(){return this};g.Oa=function(a,b){return new fc(a,b,null)};g.remove=function(){return this};g.count=function(){return 0};g.e=function(){return!0};g.ia=function(){return!1};g.Sc=function(){return null};g.fc=function(){return null};g.fa=function(){return!1};var bc=new nc;function oc(a,b){return a&&"object"===typeof a?(K(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function pc(a,b){var c=new qc;rc(a,new L(""),function(a,e){c.nc(a,sc(e,b))});return c}function sc(a,b){var c=a.C().I(),c=oc(c,b),d;if(a.K()){var e=oc(a.Ca(),b);return e!==a.Ca()||c!==a.C().I()?new tc(e,M(c)):a}d=a;c!==a.C().I()&&(d=d.ga(new tc(c)));a.P(N,function(a,c){var e=sc(c,b);e!==c&&(d=d.U(a,e))});return d};function uc(){this.wc={}}uc.prototype.set=function(a,b){null==b?delete this.wc[a]:this.wc[a]=b};uc.prototype.get=function(a){return v(this.wc,a)?this.wc[a]:null};uc.prototype.remove=function(a){delete this.wc[a]};uc.prototype.wf=!0;function vc(a){this.Fc=a;this.Pd="firebase:"}g=vc.prototype;g.set=function(a,b){null==b?this.Fc.removeItem(this.Pd+a):this.Fc.setItem(this.Pd+a,B(b))};g.get=function(a){a=this.Fc.getItem(this.Pd+a);return null==a?null:nb(a)};g.remove=function(a){this.Fc.removeItem(this.Pd+a)};g.wf=!1;g.toString=function(){return this.Fc.toString()};function wc(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new vc(b)}}catch(c){}return new uc}var xc=wc("localStorage"),yc=wc("sessionStorage");function zc(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.kb=b;this.hc=c;this.Wg=d;this.Od=e||"";this.Ya=xc.get("host:"+a)||this.host}function Ac(a,b){b!==a.Ya&&(a.Ya=b,"s-"===a.Ya.substr(0,2)&&xc.set("host:"+a.host,a.Ya))}
function Bc(a,b,c){K("string"===typeof b,"typeof type must == string");K("object"===typeof c,"typeof params must == object");if(b===Cc)b=(a.kb?"wss://":"ws://")+a.Ya+"/.ws?";else if(b===Dc)b=(a.kb?"https://":"http://")+a.Ya+"/.lp?";else throw Error("Unknown connection type: "+b);a.host!==a.Ya&&(c.ns=a.hc);var d=[];r(c,function(a,b){d.push(b+"="+a)});return b+d.join("&")}zc.prototype.toString=function(){var a=(this.kb?"https://":"http://")+this.host;this.Od&&(a+="<"+this.Od+">");return a};var Ec=function(){var a=1;return function(){return a++}}();function K(a,b){if(!a)throw Fc(b);}function Fc(a){return Error("Firebase ("+hb+") INTERNAL ASSERT FAILED: "+a)}
function Gc(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{gb();for(var c=eb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],h=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==h||null==k||null==l)throw Error();d.push(f<<2|h>>4);64!=k&&(d.push(h<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Wa(d,c,
c+8192));b=a}}return b}catch(m){Cb("base64Decode failed: ",m)}return null}function Hc(a){var b=Ic(a);a=new La;a.update(b);var b=[],c=8*a.de;56>a.ac?a.update(a.Ld,56-a.ac):a.update(a.Ld,a.Va-(a.ac-56));for(var d=a.Va-1;56<=d;d--)a.me[d]=c&255,c/=256;Ma(a,a.me);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.N[d]>>e&255,++c;return fb(b)}
function Jc(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+Jc.apply(null,arguments[c]):"object"===typeof arguments[c]?b+B(arguments[c]):b+arguments[c],b+=" ";return b}var Bb=null,Kc=!0;function Cb(a){!0===Kc&&(Kc=!1,null===Bb&&!0===yc.get("logging_enabled")&&Lc(!0));if(Bb){var b=Jc.apply(null,arguments);Bb(b)}}function Mc(a){return function(){Cb(a,arguments)}}
function Nc(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+Jc.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function Oc(a){var b=Jc.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function O(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+Jc.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function Pc(a){var b="",c="",d="",e="",f=!0,h="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(h=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var m=a[l];try{m=decodeURIComponent(m.replace(/\+/g," "))}catch(t){}e+="/"+m}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===h||"wss"===h,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Tg:d,kb:f,scheme:h,$c:e}}function Qc(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function Rc(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function Vb(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=Sc(a),d=Sc(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function Tc(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+B(b));}
function Uc(a){if("object"!==typeof a||null===a)return B(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=B(b[d]),c+=":",c+=Uc(a[b[d]]);return c+"}"}function Vc(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function Wc(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else r(a,b)}
function Xc(a){K(!Qc(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;--a)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;--a)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Yc=/^-?\d{1,10}$/;function Sc(a){return Yc.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Db(a){try{a()}catch(b){setTimeout(function(){O("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function P(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Db(function(){a.apply(null,c)})}};function Ic(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,K(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b}function Zc(a){for(var b=0,c=0;c<a.length;c++){var d=a.charCodeAt(c);128>d?b++:2048>d?b+=2:55296<=d&&56319>=d?(b+=4,c++):b+=3}return b};function $c(a){var b={},c={},d={},e="";try{var f=a.split("."),b=nb(Gc(f[0])||""),c=nb(Gc(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(h){}return{Zg:b,Bc:c,data:d,Qg:e}}function ad(a){a=$c(a).Bc;return"object"===typeof a&&a.hasOwnProperty("iat")?w(a,"iat"):null}function bd(a){a=$c(a);var b=a.Bc;return!!a.Qg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function cd(a){this.W=a;this.g=a.n.g}function dd(a,b,c,d){var e=[],f=[];Oa(b,function(b){"child_changed"===b.type&&a.g.Ad(b.Ke,b.Ja)&&f.push(new D("child_moved",b.Ja,b.Wa))});ed(a,e,"child_removed",b,d,c);ed(a,e,"child_added",b,d,c);ed(a,e,"child_moved",f,d,c);ed(a,e,"child_changed",b,d,c);ed(a,e,Fb,b,d,c);return e}function ed(a,b,c,d,e,f){d=Pa(d,function(a){return a.type===c});Xa(d,q(a.hg,a));Oa(d,function(c){var d=fd(a,c,f);Oa(e,function(e){e.Kf(c.type)&&b.push(e.createEvent(d,a.W))})})}
function fd(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Qd=c.rf(b.Wa,b.Ja,a.g));return b}cd.prototype.hg=function(a,b){if(null==a.Wa||null==b.Wa)throw Fc("Should only compare child_ events.");return this.g.compare(new F(a.Wa,a.Ja),new F(b.Wa,b.Ja))};function gd(){this.bb={}}
function hd(a,b){var c=b.type,d=b.Wa;K("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");K(".priority"!==d,"Only non-priority child changes can be tracked.");var e=w(a.bb,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.bb[d]=new D("child_changed",b.Ja,d,e.Ja);else if("child_removed"==c&&"child_added"==f)delete a.bb[d];else if("child_removed"==c&&"child_changed"==f)a.bb[d]=new D("child_removed",e.Ke,d);else if("child_changed"==c&&
"child_added"==f)a.bb[d]=new D("child_added",b.Ja,d);else if("child_changed"==c&&"child_changed"==f)a.bb[d]=new D("child_changed",b.Ja,d,e.Ke);else throw Fc("Illegal combination of changes: "+b+" occurred after "+e);}else a.bb[d]=b};function id(a,b,c){this.Rb=a;this.pb=b;this.rb=c||null}g=id.prototype;g.Kf=function(a){return"value"===a};g.createEvent=function(a,b){var c=b.n.g;return new Gb("value",this,new Q(a.Ja,b.Ib(),c))};g.Vb=function(a){var b=this.rb;if("cancel"===a.ze()){K(this.pb,"Raising a cancel event on a listener with no cancel callback");var c=this.pb;return function(){c.call(b,a.error)}}var d=this.Rb;return function(){d.call(b,a.Zd)}};g.gf=function(a,b){return this.pb?new Hb(this,a,b):null};
g.matches=function(a){return a instanceof id?a.Rb&&this.Rb?a.Rb===this.Rb&&a.rb===this.rb:!0:!1};g.tf=function(){return null!==this.Rb};function jd(a,b,c){this.ha=a;this.pb=b;this.rb=c}g=jd.prototype;g.Kf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ha};g.gf=function(a,b){return this.pb?new Hb(this,a,b):null};
g.createEvent=function(a,b){K(null!=a.Wa,"Child events should have a childName.");var c=b.Ib().u(a.Wa);return new Gb(a.type,this,new Q(a.Ja,c,b.n.g),a.Qd)};g.Vb=function(a){var b=this.rb;if("cancel"===a.ze()){K(this.pb,"Raising a cancel event on a listener with no cancel callback");var c=this.pb;return function(){c.call(b,a.error)}}var d=this.ha[a.ud];return function(){d.call(b,a.Zd,a.Qd)}};
g.matches=function(a){if(a instanceof jd){if(!this.ha||!a.ha)return!0;if(this.rb===a.rb){var b=pa(a.ha);if(b===pa(this.ha)){if(1===b){var b=qa(a.ha),c=qa(this.ha);return c===b&&(!a.ha[b]||!this.ha[c]||a.ha[b]===this.ha[c])}return oa(this.ha,function(b,c){return a.ha[c]===b})}}}return!1};g.tf=function(){return null!==this.ha};function kd(a){this.g=a}g=kd.prototype;g.G=function(a,b,c,d,e,f){K(a.Jc(this.g),"A node must be indexed if only a child is updated");e=a.R(b);if(e.Q(d).ca(c.Q(d))&&e.e()==c.e())return a;null!=f&&(c.e()?a.Da(b)?hd(f,new D("child_removed",e,b)):K(a.K(),"A child remove without an old child only makes sense on a leaf node"):e.e()?hd(f,new D("child_added",c,b)):hd(f,new D("child_changed",c,b,e)));return a.K()&&c.e()?a:a.U(b,c).lb(this.g)};
g.xa=function(a,b,c){null!=c&&(a.K()||a.P(N,function(a,e){b.Da(a)||hd(c,new D("child_removed",e,a))}),b.K()||b.P(N,function(b,e){if(a.Da(b)){var f=a.R(b);f.ca(e)||hd(c,new D("child_changed",e,b,f))}else hd(c,new D("child_added",e,b))}));return b.lb(this.g)};g.ga=function(a,b){return a.e()?C:a.ga(b)};g.Na=function(){return!1};g.Wb=function(){return this};function ld(a){this.Be=new kd(a.g);this.g=a.g;var b;a.ma?(b=md(a),b=a.g.Pc(nd(a),b)):b=a.g.Tc();this.ed=b;a.pa?(b=od(a),a=a.g.Pc(pd(a),b)):a=a.g.Qc();this.Gc=a}g=ld.prototype;g.matches=function(a){return 0>=this.g.compare(this.ed,a)&&0>=this.g.compare(a,this.Gc)};g.G=function(a,b,c,d,e,f){this.matches(new F(b,c))||(c=C);return this.Be.G(a,b,c,d,e,f)};
g.xa=function(a,b,c){b.K()&&(b=C);var d=b.lb(this.g),d=d.ga(C),e=this;b.P(N,function(a,b){e.matches(new F(a,b))||(d=d.U(a,C))});return this.Be.xa(a,d,c)};g.ga=function(a){return a};g.Na=function(){return!0};g.Wb=function(){return this.Be};function qd(a){this.sa=new ld(a);this.g=a.g;K(a.ja,"Only valid if limit has been set");this.ka=a.ka;this.Jb=!rd(a)}g=qd.prototype;g.G=function(a,b,c,d,e,f){this.sa.matches(new F(b,c))||(c=C);return a.R(b).ca(c)?a:a.Db()<this.ka?this.sa.Wb().G(a,b,c,d,e,f):sd(this,a,b,c,e,f)};
g.xa=function(a,b,c){var d;if(b.K()||b.e())d=C.lb(this.g);else if(2*this.ka<b.Db()&&b.Jc(this.g)){d=C.lb(this.g);b=this.Jb?b.$b(this.sa.Gc,this.g):b.Yb(this.sa.ed,this.g);for(var e=0;0<b.Pa.length&&e<this.ka;){var f=J(b),h;if(h=this.Jb?0>=this.g.compare(this.sa.ed,f):0>=this.g.compare(f,this.sa.Gc))d=d.U(f.name,f.S),e++;else break}}else{d=b.lb(this.g);d=d.ga(C);var k,l,m;if(this.Jb){b=d.sf(this.g);k=this.sa.Gc;l=this.sa.ed;var t=td(this.g);m=function(a,b){return t(b,a)}}else b=d.Xb(this.g),k=this.sa.ed,
l=this.sa.Gc,m=td(this.g);for(var e=0,z=!1;0<b.Pa.length;)f=J(b),!z&&0>=m(k,f)&&(z=!0),(h=z&&e<this.ka&&0>=m(f,l))?e++:d=d.U(f.name,C)}return this.sa.Wb().xa(a,d,c)};g.ga=function(a){return a};g.Na=function(){return!0};g.Wb=function(){return this.sa.Wb()};
function sd(a,b,c,d,e,f){var h;if(a.Jb){var k=td(a.g);h=function(a,b){return k(b,a)}}else h=td(a.g);K(b.Db()==a.ka,"");var l=new F(c,d),m=a.Jb?ud(b,a.g):vd(b,a.g),t=a.sa.matches(l);if(b.Da(c)){for(var z=b.R(c),m=e.ye(a.g,m,a.Jb);null!=m&&(m.name==c||b.Da(m.name));)m=e.ye(a.g,m,a.Jb);e=null==m?1:h(m,l);if(t&&!d.e()&&0<=e)return null!=f&&hd(f,new D("child_changed",d,c,z)),b.U(c,d);null!=f&&hd(f,new D("child_removed",z,c));b=b.U(c,C);return null!=m&&a.sa.matches(m)?(null!=f&&hd(f,new D("child_added",
m.S,m.name)),b.U(m.name,m.S)):b}return d.e()?b:t&&0<=h(m,l)?(null!=f&&(hd(f,new D("child_removed",m.S,m.name)),hd(f,new D("child_added",d,c))),b.U(c,d).U(m.name,C)):b};function wd(a,b){this.je=a;this.fg=b}function xd(a){this.V=a}
xd.prototype.ab=function(a,b,c,d){var e=new gd,f;if(b.type===Yb)b.source.we?c=yd(this,a,b.path,b.Ga,c,d,e):(K(b.source.pf,"Unknown source."),f=b.source.af||Jb(a.w())&&!b.path.e(),c=Ad(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===Bd)b.source.we?c=Cd(this,a,b.path,b.children,c,d,e):(K(b.source.pf,"Unknown source."),f=b.source.af||Jb(a.w()),c=Dd(this,a,b.path,b.children,c,d,f,e));else if(b.type===Ed)if(b.Vd)if(b=b.path,null!=c.tc(b))c=a;else{f=new rb(c,a,d);d=a.O.j();if(b.e()||".priority"===E(b))Ib(a.w())?
b=c.za(ub(a)):(b=a.w().j(),K(b instanceof R,"serverChildren would be complete if leaf node"),b=c.yc(b)),b=this.V.xa(d,b,e);else{var h=E(b),k=c.xc(h,a.w());null==k&&sb(a.w(),h)&&(k=d.R(h));b=null!=k?this.V.G(d,h,k,H(b),f,e):a.O.j().Da(h)?this.V.G(d,h,C,H(b),f,e):d;b.e()&&Ib(a.w())&&(d=c.za(ub(a)),d.K()&&(b=this.V.xa(b,d,e)))}d=Ib(a.w())||null!=c.tc(G);c=Fd(a,b,d,this.V.Na())}else c=Gd(this,a,b.path,b.Qb,c,d,e);else if(b.type===$b)d=b.path,b=a.w(),f=b.j(),h=b.ea||d.e(),c=Hd(this,new Id(a.O,new tb(f,
h,b.Ub)),d,c,qb,e);else throw Fc("Unknown operation type: "+b.type);e=ra(e.bb);d=c;b=d.O;b.ea&&(f=b.j().K()||b.j().e(),h=Jd(a),(0<e.length||!a.O.ea||f&&!b.j().ca(h)||!b.j().C().ca(h.C()))&&e.push(Eb(Jd(d))));return new wd(c,e)};
function Hd(a,b,c,d,e,f){var h=b.O;if(null!=d.tc(c))return b;var k;if(c.e())K(Ib(b.w()),"If change path is empty, we must have complete server data"),Jb(b.w())?(e=ub(b),d=d.yc(e instanceof R?e:C)):d=d.za(ub(b)),f=a.V.xa(b.O.j(),d,f);else{var l=E(c);if(".priority"==l)K(1==Kd(c),"Can't have a priority with additional path components"),f=h.j(),k=b.w().j(),d=d.ld(c,f,k),f=null!=d?a.V.ga(f,d):h.j();else{var m=H(c);sb(h,l)?(k=b.w().j(),d=d.ld(c,h.j(),k),d=null!=d?h.j().R(l).G(m,d):h.j().R(l)):d=d.xc(l,
b.w());f=null!=d?a.V.G(h.j(),l,d,m,e,f):h.j()}}return Fd(b,f,h.ea||c.e(),a.V.Na())}function Ad(a,b,c,d,e,f,h,k){var l=b.w();h=h?a.V:a.V.Wb();if(c.e())d=h.xa(l.j(),d,null);else if(h.Na()&&!l.Ub)d=l.j().G(c,d),d=h.xa(l.j(),d,null);else{var m=E(c);if(!Kb(l,c)&&1<Kd(c))return b;var t=H(c);d=l.j().R(m).G(t,d);d=".priority"==m?h.ga(l.j(),d):h.G(l.j(),m,d,t,qb,null)}l=l.ea||c.e();b=new Id(b.O,new tb(d,l,h.Na()));return Hd(a,b,c,e,new rb(e,b,f),k)}
function yd(a,b,c,d,e,f,h){var k=b.O;e=new rb(e,b,f);if(c.e())h=a.V.xa(b.O.j(),d,h),a=Fd(b,h,!0,a.V.Na());else if(f=E(c),".priority"===f)h=a.V.ga(b.O.j(),d),a=Fd(b,h,k.ea,k.Ub);else{c=H(c);var l=k.j().R(f);if(!c.e()){var m=e.qf(f);d=null!=m?".priority"===Ld(c)&&m.Q(c.parent()).e()?m:m.G(c,d):C}l.ca(d)?a=b:(h=a.V.G(k.j(),f,d,c,e,h),a=Fd(b,h,k.ea,a.V.Na()))}return a}
function Cd(a,b,c,d,e,f,h){var k=b;Md(d,function(d,m){var t=c.u(d);sb(b.O,E(t))&&(k=yd(a,k,t,m,e,f,h))});Md(d,function(d,m){var t=c.u(d);sb(b.O,E(t))||(k=yd(a,k,t,m,e,f,h))});return k}function Nd(a,b){Md(b,function(b,d){a=a.G(b,d)});return a}
function Dd(a,b,c,d,e,f,h,k){if(b.w().j().e()&&!Ib(b.w()))return b;var l=b;c=c.e()?d:Od(Pd,c,d);var m=b.w().j();c.children.ia(function(c,d){if(m.Da(c)){var I=b.w().j().R(c),I=Nd(I,d);l=Ad(a,l,new L(c),I,e,f,h,k)}});c.children.ia(function(c,d){var I=!sb(b.w(),c)&&null==d.value;m.Da(c)||I||(I=b.w().j().R(c),I=Nd(I,d),l=Ad(a,l,new L(c),I,e,f,h,k))});return l}
function Gd(a,b,c,d,e,f,h){if(null!=e.tc(c))return b;var k=Jb(b.w()),l=b.w();if(null!=d.value){if(c.e()&&l.ea||Kb(l,c))return Ad(a,b,c,l.j().Q(c),e,f,k,h);if(c.e()){var m=Pd;l.j().P(Qd,function(a,b){m=m.set(new L(a),b)});return Dd(a,b,c,m,e,f,k,h)}return b}m=Pd;Md(d,function(a){var b=c.u(a);Kb(l,b)&&(m=m.set(a,l.j().Q(b)))});return Dd(a,b,c,m,e,f,k,h)};function Rd(){}var Sd={};function td(a){return q(a.compare,a)}Rd.prototype.Ad=function(a,b){return 0!==this.compare(new F("[MIN_NAME]",a),new F("[MIN_NAME]",b))};Rd.prototype.Tc=function(){return Td};function Ud(a){K(!a.e()&&".priority"!==E(a),"Can't create PathIndex with empty path or .priority key");this.cc=a}ma(Ud,Rd);g=Ud.prototype;g.Ic=function(a){return!a.Q(this.cc).e()};g.compare=function(a,b){var c=a.S.Q(this.cc),d=b.S.Q(this.cc),c=c.Dc(d);return 0===c?Vb(a.name,b.name):c};
g.Pc=function(a,b){var c=M(a),c=C.G(this.cc,c);return new F(b,c)};g.Qc=function(){var a=C.G(this.cc,Vd);return new F("[MAX_NAME]",a)};g.toString=function(){return this.cc.slice().join("/")};function Wd(){}ma(Wd,Rd);g=Wd.prototype;g.compare=function(a,b){var c=a.S.C(),d=b.S.C(),c=c.Dc(d);return 0===c?Vb(a.name,b.name):c};g.Ic=function(a){return!a.C().e()};g.Ad=function(a,b){return!a.C().ca(b.C())};g.Tc=function(){return Td};g.Qc=function(){return new F("[MAX_NAME]",new tc("[PRIORITY-POST]",Vd))};
g.Pc=function(a,b){var c=M(a);return new F(b,new tc("[PRIORITY-POST]",c))};g.toString=function(){return".priority"};var N=new Wd;function Xd(){}ma(Xd,Rd);g=Xd.prototype;g.compare=function(a,b){return Vb(a.name,b.name)};g.Ic=function(){throw Fc("KeyIndex.isDefinedOn not expected to be called.");};g.Ad=function(){return!1};g.Tc=function(){return Td};g.Qc=function(){return new F("[MAX_NAME]",C)};g.Pc=function(a){K(p(a),"KeyIndex indexValue must always be a string.");return new F(a,C)};g.toString=function(){return".key"};
var Qd=new Xd;function Yd(){}ma(Yd,Rd);g=Yd.prototype;g.compare=function(a,b){var c=a.S.Dc(b.S);return 0===c?Vb(a.name,b.name):c};g.Ic=function(){return!0};g.Ad=function(a,b){return!a.ca(b)};g.Tc=function(){return Td};g.Qc=function(){return Zd};g.Pc=function(a,b){var c=M(a);return new F(b,c)};g.toString=function(){return".value"};var $d=new Yd;function ae(){this.Tb=this.pa=this.Lb=this.ma=this.ja=!1;this.ka=0;this.Nb="";this.ec=null;this.xb="";this.bc=null;this.vb="";this.g=N}var be=new ae;function rd(a){return""===a.Nb?a.ma:"l"===a.Nb}function nd(a){K(a.ma,"Only valid if start has been set");return a.ec}function md(a){K(a.ma,"Only valid if start has been set");return a.Lb?a.xb:"[MIN_NAME]"}function pd(a){K(a.pa,"Only valid if end has been set");return a.bc}
function od(a){K(a.pa,"Only valid if end has been set");return a.Tb?a.vb:"[MAX_NAME]"}function ce(a){var b=new ae;b.ja=a.ja;b.ka=a.ka;b.ma=a.ma;b.ec=a.ec;b.Lb=a.Lb;b.xb=a.xb;b.pa=a.pa;b.bc=a.bc;b.Tb=a.Tb;b.vb=a.vb;b.g=a.g;return b}g=ae.prototype;g.He=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="";return b};g.Ie=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="l";return b};g.Je=function(a){var b=ce(this);b.ja=!0;b.ka=a;b.Nb="r";return b};
g.$d=function(a,b){var c=ce(this);c.ma=!0;n(a)||(a=null);c.ec=a;null!=b?(c.Lb=!0,c.xb=b):(c.Lb=!1,c.xb="");return c};g.td=function(a,b){var c=ce(this);c.pa=!0;n(a)||(a=null);c.bc=a;n(b)?(c.Tb=!0,c.vb=b):(c.ah=!1,c.vb="");return c};function de(a,b){var c=ce(a);c.g=b;return c}function ee(a){var b={};a.ma&&(b.sp=a.ec,a.Lb&&(b.sn=a.xb));a.pa&&(b.ep=a.bc,a.Tb&&(b.en=a.vb));if(a.ja){b.l=a.ka;var c=a.Nb;""===c&&(c=rd(a)?"l":"r");b.vf=c}a.g!==N&&(b.i=a.g.toString());return b}
function S(a){return!(a.ma||a.pa||a.ja)}function fe(a){return S(a)&&a.g==N}function ge(a){var b={};if(fe(a))return b;var c;a.g===N?c="$priority":a.g===$d?c="$value":a.g===Qd?c="$key":(K(a.g instanceof Ud,"Unrecognized index type!"),c=a.g.toString());b.orderBy=B(c);a.ma&&(b.startAt=B(a.ec),a.Lb&&(b.startAt+=","+B(a.xb)));a.pa&&(b.endAt=B(a.bc),a.Tb&&(b.endAt+=","+B(a.vb)));a.ja&&(rd(a)?b.limitToFirst=a.ka:b.limitToLast=a.ka);return b}g.toString=function(){return B(ee(this))};function he(a,b){this.Bd=a;this.dc=b}he.prototype.get=function(a){var b=w(this.Bd,a);if(!b)throw Error("No index defined for "+a);return b===Sd?null:b};function ie(a,b,c){var d=na(a.Bd,function(d,f){var h=w(a.dc,f);K(h,"Missing index implementation for "+f);if(d===Sd){if(h.Ic(b.S)){for(var k=[],l=c.Xb(Tb),m=J(l);m;)m.name!=b.name&&k.push(m),m=J(l);k.push(b);return je(k,td(h))}return Sd}h=c.get(b.name);k=d;h&&(k=k.remove(new F(b.name,h)));return k.Oa(b,b.S)});return new he(d,a.dc)}
function ke(a,b,c){var d=na(a.Bd,function(a){if(a===Sd)return a;var d=c.get(b.name);return d?a.remove(new F(b.name,d)):a});return new he(d,a.dc)}var le=new he({".priority":Sd},{".priority":N});function tc(a,b){this.B=a;K(n(this.B)&&null!==this.B,"LeafNode shouldn't be created with null/undefined value.");this.aa=b||C;me(this.aa);this.Cb=null}var ne=["object","boolean","number","string"];g=tc.prototype;g.K=function(){return!0};g.C=function(){return this.aa};g.ga=function(a){return new tc(this.B,a)};g.R=function(a){return".priority"===a?this.aa:C};g.Q=function(a){return a.e()?this:".priority"===E(a)?this.aa:C};g.Da=function(){return!1};g.rf=function(){return null};
g.U=function(a,b){return".priority"===a?this.ga(b):b.e()&&".priority"!==a?this:C.U(a,b).ga(this.aa)};g.G=function(a,b){var c=E(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;K(".priority"!==c||1===Kd(a),".priority must be the last token in a path");return this.U(c,C.G(H(a),b))};g.e=function(){return!1};g.Db=function(){return 0};g.P=function(){return!1};g.I=function(a){return a&&!this.C().e()?{".value":this.Ca(),".priority":this.C().I()}:this.Ca()};
g.hash=function(){if(null===this.Cb){var a="";this.aa.e()||(a+="priority:"+oe(this.aa.I())+":");var b=typeof this.B,a=a+(b+":"),a="number"===b?a+Xc(this.B):a+this.B;this.Cb=Hc(a)}return this.Cb};g.Ca=function(){return this.B};g.Dc=function(a){if(a===C)return 1;if(a instanceof R)return-1;K(a.K(),"Unknown node type");var b=typeof a.B,c=typeof this.B,d=Na(ne,b),e=Na(ne,c);K(0<=d,"Unknown leaf type: "+b);K(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.B<a.B?-1:this.B===a.B?0:1:e-d};
g.lb=function(){return this};g.Jc=function(){return!0};g.ca=function(a){return a===this?!0:a.K()?this.B===a.B&&this.aa.ca(a.aa):!1};g.toString=function(){return B(this.I(!0))};function R(a,b,c){this.m=a;(this.aa=b)&&me(this.aa);a.e()&&K(!this.aa||this.aa.e(),"An empty node cannot have a priority");this.wb=c;this.Cb=null}g=R.prototype;g.K=function(){return!1};g.C=function(){return this.aa||C};g.ga=function(a){return this.m.e()?this:new R(this.m,a,this.wb)};g.R=function(a){if(".priority"===a)return this.C();a=this.m.get(a);return null===a?C:a};g.Q=function(a){var b=E(a);return null===b?this:this.R(b).Q(H(a))};g.Da=function(a){return null!==this.m.get(a)};
g.U=function(a,b){K(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.ga(b);var c=new F(a,b),d,e;b.e()?(d=this.m.remove(a),c=ke(this.wb,c,this.m)):(d=this.m.Oa(a,b),c=ie(this.wb,c,this.m));e=d.e()?C:this.aa;return new R(d,e,c)};g.G=function(a,b){var c=E(a);if(null===c)return b;K(".priority"!==E(a)||1===Kd(a),".priority must be the last token in a path");var d=this.R(c).G(H(a),b);return this.U(c,d)};g.e=function(){return this.m.e()};g.Db=function(){return this.m.count()};
var pe=/^(0|[1-9]\d*)$/;g=R.prototype;g.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.P(N,function(f,h){b[f]=h.I(a);c++;e&&pe.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],h;for(h in b)f[h]=b[h];return f}a&&!this.C().e()&&(b[".priority"]=this.C().I());return b};g.hash=function(){if(null===this.Cb){var a="";this.C().e()||(a+="priority:"+oe(this.C().I())+":");this.P(N,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.Cb=""===a?"":Hc(a)}return this.Cb};
g.rf=function(a,b,c){return(c=qe(this,c))?(a=cc(c,new F(a,b)))?a.name:null:cc(this.m,a)};function ud(a,b){var c;c=(c=qe(a,b))?(c=c.Sc())&&c.name:a.m.Sc();return c?new F(c,a.m.get(c)):null}function vd(a,b){var c;c=(c=qe(a,b))?(c=c.fc())&&c.name:a.m.fc();return c?new F(c,a.m.get(c)):null}g.P=function(a,b){var c=qe(this,a);return c?c.ia(function(a){return b(a.name,a.S)}):this.m.ia(b)};g.Xb=function(a){return this.Yb(a.Tc(),a)};
g.Yb=function(a,b){var c=qe(this,b);if(c)return c.Yb(a,function(a){return a});for(var c=this.m.Yb(a.name,Tb),d=ec(c);null!=d&&0>b.compare(d,a);)J(c),d=ec(c);return c};g.sf=function(a){return this.$b(a.Qc(),a)};g.$b=function(a,b){var c=qe(this,b);if(c)return c.$b(a,function(a){return a});for(var c=this.m.$b(a.name,Tb),d=ec(c);null!=d&&0<b.compare(d,a);)J(c),d=ec(c);return c};g.Dc=function(a){return this.e()?a.e()?0:-1:a.K()||a.e()?1:a===Vd?-1:0};
g.lb=function(a){if(a===Qd||ta(this.wb.dc,a.toString()))return this;var b=this.wb,c=this.m;K(a!==Qd,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Xb(Tb),f=J(c);f;)e=e||a.Ic(f.S),d.push(f),f=J(c);d=e?je(d,td(a)):Sd;e=a.toString();c=xa(b.dc);c[e]=a;a=xa(b.Bd);a[e]=d;return new R(this.m,this.aa,new he(a,c))};g.Jc=function(a){return a===Qd||ta(this.wb.dc,a.toString())};
g.ca=function(a){if(a===this)return!0;if(a.K())return!1;if(this.C().ca(a.C())&&this.m.count()===a.m.count()){var b=this.Xb(N);a=a.Xb(N);for(var c=J(b),d=J(a);c&&d;){if(c.name!==d.name||!c.S.ca(d.S))return!1;c=J(b);d=J(a)}return null===c&&null===d}return!1};function qe(a,b){return b===Qd?null:a.wb.get(b.toString())}g.toString=function(){return B(this.I(!0))};function M(a,b){if(null===a)return C;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);K(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new tc(a,M(c));if(a instanceof Array){var d=C,e=a;r(e,function(a,b){if(v(e,b)&&"."!==b.substring(0,1)){var c=M(a);if(c.K()||!c.e())d=
d.U(b,c)}});return d.ga(M(c))}var f=[],h=!1,k=a;ib(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=M(k[a]);b.e()||(h=h||!b.C().e(),f.push(new F(a,b)))}});if(0==f.length)return C;var l=je(f,Ub,function(a){return a.name},Wb);if(h){var m=je(f,td(N));return new R(l,M(c),new he({".priority":m},{".priority":N}))}return new R(l,M(c),le)}var re=Math.log(2);
function se(a){this.count=parseInt(Math.log(a+1)/re,10);this.jf=this.count-1;this.eg=a+1&parseInt(Array(this.count+1).join("1"),2)}function te(a){var b=!(a.eg&1<<a.jf);a.jf--;return b}
function je(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var m=a[b],t=c?c(m):m;return new fc(t,m.S,!1,null,null)}var m=parseInt(f/2,10)+b,f=e(b,m),z=e(m+1,d),m=a[m],t=c?c(m):m;return new fc(t,m.S,!1,f,z)}a.sort(b);var f=function(b){function d(b,h){var k=t-b,z=t;t-=b;var z=e(k+1,z),k=a[k],I=c?c(k):k,z=new fc(I,k.S,h,null,z);f?f.left=z:m=z;f=z}for(var f=null,m=null,t=a.length,z=0;z<b.count;++z){var I=te(b),zd=Math.pow(2,b.count-(z+1));I?d(zd,!1):(d(zd,!1),d(zd,!0))}return m}(new se(a.length));
return null!==f?new ac(d||b,f):new ac(d||b)}function oe(a){return"number"===typeof a?"number:"+Xc(a):"string:"+a}function me(a){if(a.K()){var b=a.I();K("string"===typeof b||"number"===typeof b||"object"===typeof b&&v(b,".sv"),"Priority must be a string or number.")}else K(a===Vd||a.e(),"priority of unexpected type.");K(a===Vd||a.C().e(),"Priority nodes can't have a priority of their own.")}var C=new R(new ac(Wb),null,le);function ue(){R.call(this,new ac(Wb),C,le)}ma(ue,R);g=ue.prototype;
g.Dc=function(a){return a===this?0:1};g.ca=function(a){return a===this};g.C=function(){return this};g.R=function(){return C};g.e=function(){return!1};var Vd=new ue,Td=new F("[MIN_NAME]",C),Zd=new F("[MAX_NAME]",Vd);function Id(a,b){this.O=a;this.Yd=b}function Fd(a,b,c,d){return new Id(new tb(b,c,d),a.Yd)}function Jd(a){return a.O.ea?a.O.j():null}Id.prototype.w=function(){return this.Yd};function ub(a){return a.Yd.ea?a.Yd.j():null};function ve(a,b){this.W=a;var c=a.n,d=new kd(c.g),c=S(c)?new kd(c.g):c.ja?new qd(c):new ld(c);this.Hf=new xd(c);var e=b.w(),f=b.O,h=d.xa(C,e.j(),null),k=c.xa(C,f.j(),null);this.Ka=new Id(new tb(k,f.ea,c.Na()),new tb(h,e.ea,d.Na()));this.Xa=[];this.lg=new cd(a)}function we(a){return a.W}g=ve.prototype;g.w=function(){return this.Ka.w().j()};g.fb=function(a){var b=ub(this.Ka);return b&&(S(this.W.n)||!a.e()&&!b.R(E(a)).e())?b.Q(a):null};g.e=function(){return 0===this.Xa.length};g.Pb=function(a){this.Xa.push(a)};
g.jb=function(a,b){var c=[];if(b){K(null==a,"A cancel should cancel all event registrations.");var d=this.W.path;Oa(this.Xa,function(a){(a=a.gf(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Xa.length;++f){var h=this.Xa[f];if(!h.matches(a))e.push(h);else if(a.tf()){e=e.concat(this.Xa.slice(f+1));break}}this.Xa=e}else this.Xa=[];return c};
g.ab=function(a,b,c){a.type===Bd&&null!==a.source.Hb&&(K(ub(this.Ka),"We should always have a full cache before handling merges"),K(Jd(this.Ka),"Missing event cache, even though we have a server cache"));var d=this.Ka;a=this.Hf.ab(d,a,b,c);b=this.Hf;c=a.je;K(c.O.j().Jc(b.V.g),"Event snap not indexed");K(c.w().j().Jc(b.V.g),"Server snap not indexed");K(Ib(a.je.w())||!Ib(d.w()),"Once a server snap is complete, it should never go back");this.Ka=a.je;return xe(this,a.fg,a.je.O.j(),null)};
function ye(a,b){var c=a.Ka.O,d=[];c.j().K()||c.j().P(N,function(a,b){d.push(new D("child_added",b,a))});c.ea&&d.push(Eb(c.j()));return xe(a,d,c.j(),b)}function xe(a,b,c,d){return dd(a.lg,b,c,d?[d]:a.Xa)};function ze(a,b,c){this.type=Bd;this.source=a;this.path=b;this.children=c}ze.prototype.Xc=function(a){if(this.path.e())return a=this.children.subtree(new L(a)),a.e()?null:a.value?new Xb(this.source,G,a.value):new ze(this.source,G,a);K(E(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new ze(this.source,H(this.path),this.children)};ze.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};function Ae(a,b){this.f=Mc("p:rest:");this.F=a;this.Gb=b;this.Aa=null;this.$={}}function Be(a,b){if(n(b))return"tag$"+b;K(fe(a.n),"should have a tag if it's not a default query.");return a.path.toString()}g=Ae.prototype;
g.yf=function(a,b,c,d){var e=a.path.toString();this.f("Listen called for "+e+" "+a.va());var f=Be(a,c),h={};this.$[f]=h;a=ge(a.n);var k=this;Ce(this,e+".json",a,function(a,b){var t=b;404===a&&(a=t=null);null===a&&k.Gb(e,t,!1,c);w(k.$,f)===h&&d(a?401==a?"permission_denied":"rest_error:"+a:"ok",null)})};g.Rf=function(a,b){var c=Be(a,b);delete this.$[c]};g.M=function(a,b){this.Aa=a;var c=$c(a),d=c.data,c=c.Bc&&c.Bc.exp;b&&b("ok",{auth:d,expires:c})};g.ge=function(a){this.Aa=null;a("ok",null)};g.Me=function(){};
g.Cf=function(){};g.Jd=function(){};g.put=function(){};g.zf=function(){};g.Ue=function(){};
function Ce(a,b,c,d){c=c||{};c.format="export";a.Aa&&(c.auth=a.Aa);var e=(a.F.kb?"https://":"http://")+a.F.host+b+"?"+kb(c);a.f("Sending REST request for "+e);var f=new XMLHttpRequest;f.onreadystatechange=function(){if(d&&4===f.readyState){a.f("REST Response for "+e+" received. status:",f.status,"response:",f.responseText);var b=null;if(200<=f.status&&300>f.status){try{b=nb(f.responseText)}catch(c){O("Failed to parse JSON response for "+e+": "+f.responseText)}d(null,b)}else 401!==f.status&&404!==
f.status&&O("Got unsuccessful REST response for "+e+" Status: "+f.status),d(f.status);d=null}};f.open("GET",e,!0);f.send()};function De(a){K(ea(a)&&0<a.length,"Requires a non-empty array");this.Xf=a;this.Oc={}}De.prototype.fe=function(a,b){var c;c=this.Oc[a]||[];var d=c.length;if(0<d){for(var e=Array(d),f=0;f<d;f++)e[f]=c[f];c=e}else c=[];for(d=0;d<c.length;d++)c[d].zc.apply(c[d].Ma,Array.prototype.slice.call(arguments,1))};De.prototype.Eb=function(a,b,c){Ee(this,a);this.Oc[a]=this.Oc[a]||[];this.Oc[a].push({zc:b,Ma:c});(a=this.Ae(a))&&b.apply(c,a)};
De.prototype.ic=function(a,b,c){Ee(this,a);a=this.Oc[a]||[];for(var d=0;d<a.length;d++)if(a[d].zc===b&&(!c||c===a[d].Ma)){a.splice(d,1);break}};function Ee(a,b){K(Ta(a.Xf,function(a){return a===b}),"Unknown event: "+b)};var Fe=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);K(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);K(20===c.length,"nextPushId: Length should be 20.");
return c}}();function Ge(){De.call(this,["online"]);this.kc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.kc||(a.kc=!0,a.fe("online",!0))},!1);window.addEventListener("offline",function(){a.kc&&(a.kc=!1,a.fe("online",!1))},!1)}}ma(Ge,De);Ge.prototype.Ae=function(a){K("online"===a,"Unknown event type: "+a);return[this.kc]};ca(Ge);function He(){De.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.Ob=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.Ob&&(c.Ob=b,c.fe("visible",b))},!1)}}ma(He,De);He.prototype.Ae=function(a){K("visible"===a,"Unknown event type: "+a);return[this.Ob]};ca(He);function L(a,b){if(1==arguments.length){this.o=a.split("/");for(var c=0,d=0;d<this.o.length;d++)0<this.o[d].length&&(this.o[c]=this.o[d],c++);this.o.length=c;this.Z=0}else this.o=a,this.Z=b}function T(a,b){var c=E(a);if(null===c)return b;if(c===E(b))return T(H(a),H(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
function Ie(a,b){for(var c=a.slice(),d=b.slice(),e=0;e<c.length&&e<d.length;e++){var f=Vb(c[e],d[e]);if(0!==f)return f}return c.length===d.length?0:c.length<d.length?-1:1}function E(a){return a.Z>=a.o.length?null:a.o[a.Z]}function Kd(a){return a.o.length-a.Z}function H(a){var b=a.Z;b<a.o.length&&b++;return new L(a.o,b)}function Ld(a){return a.Z<a.o.length?a.o[a.o.length-1]:null}g=L.prototype;
g.toString=function(){for(var a="",b=this.Z;b<this.o.length;b++)""!==this.o[b]&&(a+="/"+this.o[b]);return a||"/"};g.slice=function(a){return this.o.slice(this.Z+(a||0))};g.parent=function(){if(this.Z>=this.o.length)return null;for(var a=[],b=this.Z;b<this.o.length-1;b++)a.push(this.o[b]);return new L(a,0)};
g.u=function(a){for(var b=[],c=this.Z;c<this.o.length;c++)b.push(this.o[c]);if(a instanceof L)for(c=a.Z;c<a.o.length;c++)b.push(a.o[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new L(b,0)};g.e=function(){return this.Z>=this.o.length};g.ca=function(a){if(Kd(this)!==Kd(a))return!1;for(var b=this.Z,c=a.Z;b<=this.o.length;b++,c++)if(this.o[b]!==a.o[c])return!1;return!0};
g.contains=function(a){var b=this.Z,c=a.Z;if(Kd(this)>Kd(a))return!1;for(;b<this.o.length;){if(this.o[b]!==a.o[c])return!1;++b;++c}return!0};var G=new L("");function Je(a,b){this.Qa=a.slice();this.Ha=Math.max(1,this.Qa.length);this.lf=b;for(var c=0;c<this.Qa.length;c++)this.Ha+=Zc(this.Qa[c]);Ke(this)}Je.prototype.push=function(a){0<this.Qa.length&&(this.Ha+=1);this.Qa.push(a);this.Ha+=Zc(a);Ke(this)};Je.prototype.pop=function(){var a=this.Qa.pop();this.Ha-=Zc(a);0<this.Qa.length&&--this.Ha};
function Ke(a){if(768<a.Ha)throw Error(a.lf+"has a key path longer than 768 bytes ("+a.Ha+").");if(32<a.Qa.length)throw Error(a.lf+"path specified exceeds the maximum depth that can be written (32) or object contains a cycle "+Le(a));}function Le(a){return 0==a.Qa.length?"":"in property '"+a.Qa.join(".")+"'"};function Me(a,b){this.value=a;this.children=b||Ne}var Ne=new ac(function(a,b){return a===b?0:a<b?-1:1});function Oe(a){var b=Pd;r(a,function(a,d){b=b.set(new L(d),a)});return b}g=Me.prototype;g.e=function(){return null===this.value&&this.children.e()};function Pe(a,b,c){if(null!=a.value&&c(a.value))return{path:G,value:a.value};if(b.e())return null;var d=E(b);a=a.children.get(d);return null!==a?(b=Pe(a,H(b),c),null!=b?{path:(new L(d)).u(b.path),value:b.value}:null):null}
function Qe(a,b){return Pe(a,b,function(){return!0})}g.subtree=function(a){if(a.e())return this;var b=this.children.get(E(a));return null!==b?b.subtree(H(a)):Pd};g.set=function(a,b){if(a.e())return new Me(b,this.children);var c=E(a),d=(this.children.get(c)||Pd).set(H(a),b),c=this.children.Oa(c,d);return new Me(this.value,c)};
g.remove=function(a){if(a.e())return this.children.e()?Pd:new Me(null,this.children);var b=E(a),c=this.children.get(b);return c?(a=c.remove(H(a)),b=a.e()?this.children.remove(b):this.children.Oa(b,a),null===this.value&&b.e()?Pd:new Me(this.value,b)):this};g.get=function(a){if(a.e())return this.value;var b=this.children.get(E(a));return b?b.get(H(a)):null};
function Od(a,b,c){if(b.e())return c;var d=E(b);b=Od(a.children.get(d)||Pd,H(b),c);d=b.e()?a.children.remove(d):a.children.Oa(d,b);return new Me(a.value,d)}function Re(a,b){return Se(a,G,b)}function Se(a,b,c){var d={};a.children.ia(function(a,f){d[a]=Se(f,b.u(a),c)});return c(b,a.value,d)}function Te(a,b,c){return Ue(a,b,G,c)}function Ue(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=E(b);return(a=a.children.get(e))?Ue(a,H(b),c.u(e),d):null}
function Ve(a,b,c){var d=G;if(!b.e()){var e=!0;a.value&&(e=c(d,a.value));!0===e&&(e=E(b),(a=a.children.get(e))&&We(a,H(b),d.u(e),c))}}function We(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=E(b);return(a=a.children.get(e))?We(a,H(b),c.u(e),d):Pd}function Md(a,b){Xe(a,G,b)}function Xe(a,b,c){a.children.ia(function(a,e){Xe(e,b.u(a),c)});a.value&&c(b,a.value)}function Ye(a,b){a.children.ia(function(a,d){d.value&&b(a,d.value)})}var Pd=new Me(null);
Me.prototype.toString=function(){var a={};Md(this,function(b,c){a[b.toString()]=c.toString()});return B(a)};function Ze(a,b,c){this.type=Ed;this.source=$e;this.path=a;this.Qb=b;this.Vd=c}Ze.prototype.Xc=function(a){if(this.path.e()){if(null!=this.Qb.value)return K(this.Qb.children.e(),"affectedTree should not have overlapping affected paths."),this;a=this.Qb.subtree(new L(a));return new Ze(G,a,this.Vd)}K(E(this.path)===a,"operationForChild called for unrelated child.");return new Ze(H(this.path),this.Qb,this.Vd)};
Ze.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Vd+" affectedTree="+this.Qb+")"};var Yb=0,Bd=1,Ed=2,$b=3;function af(a,b,c,d){this.we=a;this.pf=b;this.Hb=c;this.af=d;K(!d||b,"Tagged queries must be from server.")}var $e=new af(!0,!1,null,!1),bf=new af(!1,!0,null,!1);af.prototype.toString=function(){return this.we?"user":this.af?"server(queryID="+this.Hb+")":"server"};function cf(a){this.X=a}var df=new cf(new Me(null));function ef(a,b,c){if(b.e())return new cf(new Me(c));var d=Qe(a.X,b);if(null!=d){var e=d.path,d=d.value;b=T(e,b);d=d.G(b,c);return new cf(a.X.set(e,d))}a=Od(a.X,b,new Me(c));return new cf(a)}function ff(a,b,c){var d=a;ib(c,function(a,c){d=ef(d,b.u(a),c)});return d}cf.prototype.Rd=function(a){if(a.e())return df;a=Od(this.X,a,Pd);return new cf(a)};function gf(a,b){var c=Qe(a.X,b);return null!=c?a.X.get(c.path).Q(T(c.path,b)):null}
function hf(a){var b=[],c=a.X.value;null!=c?c.K()||c.P(N,function(a,c){b.push(new F(a,c))}):a.X.children.ia(function(a,c){null!=c.value&&b.push(new F(a,c.value))});return b}function jf(a,b){if(b.e())return a;var c=gf(a,b);return null!=c?new cf(new Me(c)):new cf(a.X.subtree(b))}cf.prototype.e=function(){return this.X.e()};cf.prototype.apply=function(a){return kf(G,this.X,a)};
function kf(a,b,c){if(null!=b.value)return c.G(a,b.value);var d=null;b.children.ia(function(b,f){".priority"===b?(K(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=kf(a.u(b),f,c)});c.Q(a).e()||null===d||(c=c.G(a.u(".priority"),d));return c};function lf(){this.T=df;this.na=[];this.Mc=-1}function mf(a,b){for(var c=0;c<a.na.length;c++){var d=a.na[c];if(d.kd===b)return d}return null}g=lf.prototype;
g.Rd=function(a){var b=Ua(this.na,function(b){return b.kd===a});K(0<=b,"removeWrite called with nonexistent writeId.");var c=this.na[b];this.na.splice(b,1);for(var d=c.visible,e=!1,f=this.na.length-1;d&&0<=f;){var h=this.na[f];h.visible&&(f>=b&&nf(h,c.path)?d=!1:c.path.contains(h.path)&&(e=!0));f--}if(d){if(e)this.T=of(this.na,pf,G),this.Mc=0<this.na.length?this.na[this.na.length-1].kd:-1;else if(c.Ga)this.T=this.T.Rd(c.path);else{var k=this;r(c.children,function(a,b){k.T=k.T.Rd(c.path.u(b))})}return!0}return!1};
g.za=function(a,b,c,d){if(c||d){var e=jf(this.T,a);return!d&&e.e()?b:d||null!=b||null!=gf(e,G)?(e=of(this.na,function(b){return(b.visible||d)&&(!c||!(0<=Na(c,b.kd)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||C,e.apply(b)):null}e=gf(this.T,a);if(null!=e)return e;e=jf(this.T,a);return e.e()?b:null!=b||null!=gf(e,G)?(b=b||C,e.apply(b)):null};
g.yc=function(a,b){var c=C,d=gf(this.T,a);if(d)d.K()||d.P(N,function(a,b){c=c.U(a,b)});else if(b){var e=jf(this.T,a);b.P(N,function(a,b){var d=jf(e,new L(a)).apply(b);c=c.U(a,d)});Oa(hf(e),function(a){c=c.U(a.name,a.S)})}else e=jf(this.T,a),Oa(hf(e),function(a){c=c.U(a.name,a.S)});return c};g.ld=function(a,b,c,d){K(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.u(b);if(null!=gf(this.T,a))return null;a=jf(this.T,a);return a.e()?d.Q(b):a.apply(d.Q(b))};
g.xc=function(a,b,c){a=a.u(b);var d=gf(this.T,a);return null!=d?d:sb(c,b)?jf(this.T,a).apply(c.j().R(b)):null};g.tc=function(a){return gf(this.T,a)};g.ne=function(a,b,c,d,e,f){var h;a=jf(this.T,a);h=gf(a,G);if(null==h)if(null!=b)h=a.apply(b);else return[];h=h.lb(f);if(h.e()||h.K())return[];b=[];a=td(f);e=e?h.$b(c,f):h.Yb(c,f);for(f=J(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=J(e);return b};
function nf(a,b){return a.Ga?a.path.contains(b):!!ua(a.children,function(c,d){return a.path.u(d).contains(b)})}function pf(a){return a.visible}
function of(a,b,c){for(var d=df,e=0;e<a.length;++e){var f=a[e];if(b(f)){var h=f.path;if(f.Ga)c.contains(h)?(h=T(c,h),d=ef(d,h,f.Ga)):h.contains(c)&&(h=T(h,c),d=ef(d,G,f.Ga.Q(h)));else if(f.children)if(c.contains(h))h=T(c,h),d=ff(d,h,f.children);else{if(h.contains(c))if(h=T(h,c),h.e())d=ff(d,G,f.children);else if(f=w(f.children,E(h)))f=f.Q(H(h)),d=ef(d,G,f)}else throw Fc("WriteRecord should have .snap or .children");}}return d}function qf(a,b){this.Mb=a;this.X=b}g=qf.prototype;
g.za=function(a,b,c){return this.X.za(this.Mb,a,b,c)};g.yc=function(a){return this.X.yc(this.Mb,a)};g.ld=function(a,b,c){return this.X.ld(this.Mb,a,b,c)};g.tc=function(a){return this.X.tc(this.Mb.u(a))};g.ne=function(a,b,c,d,e){return this.X.ne(this.Mb,a,b,c,d,e)};g.xc=function(a,b){return this.X.xc(this.Mb,a,b)};g.u=function(a){return new qf(this.Mb.u(a),this.X)};function rf(){this.ya={}}g=rf.prototype;g.e=function(){return wa(this.ya)};g.ab=function(a,b,c){var d=a.source.Hb;if(null!==d)return d=w(this.ya,d),K(null!=d,"SyncTree gave us an op for an invalid query."),d.ab(a,b,c);var e=[];r(this.ya,function(d){e=e.concat(d.ab(a,b,c))});return e};g.Pb=function(a,b,c,d,e){var f=a.va(),h=w(this.ya,f);if(!h){var h=c.za(e?d:null),k=!1;h?k=!0:(h=d instanceof R?c.yc(d):C,k=!1);h=new ve(a,new Id(new tb(h,k,!1),new tb(d,e,!1)));this.ya[f]=h}h.Pb(b);return ye(h,b)};
g.jb=function(a,b,c){var d=a.va(),e=[],f=[],h=null!=sf(this);if("default"===d){var k=this;r(this.ya,function(a,d){f=f.concat(a.jb(b,c));a.e()&&(delete k.ya[d],S(a.W.n)||e.push(a.W))})}else{var l=w(this.ya,d);l&&(f=f.concat(l.jb(b,c)),l.e()&&(delete this.ya[d],S(l.W.n)||e.push(l.W)))}h&&null==sf(this)&&e.push(new U(a.k,a.path));return{Kg:e,mg:f}};function tf(a){return Pa(ra(a.ya),function(a){return!S(a.W.n)})}g.fb=function(a){var b=null;r(this.ya,function(c){b=b||c.fb(a)});return b};
function uf(a,b){if(S(b.n))return sf(a);var c=b.va();return w(a.ya,c)}function sf(a){return va(a.ya,function(a){return S(a.W.n)})||null};function vf(a){this.ta=Pd;this.ib=new lf;this.$e={};this.mc={};this.Nc=a}function wf(a,b,c,d,e){var f=a.ib,h=e;K(d>f.Mc,"Stacking an older write on top of newer ones");n(h)||(h=!0);f.na.push({path:b,Ga:c,kd:d,visible:h});h&&(f.T=ef(f.T,b,c));f.Mc=d;return e?xf(a,new Xb($e,b,c)):[]}function yf(a,b,c,d){var e=a.ib;K(d>e.Mc,"Stacking an older merge on top of newer ones");e.na.push({path:b,children:c,kd:d,visible:!0});e.T=ff(e.T,b,c);e.Mc=d;c=Oe(c);return xf(a,new ze($e,b,c))}
function zf(a,b,c){c=c||!1;var d=mf(a.ib,b);if(a.ib.Rd(b)){var e=Pd;null!=d.Ga?e=e.set(G,!0):ib(d.children,function(a,b){e=e.set(new L(a),b)});return xf(a,new Ze(d.path,e,c))}return[]}function Af(a,b,c){c=Oe(c);return xf(a,new ze(bf,b,c))}function Bf(a,b,c,d){d=Cf(a,d);if(null!=d){var e=Df(d);d=e.path;e=e.Hb;b=T(d,b);c=new Xb(new af(!1,!0,e,!0),b,c);return Ef(a,d,c)}return[]}
function Ff(a,b,c,d){if(d=Cf(a,d)){var e=Df(d);d=e.path;e=e.Hb;b=T(d,b);c=Oe(c);c=new ze(new af(!1,!0,e,!0),b,c);return Ef(a,d,c)}return[]}
vf.prototype.Pb=function(a,b){var c=a.path,d=null,e=!1;Ve(this.ta,c,function(a,b){var f=T(a,c);d=b.fb(f);e=e||null!=sf(b);return!d});var f=this.ta.get(c);f?(e=e||null!=sf(f),d=d||f.fb(G)):(f=new rf,this.ta=this.ta.set(c,f));var h;null!=d?h=!0:(h=!1,d=C,Ye(this.ta.subtree(c),function(a,b){var c=b.fb(G);c&&(d=d.U(a,c))}));var k=null!=uf(f,a);if(!k&&!S(a.n)){var l=Gf(a);K(!(l in this.mc),"View does not exist, but we have a tag");var m=Hf++;this.mc[l]=m;this.$e["_"+m]=l}h=f.Pb(a,b,new qf(c,this.ib),d,
h);k||e||(f=uf(f,a),h=h.concat(If(this,a,f)));return h};
vf.prototype.jb=function(a,b,c){var d=a.path,e=this.ta.get(d),f=[];if(e&&("default"===a.va()||null!=uf(e,a))){f=e.jb(a,b,c);e.e()&&(this.ta=this.ta.remove(d));e=f.Kg;f=f.mg;b=-1!==Ua(e,function(a){return S(a.n)});var h=Te(this.ta,d,function(a,b){return null!=sf(b)});if(b&&!h&&(d=this.ta.subtree(d),!d.e()))for(var d=Jf(d),k=0;k<d.length;++k){var l=d[k],m=l.W,l=Kf(this,l);this.Nc.Xe(Lf(m),Mf(this,m),l.xd,l.H)}if(!h&&0<e.length&&!c)if(b)this.Nc.ae(Lf(a),null);else{var t=this;Oa(e,function(a){a.va();
var b=t.mc[Gf(a)];t.Nc.ae(Lf(a),b)})}Nf(this,e)}return f};vf.prototype.za=function(a,b){var c=this.ib,d=Te(this.ta,a,function(b,c){var d=T(b,a);if(d=c.fb(d))return d});return c.za(a,d,b,!0)};function Jf(a){return Re(a,function(a,c,d){if(c&&null!=sf(c))return[sf(c)];var e=[];c&&(e=tf(c));r(d,function(a){e=e.concat(a)});return e})}function Nf(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!S(d.n)){var d=Gf(d),e=a.mc[d];delete a.mc[d];delete a.$e["_"+e]}}}
function Lf(a){return S(a.n)&&!fe(a.n)?a.Ib():a}function If(a,b,c){var d=b.path,e=Mf(a,b);c=Kf(a,c);b=a.Nc.Xe(Lf(b),e,c.xd,c.H);d=a.ta.subtree(d);if(e)K(null==sf(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=Re(d,function(a,b,c){if(!a.e()&&b&&null!=sf(b))return[we(sf(b))];var d=[];b&&(d=d.concat(Qa(tf(b),function(a){return a.W})));r(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Nc.ae(Lf(c),Mf(a,c));return b}
function Kf(a,b){var c=b.W,d=Mf(a,c);return{xd:function(){return(b.w()||C).hash()},H:function(b){if("ok"===b){if(d){var f=c.path;if(b=Cf(a,d)){var h=Df(b);b=h.path;h=h.Hb;f=T(b,f);f=new Zb(new af(!1,!0,h,!0),f);b=Ef(a,b,f)}else b=[]}else b=xf(a,new Zb(bf,c.path));return b}f="Unknown Error";"too_big"===b?f="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?f="Client doesn't have permission to access the desired data.":"unavailable"==b&&
(f="The service is unavailable");f=Error(b+": "+f);f.code=b.toUpperCase();return a.jb(c,null,f)}}}function Gf(a){return a.path.toString()+"$"+a.va()}function Df(a){var b=a.indexOf("$");K(-1!==b&&b<a.length-1,"Bad queryKey.");return{Hb:a.substr(b+1),path:new L(a.substr(0,b))}}function Cf(a,b){var c=a.$e,d="_"+b;return d in c?c[d]:void 0}function Mf(a,b){var c=Gf(b);return w(a.mc,c)}var Hf=1;
function Ef(a,b,c){var d=a.ta.get(b);K(d,"Missing sync point for query tag that we're tracking");return d.ab(c,new qf(b,a.ib),null)}function xf(a,b){return Of(a,b,a.ta,null,new qf(G,a.ib))}function Of(a,b,c,d,e){if(b.path.e())return Pf(a,b,c,d,e);var f=c.get(G);null==d&&null!=f&&(d=f.fb(G));var h=[],k=E(b.path),l=b.Xc(k);if((c=c.children.get(k))&&l)var m=d?d.R(k):null,k=e.u(k),h=h.concat(Of(a,l,c,m,k));f&&(h=h.concat(f.ab(b,e,d)));return h}
function Pf(a,b,c,d,e){var f=c.get(G);null==d&&null!=f&&(d=f.fb(G));var h=[];c.children.ia(function(c,f){var m=d?d.R(c):null,t=e.u(c),z=b.Xc(c);z&&(h=h.concat(Pf(a,z,f,m,t)))});f&&(h=h.concat(f.ab(b,e,d)));return h};function Qf(){this.children={};this.nd=0;this.value=null}function Rf(a,b,c){this.Gd=a?a:"";this.Zc=b?b:null;this.A=c?c:new Qf}function Sf(a,b){for(var c=b instanceof L?b:new L(b),d=a,e;null!==(e=E(c));)d=new Rf(e,d,w(d.A.children,e)||new Qf),c=H(c);return d}g=Rf.prototype;g.Ca=function(){return this.A.value};function Tf(a,b){K("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Uf(a)}g.clear=function(){this.A.value=null;this.A.children={};this.A.nd=0;Uf(this)};
g.wd=function(){return 0<this.A.nd};g.e=function(){return null===this.Ca()&&!this.wd()};g.P=function(a){var b=this;r(this.A.children,function(c,d){a(new Rf(d,b,c))})};function Vf(a,b,c,d){c&&!d&&b(a);a.P(function(a){Vf(a,b,!0,d)});c&&d&&b(a)}function Wf(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}g.path=function(){return new L(null===this.Zc?this.Gd:this.Zc.path()+"/"+this.Gd)};g.name=function(){return this.Gd};g.parent=function(){return this.Zc};
function Uf(a){if(null!==a.Zc){var b=a.Zc,c=a.Gd,d=a.e(),e=v(b.A.children,c);d&&e?(delete b.A.children[c],b.A.nd--,Uf(b)):d||e||(b.A.children[c]=a.A,b.A.nd++,Uf(b))}};var Xf=/[\[\].#$\/\u0000-\u001F\u007F]/,Yf=/[\[\].#$\u0000-\u001F\u007F]/,Zf=/^[a-zA-Z][a-zA-Z._\-+]+$/;function $f(a){return p(a)&&0!==a.length&&!Xf.test(a)}function ag(a){return null===a||p(a)||ga(a)&&!Qc(a)||ia(a)&&v(a,".sv")}function bg(a,b,c,d){d&&!n(b)||cg(y(a,1,d),b,c)}
function cg(a,b,c){c instanceof L&&(c=new Je(c,a));if(!n(b))throw Error(a+"contains undefined "+Le(c));if(ha(b))throw Error(a+"contains a function "+Le(c)+" with contents: "+b.toString());if(Qc(b))throw Error(a+"contains "+b.toString()+" "+Le(c));if(p(b)&&b.length>10485760/3&&10485760<Zc(b))throw Error(a+"contains a string greater than 10485760 utf8 bytes "+Le(c)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var d=!1,e=!1;ib(b,function(b,h){if(".value"===b)d=!0;else if(".priority"!==b&&".sv"!==b&&(e=
!0,!$f(b)))throw Error(a+" contains an invalid key ("+b+") "+Le(c)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');c.push(b);cg(a,h,c);c.pop()});if(d&&e)throw Error(a+' contains ".value" child '+Le(c)+" in addition to actual children.");}}
function dg(a,b){var c,d;for(c=0;c<b.length;c++){d=b[c];for(var e=d.slice(),f=0;f<e.length;f++)if((".priority"!==e[f]||f!==e.length-1)&&!$f(e[f]))throw Error(a+"contains an invalid key ("+e[f]+") in path "+d.toString()+'. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');}b.sort(Ie);e=null;for(c=0;c<b.length;c++){d=b[c];if(null!==e&&e.contains(d))throw Error(a+"contains a path "+e.toString()+" that is ancestor of another path "+d.toString());e=d}}
function eg(a,b,c){var d=y(a,1,!1);if(!ia(b)||ea(b))throw Error(d+" must be an object containing the children to replace.");var e=[];ib(b,function(a,b){var k=new L(a);cg(d,b,c.u(k));if(".priority"===Ld(k)&&!ag(b))throw Error(d+"contains an invalid value for '"+k.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");e.push(k)});dg(d,e)}
function fg(a,b,c){if(Qc(c))throw Error(y(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!ag(c))throw Error(y(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function gg(a,b,c){if(!c||n(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(y(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function hg(a,b){if(n(b)&&!$f(b))throw Error(y(a,2,!0)+'was an invalid key: "'+b+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function ig(a,b){if(!p(b)||0===b.length||Yf.test(b))throw Error(y(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function jg(a,b){if(".info"===E(b))throw Error(a+" failed: Can't modify data under /.info/");}function kg(a,b){if(!p(b))throw Error(y(a,1,!1)+"must be a valid credential (a string).");}function lg(a,b,c){if(!p(c))throw Error(y(a,b,!1)+"must be a valid string.");}
function mg(a,b){lg(a,1,b);if(!Zf.test(b))throw Error(y(a,1,!1)+"'"+b+"' is not a valid authentication provider.");}function ng(a,b,c,d){if(!d||n(c))if(!ia(c)||null===c)throw Error(y(a,b,d)+"must be a valid object.");}function og(a,b,c){if(!ia(b)||!v(b,c))throw Error(y(a,1,!1)+'must contain the key "'+c+'"');if(!p(w(b,c)))throw Error(y(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function pg(){this.set={}}g=pg.prototype;g.add=function(a,b){this.set[a]=null!==b?b:!0};g.contains=function(a){return v(this.set,a)};g.get=function(a){return this.contains(a)?this.set[a]:void 0};g.remove=function(a){delete this.set[a]};g.clear=function(){this.set={}};g.e=function(){return wa(this.set)};g.count=function(){return pa(this.set)};function qg(a,b){r(a.set,function(a,d){b(d,a)})}g.keys=function(){var a=[];r(this.set,function(b,c){a.push(c)});return a};function qc(){this.m=this.B=null}qc.prototype.find=function(a){if(null!=this.B)return this.B.Q(a);if(a.e()||null==this.m)return null;var b=E(a);a=H(a);return this.m.contains(b)?this.m.get(b).find(a):null};qc.prototype.nc=function(a,b){if(a.e())this.B=b,this.m=null;else if(null!==this.B)this.B=this.B.G(a,b);else{null==this.m&&(this.m=new pg);var c=E(a);this.m.contains(c)||this.m.add(c,new qc);c=this.m.get(c);a=H(a);c.nc(a,b)}};
function rg(a,b){if(b.e())return a.B=null,a.m=null,!0;if(null!==a.B){if(a.B.K())return!1;var c=a.B;a.B=null;c.P(N,function(b,c){a.nc(new L(b),c)});return rg(a,b)}return null!==a.m?(c=E(b),b=H(b),a.m.contains(c)&&rg(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function rc(a,b,c){null!==a.B?c(b,a.B):a.P(function(a,e){var f=new L(b.toString()+"/"+a);rc(e,f,c)})}qc.prototype.P=function(a){null!==this.m&&qg(this.m,function(b,c){a(b,c)})};var sg="auth.firebase.com";function tg(a,b,c){this.od=a||{};this.ee=b||{};this.$a=c||{};this.od.remember||(this.od.remember="default")}var ug=["remember","redirectTo"];function vg(a){var b={},c={};ib(a||{},function(a,e){0<=Na(ug,a)?b[a]=e:c[a]=e});return new tg(b,{},c)};function wg(a,b){this.Qe=["session",a.Od,a.hc].join(":");this.be=b}wg.prototype.set=function(a,b){if(!b)if(this.be.length)b=this.be[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Qe,a)};wg.prototype.get=function(){var a=Qa(this.be,q(this.qg,this)),a=Pa(a,function(a){return null!==a});Xa(a,function(a,c){return ad(c.token)-ad(a.token)});return 0<a.length?a.shift():null};wg.prototype.qg=function(a){try{var b=a.get(this.Qe);if(b&&b.token)return b}catch(c){}return null};
wg.prototype.clear=function(){var a=this;Oa(this.be,function(b){b.remove(a.Qe)})};function xg(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function yg(){return"undefined"!==typeof window&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(xg())}function zg(){return"undefined"!==typeof location&&/^file:\//.test(location.href)}
function Ag(a){var b=xg();if(""===b)return!1;if("Microsoft Internet Explorer"===navigator.appName){if((b=b.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a}else if(-1<b.indexOf("Trident")&&(b=b.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a;return!1};function Bg(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function Cg(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function Dg(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function Eg(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function Fg(a){var b="";try{a=a.replace("#","");var c=lb(a);c&&v(c,"__firebase_request_key")&&(b=w(c,"__firebase_request_key"))}catch(d){}return b}function Gg(){var a=Pc(sg);return a.scheme+"://"+a.host+"/v2"}function Hg(a){return Gg()+"/"+a+"/auth/channel"};function Ig(a){var b=this;this.Ac=a;this.ce="*";Ag(8)?this.Rc=this.zd=Bg():(this.Rc=window.opener,this.zd=window);if(!b.Rc)throw"Unable to find relay frame";Cg(this.zd,"message",q(this.jc,this));Cg(this.zd,"message",q(this.Bf,this));try{Jg(this,{a:"ready"})}catch(c){Cg(this.Rc,"load",function(){Jg(b,{a:"ready"})})}Cg(window,"unload",q(this.Bg,this))}function Jg(a,b){b=B(b);Ag(8)?a.Rc.doPost(b,a.ce):a.Rc.postMessage(b,a.ce)}
Ig.prototype.jc=function(a){var b=this,c;try{c=nb(a.data)}catch(d){}c&&"request"===c.a&&(Dg(window,"message",this.jc),this.ce=a.origin,this.Ac&&setTimeout(function(){b.Ac(b.ce,c.d,function(a,c){b.dg=!c;b.Ac=void 0;Jg(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Ig.prototype.Bg=function(){try{Dg(this.zd,"message",this.Bf)}catch(a){}this.Ac&&(Jg(this,{a:"error",d:"unknown closed window"}),this.Ac=void 0);try{window.close()}catch(b){}};Ig.prototype.Bf=function(a){if(this.dg&&"die"===a.data)try{window.close()}catch(b){}};function Kg(a){this.pc=Ga()+Ga()+Ga();this.Ef=a}Kg.prototype.open=function(a,b){yc.set("redirect_request_id",this.pc);yc.set("redirect_request_id",this.pc);b.requestId=this.pc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+kb(b);window.location=a};Kg.isAvailable=function(){return!zg()&&!yg()};Kg.prototype.Cc=function(){return"redirect"};var Lg={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function Mg(a){var b=Error(w(Lg,a),a);b.code=a;return b};function Ng(a){var b;(b=!a.window_features)||(b=xg(),b=-1!==b.indexOf("Fennec/")||-1!==b.indexOf("Firefox/")&&-1!==b.indexOf("Android"));b&&(a.window_features=void 0);a.window_name||(a.window_name="_blank");this.options=a}
Ng.prototype.open=function(a,b,c){function d(a){h&&(document.body.removeChild(h),h=void 0);t&&(t=clearInterval(t));Dg(window,"message",e);Dg(window,"unload",d);if(m&&!a)try{m.close()}catch(b){k.postMessage("die",l)}m=k=void 0}function e(a){if(a.origin===l)try{var b=nb(a.data);"ready"===b.a?k.postMessage(z,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=Ag(8),h,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=Eg(a);if(l!==Eg(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(h=document.createElement("iframe"),h.setAttribute("src",this.options.relay_url),h.style.display="none",h.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(h),k=h.contentWindow);a+=(/\?/.test(a)?"":"?")+kb(b);var m=window.open(a,this.options.window_name,this.options.window_features);k||(k=m);var t=setInterval(function(){m&&m.closed&&
(d(!1),c&&(c(Mg("USER_CANCELLED")),c=null))},500),z=B({a:"request",d:b});Cg(window,"unload",d);Cg(window,"message",e)}};
Ng.isAvailable=function(){var a;if(a="postMessage"in window&&!zg())(a=yg()||"undefined"!==typeof navigator&&(!!xg().match(/Windows Phone/)||!!window.Windows&&/^ms-appx:/.test(location.href)))||(a=xg(),a="undefined"!==typeof navigator&&"undefined"!==typeof window&&!!(a.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||a.match(/CriOS/)||a.match(/Twitter for iPhone/)||a.match(/FBAN\/FBIOS/)||window.navigator.standalone)),a=!a;return a&&!xg().match(/PhantomJS/)};Ng.prototype.Cc=function(){return"popup"};function Og(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
Og.prototype.open=function(a,b,c){function d(){c&&(c(Mg("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),h;Cg(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=nb(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(Mg("SERVER_ERROR")):c(Mg("NETWORK_ERROR"));c=null;Dg(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+kb(b),h=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(h=B(b));"application/x-www-form-urlencoded"===k&&(h=kb(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};za(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(h)};Og.isAvailable=function(){var a;if(a=!!window.XMLHttpRequest)a=xg(),a=!(a.match(/MSIE/)||a.match(/Trident/))||Ag(10);return a};Og.prototype.Cc=function(){return"json"};function Pg(a){this.pc=Ga()+Ga()+Ga();this.Ef=a}
Pg.prototype.open=function(a,b,c){function d(){c&&(c(Mg("USER_CANCELLED")),c=null)}var e=this,f=Pc(sg),h;b.requestId=this.pc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=kb(b);(h=window.open(a,"_blank","location=no"))&&ha(h.addEventListener)?(h.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{try{var m=document.createElement("a");m.href=a.url;b=m.host===f.host&&"/blank/page.html"===m.pathname;break a}catch(t){}b=!1}b&&(a=Fg(a.url),h.removeEventListener("exit",
d),h.close(),a=new tg(null,null,{requestId:e.pc,requestKey:a}),e.Ef.requestWithCredential("/auth/session",a,c),c=null)}),h.addEventListener("exit",d)):c(Mg("TRANSPORT_UNAVAILABLE"))};Pg.isAvailable=function(){return yg()};Pg.prototype.Cc=function(){return"redirect"};function Qg(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Qg.prototype.open=function(a,b,c){function d(){c&&(c(Mg("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;wa(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);Dg(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+kb(b);
Cg(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Rg(f,a,c)};
function Rg(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(Mg("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(Mg("NETWORK_ERROR"))}},0)}Qg.isAvailable=function(){return"undefined"!==typeof document&&null!=document.createElement};
Qg.prototype.Cc=function(){return"json"};function Sg(a,b,c,d){De.call(this,["auth_status"]);this.F=a;this.df=b;this.Vg=c;this.Le=d;this.sc=new wg(a,[xc,yc]);this.mb=null;this.Se=!1;Tg(this)}ma(Sg,De);g=Sg.prototype;g.xe=function(){return this.mb||null};function Tg(a){yc.get("redirect_request_id")&&Ug(a);var b=a.sc.get();b&&b.token?(Vg(a,b),a.df(b.token,function(c,d){Wg(a,c,d,!1,b.token,b)},function(b,d){Xg(a,"resumeSession()",b,d)})):Vg(a,null)}
function Yg(a,b,c,d,e,f){"firebaseio-demo.com"===a.F.domain&&O("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.df(b,function(f,k){Wg(a,f,k,!0,b,c,d||{},e)},function(b,c){Xg(a,"auth()",b,c,f)})}function Zg(a,b){a.sc.clear();Vg(a,null);a.Vg(function(a,d){if("ok"===a)P(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;P(b,f)}})}
function Wg(a,b,c,d,e,f,h,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=bd(e)?e:"",c=null,b&&v(b,"uid")?c=w(b,"uid"):v(f,"uid")&&(c=w(f,"uid")),f.uid=c,c="custom",b&&v(b,"provider")?c=w(b,"provider"):v(f,"provider")&&(c=w(f,"provider")),f.provider=c,a.sc.clear(),bd(e)&&(h=h||{},c=xc,"sessionOnly"===h.remember&&(c=yc),"none"!==h.remember&&a.sc.set(f,c)),Vg(a,f)),P(k,null,f)):(a.sc.clear(),Vg(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,P(k,f))}
function Xg(a,b,c,d,e){O(b+" was canceled: "+d);a.sc.clear();Vg(a,null);a=Error(d);a.code=c.toUpperCase();P(e,a)}function $g(a,b,c,d,e){ah(a);c=new tg(d||{},{},c||{});bh(a,[Og,Qg],"/auth/"+b,c,e)}
function ch(a,b,c,d){ah(a);var e=[Ng,Pg];c=vg(c);"anonymous"===b||"password"===b?setTimeout(function(){P(d,Mg("TRANSPORT_UNAVAILABLE"))},0):(c.ee.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.ee.relay_url=Hg(a.F.hc),c.ee.requestWithCredential=q(a.qc,a),bh(a,e,"/auth/"+b,c,d))}
function Ug(a){var b=yc.get("redirect_request_id");if(b){var c=yc.get("redirect_client_options");yc.remove("redirect_request_id");yc.remove("redirect_client_options");var d=[Og,Qg],b={requestId:b,requestKey:Fg(document.location.hash)},c=new tg(c,{},b);a.Se=!0;try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}bh(a,d,"/auth/session",c,function(){this.Se=!1}.bind(a))}}
g.se=function(a,b){ah(this);var c=vg(a);c.$a._method="POST";this.qc("/users",c,function(a,c){a?P(b,a):P(b,a,c)})};g.Te=function(a,b){var c=this;ah(this);var d="/users/"+encodeURIComponent(a.email),e=vg(a);e.$a._method="DELETE";this.qc(d,e,function(a,d){!a&&d&&d.uid&&c.mb&&c.mb.uid&&c.mb.uid===d.uid&&Zg(c);P(b,a)})};g.pe=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=vg(a);d.$a._method="PUT";d.$a.password=a.newPassword;this.qc(c,d,function(a){P(b,a)})};
g.oe=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=vg(a);d.$a._method="PUT";d.$a.email=a.newEmail;d.$a.password=a.password;this.qc(c,d,function(a){P(b,a)})};g.Ve=function(a,b){ah(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=vg(a);d.$a._method="POST";this.qc(c,d,function(a){P(b,a)})};g.qc=function(a,b,c){dh(this,[Og,Qg],a,b,c)};
function bh(a,b,c,d,e){dh(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Yg(a,c.token,c,d.od,function(a,b){a?P(e,a):P(e,null,b)}):P(e,b||Mg("UNKNOWN_ERROR"))})}
function dh(a,b,c,d,e){b=Pa(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){P(e,Mg("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.ee),d=jb(d.$a),d.v="js-"+hb,d.transport=b.Cc(),d.suppress_status_codes=!0,a=Gg()+"/"+a.F.hc+c,b.open(a,d,function(a,b){if(a)P(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;P(e,c)}else P(e,null,b)}))}
function Vg(a,b){var c=null!==a.mb||null!==b;a.mb=b;c&&a.fe("auth_status",b);a.Le(null!==b)}g.Ae=function(a){K("auth_status"===a,'initial event must be of type "auth_status"');return this.Se?null:[this.mb]};function ah(a){var b=a.F;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===sg)throw Error("This custom Firebase server ('"+a.F.domain+"') does not support delegated login.");};var Cc="websocket",Dc="long_polling";function eh(a){this.jc=a;this.Nd=[];this.Sb=0;this.qe=-1;this.Fb=null}function fh(a,b,c){a.qe=b;a.Fb=c;a.qe<a.Sb&&(a.Fb(),a.Fb=null)}function gh(a,b,c){for(a.Nd[b]=c;a.Nd[a.Sb];){var d=a.Nd[a.Sb];delete a.Nd[a.Sb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Db(function(){f.jc(d[e])})}if(a.Sb===a.qe){a.Fb&&(clearTimeout(a.Fb),a.Fb(),a.Fb=null);break}a.Sb++}};function hh(a,b,c,d){this.re=a;this.f=Mc(a);this.nb=this.ob=0;this.Ua=Rb(b);this.Qf=c;this.Hc=!1;this.Bb=d;this.jd=function(a){return Bc(b,Dc,a)}}var ih,jh;
hh.prototype.open=function(a,b){this.hf=0;this.la=b;this.Af=new eh(a);this.zb=!1;var c=this;this.qb=setTimeout(function(){c.f("Timed out trying to connect.");c.gb();c.qb=null},Math.floor(3E4));Rc(function(){if(!c.zb){c.Sa=new kh(function(a,b,d,k,l){lh(c,arguments);if(c.Sa)if(c.qb&&(clearTimeout(c.qb),c.qb=null),c.Hc=!0,"start"==a)c.id=b,c.Gf=d;else if("close"===a)b?(c.Sa.Xd=!1,fh(c.Af,b,function(){c.gb()})):c.gb();else throw Error("Unrecognized command received: "+a);},function(a,b){lh(c,arguments);
gh(c.Af,a,b)},function(){c.gb()},c.jd);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Sa.he&&(a.cb=c.Sa.he);a.v="5";c.Qf&&(a.s=c.Qf);c.Bb&&(a.ls=c.Bb);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.jd(a);c.f("Connecting via long-poll to "+a);mh(c.Sa,a,function(){})}})};
hh.prototype.start=function(){var a=this.Sa,b=this.Gf;a.ug=this.id;a.vg=b;for(a.le=!0;nh(a););a=this.id;b=this.Gf;this.gc=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.gc.src=this.jd(c);this.gc.style.display="none";document.body.appendChild(this.gc)};
hh.isAvailable=function(){return ih||!jh&&"undefined"!==typeof document&&null!=document.createElement&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Xg)&&!0};g=hh.prototype;g.Ed=function(){};g.dd=function(){this.zb=!0;this.Sa&&(this.Sa.close(),this.Sa=null);this.gc&&(document.body.removeChild(this.gc),this.gc=null);this.qb&&(clearTimeout(this.qb),this.qb=null)};
g.gb=function(){this.zb||(this.f("Longpoll is closing itself"),this.dd(),this.la&&(this.la(this.Hc),this.la=null))};g.close=function(){this.zb||(this.f("Longpoll is being closed."),this.dd())};g.send=function(a){a=B(a);this.ob+=a.length;Ob(this.Ua,"bytes_sent",a.length);a=Ic(a);a=fb(a,!0);a=Vc(a,1840);for(var b=0;b<a.length;b++){var c=this.Sa;c.ad.push({Mg:this.hf,Ug:a.length,kf:a[b]});c.le&&nh(c);this.hf++}};function lh(a,b){var c=B(b).length;a.nb+=c;Ob(a.Ua,"bytes_received",c)}
function kh(a,b,c,d){this.jd=d;this.hb=c;this.Pe=new pg;this.ad=[];this.te=Math.floor(1E8*Math.random());this.Xd=!0;this.he=Ec();window["pLPCommand"+this.he]=a;window["pRTLPCB"+this.he]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||Cb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.eb=a.contentDocument:a.contentWindow?a.eb=a.contentWindow.document:a.document&&(a.eb=a.document);this.Ea=a;a="";this.Ea.src&&"javascript:"===this.Ea.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ea.eb.open(),this.Ea.eb.write(a),this.Ea.eb.close()}catch(f){Cb("frame writing exception"),f.stack&&Cb(f.stack),Cb(f)}}
kh.prototype.close=function(){this.le=!1;if(this.Ea){this.Ea.eb.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ea&&(document.body.removeChild(a.Ea),a.Ea=null)},Math.floor(0))}var b=this.hb;b&&(this.hb=null,b())};
function nh(a){if(a.le&&a.Xd&&a.Pe.count()<(0<a.ad.length?2:1)){a.te++;var b={};b.id=a.ug;b.pw=a.vg;b.ser=a.te;for(var b=a.jd(b),c="",d=0;0<a.ad.length;)if(1870>=a.ad[0].kf.length+30+c.length){var e=a.ad.shift(),c=c+"&seg"+d+"="+e.Mg+"&ts"+d+"="+e.Ug+"&d"+d+"="+e.kf;d++}else break;oh(a,b+c,a.te);return!0}return!1}function oh(a,b,c){function d(){a.Pe.remove(c);nh(a)}a.Pe.add(c,1);var e=setTimeout(d,Math.floor(25E3));mh(a,b,function(){clearTimeout(e);d()})}
function mh(a,b,c){setTimeout(function(){try{if(a.Xd){var d=a.Ea.eb.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){Cb("Long-poll script failed to load: "+b);a.Xd=!1;a.close()};a.Ea.eb.body.appendChild(d)}}catch(e){}},Math.floor(1))};var ph=null;"undefined"!==typeof MozWebSocket?ph=MozWebSocket:"undefined"!==typeof WebSocket&&(ph=WebSocket);function qh(a,b,c,d){this.re=a;this.f=Mc(this.re);this.frames=this.Kc=null;this.nb=this.ob=this.bf=0;this.Ua=Rb(b);a={v:"5"};"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");c&&(a.s=c);d&&(a.ls=d);this.ef=Bc(b,Cc,a)}var rh;
qh.prototype.open=function(a,b){this.hb=b;this.zg=a;this.f("Websocket connecting to "+this.ef);this.Hc=!1;xc.set("previous_websocket_failure",!0);try{this.ua=new ph(this.ef)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.gb();return}var e=this;this.ua.onopen=function(){e.f("Websocket connected.");e.Hc=!0};this.ua.onclose=function(){e.f("Websocket connection was disconnected.");e.ua=null;e.gb()};this.ua.onmessage=function(a){if(null!==e.ua)if(a=a.data,e.nb+=
a.length,Ob(e.Ua,"bytes_received",a.length),sh(e),null!==e.frames)th(e,a);else{a:{K(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.bf=b;e.frames=[];a=null;break a}}e.bf=1;e.frames=[]}null!==a&&th(e,a)}};this.ua.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.gb()}};qh.prototype.start=function(){};
qh.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==ph&&!rh};qh.responsesRequiredToBeHealthy=2;qh.healthyTimeout=3E4;g=qh.prototype;g.Ed=function(){xc.remove("previous_websocket_failure")};function th(a,b){a.frames.push(b);if(a.frames.length==a.bf){var c=a.frames.join("");a.frames=null;c=nb(c);a.zg(c)}}
g.send=function(a){sh(this);a=B(a);this.ob+=a.length;Ob(this.Ua,"bytes_sent",a.length);a=Vc(a,16384);1<a.length&&this.ua.send(String(a.length));for(var b=0;b<a.length;b++)this.ua.send(a[b])};g.dd=function(){this.zb=!0;this.Kc&&(clearInterval(this.Kc),this.Kc=null);this.ua&&(this.ua.close(),this.ua=null)};g.gb=function(){this.zb||(this.f("WebSocket is closing itself"),this.dd(),this.hb&&(this.hb(this.Hc),this.hb=null))};g.close=function(){this.zb||(this.f("WebSocket is being closed"),this.dd())};
function sh(a){clearInterval(a.Kc);a.Kc=setInterval(function(){a.ua&&a.ua.send("0");sh(a)},Math.floor(45E3))};function uh(a){vh(this,a)}var wh=[hh,qh];function vh(a,b){var c=qh&&qh.isAvailable(),d=c&&!(xc.wf||!0===xc.get("previous_websocket_failure"));b.Wg&&(c||O("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.gd=[qh];else{var e=a.gd=[];Wc(wh,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function xh(a){if(0<a.gd.length)return a.gd[0];throw Error("No transports available");};function yh(a,b,c,d,e,f,h){this.id=a;this.f=Mc("c:"+this.id+":");this.jc=c;this.Wc=d;this.la=e;this.Ne=f;this.F=b;this.Md=[];this.ff=0;this.Pf=new uh(b);this.Ta=0;this.Bb=h;this.f("Connection created");zh(this)}
function zh(a){var b=xh(a.Pf);a.J=new b("c:"+a.id+":"+a.ff++,a.F,void 0,a.Bb);a.Re=b.responsesRequiredToBeHealthy||0;var c=Ah(a,a.J),d=Bh(a,a.J);a.hd=a.J;a.cd=a.J;a.D=null;a.Ab=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.yd=setTimeout(function(){a.yd=null;a.Ab||(a.J&&102400<a.J.nb?(a.f("Connection exceeded healthy timeout but has received "+a.J.nb+" bytes.  Marking connection healthy."),a.Ab=!0,a.J.Ed()):a.J&&10240<a.J.ob?a.f("Connection exceeded healthy timeout but has sent "+
a.J.ob+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function Bh(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Ta?1===a.Ta&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.F.Ya.substr(0,2)&&(xc.remove("host:"+a.F.host),a.F.Ya=a.F.host)),a.close()):b===a.D?(a.f("Secondary connection lost."),c=a.D,a.D=null,a.hd!==c&&a.cd!==c||a.close()):a.f("closing an old connection")}}
function Ah(a,b){return function(c){if(2!=a.Ta)if(b===a.cd){var d=Tc("t",c);c=Tc("d",c);if("c"==d){if(d=Tc("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Nf=c.s;Ac(a.F,f);0==a.Ta&&(a.J.start(),Ch(a,a.J,d),"5"!==e&&O("Protocol version mismatch detected"),c=a.Pf,(c=1<c.gd.length?c.gd[1]:null)&&Dh(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.cd=a.D;for(c=0;c<a.Md.length;++c)a.Id(a.Md[c]);a.Md=[];Eh(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.Ne&&(a.Ne(c),a.Ne=null),a.la=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ac(a.F,c),1===a.Ta?a.close():(Fh(a),zh(a))):"e"===d?Nc("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Gh(a),Hh(a)):Nc("Unknown control packet command: "+d)}else"d"==d&&a.Id(c)}else if(b===a.D)if(d=Tc("t",c),c=Tc("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ih(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.D.close(),a.hd!==a.D&&a.cd!==a.D||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.Mf--,Ih(a)));else if("d"==d)a.Md.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}yh.prototype.Fa=function(a){Jh(this,{t:"d",d:a})};function Eh(a){a.hd===a.D&&a.cd===a.D&&(a.f("cleaning up and promoting a connection: "+a.D.re),a.J=a.D,a.D=null)}
function Ih(a){0>=a.Mf?(a.f("Secondary connection is healthy."),a.Ab=!0,a.D.Ed(),a.D.start(),a.f("sending client ack on secondary"),a.D.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.hd=a.D,Eh(a)):(a.f("sending ping on secondary."),a.D.send({t:"c",d:{t:"p",d:{}}}))}yh.prototype.Id=function(a){Gh(this);this.jc(a)};function Gh(a){a.Ab||(a.Re--,0>=a.Re&&(a.f("Primary connection is healthy."),a.Ab=!0,a.J.Ed()))}
function Dh(a,b){a.D=new b("c:"+a.id+":"+a.ff++,a.F,a.Nf);a.Mf=b.responsesRequiredToBeHealthy||0;a.D.open(Ah(a,a.D),Bh(a,a.D));setTimeout(function(){a.D&&(a.f("Timed out trying to upgrade."),a.D.close())},Math.floor(6E4))}function Ch(a,b,c){a.f("Realtime connection established.");a.J=b;a.Ta=1;a.Wc&&(a.Wc(c,a.Nf),a.Wc=null);0===a.Re?(a.f("Primary connection is healthy."),a.Ab=!0):setTimeout(function(){Hh(a)},Math.floor(5E3))}
function Hh(a){a.Ab||1!==a.Ta||(a.f("sending ping on primary."),Jh(a,{t:"c",d:{t:"p",d:{}}}))}function Jh(a,b){if(1!==a.Ta)throw"Connection is not connected";a.hd.send(b)}yh.prototype.close=function(){2!==this.Ta&&(this.f("Closing realtime connection."),this.Ta=2,Fh(this),this.la&&(this.la(),this.la=null))};function Fh(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.D&&(a.D.close(),a.D=null);a.yd&&(clearTimeout(a.yd),a.yd=null)};function Kh(a,b,c,d){this.id=Lh++;this.f=Mc("p:"+this.id+":");this.xf=this.Ee=!1;this.$={};this.qa=[];this.Yc=0;this.Vc=[];this.oa=!1;this.Za=1E3;this.Fd=3E5;this.Gb=b;this.Uc=c;this.Oe=d;this.F=a;this.sb=this.Aa=this.Ia=this.Bb=this.We=null;this.Ob=!1;this.Td={};this.Lg=0;this.nf=!0;this.Lc=this.Ge=null;Mh(this,0);He.ub().Eb("visible",this.Cg,this);-1===a.host.indexOf("fblocal")&&Ge.ub().Eb("online",this.Ag,this)}var Lh=0,Nh=0;g=Kh.prototype;
g.Fa=function(a,b,c){var d=++this.Lg;a={r:d,a:a,b:b};this.f(B(a));K(this.oa,"sendRequest call when we're not connected not allowed.");this.Ia.Fa(a);c&&(this.Td[d]=c)};g.yf=function(a,b,c,d){var e=a.va(),f=a.path.toString();this.f("Listen called for "+f+" "+e);this.$[f]=this.$[f]||{};K(fe(a.n)||!S(a.n),"listen() called for non-default but complete query");K(!this.$[f][e],"listen() called twice for same path/queryId.");a={H:d,xd:b,Ig:a,tag:c};this.$[f][e]=a;this.oa&&Oh(this,a)};
function Oh(a,b){var c=b.Ig,d=c.path.toString(),e=c.va();a.f("Listen on "+d+" for "+e);var f={p:d};b.tag&&(f.q=ee(c.n),f.t=b.tag);f.h=b.xd();a.Fa("q",f,function(f){var k=f.d,l=f.s;if(k&&"object"===typeof k&&v(k,"w")){var m=w(k,"w");ea(m)&&0<=Na(m,"no_index")&&O("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}(a.$[d]&&a.$[d][e])===b&&(a.f("listen response",f),"ok"!==l&&Ph(a,d,e),b.H&&b.H(l,
k))})}g.M=function(a,b,c){this.Aa={ig:a,of:!1,zc:b,md:c};this.f("Authenticating using credential: "+a);Qh(this);(b=40==a.length)||(a=$c(a).Bc,b="object"===typeof a&&!0===w(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.Fd=3E4)};g.ge=function(a){delete this.Aa;this.oa&&this.Fa("unauth",{},function(b){a(b.s,b.d)})};
function Qh(a){var b=a.Aa;a.oa&&b&&a.Fa("auth",{cred:b.ig},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Aa===b&&delete a.Aa;b.of?"ok"!==d&&b.md&&b.md(d,c):(b.of=!0,b.zc&&b.zc(d,c))})}g.Rf=function(a,b){var c=a.path.toString(),d=a.va();this.f("Unlisten called for "+c+" "+d);K(fe(a.n)||!S(a.n),"unlisten() called for non-default but complete query");if(Ph(this,c,d)&&this.oa){var e=ee(a.n);this.f("Unlisten on "+c+" for "+d);c={p:c};b&&(c.q=e,c.t=b);this.Fa("n",c)}};
g.Me=function(a,b,c){this.oa?Rh(this,"o",a,b,c):this.Vc.push({$c:a,action:"o",data:b,H:c})};g.Cf=function(a,b,c){this.oa?Rh(this,"om",a,b,c):this.Vc.push({$c:a,action:"om",data:b,H:c})};g.Jd=function(a,b){this.oa?Rh(this,"oc",a,null,b):this.Vc.push({$c:a,action:"oc",data:null,H:b})};function Rh(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Fa(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}g.put=function(a,b,c,d){Sh(this,"p",a,b,c,d)};
g.zf=function(a,b,c,d){Sh(this,"m",a,b,c,d)};function Sh(a,b,c,d,e,f){d={p:c,d:d};n(f)&&(d.h=f);a.qa.push({action:b,Jf:d,H:e});a.Yc++;b=a.qa.length-1;a.oa?Th(a,b):a.f("Buffering put: "+c)}function Th(a,b){var c=a.qa[b].action,d=a.qa[b].Jf,e=a.qa[b].H;a.qa[b].Jg=a.oa;a.Fa(c,d,function(d){a.f(c+" response",d);delete a.qa[b];a.Yc--;0===a.Yc&&(a.qa=[]);e&&e(d.s,d.d)})}
g.Ue=function(a){this.oa&&(a={c:a},this.f("reportStats",a),this.Fa("s",a,function(a){"ok"!==a.s&&this.f("reportStats","Error sending stats: "+a.d)}))};
g.Id=function(a){if("r"in a){this.f("from server: "+B(a));var b=a.r,c=this.Td[b];c&&(delete this.Td[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.Gb(c.p,c.d,!1,c.t):"m"===b?this.Gb(c.p,c.d,!0,c.t):"c"===b?Uh(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Aa,delete this.Aa,c&&c.md&&c.md(a,b)):"sd"===b?this.We?this.We(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):Nc("Unrecognized action received from server: "+B(b)+"\nAre you using the latest client?"))}};g.Wc=function(a,b){this.f("connection ready");this.oa=!0;this.Lc=(new Date).getTime();this.Oe({serverTimeOffset:a-(new Date).getTime()});this.Bb=b;if(this.nf){var c={};c["sdk.js."+hb.replace(/\./g,"-")]=1;yg()&&(c["framework.cordova"]=1);this.Ue(c)}Vh(this);this.nf=!1;this.Uc(!0)};
function Mh(a,b){K(!a.Ia,"Scheduling a connect when we're already connected/ing?");a.sb&&clearTimeout(a.sb);a.sb=setTimeout(function(){a.sb=null;Wh(a)},Math.floor(b))}g.Cg=function(a){a&&!this.Ob&&this.Za===this.Fd&&(this.f("Window became visible.  Reducing delay."),this.Za=1E3,this.Ia||Mh(this,0));this.Ob=a};g.Ag=function(a){a?(this.f("Browser went online."),this.Za=1E3,this.Ia||Mh(this,0)):(this.f("Browser went offline.  Killing connection."),this.Ia&&this.Ia.close())};
g.Df=function(){this.f("data client disconnected");this.oa=!1;this.Ia=null;for(var a=0;a<this.qa.length;a++){var b=this.qa[a];b&&"h"in b.Jf&&b.Jg&&(b.H&&b.H("disconnect"),delete this.qa[a],this.Yc--)}0===this.Yc&&(this.qa=[]);this.Td={};Xh(this)&&(this.Ob?this.Lc&&(3E4<(new Date).getTime()-this.Lc&&(this.Za=1E3),this.Lc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Za=this.Fd,this.Ge=(new Date).getTime()),a=Math.max(0,this.Za-((new Date).getTime()-this.Ge)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Mh(this,a),this.Za=Math.min(this.Fd,1.3*this.Za));this.Uc(!1)};function Wh(a){if(Xh(a)){a.f("Making a connection attempt");a.Ge=(new Date).getTime();a.Lc=null;var b=q(a.Id,a),c=q(a.Wc,a),d=q(a.Df,a),e=a.id+":"+Nh++;a.Ia=new yh(e,a.F,b,c,d,function(b){O(b+" ("+a.F.toString()+")");a.xf=!0},a.Bb)}}g.yb=function(){this.Ee=!0;this.Ia?this.Ia.close():(this.sb&&(clearTimeout(this.sb),this.sb=null),this.oa&&this.Df())};g.rc=function(){this.Ee=!1;this.Za=1E3;this.Ia||Mh(this,0)};
function Uh(a,b,c){c=c?Qa(c,function(a){return Uc(a)}).join("$"):"default";(a=Ph(a,b,c))&&a.H&&a.H("permission_denied")}function Ph(a,b,c){b=(new L(b)).toString();var d;n(a.$[b])?(d=a.$[b][c],delete a.$[b][c],0===pa(a.$[b])&&delete a.$[b]):d=void 0;return d}function Vh(a){Qh(a);r(a.$,function(b){r(b,function(b){Oh(a,b)})});for(var b=0;b<a.qa.length;b++)a.qa[b]&&Th(a,b);for(;a.Vc.length;)b=a.Vc.shift(),Rh(a,b.action,b.$c,b.data,b.H)}function Xh(a){var b;b=Ge.ub().kc;return!a.xf&&!a.Ee&&b};var V={og:function(){ih=rh=!0}};V.forceLongPolling=V.og;V.pg=function(){jh=!0};V.forceWebSockets=V.pg;V.Pg=function(a,b){a.k.Ra.We=b};V.setSecurityDebugCallback=V.Pg;V.Ye=function(a,b){a.k.Ye(b)};V.stats=V.Ye;V.Ze=function(a,b){a.k.Ze(b)};V.statsIncrementCounter=V.Ze;V.sd=function(a){return a.k.sd};V.dataUpdateCount=V.sd;V.sg=function(a,b){a.k.De=b};V.interceptServerData=V.sg;V.yg=function(a){new Ig(a)};V.onPopupOpen=V.yg;V.Ng=function(a){sg=a};V.setAuthenticationServer=V.Ng;function Q(a,b,c){this.A=a;this.W=b;this.g=c}Q.prototype.I=function(){x("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};Q.prototype.val=Q.prototype.I;Q.prototype.mf=function(){x("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};Q.prototype.exportVal=Q.prototype.mf;Q.prototype.ng=function(){x("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};Q.prototype.exists=Q.prototype.ng;
Q.prototype.u=function(a){x("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));ig("Firebase.DataSnapshot.child",a);var b=new L(a),c=this.W.u(b);return new Q(this.A.Q(b),c,N)};Q.prototype.child=Q.prototype.u;Q.prototype.Da=function(a){x("Firebase.DataSnapshot.hasChild",1,1,arguments.length);ig("Firebase.DataSnapshot.hasChild",a);var b=new L(a);return!this.A.Q(b).e()};Q.prototype.hasChild=Q.prototype.Da;
Q.prototype.C=function(){x("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.C().I()};Q.prototype.getPriority=Q.prototype.C;Q.prototype.forEach=function(a){x("Firebase.DataSnapshot.forEach",1,1,arguments.length);A("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.K())return!1;var b=this;return!!this.A.P(this.g,function(c,d){return a(new Q(d,b.W.u(c),N))})};Q.prototype.forEach=Q.prototype.forEach;
Q.prototype.wd=function(){x("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.K()?!1:!this.A.e()};Q.prototype.hasChildren=Q.prototype.wd;Q.prototype.name=function(){O("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");x("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};Q.prototype.name=Q.prototype.name;Q.prototype.key=function(){x("Firebase.DataSnapshot.key",0,0,arguments.length);return this.W.key()};
Q.prototype.key=Q.prototype.key;Q.prototype.Db=function(){x("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.Db()};Q.prototype.numChildren=Q.prototype.Db;Q.prototype.Ib=function(){x("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.W};Q.prototype.ref=Q.prototype.Ib;function Yh(a,b){this.F=a;this.Ua=Rb(a);this.fd=null;this.da=new vb;this.Hd=1;this.Ra=null;b||0<=("object"===typeof window&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)?(this.ba=new Ae(this.F,q(this.Gb,this)),setTimeout(q(this.Uc,this,!0),0)):this.ba=this.Ra=new Kh(this.F,q(this.Gb,this),q(this.Uc,this),q(this.Oe,this));this.Sg=Sb(a,q(function(){return new Mb(this.Ua,this.ba)},this));this.uc=new Rf;
this.Ce=new ob;var c=this;this.Cd=new vf({Xe:function(a,b,f,h){b=[];f=c.Ce.j(a.path);f.e()||(b=xf(c.Cd,new Xb(bf,a.path,f)),setTimeout(function(){h("ok")},0));return b},ae:ba});Zh(this,"connected",!1);this.la=new qc;this.M=new Sg(a,q(this.ba.M,this.ba),q(this.ba.ge,this.ba),q(this.Le,this));this.sd=0;this.De=null;this.L=new vf({Xe:function(a,b,f,h){c.ba.yf(a,f,b,function(b,e){var f=h(b,e);Ab(c.da,a.path,f)});return[]},ae:function(a,b){c.ba.Rf(a,b)}})}g=Yh.prototype;
g.toString=function(){return(this.F.kb?"https://":"http://")+this.F.host};g.name=function(){return this.F.hc};function $h(a){a=a.Ce.j(new L(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function ai(a){a=a={timestamp:$h(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}
g.Gb=function(a,b,c,d){this.sd++;var e=new L(a);b=this.De?this.De(a,b):b;a=[];d?c?(b=na(b,function(a){return M(a)}),a=Ff(this.L,e,b,d)):(b=M(b),a=Bf(this.L,e,b,d)):c?(d=na(b,function(a){return M(a)}),a=Af(this.L,e,d)):(d=M(b),a=xf(this.L,new Xb(bf,e,d)));d=e;0<a.length&&(d=bi(this,e));Ab(this.da,d,a)};g.Uc=function(a){Zh(this,"connected",a);!1===a&&ci(this)};g.Oe=function(a){var b=this;Wc(a,function(a,d){Zh(b,d,a)})};g.Le=function(a){Zh(this,"authenticated",a)};
function Zh(a,b,c){b=new L("/.info/"+b);c=M(c);var d=a.Ce;d.Wd=d.Wd.G(b,c);c=xf(a.Cd,new Xb(bf,b,c));Ab(a.da,b,c)}g.Kb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,$g:c});var e=ai(this);b=M(b,c);var e=sc(b,e),f=this.Hd++,e=wf(this.L,a,e,f,!0);wb(this.da,e);var h=this;this.ba.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||O("set at "+a+" failed: "+b);e=zf(h.L,f,!e);Ab(h.da,a,e);di(d,b,c)});e=ei(this,a);bi(this,e);Ab(this.da,e,[])};
g.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=ai(this),f={};r(b,function(a,b){d=!1;var c=M(a);f[b]=sc(c,e)});if(d)Cb("update() called with empty data.  Don't do anything."),di(c,"ok");else{var h=this.Hd++,k=yf(this.L,a,f,h);wb(this.da,k);var l=this;this.ba.zf(a.toString(),b,function(b,d){var e="ok"===b;e||O("update at "+a+" failed: "+b);var e=zf(l.L,h,!e),f=a;0<e.length&&(f=bi(l,a));Ab(l.da,f,e);di(c,b,d)});b=ei(this,a);bi(this,b);Ab(this.da,a,[])}};
function ci(a){a.f("onDisconnectEvents");var b=ai(a),c=[];rc(pc(a.la,b),G,function(b,e){c=c.concat(xf(a.L,new Xb(bf,b,e)));var f=ei(a,b);bi(a,f)});a.la=new qc;Ab(a.da,G,c)}g.Jd=function(a,b){var c=this;this.ba.Jd(a.toString(),function(d,e){"ok"===d&&rg(c.la,a);di(b,d,e)})};function fi(a,b,c,d){var e=M(c);a.ba.Me(b.toString(),e.I(!0),function(c,h){"ok"===c&&a.la.nc(b,e);di(d,c,h)})}function gi(a,b,c,d,e){var f=M(c,d);a.ba.Me(b.toString(),f.I(!0),function(c,d){"ok"===c&&a.la.nc(b,f);di(e,c,d)})}
function hi(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(Cb("onDisconnect().update() called with empty data.  Don't do anything."),di(d,"ok")):a.ba.Cf(b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var m=M(c[l]);a.la.nc(b.u(l),m)}di(d,e,f)})}function ii(a,b,c){c=".info"===E(b.path)?a.Cd.Pb(b,c):a.L.Pb(b,c);yb(a.da,b.path,c)}g.yb=function(){this.Ra&&this.Ra.yb()};g.rc=function(){this.Ra&&this.Ra.rc()};
g.Ye=function(a){if("undefined"!==typeof console){a?(this.fd||(this.fd=new Lb(this.Ua)),a=this.fd.get()):a=this.Ua.get();var b=Ra(sa(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};g.Ze=function(a){Ob(this.Ua,a);this.Sg.Of[a]=!0};g.f=function(a){var b="";this.Ra&&(b=this.Ra.id+":");Cb(b,arguments)};
function di(a,b,c){a&&Db(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function ji(a,b,c,d,e){function f(){}a.f("transaction on "+b);var h=new U(a,b);h.Eb("value",f);c={path:b,update:c,H:d,status:null,Ff:Ec(),cf:e,Lf:0,ie:function(){h.ic("value",f)},ke:null,Ba:null,pd:null,qd:null,rd:null};d=a.L.za(b,void 0)||C;c.pd=d;d=c.update(d.I());if(n(d)){cg("transaction failed: Data returned ",d,c.path);c.status=1;e=Sf(a.uc,b);var k=e.Ca()||[];k.push(c);Tf(e,k);"object"===typeof d&&null!==d&&v(d,".priority")?(k=w(d,".priority"),K(ag(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.L.za(b)||C).C().I();e=ai(a);d=M(d,k);e=sc(d,e);c.qd=d;c.rd=e;c.Ba=a.Hd++;c=wf(a.L,b,e,c.Ba,c.cf);Ab(a.da,b,c);ki(a)}else c.ie(),c.qd=null,c.rd=null,c.H&&(a=new Q(c.pd,new U(a,c.path),N),c.H(null,!1,a))}function ki(a,b){var c=b||a.uc;b||li(a,c);if(null!==c.Ca()){var d=mi(a,c);K(0<d.length,"Sending zero length transaction queue");Sa(d,function(a){return 1===a.status})&&ni(a,c.path(),d)}else c.wd()&&c.P(function(b){ki(a,b)})}
function ni(a,b,c){for(var d=Qa(c,function(a){return a.Ba}),e=a.L.za(b,d)||C,d=e,e=e.hash(),f=0;f<c.length;f++){var h=c[f];K(1===h.status,"tryToSendTransactionQueue_: items in queue should all be run.");h.status=2;h.Lf++;var k=T(b,h.path),d=d.G(k,h.qd)}d=d.I(!0);a.ba.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(zf(a.L,c[f].Ba));if(c[f].H){var h=c[f].rd,k=new U(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new Q(h,k,N)))}c[f].ie()}li(a,Sf(a.uc,b));ki(a);Ab(a.da,b,e);for(f=0;f<d.length;f++)Db(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(O("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].ke=d;bi(a,b)}},e)}function bi(a,b){var c=oi(a,b),d=c.path(),c=mi(a,c);pi(a,c,d);return d}
function pi(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Qa(b,function(a){return a.Ba}),h=0;h<b.length;h++){var k=b[h],l=T(c,k.path),m=!1,t;K(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)m=!0,t=k.ke,e=e.concat(zf(a.L,k.Ba,!0));else if(1===k.status)if(25<=k.Lf)m=!0,t="maxretry",e=e.concat(zf(a.L,k.Ba,!0));else{var z=a.L.za(k.path,f)||C;k.pd=z;var I=b[h].update(z.I());n(I)?(cg("transaction failed: Data returned ",I,k.path),l=M(I),"object"===typeof I&&null!=
I&&v(I,".priority")||(l=l.ga(z.C())),z=k.Ba,I=ai(a),I=sc(l,I),k.qd=l,k.rd=I,k.Ba=a.Hd++,Va(f,z),e=e.concat(wf(a.L,k.path,I,k.Ba,k.cf)),e=e.concat(zf(a.L,z,!0))):(m=!0,t="nodata",e=e.concat(zf(a.L,k.Ba,!0)))}Ab(a.da,c,e);e=[];m&&(b[h].status=3,setTimeout(b[h].ie,Math.floor(0)),b[h].H&&("nodata"===t?(k=new U(a,b[h].path),d.push(q(b[h].H,null,null,!1,new Q(b[h].pd,k,N)))):d.push(q(b[h].H,null,Error(t),!1,null))))}li(a,a.uc);for(h=0;h<d.length;h++)Db(d[h]);ki(a)}}
function oi(a,b){for(var c,d=a.uc;null!==(c=E(b))&&null===d.Ca();)d=Sf(d,c),b=H(b);return d}function mi(a,b){var c=[];qi(a,b,c);c.sort(function(a,b){return a.Ff-b.Ff});return c}function qi(a,b,c){var d=b.Ca();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.P(function(b){qi(a,b,c)})}function li(a,b){var c=b.Ca();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Tf(b,0<c.length?c:null)}b.P(function(b){li(a,b)})}
function ei(a,b){var c=oi(a,b).path(),d=Sf(a.uc,b);Wf(d,function(b){ri(a,b)});ri(a,d);Vf(d,function(b){ri(a,b)});return c}
function ri(a,b){var c=b.Ca();if(null!==c){for(var d=[],e=[],f=-1,h=0;h<c.length;h++)4!==c[h].status&&(2===c[h].status?(K(f===h-1,"All SENT items should be at beginning of queue."),f=h,c[h].status=4,c[h].ke="set"):(K(1===c[h].status,"Unexpected transaction status in abort"),c[h].ie(),e=e.concat(zf(a.L,c[h].Ba,!0)),c[h].H&&d.push(q(c[h].H,null,Error("set"),!1,null))));-1===f?Tf(b,null):c.length=f+1;Ab(a.da,b.path(),e);for(h=0;h<d.length;h++)Db(d[h])}};function W(){this.oc={};this.Sf=!1}W.prototype.yb=function(){for(var a in this.oc)this.oc[a].yb()};W.prototype.rc=function(){for(var a in this.oc)this.oc[a].rc()};W.prototype.ve=function(){this.Sf=!0};ca(W);W.prototype.interrupt=W.prototype.yb;W.prototype.resume=W.prototype.rc;function X(a,b){this.bd=a;this.ra=b}X.prototype.cancel=function(a){x("Firebase.onDisconnect().cancel",0,1,arguments.length);A("Firebase.onDisconnect().cancel",1,a,!0);this.bd.Jd(this.ra,a||null)};X.prototype.cancel=X.prototype.cancel;X.prototype.remove=function(a){x("Firebase.onDisconnect().remove",0,1,arguments.length);jg("Firebase.onDisconnect().remove",this.ra);A("Firebase.onDisconnect().remove",1,a,!0);fi(this.bd,this.ra,null,a)};X.prototype.remove=X.prototype.remove;
X.prototype.set=function(a,b){x("Firebase.onDisconnect().set",1,2,arguments.length);jg("Firebase.onDisconnect().set",this.ra);bg("Firebase.onDisconnect().set",a,this.ra,!1);A("Firebase.onDisconnect().set",2,b,!0);fi(this.bd,this.ra,a,b)};X.prototype.set=X.prototype.set;
X.prototype.Kb=function(a,b,c){x("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);jg("Firebase.onDisconnect().setWithPriority",this.ra);bg("Firebase.onDisconnect().setWithPriority",a,this.ra,!1);fg("Firebase.onDisconnect().setWithPriority",2,b);A("Firebase.onDisconnect().setWithPriority",3,c,!0);gi(this.bd,this.ra,a,b,c)};X.prototype.setWithPriority=X.prototype.Kb;
X.prototype.update=function(a,b){x("Firebase.onDisconnect().update",1,2,arguments.length);jg("Firebase.onDisconnect().update",this.ra);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}eg("Firebase.onDisconnect().update",a,this.ra);A("Firebase.onDisconnect().update",2,b,!0);
hi(this.bd,this.ra,a,b)};X.prototype.update=X.prototype.update;function Y(a,b,c,d){this.k=a;this.path=b;this.n=c;this.lc=d}
function si(a){var b=null,c=null;a.ma&&(b=nd(a));a.pa&&(c=pd(a));if(a.g===Qd){if(a.ma){if("[MIN_NAME]"!=md(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.pa){if("[MAX_NAME]"!=od(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===N){if(null!=b&&!ag(b)||null!=c&&!ag(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(K(a.g instanceof Ud||a.g===$d,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function ti(a){if(a.ma&&a.pa&&a.ja&&(!a.ja||""===a.Nb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function ui(a,b){if(!0===a.lc)throw Error(b+": You can't combine multiple orderBy calls.");}g=Y.prototype;g.Ib=function(){x("Query.ref",0,0,arguments.length);return new U(this.k,this.path)};
g.Eb=function(a,b,c,d){x("Query.on",2,4,arguments.length);gg("Query.on",a,!1);A("Query.on",2,b,!1);var e=vi("Query.on",c,d);if("value"===a)ii(this.k,this,new id(b,e.cancel||null,e.Ma||null));else{var f={};f[a]=b;ii(this.k,this,new jd(f,e.cancel,e.Ma))}return b};
g.ic=function(a,b,c){x("Query.off",0,3,arguments.length);gg("Query.off",a,!0);A("Query.off",2,b,!0);mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new id(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new jd(e,null,c||null));e=this.k;d=".info"===E(this.path)?e.Cd.jb(this,d):e.L.jb(this,d);yb(e.da,this.path,d)};
g.Dg=function(a,b){function c(h){f&&(f=!1,e.ic(a,c),b.call(d.Ma,h))}x("Query.once",2,4,arguments.length);gg("Query.once",a,!1);A("Query.once",2,b,!1);var d=vi("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.Eb(a,c,function(b){e.ic(a,c);d.cancel&&d.cancel.call(d.Ma,b)})};
g.He=function(a){O("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");x("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.He(a);ti(b);return new Y(this.k,this.path,b,this.lc)};
g.Ie=function(a){x("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Ie(a),this.lc)};
g.Je=function(a){x("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ja)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Je(a),this.lc)};
g.Eg=function(a){x("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');ig("Query.orderByChild",a);ui(this,"Query.orderByChild");var b=new L(a);if(b.e())throw Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
b=new Ud(b);b=de(this.n,b);si(b);return new Y(this.k,this.path,b,!0)};g.Fg=function(){x("Query.orderByKey",0,0,arguments.length);ui(this,"Query.orderByKey");var a=de(this.n,Qd);si(a);return new Y(this.k,this.path,a,!0)};g.Gg=function(){x("Query.orderByPriority",0,0,arguments.length);ui(this,"Query.orderByPriority");var a=de(this.n,N);si(a);return new Y(this.k,this.path,a,!0)};
g.Hg=function(){x("Query.orderByValue",0,0,arguments.length);ui(this,"Query.orderByValue");var a=de(this.n,$d);si(a);return new Y(this.k,this.path,a,!0)};g.$d=function(a,b){x("Query.startAt",0,2,arguments.length);bg("Query.startAt",a,this.path,!0);hg("Query.startAt",b);var c=this.n.$d(a,b);ti(c);si(c);if(this.n.ma)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");n(a)||(b=a=null);return new Y(this.k,this.path,c,this.lc)};
g.td=function(a,b){x("Query.endAt",0,2,arguments.length);bg("Query.endAt",a,this.path,!0);hg("Query.endAt",b);var c=this.n.td(a,b);ti(c);si(c);if(this.n.pa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Y(this.k,this.path,c,this.lc)};
g.kg=function(a,b){x("Query.equalTo",1,2,arguments.length);bg("Query.equalTo",a,this.path,!1);hg("Query.equalTo",b);if(this.n.ma)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.pa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.$d(a,b).td(a,b)};
g.toString=function(){x("Query.toString",0,0,arguments.length);for(var a=this.path,b="",c=a.Z;c<a.o.length;c++)""!==a.o[c]&&(b+="/"+encodeURIComponent(String(a.o[c])));return this.k.toString()+(b||"/")};g.va=function(){var a=Uc(ee(this.n));return"{}"===a?"default":a};
function vi(a,b,c){var d={cancel:null,Ma:null};if(b&&c)d.cancel=b,A(a,3,d.cancel,!0),d.Ma=c,mb(a,4,d.Ma);else if(b)if("object"===typeof b&&null!==b)d.Ma=b;else if("function"===typeof b)d.cancel=b;else throw Error(y(a,3,!0)+" must either be a cancel callback or a context object.");return d}Y.prototype.ref=Y.prototype.Ib;Y.prototype.on=Y.prototype.Eb;Y.prototype.off=Y.prototype.ic;Y.prototype.once=Y.prototype.Dg;Y.prototype.limit=Y.prototype.He;Y.prototype.limitToFirst=Y.prototype.Ie;
Y.prototype.limitToLast=Y.prototype.Je;Y.prototype.orderByChild=Y.prototype.Eg;Y.prototype.orderByKey=Y.prototype.Fg;Y.prototype.orderByPriority=Y.prototype.Gg;Y.prototype.orderByValue=Y.prototype.Hg;Y.prototype.startAt=Y.prototype.$d;Y.prototype.endAt=Y.prototype.td;Y.prototype.equalTo=Y.prototype.kg;Y.prototype.toString=Y.prototype.toString;var Z={};Z.vc=Kh;Z.DataConnection=Z.vc;Kh.prototype.Rg=function(a,b){this.Fa("q",{p:a},b)};Z.vc.prototype.simpleListen=Z.vc.prototype.Rg;Kh.prototype.jg=function(a,b){this.Fa("echo",{d:a},b)};Z.vc.prototype.echo=Z.vc.prototype.jg;Kh.prototype.interrupt=Kh.prototype.yb;Z.Vf=yh;Z.RealTimeConnection=Z.Vf;yh.prototype.sendRequest=yh.prototype.Fa;yh.prototype.close=yh.prototype.close;
Z.rg=function(a){var b=Kh.prototype.put;Kh.prototype.put=function(c,d,e,f){n(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Kh.prototype.put=b}};Z.hijackHash=Z.rg;Z.Uf=zc;Z.ConnectionTarget=Z.Uf;Z.va=function(a){return a.va()};Z.queryIdentifier=Z.va;Z.tg=function(a){return a.k.Ra.$};Z.listens=Z.tg;Z.ve=function(a){a.ve()};Z.forceRestClient=Z.ve;function U(a,b){var c,d,e;if(a instanceof Yh)c=a,d=b;else{x("new Firebase",1,2,arguments.length);d=Pc(arguments[0]);c=d.Tg;"firebase"===d.domain&&Oc(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c&&"undefined"!=c||Oc("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.kb||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&O("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new zc(d.host,d.kb,c,"ws"===d.scheme||"wss"===d.scheme);d=new L(d.$c);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!$f(c.hc))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Yf.test(e)));if(f)throw Error(y("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof W)e=b;else if(p(b))e=W.ub(),c.Od=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=W.ub();f=c.toString();var h=w(e.oc,f);h||(h=new Yh(c,e.Sf),e.oc[f]=h);c=h}Y.call(this,c,d,be,!1)}ma(U,Y);var wi=U,xi=["Firebase"],yi=aa;xi[0]in yi||!yi.execScript||yi.execScript("var "+xi[0]);for(var zi;xi.length&&(zi=xi.shift());)!xi.length&&n(wi)?yi[zi]=wi:yi=yi[zi]?yi[zi]:yi[zi]={};U.goOffline=function(){x("Firebase.goOffline",0,0,arguments.length);W.ub().yb()};U.goOnline=function(){x("Firebase.goOnline",0,0,arguments.length);W.ub().rc()};
function Lc(a,b){K(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?Bb=q(console.log,console):"object"===typeof console.log&&(Bb=function(a){console.log(a)})),b&&yc.set("logging_enabled",!0)):a?Bb=a:(Bb=null,yc.remove("logging_enabled"))}U.enableLogging=Lc;U.ServerValue={TIMESTAMP:{".sv":"timestamp"}};U.SDK_VERSION=hb;U.INTERNAL=V;U.Context=W;U.TEST_ACCESS=Z;
U.prototype.name=function(){O("Firebase.name() being deprecated. Please use Firebase.key() instead.");x("Firebase.name",0,0,arguments.length);return this.key()};U.prototype.name=U.prototype.name;U.prototype.key=function(){x("Firebase.key",0,0,arguments.length);return this.path.e()?null:Ld(this.path)};U.prototype.key=U.prototype.key;
U.prototype.u=function(a){x("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof L))if(null===E(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));ig("Firebase.child",b)}else ig("Firebase.child",a);return new U(this.k,this.path.u(a))};U.prototype.child=U.prototype.u;U.prototype.parent=function(){x("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new U(this.k,a)};U.prototype.parent=U.prototype.parent;
U.prototype.root=function(){x("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};U.prototype.root=U.prototype.root;U.prototype.set=function(a,b){x("Firebase.set",1,2,arguments.length);jg("Firebase.set",this.path);bg("Firebase.set",a,this.path,!1);A("Firebase.set",2,b,!0);this.k.Kb(this.path,a,null,b||null)};U.prototype.set=U.prototype.set;
U.prototype.update=function(a,b){x("Firebase.update",1,2,arguments.length);jg("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}eg("Firebase.update",a,this.path);A("Firebase.update",2,b,!0);this.k.update(this.path,a,b||null)};U.prototype.update=U.prototype.update;
U.prototype.Kb=function(a,b,c){x("Firebase.setWithPriority",2,3,arguments.length);jg("Firebase.setWithPriority",this.path);bg("Firebase.setWithPriority",a,this.path,!1);fg("Firebase.setWithPriority",2,b);A("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Kb(this.path,a,b,c||null)};U.prototype.setWithPriority=U.prototype.Kb;
U.prototype.remove=function(a){x("Firebase.remove",0,1,arguments.length);jg("Firebase.remove",this.path);A("Firebase.remove",1,a,!0);this.set(null,a)};U.prototype.remove=U.prototype.remove;
U.prototype.transaction=function(a,b,c){x("Firebase.transaction",1,3,arguments.length);jg("Firebase.transaction",this.path);A("Firebase.transaction",1,a,!1);A("Firebase.transaction",2,b,!0);if(n(c)&&"boolean"!=typeof c)throw Error(y("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);ji(this.k,this.path,a,b||null,c)};U.prototype.transaction=U.prototype.transaction;
U.prototype.Og=function(a,b){x("Firebase.setPriority",1,2,arguments.length);jg("Firebase.setPriority",this.path);fg("Firebase.setPriority",1,a);A("Firebase.setPriority",2,b,!0);this.k.Kb(this.path.u(".priority"),a,null,b)};U.prototype.setPriority=U.prototype.Og;
U.prototype.push=function(a,b){x("Firebase.push",0,2,arguments.length);jg("Firebase.push",this.path);bg("Firebase.push",a,this.path,!0);A("Firebase.push",2,b,!0);var c=$h(this.k),c=Fe(c),c=this.u(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};U.prototype.push=U.prototype.push;U.prototype.hb=function(){jg("Firebase.onDisconnect",this.path);return new X(this.k,this.path)};U.prototype.onDisconnect=U.prototype.hb;
U.prototype.M=function(a,b,c){O("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");x("Firebase.auth",1,3,arguments.length);kg("Firebase.auth",a);A("Firebase.auth",2,b,!0);A("Firebase.auth",3,b,!0);Yg(this.k.M,a,{},{remember:"none"},b,c)};U.prototype.auth=U.prototype.M;U.prototype.ge=function(a){x("Firebase.unauth",0,1,arguments.length);A("Firebase.unauth",1,a,!0);Zg(this.k.M,a)};U.prototype.unauth=U.prototype.ge;
U.prototype.xe=function(){x("Firebase.getAuth",0,0,arguments.length);return this.k.M.xe()};U.prototype.getAuth=U.prototype.xe;U.prototype.xg=function(a,b){x("Firebase.onAuth",1,2,arguments.length);A("Firebase.onAuth",1,a,!1);mb("Firebase.onAuth",2,b);this.k.M.Eb("auth_status",a,b)};U.prototype.onAuth=U.prototype.xg;U.prototype.wg=function(a,b){x("Firebase.offAuth",1,2,arguments.length);A("Firebase.offAuth",1,a,!1);mb("Firebase.offAuth",2,b);this.k.M.ic("auth_status",a,b)};U.prototype.offAuth=U.prototype.wg;
U.prototype.Zf=function(a,b,c){x("Firebase.authWithCustomToken",2,3,arguments.length);kg("Firebase.authWithCustomToken",a);A("Firebase.authWithCustomToken",2,b,!1);ng("Firebase.authWithCustomToken",3,c,!0);Yg(this.k.M,a,{},c||{},b)};U.prototype.authWithCustomToken=U.prototype.Zf;U.prototype.$f=function(a,b,c){x("Firebase.authWithOAuthPopup",2,3,arguments.length);mg("Firebase.authWithOAuthPopup",a);A("Firebase.authWithOAuthPopup",2,b,!1);ng("Firebase.authWithOAuthPopup",3,c,!0);ch(this.k.M,a,c,b)};
U.prototype.authWithOAuthPopup=U.prototype.$f;U.prototype.ag=function(a,b,c){x("Firebase.authWithOAuthRedirect",2,3,arguments.length);mg("Firebase.authWithOAuthRedirect",a);A("Firebase.authWithOAuthRedirect",2,b,!1);ng("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.M;ah(d);var e=[Kg],f=vg(c);"anonymous"===a||"firebase"===a?P(b,Mg("TRANSPORT_UNAVAILABLE")):(yc.set("redirect_client_options",f.od),bh(d,e,"/auth/"+a,f,b))};U.prototype.authWithOAuthRedirect=U.prototype.ag;
U.prototype.bg=function(a,b,c,d){x("Firebase.authWithOAuthToken",3,4,arguments.length);mg("Firebase.authWithOAuthToken",a);A("Firebase.authWithOAuthToken",3,c,!1);ng("Firebase.authWithOAuthToken",4,d,!0);p(b)?(lg("Firebase.authWithOAuthToken",2,b),$g(this.k.M,a+"/token",{access_token:b},d,c)):(ng("Firebase.authWithOAuthToken",2,b,!1),$g(this.k.M,a+"/token",b,d,c))};U.prototype.authWithOAuthToken=U.prototype.bg;
U.prototype.Yf=function(a,b){x("Firebase.authAnonymously",1,2,arguments.length);A("Firebase.authAnonymously",1,a,!1);ng("Firebase.authAnonymously",2,b,!0);$g(this.k.M,"anonymous",{},b,a)};U.prototype.authAnonymously=U.prototype.Yf;
U.prototype.cg=function(a,b,c){x("Firebase.authWithPassword",2,3,arguments.length);ng("Firebase.authWithPassword",1,a,!1);og("Firebase.authWithPassword",a,"email");og("Firebase.authWithPassword",a,"password");A("Firebase.authWithPassword",2,b,!1);ng("Firebase.authWithPassword",3,c,!0);$g(this.k.M,"password",a,c,b)};U.prototype.authWithPassword=U.prototype.cg;
U.prototype.se=function(a,b){x("Firebase.createUser",2,2,arguments.length);ng("Firebase.createUser",1,a,!1);og("Firebase.createUser",a,"email");og("Firebase.createUser",a,"password");A("Firebase.createUser",2,b,!1);this.k.M.se(a,b)};U.prototype.createUser=U.prototype.se;U.prototype.Te=function(a,b){x("Firebase.removeUser",2,2,arguments.length);ng("Firebase.removeUser",1,a,!1);og("Firebase.removeUser",a,"email");og("Firebase.removeUser",a,"password");A("Firebase.removeUser",2,b,!1);this.k.M.Te(a,b)};
U.prototype.removeUser=U.prototype.Te;U.prototype.pe=function(a,b){x("Firebase.changePassword",2,2,arguments.length);ng("Firebase.changePassword",1,a,!1);og("Firebase.changePassword",a,"email");og("Firebase.changePassword",a,"oldPassword");og("Firebase.changePassword",a,"newPassword");A("Firebase.changePassword",2,b,!1);this.k.M.pe(a,b)};U.prototype.changePassword=U.prototype.pe;
U.prototype.oe=function(a,b){x("Firebase.changeEmail",2,2,arguments.length);ng("Firebase.changeEmail",1,a,!1);og("Firebase.changeEmail",a,"oldEmail");og("Firebase.changeEmail",a,"newEmail");og("Firebase.changeEmail",a,"password");A("Firebase.changeEmail",2,b,!1);this.k.M.oe(a,b)};U.prototype.changeEmail=U.prototype.oe;
U.prototype.Ve=function(a,b){x("Firebase.resetPassword",2,2,arguments.length);ng("Firebase.resetPassword",1,a,!1);og("Firebase.resetPassword",a,"email");A("Firebase.resetPassword",2,b,!1);this.k.M.Ve(a,b)};U.prototype.resetPassword=U.prototype.Ve;})();

module.exports = Firebase;

},{}]},{},["/Users/dave/lh2/angular2/study-tracker/client/app/main.ts"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQvYXBwL21haW4udHMiLCJjbGllbnQvYXBwL3BsYW4udHMiLCJjbGllbnQvYXBwL3NpZ25pbi50cyIsImNsaWVudC9hcHAvdXNlcnMudHMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvYW5ndWxhcjIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvYm9vdHN0cmFwLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL2NvcmUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbGlmZWN5Y2xlX2hvb2tzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9ub2RlX21vZHVsZXMvQHJlYWN0aXZleC9yeGpzL2Rpc3QvY2pzL1N1YmplY3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvU3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL25vZGVfbW9kdWxlcy9AcmVhY3RpdmV4L3J4anMvZGlzdC9janMvc3ViamVjdHMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9ub2RlX21vZHVsZXMvQHJlYWN0aXZleC9yeGpzL2Rpc3QvY2pzL3V0aWwvU3ltYm9sX29ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL25vb3AuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3Rocm93RXJyb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvbm9kZV9tb2R1bGVzL0ByZWFjdGl2ZXgvcnhqcy9kaXN0L2Nqcy91dGlsL3RyeU9yT25FcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9wcm9maWxlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2FuaW1hdGUvYW5pbWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9hbmltYXRlL2FuaW1hdGlvbl9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9hbmltYXRlL2Jyb3dzZXJfZGV0YWlscy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvYW5pbWF0ZS9jc3NfYW5pbWF0aW9uX2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2FuaW1hdGUvY3NzX2FuaW1hdGlvbl9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2FwcGxpY2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2FwcGxpY2F0aW9uX2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9hcHBsaWNhdGlvbl9yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvYXBwbGljYXRpb25fdG9rZW5zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Jvb3RzdHJhcC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYmluZGluZ19yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdG9yX3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvYWxlc2NlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY29kZWdlbl9mYWNhZGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jb2RlZ2VuX2xvZ2ljX3V0aWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jb2RlZ2VuX25hbWVfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2RpZmZlcnMvZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9kaWZmZXJzL2RlZmF1bHRfa2V5dmFsdWVfZGlmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9rZXl2YWx1ZV9kaWZmZXJzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZGlyZWN0aXZlX3JlY29yZC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2R5bmFtaWNfY2hhbmdlX2RldGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vZXZlbnRfYmluZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2V4Y2VwdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9pbnRlcmZhY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vaml0X3Byb3RvX2NoYW5nZV9kZXRlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL29ic2VydmFibGVfZmFjYWRlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGFyc2VyL2FzdC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3BhcnNlci9sZXhlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3BhcnNlci9sb2NhbHMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wYXJzZXIvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGlwZV9saWZlY3ljbGVfcmVmbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcGlwZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wcm90b19jaGFuZ2VfZGV0ZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wcm90b19yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9hcHBfcm9vdF91cmwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY2hhbmdlX2RlZmluaXRpb25fZmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY29tbWFuZF9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9kaXJlY3RpdmVfbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvaHRtbF9hc3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvaHRtbF9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvcnVudGltZV9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9ydW50aW1lX21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NjaGVtYS9kb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NlbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NoYWRvd19jc3MuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc291cmNlX21vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zdHlsZV9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zdHlsZV91cmxfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfYXN0LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX25vcm1hbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX3ByZXBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci91cmxfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIveGhyX2ltcGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGVidWcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGVidWcvZGVidWdfZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kZWJ1Zy9kZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9leGNlcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2ZvcndhcmRfcmVmLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2luamVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaS9vcGFxdWVfdG9rZW4uanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGkvdHlwZV9saXRlcmFsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9uZ19jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaXJlY3RpdmVzL25nX2Zvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kaXJlY3RpdmVzL25nX2lmLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RpcmVjdGl2ZXMvbmdfc3R5bGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9uZ19zd2l0Y2guanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZGlyZWN0aXZlcy9vYnNlcnZhYmxlX2xpc3RfZGlmZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kb20vYnJvd3Nlcl9hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9kb20vZ2VuZXJpY19icm93c2VyX2FkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9uX2hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2ludGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL21hdGguanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvY2hlY2tib3hfdmFsdWVfYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9jb250cm9sX2NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX3N0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL25nX2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX2NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfbW9kZWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9mb3Jtcy9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvZm9ybXMvZm9ybV9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2Zvcm1zL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlmZV9jeWNsZS9saWZlX2N5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpZmVjeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9kaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZGlyZWN0aXZlX3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2VsZW1lbnRfYmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9lbGVtZW50X2luamVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9lbGVtZW50X3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZXZlbnRfY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9pbnRlcmZhY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9waXBlX3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9wcm90b192aWV3X2ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3F1ZXJ5X2xpc3QuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3RlbXBsYXRlX2NvbW1hbmRzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci90ZW1wbGF0ZV9yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXcuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19saXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X21hbmFnZXJfdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19yZWYuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvZGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEvZGlyZWN0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL2FzeW5jX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvZGF0ZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL2RlZmF1bHRfcGlwZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9qc29uX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvbG93ZXJjYXNlX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvbnVtYmVyX3BpcGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMvcGlwZV9wcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9waXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9waXBlcy9zbGljZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BpcGVzL3VwcGVyY2FzZV9waXBlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3BsYXRmb3JtX2JpbmRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Byb2ZpbGUvcHJvZmlsZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9wcm9maWxlL3d0Zl9pbXBsLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Byb2ZpbGUvd3RmX2luaXQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9hcGkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9kb21fcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9kb21fdG9rZW5zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9kb20vZXZlbnRzL2V2ZW50X21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMvaGFtbWVyX2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL2V2ZW50cy9oYW1tZXJfZ2VzdHVyZXMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS9ldmVudHMva2V5X2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3NoYXJlZF9zdHlsZXNfaG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvdmlld19mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3NlcnZpY2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3NlcnZpY2VzL3RpdGxlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9jb3JlL3Rlc3RhYmlsaXR5L2Jyb3dzZXJfdGVzdGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvdGVzdGFiaWxpdHkvdGVzdGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS91dGlsL2RlY29yYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL2NvcmUvem9uZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvY29yZS96b25lL25nX3pvbmUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9hc3luY19yb3V0ZV9oYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvaGFzaF9sb2NhdGlvbl9zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL2luc3RydWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvbGlmZWN5Y2xlX2Fubm90YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGwuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9sb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL2xvY2F0aW9uX3N0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcGF0aF9sb2NhdGlvbl9zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3BhdGhfcmVjb2duaXplci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2NvbmZpZ19kZWNvcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9jb25maWdfaW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2NvbmZpZ19ub21hbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcm91dGVfZGVmaW5pdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZV9yZWNvZ25pemVyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy9yb3V0ZXIvcm91dGVfcmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9yb3V0ZXJfbGluay5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyMi9zcmMvcm91dGVyL3JvdXRlcl9vdXRsZXQuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci9zeW5jX3JvdXRlX2hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhcjIvc3JjL3JvdXRlci91cmxfcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXIyL3NyYy90cmFuc2Zvcm0vdGVtcGxhdGVfY29tcGlsZXIvY2hhbmdlX2RldGVjdG9yX2NvZGVnZW4uanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvbnBtLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9hZmZpeC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvYWxlcnQuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2J1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvY2Fyb3VzZWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2NvbGxhcHNlLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9kcm9wZG93bi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvbW9kYWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3BvcG92ZXIuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3Njcm9sbHNweS5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvdGFiLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxrRUFBa0U7QUFDbEUsNkRBQTZEO0FBQzdELDZEQUE2RDs7Ozs7Ozs7Ozs7O0FBRTdELE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNwQixPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFckIseUJBQXNFLG1CQUFtQixDQUFDLENBQUE7QUFFMUYsdUJBQXNFLGlCQUFpQixDQUFDLENBQUE7QUFDeEYsdUJBQXNFLGlCQUFpQixDQUFDLENBQUE7QUFDeEYsdUJBQXNFLGlCQUFpQixDQUFDLENBQUE7QUFFeEYsc0JBQXdCLFNBQVMsQ0FBQyxDQUFBO0FBQ2xDLHVCQUF3QixVQUFVLENBQUMsQ0FBQTtBQUNuQyxxQkFBd0IsUUFBUSxDQUFDLENBQUE7QUFJakMsSUFBSSxRQUFRLEdBQUssT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFFekQ7SUEwQkksc0JBQVksTUFBZTtRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFJLElBQUksUUFBUSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7UUFDbkUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRCx3Q0FBaUIsR0FBakIsVUFBa0IsUUFBUTtRQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztRQUMxQixRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFakQsZ0VBQWdFO1FBQ2hFLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFJLFNBQVM7SUFDM0MsQ0FBQztJQXRDTDtRQUFDLG9CQUFTLENBQUM7WUFDUCxRQUFRLEVBQUUsS0FBSztTQUNsQixDQUFDO1FBRUQsZUFBSSxDQUFDO1lBQ0YsVUFBVSxFQUFFLENBQUMsbUJBQVUsRUFBRSxxQkFBWSxFQUFFLGlCQUFTLENBQUM7WUFFakQsUUFBUSxFQUFFLDBMQU1MO1NBQ1IsQ0FBQztRQUVELG9CQUFXLENBQUM7WUFDVCxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUssRUFBRSxFQUFFLE1BQU0sRUFBSSxTQUFTLEVBQUUsV0FBSSxFQUFFO1lBQ25ELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxlQUFNLEVBQUU7U0FDeEQsQ0FBQzs7cUJBb0JEO0lBQUQsbUJBQUM7QUFBRCxDQXZDQSxBQXVDQyxJQUFBO0FBRUQsMkVBQTJFO0FBQzNFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRTtJQUMxQyxvQkFBUyxDQUFDLFlBQVk7SUFFWiwyQ0FBMkM7SUFDM0M7UUFDVix5QkFBZ0I7UUFDRixrQkFBTyxDQUFDLHlCQUFnQixFQUFFLEVBQUMsUUFBUSxFQUFFLDZCQUFvQixFQUFDLENBQUM7S0FDOUQsQ0FFRCxDQUFDO0FBRWYsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7QUMxRVYsa0VBQWtFO0FBQ2xFLDZEQUE2RDs7Ozs7Ozs7Ozs7O0FBRTdELHlCQUFnQyxtQkFBbUIsQ0FBQyxDQUFBO0FBSXBEO0lBZUk7UUFDSSxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUE7UUFFdEMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBSyxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQzVDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFNLElBQUksRUFBRSxNQUFNLEVBQUU7WUFDekMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUM1QyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBSyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUV0RCxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDakMsTUFBTSxFQUFZLElBQUk7WUFDdEIsU0FBUyxFQUFTLENBQUM7WUFDbkIsZUFBZSxFQUFHLElBQUk7WUFDdEIsT0FBTyxFQUFXLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUU7WUFDeEQsU0FBUyxFQUFLLFVBQVMsSUFBSTtnQkFDOUIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3BELEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUNiLElBQUksR0FBRywwREFBMEQsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7Z0JBQ3hHLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ0osSUFBSSxHQUFHLHlDQUF5QyxHQUFHLElBQUksQ0FBQztnQkFDNUQsQ0FBQztnQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFBO1lBQ1IsQ0FBQztZQUNNLFdBQVcsRUFBTyxVQUFTLElBQUk7Z0JBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDakIsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDN0MsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNuQyxDQUFDO1lBQ1MsQ0FBQztZQUNELE9BQU8sRUFBVyxVQUFTLElBQUk7Z0JBQzNCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNqQixNQUFNLENBQUMsRUFBQyxFQUFFLEVBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQztnQkFDbEQsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDSixNQUFNLENBQUMsSUFBSSxDQUFDO2dCQUNoQixDQUFDO1lBQ0wsQ0FBQztTQUNKLENBQUMsQ0FBQztRQUVWLGtDQUFrQztRQUNsQywrRkFBK0Y7UUFDL0YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLENBQUM7WUFDbEUsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLENBQUMsQ0FBQyxDQUFDO0lBQ0EsQ0FBQztJQTFETDtRQUFDLG9CQUFTLENBQUM7WUFDUCxRQUFRLEVBQUUsTUFBTTtTQUNuQixDQUFDO1FBRUQsZUFBSSxDQUFDO1lBQ0YsUUFBUSxFQUFFLGdSQU1MO1NBQ1IsQ0FBQzs7YUErQ0Q7SUFBRCxXQUFDO0FBQUQsQ0EzREEsQUEyREMsSUFBQTtBQTdDWSxZQUFJLE9BNkNoQixDQUFBOzs7QUNsRUQsa0VBQWtFO0FBQ2xFLDZEQUE2RDtBQUM3RCw2REFBNkQ7Ozs7Ozs7Ozs7OztBQUU3RCxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFcEIseUJBQXVDLG1CQUFtQixDQUFDLENBQUE7QUFDM0QsdUJBQXVDLGlCQUFpQixDQUFDLENBQUE7QUFJekQsSUFBSSxRQUFRLEdBQUssT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFFekQ7SUFjSTtJQUNBLENBQUM7SUFmTDtRQUFDLG9CQUFTLENBQUM7WUFDUCxRQUFRLEVBQUUsUUFBUTtTQUNyQixDQUFDO1FBRUQsZUFBSSxDQUFDO1lBQ0YsVUFBVSxFQUFFLENBQUMsbUJBQVUsQ0FBQztZQUV4QixRQUFRLEVBQUUsK0NBRUw7U0FDUixDQUFDOztlQU1EO0lBQUQsYUFBQztBQUFELENBaEJBLEFBZ0JDLElBQUE7QUFKWSxjQUFNLFNBSWxCLENBQUE7OztBQzdCRCxrRUFBa0U7QUFDbEUsNkRBQTZEOzs7Ozs7Ozs7Ozs7QUFFN0QseUJBQTRDLG1CQUFtQixDQUFDLENBQUE7QUFFckQsWUFBSSxHQUFHLEVBQUUsQ0FBQztBQUVyQjtJQWlESTtRQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQTtRQUVqRCxpREFBaUQ7UUFDakQsK0RBQStEO1FBRS9ELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSx1QkFBWSxFQUFFLENBQUM7UUFFcEMsSUFBSSxDQUFDLE1BQU0sR0FBTSxJQUFJLENBQUMsQ0FBRSw0QkFBNEI7UUFDcEQsSUFBSSxDQUFDLEtBQUssR0FBTyxJQUFJLENBQUM7UUFFdEIsSUFBSSxDQUFDLElBQUksR0FBUSxZQUFJLENBQUM7UUFFdEIsYUFBYTtRQUNiLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFMUIsT0FBTyxDQUFDLEdBQUcsQ0FBQywwQ0FBMEMsQ0FBQyxDQUFBO0lBQzNELENBQUM7SUFFRCwwQkFBTSxHQUFOO1FBQ0ksa0RBQWtEO1FBQ2xELDREQUE0RDtRQUU1RCxPQUFPLENBQUMsR0FBRyxDQUFDLDZCQUE2QixFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMscUNBQXFDO0lBQ3BFLENBQUM7SUFFRCxrQ0FBYyxHQUFkLFVBQWUsTUFBTSxFQUFFLEtBQUs7UUFDL0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBRWhCLElBQUksQ0FBQyxLQUFLLEdBQUksS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRWQsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVMsUUFBUTtZQUMvQixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELHlCQUFLLEdBQUwsVUFBTSxRQUFRO1FBQ2pCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUVULEVBQUUsQ0FBQyxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQzFCLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQztRQUNYLENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxVQUFTLEtBQUssRUFBRSxRQUFRO1lBQzVELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ1IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyx1QkFBdUIsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLG1EQUFtRDtvQkFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsVUFBUyxLQUFLO3dCQUNyRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzRCQUNSLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO3dCQUN4QyxDQUFDO29CQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNQLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ0osT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3hDLENBQUM7WUFDTCxDQUFDO1lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxrQ0FBa0M7Z0JBQ2pFLE9BQU8sQ0FBQyxHQUFHLENBQUMsMENBQTBDLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDdEUsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNKLE9BQU8sQ0FBQyxHQUFHLENBQUMsaURBQWlELENBQUMsQ0FBQztZQUNuRSxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsMEJBQU0sR0FBTjtRQUNJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsa0NBQWMsR0FBZCxVQUFlLFFBQVE7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUssUUFBUSxDQUFDO1FBRWpDLElBQUksUUFBUSxDQUFDO1FBRWIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNYLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ2pDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNKLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDcEIsQ0FBQztRQUVELE1BQU0sQ0FBQSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDbEIsS0FBSyxRQUFRO2dCQUNULElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFRLElBQUksQ0FBQztnQkFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQztnQkFDcEYsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQztnQkFDckYsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztnQkFDdkUsS0FBSyxDQUFDO1lBQ1Y7Z0JBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQVEsS0FBSyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBUyxJQUFJLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFVLElBQUksQ0FBQztnQkFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO2dCQUNqQyxLQUFLLENBQUM7UUFDVixDQUFDO0lBQ0wsQ0FBQztJQW5KTDtRQUFDLG9CQUFTLENBQUM7WUFDUCxRQUFRLEVBQUUsWUFBWTtZQUN0QixNQUFNLEVBQUksQ0FBQyxXQUFXLENBQUMsQ0FBSywrQ0FBK0M7U0FDOUUsQ0FBQztRQUVELGVBQUksQ0FBQztZQUNGLFFBQVEsRUFBRSx3c0JBaUJQO1NBQ04sQ0FBQzs7a0JBNEhEO0lBQUQsZ0JBQUM7QUFBRCxDQXBKQSxBQW9KQyxJQUFBO0FBMUhZLGlCQUFTLFlBMEhyQixDQUFBOzs7QUMzSkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNub0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ244QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9ub2RlX21vZHVsZXMvYW5ndWxhcjIvYW5ndWxhcjIuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy9maXJlYmFzZS9maXJlYmFzZS5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi90eXBpbmdzL3JlcXVpcmVqcy9yZXF1aXJlLmQudHNcIiAvPlxuXG5yZXF1aXJlKFwiZmlyZWJhc2VcIik7XG5yZXF1aXJlKFwiYm9vdHN0cmFwXCIpO1xuXG5pbXBvcnQge0NvbXBvbmVudCwgVmlldywgYm9vdHN0cmFwLCBwcm92aWRlfSAgICAgICAgICAgICAgICAgICAgIGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcblxuaW1wb3J0IHtST1VURVJfUFJPVklERVJTLCBSb3V0ZUNvbmZpZywgUm91dGVyfSAgICAgICAgICAgICAgICAgICBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xuaW1wb3J0IHtSb3V0ZSwgTG9jYXRpb24sIExvY2F0aW9uU3RyYXRlZ3ksIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xuaW1wb3J0IHtSb3V0ZXJMaW5rLCBSb3V0ZXJPdXRsZXR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xuXG5pbXBvcnQge1VzZXJCbG9ja30gZnJvbSAnLi91c2Vycyc7XG5pbXBvcnQge1NpZ25Jbn0gICAgZnJvbSAnLi9zaWduaW4nO1xuaW1wb3J0IHtQbGFufSAgICAgIGZyb20gJy4vcGxhbic7XG5cbmRlY2xhcmUgdmFyIGpRdWVyeTphbnk7XG5cbnZhciBGaXJlYmFzZSAgID0gcmVxdWlyZSgnZmlyZWJhc2UvbGliL2ZpcmViYXNlLXdlYi5qcycpO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FwcCdcbn0pXG5cbkBWaWV3KHtcbiAgICBkaXJlY3RpdmVzOiBbUm91dGVyTGluaywgUm91dGVyT3V0bGV0LCBVc2VyQmxvY2tdLFxuXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHVzZXItYmxvY2sgKGluaXRldmVudCk9XCJyZWdpc3RlclVzZXJCbG9jaygkZXZlbnQpXCI+IDwvdXNlci1ibG9jaz5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgYFxufSlcblxuQFJvdXRlQ29uZmlnKFtcbiAgICB7IHBhdGg6ICcvcGxhbicsICAgIGFzOiAnUGxhbicsICAgY29tcG9uZW50OiBQbGFuIH0sXG4gICAgeyBwYXRoOiAnL3NpZ25pbicsICBhczogJ1NpZ25JbicsIGNvbXBvbmVudDogU2lnbkluIH1cbl0pXG5cbmNsYXNzIFN0dWR5VHJhY2tlciB7XG4gICAgdXNlckJsb2NrICAgOiBVc2VyQmxvY2s7XG4gICAgZmJSZWYgICAgICAgOiBGaXJlYmFzZTtcbiAgICByb3V0ZXIgICAgICA6IFJvdXRlcjtcblxuICAgIGNvbnN0cnVjdG9yKHJvdXRlciA6IFJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5mYlJlZiAgPSBuZXcgRmlyZWJhc2UoJ2h0dHBzOi8vc3R1ZHktdHJhY2tlci5maXJlYmFzZWlvLmNvbScpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm1haW4udHM6IGluIFN0dWR5VHJhY2tlciBjb25zdHJ1Y3RvclwiKVxuICAgIH1cblxuICAgIHJlZ2lzdGVyVXNlckJsb2NrKHVzZXJDb21wKSB7XG4gICAgICAgIHRoaXMudXNlckJsb2NrID0gdXNlckNvbXA7XG4gICAgICAgIHVzZXJDb21wLnJlZ2lzdGVyUGFyZW50KHRoaXMsIHRoaXMuZmJSZWYpO1xuXG5cdC8vIE5PVEU6IGhlcmUgd2UgdXNlIHRoZSByb3V0ZXIgKm5hbWUqIG5vdCB0aGUgYWN0dWFsIHJvdXRlIFVSTCFcblx0dGhpcy5yb3V0ZXIubmF2aWdhdGUoWycuL1BsYW4nXSk7ICAgIC8vIFNpZ25JblxuICAgIH1cbn1cblxuLy8gc2ltaWxhciB0byBqUXVlcnkoZG9jdW1lbnQpLnJlYWR5KCksIGJ1dCBkb2Vzbid0IHdvcmsgaW4gb2xkIElFIGJyb3dzZXJzXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKXsgXG4gICAgYm9vdHN0cmFwKFN0dWR5VHJhY2tlciwgXG5cbiAgICAgICAgICAgICAgLy8gTGlzdCBvZiB1bml2ZXJzYWxseSBpbmplY3RhYmxlIHByb3ZpZGVyc1xuICAgICAgICAgICAgICBbXG5cdFx0ICBST1VURVJfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZShMb2NhdGlvblN0cmF0ZWd5LCB7dXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5fSlcbiAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICAgKTtcblxufSwgZmFsc2UpO1xuXG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyL2FuZ3VsYXIyLmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvcmVxdWlyZWpzL3JlcXVpcmUuZC50c1wiIC8+XG5cbmltcG9ydCB7Q29tcG9uZW50LCBWaWV3fSAgIGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcblxuZGVjbGFyZSB2YXIgalF1ZXJ5OmFueTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwbGFuJ1xufSlcblxuQFZpZXcoe1xuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1wcm92aWRlPVwidHlwZWFoZWFkXCIgaWQ9XCJjYXRlZ29yeS1zZWxlY3RcIiBwbGFjZWhvbGRlcj1cIkVudGVyIGEgY2xhc3NcIj5cblxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsYXBzZVwiIGlkPVwiY2F0ZWdvcnktYWRkXCI+XG4gIFx0ICAgIFNlbGVjdCBhIGNvbG9yIGZvciBuZXcgY2xhc3MgPGIgaWQ9XCJjYXRlZ29yeS1hZGQtbmFtZVwiPjwvYj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYFxufSlcblxuZXhwb3J0IGNsYXNzIFBsYW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInBsYW4udHM6IGluIGNvbnN0cnVjdG9yXCIpXG5cbiAgICAgICAgdmFyIGRhdGEgPSBbeyBpZDogMSwgY29sb3I6ICdibHVlJywgICAgbmFtZTogJ1NjaWVuY2UnIH0sIFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiAyLCBjb2xvcjogJ3JlZCcsICAgICBuYW1lOiAnTWF0aCcgfSwgXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IDMsIGNvbG9yOiAnI0FBMjJCQicsIG5hbWU6ICdFbmdsaXNoJyB9LCBcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogNCwgY29sb3I6ICcjMjIyJywgICAgbmFtZTogJ0FydCcgfV07XG5cbiAgICAgICAgalF1ZXJ5KFwiI2NhdGVnb3J5LXNlbGVjdFwiKS50eXBlYWhlYWQoe1xuICAgICAgICAgICAgc291cmNlICAgICAgICAgIDogZGF0YSxcbiAgICAgICAgICAgIG1pbkxlbmd0aCAgICAgICA6IDAsXG4gICAgICAgICAgICBzaG93SGludE9uRm9jdXMgOiB0cnVlLFxuICAgICAgICAgICAgYWRkSXRlbSAgICAgICAgIDogeyBpZDogLTEsIG5hbWU6ICcoQWRkIGNsYXNzKScgfSxcblx0ICAgIGZvcm1hdHRlciAgIDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBodG1sID0gdGhpcy5oaWdobGlnaHRlcih0aGlzLmRpc3BsYXlUZXh0KGl0ZW0pKTtcblx0XHRpZiAoaXRlbS5jb2xvcikge1xuXHRcdCAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1jb2xvci1ib3hcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGl0ZW0uY29sb3IgKyAnXCI+IDwvZGl2PicgKyBodG1sO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cImRyb3Bkb3duLWNvbG9yLWJveFwiPiA8L2Rpdj4nICsgaHRtbDtcblx0XHR9XG5cdFx0cmV0dXJuIGh0bWxcblx0ICAgIH0sXG4gICAgICAgICAgICBhZnRlclNlbGVjdCAgICAgOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZWxlY3RlZFwiLCBpdGVtKTtcblx0XHRpZiAoaXRlbS5pZCA9PT0gLTIpIHtcblx0XHQgICAgalF1ZXJ5KFwiI2NhdGVnb3J5LWFkZC1uYW1lXCIpLnRleHQoaXRlbS5uYW1lKTtcblx0XHQgICAgalF1ZXJ5KFwiI2NhdGVnb3J5LWFkZFwiKS5zaG93KCk7XG5cdFx0fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZXIgICAgICAgICA6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtpZCA6IC0yLCBuYW1lIDogdGhpcy4kZWxlbWVudC52YWwoKSB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblx0Ly8gRml4IGZvciBidWcgaW4gSU9TIGFzIHJlcG9ydGVkOlxuXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMTkwNzgzL3doeS1kb2VzbnQtYm9vdHN0cmFwLWJ1dHRvbi1kcm9wZG93bi13b3JrLW9uLWlvc1xuXHRqUXVlcnkoJ2JvZHknKS5vbigndG91Y2hzdGFydC5kcm9wZG93bicsICcuZHJvcGRvd24tbWVudScsIGZ1bmN0aW9uIChlKSB7IFxuXHQgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgXG5cdH0pO1xuICAgIH1cbn1cblxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL25vZGVfbW9kdWxlcy9hbmd1bGFyMi9hbmd1bGFyMi5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi90eXBpbmdzL2ZpcmViYXNlL2ZpcmViYXNlLmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvcmVxdWlyZWpzL3JlcXVpcmUuZC50c1wiIC8+XG5cbnJlcXVpcmUoXCJmaXJlYmFzZVwiKTtcblxuaW1wb3J0IHtDb21wb25lbnQsIFZpZXd9ICAgICAgICAgIGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcbmltcG9ydCB7Um91dGVyTGlua30gICAgICAgICAgICAgICBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xuXG5kZWNsYXJlIHZhciBqUXVlcnk6YW55O1xuXG52YXIgRmlyZWJhc2UgICA9IHJlcXVpcmUoJ2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMnKTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdzaWduaW4nXG59KVxuXG5AVmlldyh7XG4gICAgZGlyZWN0aXZlczogW1JvdXRlckxpbmtdLFxuXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGgxPiBQbGVhc2Ugc2lnbiBpbiA8L2gxPlxuICAgICAgICBgXG59KVxuXG5leHBvcnQgY2xhc3MgU2lnbkluIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9ub2RlX21vZHVsZXMvYW5ndWxhcjIvYW5ndWxhcjIuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy9maXJlYmFzZS9maXJlYmFzZS5kLnRzXCIgLz5cblxuaW1wb3J0IHtDb21wb25lbnQsIFZpZXcsIEV2ZW50RW1pdHRlcn0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xuXG5leHBvcnQgdmFyIFVzZXIgPSB7fTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1c2VyLWJsb2NrJyxcbiAgICBldmVudHM6ICAgWydpbml0ZXZlbnQnXSAgICAgLy8gTk9URSB0aGF0IGV2ZW50IG5hbWVzIG11c3QgYmUgYWxsIGxvd2VyIGNhc2Vcbn0pXG5cbkBWaWV3KHtcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2lnbmluLWZvcm1cIj5cbiAgICAgICAgICA8ZGl2IFtoaWRkZW5dPVwidXNlci5pc0xvZ2dlZEluXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3M9XCJmb3JtLXNpZ25pbi1oZWFkaW5nXCI+UGxlYXNlIHNpZ24gaW4gdXNpbmc6PC9oMz5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWxnIGJ0bi1wcmltYXJ5IGJ0bi1ibG9ja1wiIChjbGljayk9XCJsb2dpbignZ29vZ2xlJylcIj4gIEdvb2dsZSAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1sZyBidG4tcHJpbWFyeSBidG4tYmxvY2tcIiAoY2xpY2spPVwibG9naW4oJ2ZhY2Vib29rJylcIj5GYWNlYm9vazwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBbaGlkZGVuXT1cIiF1c2VyLmlzTG9nZ2VkSW5cIj5cbiAgICAgICAgICAgIEhlbGxvIHt7dXNlci5maXJzdE5hbWV9fSA8aW1nIHNyYz1cInt7dXNlci5wcm9maWxlSW1hZ2VVUkx9fVwiLz4gXG4gICAgICAgICAgICA8YSBjbGFzcz1cImJ0blwiIChjbGljayk9XCJsb2dvdXQoKVwiPlxuICAgICAgICAgICAgICBTaWduIG91dFxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgYFxufSlcblxuZXhwb3J0IGNsYXNzIFVzZXJCbG9jayB7XG4gICAgdXNlciA6IGFueTtcbiAgICBcbiAgICAvL1xuICAgIC8vIEN1cnJlbnRseSBhIDMtc3RlcCBpbml0aWFsaXphdGlvbiB0byBob29rLXVwIGNoaWxkIHRvIHBhcmVudCBjb21wb25lbnRzXG4gICAgLy9cbiAgICAvLyAgIGNvbnN0cnVjdG9yKCkgLSBbbmFtZSBmaXhlZCBieSBKUy9UeXBlc2NyaXB0XSBsb2NhbCAobm9uLWFuZ3VsYXIyLWRlcGVuZGVudCkgZGF0YSBvbmx5IFxuICAgIC8vXG4gICAgLy8gICBvbkluaXQoKSAgICAgIC0gW25hbWUgZml4ZWQgYnkgYW5ndWxhcjJdIGFuZ3VsYXIyIGxpZmVjeWNsZSBpbml0LWRvbmUgZXZlbnQgY2FsbGJhY2sgXG4gICAgLy8gICAgICAgICAgICAgICAgICAgR2VuZXJhdGUgYSBpbml0ZXZlbnQgW0RCIGNvbnZlbnRpb24gbmFtZV0gdG8gYWxlcnQgcGFyZW50IG9mIG5ldyBjaGlsZCBjb21wb25lbnQuXG4gICAgLy8gICAgICAgICAgICAgICAgICAgKFBhcmVudCBjb21wb25lbnQgd2lsbCB0aGVuIHR5cGljYWxseSBoYXZlIGEgcmVnaXN0ZXI8Q2hpbGRDb21wb25lbnRUeXBlPigpIGV2ZW50IGhhbmRsZXIpXG4gICAgLy9cbiAgICAvLyAgIHJlZ2lzdGVyUGFyZW50KCkgLSBbREIgY29udmVudGlvbiBuYW1lXSBjYWxsZWQgYnkgcGFyZW50IGNvbXBvbmVudFxuICAgIC8vXG4gICAgLy8gVE9ETzogRWFzaWVyIG1ldGhvZCB0byBnZXQgcG9pbnRlcnMgdG8gcGFyZW50ICYgY2hpbGRyZW4gY29tcG9uZW50cyBcbiAgICAvLyAgICAgICAoYW5kL29yIHRoZWlyIG5lZWRlZCBkYXRhKVxuICAgIC8vXG4gICAgLy9cblxuICAgIHBhcmVudCAgICAgICAgOiBhbnk7ICBcbiAgICBmYlJlZiAgICAgICAgIDogRmlyZWJhc2U7ICAgICAgLy8gVG9EbzogdXNlIGRlcGVuZGVuY3kgaW5qZWN0b3IgdG8gZ2V0IERhdGFiYXNlIHNlcnZpY2VcbiAgICBpbml0ZXZlbnQgICAgIDogRXZlbnRFbWl0dGVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidXNlcnMudHM6IGluIFVzZXJCbG9jayBjb25zdHJ1Y3RvclwiKVxuXG4gICAgICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSBsb2NhbGx5IGluc3RhdGlhdGVkIGRhdGEgaGVyZSBcbiAgICAgICAgLy8gKGFuZ3VsYXIyLWRlcGVuZGVudCBkYXRhIGhhcyBub3QgeWV0IGJlZW4gZnVsbHkgaW5pdGlhbGl6ZWQpXG5cbiAgICAgICAgdGhpcy5pbml0ZXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQgICAgPSBudWxsOyAgLy8gd2lsbCBiZSBzZXQgYnkgdGhlIHBhcmVudFxuICAgICAgICB0aGlzLmZiUmVmICAgICA9IG51bGw7XG5cbiAgICAgICAgdGhpcy51c2VyICAgICAgPSBVc2VyO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgICAgdGhpcy51cGRhdGVVc2VyRGF0YShudWxsKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcInVzZXJzLnRzOiBmaW5pc2hlZCBVc2VyQmxvY2sgY29uc3RydWN0b3JcIilcbiAgICB9XG5cbiAgICBvbkluaXQoKSB7XG4gICAgICAgIC8vIG9uSW5pdCgpIGlzIGEgYW5ndWxhcjIgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW5ndWxhcjIgaGFzIGNvbXBsZXRlZCBpbml0aWFsaXphdGlvblxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwib25Jbml0OiBmb3IgVXNlcnMgQ29tcG9uZW50XCIsIHRoaXMpO1xuICAgICAgICB0aGlzLmluaXRldmVudC5uZXh0KHRoaXMpOyAvLyBzZW5kIGluaXRldmVudCB0byBwYXJlbnQgY29tcG9uZW50XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJQYXJlbnQocGFyZW50LCBmYlJlZikge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0dGhpcy5mYlJlZiAgPSBmYlJlZjtcblx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrXG4gICAgICAgIHRoaXMuZmJSZWYub25BdXRoKGZ1bmN0aW9uKGF1dGhEYXRhKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVVzZXJEYXRhKGF1dGhEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9naW4ocHJvdmlkZXIpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmIChwcm92aWRlciA9PT0gJ2ZhY2Vib29rJykge1xuICAgICAgICAgICAgYWxlcnQoXCJTb3JyeSwgRmFjZWJvb2sgc2lnbmluIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mYlJlZi5hdXRoV2l0aE9BdXRoUG9wdXAocHJvdmlkZXIsIGZ1bmN0aW9uKGVycm9yLCBhdXRoRGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgZHVlIHRvIG5vdCBhbGxvd2luZyBwb3AtdXBzIGluIHRoaXMgZW52XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmJSZWYuYXV0aFdpdGhPQXV0aFJlZGlyZWN0KFwiZ29vZ2xlXCIsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvZ2luIEZhaWxlZCFcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpbiBGYWlsZWQhXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF1dGhEYXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVVc2VyRGF0YShhdXRoRGF0YSk7IC8vIGFjY2VsZXJhdGUgdGhlIHByb2Nlc3MgYSBsaXR0bGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkF1dGhlbnRpY2F0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggcGF5bG9hZDpcIiwgYXV0aERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvZ2luIGFwcGFyZW50bHkgZmFpbGVkLCBidXQgd2l0aG91dCBlcnJvciBpbmZvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2dvdXQoKSB7XG4gICAgICAgIHRoaXMuZmJSZWYudW5hdXRoKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVXNlckRhdGEobnVsbCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVXNlckRhdGEoYXV0aERhdGEpIHtcbiAgICAgICAgdGhpcy51c2VyLl9hdXRoRGF0YSAgID0gYXV0aERhdGE7XG5cbiAgICAgICAgdmFyIHByb3ZpZGVyO1xuXG4gICAgICAgIGlmIChhdXRoRGF0YSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBhdXRoRGF0YS5wcm92aWRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChwcm92aWRlcikge1xuICAgICAgICBjYXNlICdnb29nbGUnOlxuICAgICAgICAgICAgdGhpcy51c2VyLmlzTG9nZ2VkSW4gICAgICA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVzZXIuZmlyc3ROYW1lICAgICAgID0gdGhpcy51c2VyLl9hdXRoRGF0YS5nb29nbGUuY2FjaGVkVXNlclByb2ZpbGUuZ2l2ZW5fbmFtZTtcbiAgICAgICAgICAgIHRoaXMudXNlci5sYXN0TmFtZSAgICAgICAgPSB0aGlzLnVzZXIuX2F1dGhEYXRhLmdvb2dsZS5jYWNoZWRVc2VyUHJvZmlsZS5mYW1pbHlfbmFtZTtcbiAgICAgICAgICAgIHRoaXMudXNlci5wcm9maWxlSW1hZ2VVUkwgPSB0aGlzLnVzZXIuX2F1dGhEYXRhLmdvb2dsZS5wcm9maWxlSW1hZ2VVUkw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMudXNlci5pc0xvZ2dlZEluICAgICAgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXNlci5maXJzdE5hbWUgICAgICAgPSBudWxsOyBcbiAgICAgICAgICAgIHRoaXMudXNlci5sYXN0TmFtZSAgICAgICAgPSBudWxsOyBcbiAgICAgICAgICAgIHRoaXMudXNlci5wcm9maWxlSW1hZ2VVUkwgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY29yZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9wcm9maWxlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2xpZmVjeWNsZV9ob29rcycpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9ib290c3RyYXAnKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuZ3VsYXIyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogVGhpcyBmaWxlIGlzIG9ubHkgdXNlZCBmb3IgZGFydCBhcHBsaWNhdGlvbnMgYW5kIGZvciBpbnRlcm5hbCBleGFtcGxlc1xyXG4gKiB0aGF0IGNvbXBpbGUgd2l0aCBib3RoIEphdmFTY3JpcHQgYW5kIERhcnQuXHJcbiAqL1xyXG52YXIgYm9vdHN0cmFwXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9ib290c3RyYXAnKTtcclxuZXhwb3J0cy5ib290c3RyYXAgPSBib290c3RyYXBfMS5ib290c3RyYXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbi8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTdGFydGluZyBwb2ludCB0byBpbXBvcnQgYWxsIHB1YmxpYyBjb3JlIEFQSXMuXHJcbiAqL1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL21ldGFkYXRhJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL3V0aWwnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvZGknKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvcGlwZXMnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvZmFjYWRlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2FwcGxpY2F0aW9uJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2Jvb3RzdHJhcCcpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9zZXJ2aWNlcycpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9saW5rZXInKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvbGlmZWN5Y2xlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL3pvbmUnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvcmVuZGVyJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9jb3JlL2RpcmVjdGl2ZXMnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvZm9ybXMnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvZGVidWcnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbicpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERlZmluZXMgaW50ZXJmYWNlcyB0byBiZSBpbXBsZW1lbnRlZCBieSBkaXJlY3RpdmVzIHdoZW4gdGhleSBuZWVkIHRvIGhvb2sgaW50byB0aGUgY2hhbmdlXHJcbiAqIGRldGVjdGlvbiBtZWNoYW5pc20uXHJcbiAqL1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlY3ljbGVfaG9va3MuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX1N1YnNjcmliZXIgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcblxudmFyIF9TdWJzY3JpYmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmliZXIpO1xuXG52YXIgX3V0aWxTeW1ib2xfb2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4vdXRpbC9TeW1ib2xfb2JzZXJ2YWJsZScpO1xuXG52YXIgX3V0aWxTeW1ib2xfb2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsU3ltYm9sX29ic2VydmFibGUpO1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xuXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXMgaW5pdGlhbGx5IHN1YnNjcmliZWQgdG8uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBTdWJzY3JpYmVyLCB0byB3aGljaCBuZXcgdmFsdWVzXG4gICAgICogY2FuIGJlIGBuZXh0YGVkLCBvciBhbiBgZXJyb3JgIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJhaXNlIGFuIGVycm9yLCBvciBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5XG4gICAgICogb2YgYSBzdWNjZXNmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYnNlcnZhYmxlKTtcblxuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmUuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICogQGRlc2NyaXB0aW9uIGNyZWF0ZXMgYSBuZXcgY29sZCBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgbGlmdFxuICAgICAqIEBwYXJhbSB7T3BlcmF0b3J9IHRoZSBvcGVyYXRvciBkZWZpbmluZyB0aGUgb3BlcmF0aW9uIHRvIHRha2Ugb24gdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICogQGRlc2NyaXB0aW9uIGNyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSwgd2l0aCB0aGlzIE9ic2VydmFibGUgYXMgdGhlIHNvdXJjZSwgYW5kIHRoZSBwYXNzZWRcbiAgICAgKiBvcGVyYXRvciBkZWZpbmVkIGFzIHRoZSBuZXcgb2JzZXJ2YWJsZSdzIG9wZXJhdG9yLlxuICAgICAqL1xuXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIGxpZnQob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgU3ltYm9sLm9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBkZXNjcmlwdGlvbiBhbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgICAqL1xuXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbX3V0aWxTeW1ib2xfb2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8RnVuY3Rpb259IG9ic2VydmVyT3JOZXh0IChvcHRpb25hbCkgZWl0aGVyIGFuIG9ic2VydmVyIGRlZmluaW5nIGFsbCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLFxuICAgICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBhbiBlcnJvci4gSWYgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZCxcbiAgICAgKiAgdGhlIGVycm9yIHdpbGwgYmUgdGhyb3duIGFzIHVuaGFuZGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJucyB7U3Vic2NyaXB0aW9ufSBhIHN1YnNjcmlwdGlvbiByZWZlcmVuY2UgdG8gdGhlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICAgKiBAZGVzY3JpcHRpb24gcmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBoYW5kbGluZyBlbWl0dGVkIHZhbHVlcywgZXJyb3IgYW5kIGNvbXBsZXRpb25zIGZyb20gdGhlIG9ic2VydmFibGUsIGFuZFxuICAgICAqICBleGVjdXRlcyB0aGUgb2JzZXJ2YWJsZSdzIHN1YnNjcmliZXIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgdGFrZSBhY3Rpb24gdG8gc2V0IHVwIHRoZSB1bmRlcmx5aW5nIGRhdGEgc3RyZWFtXG4gICAgICovXG5cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG9ic2VydmVyT3JOZXh0ICYmIHR5cGVvZiBvYnNlcnZlck9yTmV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyT3JOZXh0IGluc3RhbmNlb2YgX1N1YnNjcmliZXIyWydkZWZhdWx0J10pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIgPSBuZXcgX1N1YnNjcmliZXIyWydkZWZhdWx0J10ob2JzZXJ2ZXJPck5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgICAgIHN1YnNjcmliZXIgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5jcmVhdGUobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZCh0aGlzLl9zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXMgb24gb2JzZXJ2YWJsZSBjb21wbGV0aW9uIG9yXG4gICAgICogIHJlamVjdHMgd2l0aCB0aGUgaGFuZGxlZCBlcnJvclxuICAgICAqL1xuXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobmV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmUobmV4dCwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiBfc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLl9zdWJzY3JpYmUodGhpcy5vcGVyYXRvci5jYWxsKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBPYnNlcnZhYmxlO1xuT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX09ic2VydmFibGUyID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG5cbnZhciBfT2JzZXJ2YWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYnNlcnZhYmxlMik7XG5cbnZhciBfU3Vic2NyaWJlciA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuXG52YXIgX1N1YnNjcmliZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaWJlcik7XG5cbnZhciBfU3Vic2NyaXB0aW9uID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaXB0aW9uKTtcblxudmFyIF9zdWJqZWN0c1N1YmplY3RTdWJzY3JpcHRpb24gPSByZXF1aXJlKCcuL3N1YmplY3RzL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcblxudmFyIF9zdWJqZWN0c1N1YmplY3RTdWJzY3JpcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ViamVjdHNTdWJqZWN0U3Vic2NyaXB0aW9uKTtcblxudmFyIHN1YnNjcmlwdGlvbkFkZCA9IF9TdWJzY3JpcHRpb24yWydkZWZhdWx0J10ucHJvdG90eXBlLmFkZDtcbnZhciBzdWJzY3JpcHRpb25SZW1vdmUgPSBfU3Vic2NyaXB0aW9uMlsnZGVmYXVsdCddLnByb3RvdHlwZS5yZW1vdmU7XG52YXIgc3Vic2NyaXB0aW9uVW5zdWJzY3JpYmUgPSBfU3Vic2NyaXB0aW9uMlsnZGVmYXVsdCddLnByb3RvdHlwZS51bnN1YnNjcmliZTtcbnZhciBzdWJzY3JpYmVyTmV4dCA9IF9TdWJzY3JpYmVyMlsnZGVmYXVsdCddLnByb3RvdHlwZS5uZXh0O1xudmFyIHN1YnNjcmliZXJFcnJvciA9IF9TdWJzY3JpYmVyMlsnZGVmYXVsdCddLnByb3RvdHlwZS5lcnJvcjtcbnZhciBzdWJzY3JpYmVyQ29tcGxldGUgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuY29tcGxldGU7XG52YXIgX3N1YnNjcmliZXJOZXh0ID0gX1N1YnNjcmliZXIyWydkZWZhdWx0J10ucHJvdG90eXBlLl9uZXh0O1xudmFyIF9zdWJzY3JpYmVyRXJyb3IgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuX2Vycm9yO1xudmFyIF9zdWJzY3JpYmVyQ29tcGxldGUgPSBfU3Vic2NyaWJlcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuX2NvbXBsZXRlO1xudmFyIF9vYnNlcnZhYmxlU3Vic2NyaWJlID0gX09ic2VydmFibGUzWydkZWZhdWx0J10ucHJvdG90eXBlLl9zdWJzY3JpYmU7XG5cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfT2JzZXJ2YWJsZSkge1xuICAgIF9pbmhlcml0cyhTdWJqZWN0LCBfT2JzZXJ2YWJsZSk7XG5cbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ViamVjdCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBfT2JzZXJ2YWJsZS5jYWxsLmFwcGx5KF9PYnNlcnZhYmxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JTaWduYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZVNpZ25hbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWRpcmVjdGlvbmFsU3ViamVjdChzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIGxpZnQob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQmlkaXJlY3Rpb25hbFN1YmplY3QodGhpcywgdGhpcy5kZXN0aW5hdGlvbiB8fCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIF9zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXJyb3JTaWduYWwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy5lcnJvckluc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbXBsZXRlU2lnbmFsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1YnNjcmliZSB0byBhIGRpc3Bvc2VkIFN1YmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgX3N1YmplY3RzU3ViamVjdFN1YnNjcmlwdGlvbjJbJ2RlZmF1bHQnXSh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuXG4gICAgU3ViamVjdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBzdWJzY3JpcHRpb25BZGQuY2FsbCh0aGlzLCBzdWJzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvblJlbW92ZS5jYWxsKHRoaXMsIHN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdm9pZCAwO1xuICAgICAgICBzdWJzY3JpcHRpb25VbnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lcnJvclNpZ25hbCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLmVycm9ySW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29tcGxldGVTaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCB8fCB0aGlzLmNvbXBsZXRlU2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvclNpZ25hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3JJbnN0YW5jZSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihfZXJyb3IpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5zdWJzY3JpYmVkIHx8IHRoaXMuZXJyb3JTaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBsZXRlU2lnbmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKTtcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnNbaW5kZXhdLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIF9lcnJvcihlcnJvcikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIC0tIGJsb2NrIG5leHQsIGNvbXBsZXRlLCBhbmQgdW5zdWJzY3JpYmUgd2hpbGUgZGlzcGF0Y2hpbmdcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzW2luZGV4XS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiBfY29tcGxldGUoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICAvLyBvcHRpbWl6YXRpb24gLS0gYmxvY2sgbmV4dCwgY29tcGxldGUsIGFuZCB1bnN1YnNjcmliZSB3aGlsZSBkaXNwYXRjaGluZ1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IHZvaWQgMDsgLy8gb3B0aW1pemF0aW9uXG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzW2luZGV4XS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KShfT2JzZXJ2YWJsZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN1YmplY3Q7XG5cbnZhciBCaWRpcmVjdGlvbmFsU3ViamVjdCA9IChmdW5jdGlvbiAoX1N1YmplY3QpIHtcbiAgICBfaW5oZXJpdHMoQmlkaXJlY3Rpb25hbFN1YmplY3QsIF9TdWJqZWN0KTtcblxuICAgIGZ1bmN0aW9uIEJpZGlyZWN0aW9uYWxTdWJqZWN0KHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJpZGlyZWN0aW9uYWxTdWJqZWN0KTtcblxuICAgICAgICBfU3ViamVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cblxuICAgIEJpZGlyZWN0aW9uYWxTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQoeCkge1xuICAgICAgICBzdWJzY3JpYmVyTmV4dC5jYWxsKHRoaXMsIHgpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlKSB7XG4gICAgICAgIHN1YnNjcmliZXJFcnJvci5jYWxsKHRoaXMsIGUpO1xuICAgIH07XG5cbiAgICBCaWRpcmVjdGlvbmFsU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgc3Vic2NyaWJlckNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIEJpZGlyZWN0aW9uYWxTdWJqZWN0LnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIF9uZXh0KHgpIHtcbiAgICAgICAgX3N1YnNjcmliZXJOZXh0LmNhbGwodGhpcywgeCk7XG4gICAgfTtcblxuICAgIEJpZGlyZWN0aW9uYWxTdWJqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiBfZXJyb3IoZSkge1xuICAgICAgICBfc3Vic2NyaWJlckVycm9yLmNhbGwodGhpcywgZSk7XG4gICAgfTtcblxuICAgIEJpZGlyZWN0aW9uYWxTdWJqZWN0LnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiBfY29tcGxldGUoKSB7XG4gICAgICAgIF9zdWJzY3JpYmVyQ29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJpZGlyZWN0aW9uYWxTdWJqZWN0O1xufSkoU3ViamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF91dGlsTm9vcCA9IHJlcXVpcmUoJy4vdXRpbC9ub29wJyk7XG5cbnZhciBfdXRpbE5vb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbE5vb3ApO1xuXG52YXIgX3V0aWxUaHJvd0Vycm9yID0gcmVxdWlyZSgnLi91dGlsL3Rocm93RXJyb3InKTtcblxudmFyIF91dGlsVGhyb3dFcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsVGhyb3dFcnJvcik7XG5cbnZhciBfdXRpbFRyeU9yT25FcnJvciA9IHJlcXVpcmUoJy4vdXRpbC90cnlPck9uRXJyb3InKTtcblxudmFyIF91dGlsVHJ5T3JPbkVycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxUcnlPck9uRXJyb3IpO1xuXG52YXIgX1N1YnNjcmlwdGlvbjIgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuXG52YXIgX1N1YnNjcmlwdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJzY3JpcHRpb24yKTtcblxudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9TdWJzY3JpcHRpb24pIHtcbiAgICBfaW5oZXJpdHMoU3Vic2NyaWJlciwgX1N1YnNjcmlwdGlvbik7XG5cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzY3JpYmVyKTtcblxuICAgICAgICBfU3Vic2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBkZXN0aW5hdGlvbi5fc3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKCk7XG4gICAgICAgIHN1YnNjcmliZXIuX25leHQgPSB0eXBlb2YgbmV4dCA9PT0gXCJmdW5jdGlvblwiICYmIF91dGlsVHJ5T3JPbkVycm9yMlsnZGVmYXVsdCddKG5leHQpIHx8IF91dGlsTm9vcDJbJ2RlZmF1bHQnXTtcbiAgICAgICAgc3Vic2NyaWJlci5fZXJyb3IgPSB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIiAmJiBlcnJvciB8fCBfdXRpbFRocm93RXJyb3IyWydkZWZhdWx0J107XG4gICAgICAgIHN1YnNjcmliZXIuX2NvbXBsZXRlID0gdHlwZW9mIGNvbXBsZXRlID09PSBcImZ1bmN0aW9uXCIgJiYgY29tcGxldGUgfHwgX3V0aWxOb29wMlsnZGVmYXVsdCddO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiBfZXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gX2NvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzdWIpIHtcbiAgICAgICAgLy8gcm91dGUgYWRkIHRvIHRoZSBzaGFyZWQgU3Vic2NyaXB0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICB2YXIgX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKF9zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb24uYWRkKHN1Yik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBzdWIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzdWIpIHtcbiAgICAgICAgLy8gcm91dGUgcmVtb3ZlIHRvIHRoZSBzaGFyZWQgU3Vic2NyaXB0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24ucmVtb3ZlKHN1Yik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBzdWIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5faXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX1N1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoX2Vycm9yMikge1xuICAgICAgICBpZiAoIXRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKF9lcnJvcjIpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3Vic2NyaWJlciwgW3tcbiAgICAgICAga2V5OiAnaXNVbnN1YnNjcmliZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcm91dGUgdG8gdGhlIHNoYXJlZCBTdWJzY3JpcHRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVW5zdWJzY3JpYmVkIHx8IHN1YnNjcmlwdGlvbi5pc1Vuc3Vic2NyaWJlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVW5zdWJzY3JpYmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyByb3V0ZSB0byB0aGUgc2hhcmVkIFN1YnNjcmlwdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNVbnN1YnNjcmliZWQgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufSkoX1N1YnNjcmlwdGlvbjNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN1YnNjcmliZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKF91bnN1YnNjcmliZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChfdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gX3Vuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiBfdW5zdWJzY3JpYmUoKSB7fTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gdGhpcy5fdW5zdWJzY3JpYmU7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zW2luZGV4XS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAvLyByZXR1cm4gZWFybHkgaWY6XG4gICAgICAgIC8vICAxLiB0aGUgc3Vic2NyaXB0aW9uIGlzIG51bGxcbiAgICAgICAgLy8gIDIuIHdlJ3JlIGF0dGVtcHRpbmcgdG8gYWRkIG91ciB0aGlzXG4gICAgICAgIC8vICAzLiB3ZSdyZSBhdHRlbXB0aW5nIHRvIGFkZCB0aGUgc3RhdGljIGBlbXB0eWAgU3Vic2NyaXB0aW9uXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uIHx8IHN1YnNjcmlwdGlvbiA9PT0gdGhpcyB8fCBzdWJzY3JpcHRpb24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgc3ViID0gbmV3IFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGlmIChzdWIuaXNVbnN1YnNjcmliZWQgfHwgdHlwZW9mIHN1Yi51bnN1YnNjcmliZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnMgfHwgKHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgc3Vic2NyaXB0aW9uICcgKyBzdWJzY3JpcHRpb24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmOlxuICAgICAgICAvLyAgMS4gdGhlIHN1YnNjcmlwdGlvbiBpcyBudWxsXG4gICAgICAgIC8vICAyLiB3ZSdyZSBhdHRlbXB0aW5nIHRvIHJlbW92ZSBvdXJ0aGlzXG4gICAgICAgIC8vICAzLiB3ZSdyZSBhdHRlbXB0aW5nIHRvIHJlbW92ZSB0aGUgc3RhdGljIGBlbXB0eWAgU3Vic2NyaXB0aW9uXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCB8fCBzdWJzY3JpcHRpb24gPT09IHRoaXMgfHwgc3Vic2NyaXB0aW9uID09PSBTdWJzY3JpcHRpb24uRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0pKCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3Vic2NyaXB0aW9uO1xuXG5TdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgZW1wdHkuaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgIHJldHVybiBlbXB0eTtcbn0pKG5ldyBTdWJzY3JpcHRpb24oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9TdWJzY3JpcHRpb24yID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbjIpO1xuXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX1N1YnNjcmlwdGlvbikge1xuICAgIF9pbmhlcml0cyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfU3Vic2NyaXB0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YmplY3RTdWJzY3JpcHRpb24pO1xuXG4gICAgICAgIF9TdWJzY3JpcHRpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgU3ViamVjdFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBzdWJqZWN0Lm9ic2VydmVycztcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gdm9pZCAwO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5vYnNlcnZlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KShfU3Vic2NyaXB0aW9uM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5cbmlmICghX3Jvb3Qucm9vdC5TeW1ib2wpIHtcbiAgICBfcm9vdC5yb290LlN5bWJvbCA9IHt9O1xufVxuaWYgKCFfcm9vdC5yb290LlN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBfcm9vdC5yb290LlN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3Jvb3Qucm9vdC5TeW1ib2wub2JzZXJ2YWJsZSA9IF9yb290LnJvb3QuU3ltYm9sWydmb3InXSgnb2JzZXJ2YWJsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9yb290LnJvb3QuU3ltYm9sLm9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG59XG5leHBvcnRzWydkZWZhdWx0J10gPSBfcm9vdC5yb290LlN5bWJvbC5vYnNlcnZhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG5vb3A7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2Vcbn07XG52YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmIHx8IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdztcbmV4cG9ydHMucm9vdCA9IHJvb3Q7XG52YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xudmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG52YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbmlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICBleHBvcnRzLnJvb3QgPSByb290ID0gZnJlZUdsb2JhbDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdGhyb3dFcnJvcjtcblxuZnVuY3Rpb24gdGhyb3dFcnJvcihlKSB7XG4gIHRocm93IGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHRyeU9yT25FcnJvcjtcblxuZnVuY3Rpb24gdHJ5T3JPbkVycm9yKHRhcmdldCkge1xuICAgIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cnlDYXRjaGVyLnRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeUNhdGNoZXIudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0Jzt2YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi9zcmMvY29yZS9wcm9maWxlL3Byb2ZpbGUnKTtcclxuZXhwb3J0cy53dGZDcmVhdGVTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZTtcclxuZXhwb3J0cy53dGZMZWF2ZSA9IHByb2ZpbGVfMS53dGZMZWF2ZTtcclxuZXhwb3J0cy53dGZTdGFydFRpbWVSYW5nZSA9IHByb2ZpbGVfMS53dGZTdGFydFRpbWVSYW5nZTtcclxuZXhwb3J0cy53dGZFbmRUaW1lUmFuZ2UgPSBwcm9maWxlXzEud3RmRW5kVGltZVJhbmdlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9maWxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgZm9yIGRhcnQgYXBwbGljYXRpb25zIGFuZCBmb3IgaW50ZXJuYWwgZXhhbXBsZXNcclxuICogdGhhdCBjb21waWxlIHdpdGggYm90aCBKYXZhU2NyaXB0IGFuZCBEYXJ0LlxyXG4gKlxyXG4gKiBKYXZhU2NyaXB0IHVzZXJzIHNob3VsZCBpbXBvcnQgZnJvbSBhbmd1bGFyMi9jb3JlLlxyXG4gKi9cclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29yZS9yZW5kZXInKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIE1hcHMgYXBwbGljYXRpb24gVVJMcyBpbnRvIGFwcGxpY2F0aW9uIHN0YXRlcywgdG8gc3VwcG9ydCBkZWVwLWxpbmtpbmcgYW5kIG5hdmlnYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIHJvdXRlcl8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlcicpO1xyXG5leHBvcnRzLlJvdXRlciA9IHJvdXRlcl8xLlJvdXRlcjtcclxudmFyIHJvdXRlcl9vdXRsZXRfMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZXJfb3V0bGV0Jyk7XHJcbmV4cG9ydHMuUm91dGVyT3V0bGV0ID0gcm91dGVyX291dGxldF8xLlJvdXRlck91dGxldDtcclxudmFyIHJvdXRlcl9saW5rXzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVyX2xpbmsnKTtcclxuZXhwb3J0cy5Sb3V0ZXJMaW5rID0gcm91dGVyX2xpbmtfMS5Sb3V0ZXJMaW5rO1xyXG52YXIgaW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9pbnN0cnVjdGlvbicpO1xyXG5leHBvcnRzLlJvdXRlUGFyYW1zID0gaW5zdHJ1Y3Rpb25fMS5Sb3V0ZVBhcmFtcztcclxudmFyIHJvdXRlX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVfcmVnaXN0cnknKTtcclxuZXhwb3J0cy5Sb3V0ZVJlZ2lzdHJ5ID0gcm91dGVfcmVnaXN0cnlfMS5Sb3V0ZVJlZ2lzdHJ5O1xyXG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG5leHBvcnRzLkxvY2F0aW9uU3RyYXRlZ3kgPSBsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3k7XHJcbnZhciBoYXNoX2xvY2F0aW9uX3N0cmF0ZWd5XzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvaGFzaF9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG5leHBvcnRzLkhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gaGFzaF9sb2NhdGlvbl9zdHJhdGVneV8xLkhhc2hMb2NhdGlvblN0cmF0ZWd5O1xyXG52YXIgcGF0aF9sb2NhdGlvbl9zdHJhdGVneV8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3BhdGhfbG9jYXRpb25fc3RyYXRlZ3knKTtcclxuZXhwb3J0cy5QYXRoTG9jYXRpb25TdHJhdGVneSA9IHBhdGhfbG9jYXRpb25fc3RyYXRlZ3lfMS5QYXRoTG9jYXRpb25TdHJhdGVneTtcclxudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvbG9jYXRpb24nKTtcclxuZXhwb3J0cy5Mb2NhdGlvbiA9IGxvY2F0aW9uXzEuTG9jYXRpb247XHJcbmV4cG9ydHMuQVBQX0JBU0VfSFJFRiA9IGxvY2F0aW9uXzEuQVBQX0JBU0VfSFJFRjtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlX2NvbmZpZ19kZWNvcmF0b3InKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZV9kZWZpbml0aW9uJykpO1xyXG52YXIgbGlmZWN5Y2xlX2Fubm90YXRpb25zXzEgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvbGlmZWN5Y2xlX2Fubm90YXRpb25zJyk7XHJcbmV4cG9ydHMuQ2FuQWN0aXZhdGUgPSBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfMS5DYW5BY3RpdmF0ZTtcclxudmFyIGluc3RydWN0aW9uXzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvaW5zdHJ1Y3Rpb24nKTtcclxuZXhwb3J0cy5JbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uXzIuSW5zdHJ1Y3Rpb247XHJcbmV4cG9ydHMuQ29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbl8yLkNvbXBvbmVudEluc3RydWN0aW9uO1xyXG52YXIgYW5ndWxhcjJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbmV4cG9ydHMuT3BhcXVlVG9rZW4gPSBhbmd1bGFyMl8xLk9wYXF1ZVRva2VuO1xyXG52YXIgcm91dGVfZGF0YV8xID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL3JvdXRlX2RhdGEnKTtcclxuZXhwb3J0cy5ST1VURV9EQVRBID0gcm91dGVfZGF0YV8xLlJPVVRFX0RBVEE7XHJcbnZhciBsb2NhdGlvbl9zdHJhdGVneV8yID0gcmVxdWlyZSgnLi9zcmMvcm91dGVyL2xvY2F0aW9uX3N0cmF0ZWd5Jyk7XHJcbnZhciBwYXRoX2xvY2F0aW9uX3N0cmF0ZWd5XzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcGF0aF9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG52YXIgcm91dGVyXzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVyJyk7XHJcbnZhciByb3V0ZXJfb3V0bGV0XzIgPSByZXF1aXJlKCcuL3NyYy9yb3V0ZXIvcm91dGVyX291dGxldCcpO1xyXG52YXIgcm91dGVyX2xpbmtfMiA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZXJfbGluaycpO1xyXG52YXIgcm91dGVfcmVnaXN0cnlfMiA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9yb3V0ZV9yZWdpc3RyeScpO1xyXG52YXIgbG9jYXRpb25fMiA9IHJlcXVpcmUoJy4vc3JjL3JvdXRlci9sb2NhdGlvbicpO1xyXG52YXIgYW5ndWxhcjJfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG4vKipcclxuICogVG9rZW4gdXNlZCB0byBiaW5kIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgdG9wLWxldmVsIHtAbGluayBSb3V0ZUNvbmZpZ31zIGZvciB0aGVcclxuICogYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2lSVVA4QjVPVWJ4Q1dRM0FjSURtKSlcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7XHJcbiAqICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBSb3V0ZUNvbmZpZ1xyXG4gKiB9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgLy8gLi4uXHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcENtcCwgW1JPVVRFUl9QUk9WSURFUlNdKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLlJPVVRFUl9QUklNQVJZX0NPTVBPTkVOVCA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBhbmd1bGFyMl8yLk9wYXF1ZVRva2VuKCdSb3V0ZXJQcmltYXJ5Q29tcG9uZW50JykpO1xyXG4vKipcclxuICogQSBsaXN0IG9mIGRpcmVjdGl2ZXMuIFRvIHVzZSB0aGUgcm91dGVyIGRpcmVjdGl2ZXMgbGlrZSB7QGxpbmsgUm91dGVyT3V0bGV0fSBhbmRcclxuICoge0BsaW5rIFJvdXRlckxpbmt9LCBhZGQgdGhpcyB0byB5b3VyIGBkaXJlY3RpdmVzYCBhcnJheSBpbiB0aGUge0BsaW5rIFZpZXd9IGRlY29yYXRvciBvZiB5b3VyXHJcbiAqIGNvbXBvbmVudC5cclxuICpcclxuICogIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvaVJVUDhCNU9VYnhDV1EzQWNJRG0pKVxyXG4gKlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtST1VURVJfRElSRUNUSVZFUywgUk9VVEVSX1BST1ZJREVSUywgUm91dGVDb25maWd9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgIC8vIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtST1VURVJfUFJPVklERVJTXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5ST1VURVJfRElSRUNUSVZFUyA9IGxhbmdfMS5DT05TVF9FWFBSKFtyb3V0ZXJfb3V0bGV0XzIuUm91dGVyT3V0bGV0LCByb3V0ZXJfbGlua18yLlJvdXRlckxpbmtdKTtcclxuLyoqXHJcbiAqIEEgbGlzdCBvZiB7QGxpbmsgUHJvdmlkZXJ9cy4gVG8gdXNlIHRoZSByb3V0ZXIsIHlvdSBtdXN0IGFkZCB0aGlzIHRvIHlvdXIgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2lSVVA4QjVPVWJ4Q1dRM0FjSURtKSlcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7XHJcbiAqICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBSb3V0ZUNvbmZpZ1xyXG4gKiB9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgLy8gLi4uXHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcENtcCwgW1JPVVRFUl9QUk9WSURFUlNdKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLlJPVVRFUl9QUk9WSURFUlMgPSBsYW5nXzEuQ09OU1RfRVhQUihbXHJcbiAgICByb3V0ZV9yZWdpc3RyeV8yLlJvdXRlUmVnaXN0cnksXHJcbiAgICBsYW5nXzEuQ09OU1RfRVhQUihuZXcgYW5ndWxhcjJfMi5Qcm92aWRlcihsb2NhdGlvbl9zdHJhdGVneV8yLkxvY2F0aW9uU3RyYXRlZ3ksIHsgdXNlQ2xhc3M6IHBhdGhfbG9jYXRpb25fc3RyYXRlZ3lfMi5QYXRoTG9jYXRpb25TdHJhdGVneSB9KSksXHJcbiAgICBsb2NhdGlvbl8yLkxvY2F0aW9uLFxyXG4gICAgbGFuZ18xLkNPTlNUX0VYUFIobmV3IGFuZ3VsYXIyXzIuUHJvdmlkZXIocm91dGVyXzIuUm91dGVyLCB7XHJcbiAgICAgICAgdXNlRmFjdG9yeTogcm91dGVyRmFjdG9yeSxcclxuICAgICAgICBkZXBzOiBsYW5nXzEuQ09OU1RfRVhQUihbcm91dGVfcmVnaXN0cnlfMi5Sb3V0ZVJlZ2lzdHJ5LCBsb2NhdGlvbl8yLkxvY2F0aW9uLCBleHBvcnRzLlJPVVRFUl9QUklNQVJZX0NPTVBPTkVOVF0pXHJcbiAgICB9KSksXHJcbiAgICBsYW5nXzEuQ09OU1RfRVhQUihuZXcgYW5ndWxhcjJfMi5Qcm92aWRlcihleHBvcnRzLlJPVVRFUl9QUklNQVJZX0NPTVBPTkVOVCwgeyB1c2VGYWN0b3J5OiByb3V0ZXJQcmltYXJ5Q29tcG9uZW50RmFjdG9yeSwgZGVwczogbGFuZ18xLkNPTlNUX0VYUFIoW2FuZ3VsYXIyXzIuQXBwbGljYXRpb25SZWZdKSB9KSlcclxuXSk7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxuZXhwb3J0cy5ST1VURVJfQklORElOR1MgPSBleHBvcnRzLlJPVVRFUl9QUk9WSURFUlM7XHJcbmZ1bmN0aW9uIHJvdXRlckZhY3RvcnkocmVnaXN0cnksIGxvY2F0aW9uLCBwcmltYXJ5Q29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gbmV3IHJvdXRlcl8yLlJvb3RSb3V0ZXIocmVnaXN0cnksIGxvY2F0aW9uLCBwcmltYXJ5Q29tcG9uZW50KTtcclxufVxyXG5mdW5jdGlvbiByb3V0ZXJQcmltYXJ5Q29tcG9uZW50RmFjdG9yeShhcHApIHtcclxuICAgIGlmIChhcHAuY29tcG9uZW50VHlwZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJCb290c3RyYXAgYXQgbGVhc3Qgb25lIGNvbXBvbmVudCBiZWZvcmUgaW5qZWN0aW5nIFJvdXRlci5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbXBvbmVudFR5cGVzWzBdO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtYXRoXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbWF0aCcpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL2RvbS91dGlsJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzIHRoZSBzdGFydCB0aW1lIGFuZCBzdGFydHMgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKiBAcGFyYW0gYnJvd3NlckRldGFpbHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKGVsZW1lbnQsIGRhdGEsIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xyXG4gICAgICAgIC8qKiBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkIHVwb24gY29tcGxldGlvbiAqL1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLyoqIGZ1bmN0aW9ucyBmb3IgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXJzICovXHJcbiAgICAgICAgdGhpcy5ldmVudENsZWFyRnVuY3Rpb25zID0gW107XHJcbiAgICAgICAgLyoqIGZsYWcgdXNlZCB0byB0cmFjayB3aGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZCAqL1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RyaW5nUHJlZml4ID0gJyc7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBsYW5nXzEuRGF0ZVdyYXBwZXIudG9NaWxsaXMobGFuZ18xLkRhdGVXcmFwcGVyLm5vdygpKTtcclxuICAgICAgICB0aGlzLl9zdHJpbmdQcmVmaXggPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRBbmltYXRpb25QcmVmaXgoKTtcclxuICAgICAgICB0aGlzLnNldHVwKCk7XHJcbiAgICAgICAgdGhpcy53YWl0KGZ1bmN0aW9uICh0aW1lc3RhbXApIHsgcmV0dXJuIF90aGlzLnN0YXJ0KCk7IH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbi5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcclxuICAgICAgICAvKiogdG90YWwgYW1vdW50IG9mIHRpbWUgdGhhdCB0aGUgYW5pbWF0aW9uIHNob3VsZCB0YWtlIGluY2x1ZGluZyBkZWxheSAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmNvbXB1dGVkRGVsYXkgIT0gbnVsbCA/IHRoaXMuY29tcHV0ZWREZWxheSA6IDA7XHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuY29tcHV0ZWREdXJhdGlvbiAhPSBudWxsID8gdGhpcy5jb21wdXRlZER1cmF0aW9uIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIGRlbGF5ICsgZHVyYXRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIDIgZnJhbWVzIGZvciBzb21lIHJlYXNvblxyXG4gICAgICAgIHRoaXMuYnJvd3NlckRldGFpbHMucmFmKGNhbGxiYWNrLCAyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIGluaXRpYWwgc3R5bGVzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGlzIHN0YXJ0ZWRcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmZyb21TdHlsZXMgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyh0aGlzLmRhdGEuZnJvbVN0eWxlcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kdXJhdGlvbiAhPSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKHsgJ3RyYW5zaXRpb25EdXJhdGlvbic6IHRoaXMuZGF0YS5kdXJhdGlvbi50b1N0cmluZygpICsgJ21zJyB9KTtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmRlbGF5ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXMoeyAndHJhbnNpdGlvbkRlbGF5JzogdGhpcy5kYXRhLmRlbGF5LnRvU3RyaW5nKCkgKyAnbXMnIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWZ0ZXIgdGhlIGluaXRpYWwgc2V0dXAgaGFzIG9jY3VycmVkLCB0aGlzIG1ldGhvZCBhZGRzIHRoZSBhbmltYXRpb24gc3R5bGVzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRDbGFzc2VzKHRoaXMuZGF0YS5jbGFzc2VzVG9BZGQpO1xyXG4gICAgICAgIHRoaXMuYWRkQ2xhc3Nlcyh0aGlzLmRhdGEuYW5pbWF0aW9uQ2xhc3Nlcyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzc2VzKHRoaXMuZGF0YS5jbGFzc2VzVG9SZW1vdmUpO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEudG9TdHlsZXMgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyh0aGlzLmRhdGEudG9TdHlsZXMpO1xyXG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlcyA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVkRGVsYXkgPVxyXG4gICAgICAgICAgICBtYXRoXzEuTWF0aC5tYXgodGhpcy5wYXJzZUR1cmF0aW9uU3RyaW5nKGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUodGhpcy5fc3RyaW5nUHJlZml4ICsgJ3RyYW5zaXRpb24tZGVsYXknKSksIHRoaXMucGFyc2VEdXJhdGlvblN0cmluZyh0aGlzLmVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLl9zdHJpbmdQcmVmaXggKyAndHJhbnNpdGlvbi1kZWxheScpKSk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlZER1cmF0aW9uID0gbWF0aF8xLk1hdGgubWF4KHRoaXMucGFyc2VEdXJhdGlvblN0cmluZyhjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMuX3N0cmluZ1ByZWZpeCArICd0cmFuc2l0aW9uLWR1cmF0aW9uJykpLCB0aGlzLnBhcnNlRHVyYXRpb25TdHJpbmcodGhpcy5lbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUodGhpcy5fc3RyaW5nUHJlZml4ICsgJ3RyYW5zaXRpb24tZHVyYXRpb24nKSkpO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRzKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBzdHlsZXMgdG8gdGhlIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBzdHlsZXNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hcHBseVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZGFzaENhc2VLZXkgPSB1dGlsXzEuY2FtZWxDYXNlVG9EYXNoQ2FzZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkb21fYWRhcHRlcl8xLkRPTS5nZXRTdHlsZShfdGhpcy5lbGVtZW50LCBkYXNoQ2FzZUtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRTdHlsZShfdGhpcy5lbGVtZW50LCBkYXNoQ2FzZUtleSwgdmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRTdHlsZShfdGhpcy5lbGVtZW50LCBfdGhpcy5fc3RyaW5nUHJlZml4ICsgZGFzaENhc2VLZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBwcm92aWRlZCBjbGFzc2VzIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gY2xhc3Nlc1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkZENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIGNsYXNzZXNbaV0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQgY2xhc3NlcyBmcm9tIHRoZSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gY2xhc3Nlc1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlbW92ZUNsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIGNsYXNzZXNbaV0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBldmVudHMgdG8gdHJhY2sgd2hlbiBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy50b3RhbFRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDbGVhckZ1bmN0aW9ucy5wdXNoKGRvbV9hZGFwdGVyXzEuRE9NLm9uQW5kQ2FuY2VsKHRoaXMuZWxlbWVudCwgZG9tX2FkYXB0ZXJfMS5ET00uZ2V0VHJhbnNpdGlvbkVuZCgpLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUFuaW1hdGlvbkV2ZW50KGV2ZW50KTsgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5oYW5kbGVBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG1hdGhfMS5NYXRoLnJvdW5kKGV2ZW50LmVsYXBzZWRUaW1lICogMTAwMCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJyb3dzZXJEZXRhaWxzLmVsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSlcclxuICAgICAgICAgICAgZWxhcHNlZFRpbWUgKz0gdGhpcy5jb21wdXRlZERlbGF5O1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGlmIChlbGFwc2VkVGltZSA+PSB0aGlzLnRvdGFsVGltZSlcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYWxsIGFuaW1hdGlvbiBjYWxsYmFja3MgYW5kIHJlbW92ZXMgdGVtcG9yYXJ5IGNsYXNzZXNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzc2VzKHRoaXMuZGF0YS5hbmltYXRpb25DbGFzc2VzKTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2soKTsgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50Q2xlYXJGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRDbGVhckZ1bmN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW5pbWF0aW9uIGNhbGxiYWNrcyB0byBiZSBjYWxsZWQgdXBvbiBjb21wbGV0aW9uXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb259XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGR1cmF0aW9uIHN0cmluZyB0byB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnBhcnNlRHVyYXRpb25TdHJpbmcgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICB2YXIgbWF4VmFsdWUgPSAwO1xyXG4gICAgICAgIC8vIGR1cmF0aW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgdG8gYmUgdmFsaWQuIChudW1iZXIgKyB0eXBlKVxyXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PSBudWxsIHx8IGR1cmF0aW9uLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkdXJhdGlvbi5zdWJzdHJpbmcoZHVyYXRpb24ubGVuZ3RoIC0gMikgPT0gJ21zJykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludCh0aGlzLnN0cmlwTGV0dGVycyhkdXJhdGlvbiksIDEwKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpXHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkdXJhdGlvbi5zdWJzdHJpbmcoZHVyYXRpb24ubGVuZ3RoIC0gMSkgPT0gJ3MnKSB7XHJcbiAgICAgICAgICAgIHZhciBtcyA9IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlRmxvYXQodGhpcy5zdHJpcExldHRlcnMoZHVyYXRpb24pKSAqIDEwMDA7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGhfMS5NYXRoLmZsb29yKG1zKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpXHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpcHMgdGhlIGxldHRlcnMgZnJvbSB0aGUgZHVyYXRpb24gc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnN0cmlwTGV0dGVycyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzdHIsIGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnW14wLTldKyQnLCAnJyksICcnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQW5pbWF0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjc3NfYW5pbWF0aW9uX2J1aWxkZXJfMSA9IHJlcXVpcmUoJy4vY3NzX2FuaW1hdGlvbl9idWlsZGVyJyk7XHJcbnZhciBicm93c2VyX2RldGFpbHNfMSA9IHJlcXVpcmUoJy4vYnJvd3Nlcl9kZXRhaWxzJyk7XHJcbnZhciBBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgRElcclxuICAgICAqIEBwYXJhbSBicm93c2VyRGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25CdWlsZGVyKGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENTUyBBbmltYXRpb25cclxuICAgICAqIEByZXR1cm5zIHtDc3NBbmltYXRpb25CdWlsZGVyfVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgY3NzX2FuaW1hdGlvbl9idWlsZGVyXzEuQ3NzQW5pbWF0aW9uQnVpbGRlcih0aGlzLmJyb3dzZXJEZXRhaWxzKTsgfTtcclxuICAgIEFuaW1hdGlvbkJ1aWxkZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbYnJvd3Nlcl9kZXRhaWxzXzEuQnJvd3NlckRldGFpbHNdKVxyXG4gICAgXSwgQW5pbWF0aW9uQnVpbGRlcik7XHJcbiAgICByZXR1cm4gQW5pbWF0aW9uQnVpbGRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5BbmltYXRpb25CdWlsZGVyID0gQW5pbWF0aW9uQnVpbGRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uX2J1aWxkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIG1hdGhfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9tYXRoJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBCcm93c2VyRGV0YWlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCcm93c2VyRGV0YWlscygpIHtcclxuICAgICAgICB0aGlzLmVsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZG9lc0VsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGBldmVudC5lbGFwc2VkVGltZWAgaW5jbHVkZXMgdHJhbnNpdGlvbiBkZWxheSBpbiB0aGUgY3VycmVudCBicm93c2VyLiAgQXQgdGhpc1xyXG4gICAgICogdGltZSwgQ2hyb21lIGFuZCBPcGVyYSBzZWVtIHRvIGJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXQgaW5jbHVkZSB0aGlzLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyRGV0YWlscy5wcm90b3R5cGUuZG9lc0VsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkaXYgPSBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRBdHRyaWJ1dGUoZGl2LCAnc3R5bGUnLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtOTk5OXB4OyBsZWZ0OiAtOTk5OXB4OyB3aWR0aDogMXB4O1xcbiAgICAgIGhlaWdodDogMXB4OyB0cmFuc2l0aW9uOiBhbGwgMW1zIGxpbmVhciAxbXM7XCIpO1xyXG4gICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhhdCB3ZSB3YWl0IGZvciAyIGZyYW1lcyBmb3Igc29tZSByZWFzb25cclxuICAgICAgICB0aGlzLnJhZihmdW5jdGlvbiAodGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLm9uKGRpdiwgJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkID0gbWF0aF8xLk1hdGgucm91bmQoZXZlbnQuZWxhcHNlZFRpbWUgKiAxMDAwKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSA9IGVsYXBzZWQgPT0gMjtcclxuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZShkaXYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0U3R5bGUoZGl2LCAnd2lkdGgnLCAnMnB4Jyk7XHJcbiAgICAgICAgfSwgMik7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRldGFpbHMucHJvdG90eXBlLnJhZiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZnJhbWVzKSB7XHJcbiAgICAgICAgaWYgKGZyYW1lcyA9PT0gdm9pZCAwKSB7IGZyYW1lcyA9IDE7IH1cclxuICAgICAgICB2YXIgcXVldWUgPSBuZXcgUmFmUXVldWUoY2FsbGJhY2ssIGZyYW1lcyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXVlLmNhbmNlbCgpOyB9O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEZXRhaWxzID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBCcm93c2VyRGV0YWlscyk7XHJcbiAgICByZXR1cm4gQnJvd3NlckRldGFpbHM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQnJvd3NlckRldGFpbHMgPSBCcm93c2VyRGV0YWlscztcclxudmFyIFJhZlF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhZlF1ZXVlKGNhbGxiYWNrLCBmcmFtZXMpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBmcmFtZXM7XHJcbiAgICAgICAgdGhpcy5fcmFmKCk7XHJcbiAgICB9XHJcbiAgICBSYWZRdWV1ZS5wcm90b3R5cGUuX3JhZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lSWQgPSBkb21fYWRhcHRlcl8xLkRPTS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkgeyByZXR1cm4gX3RoaXMuX25leHRGcmFtZSh0aW1lc3RhbXApOyB9KTtcclxuICAgIH07XHJcbiAgICBSYWZRdWV1ZS5wcm90b3R5cGUuX25leHRGcmFtZSA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcclxuICAgICAgICB0aGlzLmZyYW1lcy0tO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJhZlF1ZXVlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5jdXJyZW50RnJhbWVJZCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVJZCA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJhZlF1ZXVlO1xyXG59KSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyX2RldGFpbHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjc3NfYW5pbWF0aW9uX29wdGlvbnNfMSA9IHJlcXVpcmUoJy4vY3NzX2FuaW1hdGlvbl9vcHRpb25zJyk7XHJcbnZhciBhbmltYXRpb25fMSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJyk7XHJcbnZhciBDc3NBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQWNjZXB0cyBwdWJsaWMgcHJvcGVydGllcyBmb3IgQ3NzQW5pbWF0aW9uQnVpbGRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDc3NBbmltYXRpb25CdWlsZGVyKGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7Q3NzQW5pbWF0aW9uT3B0aW9uc30gKi9cclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgY3NzX2FuaW1hdGlvbl9vcHRpb25zXzEuQ3NzQW5pbWF0aW9uT3B0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdGVtcG9yYXJ5IGNsYXNzIHRoYXQgd2lsbCBiZSByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxyXG4gICAgICovXHJcbiAgICBDc3NBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRBbmltYXRpb25DbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB0aGlzLmRhdGEuYW5pbWF0aW9uQ2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY2xhc3MgdGhhdCB3aWxsIHJlbWFpbiBvbiB0aGUgZWxlbWVudCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZFxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxyXG4gICAgICovXHJcbiAgICBDc3NBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB0aGlzLmRhdGEuY2xhc3Nlc1RvQWRkLnB1c2goY2xhc3NOYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YS5jbGFzc2VzVG9SZW1vdmUucHVzaChjbGFzc05hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIChhbmQgb3ZlcnJpZGVzIGFueSBkZWZpbmVkIHRocm91Z2ggQ1NTKVxyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldER1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmltYXRpb24gZGVsYXkgKGFuZCBvdmVycmlkZXMgYW55IGRlZmluZWQgdGhyb3VnaCBDU1MpXHJcbiAgICAgKiBAcGFyYW0gZGVsYXlcclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0RGVsYXkgPSBmdW5jdGlvbiAoZGVsYXkpIHtcclxuICAgICAgICB0aGlzLmRhdGEuZGVsYXkgPSBkZWxheTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc3R5bGVzIGZvciBib3RoIHRoZSBpbml0aWFsIHN0YXRlIGFuZCB0aGUgZGVzdGluYXRpb24gc3RhdGVcclxuICAgICAqIEBwYXJhbSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdG9cclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbVN0eWxlcyhmcm9tKS5zZXRUb1N0eWxlcyh0byk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpbml0aWFsIHN0eWxlcyBmb3IgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGZyb21cclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0RnJvbVN0eWxlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLmZyb21TdHlsZXMgPSBmcm9tO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZGVzdGluYXRpb24gc3R5bGVzIGZvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gdG9cclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0VG9TdHlsZXMgPSBmdW5jdGlvbiAodG8pIHtcclxuICAgICAgICB0aGlzLmRhdGEudG9TdHlsZXMgPSB0bztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgYW5pbWF0aW9uIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgYW5pbWF0aW9uXzEuQW5pbWF0aW9uKGVsZW1lbnQsIHRoaXMuZGF0YSwgdGhpcy5icm93c2VyRGV0YWlscyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENzc0FuaW1hdGlvbkJ1aWxkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ3NzQW5pbWF0aW9uQnVpbGRlciA9IENzc0FuaW1hdGlvbkJ1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzc19hbmltYXRpb25fYnVpbGRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIENzc0FuaW1hdGlvbk9wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ3NzQW5pbWF0aW9uT3B0aW9ucygpIHtcclxuICAgICAgICAvKiogY2xhc3NlcyB0byBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3Nlc1RvQWRkID0gW107XHJcbiAgICAgICAgLyoqIGNsYXNzZXMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50ICovXHJcbiAgICAgICAgdGhpcy5jbGFzc2VzVG9SZW1vdmUgPSBbXTtcclxuICAgICAgICAvKiogY2xhc3NlcyB0byBiZSBhZGRlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKi9cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkNsYXNzZXMgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBDc3NBbmltYXRpb25PcHRpb25zO1xyXG59KSgpO1xyXG5leHBvcnRzLkNzc0FuaW1hdGlvbk9wdGlvbnMgPSBDc3NBbmltYXRpb25PcHRpb25zO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3NfYW5pbWF0aW9uX29wdGlvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL2NvbXBpbGVyJyk7XHJcbnZhciBhcHBsaWNhdGlvbl9jb21tb25fMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fY29tbW9uJyk7XHJcbnZhciBhcHBsaWNhdGlvbl90b2tlbnNfMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fdG9rZW5zJyk7XHJcbmV4cG9ydHMuQVBQX0NPTVBPTkVOVCA9IGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9DT01QT05FTlQ7XHJcbmV4cG9ydHMuQVBQX0lEID0gYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lEO1xyXG52YXIgYXBwbGljYXRpb25fY29tbW9uXzIgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX2NvbW1vbicpO1xyXG5leHBvcnRzLnBsYXRmb3JtID0gYXBwbGljYXRpb25fY29tbW9uXzIucGxhdGZvcm07XHJcbnZhciBhcHBsaWNhdGlvbl9yZWZfMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fcmVmJyk7XHJcbmV4cG9ydHMuUGxhdGZvcm1SZWYgPSBhcHBsaWNhdGlvbl9yZWZfMS5QbGF0Zm9ybVJlZjtcclxuZXhwb3J0cy5BcHBsaWNhdGlvblJlZiA9IGFwcGxpY2F0aW9uX3JlZl8xLkFwcGxpY2F0aW9uUmVmO1xyXG5leHBvcnRzLmFwcGxpY2F0aW9uQ29tbW9uQmluZGluZ3MgPSBhcHBsaWNhdGlvbl9yZWZfMS5hcHBsaWNhdGlvbkNvbW1vbkJpbmRpbmdzO1xyXG5leHBvcnRzLmNyZWF0ZU5nWm9uZSA9IGFwcGxpY2F0aW9uX3JlZl8xLmNyZWF0ZU5nWm9uZTtcclxuZXhwb3J0cy5wbGF0Zm9ybUNvbW1vbiA9IGFwcGxpY2F0aW9uX3JlZl8xLnBsYXRmb3JtQ29tbW9uO1xyXG5leHBvcnRzLnBsYXRmb3JtQmluZGluZ3MgPSBhcHBsaWNhdGlvbl9yZWZfMS5wbGF0Zm9ybUJpbmRpbmdzO1xyXG4vLy8gU2VlIFtjb21tb25Cb290c3RyYXBdIGZvciBkZXRhaWxlZCBkb2N1bWVudGF0aW9uLlxyXG5mdW5jdGlvbiBib290c3RyYXAoYXBwQ29tcG9uZW50VHlwZSwgYXBwQmluZGluZ3MpIHtcclxuICAgIGlmIChhcHBCaW5kaW5ncyA9PT0gdm9pZCAwKSB7IGFwcEJpbmRpbmdzID0gbnVsbDsgfVxyXG4gICAgdmFyIGJpbmRpbmdzID0gW2NvbXBpbGVyXzEuY29tcGlsZXJQcm92aWRlcnMoKV07XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhcHBCaW5kaW5ncykpIHtcclxuICAgICAgICBiaW5kaW5ncy5wdXNoKGFwcEJpbmRpbmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHBsaWNhdGlvbl9jb21tb25fMS5jb21tb25Cb290c3RyYXAoYXBwQ29tcG9uZW50VHlwZSwgYmluZGluZ3MpO1xyXG59XHJcbmV4cG9ydHMuYm9vdHN0cmFwID0gYm9vdHN0cmFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGZvcm1zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mb3JtcycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYnJvd3Nlcl9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vYnJvd3Nlcl9hZGFwdGVyJyk7XHJcbnZhciBicm93c2VyX3Rlc3RhYmlsaXR5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS90ZXN0YWJpbGl0eS9icm93c2VyX3Rlc3RhYmlsaXR5Jyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciB4aHJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3hocicpO1xyXG52YXIgeGhyX2ltcGxfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3hocl9pbXBsJyk7XHJcbnZhciBldmVudF9tYW5hZ2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL2V2ZW50cy9ldmVudF9tYW5hZ2VyJyk7XHJcbnZhciBrZXlfZXZlbnRzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL2V2ZW50cy9rZXlfZXZlbnRzJyk7XHJcbnZhciBoYW1tZXJfZ2VzdHVyZXNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9kb20vZXZlbnRzL2hhbW1lcl9nZXN0dXJlcycpO1xyXG52YXIgdGVzdGFiaWxpdHlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3Rlc3RhYmlsaXR5L3Rlc3RhYmlsaXR5Jyk7XHJcbnZhciBhcGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9hcGknKTtcclxudmFyIHJlbmRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyL3JlbmRlcicpO1xyXG52YXIgc2hhcmVkX3N0eWxlc19ob3N0XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3NoYXJlZF9zdHlsZXNfaG9zdCcpO1xyXG52YXIgcGxhdGZvcm1fYmluZGluZ3NfMSA9IHJlcXVpcmUoJy4vcGxhdGZvcm1fYmluZGluZ3MnKTtcclxudmFyIGFuaW1hdGlvbl9idWlsZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvYW5pbWF0ZS9hbmltYXRpb25fYnVpbGRlcicpO1xyXG52YXIgYnJvd3Nlcl9kZXRhaWxzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvYW5pbWF0ZS9icm93c2VyX2RldGFpbHMnKTtcclxudmFyIHd0Zl9pbml0XzEgPSByZXF1aXJlKCcuL3Byb2ZpbGUvd3RmX2luaXQnKTtcclxudmFyIGFwcGxpY2F0aW9uX3JlZl8xID0gcmVxdWlyZSgnLi9hcHBsaWNhdGlvbl9yZWYnKTtcclxuLyoqXHJcbiAqIEEgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzIHdoaWNoIGFwcGx5IG9ubHkgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uXHJcbiAqIHRoZSBVSSB0aHJlYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBsaWNhdGlvbkRvbUJpbmRpbmdzKCkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGRvbV9hZGFwdGVyXzEuRE9NKSkge1xyXG4gICAgICAgIHRocm93IFwiTXVzdCBzZXQgYSByb290IERPTSBhZGFwdGVyIGZpcnN0LlwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBkaV8xLnByb3ZpZGUocmVuZGVyXzEuRE9DVU1FTlQsIHsgdXNlVmFsdWU6IGRvbV9hZGFwdGVyXzEuRE9NLmRlZmF1bHREb2MoKSB9KSxcclxuICAgICAgICBldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyLFxyXG4gICAgICAgIG5ldyBkaV8xLlByb3ZpZGVyKGV2ZW50X21hbmFnZXJfMS5FVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHsgdXNlQ2xhc3M6IGV2ZW50X21hbmFnZXJfMS5Eb21FdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlIH0pLFxyXG4gICAgICAgIG5ldyBkaV8xLlByb3ZpZGVyKGV2ZW50X21hbmFnZXJfMS5FVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHsgdXNlQ2xhc3M6IGtleV9ldmVudHNfMS5LZXlFdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlIH0pLFxyXG4gICAgICAgIG5ldyBkaV8xLlByb3ZpZGVyKGV2ZW50X21hbmFnZXJfMS5FVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHsgdXNlQ2xhc3M6IGhhbW1lcl9nZXN0dXJlc18xLkhhbW1lckdlc3R1cmVzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUocmVuZGVyXzEuRG9tUmVuZGVyZXIsIHsgdXNlQ2xhc3M6IHJlbmRlcl8xLkRvbVJlbmRlcmVyXyB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUoYXBpXzEuUmVuZGVyZXIsIHsgdXNlRXhpc3Rpbmc6IHJlbmRlcl8xLkRvbVJlbmRlcmVyIH0pLFxyXG4gICAgICAgIHNoYXJlZF9zdHlsZXNfaG9zdF8xLkRvbVNoYXJlZFN0eWxlc0hvc3QsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKHNoYXJlZF9zdHlsZXNfaG9zdF8xLlNoYXJlZFN0eWxlc0hvc3QsIHsgdXNlRXhpc3Rpbmc6IHNoYXJlZF9zdHlsZXNfaG9zdF8xLkRvbVNoYXJlZFN0eWxlc0hvc3QgfSksXHJcbiAgICAgICAgcGxhdGZvcm1fYmluZGluZ3NfMS5FWENFUFRJT05fUFJPVklERVIsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKHhocl8xLlhIUiwgeyB1c2VWYWx1ZTogbmV3IHhocl9pbXBsXzEuWEhSSW1wbCgpIH0pLFxyXG4gICAgICAgIHRlc3RhYmlsaXR5XzEuVGVzdGFiaWxpdHksXHJcbiAgICAgICAgYnJvd3Nlcl9kZXRhaWxzXzEuQnJvd3NlckRldGFpbHMsXHJcbiAgICAgICAgYW5pbWF0aW9uX2J1aWxkZXJfMS5BbmltYXRpb25CdWlsZGVyLFxyXG4gICAgICAgIGZvcm1zXzEuRk9STV9QUk9WSURFUlNcclxuICAgIF07XHJcbn1cclxuZXhwb3J0cy5hcHBsaWNhdGlvbkRvbUJpbmRpbmdzID0gYXBwbGljYXRpb25Eb21CaW5kaW5ncztcclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIEFuZ3VsYXIgJ3BsYXRmb3JtJyBvbiB0aGUgcGFnZS5cclxuICpcclxuICogU2VlIHtAbGluayBQbGF0Zm9ybVJlZn0gZm9yIGRldGFpbHMgb24gdGhlIEFuZ3VsYXIgcGxhdGZvcm0uXHJcbiAqXHJcbiAqICMgV2l0aG91dCBzcGVjaWZpZWQgcHJvdmlkZXJzXHJcbiAqXHJcbiAqIElmIG5vIHByb3ZpZGVycyBhcmUgc3BlY2lmaWVkLCBgcGxhdGZvcm1gJ3MgYmVoYXZpb3IgZGVwZW5kcyBvbiB3aGV0aGVyIGFuIGV4aXN0aW5nXHJcbiAqIHBsYXRmb3JtIGV4aXN0czpcclxuICpcclxuICogSWYgbm8gcGxhdGZvcm0gZXhpc3RzLCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHQge0BsaW5rIHBsYXRmb3JtQmluZGluZ3N9LlxyXG4gKlxyXG4gKiBJZiBhIHBsYXRmb3JtIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIHJldHVybmVkIChyZWdhcmRsZXNzIG9mIHdoYXQgcHJvdmlkZXJzIGl0XHJcbiAqIHdhcyBjcmVhdGVkIHdpdGgpLiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZmVhdHVyZSwgYWxsb3dpbmcgZm9yIG11bHRpcGxlIGFwcGxpY2F0aW9uc1xyXG4gKiB0byBiZSBsb2FkZWQgaW50byB0aGUgc2FtZSBwbGF0Zm9ybSB3aXRob3V0IGF3YXJlbmVzcyBvZiBlYWNoIG90aGVyLlxyXG4gKlxyXG4gKiAjIFdpdGggc3BlY2lmaWVkIHByb3ZpZGVyc1xyXG4gKlxyXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHNwZWNpZnkgcHJvdmlkZXJzIHRvIGJlIG1hZGUgaW4gdGhlIG5ldyBwbGF0Zm9ybS4gVGhlc2UgcHJvdmlkZXJzXHJcbiAqIHdpbGwgYmUgc2hhcmVkIGJldHdlZW4gYWxsIGFwcGxpY2F0aW9ucyBvbiB0aGUgcGFnZS4gRm9yIGV4YW1wbGUsIGFuIGFic3RyYWN0aW9uIGZvclxyXG4gKiB0aGUgYnJvd3NlciBjb29raWUgamFyIHNob3VsZCBiZSBib3VuZCBhdCB0aGUgcGxhdGZvcm0gbGV2ZWwsIGJlY2F1c2UgdGhlcmUgaXMgb25seSBvbmVcclxuICogY29va2llIGphciByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGFwcGxpY2F0aW9ucyBvbiB0aGUgYWdlIHdpbGwgYmUgYWNjZXNzaW5nIGl0LlxyXG4gKlxyXG4gKiBJZiBwcm92aWRlcnMgYXJlIHNwZWNpZmllZCBkaXJlY3RseSwgYHBsYXRmb3JtYCB3aWxsIGNyZWF0ZSB0aGUgQW5ndWxhciBwbGF0Zm9ybSB3aXRoXHJcbiAqIHRoZW0gaWYgYSBwbGF0Zm9ybSBkaWQgbm90IGV4aXN0IGFscmVhZHkuIElmIGl0IGRpZCBleGlzdCwgaG93ZXZlciwgYW4gZXJyb3Igd2lsbCBiZVxyXG4gKiB0aHJvd24uXHJcbiAqXHJcbiAqICMgRE9NIEFwcGxpY2F0aW9uc1xyXG4gKlxyXG4gKiBUaGlzIHZlcnNpb24gb2YgYHBsYXRmb3JtYCBpbml0aWFsaXplcyBBbmd1bGFyIHRvIHJ1biBpbiB0aGUgVUkgdGhyZWFkLCB3aXRoIGRpcmVjdFxyXG4gKiBET00gYWNjZXNzLiBXZWItd29ya2VyIGFwcGxpY2F0aW9ucyBzaG91bGQgY2FsbCBgcGxhdGZvcm1gIGZyb21cclxuICogYHNyYy93ZWJfd29ya2Vycy93b3JrZXIvYXBwbGljYXRpb25fY29tbW9uYCBpbnN0ZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gcGxhdGZvcm0oYmluZGluZ3MpIHtcclxuICAgIHJldHVybiBhcHBsaWNhdGlvbl9yZWZfMS5wbGF0Zm9ybUNvbW1vbihiaW5kaW5ncywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGJyb3dzZXJfYWRhcHRlcl8xLkJyb3dzZXJEb21BZGFwdGVyLm1ha2VDdXJyZW50KCk7XHJcbiAgICAgICAgd3RmX2luaXRfMS53dGZJbml0KCk7XHJcbiAgICAgICAgYnJvd3Nlcl90ZXN0YWJpbGl0eV8xLkJyb3dzZXJHZXRUZXN0YWJpbGl0eS5pbml0KCk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbi8qKlxyXG4gKiBCb290c3RyYXBwaW5nIGZvciBBbmd1bGFyIGFwcGxpY2F0aW9ucy5cclxuICpcclxuICogWW91IGluc3RhbnRpYXRlIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24gYnkgZXhwbGljaXRseSBzcGVjaWZ5aW5nIGEgY29tcG9uZW50IHRvIHVzZVxyXG4gKiBhcyB0aGUgcm9vdCBjb21wb25lbnQgZm9yIHlvdXIgYXBwbGljYXRpb24gdmlhIHRoZSBgYm9vdHN0cmFwKClgIG1ldGhvZC5cclxuICpcclxuICogIyMgU2ltcGxlIEV4YW1wbGVcclxuICpcclxuICogQXNzdW1pbmcgdGhpcyBgaW5kZXguaHRtbGA6XHJcbiAqXHJcbiAqIGBgYGh0bWxcclxuICogPGh0bWw+XHJcbiAqICAgPCEtLSBsb2FkIEFuZ3VsYXIgc2NyaXB0IHRhZ3MgaGVyZS4gLS0+XHJcbiAqICAgPGJvZHk+XHJcbiAqICAgICA8bXktYXBwPmxvYWRpbmcuLi48L215LWFwcD5cclxuICogICA8L2JvZHk+XHJcbiAqIDwvaHRtbD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEFuIGFwcGxpY2F0aW9uIGlzIGJvb3RzdHJhcHBlZCBpbnNpZGUgYW4gZXhpc3RpbmcgYnJvd3NlciBET00sIHR5cGljYWxseSBgaW5kZXguaHRtbGAuXHJcbiAqIFVubGlrZSBBbmd1bGFyIDEsIEFuZ3VsYXIgMiBkb2VzIG5vdCBjb21waWxlL3Byb2Nlc3MgcHJvdmlkZXJzIGluIGBpbmRleC5odG1sYC4gVGhpcyBpc1xyXG4gKiBtYWlubHkgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGFzIHdlbGwgYXMgYXJjaGl0ZWN0dXJhbCBjaGFuZ2VzIGluIEFuZ3VsYXIgMi4gVGhpcyBtZWFuc1xyXG4gKiB0aGF0IGBpbmRleC5odG1sYCBjYW4gc2FmZWx5IGJlIHByb2Nlc3NlZCB1c2luZyBzZXJ2ZXItc2lkZSB0ZWNobm9sb2dpZXMgc3VjaCBhc1xyXG4gKiBwcm92aWRlcnMuIEJpbmRpbmdzIGNhbiB0aHVzIHVzZSBkb3VibGUtY3VybHkgYHt7IHN5bnRheCB9fWAgd2l0aG91dCBjb2xsaXNpb24gZnJvbVxyXG4gKiBBbmd1bGFyIDIgY29tcG9uZW50IGRvdWJsZS1jdXJseSBge3sgc3ludGF4IH19YC5cclxuICpcclxuICogV2UgY2FuIHVzZSB0aGlzIHNjcmlwdCBjb2RlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcclxuICogICAgdGVtcGxhdGU6ICdIZWxsbyB7eyBuYW1lIH19ISdcclxuICogfSlcclxuICogY2xhc3MgTXlBcHAge1xyXG4gKiAgIG5hbWU6c3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogbWFpbigpIHtcclxuICogICByZXR1cm4gYm9vdHN0cmFwKE15QXBwKTtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogV2hlbiB0aGUgYXBwIGRldmVsb3BlciBpbnZva2VzIGBib290c3RyYXAoKWAgd2l0aCB0aGUgcm9vdCBjb21wb25lbnQgYE15QXBwYCBhcyBpdHNcclxuICogYXJndW1lbnQsIEFuZ3VsYXIgcGVyZm9ybXMgdGhlIGZvbGxvd2luZyB0YXNrczpcclxuICpcclxuICogIDEuIEl0IHVzZXMgdGhlIGNvbXBvbmVudCdzIGBzZWxlY3RvcmAgcHJvcGVydHkgdG8gbG9jYXRlIHRoZSBET00gZWxlbWVudCB3aGljaCBuZWVkc1xyXG4gKiAgICAgdG8gYmUgdXBncmFkZWQgaW50byB0aGUgYW5ndWxhciBjb21wb25lbnQuXHJcbiAqICAyLiBJdCBjcmVhdGVzIGEgbmV3IGNoaWxkIGluamVjdG9yIChmcm9tIHRoZSBwbGF0Zm9ybSBpbmplY3RvcikuIE9wdGlvbmFsbHksIHlvdSBjYW5cclxuICogICAgIGFsc28gb3ZlcnJpZGUgdGhlIGluamVjdG9yIGNvbmZpZ3VyYXRpb24gZm9yIGFuIGFwcCBieSBpbnZva2luZyBgYm9vdHN0cmFwYCB3aXRoIHRoZVxyXG4gKiAgICAgYGNvbXBvbmVudEluamVjdGFibGVCaW5kaW5nc2AgYXJndW1lbnQuXHJcbiAqICAzLiBJdCBjcmVhdGVzIGEgbmV3IGBab25lYCBhbmQgY29ubmVjdHMgaXQgdG8gdGhlIGFuZ3VsYXIgYXBwbGljYXRpb24ncyBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAqICAgICBkb21haW4gaW5zdGFuY2UuXHJcbiAqICA0LiBJdCBjcmVhdGVzIGEgc2hhZG93IERPTSBvbiB0aGUgc2VsZWN0ZWQgY29tcG9uZW50J3MgaG9zdCBlbGVtZW50IGFuZCBsb2FkcyB0aGVcclxuICogICAgIHRlbXBsYXRlIGludG8gaXQuXHJcbiAqICA1LiBJdCBpbnN0YW50aWF0ZXMgdGhlIHNwZWNpZmllZCBjb21wb25lbnQuXHJcbiAqICA2LiBGaW5hbGx5LCBBbmd1bGFyIHBlcmZvcm1zIGNoYW5nZSBkZXRlY3Rpb24gdG8gYXBwbHkgdGhlIGluaXRpYWwgZGF0YSBwcm92aWRlcnMgZm9yIHRoZVxyXG4gKiAgICAgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqXHJcbiAqICMjIEluc3RhbnRpYXRpbmcgTXVsdGlwbGUgQXBwbGljYXRpb25zIG9uIGEgU2luZ2xlIFBhZ2VcclxuICpcclxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIGRvIHRoaXMuXHJcbiAqXHJcbiAqICMjIyBJc29sYXRlZCBBcHBsaWNhdGlvbnNcclxuICpcclxuICogQW5ndWxhciBjcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGVhY2ggdGltZSB0aGF0IHRoZSBgYm9vdHN0cmFwKClgIG1ldGhvZCBpcyBpbnZva2VkLlxyXG4gKiBXaGVuIG11bHRpcGxlIGFwcGxpY2F0aW9ucyBhcmUgY3JlYXRlZCBmb3IgYSBwYWdlLCBBbmd1bGFyIHRyZWF0cyBlYWNoIGFwcGxpY2F0aW9uIGFzXHJcbiAqIGluZGVwZW5kZW50IHdpdGhpbiBhbiBpc29sYXRlZCBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCBgWm9uZWAgZG9tYWluLiBJZiB5b3UgbmVlZCB0byBzaGFyZVxyXG4gKiBkYXRhIGJldHdlZW4gYXBwbGljYXRpb25zLCB1c2UgdGhlIHN0cmF0ZWd5IGRlc2NyaWJlZCBpbiB0aGUgbmV4dCBzZWN0aW9uLCBcIkFwcGxpY2F0aW9uc1xyXG4gKiBUaGF0IFNoYXJlIENoYW5nZSBEZXRlY3Rpb24uXCJcclxuICpcclxuICpcclxuICogIyMjIEFwcGxpY2F0aW9ucyBUaGF0IFNoYXJlIENoYW5nZSBEZXRlY3Rpb25cclxuICpcclxuICogSWYgeW91IG5lZWQgdG8gYm9vdHN0cmFwIG11bHRpcGxlIGFwcGxpY2F0aW9ucyB0aGF0IHNoYXJlIGNvbW1vbiBkYXRhLCB0aGUgYXBwbGljYXRpb25zXHJcbiAqIG11c3Qgc2hhcmUgYSBjb21tb24gY2hhbmdlIGRldGVjdGlvbiBhbmQgem9uZS4gVG8gZG8gdGhhdCwgY3JlYXRlIGEgbWV0YS1jb21wb25lbnQgdGhhdFxyXG4gKiBsaXN0cyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cyBpbiBpdHMgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIEJ5IG9ubHkgaW52b2tpbmcgdGhlIGBib290c3RyYXAoKWAgbWV0aG9kIG9uY2UsIHdpdGggdGhlIG1ldGEtY29tcG9uZW50IGFzIGl0cyBhcmd1bWVudCxcclxuICogeW91IGVuc3VyZSB0aGF0IG9ubHkgYSBzaW5nbGUgY2hhbmdlIGRldGVjdGlvbiB6b25lIGlzIGNyZWF0ZWQgYW5kIHRoZXJlZm9yZSBkYXRhIGNhbiBiZVxyXG4gKiBzaGFyZWQgYWNyb3NzIHRoZSBhcHBsaWNhdGlvbnMuXHJcbiAqXHJcbiAqXHJcbiAqICMjIFBsYXRmb3JtIEluamVjdG9yXHJcbiAqXHJcbiAqIFdoZW4gd29ya2luZyB3aXRoaW4gYSBicm93c2VyIHdpbmRvdywgdGhlcmUgYXJlIG1hbnkgc2luZ2xldG9uIHJlc291cmNlczogY29va2llcywgdGl0bGUsXHJcbiAqIGxvY2F0aW9uLCBhbmQgb3RoZXJzLiBBbmd1bGFyIHNlcnZpY2VzIHRoYXQgcmVwcmVzZW50IHRoZXNlIHJlc291cmNlcyBtdXN0IGxpa2V3aXNlIGJlXHJcbiAqIHNoYXJlZCBhY3Jvc3MgYWxsIEFuZ3VsYXIgYXBwbGljYXRpb25zIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGJyb3dzZXIgd2luZG93LiBGb3IgdGhpc1xyXG4gKiByZWFzb24sIEFuZ3VsYXIgY3JlYXRlcyBleGFjdGx5IG9uZSBnbG9iYWwgcGxhdGZvcm0gaW5qZWN0b3Igd2hpY2ggc3RvcmVzIGFsbCBzaGFyZWRcclxuICogc2VydmljZXMsIGFuZCBlYWNoIGFuZ3VsYXIgYXBwbGljYXRpb24gaW5qZWN0b3IgaGFzIHRoZSBwbGF0Zm9ybSBpbmplY3RvciBhcyBpdHMgcGFyZW50LlxyXG4gKlxyXG4gKiBFYWNoIGFwcGxpY2F0aW9uIGhhcyBpdHMgb3duIHByaXZhdGUgaW5qZWN0b3IgYXMgd2VsbC4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGVcclxuICogYXBwbGljYXRpb25zIG9uIGEgcGFnZSwgQW5ndWxhciB0cmVhdHMgZWFjaCBhcHBsaWNhdGlvbiBpbmplY3RvcidzIHNlcnZpY2VzIGFzIHByaXZhdGVcclxuICogdG8gdGhhdCBhcHBsaWNhdGlvbi5cclxuICpcclxuICpcclxuICogIyBBUElcclxuICogLSBgYXBwQ29tcG9uZW50VHlwZWA6IFRoZSByb290IGNvbXBvbmVudCB3aGljaCBzaG91bGQgYWN0IGFzIHRoZSBhcHBsaWNhdGlvbi4gVGhpcyBpc1xyXG4gKiAgIGEgcmVmZXJlbmNlIHRvIGEgYFR5cGVgIHdoaWNoIGlzIGFubm90YXRlZCB3aXRoIGBAQ29tcG9uZW50KC4uLilgLlxyXG4gKiAtIGBjb21wb25lbnRJbmplY3RhYmxlQmluZGluZ3NgOiBBbiBhZGRpdGlvbmFsIHNldCBvZiBwcm92aWRlcnMgdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlXHJcbiAqICAgYXBwIGluamVjdG9yIHRvIG92ZXJyaWRlIGRlZmF1bHQgaW5qZWN0aW9uIGJlaGF2aW9yLlxyXG4gKiAtIGBlcnJvclJlcG9ydGVyYDogYGZ1bmN0aW9uKGV4Y2VwdGlvbjphbnksIHN0YWNrVHJhY2U6c3RyaW5nKWAgYSBkZWZhdWx0IGVycm9yIHJlcG9ydGVyXHJcbiAqICAgZm9yIHVuaGFuZGxlZCBleGNlcHRpb25zLlxyXG4gKlxyXG4gKiBSZXR1cm5zIGEgYFByb21pc2VgIG9mIHtAbGluayBDb21wb25lbnRSZWZ9LlxyXG4gKi9cclxuZnVuY3Rpb24gY29tbW9uQm9vdHN0cmFwKGFwcENvbXBvbmVudFR5cGUsIGFwcEJpbmRpbmdzKSB7XHJcbiAgICBpZiAoYXBwQmluZGluZ3MgPT09IHZvaWQgMCkgeyBhcHBCaW5kaW5ncyA9IG51bGw7IH1cclxuICAgIHZhciBwID0gcGxhdGZvcm0oKTtcclxuICAgIHZhciBiaW5kaW5ncyA9IFthcHBsaWNhdGlvbl9yZWZfMS5hcHBsaWNhdGlvbkNvbW1vbkJpbmRpbmdzKCksIGFwcGxpY2F0aW9uRG9tQmluZGluZ3MoKV07XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhcHBCaW5kaW5ncykpIHtcclxuICAgICAgICBiaW5kaW5ncy5wdXNoKGFwcEJpbmRpbmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwLmFwcGxpY2F0aW9uKGJpbmRpbmdzKS5ib290c3RyYXAoYXBwQ29tcG9uZW50VHlwZSk7XHJcbn1cclxuZXhwb3J0cy5jb21tb25Cb290c3RyYXAgPSBjb21tb25Cb290c3RyYXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2F0aW9uX2NvbW1vbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3pvbmUvbmdfem9uZScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgYXBwbGljYXRpb25fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX3Rva2VucycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgdGVzdGFiaWxpdHlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3Rlc3RhYmlsaXR5L3Rlc3RhYmlsaXR5Jyk7XHJcbnZhciBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXInKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciB2aWV3X3JlZl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfcmVmJyk7XHJcbnZhciBsaWZlX2N5Y2xlXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saWZlX2N5Y2xlL2xpZmVfY3ljbGUnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgdmlld19wb29sXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19wb29sJyk7XHJcbnZhciB2aWV3X21hbmFnZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X21hbmFnZXInKTtcclxudmFyIHZpZXdfbWFuYWdlcl91dGlsc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfbWFuYWdlcl91dGlscycpO1xyXG52YXIgdmlld19saXN0ZW5lcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3ZpZXdfbGlzdGVuZXInKTtcclxudmFyIHByb3RvX3ZpZXdfZmFjdG9yeV8xID0gcmVxdWlyZSgnLi9saW5rZXIvcHJvdG9fdmlld19mYWN0b3J5Jyk7XHJcbnZhciBwaXBlc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMnKTtcclxudmFyIHZpZXdfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfcmVzb2x2ZXInKTtcclxudmFyIGRpcmVjdGl2ZV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvZGlyZWN0aXZlX3Jlc29sdmVyJyk7XHJcbnZhciBwaXBlX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL2xpbmtlci9waXBlX3Jlc29sdmVyJyk7XHJcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2NvbXBpbGVyJyk7XHJcbnZhciBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMiA9IHJlcXVpcmUoXCIuL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXJcIik7XHJcbnZhciB2aWV3X21hbmFnZXJfMiA9IHJlcXVpcmUoXCIuL2xpbmtlci92aWV3X21hbmFnZXJcIik7XHJcbnZhciBjb21waWxlcl8yID0gcmVxdWlyZShcIi4vbGlua2VyL2NvbXBpbGVyXCIpO1xyXG4vKipcclxuICogQ29uc3RydWN0cyB0aGUgc2V0IG9mIHByb3ZpZGVycyBtZWFudCBmb3IgdXNlIGF0IHRoZSBwbGF0Zm9ybSBsZXZlbC5cclxuICpcclxuICogVGhlc2UgYXJlIHByb3ZpZGVycyB0aGF0IHNob3VsZCBiZSBzaW5nbGV0b25zIHNoYXJlZCBhbW9uZyBhbGwgQW5ndWxhciBhcHBsaWNhdGlvbnNcclxuICogcnVubmluZyBvbiB0aGUgcGFnZS5cclxuICovXHJcbmZ1bmN0aW9uIHBsYXRmb3JtQmluZGluZ3MoKSB7XHJcbiAgICByZXR1cm4gW2RpXzEucHJvdmlkZShyZWZsZWN0aW9uXzEuUmVmbGVjdG9yLCB7IHVzZVZhbHVlOiByZWZsZWN0aW9uXzEucmVmbGVjdG9yIH0pLCB0ZXN0YWJpbGl0eV8xLlRlc3RhYmlsaXR5UmVnaXN0cnldO1xyXG59XHJcbmV4cG9ydHMucGxhdGZvcm1CaW5kaW5ncyA9IHBsYXRmb3JtQmluZGluZ3M7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgcHJvdmlkZXJzIHNwZWNpZmljIHRvIGFuIGluZGl2aWR1YWwgcm9vdCBjb21wb25lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBfY29tcG9uZW50UHJvdmlkZXJzKGFwcENvbXBvbmVudFR5cGUpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9DT01QT05FTlQsIHsgdXNlVmFsdWU6IGFwcENvbXBvbmVudFR5cGUgfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9DT01QT05FTlRfUkVGX1BST01JU0UsIHtcclxuICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKGR5bmFtaWNDb21wb25lbnRMb2FkZXIsIGluamVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHJhZG8pOiBpbnZlc3RpZ2F0ZSB3aGV0aGVyIHRvIHN1cHBvcnQgYmluZGluZ3Mgb24gcm9vdCBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHluYW1pY0NvbXBvbmVudExvYWRlci5sb2FkQXNSb290KGFwcENvbXBvbmVudFR5cGUsIG51bGwsIGluamVjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IuZ2V0KHRlc3RhYmlsaXR5XzEuVGVzdGFiaWxpdHlSZWdpc3RyeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWdpc3RlckFwcGxpY2F0aW9uKGNvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBpbmplY3Rvci5nZXQodGVzdGFiaWxpdHlfMS5UZXN0YWJpbGl0eSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlcHM6IFtkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMS5EeW5hbWljQ29tcG9uZW50TG9hZGVyLCBkaV8xLkluamVjdG9yXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShhcHBDb21wb25lbnRUeXBlLCB7XHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRoZW4oZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLmluc3RhbmNlOyB9KTsgfSxcclxuICAgICAgICAgICAgZGVwczogW2FwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9DT01QT05FTlRfUkVGX1BST01JU0VdXHJcbiAgICAgICAgfSksXHJcbiAgICBdO1xyXG59XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgYSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIGluIGFueSBBbmd1bGFyXHJcbiAqIGFwcGxpY2F0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgcnVucyBvbiB0aGUgVUkgdGhyZWFkIG9yIGluIGEgd2ViIHdvcmtlci5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGxpY2F0aW9uQ29tbW9uQmluZGluZ3MoKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGRpXzEucHJvdmlkZShjb21waWxlcl8xLkNvbXBpbGVyLCB7IHVzZUNsYXNzOiBjb21waWxlcl8yLkNvbXBpbGVyXyB9KSxcclxuICAgICAgICBhcHBsaWNhdGlvbl90b2tlbnNfMS5BUFBfSURfUkFORE9NX1BST1ZJREVSLFxyXG4gICAgICAgIHZpZXdfcG9vbF8xLkFwcFZpZXdQb29sLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZSh2aWV3X3Bvb2xfMS5BUFBfVklFV19QT09MX0NBUEFDSVRZLCB7IHVzZVZhbHVlOiAxMDAwMCB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUodmlld19tYW5hZ2VyXzEuQXBwVmlld01hbmFnZXIsIHsgdXNlQ2xhc3M6IHZpZXdfbWFuYWdlcl8yLkFwcFZpZXdNYW5hZ2VyXyB9KSxcclxuICAgICAgICB2aWV3X21hbmFnZXJfdXRpbHNfMS5BcHBWaWV3TWFuYWdlclV0aWxzLFxyXG4gICAgICAgIHZpZXdfbGlzdGVuZXJfMS5BcHBWaWV3TGlzdGVuZXIsXHJcbiAgICAgICAgcHJvdG9fdmlld19mYWN0b3J5XzEuUHJvdG9WaWV3RmFjdG9yeSxcclxuICAgICAgICB2aWV3X3Jlc29sdmVyXzEuVmlld1Jlc29sdmVyLFxyXG4gICAgICAgIHBpcGVzXzEuREVGQVVMVF9QSVBFUyxcclxuICAgICAgICBkaV8xLnByb3ZpZGUoY2hhbmdlX2RldGVjdGlvbl8xLkl0ZXJhYmxlRGlmZmVycywgeyB1c2VWYWx1ZTogY2hhbmdlX2RldGVjdGlvbl8xLmRlZmF1bHRJdGVyYWJsZURpZmZlcnMgfSksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGNoYW5nZV9kZXRlY3Rpb25fMS5LZXlWYWx1ZURpZmZlcnMsIHsgdXNlVmFsdWU6IGNoYW5nZV9kZXRlY3Rpb25fMS5kZWZhdWx0S2V5VmFsdWVEaWZmZXJzIH0pLFxyXG4gICAgICAgIGRpcmVjdGl2ZV9yZXNvbHZlcl8xLkRpcmVjdGl2ZVJlc29sdmVyLFxyXG4gICAgICAgIHBpcGVfcmVzb2x2ZXJfMS5QaXBlUmVzb2x2ZXIsXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8xLkR5bmFtaWNDb21wb25lbnRMb2FkZXIsIHsgdXNlQ2xhc3M6IGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8yLkR5bmFtaWNDb21wb25lbnRMb2FkZXJfIH0pLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShsaWZlX2N5Y2xlXzEuTGlmZUN5Y2xlLCB7XHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChleGNlcHRpb25IYW5kbGVyKSB7IHJldHVybiBuZXcgbGlmZV9jeWNsZV8xLkxpZmVDeWNsZV8obnVsbCwgbGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCkpOyB9LFxyXG4gICAgICAgICAgICBkZXBzOiBbZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXJdXHJcbiAgICAgICAgfSlcclxuICAgIF07XHJcbn1cclxuZXhwb3J0cy5hcHBsaWNhdGlvbkNvbW1vbkJpbmRpbmdzID0gYXBwbGljYXRpb25Db21tb25CaW5kaW5ncztcclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBbmd1bGFyIHpvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVOZ1pvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IG5nX3pvbmVfMS5OZ1pvbmUoeyBlbmFibGVMb25nU3RhY2tUcmFjZTogbGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCkgfSk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVOZ1pvbmUgPSBjcmVhdGVOZ1pvbmU7XHJcbnZhciBfcGxhdGZvcm07XHJcbmZ1bmN0aW9uIHBsYXRmb3JtQ29tbW9uKGJpbmRpbmdzLCBpbml0aWFsaXplcikge1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3BsYXRmb3JtKSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhiaW5kaW5ncykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgXCJwbGF0Zm9ybSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBwYWdlXCI7XHJcbiAgICB9XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbml0aWFsaXplcikpIHtcclxuICAgICAgICBpbml0aWFsaXplcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGJpbmRpbmdzKSkge1xyXG4gICAgICAgIGJpbmRpbmdzID0gcGxhdGZvcm1CaW5kaW5ncygpO1xyXG4gICAgfVxyXG4gICAgX3BsYXRmb3JtID0gbmV3IFBsYXRmb3JtUmVmXyhkaV8xLkluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoYmluZGluZ3MpLCBmdW5jdGlvbiAoKSB7IF9wbGF0Zm9ybSA9IG51bGw7IH0pO1xyXG4gICAgcmV0dXJuIF9wbGF0Zm9ybTtcclxufVxyXG5leHBvcnRzLnBsYXRmb3JtQ29tbW9uID0gcGxhdGZvcm1Db21tb247XHJcbi8qKlxyXG4gKiBUaGUgQW5ndWxhciBwbGF0Zm9ybSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIEFuZ3VsYXIgb24gYSB3ZWIgcGFnZS4gRWFjaCBwYWdlXHJcbiAqIGhhcyBleGFjdGx5IG9uZSBwbGF0Zm9ybSwgYW5kIHNlcnZpY2VzIChzdWNoIGFzIHJlZmxlY3Rpb24pIHdoaWNoIGFyZSBjb21tb25cclxuICogdG8gZXZlcnkgQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIHRoZSBwYWdlIGFyZSBib3VuZCBpbiBpdHMgc2NvcGUuXHJcbiAqXHJcbiAqIEEgcGFnZSdzIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkIGltcGxpY2l0bHkgd2hlbiB7QGxpbmsgYm9vdHN0cmFwfSgpIGlzIGNhbGxlZCwgb3JcclxuICogZXhwbGljaXRseSBieSBjYWxsaW5nIHtAbGluayBwbGF0Zm9ybX0oKS5cclxuICovXHJcbnZhciBQbGF0Zm9ybVJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybVJlZigpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB7QGxpbmsgSW5qZWN0b3J9LCB3aGljaCBpcyB0aGUgcGFyZW50IGluamVjdG9yIGZvclxyXG4gICAgICAgICAqIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gb24gdGhlIHBhZ2UgYW5kIHByb3ZpZGVzIHNpbmdsZXRvbiBwcm92aWRlcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIHJldHVybiBQbGF0Zm9ybVJlZjtcclxufSkoKTtcclxuZXhwb3J0cy5QbGF0Zm9ybVJlZiA9IFBsYXRmb3JtUmVmO1xyXG52YXIgUGxhdGZvcm1SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQbGF0Zm9ybVJlZl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybVJlZl8oX2luamVjdG9yLCBfZGlzcG9zZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2UgPSBfZGlzcG9zZTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKGJpbmRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGFwcCA9IHRoaXMuX2luaXRBcHAoY3JlYXRlTmdab25lKCksIGJpbmRpbmdzKTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxuICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuYXN5bmNBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uIChiaW5kaW5nRm4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB6b25lID0gY3JlYXRlTmdab25lKCk7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlciA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuY29tcGxldGVyKCk7XHJcbiAgICAgICAgem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLnRoZW4oYmluZGluZ0ZuKHpvbmUpLCBmdW5jdGlvbiAoYmluZGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZXNvbHZlKF90aGlzLl9pbml0QXBwKHpvbmUsIGJpbmRpbmdzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZXIucHJvbWlzZTtcclxuICAgIH07XHJcbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9pbml0QXBwID0gZnVuY3Rpb24gKHpvbmUsIHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGluamVjdG9yO1xyXG4gICAgICAgIHZhciBhcHA7XHJcbiAgICAgICAgem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChkaV8xLnByb3ZpZGUobmdfem9uZV8xLk5nWm9uZSwgeyB1c2VWYWx1ZTogem9uZSB9KSk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKGRpXzEucHJvdmlkZShBcHBsaWNhdGlvblJlZiwgeyB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHA7IH0sIGRlcHM6IFtdIH0pKTtcclxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbkhhbmRsZXI7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RvciA9IF90aGlzLmluamVjdG9yLnJlc29sdmVBbmRDcmVhdGVDaGlsZChwcm92aWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlciA9IGluamVjdG9yLmdldChleGNlcHRpb25zXzEuRXhjZXB0aW9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB6b25lLm92ZXJyaWRlT25FcnJvckhhbmRsZXIoZnVuY3Rpb24gKGUsIHMpIHsgcmV0dXJuIGV4Y2VwdGlvbkhhbmRsZXIuY2FsbChlLCBzKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4Y2VwdGlvbkhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlci5jYWxsKGUsIGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ubG9nRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhcHAgPSBuZXcgQXBwbGljYXRpb25SZWZfKHRoaXMsIHpvbmUsIGluamVjdG9yKTtcclxuICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMucHVzaChhcHApO1xyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICB9O1xyXG4gICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHsgcmV0dXJuIGFwcC5kaXNwb3NlKCk7IH0pO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9hcHBsaWNhdGlvbkRpc3Bvc2VkID0gZnVuY3Rpb24gKGFwcCkgeyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuX2FwcGxpY2F0aW9ucywgYXBwKTsgfTtcclxuICAgIHJldHVybiBQbGF0Zm9ybVJlZl87XHJcbn0pKFBsYXRmb3JtUmVmKTtcclxuZXhwb3J0cy5QbGF0Zm9ybVJlZl8gPSBQbGF0Zm9ybVJlZl87XHJcbi8qKlxyXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gYSBwYWdlLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBhYm91dCBBbmd1bGFyIGFwcGxpY2F0aW9ucywgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB7QGxpbmsgYm9vdHN0cmFwfS5cclxuICovXHJcbnZhciBBcHBsaWNhdGlvblJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZigpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBhcHBsaWNhdGlvbiB7QGxpbmsgSW5qZWN0b3J9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWYucHJvdG90eXBlLCBcInpvbmVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBhcHBsaWNhdGlvbiB7QGxpbmsgTmdab25lfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgbGlzdCBvZiBjb21wb25lbnQgdHlwZXMgcmVnaXN0ZXJlZCB0byB0aGlzIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQXBwbGljYXRpb25SZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwbGljYXRpb25SZWYgPSBBcHBsaWNhdGlvblJlZjtcclxudmFyIEFwcGxpY2F0aW9uUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXBwbGljYXRpb25SZWZfKF9wbGF0Zm9ybSwgX3pvbmUsIF9pbmplY3Rvcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xyXG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcclxuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcclxuICAgICAgICB0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRUeXBlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5yZWdpc3RlckJvb3RzdHJhcExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fYm9vdHN0cmFwTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfTtcclxuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlciA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuY29tcGxldGVyKCk7XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UHJvdmlkZXJzID0gX2NvbXBvbmVudFByb3ZpZGVycyhjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvdmlkZXJzLnB1c2gocHJvdmlkZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uSGFuZGxlciA9IF90aGlzLl9pbmplY3Rvci5nZXQoZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXIpO1xyXG4gICAgICAgICAgICBfdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBfdGhpcy5faW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKGNvbXBvbmVudFByb3ZpZGVycyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcFJlZlRva2VuID0gaW5qZWN0b3IuZ2V0KGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9DT01QT05FTlRfUkVGX1BST01JU0UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcENoYW5nZURldGVjdG9yID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KS5jaGFuZ2VEZXRlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGMgPSBpbmplY3Rvci5nZXQobGlmZV9jeWNsZV8xLkxpZmVDeWNsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGMucmVnaXN0ZXJXaXRoKF90aGlzLl96b25lLCBhcHBDaGFuZ2VEZXRlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGMudGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZXNvbHZlKGNvbXBvbmVudFJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jvb3RDb21wb25lbnRzLnB1c2goY29tcG9uZW50UmVmKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYm9vdHN0cmFwTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihjb21wb25lbnRSZWYpOyB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlja1Jlc3VsdCA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIudGhlbihjb21wUmVmVG9rZW4sIHRpY2spO1xyXG4gICAgICAgICAgICAgICAgYXN5bmNfMS5Qcm9taXNlV3JhcHBlci50aGVuKHRpY2tSZXN1bHQsIGZ1bmN0aW9uIChfKSB7IH0pO1xyXG4gICAgICAgICAgICAgICAgYXN5bmNfMS5Qcm9taXNlV3JhcHBlci50aGVuKHRpY2tSZXN1bHQsIG51bGwsIGZ1bmN0aW9uIChlcnIsIHN0YWNrVHJhY2UpIHsgcmV0dXJuIGNvbXBsZXRlci5yZWplY3QoZXJyLCBzdGFja1RyYWNlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIuY2FsbChlLCBlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZWplY3QoZSwgZS5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGVyLnByb21pc2U7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5qZWN0b3I7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiem9uZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl96b25lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IERpc3Bvc2Ugb2YgdGhlIE5nWm9uZS5cclxuICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi5kaXNwb3NlKCk7IH0pO1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtLl9hcHBsaWNhdGlvbkRpc3Bvc2VkKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3RDb21wb25lbnRUeXBlczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQXBwbGljYXRpb25SZWZfO1xyXG59KShBcHBsaWNhdGlvblJlZik7XHJcbmV4cG9ydHMuQXBwbGljYXRpb25SZWZfID0gQXBwbGljYXRpb25SZWZfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhdGlvbl9yZWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiAgQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnRzLkFQUF9DT01QT05FTlRfUkVGX1BST01JU0UgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5PcGFxdWVUb2tlbignUHJvbWlzZTxDb21wb25lbnRSZWY+JykpO1xyXG4vKipcclxuICogQW4ge0BsaW5rIGFuZ3VsYXIyL2RpL09wYXF1ZVRva2VufSByZXByZXNlbnRpbmcgdGhlIGFwcGxpY2F0aW9uIHJvb3QgdHlwZSBpbiB0aGUge0BsaW5rXHJcbiAqIEluamVjdG9yfS5cclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoLi4uKVxyXG4gKiBjbGFzcyBNeUFwcCB7XHJcbiAqICAgLi4uXHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKE15QXBwKS50aGVuKChhcHBSZWY6QXBwbGljYXRpb25SZWYpIHtcclxuICogICBleHBlY3QoYXBwUmVmLmluamVjdG9yLmdldChhcHBDb21wb25lbnRUeXBlVG9rZW4pKS50b0VxdWFsKE15QXBwKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5BUFBfQ09NUE9ORU5UID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oJ0FwcENvbXBvbmVudCcpKTtcclxuLyoqXHJcbiAqIEEgREkgVG9rZW4gcmVwcmVzZW50aW5nIGEgdW5pcXVlIHN0cmluZyBpZCBhc3NpZ25lZCB0byB0aGUgYXBwbGljYXRpb24gYnkgQW5ndWxhciBhbmQgdXNlZFxyXG4gKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cclxuICoge0BsaW5rIFZpZXdFbmNhcHN1bGF0aW9uI0VtdWxhdGVkfSBpcyBiZWluZyB1c2VkLlxyXG4gKlxyXG4gKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXHJcbiAqIGEgY3VzdG9tIHZhbHVlIHZpYSBhIERJIHByb3ZpZGVyIDwhLS0gVE9ETzogcHJvdmlkZXIgLS0+IGNvbmZpZ3VyaW5nIHRoZSByb290IHtAbGluayBJbmplY3Rvcn1cclxuICogdXNpbmcgdGhpcyB0b2tlbi5cclxuICovXHJcbmV4cG9ydHMuQVBQX0lEID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oJ0FwcElkJykpO1xyXG5mdW5jdGlvbiBfYXBwSWRSYW5kb21Qcm92aWRlckZhY3RvcnkoKSB7XHJcbiAgICByZXR1cm4gXCJcIiArIF9yYW5kb21DaGFyKCkgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKTtcclxufVxyXG4vKipcclxuICogQmluZGluZ3MgdGhhdCB3aWxsIGdlbmVyYXRlIGEgcmFuZG9tIEFQUF9JRF9UT0tFTi5cclxuICovXHJcbmV4cG9ydHMuQVBQX0lEX1JBTkRPTV9QUk9WSURFUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKGV4cG9ydHMuQVBQX0lELCB7IHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSwgZGVwczogW10gfSkpO1xyXG5mdW5jdGlvbiBfcmFuZG9tQ2hhcigpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoOTcgKyBsYW5nXzEuTWF0aC5mbG9vcihsYW5nXzEuTWF0aC5yYW5kb20oKSAqIDI1KSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYXRpb25fdG9rZW5zLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBOb3RlOiBUaGlzIGZpbGUgb25seSBleGlzdHMgc28gdGhhdCBEYXJ0IHVzZXJzIGNhbiBpbXBvcnRcclxuLy8gYm9vdHN0cmFwIGZyb20gYW5ndWxhcjIvYm9vdHN0cmFwLiBKUyB1c2VycyBzaG91bGQgaW1wb3J0XHJcbi8vIGZyb20gYW5ndWxhcjIvY29yZS5cclxudmFyIGFwcGxpY2F0aW9uXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uJyk7XHJcbmV4cG9ydHMuYm9vdHN0cmFwID0gYXBwbGljYXRpb25fMS5ib290c3RyYXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENoYW5nZSBkZXRlY3Rpb24gZW5hYmxlcyBkYXRhIGJpbmRpbmcgaW4gQW5ndWxhci5cclxuICovXHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xyXG5leHBvcnRzLkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uID0gY2hhbmdlX2RldGVjdGlvbl8xLkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvbkVycm9yID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvbkVycm9yO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yUmVmO1xyXG5leHBvcnRzLldyYXBwZWRWYWx1ZSA9IGNoYW5nZV9kZXRlY3Rpb25fMS5XcmFwcGVkVmFsdWU7XHJcbmV4cG9ydHMuU2ltcGxlQ2hhbmdlID0gY2hhbmdlX2RldGVjdGlvbl8xLlNpbXBsZUNoYW5nZTtcclxuZXhwb3J0cy5JdGVyYWJsZURpZmZlcnMgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuSXRlcmFibGVEaWZmZXJzO1xyXG5leHBvcnRzLktleVZhbHVlRGlmZmVycyA9IGNoYW5nZV9kZXRlY3Rpb25fMS5LZXlWYWx1ZURpZmZlcnM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdGlvbl91dGlsJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0b3JfcmVmXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rvcl9yZWYnKTtcclxudmFyIGV4Y2VwdGlvbnNfMiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9ucycpO1xyXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG52YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi4vcHJvZmlsZS9wcm9maWxlJyk7XHJcbnZhciBvYnNlcnZhYmxlX2ZhY2FkZV8xID0gcmVxdWlyZSgnLi9vYnNlcnZhYmxlX2ZhY2FkZScpO1xyXG52YXIgX3Njb3BlX2NoZWNrID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKFwiQ2hhbmdlRGV0ZWN0b3IjY2hlY2soYXNjaWkgaWQsIGJvb2wgdGhyb3dPbkNoYW5nZSlcIik7XHJcbnZhciBfQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfQ29udGV4dChlbGVtZW50LCBjb21wb25lbnRFbGVtZW50LCBjb250ZXh0LCBsb2NhbHMsIGluamVjdG9yLCBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudEVsZW1lbnQgPSBjb21wb25lbnRFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBsb2NhbHM7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX0NvbnRleHQ7XHJcbn0pKCk7XHJcbnZhciBBYnN0cmFjdENoYW5nZURldGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IoaWQsIGRpc3BhdGNoZXIsIG51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMsIGJpbmRpbmdUYXJnZXRzLCBkaXJlY3RpdmVJbmRpY2VzLCBzdHJhdGVneSkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZQcm9wZXJ0eVByb3RvUmVjb3JkcyA9IG51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHM7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nVGFyZ2V0cyA9IGJpbmRpbmdUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlSW5kaWNlcyA9IGRpcmVjdGl2ZUluZGljZXM7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMubGlnaHREb21DaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tQ2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAvLyBUaGUgbmFtZXMgb2YgdGhlIGJlbG93IGZpZWxkcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIGNvZGVnZW5fbmFtZV91dGlsLnRzIG9yXHJcbiAgICAgICAgLy8gY2hhbmdlIGRldGVjdGlvbiB3aWxsIGZhaWwuXHJcbiAgICAgICAgdGhpcy5hbHJlYWR5Q2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGlwZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVmID0gbmV3IGNoYW5nZV9kZXRlY3Rvcl9yZWZfMS5DaGFuZ2VEZXRlY3RvclJlZl8odGhpcyk7XHJcbiAgICB9XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjZCkge1xyXG4gICAgICAgIHRoaXMubGlnaHREb21DaGlsZHJlbi5wdXNoKGNkKTtcclxuICAgICAgICBjZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNkKSB7IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUodGhpcy5saWdodERvbUNoaWxkcmVuLCBjZCk7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZGRTaGFkb3dEb21DaGlsZCA9IGZ1bmN0aW9uIChjZCkge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tQ2hpbGRyZW4ucHVzaChjZCk7XHJcbiAgICAgICAgY2QucGFyZW50ID0gdGhpcztcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5yZW1vdmVTaGFkb3dEb21DaGlsZCA9IGZ1bmN0aW9uIChjZCkgeyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuc2hhZG93RG9tQ2hpbGRyZW4sIGNkKTsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsSW5kZXgsIGxvY2Fscykge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmhhbmRsZUV2ZW50SW50ZXJuYWwoZXZlbnROYW1lLCBlbEluZGV4LCBsb2NhbHMpO1xyXG4gICAgICAgIHRoaXMubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaGFuZGxlRXZlbnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsSW5kZXgsIGxvY2FscykgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJ1bkRldGVjdENoYW5nZXMoZmFsc2UpOyB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vdCBpbXBsZW1lbnRlZFwiKTsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLnJ1bkRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRldGFjaGVkIHx8XHJcbiAgICAgICAgICAgIHRoaXMubW9kZSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBzID0gX3Njb3BlX2NoZWNrKHRoaXMuaWQsIHRocm93T25DaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkcyh0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLl9kZXRlY3RDaGFuZ2VzSW5MaWdodERvbUNoaWxkcmVuKHRocm93T25DaGFuZ2UpO1xyXG4gICAgICAgIGlmICghdGhyb3dPbkNoYW5nZSlcclxuICAgICAgICAgICAgdGhpcy5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoKTtcclxuICAgICAgICB0aGlzLl9kZXRlY3RDaGFuZ2VzSW5TaGFkb3dEb21DaGlsZHJlbih0aHJvd09uQ2hhbmdlKTtcclxuICAgICAgICBpZiAoIXRocm93T25DaGFuZ2UpXHJcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tPbmNlKVxyXG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja2VkO1xyXG4gICAgICAgIHRoaXMuYWxyZWFkeUNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgIH07XHJcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbi4gU3ViY2xhc3NlcyBzaG91bGQgaW5zdGVhZCBwcm92aWRlIGFuXHJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsYCB3aGljaCBkb2VzIHRoZSB3b3JrIG9mIGRldGVjdGluZyBjaGFuZ2VzXHJcbiAgICAvLyBhbmQgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBjYWxsLlxyXG4gICAgLy8gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGF0IGBkZXRlY3RDaGFuZ2VzSW5SZWNvcmRzSW50ZXJuYWxgIHdpbGwgc2V0IHRoZSBwcm9wZXJ0eVxyXG4gICAgLy8gYHRoaXMucHJvcGVydHlCaW5kaW5nSW5kZXhgIHRvIHRoZSBwcm9wZXJ0eUJpbmRpbmdJbmRleCBvZiB0aGUgZmlyc3QgcHJvdG8gcmVjb3JkLiBUaGlzIGlzIHRvXHJcbiAgICAvLyBmYWNpbGl0YXRlIGVycm9yIHJlcG9ydGluZy5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdENoYW5nZXNJblJlY29yZHMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5oeWRyYXRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyb3dEZWh5ZHJhdGVkRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW5SZWNvcmRzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoZSwgZS5zdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gYW55IHdvcmsgbmVjZXNzYXJ5IHRvIGRldGVjdCBhbmQgcmVwb3J0XHJcbiAgICAvLyBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgY2hhbmdlcyBzaG91bGQgYmUgcmVwb3J0ZWQgdmlhIGBDaGFuZ2VEZXRlY3Rpb25VdGlsLmFkZENoYW5nZWAsIGxpZmVjeWNsZVxyXG4gICAgLy8gbWV0aG9kcyBzaG91bGQgYmUgY2FsbGVkLCBldGMuXHJcbiAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHNob3VsZCBhbHNvIHNldCBgdGhpcy5wcm9wZXJ0eUJpbmRpbmdJbmRleGAgdG8gdGhlIHByb3BlcnR5QmluZGluZ0luZGV4IG9mXHJcbiAgICAvLyB0aGVcclxuICAgIC8vIGZpcnN0IHByb3RvIHJlY29yZCB0byBmYWNpbGl0YXRlIGVycm9yIHJlcG9ydGluZy4gU2VlIHtAbGluayAjZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc30uXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzSW5SZWNvcmRzSW50ZXJuYWwgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkgeyB9O1xyXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4uIFN1YmNsYXNzZXMgc2hvdWxkIGluc3RlYWQgcHJvdmlkZSBhblxyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgYGh5ZHJhdGVEaXJlY3RpdmVzYC5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbG9jYWxzLCBkaXJlY3RpdmVzLCBwaXBlcykge1xyXG4gICAgICAgIHRoaXMubW9kZSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuY2hhbmdlRGV0ZWN0aW9uTW9kZSh0aGlzLnN0cmF0ZWd5KTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLnN0cmF0ZWd5ID09PSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hPYnNlcnZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUNvbXBvbmVudChjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBsb2NhbHM7XHJcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZURpcmVjdGl2ZXMoZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgdGhpcy5hbHJlYWR5Q2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGh5ZHJhdGUgYW55IGRpcmVjdGl2ZXMuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7IH07XHJcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbi4gU3ViY2xhc3NlcyBzaG91bGQgaW5zdGVhZCBwcm92aWRlIGFuXHJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVoeWRyYXRlRGlyZWN0aXZlc2AuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5kZWh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWh5ZHJhdGVEaXJlY3RpdmVzKHRydWUpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgICAgICBpZiAodGhpcy5zdHJhdGVneSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoT2JzZXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl91bnN1YnNyaWJlRnJvbU9ic2VydmFibGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGlwZXMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRlaHlkcmF0ZSBhbnkgZGlyZWN0aXZlcy4gVGhpcyBtZXRob2Qgc2hvdWxkIHJldmVyc2VcclxuICAgIC8vIGFueSB3b3JrIGRvbmUgaW4gYGh5ZHJhdGVEaXJlY3RpdmVzYC5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmRlaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGVzdHJveVBpcGVzKSB7IH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oeWRyYXRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCAhPT0gbnVsbDsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIubm90aWZ5QWZ0ZXJDb250ZW50Q2hlY2tlZCgpO1xyXG4gICAgICAgIHRoaXMuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzSW50ZXJuYWwoKTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIubm90aWZ5QWZ0ZXJWaWV3Q2hlY2tlZCgpO1xyXG4gICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzSW50ZXJuYWwoKTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9kZXRlY3RDaGFuZ2VzSW5MaWdodERvbUNoaWxkcmVuID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMubGlnaHREb21DaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY1tpXS5ydW5EZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZGV0ZWN0Q2hhbmdlc0luU2hhZG93RG9tQ2hpbGRyZW4gPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5zaGFkb3dEb21DaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY1tpXS5ydW5EZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5tYXJrQXNDaGVja09uY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMubW9kZSA9IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZTsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KGMpICYmIGMubW9kZSAhPT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGV0YWNoZWQpIHtcclxuICAgICAgICAgICAgaWYgKGMubW9kZSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tlZClcclxuICAgICAgICAgICAgICAgIGMubW9kZSA9IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZTtcclxuICAgICAgICAgICAgYyA9IGMucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiBXb3JrcyBvbmx5IGluIERhcnQuXHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fdW5zdWJzcmliZUZyb21PYnNlcnZhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnN1YnNjcmlwdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuc3Vic2NyaXB0aW9uc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gV29ya3Mgb25seSBpbiBEYXJ0LlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUub2JzZXJ2ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9ic2VydmFibGVfZmFjYWRlXzEuaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVBcnJheVRvU3RvcmVPYnNlcnZhYmxlcygpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5zdWJzY3JpcHRpb25zW2luZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtc1tpbmRleF0gPSB2YWx1ZS5jaGFuZ2VzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zW2luZGV4XSA9IHZhbHVlLmNoYW5nZXMubGlzdGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5yZWYubWFya0ZvckNoZWNrKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtc1tpbmRleF0gIT09IHZhbHVlLmNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpbmRleF0uY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbXNbaW5kZXhdID0gdmFsdWUuY2hhbmdlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSB2YWx1ZS5jaGFuZ2VzLmxpc3RlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMucmVmLm1hcmtGb3JDaGVjaygpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gV29ya3Mgb25seSBpbiBEYXJ0LlxyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUub2JzZXJ2ZURpcmVjdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvYnNlcnZhYmxlX2ZhY2FkZV8xLmlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXJyYXlUb1N0b3JlT2JzZXJ2YWJsZXMoKTtcclxuICAgICAgICAgICAgdmFyIGFycmF5SW5kZXggPSB0aGlzLm51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMgKyBpbmRleCArIDI7IC8vICsxIGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbXNbYXJyYXlJbmRleF0gPSB2YWx1ZS5jaGFuZ2VzO1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbYXJyYXlJbmRleF0gPSB2YWx1ZS5jaGFuZ2VzLmxpc3RlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMucmVmLm1hcmtGb3JDaGVjaygpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLm9ic2VydmVDb21wb25lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvYnNlcnZhYmxlX2ZhY2FkZV8xLmlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXJyYXlUb1N0b3JlT2JzZXJ2YWJsZXMoKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5udW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzICsgMTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zW2luZGV4XSA9IHZhbHVlLmNoYW5nZXM7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSB2YWx1ZS5jaGFuZ2VzLmxpc3RlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMucmVmLm1hcmtGb3JDaGVjaygpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9jcmVhdGVBcnJheVRvU3RvcmVPYnNlcnZhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5zdWJzY3JpcHRpb25zKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHRoaXMubnVtYmVyT2ZQcm9wZXJ0eVByb3RvUmVjb3JkcyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZUluZGljZXMubGVuZ3RoICsgMik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodGhpcy5udW1iZXJPZlByb3BlcnR5UHJvdG9SZWNvcmRzICtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlSW5kaWNlcy5sZW5ndGggKyAyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlRm9yID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuZ2V0RGlyZWN0aXZlRm9yKHRoaXMuZGlyZWN0aXZlSW5kaWNlc1tpbmRleF0pO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmdldERldGVjdG9yRm9yID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuZ2V0RGV0ZWN0b3JGb3IodGhpcy5kaXJlY3RpdmVJbmRpY2VzW2luZGV4XSk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUubm90aWZ5RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5ub3RpZnlPbkJpbmRpbmcodGhpcy5fY3VycmVudEJpbmRpbmcoKSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmxvZ0JpbmRpbmdVcGRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIubG9nQmluZGluZ1VwZGF0ZSh0aGlzLl9jdXJyZW50QmluZGluZygpLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuYWRkQ2hhbmdlID0gZnVuY3Rpb24gKGNoYW5nZXMsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjaGFuZ2VzKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYW5nZXNbdGhpcy5fY3VycmVudEJpbmRpbmcoKS5uYW1lXSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuc2ltcGxlQ2hhbmdlKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3Rocm93RXJyb3IgPSBmdW5jdGlvbiAoZXhjZXB0aW9uLCBzdGFjaykge1xyXG4gICAgICAgIHZhciBlcnJvcjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZGlzcGF0Y2hlci5nZXREZWJ1Z0NvbnRleHQodGhpcy5fY3VycmVudEJpbmRpbmcoKS5lbGVtZW50SW5kZXgsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGxhbmdfMS5pc1ByZXNlbnQoYykgPyBuZXcgX0NvbnRleHQoYy5lbGVtZW50LCBjLmNvbXBvbmVudEVsZW1lbnQsIGMuY29udGV4dCwgYy5sb2NhbHMsIGMuaW5qZWN0b3IsIHRoaXMuX2N1cnJlbnRCaW5kaW5nKCkuZGVidWcpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgIGVycm9yID0gbmV3IGV4Y2VwdGlvbnNfMi5DaGFuZ2VEZXRlY3Rpb25FcnJvcih0aGlzLl9jdXJyZW50QmluZGluZygpLmRlYnVnLCBleGNlcHRpb24sIHN0YWNrLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gaWYgYW4gZXJyb3IgaGFwcGVucyBkdXJpbmcgZ2V0dGluZyB0aGUgZGVidWcgY29udGV4dCwgd2UgdGhyb3cgYSBDaGFuZ2VEZXRlY3Rpb25FcnJvclxyXG4gICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBleHRyYSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgZXhjZXB0aW9uc18yLkNoYW5nZURldGVjdGlvbkVycm9yKG51bGwsIGV4Y2VwdGlvbiwgc3RhY2ssIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdENoYW5nZURldGVjdG9yLnByb3RvdHlwZS50aHJvd09uQ2hhbmdlRXJyb3IgPSBmdW5jdGlvbiAob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbih0aGlzLl9jdXJyZW50QmluZGluZygpLmRlYnVnLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLnRocm93RGVoeWRyYXRlZEVycm9yID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgZXhjZXB0aW9uc18yLkRlaHlkcmF0ZWRFeGNlcHRpb24oKTsgfTtcclxuICAgIEFic3RyYWN0Q2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9jdXJyZW50QmluZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nVGFyZ2V0c1t0aGlzLnByb3BlcnR5QmluZGluZ0luZGV4XTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWJzdHJhY3RDaGFuZ2VEZXRlY3RvcjtcclxufSkoKTtcclxuZXhwb3J0cy5BYnN0cmFjdENoYW5nZURldGVjdG9yID0gQWJzdHJhY3RDaGFuZ2VEZXRlY3RvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIERJUkVDVElWRV9MSUZFQ1lDTEUgPSBcImRpcmVjdGl2ZUxpZmVjeWNsZVwiO1xyXG52YXIgQklORElORyA9IFwibmF0aXZlXCI7XHJcbnZhciBESVJFQ1RJVkUgPSBcImRpcmVjdGl2ZVwiO1xyXG52YXIgRUxFTUVOVF9QUk9QRVJUWSA9IFwiZWxlbWVudFByb3BlcnR5XCI7XHJcbnZhciBFTEVNRU5UX0FUVFJJQlVURSA9IFwiZWxlbWVudEF0dHJpYnV0ZVwiO1xyXG52YXIgRUxFTUVOVF9DTEFTUyA9IFwiZWxlbWVudENsYXNzXCI7XHJcbnZhciBFTEVNRU5UX1NUWUxFID0gXCJlbGVtZW50U3R5bGVcIjtcclxudmFyIFRFWFRfTk9ERSA9IFwidGV4dE5vZGVcIjtcclxudmFyIEVWRU5UID0gXCJldmVudFwiO1xyXG52YXIgSE9TVF9FVkVOVCA9IFwiaG9zdEV2ZW50XCI7XHJcbnZhciBCaW5kaW5nVGFyZ2V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJpbmRpbmdUYXJnZXQobW9kZSwgZWxlbWVudEluZGV4LCBuYW1lLCB1bml0LCBkZWJ1Zykge1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50SW5kZXggPSBlbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcclxuICAgIH1cclxuICAgIEJpbmRpbmdUYXJnZXQucHJvdG90eXBlLmlzRGlyZWN0aXZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tb2RlID09PSBESVJFQ1RJVkU7IH07XHJcbiAgICBCaW5kaW5nVGFyZ2V0LnByb3RvdHlwZS5pc0VsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRUxFTUVOVF9QUk9QRVJUWTsgfTtcclxuICAgIEJpbmRpbmdUYXJnZXQucHJvdG90eXBlLmlzRWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRUxFTUVOVF9BVFRSSUJVVEU7IH07XHJcbiAgICBCaW5kaW5nVGFyZ2V0LnByb3RvdHlwZS5pc0VsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRUxFTUVOVF9DTEFTUzsgfTtcclxuICAgIEJpbmRpbmdUYXJnZXQucHJvdG90eXBlLmlzRWxlbWVudFN0eWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tb2RlID09PSBFTEVNRU5UX1NUWUxFOyB9O1xyXG4gICAgQmluZGluZ1RhcmdldC5wcm90b3R5cGUuaXNUZXh0Tm9kZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gVEVYVF9OT0RFOyB9O1xyXG4gICAgcmV0dXJuIEJpbmRpbmdUYXJnZXQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQmluZGluZ1RhcmdldCA9IEJpbmRpbmdUYXJnZXQ7XHJcbnZhciBCaW5kaW5nUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJpbmRpbmdSZWNvcmQobW9kZSwgdGFyZ2V0LCBpbXBsaWNpdFJlY2VpdmVyLCBhc3QsIHNldHRlciwgbGlmZWN5Y2xlRXZlbnQsIGRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5pbXBsaWNpdFJlY2VpdmVyID0gaW1wbGljaXRSZWNlaXZlcjtcclxuICAgICAgICB0aGlzLmFzdCA9IGFzdDtcclxuICAgICAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcclxuICAgICAgICB0aGlzLmxpZmVjeWNsZUV2ZW50ID0gbGlmZWN5Y2xlRXZlbnQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVSZWNvcmQgPSBkaXJlY3RpdmVSZWNvcmQ7XHJcbiAgICB9XHJcbiAgICBCaW5kaW5nUmVjb3JkLnByb3RvdHlwZS5pc0RpcmVjdGl2ZUxpZmVjeWNsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gRElSRUNUSVZFX0xJRkVDWUNMRTsgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQucHJvdG90eXBlLmNhbGxPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5kaXJlY3RpdmVSZWNvcmQpICYmIHRoaXMuZGlyZWN0aXZlUmVjb3JkLmNhbGxPbkNoYW5nZXM7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5wcm90b3R5cGUuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayh0aGlzLmRpcmVjdGl2ZVJlY29yZCkgfHwgdGhpcy5kaXJlY3RpdmVSZWNvcmQuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVEaXJlY3RpdmVEb0NoZWNrID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChESVJFQ1RJVkVfTElGRUNZQ0xFLCBudWxsLCAwLCBudWxsLCBudWxsLCBcIkRvQ2hlY2tcIiwgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZURpcmVjdGl2ZU9uSW5pdCA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoRElSRUNUSVZFX0xJRkVDWUNMRSwgbnVsbCwgMCwgbnVsbCwgbnVsbCwgXCJPbkluaXRcIiwgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZURpcmVjdGl2ZU9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoRElSRUNUSVZFX0xJRkVDWUNMRSwgbnVsbCwgMCwgbnVsbCwgbnVsbCwgXCJPbkNoYW5nZXNcIiwgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckRpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIHByb3BlcnR5TmFtZSwgc2V0dGVyLCBkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudEluZGV4ID0gZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleDtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KERJUkVDVElWRSwgZWxlbWVudEluZGV4LCBwcm9wZXJ0eU5hbWUsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoRElSRUNUSVZFLCB0LCAwLCBhc3QsIHNldHRlciwgbnVsbCwgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGVsZW1lbnRJbmRleCwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChFTEVNRU5UX1BST1BFUlRZLCBlbGVtZW50SW5kZXgsIHByb3BlcnR5TmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCAwLCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhc3QsIGVsZW1lbnRJbmRleCwgYXR0cmlidXRlTmFtZSkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9BVFRSSUJVVEUsIGVsZW1lbnRJbmRleCwgYXR0cmlidXRlTmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCAwLCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudENsYXNzID0gZnVuY3Rpb24gKGFzdCwgZWxlbWVudEluZGV4LCBjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVMRU1FTlRfQ0xBU1MsIGVsZW1lbnRJbmRleCwgY2xhc3NOYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEJJTkRJTkcsIHQsIDAsIGFzdCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAoYXN0LCBlbGVtZW50SW5kZXgsIHN0eWxlTmFtZSwgdW5pdCkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9TVFlMRSwgZWxlbWVudEluZGV4LCBzdHlsZU5hbWUsIHVuaXQsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgMCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbmRleCwgYXN0LCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICB2YXIgdCA9IG5ldyBCaW5kaW5nVGFyZ2V0KEVMRU1FTlRfUFJPUEVSVFksIGRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleCwgcHJvcGVydHlOYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEJJTkRJTkcsIHQsIGRpcmVjdGl2ZUluZGV4LCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbmRleCwgYXN0LCBhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChFTEVNRU5UX0FUVFJJQlVURSwgZGlyZWN0aXZlSW5kZXguZWxlbWVudEluZGV4LCBhdHRyaWJ1dGVOYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEJJTkRJTkcsIHQsIGRpcmVjdGl2ZUluZGV4LCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdENsYXNzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4LCBhc3QsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRUxFTUVOVF9DTEFTUywgZGlyZWN0aXZlSW5kZXguZWxlbWVudEluZGV4LCBjbGFzc05hbWUsIG51bGwsIGFzdC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZWNvcmQoQklORElORywgdCwgZGlyZWN0aXZlSW5kZXgsIGFzdCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgQmluZGluZ1JlY29yZC5jcmVhdGVGb3JIb3N0U3R5bGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgsIGFzdCwgc3R5bGVOYW1lLCB1bml0KSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChFTEVNRU5UX1NUWUxFLCBkaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXgsIHN0eWxlTmFtZSwgdW5pdCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCBkaXJlY3RpdmVJbmRleCwgYXN0LCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcbiAgICBCaW5kaW5nUmVjb3JkLmNyZWF0ZUZvclRleHROb2RlID0gZnVuY3Rpb24gKGFzdCwgZWxlbWVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChURVhUX05PREUsIGVsZW1lbnRJbmRleCwgbnVsbCwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChCSU5ESU5HLCB0LCAwLCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBldmVudE5hbWUsIGVsZW1lbnRJbmRleCkge1xyXG4gICAgICAgIHZhciB0ID0gbmV3IEJpbmRpbmdUYXJnZXQoRVZFTlQsIGVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBudWxsLCBhc3QudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVjb3JkKEVWRU5ULCB0LCAwLCBhc3QsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnROYW1lLCBkaXJlY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlSW5kZXggPSBkaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXg7XHJcbiAgICAgICAgdmFyIHQgPSBuZXcgQmluZGluZ1RhcmdldChIT1NUX0VWRU5ULCBkaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgbnVsbCwgYXN0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1JlY29yZChIT1NUX0VWRU5ULCB0LCBkaXJlY3RpdmVJbmRleCwgYXN0LCBudWxsLCBudWxsLCBkaXJlY3RpdmVSZWNvcmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCaW5kaW5nUmVjb3JkO1xyXG59KSgpO1xyXG5leHBvcnRzLkJpbmRpbmdSZWNvcmQgPSBCaW5kaW5nUmVjb3JkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nX3JlY29yZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGl0ZXJhYmxlX2RpZmZlcnNfMSA9IHJlcXVpcmUoJy4vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzJyk7XHJcbnZhciBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8xID0gcmVxdWlyZSgnLi9kaWZmZXJzL2RlZmF1bHRfaXRlcmFibGVfZGlmZmVyJyk7XHJcbnZhciBrZXl2YWx1ZV9kaWZmZXJzXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMva2V5dmFsdWVfZGlmZmVycycpO1xyXG52YXIgZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXJfMSA9IHJlcXVpcmUoJy4vZGlmZmVycy9kZWZhdWx0X2tleXZhbHVlX2RpZmZlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzdF8xID0gcmVxdWlyZSgnLi9wYXJzZXIvYXN0Jyk7XHJcbmV4cG9ydHMuQVNUV2l0aFNvdXJjZSA9IGFzdF8xLkFTVFdpdGhTb3VyY2U7XHJcbmV4cG9ydHMuQVNUID0gYXN0XzEuQVNUO1xyXG5leHBvcnRzLkFzdFRyYW5zZm9ybWVyID0gYXN0XzEuQXN0VHJhbnNmb3JtZXI7XHJcbmV4cG9ydHMuUHJvcGVydHlSZWFkID0gYXN0XzEuUHJvcGVydHlSZWFkO1xyXG5leHBvcnRzLkxpdGVyYWxBcnJheSA9IGFzdF8xLkxpdGVyYWxBcnJheTtcclxuZXhwb3J0cy5JbXBsaWNpdFJlY2VpdmVyID0gYXN0XzEuSW1wbGljaXRSZWNlaXZlcjtcclxudmFyIGxleGVyXzEgPSByZXF1aXJlKCcuL3BhcnNlci9sZXhlcicpO1xyXG5leHBvcnRzLkxleGVyID0gbGV4ZXJfMS5MZXhlcjtcclxudmFyIHBhcnNlcl8xID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2VyJyk7XHJcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyXzEuUGFyc2VyO1xyXG52YXIgbG9jYWxzXzEgPSByZXF1aXJlKCcuL3BhcnNlci9sb2NhbHMnKTtcclxuZXhwb3J0cy5Mb2NhbHMgPSBsb2NhbHNfMS5Mb2NhbHM7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbnMnKTtcclxuZXhwb3J0cy5EZWh5ZHJhdGVkRXhjZXB0aW9uID0gZXhjZXB0aW9uc18xLkRlaHlkcmF0ZWRFeGNlcHRpb247XHJcbmV4cG9ydHMuRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24gPSBleGNlcHRpb25zXzEuRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb247XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uRXJyb3IgPSBleGNlcHRpb25zXzEuQ2hhbmdlRGV0ZWN0aW9uRXJyb3I7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMnKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvckRlZmluaXRpb24gPSBpbnRlcmZhY2VzXzEuQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uO1xyXG5leHBvcnRzLkRlYnVnQ29udGV4dCA9IGludGVyZmFjZXNfMS5EZWJ1Z0NvbnRleHQ7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWcgPSBpbnRlcmZhY2VzXzEuQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWc7XHJcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcclxuZXhwb3J0cy5DSEFOR0VfREVDVElPTl9TVFJBVEVHWV9WQUxVRVMgPSBjb25zdGFudHNfMS5DSEFOR0VfREVDVElPTl9TVFJBVEVHWV9WQUxVRVM7XHJcbnZhciBwcm90b19jaGFuZ2VfZGV0ZWN0b3JfMSA9IHJlcXVpcmUoJy4vcHJvdG9fY2hhbmdlX2RldGVjdG9yJyk7XHJcbmV4cG9ydHMuRHluYW1pY1Byb3RvQ2hhbmdlRGV0ZWN0b3IgPSBwcm90b19jaGFuZ2VfZGV0ZWN0b3JfMS5EeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxudmFyIGppdF9wcm90b19jaGFuZ2VfZGV0ZWN0b3JfMSA9IHJlcXVpcmUoJy4vaml0X3Byb3RvX2NoYW5nZV9kZXRlY3RvcicpO1xyXG5leHBvcnRzLkppdFByb3RvQ2hhbmdlRGV0ZWN0b3IgPSBqaXRfcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEuSml0UHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxudmFyIGJpbmRpbmdfcmVjb3JkXzEgPSByZXF1aXJlKCcuL2JpbmRpbmdfcmVjb3JkJyk7XHJcbmV4cG9ydHMuQmluZGluZ1JlY29yZCA9IGJpbmRpbmdfcmVjb3JkXzEuQmluZGluZ1JlY29yZDtcclxuZXhwb3J0cy5CaW5kaW5nVGFyZ2V0ID0gYmluZGluZ19yZWNvcmRfMS5CaW5kaW5nVGFyZ2V0O1xyXG52YXIgZGlyZWN0aXZlX3JlY29yZF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfcmVjb3JkJyk7XHJcbmV4cG9ydHMuRGlyZWN0aXZlSW5kZXggPSBkaXJlY3RpdmVfcmVjb3JkXzEuRGlyZWN0aXZlSW5kZXg7XHJcbmV4cG9ydHMuRGlyZWN0aXZlUmVjb3JkID0gZGlyZWN0aXZlX3JlY29yZF8xLkRpcmVjdGl2ZVJlY29yZDtcclxudmFyIGR5bmFtaWNfY2hhbmdlX2RldGVjdG9yXzEgPSByZXF1aXJlKCcuL2R5bmFtaWNfY2hhbmdlX2RldGVjdG9yJyk7XHJcbmV4cG9ydHMuRHluYW1pY0NoYW5nZURldGVjdG9yID0gZHluYW1pY19jaGFuZ2VfZGV0ZWN0b3JfMS5EeW5hbWljQ2hhbmdlRGV0ZWN0b3I7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0b3JfcmVmXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rvcl9yZWYnKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZV9kZXRlY3Rvcl9yZWZfMS5DaGFuZ2VEZXRlY3RvclJlZjtcclxudmFyIGl0ZXJhYmxlX2RpZmZlcnNfMiA9IHJlcXVpcmUoJy4vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzJyk7XHJcbmV4cG9ydHMuSXRlcmFibGVEaWZmZXJzID0gaXRlcmFibGVfZGlmZmVyc18yLkl0ZXJhYmxlRGlmZmVycztcclxudmFyIGtleXZhbHVlX2RpZmZlcnNfMiA9IHJlcXVpcmUoJy4vZGlmZmVycy9rZXl2YWx1ZV9kaWZmZXJzJyk7XHJcbmV4cG9ydHMuS2V5VmFsdWVEaWZmZXJzID0ga2V5dmFsdWVfZGlmZmVyc18yLktleVZhbHVlRGlmZmVycztcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwnKTtcclxuZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5XcmFwcGVkVmFsdWU7XHJcbmV4cG9ydHMuU2ltcGxlQ2hhbmdlID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuU2ltcGxlQ2hhbmdlO1xyXG4vKipcclxuICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgT2JqZWN0YHMgYW5kIGBNYXBgcy5cclxuICovXHJcbmV4cG9ydHMua2V5VmFsRGlmZiA9IGxhbmdfMS5DT05TVF9FWFBSKFtsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXJfMS5EZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5KCkpXSk7XHJcbi8qKlxyXG4gKiBTdHJ1Y3R1cmFsIGRpZmZpbmcgZm9yIGBJdGVyYWJsZWAgdHlwZXMgc3VjaCBhcyBgQXJyYXlgcy5cclxuICovXHJcbmV4cG9ydHMuaXRlcmFibGVEaWZmID0gbGFuZ18xLkNPTlNUX0VYUFIoW2xhbmdfMS5DT05TVF9FWFBSKG5ldyBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8xLkRlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkoKSldKTtcclxuZXhwb3J0cy5kZWZhdWx0SXRlcmFibGVEaWZmZXJzID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGl0ZXJhYmxlX2RpZmZlcnNfMS5JdGVyYWJsZURpZmZlcnMoZXhwb3J0cy5pdGVyYWJsZURpZmYpKTtcclxuZXhwb3J0cy5kZWZhdWx0S2V5VmFsdWVEaWZmZXJzID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGtleXZhbHVlX2RpZmZlcnNfMS5LZXlWYWx1ZURpZmZlcnMoZXhwb3J0cy5rZXlWYWxEaWZmKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvcl8xID0gcmVxdWlyZSgnLi9hYnN0cmFjdF9jaGFuZ2VfZGV0ZWN0b3InKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwnKTtcclxudmFyIGNvZGVnZW5fbmFtZV91dGlsXzEgPSByZXF1aXJlKCcuL2NvZGVnZW5fbmFtZV91dGlsJyk7XHJcbnZhciBjb2RlZ2VuX2xvZ2ljX3V0aWxfMSA9IHJlcXVpcmUoJy4vY29kZWdlbl9sb2dpY191dGlsJyk7XHJcbnZhciBjb2RlZ2VuX2ZhY2FkZV8xID0gcmVxdWlyZSgnLi9jb2RlZ2VuX2ZhY2FkZScpO1xyXG52YXIgcHJvdG9fY2hhbmdlX2RldGVjdG9yXzEgPSByZXF1aXJlKCcuL3Byb3RvX2NoYW5nZV9kZXRlY3RvcicpO1xyXG4vKipcclxuICogVGhlIGNvZGUgZ2VuZXJhdG9yIHRha2VzIGEgbGlzdCBvZiBwcm90byByZWNvcmRzIGFuZCBjcmVhdGVzIGEgZnVuY3Rpb24vY2xhc3NcclxuICogdGhhdCBcImVtdWxhdGVzXCIgd2hhdCB0aGUgZGV2ZWxvcGVyIHdvdWxkIHdyaXRlIGJ5IGhhbmQgdG8gaW1wbGVtZW50IHRoZSBzYW1lXHJcbiAqIGtpbmQgb2YgYmVoYXZpb3VyLlxyXG4gKlxyXG4gKiBUaGlzIGNvZGUgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBEYXJ0IHRyYW5zZm9ybWVyJ3NcclxuICogYGFuZ3VsYXIyLnRyYW5zZm9ybS50ZW1wbGF0ZV9jb21waWxlci5jaGFuZ2VfZGV0ZWN0b3JfY29kZWdlbmAgbGlicmFyeS4gSWYgeW91IG1ha2UgdXBkYXRlc1xyXG4gKiBoZXJlLCBwbGVhc2UgbWFrZSBlcXVpdmFsZW50IGNoYW5nZXMgdGhlcmUuXHJcbiovXHJcbnZhciBJU19DSEFOR0VEX0xPQ0FMID0gXCJpc0NoYW5nZWRcIjtcclxudmFyIENIQU5HRVNfTE9DQUwgPSBcImNoYW5nZXNcIjtcclxudmFyIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yKGRlZmluaXRpb24sIGNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lLCBhYnN0cmFjdENoYW5nZURldGVjdG9yVmFyTmFtZSkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWUgPSBjaGFuZ2VEZXRlY3Rpb25VdGlsVmFyTmFtZTtcclxuICAgICAgICB0aGlzLmFic3RyYWN0Q2hhbmdlRGV0ZWN0b3JWYXJOYW1lID0gYWJzdHJhY3RDaGFuZ2VEZXRlY3RvclZhck5hbWU7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5QmluZGluZ1JlY29yZHMgPSBwcm90b19jaGFuZ2VfZGV0ZWN0b3JfMS5jcmVhdGVQcm9wZXJ0eVJlY29yZHMoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdmFyIGV2ZW50QmluZGluZ1JlY29yZHMgPSBwcm90b19jaGFuZ2VfZGV0ZWN0b3JfMS5jcmVhdGVFdmVudFJlY29yZHMoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5QmluZGluZ1RhcmdldHMgPSBkZWZpbml0aW9uLmJpbmRpbmdSZWNvcmRzLm1hcChmdW5jdGlvbiAoYikgeyByZXR1cm4gYi50YXJnZXQ7IH0pO1xyXG4gICAgICAgIHRoaXMuaWQgPSBkZWZpbml0aW9uLmlkO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBkZWZpbml0aW9uLnN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMuZ2VuQ29uZmlnID0gZGVmaW5pdGlvbi5nZW5Db25maWc7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gcHJvcGVydHlCaW5kaW5nUmVjb3JkcztcclxuICAgICAgICB0aGlzLnByb3BlcnR5QmluZGluZ1RhcmdldHMgPSBwcm9wZXJ0eUJpbmRpbmdUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMuZXZlbnRCaW5kaW5ncyA9IGV2ZW50QmluZGluZ1JlY29yZHM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVSZWNvcmRzID0gZGVmaW5pdGlvbi5kaXJlY3RpdmVSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuX25hbWVzID0gbmV3IGNvZGVnZW5fbmFtZV91dGlsXzEuQ29kZWdlbk5hbWVVdGlsKHRoaXMucmVjb3JkcywgdGhpcy5ldmVudEJpbmRpbmdzLCB0aGlzLmRpcmVjdGl2ZVJlY29yZHMsIHRoaXMuY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWUpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2ljID0gbmV3IGNvZGVnZW5fbG9naWNfdXRpbF8xLkNvZGVnZW5Mb2dpY1V0aWwodGhpcy5fbmFtZXMsIHRoaXMuY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWUsIHRoaXMuY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBjb2RlZ2VuX25hbWVfdXRpbF8xLnNhbml0aXplTmFtZShcIkNoYW5nZURldGVjdG9yX1wiICsgdGhpcy5pZCk7XHJcbiAgICB9XHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnlTb3VyY2UgPSBcIlxcbiAgICAgIFwiICsgdGhpcy5nZW5lcmF0ZVNvdXJjZSgpICsgXCJcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGlzcGF0Y2hlcikge1xcbiAgICAgICAgcmV0dXJuIG5ldyBcIiArIHRoaXMudHlwZU5hbWUgKyBcIihkaXNwYXRjaGVyKTtcXG4gICAgICB9XFxuICAgIFwiO1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24odGhpcy5hYnN0cmFjdENoYW5nZURldGVjdG9yVmFyTmFtZSwgdGhpcy5jaGFuZ2VEZXRlY3Rpb25VdGlsVmFyTmFtZSwgZmFjdG9yeVNvdXJjZSkoYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yXzEuQWJzdHJhY3RDaGFuZ2VEZXRlY3RvciwgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbCk7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlU291cmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgdmFyIFwiICsgdGhpcy50eXBlTmFtZSArIFwiID0gZnVuY3Rpb24gXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIoZGlzcGF0Y2hlcikge1xcbiAgICAgICAgXCIgKyB0aGlzLmFic3RyYWN0Q2hhbmdlRGV0ZWN0b3JWYXJOYW1lICsgXCIuY2FsbChcXG4gICAgICAgICAgICB0aGlzLCBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuaWQpICsgXCIsIGRpc3BhdGNoZXIsIFwiICsgdGhpcy5yZWNvcmRzLmxlbmd0aCArIFwiLFxcbiAgICAgICAgICAgIFwiICsgdGhpcy50eXBlTmFtZSArIFwiLmdlbl9wcm9wZXJ0eUJpbmRpbmdUYXJnZXRzLCBcIiArIHRoaXMudHlwZU5hbWUgKyBcIi5nZW5fZGlyZWN0aXZlSW5kaWNlcyxcXG4gICAgICAgICAgICBcIiArIGNvZGVnZW5fZmFjYWRlXzEuY29kaWZ5KHRoaXMuY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpICsgXCIpO1xcbiAgICAgICAgdGhpcy5kZWh5ZHJhdGVEaXJlY3RpdmVzKGZhbHNlKTtcXG4gICAgICB9XFxuXFxuICAgICAgXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIiArIHRoaXMuYWJzdHJhY3RDaGFuZ2VEZXRlY3RvclZhck5hbWUgKyBcIi5wcm90b3R5cGUpO1xcblxcbiAgICAgIFwiICsgdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzSW5SZWNvcmRzSW50ZXJuYWwgPSBmdW5jdGlvbih0aHJvd09uQ2hhbmdlKSB7XFxuICAgICAgICBcIiArIHRoaXMuX25hbWVzLmdlbkluaXRMb2NhbHMoKSArIFwiXFxuICAgICAgICB2YXIgXCIgKyBJU19DSEFOR0VEX0xPQ0FMICsgXCIgPSBmYWxzZTtcXG4gICAgICAgIHZhciBcIiArIENIQU5HRVNfTE9DQUwgKyBcIiA9IG51bGw7XFxuXFxuICAgICAgICBcIiArIHRoaXMucmVjb3Jkcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF90aGlzLl9nZW5SZWNvcmQocik7IH0pLmpvaW4oXCJcXG5cIikgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICBcIiArIHRoaXMuX21heWJlR2VuSGFuZGxlRXZlbnRJbnRlcm5hbCgpICsgXCJcXG5cXG4gICAgICBcIiArIHRoaXMuX2dlbkNoZWNrTm9DaGFuZ2VzKCkgKyBcIlxcblxcbiAgICAgIFwiICsgdGhpcy5fbWF5YmVHZW5BZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoKSArIFwiXFxuXFxuICAgICAgXCIgKyB0aGlzLl9tYXliZUdlbkFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcygpICsgXCJcXG5cXG4gICAgICBcIiArIHRoaXMuX21heWJlR2VuSHlkcmF0ZURpcmVjdGl2ZXMoKSArIFwiXFxuXFxuICAgICAgXCIgKyB0aGlzLl9tYXliZUdlbkRlaHlkcmF0ZURpcmVjdGl2ZXMoKSArIFwiXFxuXFxuICAgICAgXCIgKyB0aGlzLl9nZW5Qcm9wZXJ0eUJpbmRpbmdUYXJnZXRzKCkgKyBcIlxcblxcbiAgICAgIFwiICsgdGhpcy5fZ2VuRGlyZWN0aXZlSW5kaWNlcygpICsgXCJcXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5Qcm9wZXJ0eUJpbmRpbmdUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5fbG9naWMuZ2VuUHJvcGVydHlCaW5kaW5nVGFyZ2V0cyh0aGlzLnByb3BlcnR5QmluZGluZ1RhcmdldHMsIHRoaXMuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU5hbWUgKyBcIi5nZW5fcHJvcGVydHlCaW5kaW5nVGFyZ2V0cyA9IFwiICsgdGFyZ2V0cyArIFwiO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuRGlyZWN0aXZlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuX2xvZ2ljLmdlbkRpcmVjdGl2ZUluZGljZXModGhpcy5kaXJlY3RpdmVSZWNvcmRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSArIFwiLmdlbl9kaXJlY3RpdmVJbmRpY2VzID0gXCIgKyBpbmRpY2VzICsgXCI7XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9tYXliZUdlbkhhbmRsZUV2ZW50SW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5ldmVudEJpbmRpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5ldmVudEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoZWIpIHsgcmV0dXJuIF90aGlzLl9nZW5FdmVudEJpbmRpbmcoZWIpOyB9KS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIFwiICsgdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5oYW5kbGVFdmVudEludGVybmFsID0gZnVuY3Rpb24oZXZlbnROYW1lLCBlbEluZGV4LCBsb2NhbHMpIHtcXG4gICAgICAgICAgdmFyIFwiICsgdGhpcy5fbmFtZXMuZ2V0UHJldmVudERlZmF1bHRBY2Nlc29yKCkgKyBcIiA9IGZhbHNlO1xcbiAgICAgICAgICBcIiArIHRoaXMuX25hbWVzLmdlbkluaXRFdmVudExvY2FscygpICsgXCJcXG4gICAgICAgICAgXCIgKyBoYW5kbGVycyArIFwiXFxuICAgICAgICAgIHJldHVybiBcIiArIHRoaXMuX25hbWVzLmdldFByZXZlbnREZWZhdWx0QWNjZXNvcigpICsgXCI7XFxuICAgICAgICB9XFxuICAgICAgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuRXZlbnRCaW5kaW5nID0gZnVuY3Rpb24gKGViKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVjcyA9IGViLnJlY29yZHMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy5fZ2VuRXZlbnRCaW5kaW5nRXZhbChlYiwgcik7IH0pLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGlmIChldmVudE5hbWUgPT09IFxcXCJcIiArIGViLmV2ZW50TmFtZSArIFwiXFxcIiAmJiBlbEluZGV4ID09PSBcIiArIGViLmVsSW5kZXggKyBcIikge1xcbiAgICAgIFwiICsgcmVjcyArIFwiXFxuICAgIH1cIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkV2ZW50QmluZGluZ0V2YWwgPSBmdW5jdGlvbiAoZWIsIHIpIHtcclxuICAgICAgICBpZiAoci5sYXN0SW5CaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBldmFsUmVjb3JkID0gdGhpcy5fbG9naWMuZ2VuRXZlbnRCaW5kaW5nRXZhbFZhbHVlKGViLCByKTtcclxuICAgICAgICAgICAgdmFyIG1hcmtQYXRoID0gdGhpcy5fZ2VuTWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZShyKTtcclxuICAgICAgICAgICAgdmFyIHByZXZEZWZhdWx0ID0gdGhpcy5fZ2VuVXBkYXRlUHJldmVudERlZmF1bHQoZWIsIHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZhbFJlY29yZCArIFwiXFxuXCIgKyBtYXJrUGF0aCArIFwiXFxuXCIgKyBwcmV2RGVmYXVsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dpYy5nZW5FdmVudEJpbmRpbmdFdmFsVmFsdWUoZWIsIHIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbk1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBiciA9IHIuYmluZGluZ1JlY29yZDtcclxuICAgICAgICBpZiAoYnIuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXMuZ2V0RGV0ZWN0b3JOYW1lKGJyLmRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkgKyBcIi5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlKCk7XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuVXBkYXRlUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZWIsIHIpIHtcclxuICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLl9uYW1lcy5nZXRFdmVudExvY2FsTmFtZShlYiwgci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBcImlmIChcIiArIGxvY2FsICsgXCIgPT09IGZhbHNlKSB7IFwiICsgdGhpcy5fbmFtZXMuZ2V0UHJldmVudERlZmF1bHRBY2Nlc29yKCkgKyBcIiA9IHRydWV9O1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVHZW5EZWh5ZHJhdGVEaXJlY3RpdmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZXN0cm95UGlwZXNDb2RlID0gdGhpcy5fbmFtZXMuZ2VuUGlwZU9uRGVzdHJveSgpO1xyXG4gICAgICAgIGlmIChkZXN0cm95UGlwZXNDb2RlKSB7XHJcbiAgICAgICAgICAgIGRlc3Ryb3lQaXBlc0NvZGUgPSBcImlmIChkZXN0cm95UGlwZXMpIHsgXCIgKyBkZXN0cm95UGlwZXNDb2RlICsgXCIgfVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVoeWRyYXRlRmllbGRzQ29kZSA9IHRoaXMuX25hbWVzLmdlbkRlaHlkcmF0ZUZpZWxkcygpO1xyXG4gICAgICAgIGlmICghZGVzdHJveVBpcGVzQ29kZSAmJiAhZGVoeWRyYXRlRmllbGRzQ29kZSlcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lICsgXCIucHJvdG90eXBlLmRlaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbihkZXN0cm95UGlwZXMpIHtcXG4gICAgICAgIFwiICsgZGVzdHJveVBpcGVzQ29kZSArIFwiXFxuICAgICAgICBcIiArIGRlaHlkcmF0ZUZpZWxkc0NvZGUgKyBcIlxcbiAgICB9XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9tYXliZUdlbkh5ZHJhdGVEaXJlY3RpdmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoeWRyYXRlRGlyZWN0aXZlc0NvZGUgPSB0aGlzLl9sb2dpYy5nZW5IeWRyYXRlRGlyZWN0aXZlcyh0aGlzLmRpcmVjdGl2ZVJlY29yZHMpO1xyXG4gICAgICAgIHZhciBoeWRyYXRlRGV0ZWN0b3JzQ29kZSA9IHRoaXMuX2xvZ2ljLmdlbkh5ZHJhdGVEZXRlY3RvcnModGhpcy5kaXJlY3RpdmVSZWNvcmRzKTtcclxuICAgICAgICBpZiAoIWh5ZHJhdGVEaXJlY3RpdmVzQ29kZSAmJiAhaHlkcmF0ZURldGVjdG9yc0NvZGUpXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSArIFwiLnByb3RvdHlwZS5oeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uKGRpcmVjdGl2ZXMpIHtcXG4gICAgICBcIiArIGh5ZHJhdGVEaXJlY3RpdmVzQ29kZSArIFwiXFxuICAgICAgXCIgKyBoeWRyYXRlRGV0ZWN0b3JzQ29kZSArIFwiXFxuICAgIH1cIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX21heWJlR2VuQWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25zID0gdGhpcy5fbG9naWMuZ2VuQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyh0aGlzLmRpcmVjdGl2ZVJlY29yZHMpO1xyXG4gICAgICAgIGlmIChub3RpZmljYXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyB0aGlzLnR5cGVOYW1lICsgXCIucHJvdG90eXBlLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIFwiICsgZGlyZWN0aXZlTm90aWZpY2F0aW9ucyArIFwiXFxuICAgICAgICB9XFxuICAgICAgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fbWF5YmVHZW5BZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbnMgPSB0aGlzLl9sb2dpYy5nZW5WaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKHRoaXMuZGlyZWN0aXZlUmVjb3Jkcyk7XHJcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlTm90aWZpY2F0aW9ucyA9IG5vdGlmaWNhdGlvbnMuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIHRoaXMudHlwZU5hbWUgKyBcIi5wcm90b3R5cGUuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzSW50ZXJuYWwgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgXCIgKyBkaXJlY3RpdmVOb3RpZmljYXRpb25zICsgXCJcXG4gICAgICAgIH1cXG4gICAgICBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5SZWNvcmQgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciByZWM7XHJcbiAgICAgICAgaWYgKHIuaXNMaWZlQ3ljbGVSZWNvcmQoKSkge1xyXG4gICAgICAgICAgICByZWMgPSB0aGlzLl9nZW5EaXJlY3RpdmVMaWZlY3ljbGUocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHIuaXNQaXBlUmVjb3JkKCkpIHtcclxuICAgICAgICAgICAgcmVjID0gdGhpcy5fZ2VuUGlwZUNoZWNrKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVjID0gdGhpcy5fZ2VuUmVmZXJlbmNlQ2hlY2socik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgdGhpcy5fbWF5YmVGaXJzdEluQmluZGluZyhyKSArIFwiXFxuICAgICAgXCIgKyByZWMgKyBcIlxcbiAgICAgIFwiICsgdGhpcy5fbWF5YmVHZW5MYXN0SW5EaXJlY3RpdmUocikgKyBcIlxcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkRpcmVjdGl2ZUxpZmVjeWNsZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgaWYgKHIubmFtZSA9PT0gXCJEb0NoZWNrXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbk9uQ2hlY2socik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHIubmFtZSA9PT0gXCJPbkluaXRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuT25Jbml0KHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyLm5hbWUgPT09IFwiT25DaGFuZ2VzXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbk9uQ2hhbmdlKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBsaWZlY3ljbGUgZXZlbnQgJ1wiICsgci5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlblBpcGVDaGVjayA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX25hbWVzLmdldExvY2FsTmFtZShyLmNvbnRleHRJbmRleCk7XHJcbiAgICAgICAgdmFyIGFyZ1N0cmluZyA9IHIuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gX3RoaXMuX25hbWVzLmdldExvY2FsTmFtZShhcmcpOyB9KS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0RmllbGROYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciBwaXBlID0gdGhpcy5fbmFtZXMuZ2V0UGlwZU5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciBwaXBlTmFtZSA9IHIubmFtZTtcclxuICAgICAgICB2YXIgaW5pdCA9IFwiXFxuICAgICAgaWYgKFwiICsgcGlwZSArIFwiID09PSBcIiArIHRoaXMuY2hhbmdlRGV0ZWN0aW9uVXRpbFZhck5hbWUgKyBcIi51bmluaXRpYWxpemVkKSB7XFxuICAgICAgICBcIiArIHBpcGUgKyBcIiA9IFwiICsgdGhpcy5fbmFtZXMuZ2V0UGlwZXNBY2Nlc3Nvck5hbWUoKSArIFwiLmdldCgnXCIgKyBwaXBlTmFtZSArIFwiJyk7XFxuICAgICAgfVxcbiAgICBcIjtcclxuICAgICAgICB2YXIgcmVhZCA9IG5ld1ZhbHVlICsgXCIgPSBcIiArIHBpcGUgKyBcIi5waXBlLnRyYW5zZm9ybShcIiArIGNvbnRleHQgKyBcIiwgW1wiICsgYXJnU3RyaW5nICsgXCJdKTtcIjtcclxuICAgICAgICB2YXIgY29udGV4T3JBcmdDaGVjayA9IHIuYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aGlzLl9uYW1lcy5nZXRDaGFuZ2VOYW1lKGEpOyB9KTtcclxuICAgICAgICBjb250ZXhPckFyZ0NoZWNrLnB1c2godGhpcy5fbmFtZXMuZ2V0Q2hhbmdlTmFtZShyLmNvbnRleHRJbmRleCkpO1xyXG4gICAgICAgIHZhciBjb25kaXRpb24gPSBcIiFcIiArIHBpcGUgKyBcIi5wdXJlIHx8IChcIiArIGNvbnRleE9yQXJnQ2hlY2suam9pbihcIiB8fCBcIikgKyBcIilcIjtcclxuICAgICAgICB2YXIgY2hlY2sgPSBcIlxcbiAgICAgIGlmIChcIiArIG9sZFZhbHVlICsgXCIgIT09IFwiICsgbmV3VmFsdWUgKyBcIikge1xcbiAgICAgICAgXCIgKyBuZXdWYWx1ZSArIFwiID0gXCIgKyB0aGlzLmNoYW5nZURldGVjdGlvblV0aWxWYXJOYW1lICsgXCIudW53cmFwVmFsdWUoXCIgKyBuZXdWYWx1ZSArIFwiKVxcbiAgICAgICAgXCIgKyB0aGlzLl9nZW5DaGFuZ2VNYXJrZXIocikgKyBcIlxcbiAgICAgICAgXCIgKyB0aGlzLl9nZW5VcGRhdGVEaXJlY3RpdmVPckVsZW1lbnQocikgKyBcIlxcbiAgICAgICAgXCIgKyB0aGlzLl9nZW5BZGRUb0NoYW5nZXMocikgKyBcIlxcbiAgICAgICAgXCIgKyBvbGRWYWx1ZSArIFwiID0gXCIgKyBuZXdWYWx1ZSArIFwiO1xcbiAgICAgIH1cXG4gICAgXCI7XHJcbiAgICAgICAgdmFyIGdlbkNvZGUgPSByLnNob3VsZEJlQ2hlY2tlZCgpID8gXCJcIiArIHJlYWQgKyBjaGVjayA6IHJlYWQ7XHJcbiAgICAgICAgaWYgKHIuaXNVc2VkQnlPdGhlclJlY29yZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0ICsgXCIgaWYgKFwiICsgY29uZGl0aW9uICsgXCIpIHsgXCIgKyBnZW5Db2RlICsgXCIgfSBlbHNlIHsgXCIgKyBuZXdWYWx1ZSArIFwiID0gXCIgKyBvbGRWYWx1ZSArIFwiOyB9XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5pdCArIFwiIGlmIChcIiArIGNvbmRpdGlvbiArIFwiKSB7IFwiICsgZ2VuQ29kZSArIFwiIH1cIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5SZWZlcmVuY2VDaGVjayA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRGaWVsZE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuX25hbWVzLmdldExvY2FsTmFtZShyLnNlbGZJbmRleCk7XHJcbiAgICAgICAgdmFyIHJlYWQgPSBcIlxcbiAgICAgIFwiICsgdGhpcy5fbG9naWMuZ2VuUHJvcGVydHlCaW5kaW5nRXZhbFZhbHVlKHIpICsgXCJcXG4gICAgXCI7XHJcbiAgICAgICAgdmFyIGNoZWNrID0gXCJcXG4gICAgICBpZiAoXCIgKyBuZXdWYWx1ZSArIFwiICE9PSBcIiArIG9sZFZhbHVlICsgXCIpIHtcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuQ2hhbmdlTWFya2VyKHIpICsgXCJcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuVXBkYXRlRGlyZWN0aXZlT3JFbGVtZW50KHIpICsgXCJcXG4gICAgICAgIFwiICsgdGhpcy5fZ2VuQWRkVG9DaGFuZ2VzKHIpICsgXCJcXG4gICAgICAgIFwiICsgb2xkVmFsdWUgKyBcIiA9IFwiICsgbmV3VmFsdWUgKyBcIjtcXG4gICAgICB9XFxuICAgIFwiO1xyXG4gICAgICAgIHZhciBnZW5Db2RlID0gci5zaG91bGRCZUNoZWNrZWQoKSA/IFwiXCIgKyByZWFkICsgY2hlY2sgOiByZWFkO1xyXG4gICAgICAgIGlmIChyLmlzUHVyZUZ1bmN0aW9uKCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHIuYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aGlzLl9uYW1lcy5nZXRDaGFuZ2VOYW1lKGEpOyB9KS5qb2luKFwiIHx8IFwiKTtcclxuICAgICAgICAgICAgaWYgKHIuaXNVc2VkQnlPdGhlclJlY29yZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpZiAoXCIgKyBjb25kaXRpb24gKyBcIikgeyBcIiArIGdlbkNvZGUgKyBcIiB9IGVsc2UgeyBcIiArIG5ld1ZhbHVlICsgXCIgPSBcIiArIG9sZFZhbHVlICsgXCI7IH1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImlmIChcIiArIGNvbmRpdGlvbiArIFwiKSB7IFwiICsgZ2VuQ29kZSArIFwiIH1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdlbkNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuQ2hhbmdlTWFya2VyID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICByZXR1cm4gci5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uID8gdGhpcy5fbmFtZXMuZ2V0Q2hhbmdlTmFtZShyLnNlbGZJbmRleCkgKyBcIiA9IHRydWVcIiA6IFwiXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5VcGRhdGVEaXJlY3RpdmVPckVsZW1lbnQgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIGlmICghci5sYXN0SW5CaW5kaW5nKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX25hbWVzLmdldEZpZWxkTmFtZShyLnNlbGZJbmRleCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeURlYnVnID0gdGhpcy5nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSA/IFwidGhpcy5sb2dCaW5kaW5nVXBkYXRlKFwiICsgbmV3VmFsdWUgKyBcIik7XCIgOiBcIlwiO1xyXG4gICAgICAgIHZhciBiciA9IHIuYmluZGluZ1JlY29yZDtcclxuICAgICAgICBpZiAoYnIudGFyZ2V0LmlzRGlyZWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVByb3BlcnR5ID0gdGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIuXCIgKyBici50YXJnZXQubmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIHRoaXMuX2dlblRocm93T25DaGFuZ2VDaGVjayhvbGRWYWx1ZSwgbmV3VmFsdWUpICsgXCJcXG4gICAgICAgIFwiICsgZGlyZWN0aXZlUHJvcGVydHkgKyBcIiA9IFwiICsgbmV3VmFsdWUgKyBcIjtcXG4gICAgICAgIFwiICsgbm90aWZ5RGVidWcgKyBcIlxcbiAgICAgICAgXCIgKyBJU19DSEFOR0VEX0xPQ0FMICsgXCIgPSB0cnVlO1xcbiAgICAgIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIHRoaXMuX2dlblRocm93T25DaGFuZ2VDaGVjayhvbGRWYWx1ZSwgbmV3VmFsdWUpICsgXCJcXG4gICAgICAgIHRoaXMubm90aWZ5RGlzcGF0Y2hlcihcIiArIG5ld1ZhbHVlICsgXCIpO1xcbiAgICAgICAgXCIgKyBub3RpZnlEZWJ1ZyArIFwiXFxuICAgICAgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuVGhyb3dPbkNoYW5nZUNoZWNrID0gZnVuY3Rpb24gKG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmdlbkNvbmZpZy5nZW5DaGVja05vQ2hhbmdlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGlmKHRocm93T25DaGFuZ2UpIHtcXG4gICAgICAgICAgdGhpcy50aHJvd09uQ2hhbmdlRXJyb3IoXCIgKyBvbGRWYWx1ZSArIFwiLCBcIiArIG5ld1ZhbHVlICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuQ2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2VuQ29uZmlnLmdlbkNoZWNrTm9DaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lICsgXCIucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24oKSB7IHRoaXMucnVuRGV0ZWN0Q2hhbmdlcyh0cnVlKTsgfVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbkFkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5fbmFtZXMuZ2V0TG9jYWxOYW1lKHIuc2VsZkluZGV4KTtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9uYW1lcy5nZXRGaWVsZE5hbWUoci5zZWxmSW5kZXgpO1xyXG4gICAgICAgIGlmICghci5iaW5kaW5nUmVjb3JkLmNhbGxPbkNoYW5nZXMoKSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIENIQU5HRVNfTE9DQUwgKyBcIiA9IHRoaXMuYWRkQ2hhbmdlKFwiICsgQ0hBTkdFU19MT0NBTCArIFwiLCBcIiArIG9sZFZhbHVlICsgXCIsIFwiICsgbmV3VmFsdWUgKyBcIik7XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9tYXliZUZpcnN0SW5CaW5kaW5nID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgcHJldiA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwucHJvdG9CeUluZGV4KHRoaXMucmVjb3Jkcywgci5zZWxmSW5kZXggLSAxKTtcclxuICAgICAgICB2YXIgZmlyc3RJbkJpbmRuZyA9IGxhbmdfMS5pc0JsYW5rKHByZXYpIHx8IHByZXYuYmluZGluZ1JlY29yZCAhPT0gci5iaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgIHJldHVybiBmaXJzdEluQmluZG5nICYmICFyLmJpbmRpbmdSZWNvcmQuaXNEaXJlY3RpdmVMaWZlY3ljbGUoKSA/XHJcbiAgICAgICAgICAgIHRoaXMuX25hbWVzLmdldFByb3BlcnR5QmluZGluZ0luZGV4KCkgKyBcIiA9IFwiICsgci5wcm9wZXJ0eUJpbmRpbmdJbmRleCArIFwiO1wiIDpcclxuICAgICAgICAgICAgJyc7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9tYXliZUdlbkxhc3RJbkRpcmVjdGl2ZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgaWYgKCFyLmxhc3RJbkRpcmVjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgXCIgKyBDSEFOR0VTX0xPQ0FMICsgXCIgPSBudWxsO1xcbiAgICAgIFwiICsgdGhpcy5fZ2VuTm90aWZ5T25QdXNoRGV0ZWN0b3JzKHIpICsgXCJcXG4gICAgICBcIiArIElTX0NIQU5HRURfTE9DQUwgKyBcIiA9IGZhbHNlO1xcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbk9uQ2hlY2sgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHZhciBiciA9IHIuYmluZGluZ1JlY29yZDtcclxuICAgICAgICByZXR1cm4gXCJpZiAoIXRocm93T25DaGFuZ2UpIFwiICsgdGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIuZG9DaGVjaygpO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuT25Jbml0ID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgYnIgPSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgcmV0dXJuIFwiaWYgKCF0aHJvd09uQ2hhbmdlICYmICFcIiArIHRoaXMuX25hbWVzLmdldEFscmVhZHlDaGVja2VkTmFtZSgpICsgXCIpIFwiICsgdGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShici5kaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpICsgXCIub25Jbml0KCk7XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5PbkNoYW5nZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIGJyID0gci5iaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgIHJldHVybiBcImlmICghdGhyb3dPbkNoYW5nZSAmJiBcIiArIENIQU5HRVNfTE9DQUwgKyBcIikgXCIgKyB0aGlzLl9uYW1lcy5nZXREaXJlY3RpdmVOYW1lKGJyLmRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkgKyBcIi5vbkNoYW5nZXMoXCIgKyBDSEFOR0VTX0xPQ0FMICsgXCIpO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuTm90aWZ5T25QdXNoRGV0ZWN0b3JzID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgYnIgPSByLmJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgaWYgKCFyLmxhc3RJbkRpcmVjdGl2ZSB8fCBici5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgdmFyIHJldFZhbCA9IFwiXFxuICAgICAgaWYoXCIgKyBJU19DSEFOR0VEX0xPQ0FMICsgXCIpIHtcXG4gICAgICAgIFwiICsgdGhpcy5fbmFtZXMuZ2V0RGV0ZWN0b3JOYW1lKGJyLmRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkgKyBcIi5tYXJrQXNDaGVja09uY2UoKTtcXG4gICAgICB9XFxuICAgIFwiO1xyXG4gICAgICAgIHJldHVybiByZXRWYWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yID0gQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIHBpcGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xID0gcmVxdWlyZSgnLi9waXBlX2xpZmVjeWNsZV9yZWZsZWN0b3InKTtcclxudmFyIGJpbmRpbmdfcmVjb3JkXzEgPSByZXF1aXJlKCcuL2JpbmRpbmdfcmVjb3JkJyk7XHJcbnZhciBkaXJlY3RpdmVfcmVjb3JkXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9yZWNvcmQnKTtcclxuLyoqXHJcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZU1ldGFkYXRhfSB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZCBldmVuIHRob3VnaCB0aGVcclxuICogcmVmZXJlbmNlXHJcbiAqIGhhcyBub3QgY2hhbmdlZC5cclxuICpcclxuICogVGhlIHdyYXBwZWQgdmFsdWUgd2lsbCBiZSB1bndyYXBwZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcclxuICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XHJcbiAqICB9IGVsc2Uge1xyXG4gKiAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XHJcbiAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcclxuICogIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgV3JhcHBlZFZhbHVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFdyYXBwZWRWYWx1ZSh3cmFwcGVkKSB7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkID0gd3JhcHBlZDtcclxuICAgIH1cclxuICAgIFdyYXBwZWRWYWx1ZS53cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHcgPSBfd3JhcHBlZFZhbHVlc1tfd3JhcHBlZEluZGV4KysgJSA1XTtcclxuICAgICAgICB3LndyYXBwZWQgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdztcclxuICAgIH07XHJcbiAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xyXG59KSgpO1xyXG5leHBvcnRzLldyYXBwZWRWYWx1ZSA9IFdyYXBwZWRWYWx1ZTtcclxudmFyIF93cmFwcGVkVmFsdWVzID0gW1xyXG4gICAgbmV3IFdyYXBwZWRWYWx1ZShudWxsKSxcclxuICAgIG5ldyBXcmFwcGVkVmFsdWUobnVsbCksXHJcbiAgICBuZXcgV3JhcHBlZFZhbHVlKG51bGwpLFxyXG4gICAgbmV3IFdyYXBwZWRWYWx1ZShudWxsKSxcclxuICAgIG5ldyBXcmFwcGVkVmFsdWUobnVsbClcclxuXTtcclxudmFyIF93cmFwcGVkSW5kZXggPSAwO1xyXG52YXIgU2ltcGxlQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xyXG4gICAgfVxyXG4gICAgU2ltcGxlQ2hhbmdlLnByb3RvdHlwZS5pc0ZpcnN0Q2hhbmdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcmV2aW91c1ZhbHVlID09PSBDaGFuZ2VEZXRlY3Rpb25VdGlsLnVuaW5pdGlhbGl6ZWQ7IH07XHJcbiAgICByZXR1cm4gU2ltcGxlQ2hhbmdlO1xyXG59KSgpO1xyXG5leHBvcnRzLlNpbXBsZUNoYW5nZSA9IFNpbXBsZUNoYW5nZTtcclxudmFyIF9zaW1wbGVDaGFuZ2VzSW5kZXggPSAwO1xyXG52YXIgX3NpbXBsZUNoYW5nZXMgPSBbXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKSxcclxuICAgIG5ldyBTaW1wbGVDaGFuZ2UobnVsbCwgbnVsbCksXHJcbiAgICBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIG51bGwpLFxyXG4gICAgbmV3IFNpbXBsZUNoYW5nZShudWxsLCBudWxsKVxyXG5dO1xyXG5mdW5jdGlvbiBfc2ltcGxlQ2hhbmdlKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xyXG4gICAgdmFyIGluZGV4ID0gX3NpbXBsZUNoYW5nZXNJbmRleCsrICUgMjA7XHJcbiAgICB2YXIgcyA9IF9zaW1wbGVDaGFuZ2VzW2luZGV4XTtcclxuICAgIHMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XHJcbiAgICBzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcclxuICAgIHJldHVybiBzO1xyXG59XHJcbi8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXHJcbnZhciBDaGFuZ2VEZXRlY3Rpb25VdGlsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdGlvblV0aWwoKSB7XHJcbiAgICB9XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm4wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm4xID0gZnVuY3Rpb24gKGExKSB7IHJldHVybiBbYTFdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMiA9IGZ1bmN0aW9uIChhMSwgYTIpIHsgcmV0dXJuIFthMSwgYTJdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMyA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7IHJldHVybiBbYTEsIGEyLCBhM107IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm40ID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7IHJldHVybiBbYTEsIGEyLCBhMywgYTRdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNSA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHsgcmV0dXJuIFthMSwgYTIsIGEzLCBhNCwgYTVdOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNiA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7IHJldHVybiBbYTEsIGEyLCBhMywgYTQsIGE1LCBhNl07IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm43ID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7IHJldHVybiBbYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTddOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuOCA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcclxuICAgICAgICByZXR1cm4gW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOF07XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuOSA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XHJcbiAgICAgICAgcmV0dXJuIFthMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5XTtcclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9uZWdhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICF2YWx1ZTsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2FkZCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCArIHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fc3VidHJhY3QgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgLSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX211bHRpcGx5ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ICogcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9kaXZpZGUgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgLyByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX3JlbWFpbmRlciA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAlIHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ID09IHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbm90X2VxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAhPSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2lkZW50aWNhbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9ub3RfaWRlbnRpY2FsID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ICE9PSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xlc3NfdGhlbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA8IHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZ3JlYXRlcl90aGVuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ID4gcmlnaHQ7IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9sZXNzX29yX2VxdWFsc190aGVuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0IDw9IHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZ3JlYXRlcl9vcl9lcXVhbHNfdGhlbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCA+PSByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xvZ2ljYWxfYW5kID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ICYmIHJpZ2h0OyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbG9naWNhbF9vciA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCB8fCByaWdodDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuY29uZCA9IGZ1bmN0aW9uIChjb25kLCB0cnVlVmFsLCBmYWxzZVZhbCkgeyByZXR1cm4gY29uZCA/IHRydWVWYWwgOiBmYWxzZVZhbDsgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwubWFwRm4gPSBmdW5jdGlvbiAoa2V5cykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTWFwKHZhbHVlcykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHJlcywga2V5c1tpXSwgdmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSkgeyByZXR1cm4gYnVpbGRNYXAoW2ExXSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyKSB7IHJldHVybiBidWlsZE1hcChbYTEsIGEyXSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMykgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTNdKTsgfTtcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0XSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBidWlsZE1hcChbYTEsIGEyLCBhMywgYTQsIGE1XSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTZdKTsgfTtcclxuICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykgeyByZXR1cm4gYnVpbGRNYXAoW2ExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3XSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7IHJldHVybiBidWlsZE1hcChbYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4XSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZE1hcChbYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOV0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkRvZXMgbm90IHN1cHBvcnQgbGl0ZXJhbCBtYXBzIHdpdGggbW9yZSB0aGFuIDkgZWxlbWVudHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwua2V5ZWRBY2Nlc3MgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7IHJldHVybiBvYmpbYXJnc1swXV07IH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLnVud3JhcFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS53cmFwcGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmNoYW5nZURldGVjdGlvbk1vZGUgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcclxuICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koc3RyYXRlZ3kpID8gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tBbHdheXMgOlxyXG4gICAgICAgICAgICBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja09uY2U7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5zaW1wbGVDaGFuZ2UgPSBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zaW1wbGVDaGFuZ2UocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKTtcclxuICAgIH07XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25VdGlsLmlzVmFsdWVCbGFuayA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGFuZ18xLmlzQmxhbmsodmFsdWUpOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5zID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSA/IFwiXCIgKyB2YWx1ZSA6ICcnOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5wcm90b0J5SW5kZXggPSBmdW5jdGlvbiAocHJvdG9zLCBzZWxmSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZkluZGV4IDwgMSA/XHJcbiAgICAgICAgICAgIG51bGwgOlxyXG4gICAgICAgICAgICBwcm90b3Nbc2VsZkluZGV4IC0gMV07IC8vIHNlbGYgaW5kZXggaXMgc2hpZnRlZCBieSBvbmUgYmVjYXVzZSBvZiBjb250ZXh0XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5jYWxsUGlwZU9uRGVzdHJveSA9IGZ1bmN0aW9uIChzZWxlY3RlZFBpcGUpIHtcclxuICAgICAgICBpZiAocGlwZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEuaW1wbGVtZW50c09uRGVzdHJveShzZWxlY3RlZFBpcGUucGlwZSkpIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRQaXBlLnBpcGUub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvblV0aWwuYmluZGluZ1RhcmdldCA9IGZ1bmN0aW9uIChtb2RlLCBlbGVtZW50SW5kZXgsIG5hbWUsIHVuaXQsIGRlYnVnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBiaW5kaW5nX3JlY29yZF8xLkJpbmRpbmdUYXJnZXQobW9kZSwgZWxlbWVudEluZGV4LCBuYW1lLCB1bml0LCBkZWJ1Zyk7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC5kaXJlY3RpdmVJbmRleCA9IGZ1bmN0aW9uIChlbGVtZW50SW5kZXgsIGRpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkaXJlY3RpdmVfcmVjb3JkXzEuRGlyZWN0aXZlSW5kZXgoZWxlbWVudEluZGV4LCBkaXJlY3RpdmVJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uVXRpbC51bmluaXRpYWxpemVkID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IE9iamVjdCgpKTtcclxuICAgIHJldHVybiBDaGFuZ2VEZXRlY3Rpb25VdGlsO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdGlvblV0aWwgPSBDaGFuZ2VEZXRlY3Rpb25VdGlsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBDaGFuZ2VEZXRlY3RvclJlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBDaGFuZ2VEZXRlY3RvclJlZjtcclxufSkoKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvclJlZiA9IENoYW5nZURldGVjdG9yUmVmO1xyXG52YXIgQ2hhbmdlRGV0ZWN0b3JSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDaGFuZ2VEZXRlY3RvclJlZl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZl8oX2NkKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY2QgPSBfY2Q7XHJcbiAgICB9XHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZl8ucHJvdG90eXBlLm1hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY2QubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NkLm1vZGUgPSBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZXRhY2hlZDsgfTtcclxuICAgIENoYW5nZURldGVjdG9yUmVmXy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpOyB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWZfLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jZC5tb2RlID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tBbHdheXM7XHJcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWZfO1xyXG59KShDaGFuZ2VEZXRlY3RvclJlZik7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JSZWZfID0gQ2hhbmdlRGV0ZWN0b3JSZWZfO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0b3JfcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBwcm90b19yZWNvcmRfMSA9IHJlcXVpcmUoJy4vcHJvdG9fcmVjb3JkJyk7XHJcbi8qKlxyXG4gKiBSZW1vdmVzIFwiZHVwbGljYXRlXCIgcmVjb3Jkcy4gSXQgYXNzdW1pbmcgdGhhdCByZWNvcmQgZXZhbHVhdGlvbiBkb2VzIG5vdFxyXG4gKiBoYXZlIHNpZGUtZWZmZWN0cy5cclxuICpcclxuICogUmVjb3JkcyB0aGF0IGFyZSBub3QgbGFzdCBpbiBiaW5kaW5ncyBhcmUgcmVtb3ZlZCBhbmQgYWxsIHRoZSBpbmRpY2VzXHJcbiAqIG9mIHRoZSByZWNvcmRzIHRoYXQgZGVwZW5kIG9uIHRoZW0gYXJlIHVwZGF0ZWQuXHJcbiAqXHJcbiAqIFJlY29yZHMgdGhhdCBhcmUgbGFzdCBpbiBiaW5kaW5ncyBDQU5OT1QgYmUgcmVtb3ZlZCwgYW5kIGluc3RlYWQgYXJlXHJcbiAqIHJlcGxhY2VkIHdpdGggdmVyeSBjaGVhcCBTRUxGIHJlY29yZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2FsZXNjZShyZWNvcmRzKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICB2YXIgaW5kZXhNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHIgPSByZWNvcmRzW2ldO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBfcmVwbGFjZUluZGljZXMociwgcmVzLmxlbmd0aCArIDEsIGluZGV4TWFwKTtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdSZWNvcmQgPSBfZmluZE1hdGNoaW5nKHJlY29yZCwgcmVzKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaGluZ1JlY29yZCkgJiYgcmVjb3JkLmxhc3RJbkJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2goX3NlbGZSZWNvcmQocmVjb3JkLCBtYXRjaGluZ1JlY29yZC5zZWxmSW5kZXgsIHJlcy5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgICAgIGluZGV4TWFwLnNldChyLnNlbGZJbmRleCwgbWF0Y2hpbmdSZWNvcmQuc2VsZkluZGV4KTtcclxuICAgICAgICAgICAgbWF0Y2hpbmdSZWNvcmQucmVmZXJlbmNlZEJ5U2VsZiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hpbmdSZWNvcmQpICYmICFyZWNvcmQubGFzdEluQmluZGluZykge1xyXG4gICAgICAgICAgICBpZiAocmVjb3JkLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nUmVjb3JkLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4TWFwLnNldChyLnNlbGZJbmRleCwgbWF0Y2hpbmdSZWNvcmQuc2VsZkluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgICAgIGluZGV4TWFwLnNldChyLnNlbGZJbmRleCwgcmVjb3JkLnNlbGZJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLmNvYWxlc2NlID0gY29hbGVzY2U7XHJcbmZ1bmN0aW9uIF9zZWxmUmVjb3JkKHIsIGNvbnRleHRJbmRleCwgc2VsZkluZGV4KSB7XHJcbiAgICByZXR1cm4gbmV3IHByb3RvX3JlY29yZF8xLlByb3RvUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2VsZiwgXCJzZWxmXCIsIG51bGwsIFtdLCByLmZpeGVkQXJncywgY29udGV4dEluZGV4LCByLmRpcmVjdGl2ZUluZGV4LCBzZWxmSW5kZXgsIHIuYmluZGluZ1JlY29yZCwgci5sYXN0SW5CaW5kaW5nLCByLmxhc3RJbkRpcmVjdGl2ZSwgZmFsc2UsIGZhbHNlLCByLnByb3BlcnR5QmluZGluZ0luZGV4KTtcclxufVxyXG5mdW5jdGlvbiBfZmluZE1hdGNoaW5nKHIsIHJzKSB7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbmQocnMsIGZ1bmN0aW9uIChycikgeyByZXR1cm4gcnIubW9kZSAhPT0gcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5EaXJlY3RpdmVMaWZlY3ljbGUgJiYgX3NhbWVEaXJJbmRleChyciwgcikgJiZcclxuICAgICAgICByci5tb2RlID09PSByLm1vZGUgJiYgbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHJyLmZ1bmNPclZhbHVlLCByLmZ1bmNPclZhbHVlKSAmJlxyXG4gICAgICAgIHJyLmNvbnRleHRJbmRleCA9PT0gci5jb250ZXh0SW5kZXggJiYgbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHJyLm5hbWUsIHIubmFtZSkgJiZcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZXF1YWxzKHJyLmFyZ3MsIHIuYXJncyk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9zYW1lRGlySW5kZXgoYSwgYikge1xyXG4gICAgdmFyIGRpMSA9IGxhbmdfMS5pc0JsYW5rKGEuZGlyZWN0aXZlSW5kZXgpID8gbnVsbCA6IGEuZGlyZWN0aXZlSW5kZXguZGlyZWN0aXZlSW5kZXg7XHJcbiAgICB2YXIgZWkxID0gbGFuZ18xLmlzQmxhbmsoYS5kaXJlY3RpdmVJbmRleCkgPyBudWxsIDogYS5kaXJlY3RpdmVJbmRleC5lbGVtZW50SW5kZXg7XHJcbiAgICB2YXIgZGkyID0gbGFuZ18xLmlzQmxhbmsoYi5kaXJlY3RpdmVJbmRleCkgPyBudWxsIDogYi5kaXJlY3RpdmVJbmRleC5kaXJlY3RpdmVJbmRleDtcclxuICAgIHZhciBlaTIgPSBsYW5nXzEuaXNCbGFuayhiLmRpcmVjdGl2ZUluZGV4KSA/IG51bGwgOiBiLmRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleDtcclxuICAgIHJldHVybiBkaTEgPT09IGRpMiAmJiBlaTEgPT09IGVpMjtcclxufVxyXG5mdW5jdGlvbiBfcmVwbGFjZUluZGljZXMociwgc2VsZkluZGV4LCBpbmRleE1hcCkge1xyXG4gICAgdmFyIGFyZ3MgPSByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfbWFwKGluZGV4TWFwLCBhKTsgfSk7XHJcbiAgICB2YXIgY29udGV4dEluZGV4ID0gX21hcChpbmRleE1hcCwgci5jb250ZXh0SW5kZXgpO1xyXG4gICAgcmV0dXJuIG5ldyBwcm90b19yZWNvcmRfMS5Qcm90b1JlY29yZChyLm1vZGUsIHIubmFtZSwgci5mdW5jT3JWYWx1ZSwgYXJncywgci5maXhlZEFyZ3MsIGNvbnRleHRJbmRleCwgci5kaXJlY3RpdmVJbmRleCwgc2VsZkluZGV4LCByLmJpbmRpbmdSZWNvcmQsIHIubGFzdEluQmluZGluZywgci5sYXN0SW5EaXJlY3RpdmUsIHIuYXJndW1lbnRUb1B1cmVGdW5jdGlvbiwgci5yZWZlcmVuY2VkQnlTZWxmLCByLnByb3BlcnR5QmluZGluZ0luZGV4KTtcclxufVxyXG5mdW5jdGlvbiBfbWFwKGluZGV4TWFwLCB2YWx1ZSkge1xyXG4gICAgdmFyIHIgPSBpbmRleE1hcC5nZXQodmFsdWUpO1xyXG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQocikgPyByIDogdmFsdWU7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29hbGVzY2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBDb252ZXJ0cyBgZnVuY09yVmFsdWVgIHRvIGEgc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIGluIGdlbmVyYXRlZCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29kaWZ5KG9iaikge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbn1cclxuZXhwb3J0cy5jb2RpZnkgPSBjb2RpZnk7XHJcbmZ1bmN0aW9uIHJhd1N0cmluZyhzdHIpIHtcclxuICAgIHJldHVybiBcIidcIiArIHN0ciArIFwiJ1wiO1xyXG59XHJcbmV4cG9ydHMucmF3U3RyaW5nID0gcmF3U3RyaW5nO1xyXG4vKipcclxuICogQ29tYmluZSB0aGUgc3RyaW5ncyBvZiBnZW5lcmF0ZWQgY29kZSBpbnRvIGEgc2luZ2xlIGludGVycG9sYXRlZCBzdHJpbmcuXHJcbiAqIEVhY2ggZWxlbWVudCBvZiBgdmFsc2AgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmcgbGl0ZXJhbCBvciBhIGNvZGVnZW4nZFxyXG4gKiBjYWxsIHRvIGEgbWV0aG9kIHJldHVybmluZyBhIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbWJpbmVHZW5lcmF0ZWRTdHJpbmdzKHZhbHMpIHtcclxuICAgIHJldHVybiB2YWxzLmpvaW4oJyArICcpO1xyXG59XHJcbmV4cG9ydHMuY29tYmluZUdlbmVyYXRlZFN0cmluZ3MgPSBjb21iaW5lR2VuZXJhdGVkU3RyaW5ncztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWdlbl9mYWNhZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29kZWdlbl9mYWNhZGVfMSA9IHJlcXVpcmUoJy4vY29kZWdlbl9mYWNhZGUnKTtcclxudmFyIHByb3RvX3JlY29yZF8xID0gcmVxdWlyZSgnLi9wcm90b19yZWNvcmQnKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbi8qKlxyXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIGNoYW5nZSBkZXRlY3Rpb24gbG9naWMgZm9yIGNoYW5nZSBkZXRlY3RvciBjbGFzc2VzLlxyXG4gKi9cclxudmFyIENvZGVnZW5Mb2dpY1V0aWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29kZWdlbkxvZ2ljVXRpbChfbmFtZXMsIF91dGlsTmFtZSwgX2NoYW5nZURldGVjdGlvbikge1xyXG4gICAgICAgIHRoaXMuX25hbWVzID0gX25hbWVzO1xyXG4gICAgICAgIHRoaXMuX3V0aWxOYW1lID0gX3V0aWxOYW1lO1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdGlvbiA9IF9jaGFuZ2VEZXRlY3Rpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHN0YXRlbWVudCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCB2YXJpYWJsZSByZXByZXNlbnRpbmcgYHByb3RvUmVjYCB3aXRoIHRoZSBjdXJyZW50XHJcbiAgICAgKiB2YWx1ZSBvZiB0aGUgcmVjb3JkLiBVc2VkIGJ5IHByb3BlcnR5IGJpbmRpbmdzLlxyXG4gICAgICovXHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5Qcm9wZXJ0eUJpbmRpbmdFdmFsVmFsdWUgPSBmdW5jdGlvbiAocHJvdG9SZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5FdmFsVmFsdWUocHJvdG9SZWMsIGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIF90aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUoaWR4KTsgfSwgdGhpcy5fbmFtZXMuZ2V0TG9jYWxzQWNjZXNzb3JOYW1lKCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgc3RhdGVtZW50IHdoaWNoIHVwZGF0ZXMgdGhlIGxvY2FsIHZhcmlhYmxlIHJlcHJlc2VudGluZyBgcHJvdG9SZWNgIHdpdGggdGhlIGN1cnJlbnRcclxuICAgICAqIHZhbHVlIG9mIHRoZSByZWNvcmQuIFVzZWQgYnkgZXZlbnQgYmluZGluZ3MuXHJcbiAgICAgKi9cclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLmdlbkV2ZW50QmluZGluZ0V2YWxWYWx1ZSA9IGZ1bmN0aW9uIChldmVudFJlY29yZCwgcHJvdG9SZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5FdmFsVmFsdWUocHJvdG9SZWMsIGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIF90aGlzLl9uYW1lcy5nZXRFdmVudExvY2FsTmFtZShldmVudFJlY29yZCwgaWR4KTsgfSwgXCJsb2NhbHNcIik7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuX2dlbkV2YWxWYWx1ZSA9IGZ1bmN0aW9uIChwcm90b1JlYywgZ2V0TG9jYWxOYW1lLCBsb2NhbHNBY2Nlc3Nvcikge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gKHByb3RvUmVjLmNvbnRleHRJbmRleCA9PSAtMSkgP1xyXG4gICAgICAgICAgICB0aGlzLl9uYW1lcy5nZXREaXJlY3RpdmVOYW1lKHByb3RvUmVjLmRpcmVjdGl2ZUluZGV4KSA6XHJcbiAgICAgICAgICAgIGdldExvY2FsTmFtZShwcm90b1JlYy5jb250ZXh0SW5kZXgpO1xyXG4gICAgICAgIHZhciBhcmdTdHJpbmcgPSBwcm90b1JlYy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBnZXRMb2NhbE5hbWUoYXJnKTsgfSkuam9pbihcIiwgXCIpO1xyXG4gICAgICAgIHZhciByaHM7XHJcbiAgICAgICAgc3dpdGNoIChwcm90b1JlYy5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TZWxmOlxyXG4gICAgICAgICAgICAgICAgcmhzID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ29uc3Q6XHJcbiAgICAgICAgICAgICAgICByaHMgPSBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShwcm90b1JlYy5mdW5jT3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByb3BlcnR5UmVhZDpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX29ic2VydmUoY29udGV4dCArIFwiLlwiICsgcHJvdG9SZWMubmFtZSwgcHJvdG9SZWMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TYWZlUHJvcGVydHk6XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVhZCA9IHRoaXMuX29ic2VydmUoY29udGV4dCArIFwiLlwiICsgcHJvdG9SZWMubmFtZSwgcHJvdG9SZWMpO1xyXG4gICAgICAgICAgICAgICAgcmhzID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91dGlsTmFtZSArIFwiLmlzVmFsdWVCbGFuayhcIiArIGNvbnRleHQgKyBcIikgPyBudWxsIDogXCIgKyB0aGlzLl9vYnNlcnZlKHJlYWQsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJvcGVydHlXcml0ZTpcclxuICAgICAgICAgICAgICAgIHJocyA9IGNvbnRleHQgKyBcIi5cIiArIHByb3RvUmVjLm5hbWUgKyBcIiA9IFwiICsgZ2V0TG9jYWxOYW1lKHByb3RvUmVjLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Mb2NhbDpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX29ic2VydmUobG9jYWxzQWNjZXNzb3IgKyBcIi5nZXQoXCIgKyBjb2RlZ2VuX2ZhY2FkZV8xLnJhd1N0cmluZyhwcm90b1JlYy5uYW1lKSArIFwiKVwiLCBwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludm9rZU1ldGhvZDpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX29ic2VydmUoY29udGV4dCArIFwiLlwiICsgcHJvdG9SZWMubmFtZSArIFwiKFwiICsgYXJnU3RyaW5nICsgXCIpXCIsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2FmZU1ldGhvZEludm9rZTpcclxuICAgICAgICAgICAgICAgIHZhciBpbnZva2UgPSBjb250ZXh0ICsgXCIuXCIgKyBwcm90b1JlYy5uYW1lICsgXCIoXCIgKyBhcmdTdHJpbmcgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgIHJocyA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXRpbE5hbWUgKyBcIi5pc1ZhbHVlQmxhbmsoXCIgKyBjb250ZXh0ICsgXCIpID8gbnVsbCA6IFwiICsgdGhpcy5fb2JzZXJ2ZShpbnZva2UsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW52b2tlQ2xvc3VyZTpcclxuICAgICAgICAgICAgICAgIHJocyA9IGNvbnRleHQgKyBcIihcIiArIGFyZ1N0cmluZyArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5QcmltaXRpdmVPcDpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX3V0aWxOYW1lICsgXCIuXCIgKyBwcm90b1JlYy5uYW1lICsgXCIoXCIgKyBhcmdTdHJpbmcgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ29sbGVjdGlvbkxpdGVyYWw6XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0aGlzLl91dGlsTmFtZSArIFwiLlwiICsgcHJvdG9SZWMubmFtZSArIFwiKFwiICsgYXJnU3RyaW5nICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludGVycG9sYXRlOlxyXG4gICAgICAgICAgICAgICAgcmhzID0gdGhpcy5fZ2VuSW50ZXJwb2xhdGlvbihwcm90b1JlYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkUmVhZDpcclxuICAgICAgICAgICAgICAgIHJocyA9IHRoaXMuX29ic2VydmUoY29udGV4dCArIFwiW1wiICsgZ2V0TG9jYWxOYW1lKHByb3RvUmVjLmFyZ3NbMF0pICsgXCJdXCIsIHByb3RvUmVjKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuS2V5ZWRXcml0ZTpcclxuICAgICAgICAgICAgICAgIHJocyA9IGNvbnRleHQgKyBcIltcIiArIGdldExvY2FsTmFtZShwcm90b1JlYy5hcmdzWzBdKSArIFwiXSA9IFwiICsgZ2V0TG9jYWxOYW1lKHByb3RvUmVjLmFyZ3NbMV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5DaGFpbjpcclxuICAgICAgICAgICAgICAgIHJocyA9ICdudWxsJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBvcGVyYXRpb24gXCIgKyBwcm90b1JlYy5tb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldExvY2FsTmFtZShwcm90b1JlYy5zZWxmSW5kZXgpICsgXCIgPSBcIiArIHJocyArIFwiO1wiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLl9vYnNlcnZlID0gZnVuY3Rpb24gKGV4cCwgcmVjKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gV29ya3Mgb25seSBpbiBEYXJ0LlxyXG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VEZXRlY3Rpb24gPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwidGhpcy5vYnNlcnZlVmFsdWUoXCIgKyBleHAgKyBcIiwgXCIgKyByZWMuc2VsZkluZGV4ICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5Qcm9wZXJ0eUJpbmRpbmdUYXJnZXRzID0gZnVuY3Rpb24gKHByb3BlcnR5QmluZGluZ1RhcmdldHMsIGdlbkRlYnVnSW5mbykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGJzID0gcHJvcGVydHlCaW5kaW5nVGFyZ2V0cy5tYXAoZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgICAgICAgICB2YXIgZGVidWcgPSBnZW5EZWJ1Z0luZm8gPyBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShiLmRlYnVnKSA6IFwibnVsbFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3V0aWxOYW1lICsgXCIuYmluZGluZ1RhcmdldChcIiArIGNvZGVnZW5fZmFjYWRlXzEuY29kaWZ5KGIubW9kZSkgKyBcIiwgXCIgKyBiLmVsZW1lbnRJbmRleCArIFwiLCBcIiArIGNvZGVnZW5fZmFjYWRlXzEuY29kaWZ5KGIubmFtZSkgKyBcIiwgXCIgKyBjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShiLnVuaXQpICsgXCIsIFwiICsgZGVidWcgKyBcIilcIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBicy5qb2luKFwiLCBcIikgKyBcIl1cIjtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5EaXJlY3RpdmVJbmRpY2VzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVJlY29yZHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBicyA9IGRpcmVjdGl2ZVJlY29yZHMubWFwKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuX3V0aWxOYW1lICsgXCIuZGlyZWN0aXZlSW5kZXgoXCIgKyBiLmRpcmVjdGl2ZUluZGV4LmVsZW1lbnRJbmRleCArIFwiLCBcIiArIGIuZGlyZWN0aXZlSW5kZXguZGlyZWN0aXZlSW5kZXggKyBcIilcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgYnMuam9pbihcIiwgXCIpICsgXCJdXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuX2dlbkludGVycG9sYXRpb24gPSBmdW5jdGlvbiAocHJvdG9SZWMpIHtcclxuICAgICAgICB2YXIgaVZhbHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3RvUmVjLmFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaVZhbHMucHVzaChjb2RlZ2VuX2ZhY2FkZV8xLmNvZGlmeShwcm90b1JlYy5maXhlZEFyZ3NbaV0pKTtcclxuICAgICAgICAgICAgaVZhbHMucHVzaCh0aGlzLl91dGlsTmFtZSArIFwiLnMoXCIgKyB0aGlzLl9uYW1lcy5nZXRMb2NhbE5hbWUocHJvdG9SZWMuYXJnc1tpXSkgKyBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlWYWxzLnB1c2goY29kZWdlbl9mYWNhZGVfMS5jb2RpZnkocHJvdG9SZWMuZml4ZWRBcmdzW3Byb3RvUmVjLmFyZ3MubGVuZ3RoXSkpO1xyXG4gICAgICAgIHJldHVybiBjb2RlZ2VuX2ZhY2FkZV8xLmNvbWJpbmVHZW5lcmF0ZWRTdHJpbmdzKGlWYWxzKTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTG9naWNVdGlsLnByb3RvdHlwZS5nZW5IeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmRzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aXZlUmVjb3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgciA9IGRpcmVjdGl2ZVJlY29yZHNbaV07XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoci5kaXJlY3RpdmVJbmRleCkgKyBcIiA9IFwiICsgdGhpcy5fZ2VuUmVhZERpcmVjdGl2ZShpKSArIFwiO1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLl9nZW5SZWFkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gV29ya3Mgb25seSBpbiBEYXJ0LlxyXG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VEZXRlY3Rpb24gPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwidGhpcy5vYnNlcnZlRGlyZWN0aXZlKHRoaXMuZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZXMsIFwiICsgaW5kZXggKyBcIiksIFwiICsgaW5kZXggKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInRoaXMuZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZXMsIFwiICsgaW5kZXggKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkxvZ2ljVXRpbC5wcm90b3R5cGUuZ2VuSHlkcmF0ZURldGVjdG9ycyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVSZWNvcmRzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aXZlUmVjb3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgciA9IGRpcmVjdGl2ZVJlY29yZHNbaV07XHJcbiAgICAgICAgICAgIGlmICghci5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fbmFtZXMuZ2V0RGV0ZWN0b3JOYW1lKHIuZGlyZWN0aXZlSW5kZXgpICsgXCIgPSB0aGlzLmdldERldGVjdG9yRm9yKGRpcmVjdGl2ZXMsIFwiICsgaSArIFwiKTtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLmdlbkNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3Jkcykge1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICAvLyBOT1RFKGtlZ2x1bmVxKTogT3JkZXIgaXMgaW1wb3J0YW50IVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBkaXJlY3RpdmVSZWNvcmRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSBkaXJlY3RpdmVSZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGlyLmNhbGxBZnRlckNvbnRlbnRJbml0KSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChcImlmKCEgXCIgKyB0aGlzLl9uYW1lcy5nZXRBbHJlYWR5Q2hlY2tlZE5hbWUoKSArIFwiKSBcIiArIHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoZGlyLmRpcmVjdGl2ZUluZGV4KSArIFwiLmFmdGVyQ29udGVudEluaXQoKTtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJDb250ZW50Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShkaXIuZGlyZWN0aXZlSW5kZXgpICsgXCIuYWZ0ZXJDb250ZW50Q2hlY2tlZCgpO1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5Mb2dpY1V0aWwucHJvdG90eXBlLmdlblZpZXdMaWZlY3ljbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUmVjb3Jkcykge1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICAvLyBOT1RFKGtlZ2x1bmVxKTogT3JkZXIgaXMgaW1wb3J0YW50IVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBkaXJlY3RpdmVSZWNvcmRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSBkaXJlY3RpdmVSZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGlyLmNhbGxBZnRlclZpZXdJbml0KSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChcImlmKCEgXCIgKyB0aGlzLl9uYW1lcy5nZXRBbHJlYWR5Q2hlY2tlZE5hbWUoKSArIFwiKSBcIiArIHRoaXMuX25hbWVzLmdldERpcmVjdGl2ZU5hbWUoZGlyLmRpcmVjdGl2ZUluZGV4KSArIFwiLmFmdGVyVmlld0luaXQoKTtcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJWaWV3Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fbmFtZXMuZ2V0RGlyZWN0aXZlTmFtZShkaXIuZGlyZWN0aXZlSW5kZXgpICsgXCIuYWZ0ZXJWaWV3Q2hlY2tlZCgpO1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb2RlZ2VuTG9naWNVdGlsO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvZGVnZW5Mb2dpY1V0aWwgPSBDb2RlZ2VuTG9naWNVdGlsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlZ2VuX2xvZ2ljX3V0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxuLy8gVGhlIG5hbWVzIG9mIHRoZXNlIGZpZWxkcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIGFic3RyYWN0X2NoYW5nZV9kZXRlY3Rvci50cyBvciBjaGFuZ2VcclxuLy8gZGV0ZWN0aW9uIHdpbGwgZmFpbC5cclxudmFyIF9BTFJFQURZX0NIRUNLRURfQUNDRVNTT1IgPSBcImFscmVhZHlDaGVja2VkXCI7XHJcbnZhciBfQ09OVEVYVF9BQ0NFU1NPUiA9IFwiY29udGV4dFwiO1xyXG52YXIgX1BST1BfQklORElOR19JTkRFWCA9IFwicHJvcGVydHlCaW5kaW5nSW5kZXhcIjtcclxudmFyIF9ESVJFQ1RJVkVTX0FDQ0VTU09SID0gXCJkaXJlY3RpdmVJbmRpY2VzXCI7XHJcbnZhciBfRElTUEFUQ0hFUl9BQ0NFU1NPUiA9IFwiZGlzcGF0Y2hlclwiO1xyXG52YXIgX0xPQ0FMU19BQ0NFU1NPUiA9IFwibG9jYWxzXCI7XHJcbnZhciBfTU9ERV9BQ0NFU1NPUiA9IFwibW9kZVwiO1xyXG52YXIgX1BJUEVTX0FDQ0VTU09SID0gXCJwaXBlc1wiO1xyXG52YXIgX1BST1RPU19BQ0NFU1NPUiA9IFwicHJvdG9zXCI7XHJcbi8vIGBjb250ZXh0YCBpcyBhbHdheXMgZmlyc3QuXHJcbmV4cG9ydHMuQ09OVEVYVF9JTkRFWCA9IDA7XHJcbnZhciBfRklFTERfUFJFRklYID0gJ3RoaXMuJztcclxudmFyIF93aGl0ZVNwYWNlUmVnRXhwID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKFwiXFxcXFdcIiwgXCJnXCIpO1xyXG4vKipcclxuICogUmV0dXJucyBgc2Agd2l0aCBhbGwgbm9uLWlkZW50aWZpZXIgY2hhcmFjdGVycyByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc2FuaXRpemVOYW1lKHMpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHMsIF93aGl0ZVNwYWNlUmVnRXhwLCAnJyk7XHJcbn1cclxuZXhwb3J0cy5zYW5pdGl6ZU5hbWUgPSBzYW5pdGl6ZU5hbWU7XHJcbi8qKlxyXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIGZpZWxkIGFuZCBsb2NhbCB2YXJpYWJsZSBuYW1lcyBmb3IgY2hhbmdlIGRldGVjdG9yIGNsYXNzZXMuXHJcbiAqIEFsc28gcHJvdmlkZXMgc29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnMsIGZvciBleGFtcGxlLCBkZWNsYXJpbmcgdmFyaWFibGVzLCBkZXN0cm95aW5nIHBpcGVzLFxyXG4gKiBhbmQgZGVoeWRyYXRpbmcgdGhlIGRldGVjdG9yLlxyXG4gKi9cclxudmFyIENvZGVnZW5OYW1lVXRpbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2RlZ2VuTmFtZVV0aWwoX3JlY29yZHMsIF9ldmVudEJpbmRpbmdzLCBfZGlyZWN0aXZlUmVjb3JkcywgX3V0aWxOYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcmVjb3JkcyA9IF9yZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50QmluZGluZ3MgPSBfZXZlbnRCaW5kaW5ncztcclxuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZWNvcmRzID0gX2RpcmVjdGl2ZVJlY29yZHM7XHJcbiAgICAgICAgdGhpcy5fdXRpbE5hbWUgPSBfdXRpbE5hbWU7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3Nhbml0aXplZEV2ZW50TmFtZXMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Nhbml0aXplZE5hbWVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSh0aGlzLl9yZWNvcmRzLmxlbmd0aCArIDEpO1xyXG4gICAgICAgIHRoaXMuX3Nhbml0aXplZE5hbWVzW2V4cG9ydHMuQ09OVEVYVF9JTkRFWF0gPSBfQ09OVEVYVF9BQ0NFU1NPUjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHRoaXMuX3JlY29yZHMubGVuZ3RoOyBpIDwgaUxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nhbml0aXplZE5hbWVzW2kgKyAxXSA9IHNhbml0aXplTmFtZShcIlwiICsgdGhpcy5fcmVjb3Jkc1tpXS5uYW1lICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGViSW5kZXggPSAwOyBlYkluZGV4IDwgX2V2ZW50QmluZGluZ3MubGVuZ3RoOyArK2ViSW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGViID0gX2V2ZW50QmluZGluZ3NbZWJJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IFtfQ09OVEVYVF9BQ0NFU1NPUl07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gZWIucmVjb3Jkcy5sZW5ndGg7IGkgPCBpTGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goc2FuaXRpemVOYW1lKFwiXCIgKyBlYi5yZWNvcmRzW2ldLm5hbWUgKyBpICsgXCJfXCIgKyBlYkluZGV4KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2FuaXRpemVkRXZlbnROYW1lcy5zZXQoZWIsIG5hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLl9hZGRGaWVsZFByZWZpeCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBcIlwiICsgX0ZJRUxEX1BSRUZJWCArIG5hbWU7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldERpc3BhdGNoZXJOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgoX0RJU1BBVENIRVJfQUNDRVNTT1IpOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRQaXBlc0FjY2Vzc29yTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9QSVBFU19BQ0NFU1NPUik7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldFByb3Rvc05hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfUFJPVE9TX0FDQ0VTU09SKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlc0FjY2Vzc29yTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9ESVJFQ1RJVkVTX0FDQ0VTU09SKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0TG9jYWxzQWNjZXNzb3JOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgoX0xPQ0FMU19BQ0NFU1NPUik7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldEFscmVhZHlDaGVja2VkTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9BTFJFQURZX0NIRUNLRURfQUNDRVNTT1IpOyB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRNb2RlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KF9NT0RFX0FDQ0VTU09SKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0UHJvcGVydHlCaW5kaW5nSW5kZXggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hZGRGaWVsZFByZWZpeChfUFJPUF9CSU5ESU5HX0lOREVYKTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0TG9jYWxOYW1lID0gZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gXCJsX1wiICsgdGhpcy5fc2FuaXRpemVkTmFtZXNbaWR4XTsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RXZlbnRMb2NhbE5hbWUgPSBmdW5jdGlvbiAoZWIsIGlkeCkge1xyXG4gICAgICAgIHJldHVybiBcImxfXCIgKyB0aGlzLl9zYW5pdGl6ZWRFdmVudE5hbWVzLmdldChlYilbaWR4XTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldENoYW5nZU5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBcImNfXCIgKyB0aGlzLl9zYW5pdGl6ZWROYW1lc1tpZHhdOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHN0YXRlbWVudCBpbml0aWFsaXppbmcgbG9jYWwgdmFyaWFibGVzIHVzZWQgd2hlbiBkZXRlY3RpbmcgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZW5Jbml0TG9jYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgYXNzaWdubWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHRoaXMuZ2V0RmllbGRDb3VudCgpOyBpIDwgaUxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09IGV4cG9ydHMuQ09OVEVYVF9JTkRFWCkge1xyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5nZXRMb2NhbE5hbWUoaSkgKyBcIiA9IFwiICsgdGhpcy5nZXRGaWVsZE5hbWUoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IHRoaXMuX3JlY29yZHNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYy5hcmd1bWVudFRvUHVyZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZU5hbWUgPSB0aGlzLmdldENoYW5nZU5hbWUoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5nZXRMb2NhbE5hbWUoaSkgKyBcIixcIiArIGNoYW5nZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2goY2hhbmdlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaChcIlwiICsgdGhpcy5nZXRMb2NhbE5hbWUoaSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhc3NpZ25tZW50c0NvZGUgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShhc3NpZ25tZW50cykgPyAnJyA6IGFzc2lnbm1lbnRzLmpvaW4oJz0nKSArIFwiID0gZmFsc2U7XCI7XHJcbiAgICAgICAgcmV0dXJuIFwidmFyIFwiICsgZGVjbGFyYXRpb25zLmpvaW4oJywnKSArIFwiO1wiICsgYXNzaWdubWVudHNDb2RlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSBzdGF0ZW1lbnQgaW5pdGlhbGl6aW5nIGxvY2FsIHZhcmlhYmxlcyBmb3IgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKi9cclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2VuSW5pdEV2ZW50TG9jYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlcyA9IFsodGhpcy5nZXRMb2NhbE5hbWUoZXhwb3J0cy5DT05URVhUX0lOREVYKSArIFwiID0gXCIgKyB0aGlzLmdldEZpZWxkTmFtZShleHBvcnRzLkNPTlRFWFRfSU5ERVgpKV07XHJcbiAgICAgICAgdGhpcy5fc2FuaXRpemVkRXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lcywgZWIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGV4cG9ydHMuQ09OVEVYVF9JTkRFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFwiXCIgKyBfdGhpcy5nZXRFdmVudExvY2FsTmFtZShlYiwgaSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5sZW5ndGggPiAxID8gXCJ2YXIgXCIgKyByZXMuam9pbignLCcpICsgXCI7XCIgOiAnJztcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldFByZXZlbnREZWZhdWx0QWNjZXNvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwicHJldmVudERlZmF1bHRcIjsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RmllbGRDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Nhbml0aXplZE5hbWVzLmxlbmd0aDsgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RmllbGROYW1lID0gZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgodGhpcy5fc2FuaXRpemVkTmFtZXNbaWR4XSk7IH07XHJcbiAgICBDb2RlZ2VuTmFtZVV0aWwucHJvdG90eXBlLmdldEFsbEZpZWxkTmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZpZWxkTGlzdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBrTGVuID0gdGhpcy5nZXRGaWVsZENvdW50KCk7IGsgPCBrTGVuOyArK2spIHtcclxuICAgICAgICAgICAgaWYgKGsgPT09IDAgfHwgdGhpcy5fcmVjb3Jkc1trIC0gMV0uc2hvdWxkQmVDaGVja2VkKCkpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkTGlzdC5wdXNoKHRoaXMuZ2V0RmllbGROYW1lKGspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHRoaXMuX3JlY29yZHMubGVuZ3RoOyBpIDwgaUxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWMgPSB0aGlzLl9yZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocmVjLmlzUGlwZVJlY29yZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZExpc3QucHVzaCh0aGlzLmdldFBpcGVOYW1lKHJlYy5zZWxmSW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX2RpcmVjdGl2ZVJlY29yZHMubGVuZ3RoOyBqIDwgakxlbjsgKytqKSB7XHJcbiAgICAgICAgICAgIHZhciBkUmVjID0gdGhpcy5fZGlyZWN0aXZlUmVjb3Jkc1tqXTtcclxuICAgICAgICAgICAgZmllbGRMaXN0LnB1c2godGhpcy5nZXREaXJlY3RpdmVOYW1lKGRSZWMuZGlyZWN0aXZlSW5kZXgpKTtcclxuICAgICAgICAgICAgaWYgKCFkUmVjLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZExpc3QucHVzaCh0aGlzLmdldERldGVjdG9yTmFtZShkUmVjLmRpcmVjdGl2ZUluZGV4KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkTGlzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBzdGF0ZW1lbnRzIHdoaWNoIGNsZWFyIGFsbCBmaWVsZHMgc28gdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGlzIGRlaHlkcmF0ZWQuXHJcbiAgICAgKi9cclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2VuRGVoeWRyYXRlRmllbGRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEFsbEZpZWxkTmFtZXMoKTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlQXQoZmllbGRzLCBleHBvcnRzLkNPTlRFWFRfSU5ERVgpO1xyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShmaWVsZHMpKVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgLy8gQXQgbGVhc3Qgb25lIGFzc2lnbm1lbnQuXHJcbiAgICAgICAgZmllbGRzLnB1c2godGhpcy5fdXRpbE5hbWUgKyBcIi51bmluaXRpYWxpemVkO1wiKTtcclxuICAgICAgICByZXR1cm4gZmllbGRzLmpvaW4oJyA9ICcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHN0YXRlbWVudHMgZGVzdHJveWluZyBhbGwgcGlwZSB2YXJpYWJsZXMuXHJcbiAgICAgKi9cclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2VuUGlwZU9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlsdGVyKHRoaXMuX3JlY29yZHMsIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmlzUGlwZVJlY29yZCgpOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiAoX3RoaXMuX3V0aWxOYW1lICsgXCIuY2FsbFBpcGVPbkRlc3Ryb3koXCIgKyBfdGhpcy5nZXRQaXBlTmFtZShyLnNlbGZJbmRleCkgKyBcIik7XCIpOyB9KVxyXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXRQaXBlTmFtZSA9IGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgodGhpcy5fc2FuaXRpemVkTmFtZXNbaWR4XSArIFwiX3BpcGVcIik7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbk5hbWVVdGlsLnByb3RvdHlwZS5nZXREaXJlY3RpdmVOYW1lID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRmllbGRQcmVmaXgoXCJkaXJlY3RpdmVfXCIgKyBkLm5hbWUpO1xyXG4gICAgfTtcclxuICAgIENvZGVnZW5OYW1lVXRpbC5wcm90b3R5cGUuZ2V0RGV0ZWN0b3JOYW1lID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRoaXMuX2FkZEZpZWxkUHJlZml4KFwiZGV0ZWN0b3JfXCIgKyBkLm5hbWUpOyB9O1xyXG4gICAgcmV0dXJuIENvZGVnZW5OYW1lVXRpbDtcclxufSkoKTtcclxuZXhwb3J0cy5Db2RlZ2VuTmFtZVV0aWwgPSBDb2RlZ2VuTmFtZVV0aWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVnZW5fbmFtZV91dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBgQ2hlY2tlZE9uY2VgIG1lYW5zIHRoYXQgYWZ0ZXIgY2FsbGluZyBkZXRlY3RDaGFuZ2VzIHRoZSBtb2RlIG9mIHRoZSBjaGFuZ2UgZGV0ZWN0b3JcclxuICAgICAqIHdpbGwgYmVjb21lIGBDaGVja2VkYC5cclxuICAgICAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJDaGVja09uY2VcIl0gPSAwXSA9IFwiQ2hlY2tPbmNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIGBDaGVja2VkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3Igc2hvdWxkIGJlIHNraXBwZWQgdW50aWwgaXRzIG1vZGUgY2hhbmdlcyB0b1xyXG4gICAgICogYENoZWNrT25jZWAuXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiQ2hlY2tlZFwiXSA9IDFdID0gXCJDaGVja2VkXCI7XHJcbiAgICAvKipcclxuICAgICAqIGBDaGVja0Fsd2F5c2AgbWVhbnMgdGhhdCBhZnRlciBjYWxsaW5nIGRldGVjdENoYW5nZXMgdGhlIG1vZGUgb2YgdGhlIGNoYW5nZSBkZXRlY3RvclxyXG4gICAgICogd2lsbCByZW1haW4gYENoZWNrQWx3YXlzYC5cclxuICAgICAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJDaGVja0Fsd2F5c1wiXSA9IDJdID0gXCJDaGVja0Fsd2F5c1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgRGV0YWNoZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBzdWIgdHJlZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBtYWluIHRyZWUgYW5kXHJcbiAgICAgKiBzaG91bGQgYmUgc2tpcHBlZC5cclxuICAgICAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJEZXRhY2hlZFwiXSA9IDNdID0gXCJEZXRhY2hlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgT25QdXNoYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IncyBtb2RlIHdpbGwgYmUgc2V0IHRvIGBDaGVja09uY2VgIGR1cmluZyBoeWRyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gNF0gPSBcIk9uUHVzaFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgRGVmYXVsdGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yJ3MgbW9kZSB3aWxsIGJlIHNldCB0byBgQ2hlY2tBbHdheXNgIGR1cmluZyBoeWRyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGVmYXVsdFwiXSA9IDVdID0gXCJEZWZhdWx0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUuIFdvcmtzIG9ubHkgaW4gRGFydC5cclxuICAgICAqL1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJPblB1c2hPYnNlcnZlXCJdID0gNl0gPSBcIk9uUHVzaE9ic2VydmVcIjtcclxufSkoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHt9KSk7XHJcbnZhciBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XHJcbmV4cG9ydHMuQ0hBTkdFX0RFQ1RJT05fU1RSQVRFR1lfVkFMVUVTID0gW1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tPbmNlLFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tlZCxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzLFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGV0YWNoZWQsXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoT2JzZXJ2ZVxyXG5dO1xyXG5mdW5jdGlvbiBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneShjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5pc0JsYW5rKGNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB8fFxyXG4gICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID09PSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0O1xyXG59XHJcbmV4cG9ydHMuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpIHtcclxuICAgIH1cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShvYmopOyB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNkUmVmKSB7IHJldHVybiBuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyKCk7IH07XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KTtcclxuICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5O1xyXG59KSgpO1xyXG5leHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkgPSBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5O1xyXG52YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlcigpIHtcclxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xyXG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB1c2VkIHJlY29yZHMgYXQgYW55IHBvaW50IGluIHRpbWUgKGR1cmluZyAmIGFjcm9zcyBgX2NoZWNrKClgIGNhbGxzKVxyXG4gICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBudWxsO1xyXG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSByZW1vdmVkIHJlY29yZHMgYXQgYW55IHBvaW50IGluIHRpbWUgZHVyaW5nIGBfY2hlY2soKWAgY2FsbHMuXHJcbiAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wcmV2aW91c0l0SGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faXRIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pdFRhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21vdmVzSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJjb2xsZWN0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaE1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAobGFuZ18yLmlzQmxhbmsoY29sbGVjdGlvbikpXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBbXTtcclxuICAgICAgICBpZiAoIWNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRXJyb3IgdHJ5aW5nIHRvIGRpZmYgJ1wiICsgY29sbGVjdGlvbiArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hlY2soY29sbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvLyB0b2RvKHZpY2IpOiBvcHRpbSBmb3IgVW5tb2RpZmlhYmxlTGlzdFZpZXcgKGZyb3plbiBhcnJheXMpXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2l0SGVhZDtcclxuICAgICAgICB2YXIgbWF5QmVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICB2YXIgaXRlbTtcclxuICAgICAgICBpZiAobGFuZ18yLmlzQXJyYXkoY29sbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIGxpc3QgPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gbGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsYW5nXzIubG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fbWlzbWF0Y2gocmVjb3JkLCBpdGVtLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXlCZURpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhtaXNrbyk6IGNhbiB3ZSBsaW1pdCB0aGlzIHRvIGR1cGxpY2F0ZXMgb25seT9cclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuaXRlcmF0ZUxpc3RMaWtlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsYW5nXzIubG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF5QmVEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3JkLl9uZXh0O1xyXG4gICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cnVuY2F0ZShyZWNvcmQpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwiaXNEaXJ0eVwiLCB7XHJcbiAgICAgICAgLy8gQ29sbGVjdGlvbkNoYW5nZXMgaXMgY29uc2lkZXJlZCBkaXJ0eSBpZiBpdCBoYXMgYW55IGFkZGl0aW9ucywgbW92ZXMgb3IgcmVtb3ZhbHMuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX21vdmVzSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgY2hhbmdlIG9iamVjdHMgdG8gc2hvdyBubyBjaGFuZ2VzLiBUaGlzIG1lYW5zIHNldCBwcmV2aW91c0tleSB0b1xyXG4gICAgICogY3VycmVudEtleSwgYW5kIGNsZWFyIGFsbCBvZiB0aGUgcXVldWVzIChhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscykuXHJcbiAgICAgKiBTZXQgdGhlIHByZXZpb3VzSW5kZXhlcyBvZiBtb3ZlZCBhbmQgYWRkZWQgaXRlbXMgdG8gdGhlaXIgY3VycmVudEluZGV4ZXNcclxuICAgICAqIFJlc2V0IHRoZSBsaXN0IG9mIGFkZGl0aW9ucywgbW92ZXMgYW5kIHJlbW92YWxzXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQ7XHJcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNJdEhlYWQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHRQcmV2aW91cyA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IG5leHRSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcclxuICAgICAgICAgICAgICAgIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHRNb3ZlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSB0aGlzLl9tb3Zlc1RhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyBkaWZmZXJlbmNlcyBiZXR3ZWVuIGNvbGxlY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIC0gYHJlY29yZGAgaXMgdGhlIHJlY29yZCB3aGljaCB3ZSBzYXcgYXQgdGhpcyBwb3NpdGlvbiBsYXN0IHRpbWUuIElmIG51bGwgdGhlbiBpdCBpcyBhIG5ld1xyXG4gICAgICogICBpdGVtLlxyXG4gICAgICogLSBgaXRlbWAgaXMgdGhlIGN1cnJlbnQgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICogLSBgaW5kZXhgIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9taXNtYXRjaCA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzIHJlY29yZCBhZnRlciB3aGljaCB3ZSB3aWxsIGFwcGVuZCB0aGUgY3VycmVudCBvbmUuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUmVjb3JkO1xyXG4gICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSB0aGlzLl9pdFRhaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2aW91c1JlY29yZCA9IHJlY29yZC5fcHJldjtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgY29sbGVjdGlvbiBzaW5jZSB3ZSBrbm93IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBpdGVtLlxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzZWUgaWYgd2UgaGF2ZSBzZWVuIHRoZSBpdGVtIGJlZm9yZS5cclxuICAgICAgICByZWNvcmQgPSB0aGlzLl9saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2xpbmtlZFJlY29yZHMuZ2V0KGl0ZW0sIGluZGV4KTtcclxuICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgc2VlbiB0aGlzIGJlZm9yZSwgd2UgbmVlZCB0byBtb3ZlIGl0IGZvcndhcmQgaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOZXZlciBzZWVuIGl0LCBjaGVjayBldmljdGVkIGxpc3QuXHJcbiAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbiBpdGVtIHdoaWNoIHdlIGhhdmUgZXZpY3RlZCBlYXJsaWVyOiByZWluc2VydCBpdCBiYWNrIGludG8gdGhlIGxpc3QuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWluc2VydEFmdGVyKHJlY29yZCwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgbmV3IGl0ZW06IGFkZCBpdC5cclxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX2FkZEFmdGVyKG5ldyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkKGl0ZW0pLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNoZWNrIGlzIG9ubHkgbmVlZGVkIGlmIGFuIGFycmF5IGNvbnRhaW5zIGR1cGxpY2F0ZXMuIChTaG9ydCBjaXJjdWl0IG9mIG5vdGhpbmcgZGlydHkpXHJcbiAgICAgKlxyXG4gICAgICogVXNlIGNhc2U6IGBbYSwgYV1gID0+IGBbYiwgYSwgYV1gXHJcbiAgICAgKlxyXG4gICAgICogSWYgd2UgZGlkIG5vdCBoYXZlIHRoaXMgY2hlY2sgdGhlbiB0aGUgaW5zZXJ0aW9uIG9mIGBiYCB3b3VsZDpcclxuICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXHJcbiAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxyXG4gICAgICogICAzKSBsZWF2ZSBgYWAgYXQgaW5kZXggYDFgIGFzIGlzLiA8LS0gdGhpcyBpcyB3cm9uZyFcclxuICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDIuIDwtLSB0aGlzIGlzIHdyb25nIVxyXG4gICAgICpcclxuICAgICAqIFRoZSBjb3JyZWN0IGJlaGF2aW9yIGlzOlxyXG4gICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcclxuICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXHJcbiAgICAgKiAgIDMpIHJlaW5zZXJ0IGBhYCBhdCBpbmRleCAxLlxyXG4gICAgICogICAzKSBtb3ZlIGBhYCBhdCBmcm9tIGAxYCB0byBgMmAuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIERvdWJsZSBjaGVjayB0aGF0IHdlIGhhdmUgbm90IGV2aWN0ZWQgYSBkdXBsaWNhdGUgaXRlbS4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaXRlbSB0eXBlIG1heVxyXG4gICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZDpcclxuICAgICAqIFRoZSBpbnNlcnRpb24gb2YgYiB3aWxsIGV2aWN0IHRoZSBmaXJzdCAnYScuIElmIHdlIGRvbid0IHJlaW5zZXJ0IGl0IG5vdyBpdCB3aWxsIGJlIHJlaW5zZXJ0ZWRcclxuICAgICAqIGF0IHRoZSBlbmQuIFdoaWNoIHdpbGwgc2hvdyB1cCBhcyB0aGUgdHdvICdhJ3Mgc3dpdGNoaW5nIHBvc2l0aW9uLiBUaGlzIGlzIGluY29ycmVjdCwgc2luY2UgYVxyXG4gICAgICogYmV0dGVyIHdheSB0byB0aGluayBvZiBpdCBpcyBhcyBpbnNlcnQgb2YgJ2InIHJhdGhlciB0aGVuIHN3aXRjaCAnYScgd2l0aCAnYicgYW5kIHRoZW4gYWRkICdhJ1xyXG4gICAgICogYXQgdGhlIGVuZC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdmVyaWZ5UmVpbnNlcnRpb24gPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpbmRleCkge1xyXG4gICAgICAgIHZhciByZWluc2VydFJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgIGlmIChyZWluc2VydFJlY29yZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9yZWluc2VydEFmdGVyKHJlaW5zZXJ0UmVjb3JkLCByZWNvcmQuX3ByZXYsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVjb3JkLmN1cnJlbnRJbmRleCAhPSBpbmRleCkge1xyXG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgcmlkIG9mIGFueSBleGNlc3Mge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9cyBmcm9tIHRoZSBwcmV2aW91cyBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdHJ1bmNhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgLy8gQW55dGhpbmcgYWZ0ZXIgdGhhdCBuZWVkcyB0byBiZSByZW1vdmVkO1xyXG4gICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xyXG4gICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbW92ZXNUYWlsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0VGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdFRhaWwuX25leHQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVtb3ZhbHNUYWlsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZWluc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZSZW1vdmVkO1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcclxuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5fbmV4dFJlbW92ZWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dC5fcHJldlJlbW92ZWQgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcclxuICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbW92ZUFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl91bmxpbmsocmVjb3JkKTtcclxuICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcclxuICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xyXG4gICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuX2FkZGl0aW9uc0hlYWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zSGVhZCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2luc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZCAhPSBwcmV2UmVjb3JkKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0ID09PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2ID09PSBudWxsKTtcclxuICAgICAgICB2YXIgbmV4dCA9IHByZXZSZWNvcmQgPT09IG51bGwgPyB0aGlzLl9pdEhlYWQgOiBwcmV2UmVjb3JkLl9uZXh0O1xyXG4gICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xyXG4gICAgICAgIC8vIGFzc2VydChwcmV2UmVjb3JkICE9IHJlY29yZCk7XHJcbiAgICAgICAgcmVjb3JkLl9uZXh0ID0gbmV4dDtcclxuICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xyXG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHQuX3ByZXYgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UmVjb3JkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0SGVhZCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByZXZSZWNvcmQuX25leHQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9saW5rZWRSZWNvcmRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBuZXcgX0R1cGxpY2F0ZU1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xyXG4gICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkVG9SZW1vdmFscyh0aGlzLl91bmxpbmsocmVjb3JkKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdW5saW5rID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2O1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xyXG4gICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fcHJldiA9IG51bGwpID09PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fbmV4dCA9IG51bGwpID09PSBudWxsKTtcclxuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRUb01vdmVzID0gZnVuY3Rpb24gKHJlY29yZCwgdG9JbmRleCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0TW92ZWQgPT09IG51bGwpO1xyXG4gICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNJbmRleCA9PT0gdG9JbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbW92ZXNUYWlsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc0hlYWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc0hlYWQgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNUYWlsLl9uZXh0TW92ZWQgPT09IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xyXG4gICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBudWxsO1xyXG4gICAgICAgIHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzSGVhZCA9PT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzSGVhZCA9IHJlY29yZDtcclxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydChfcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9PT0gbnVsbCk7XHJcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09PSBudWxsKTtcclxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcclxuICAgICAgICAgICAgbGlzdC5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmV2aW91cyA9IFtdO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNJdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMucHVzaChyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWRkaXRpb25zID0gW107XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XHJcbiAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb3ZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkKSB7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbW92YWxzID0gW107XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCkge1xyXG4gICAgICAgICAgICByZW1vdmFscy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcImNvbGxlY3Rpb246IFwiICsgbGlzdC5qb2luKCcsICcpICsgXCJcXG5cIiArIFwicHJldmlvdXM6IFwiICsgcHJldmlvdXMuam9pbignLCAnKSArIFwiXFxuXCIgK1xyXG4gICAgICAgICAgICBcImFkZGl0aW9uczogXCIgKyBhZGRpdGlvbnMuam9pbignLCAnKSArIFwiXFxuXCIgKyBcIm1vdmVzOiBcIiArIG1vdmVzLmpvaW4oJywgJykgKyBcIlxcblwiICtcclxuICAgICAgICAgICAgXCJyZW1vdmFsczogXCIgKyByZW1vdmFscy5qb2luKCcsICcpICsgXCJcXG5cIjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlciA9IERlZmF1bHRJdGVyYWJsZURpZmZlcjtcclxudmFyIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dFByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9wcmV2RHVwID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dER1cCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0TW92ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNJbmRleCA9PT0gdGhpcy5jdXJyZW50SW5kZXggP1xyXG4gICAgICAgICAgICBsYW5nXzIuc3RyaW5naWZ5KHRoaXMuaXRlbSkgOlxyXG4gICAgICAgICAgICBsYW5nXzIuc3RyaW5naWZ5KHRoaXMuaXRlbSkgKyAnWycgKyBsYW5nXzIuc3RyaW5naWZ5KHRoaXMucHJldmlvdXNJbmRleCkgKyAnLT4nICtcclxuICAgICAgICAgICAgICAgIGxhbmdfMi5zdHJpbmdpZnkodGhpcy5jdXJyZW50SW5kZXgpICsgJ10nO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkO1xyXG4vLyBBIGxpbmtlZCBsaXN0IG9mIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmRzIHdpdGggdGhlIHNhbWUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5pdGVtXHJcbnZhciBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCkge1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9oZWFkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZCB0aGUgcmVjb3JkIHRvIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYnkgZGVzaWduIGFsbCByZWNvcmRzIGluIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaG9sZCB0aGUgc2FtZSB2YWx1ZSBpbiByZWNvcmQuaXRlbS5cclxuICAgICAqL1xyXG4gICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dER1cCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXHJcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuaXRlbSA9PSAgX2hlYWQuaXRlbSB8fFxyXG4gICAgICAgICAgICAvLyAgICAgICByZWNvcmQuaXRlbSBpcyBudW0gJiYgcmVjb3JkLml0ZW0uaXNOYU4gJiYgX2hlYWQuaXRlbSBpcyBudW0gJiYgX2hlYWQuaXRlbS5pc05hTik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhaWwuX25leHREdXAgPSByZWNvcmQ7XHJcbiAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IHRoaXMuX3RhaWw7XHJcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dER1cCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIGhhdmluZyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLml0ZW0gPT0gaXRlbSBhbmRcclxuICAgIC8vIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQuY3VycmVudEluZGV4ID49IGFmdGVySW5kZXhcclxuICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGl0ZW0sIGFmdGVySW5kZXgpIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHREdXApIHtcclxuICAgICAgICAgICAgaWYgKChhZnRlckluZGV4ID09PSBudWxsIHx8IGFmdGVySW5kZXggPCByZWNvcmQuY3VycmVudEluZGV4KSAmJlxyXG4gICAgICAgICAgICAgICAgbGFuZ18yLmxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBvbmUge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgIC8vIGFzc2VydCgoKSB7XHJcbiAgICAgICAgLy8gIC8vIHZlcmlmeSB0aGF0IHRoZSByZWNvcmQgYmVpbmcgcmVtb3ZlZCBpcyBpbiB0aGUgbGlzdC5cclxuICAgICAgICAvLyAgZm9yIChDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIGN1cnNvciA9IF9oZWFkOyBjdXJzb3IgIT0gbnVsbDsgY3Vyc29yID0gY3Vyc29yLl9uZXh0RHVwKSB7XHJcbiAgICAgICAgLy8gICAgaWYgKGlkZW50aWNhbChjdXJzb3IsIHJlY29yZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vICB9XHJcbiAgICAgICAgLy8gIHJldHVybiBmYWxzZTtcclxuICAgICAgICAvL30pO1xyXG4gICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2RHVwO1xyXG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0RHVwO1xyXG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5fbmV4dER1cCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dC5fcHJldkR1cCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkID09PSBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfRHVwbGljYXRlSXRlbVJlY29yZExpc3Q7XHJcbn0pKCk7XHJcbnZhciBfRHVwbGljYXRlTWFwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVNYXAoKSB7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKSBoYW5kbGUgY29ybmVyIGNhc2VzXHJcbiAgICAgICAgdmFyIGtleSA9IGxhbmdfMi5nZXRNYXBLZXkocmVjb3JkLml0ZW0pO1xyXG4gICAgICAgIHZhciBkdXBsaWNhdGVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFsYW5nXzIuaXNQcmVzZW50KGR1cGxpY2F0ZXMpKSB7XHJcbiAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBuZXcgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIGR1cGxpY2F0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkdXBsaWNhdGVzLmFkZChyZWNvcmQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGB2YWx1ZWAgdXNpbmcga2V5LiBCZWNhdXNlIHRoZSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIHZhbHVlIG1heWJlIG9uZSB3aGljaCB3ZVxyXG4gICAgICogaGF2ZSBhbHJlYWR5IGl0ZXJhdGVkIG92ZXIsIHdlIHVzZSB0aGUgYWZ0ZXJJbmRleCB0byBwcmV0ZW5kIGl0IGlzIG5vdCB0aGVyZS5cclxuICAgICAqXHJcbiAgICAgKiBVc2UgY2FzZTogYFthLCBiLCBjLCBhLCBhXWAgaWYgd2UgYXJlIGF0IGluZGV4IGAzYCB3aGljaCBpcyB0aGUgc2Vjb25kIGBhYCB0aGVuIGFza2luZyBpZiB3ZVxyXG4gICAgICogaGF2ZSBhbnkgbW9yZSBgYWBzIG5lZWRzIHRvIHJldHVybiB0aGUgbGFzdCBgYWAgbm90IHRoZSBmaXJzdCBvciBzZWNvbmQuXHJcbiAgICAgKi9cclxuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh2YWx1ZSwgYWZ0ZXJJbmRleCkge1xyXG4gICAgICAgIGlmIChhZnRlckluZGV4ID09PSB2b2lkIDApIHsgYWZ0ZXJJbmRleCA9IG51bGw7IH1cclxuICAgICAgICB2YXIga2V5ID0gbGFuZ18yLmdldE1hcEtleSh2YWx1ZSk7XHJcbiAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcclxuICAgICAgICByZXR1cm4gbGFuZ18yLmlzQmxhbmsocmVjb3JkTGlzdCkgPyBudWxsIDogcmVjb3JkTGlzdC5nZXQodmFsdWUsIGFmdGVySW5kZXgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfSBmcm9tIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBhbHNvIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIGl0IGdldHMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICB2YXIga2V5ID0gbGFuZ18yLmdldE1hcEtleShyZWNvcmQuaXRlbSk7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxyXG4gICAgICAgIC8vIGFzc2VydCh0aGlzLm1hcC5jb250YWluc0tleShrZXkpKTtcclxuICAgICAgICB2YXIgcmVjb3JkTGlzdCA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxyXG4gICAgICAgIGlmIChyZWNvcmRMaXN0LnJlbW92ZShyZWNvcmQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWFwLnNpemUgPT09IDA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMubWFwLmNsZWFyKCk7IH07XHJcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdfRHVwbGljYXRlTWFwKCcgKyBsYW5nXzIuc3RyaW5naWZ5KHRoaXMubWFwKSArICcpJzsgfTtcclxuICAgIHJldHVybiBfRHVwbGljYXRlTWFwO1xyXG59KSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X2l0ZXJhYmxlX2RpZmZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSgpIHtcclxuICAgIH1cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgTWFwIHx8IGxhbmdfMS5pc0pzT2JqZWN0KG9iaik7IH07XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYpIHsgcmV0dXJuIG5ldyBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKTsgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkpO1xyXG4gICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XHJcbnZhciBEZWZhdWx0S2V5VmFsdWVEaWZmZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xyXG4gICAgICAgIHRoaXMuX3JlY29yZHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbWFwSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLCBcImlzRGlydHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9jaGFuZ2VzSGVhZCAhPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkICE9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciByZWNvcmQ7XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xyXG4gICAgICAgICAgICBmbihyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaENoYW5nZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQWRkZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcclxuICAgICAgICAgICAgZm4ocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXApKVxyXG4gICAgICAgICAgICBtYXAgPSBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMoW10pO1xyXG4gICAgICAgIGlmICghKG1hcCBpbnN0YW5jZW9mIE1hcCB8fCBsYW5nXzEuaXNKc09iamVjdChtYXApKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBtYXAgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrKG1hcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XHJcbiAgICAgICAgdmFyIG9sZFNlcVJlY29yZCA9IHRoaXMuX21hcEhlYWQ7XHJcbiAgICAgICAgdmFyIGxhc3RPbGRTZXFSZWNvcmQgPSBudWxsO1xyXG4gICAgICAgIHZhciBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcclxuICAgICAgICB2YXIgc2VxQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZvckVhY2gobWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3U2VxUmVjb3JkO1xyXG4gICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICE9PSBudWxsICYmIGtleSA9PT0gb2xkU2VxUmVjb3JkLmtleSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodmFsdWUsIG9sZFNlcVJlY29yZC5jdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkU2VxUmVjb3JkLnByZXZpb3VzVmFsdWUgPSBvbGRTZXFSZWNvcmQuY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFNlcVJlY29yZC5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9DaGFuZ2VzKG9sZFNlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXFDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQuX25leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVGcm9tU2VxKGxhc3RPbGRTZXFSZWNvcmQsIG9sZFNlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvUmVtb3ZhbHMob2xkU2VxUmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gcmVjb3Jkcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG5ldyBLVkNoYW5nZVJlY29yZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KGtleSwgbmV3U2VxUmVjb3JkKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQuY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvQWRkaXRpb25zKG5ld1NlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNlcUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNJblJlbW92YWxzKG5ld1NlcVJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVJlbW92YWxzKG5ld1NlcVJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdE5ld1NlcVJlY29yZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21hcEhlYWQgPSBuZXdTZXFSZWNvcmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TmV3U2VxUmVjb3JkLl9uZXh0ID0gbmV3U2VxUmVjb3JkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RPbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XHJcbiAgICAgICAgICAgIGxhc3ROZXdTZXFSZWNvcmQgPSBuZXdTZXFSZWNvcmQ7XHJcbiAgICAgICAgICAgIG9sZFNlcVJlY29yZCA9IG9sZFNlcVJlY29yZCA9PT0gbnVsbCA/IG51bGwgOiBvbGRTZXFSZWNvcmQuX25leHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdHJ1bmNhdGUobGFzdE9sZFNlcVJlY29yZCwgb2xkU2VxUmVjb3JkKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY29yZDtcclxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBzdGF0ZSBvZiB0aGUgbWFwcGluZ1xyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHRQcmV2aW91cyA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c1ZhbHVlID0gcmVjb3JkLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRvZG8odmljYikgb25jZSBhc3NlcnQgaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIC8vIGFzc2VydCgoKSB7XHJcbiAgICAgICAgICAgIC8vICB2YXIgciA9IF9jaGFuZ2VzSGVhZDtcclxuICAgICAgICAgICAgLy8gIHdoaWxlIChyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gICAgdmFyIG5leHRSZWNvcmQgPSByLl9uZXh0Q2hhbmdlZDtcclxuICAgICAgICAgICAgLy8gICAgci5fbmV4dENoYW5nZWQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgICByID0gbmV4dFJlY29yZDtcclxuICAgICAgICAgICAgLy8gIH1cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gIHIgPSBfYWRkaXRpb25zSGVhZDtcclxuICAgICAgICAgICAgLy8gIHdoaWxlIChyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gICAgdmFyIG5leHRSZWNvcmQgPSByLl9uZXh0QWRkZWQ7XHJcbiAgICAgICAgICAgIC8vICAgIHIuX25leHRBZGRlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vICAgIHIgPSBuZXh0UmVjb3JkO1xyXG4gICAgICAgICAgICAvLyAgfVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgciA9IF9yZW1vdmFsc0hlYWQ7XHJcbiAgICAgICAgICAgIC8vICB3aGlsZSAociAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHZhciBuZXh0UmVjb3JkID0gci5fbmV4dFJlbW92ZWQ7XHJcbiAgICAgICAgICAgIC8vICAgIHIuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gICAgciA9IG5leHRSZWNvcmQ7XHJcbiAgICAgICAgICAgIC8vICB9XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgLy99KTtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fdHJ1bmNhdGUgPSBmdW5jdGlvbiAobGFzdFJlY29yZCwgcmVjb3JkKSB7XHJcbiAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdFJlY29yZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSGVhZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0UmVjb3JkLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dDtcclxuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKSBhc3NlcnRcclxuICAgICAgICAgICAgLy8gYXNzZXJ0KCgoKSB7XHJcbiAgICAgICAgICAgIC8vICByZWNvcmQuX25leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIC8vfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHJlY29yZCk7XHJcbiAgICAgICAgICAgIGxhc3RSZWNvcmQgPSByZWNvcmQ7XHJcbiAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHJlYyA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjICE9PSBudWxsOyByZWMgPSByZWMuX25leHRSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHJlYy5wcmV2aW91c1ZhbHVlID0gcmVjLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgcmVjLmN1cnJlbnRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZHMuZGVsZXRlKHJlYy5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9pc0luUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZCA9PT0gdGhpcy5fcmVtb3ZhbHNIZWFkIHx8IHJlY29yZC5fbmV4dFJlbW92ZWQgIT09IG51bGwgfHxcclxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCAhPT0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dENoYW5nZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldlJlbW92ZWQgPT0gbnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gcmVjb3JkO1xyXG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gdGhpcy5fcmVtb3ZhbHNUYWlsO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZUZyb21TZXEgPSBmdW5jdGlvbiAocHJldiwgcmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHQ7XHJcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwSGVhZCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKSBhc3NlcnRcclxuICAgICAgICAvLyBhc3NlcnQoKCgpIHtcclxuICAgICAgICAvLyAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAvLyAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy99KSgpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgLy8gdG9kbyh2aWNiKSBhc3NlcnRcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0ID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0Q2hhbmdlZCA9PSBudWxsKTtcclxuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XHJcbiAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHRSZW1vdmVkO1xyXG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSByZWNvcmQuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb0FkZGl0aW9ucyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAvLyB0b2RvKHZpY2IpOiBhc3NlcnRcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0ID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0Q2hhbmdlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0UmVtb3ZlZCA9PSBudWxsKTtcclxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2UmVtb3ZlZCA9PSBudWxsKTtcclxuICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcclxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XHJcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRDaGFuZ2VkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09IG51bGwpO1xyXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX3ByZXZSZW1vdmVkID09IG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzSGVhZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IHRoaXMuX2NoYW5nZXNUYWlsID0gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwuX25leHRDaGFuZ2VkID0gcmVjb3JkO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgICB2YXIgcHJldmlvdXMgPSBbXTtcclxuICAgICAgICB2YXIgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbXTtcclxuICAgICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcclxuICAgICAgICAgICAgaXRlbXMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xyXG4gICAgICAgICAgICBwcmV2aW91cy5wdXNoKGxhbmdfMS5zdHJpbmdpZnkocmVjb3JkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2gobGFuZ18xLnN0cmluZ2lmeShyZWNvcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XHJcbiAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKGxhbmdfMS5zdHJpbmdpZnkocmVjb3JkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcclxuICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJtYXA6IFwiICsgaXRlbXMuam9pbignLCAnKSArIFwiXFxuXCIgKyBcInByZXZpb3VzOiBcIiArIHByZXZpb3VzLmpvaW4oJywgJykgKyBcIlxcblwiICtcclxuICAgICAgICAgICAgXCJhZGRpdGlvbnM6IFwiICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyBcIlxcblwiICsgXCJjaGFuZ2VzOiBcIiArIGNoYW5nZXMuam9pbignLCAnKSArIFwiXFxuXCIgK1xyXG4gICAgICAgICAgICBcInJlbW92YWxzOiBcIiArIHJlbW92YWxzLmpvaW4oJywgJykgKyBcIlxcblwiO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xyXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcclxuICAgICAgICAgICAgb2JqLmZvckVhY2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChvYmosIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EZWZhdWx0S2V5VmFsdWVEaWZmZXIgPSBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XHJcbnZhciBLVkNoYW5nZVJlY29yZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBLVkNoYW5nZVJlY29yZChrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dFByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHRBZGRlZCA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9uZXh0Q2hhbmdlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBLVkNoYW5nZVJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5sb29zZUlkZW50aWNhbCh0aGlzLnByZXZpb3VzVmFsdWUsIHRoaXMuY3VycmVudFZhbHVlKSA/XHJcbiAgICAgICAgICAgIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5rZXkpIDpcclxuICAgICAgICAgICAgKGxhbmdfMS5zdHJpbmdpZnkodGhpcy5rZXkpICsgJ1snICsgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzVmFsdWUpICsgJy0+JyArXHJcbiAgICAgICAgICAgICAgICBsYW5nXzEuc3RyaW5naWZ5KHRoaXMuY3VycmVudFZhbHVlKSArICddJyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEtWQ2hhbmdlUmVjb3JkO1xyXG59KSgpO1xyXG5leHBvcnRzLktWQ2hhbmdlUmVjb3JkID0gS1ZDaGFuZ2VSZWNvcmQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRfa2V5dmFsdWVfZGlmZmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbi8qKlxyXG4gKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IGl0ZXJhYmxlIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nRm9yLCBOZ0NsYXNzLCBhbmQgb3RoZXJzLlxyXG4gKi9cclxudmFyIEl0ZXJhYmxlRGlmZmVycyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZURpZmZlcnMuY3JlYXRlID0gZnVuY3Rpb24gKGZhY3RvcmllcywgcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50KSkge1xyXG4gICAgICAgICAgICB2YXIgY29waWVkID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xyXG4gICAgICAgICAgICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMuY29uY2F0KGNvcGllZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBJdGVyYWJsZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXHJcbiAgICAgKiBpbmhlcml0ZWQge0BsaW5rIEl0ZXJhYmxlRGlmZmVyc30gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZmFjdG9yaWVzIGFuZCByZXR1cm4gYSBuZXdcclxuICAgICAqIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGxpc3Qgb2YgZmFjdG9yaWVzLFxyXG4gICAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgSXRlcmFibGVEaWZmZXJ9IGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiAjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBDb21wb25lbnQoe1xyXG4gICAgICogICB2aWV3UHJvdmlkZXJzOiBbXHJcbiAgICAgKiAgICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZChbbmV3IEltbXV0YWJsZUxpc3REaWZmZXIoKV0pXHJcbiAgICAgKiAgIF1cclxuICAgICAqIH0pXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGRpXzEuUHJvdmlkZXIoSXRlcmFibGVEaWZmZXJzLCB7XHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHdvdWxkIG9jY3VyIHdoZW4gY2FsbGluZyBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kIGluc2lkZSBvZiBkZXBlbmRlbmNpZXMgcGFzc2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignQ2Fubm90IGV4dGVuZCBJdGVyYWJsZURpZmZlcnMgd2l0aG91dCBhIHBhcmVudCBpbmplY3RvcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBEZXBlbmRlbmN5IHRlY2huaWNhbGx5IGlzbid0IG9wdGlvbmFsLCBidXQgd2UgY2FuIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB0aGlzIHdheS5cclxuICAgICAgICAgICAgZGVwczogW1tJdGVyYWJsZURpZmZlcnMsIG5ldyBkaV8xLlNraXBTZWxmTWV0YWRhdGEoKSwgbmV3IGRpXzEuT3B0aW9uYWxNZXRhZGF0YSgpXV1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJdGVyYWJsZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maW5kKHRoaXMuZmFjdG9yaWVzLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhpdGVyYWJsZSk7IH0pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGZhY3RvcnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsgaXRlcmFibGUgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEl0ZXJhYmxlRGlmZmVycyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtBcnJheV0pXHJcbiAgICBdLCBJdGVyYWJsZURpZmZlcnMpO1xyXG4gICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycztcclxufSkoKTtcclxuZXhwb3J0cy5JdGVyYWJsZURpZmZlcnMgPSBJdGVyYWJsZURpZmZlcnM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhYmxlX2RpZmZlcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuLyoqXHJcbiAqIEEgcmVwb3NpdG9yeSBvZiBkaWZmZXJlbnQgTWFwIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nQ2xhc3MsIE5nU3R5bGUsIGFuZCBvdGhlcnMuXHJcbiAqL1xyXG52YXIgS2V5VmFsdWVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcclxuICAgIH1cclxuICAgIEtleVZhbHVlRGlmZmVycy5jcmVhdGUgPSBmdW5jdGlvbiAoZmFjdG9yaWVzLCBwYXJlbnQpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHZhciBjb3BpZWQgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY2xvbmUocGFyZW50LmZhY3Rvcmllcyk7XHJcbiAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2Yge0BsaW5rIEtleVZhbHVlRGlmZmVyRmFjdG9yeX0gYW5kIHJldHVybnMgYSBwcm92aWRlciB1c2VkIHRvIGV4dGVuZCB0aGVcclxuICAgICAqIGluaGVyaXRlZCB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xyXG4gICAgICoge0BsaW5rIEtleVZhbHVlRGlmZmVyc30gaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXHJcbiAgICAgICAgICAgKiB3aGljaCB3aWxsIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgaW5qZWN0b3IgZm9yIHRoaXMgY29tcG9uZW50IGFuZCBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgKiBUaGlzIHN0ZXAgaXMgYWxsIHRoYXQncyByZXF1aXJlZCB0byBtYWtlIGEgbmV3IHtAbGluayBLZXlWYWx1ZURpZmZlcn0gYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqICMgRXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogQENvbXBvbmVudCh7XHJcbiAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcclxuICAgICAqICAgICBLZXlWYWx1ZURpZmZlcnMuZXh0ZW5kKFtuZXcgSW1tdXRhYmxlTWFwRGlmZmVyKCldKVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkaV8xLlByb3ZpZGVyKEtleVZhbHVlRGlmZmVycywge1xyXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm9vdHN0cmFwKCksIHdoaWNoIHdvdWxkIG92ZXJyaWRlIGRlZmF1bHQgcGlwZXMgaW5zdGVhZCBvZiBleHRlbmRpbmcgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0Nhbm5vdCBleHRlbmQgS2V5VmFsdWVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnMuY3JlYXRlKGZhY3RvcmllcywgcGFyZW50KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXHJcbiAgICAgICAgICAgIGRlcHM6IFtbS2V5VmFsdWVEaWZmZXJzLCBuZXcgZGlfMS5Ta2lwU2VsZk1ldGFkYXRhKCksIG5ldyBkaV8xLk9wdGlvbmFsTWV0YWRhdGEoKV1dXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgS2V5VmFsdWVEaWZmZXJzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGt2KSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmluZCh0aGlzLmZhY3RvcmllcywgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoa3YpOyB9KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChmYWN0b3J5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGt2ICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLZXlWYWx1ZURpZmZlcnMgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXldKVxyXG4gICAgXSwgS2V5VmFsdWVEaWZmZXJzKTtcclxuICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuS2V5VmFsdWVEaWZmZXJzID0gS2V5VmFsdWVEaWZmZXJzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl2YWx1ZV9kaWZmZXJzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIERpcmVjdGl2ZUluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZUluZGV4KGVsZW1lbnRJbmRleCwgZGlyZWN0aXZlSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRJbmRleCA9IGVsZW1lbnRJbmRleDtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZUluZGV4ID0gZGlyZWN0aXZlSW5kZXg7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlSW5kZXgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbGVtZW50SW5kZXggKyBcIl9cIiArIHRoaXMuZGlyZWN0aXZlSW5kZXg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERpcmVjdGl2ZUluZGV4O1xyXG59KSgpO1xyXG5leHBvcnRzLkRpcmVjdGl2ZUluZGV4ID0gRGlyZWN0aXZlSW5kZXg7XHJcbnZhciBEaXJlY3RpdmVSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVjb3JkKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGRpcmVjdGl2ZUluZGV4ID0gX2IuZGlyZWN0aXZlSW5kZXgsIGNhbGxBZnRlckNvbnRlbnRJbml0ID0gX2IuY2FsbEFmdGVyQ29udGVudEluaXQsIGNhbGxBZnRlckNvbnRlbnRDaGVja2VkID0gX2IuY2FsbEFmdGVyQ29udGVudENoZWNrZWQsIGNhbGxBZnRlclZpZXdJbml0ID0gX2IuY2FsbEFmdGVyVmlld0luaXQsIGNhbGxBZnRlclZpZXdDaGVja2VkID0gX2IuY2FsbEFmdGVyVmlld0NoZWNrZWQsIGNhbGxPbkNoYW5nZXMgPSBfYi5jYWxsT25DaGFuZ2VzLCBjYWxsRG9DaGVjayA9IF9iLmNhbGxEb0NoZWNrLCBjYWxsT25Jbml0ID0gX2IuY2FsbE9uSW5pdCwgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlSW5kZXggPSBkaXJlY3RpdmVJbmRleDtcclxuICAgICAgICB0aGlzLmNhbGxBZnRlckNvbnRlbnRJbml0ID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbEFmdGVyQ29udGVudEluaXQpO1xyXG4gICAgICAgIHRoaXMuY2FsbEFmdGVyQ29udGVudENoZWNrZWQgPSBsYW5nXzEubm9ybWFsaXplQm9vbChjYWxsQWZ0ZXJDb250ZW50Q2hlY2tlZCk7XHJcbiAgICAgICAgdGhpcy5jYWxsT25DaGFuZ2VzID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbE9uQ2hhbmdlcyk7XHJcbiAgICAgICAgdGhpcy5jYWxsQWZ0ZXJWaWV3SW5pdCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNhbGxBZnRlclZpZXdJbml0KTtcclxuICAgICAgICB0aGlzLmNhbGxBZnRlclZpZXdDaGVja2VkID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbEFmdGVyVmlld0NoZWNrZWQpO1xyXG4gICAgICAgIHRoaXMuY2FsbERvQ2hlY2sgPSBsYW5nXzEubm9ybWFsaXplQm9vbChjYWxsRG9DaGVjayk7XHJcbiAgICAgICAgdGhpcy5jYWxsT25Jbml0ID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woY2FsbE9uSW5pdCk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XHJcbiAgICB9XHJcbiAgICBEaXJlY3RpdmVSZWNvcmQucHJvdG90eXBlLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kodGhpcy5jaGFuZ2VEZXRlY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEaXJlY3RpdmVSZWNvcmQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGlyZWN0aXZlUmVjb3JkID0gRGlyZWN0aXZlUmVjb3JkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVfcmVjb3JkLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2NoYW5nZV9kZXRlY3RvcicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rpb25fdXRpbCcpO1xyXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG52YXIgcHJvdG9fcmVjb3JkXzEgPSByZXF1aXJlKCcuL3Byb3RvX3JlY29yZCcpO1xyXG52YXIgRHluYW1pY0NoYW5nZURldGVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEeW5hbWljQ2hhbmdlRGV0ZWN0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IoaWQsIGRpc3BhdGNoZXIsIG51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMsIHByb3BlcnR5QmluZGluZ1RhcmdldHMsIGRpcmVjdGl2ZUluZGljZXMsIHN0cmF0ZWd5LCBfcmVjb3JkcywgX2V2ZW50QmluZGluZ3MsIF9kaXJlY3RpdmVSZWNvcmRzLCBfZ2VuQ29uZmlnKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaWQsIGRpc3BhdGNoZXIsIG51bWJlck9mUHJvcGVydHlQcm90b1JlY29yZHMsIHByb3BlcnR5QmluZGluZ1RhcmdldHMsIGRpcmVjdGl2ZUluZGljZXMsIHN0cmF0ZWd5KTtcclxuICAgICAgICB0aGlzLl9yZWNvcmRzID0gX3JlY29yZHM7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRCaW5kaW5ncyA9IF9ldmVudEJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlY29yZHMgPSBfZGlyZWN0aXZlUmVjb3JkcztcclxuICAgICAgICB0aGlzLl9nZW5Db25maWcgPSBfZ2VuQ29uZmlnO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGxlbiA9IF9yZWNvcmRzLmxlbmd0aCArIDE7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGxlbik7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBpcGVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShsZW4pO1xyXG4gICAgICAgIHRoaXMucHJldkNvbnRleHRzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShsZW4pO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICB0aGlzLmRlaHlkcmF0ZURpcmVjdGl2ZXMoZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oYW5kbGVFdmVudEludGVybmFsID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxJbmRleCwgbG9jYWxzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9tYXRjaGluZ0V2ZW50QmluZGluZ3MoZXZlbnROYW1lLCBlbEluZGV4KVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVjKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5fcHJvY2Vzc0V2ZW50QmluZGluZyhyZWMsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJldmVudERlZmF1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcHJvY2Vzc0V2ZW50QmluZGluZyA9IGZ1bmN0aW9uIChlYiwgbG9jYWxzKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUoZWIucmVjb3Jkcy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbHVlc1swXSA9IHRoaXMudmFsdWVzWzBdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWIucmVjb3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBlYi5yZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fY2FsY3VsYXRlQ3VyclZhbHVlKHByb3RvLCB2YWx1ZXMsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIGlmIChwcm90by5sYXN0SW5CaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrUGF0aEFzQ2hlY2tPbmNlKHByb3RvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVNlbGYocHJvdG8sIHJlcywgdmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgYmUgcmVhY2hlZFwiKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9tYXJrUGF0aEFzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgaWYgKCFwcm90by5iaW5kaW5nUmVjb3JkLmlzRGVmYXVsdENoYW5nZURldGVjdGlvbigpKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSBwcm90by5iaW5kaW5nUmVjb3JkLmRpcmVjdGl2ZVJlY29yZDtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0RGV0ZWN0b3JGb3IoZGlyLmRpcmVjdGl2ZUluZGV4KS5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX21hdGNoaW5nRXZlbnRCaW5kaW5ncyA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbHRlcih0aGlzLl9ldmVudEJpbmRpbmdzLCBmdW5jdGlvbiAoZWIpIHsgcmV0dXJuIGViLmV2ZW50TmFtZSA9PSBldmVudE5hbWUgJiYgZWIuZWxJbmRleCA9PT0gZWxJbmRleDsgfSk7XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5oeWRyYXRlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZXNbMF0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgICAgICBpZiAodGhpcy5zdHJhdGVneSA9PT0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoT2JzZXJ2ZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0aXZlSW5kaWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5kaXJlY3RpdmVJbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vYnNlcnZlRGlyZWN0aXZlLmNhbGwodGhpcywgZGlyZWN0aXZlcy5nZXREaXJlY3RpdmVGb3IoaW5kZXgpLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmRlaHlkcmF0ZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGVzdHJveVBpcGVzKSB7XHJcbiAgICAgICAgaWYgKGRlc3Ryb3lQaXBlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UGlwZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZXNbMF0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbGwodGhpcy52YWx1ZXMsIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwudW5pbml0aWFsaXplZCwgMSk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbGwodGhpcy5jaGFuZ2VzLCBmYWxzZSk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbGwodGhpcy5sb2NhbFBpcGVzLCBudWxsKTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlsbCh0aGlzLnByZXZDb250ZXh0cywgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC51bmluaXRpYWxpemVkKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9kZXN0cm95UGlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsUGlwZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5sb2NhbFBpcGVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5jYWxsUGlwZU9uRGVzdHJveSh0aGlzLmxvY2FsUGlwZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMucnVuRGV0ZWN0Q2hhbmdlcyh0cnVlKTsgfTtcclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0luUmVjb3Jkc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgcHJvdG9zID0gdGhpcy5fcmVjb3JkcztcclxuICAgICAgICB2YXIgY2hhbmdlcyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdG9zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm90byA9IHByb3Rvc1tpXTtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmdSZWNvcmQgPSBwcm90by5iaW5kaW5nUmVjb3JkO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlUmVjb3JkID0gYmluZGluZ1JlY29yZC5kaXJlY3RpdmVSZWNvcmQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdEluQmluZGluZyhwcm90bykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlCaW5kaW5nSW5kZXggPSBwcm90by5wcm9wZXJ0eUJpbmRpbmdJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvdG8uaXNMaWZlQ3ljbGVSZWNvcmQoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3RvLm5hbWUgPT09IFwiRG9DaGVja1wiICYmICF0aHJvd09uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkuZG9DaGVjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG8ubmFtZSA9PT0gXCJPbkluaXRcIiAmJiAhdGhyb3dPbkNoYW5nZSAmJiAhdGhpcy5hbHJlYWR5Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXJlY3RpdmVSZWNvcmQuZGlyZWN0aXZlSW5kZXgpLm9uSW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG8ubmFtZSA9PT0gXCJPbkNoYW5nZXNcIiAmJiBsYW5nXzEuaXNQcmVzZW50KGNoYW5nZXMpICYmICF0aHJvd09uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0RGlyZWN0aXZlRm9yKGRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkub25DaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuX2NoZWNrKHByb3RvLCB0aHJvd09uQ2hhbmdlLCB0aGlzLnZhbHVlcywgdGhpcy5sb2NhbHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGl2ZU9yRWxlbWVudChjaGFuZ2UsIGJpbmRpbmdSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRoaXMuX2FkZENoYW5nZShiaW5kaW5nUmVjb3JkLCBjaGFuZ2UsIGNoYW5nZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm90by5sYXN0SW5EaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCAmJiAhYmluZGluZ1JlY29yZC5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldERldGVjdG9yRm9yKGRpcmVjdGl2ZVJlY29yZC5kaXJlY3RpdmVJbmRleCkubWFya0FzQ2hlY2tPbmNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9maXJzdEluQmluZGluZyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIHByZXYgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLnByb3RvQnlJbmRleCh0aGlzLl9yZWNvcmRzLCByLnNlbGZJbmRleCAtIDEpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhwcmV2KSB8fCBwcmV2LmJpbmRpbmdSZWNvcmQgIT09IHIuYmluZGluZ1JlY29yZDtcclxuICAgIH07XHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXJzID0gdGhpcy5fZGlyZWN0aXZlUmVjb3JkcztcclxuICAgICAgICBmb3IgKHZhciBpID0gZGlycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJDb250ZW50SW5pdCAmJiAhdGhpcy5hbHJlYWR5Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0RGlyZWN0aXZlRm9yKGRpci5kaXJlY3RpdmVJbmRleCkuYWZ0ZXJDb250ZW50SW5pdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyQ29udGVudENoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXIuZGlyZWN0aXZlSW5kZXgpLmFmdGVyQ29udGVudENoZWNrZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc0ludGVybmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXJzID0gdGhpcy5fZGlyZWN0aXZlUmVjb3JkcztcclxuICAgICAgICBmb3IgKHZhciBpID0gZGlycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZGlyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpci5jYWxsQWZ0ZXJWaWV3SW5pdCAmJiAhdGhpcy5hbHJlYWR5Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0RGlyZWN0aXZlRm9yKGRpci5kaXJlY3RpdmVJbmRleCkuYWZ0ZXJWaWV3SW5pdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXIuY2FsbEFmdGVyVmlld0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldERpcmVjdGl2ZUZvcihkaXIuZGlyZWN0aXZlSW5kZXgpLmFmdGVyVmlld0NoZWNrZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl91cGRhdGVEaXJlY3RpdmVPckVsZW1lbnQgPSBmdW5jdGlvbiAoY2hhbmdlLCBiaW5kaW5nUmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGJpbmRpbmdSZWNvcmQuZGlyZWN0aXZlUmVjb3JkKSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5vdGlmeURpc3BhdGNoZXIuY2FsbCh0aGlzLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbmRleCA9IGJpbmRpbmdSZWNvcmQuZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICBiaW5kaW5nUmVjb3JkLnNldHRlcih0aGlzLl9nZXREaXJlY3RpdmVGb3IoZGlyZWN0aXZlSW5kZXgpLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2dlbkNvbmZpZy5sb2dCaW5kaW5nVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUubG9nQmluZGluZ1VwZGF0ZS5jYWxsKHRoaXMsIGNoYW5nZS5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9hZGRDaGFuZ2UgPSBmdW5jdGlvbiAoYmluZGluZ1JlY29yZCwgY2hhbmdlLCBjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGJpbmRpbmdSZWNvcmQuY2FsbE9uQ2hhbmdlcygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFkZENoYW5nZS5jYWxsKHRoaXMsIGNoYW5nZXMsIGNoYW5nZS5wcmV2aW91c1ZhbHVlLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9nZXREaXJlY3RpdmVGb3IgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgpIHsgcmV0dXJuIHRoaXMuZGlyZWN0aXZlcy5nZXREaXJlY3RpdmVGb3IoZGlyZWN0aXZlSW5kZXgpOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fZ2V0RGV0ZWN0b3JGb3IgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgpIHsgcmV0dXJuIHRoaXMuZGlyZWN0aXZlcy5nZXREZXRlY3RvckZvcihkaXJlY3RpdmVJbmRleCk7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9jaGVjayA9IGZ1bmN0aW9uIChwcm90bywgdGhyb3dPbkNoYW5nZSwgdmFsdWVzLCBsb2NhbHMpIHtcclxuICAgICAgICBpZiAocHJvdG8uaXNQaXBlUmVjb3JkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpcGVDaGVjayhwcm90bywgdGhyb3dPbkNoYW5nZSwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWZlcmVuY2VDaGVjayhwcm90bywgdGhyb3dPbkNoYW5nZSwgdmFsdWVzLCBsb2NhbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9yZWZlcmVuY2VDaGVjayA9IGZ1bmN0aW9uIChwcm90bywgdGhyb3dPbkNoYW5nZSwgdmFsdWVzLCBsb2NhbHMpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHVyZUZ1bmNBbmRBcmdzRGlkTm90Q2hhbmdlKHByb3RvKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VyclZhbHVlID0gdGhpcy5fY2FsY3VsYXRlQ3VyclZhbHVlKHByb3RvLCB2YWx1ZXMsIGxvY2Fscyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kgPT09IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaE9ic2VydmUpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vYnNlcnZlVmFsdWUuY2FsbCh0aGlzLCBjdXJyVmFsdWUsIHByb3RvLnNlbGZJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm90by5zaG91bGRCZUNoZWNrZWQoKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5fcmVhZFNlbGYocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmICghaXNTYW1lKHByZXZWYWx1ZSwgY3VyclZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3RvLmxhc3RJbkJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5zaW1wbGVDaGFuZ2UocHJldlZhbHVlLCBjdXJyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aHJvd09uQ2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93T25DaGFuZ2VFcnJvcihwcmV2VmFsdWUsIGN1cnJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWxmKHByb3RvLCBjdXJyVmFsdWUsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2hhbmdlZChwcm90bywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VsZihwcm90bywgY3VyclZhbHVlLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2hhbmdlZChwcm90bywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VsZihwcm90bywgY3VyclZhbHVlLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX2NhbGN1bGF0ZUN1cnJWYWx1ZSA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWVzLCBsb2NhbHMpIHtcclxuICAgICAgICBzd2l0Y2ggKHByb3RvLm1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNlbGY6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENvbnRleHQocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Db25zdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5mdW5jT3JWYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByb3BlcnR5UmVhZDpcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fcmVhZENvbnRleHQocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uZnVuY09yVmFsdWUoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5TYWZlUHJvcGVydHk6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc0JsYW5rKGNvbnRleHQpID8gbnVsbCA6IHByb3RvLmZ1bmNPclZhbHVlKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJvcGVydHlXcml0ZTpcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fcmVhZENvbnRleHQocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKVswXTtcclxuICAgICAgICAgICAgICAgIHByb3RvLmZ1bmNPclZhbHVlKGNvbnRleHQsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkV3JpdGU6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcylbMV07XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkxvY2FsOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2Fscy5nZXQocHJvdG8ubmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnZva2VNZXRob2Q6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5mdW5jT3JWYWx1ZShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNhZmVNZXRob2RJbnZva2U6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLmZ1bmNPclZhbHVlKGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuS2V5ZWRSZWFkOlxyXG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpW2FyZ107XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5DaGFpbjpcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuSW52b2tlQ2xvc3VyZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nXzEuRnVuY3Rpb25XcmFwcGVyLmFwcGx5KHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpLCB0aGlzLl9yZWFkQXJncyhwcm90bywgdmFsdWVzKSk7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnRlcnBvbGF0ZTpcclxuICAgICAgICAgICAgY2FzZSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByaW1pdGl2ZU9wOlxyXG4gICAgICAgICAgICBjYXNlIHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ29sbGVjdGlvbkxpdGVyYWw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ18xLkZ1bmN0aW9uV3JhcHBlci5hcHBseShwcm90by5mdW5jT3JWYWx1ZSwgdGhpcy5fcmVhZEFyZ3MocHJvdG8sIHZhbHVlcykpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBvcGVyYXRpb24gXCIgKyBwcm90by5tb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcGlwZUNoZWNrID0gZnVuY3Rpb24gKHByb3RvLCB0aHJvd09uQ2hhbmdlLCB2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3JlYWRDb250ZXh0KHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZFBpcGUgPSB0aGlzLl9waXBlRm9yKHByb3RvLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXNlbGVjdGVkUGlwZS5wdXJlIHx8IHRoaXMuX2FyZ3NPckNvbnRleHRDaGFuZ2VkKHByb3RvKSkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3JlYWRBcmdzKHByb3RvLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YXIgY3VyclZhbHVlID0gc2VsZWN0ZWRQaXBlLnBpcGUudHJhbnNmb3JtKGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAocHJvdG8uc2hvdWxkQmVDaGVja2VkKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSB0aGlzLl9yZWFkU2VsZihwcm90bywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTYW1lKHByZXZWYWx1ZSwgY3VyclZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJWYWx1ZSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwudW53cmFwVmFsdWUoY3VyclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG8ubGFzdEluQmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5zaW1wbGVDaGFuZ2UocHJldlZhbHVlLCBjdXJyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkNoYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dPbkNoYW5nZUVycm9yKHByZXZWYWx1ZSwgY3VyclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWxmKHByb3RvLCBjdXJyVmFsdWUsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWxmKHByb3RvLCBjdXJyVmFsdWUsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGFuZ2VkKHByb3RvLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVNlbGYocHJvdG8sIGN1cnJWYWx1ZSwgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldENoYW5nZWQocHJvdG8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcGlwZUZvciA9IGZ1bmN0aW9uIChwcm90bywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzdG9yZWRQaXBlID0gdGhpcy5fcmVhZFBpcGUocHJvdG8pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0b3JlZFBpcGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkUGlwZTtcclxuICAgICAgICB2YXIgcGlwZSA9IHRoaXMucGlwZXMuZ2V0KHByb3RvLm5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlUGlwZShwcm90bywgcGlwZSk7XHJcbiAgICAgICAgcmV0dXJuIHBpcGU7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcmVhZENvbnRleHQgPSBmdW5jdGlvbiAocHJvdG8sIHZhbHVlcykge1xyXG4gICAgICAgIGlmIChwcm90by5jb250ZXh0SW5kZXggPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpcmVjdGl2ZUZvcihwcm90by5kaXJlY3RpdmVJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW3Byb3RvLmNvbnRleHRJbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXNbcHJvdG8uY29udGV4dEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9yZWFkU2VsZiA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWVzKSB7IHJldHVybiB2YWx1ZXNbcHJvdG8uc2VsZkluZGV4XTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3dyaXRlU2VsZiA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWUsIHZhbHVlcykgeyB2YWx1ZXNbcHJvdG8uc2VsZkluZGV4XSA9IHZhbHVlOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fcmVhZFBpcGUgPSBmdW5jdGlvbiAocHJvdG8pIHsgcmV0dXJuIHRoaXMubG9jYWxQaXBlc1twcm90by5zZWxmSW5kZXhdOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fd3JpdGVQaXBlID0gZnVuY3Rpb24gKHByb3RvLCB2YWx1ZSkgeyB0aGlzLmxvY2FsUGlwZXNbcHJvdG8uc2VsZkluZGV4XSA9IHZhbHVlOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fc2V0Q2hhbmdlZCA9IGZ1bmN0aW9uIChwcm90bywgdmFsdWUpIHtcclxuICAgICAgICBpZiAocHJvdG8uYXJndW1lbnRUb1B1cmVGdW5jdGlvbilcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzW3Byb3RvLnNlbGZJbmRleF0gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBEeW5hbWljQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9wdXJlRnVuY0FuZEFyZ3NEaWROb3RDaGFuZ2UgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICByZXR1cm4gcHJvdG8uaXNQdXJlRnVuY3Rpb24oKSAmJiAhdGhpcy5fYXJnc0NoYW5nZWQocHJvdG8pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX2FyZ3NDaGFuZ2VkID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBwcm90by5hcmdzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VzW2FyZ3NbaV1dKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRHluYW1pY0NoYW5nZURldGVjdG9yLnByb3RvdHlwZS5fYXJnc09yQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXJnc0NoYW5nZWQocHJvdG8pIHx8IHRoaXMuY2hhbmdlc1twcm90by5jb250ZXh0SW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIER5bmFtaWNDaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuX3JlYWRBcmdzID0gZnVuY3Rpb24gKHByb3RvLCB2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShwcm90by5hcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBwcm90by5hcmdzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXNbaV0gPSB2YWx1ZXNbYXJnc1tpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIER5bmFtaWNDaGFuZ2VEZXRlY3RvcjtcclxufSkoYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yXzEuQWJzdHJhY3RDaGFuZ2VEZXRlY3Rvcik7XHJcbmV4cG9ydHMuRHluYW1pY0NoYW5nZURldGVjdG9yID0gRHluYW1pY0NoYW5nZURldGVjdG9yO1xyXG5mdW5jdGlvbiBpc1NhbWUoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZyAmJiBiIGluc3RhbmNlb2YgU3RyaW5nICYmIGEgPT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmICgoYSAhPT0gYSkgJiYgKGIgIT09IGIpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWNfY2hhbmdlX2RldGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgRXZlbnRCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50QmluZGluZyhldmVudE5hbWUsIGVsSW5kZXgsIGRpckluZGV4LCByZWNvcmRzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XHJcbiAgICAgICAgdGhpcy5lbEluZGV4ID0gZWxJbmRleDtcclxuICAgICAgICB0aGlzLmRpckluZGV4ID0gZGlySW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudEJpbmRpbmc7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRXZlbnRCaW5kaW5nID0gRXZlbnRCaW5kaW5nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9iaW5kaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zXCIpO1xyXG4vKipcclxuICogQW4gZXJyb3IgdGhyb3duIGlmIGFwcGxpY2F0aW9uIGNoYW5nZXMgbW9kZWwgYnJlYWtpbmcgdGhlIHRvcC1kb3duIGRhdGEgZmxvdy5cclxuICpcclxuICogVGhpcyBleGNlcHRpb24gaXMgb25seSB0aHJvd24gaW4gZGV2IG1vZGUuXHJcbiAqXHJcbiAqIDwhLS0gVE9ETzogQWRkIGEgbGluayBvbmNlIHRoZSBkZXYgbW9kZSBvcHRpb24gaXMgY29uZmlndXJhYmxlIC0tPlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAncGFyZW50JyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGNoaWxkIFtwcm9wXT1cInBhcmVudFByb3BcIj48L2NoaWxkPlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW2ZvcndhcmRSZWYoKCkgPT4gQ2hpbGQpXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBQYXJlbnQge1xyXG4gKiAgIHBhcmVudFByb3AgPSBcImluaXRcIjtcclxuICogfVxyXG4gKlxyXG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2NoaWxkJywgaW5wdXRzOiBbJ3Byb3AnXX0pXHJcbiAqIGNsYXNzIENoaWxkIHtcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFyZW50OiBQYXJlbnQpIHt9XHJcbiAqXHJcbiAqICAgc2V0IHByb3Aodikge1xyXG4gKiAgICAgLy8gdGhpcyB1cGRhdGVzIHRoZSBwYXJlbnQgcHJvcGVydHksIHdoaWNoIGlzIGRpc2FsbG93ZWQgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb25cclxuICogICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb25cclxuICogICAgIHRoaXMucGFyZW50LnBhcmVudFByb3AgPSBcInVwZGF0ZWRcIjtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24oZXhwLCBvbGRWYWx1ZSwgY3VyclZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgKFwiRXhwcmVzc2lvbiAnXCIgKyBleHAgKyBcIicgaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQuIFwiKSArXHJcbiAgICAgICAgICAgIChcIlByZXZpb3VzIHZhbHVlOiAnXCIgKyBvbGRWYWx1ZSArIFwiJy4gQ3VycmVudCB2YWx1ZTogJ1wiICsgY3VyclZhbHVlICsgXCInXCIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbjtcclxufSkoZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pO1xyXG5leHBvcnRzLkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uID0gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb247XHJcbi8qKlxyXG4gKiBUaHJvd24gd2hlbiBhbiBleHByZXNzaW9uIGV2YWx1YXRpb24gcmFpc2VzIGFuIGV4Y2VwdGlvbi5cclxuICpcclxuICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cclxuICogYmUgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC8yS3l3b3o/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2NoaWxkJywgaW5wdXRzOiBbJ3Byb3AnXX0pXHJcbiAqIGNsYXNzIENoaWxkIHtcclxuICogICBwcm9wO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGNoaWxkIFtwcm9wXT1cImZpZWxkLmZpcnN0XCI+PC9jaGlsZD5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDaGlsZF1cclxuICogfSlcclxuICogY2xhc3MgQXBwIHtcclxuICogICBmaWVsZCA9IG51bGw7XHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBZb3UgY2FuIGFjY2VzcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIGFuZCBzdGFjayB0aHJvdWdoIHRoZSBgb3JpZ2luYWxFeGNlcHRpb25gIGFuZFxyXG4gKiBgb3JpZ2luYWxTdGFja2AgcHJvcGVydGllcy5cclxuICovXHJcbnZhciBDaGFuZ2VEZXRlY3Rpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hhbmdlRGV0ZWN0aW9uRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3Rpb25FcnJvcihleHAsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb3JpZ2luYWxFeGNlcHRpb24gKyBcIiBpbiBbXCIgKyBleHAgKyBcIl1cIiwgb3JpZ2luYWxFeGNlcHRpb24sIG9yaWdpbmFsU3RhY2ssIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBleHA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25FcnJvciA9IENoYW5nZURldGVjdGlvbkVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gY2hhbmdlIGRldGVjdG9yIGV4ZWN1dGVzIG9uIGRlaHlkcmF0ZWQgdmlldy5cclxuICpcclxuICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cclxuICpcclxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCBBbmd1bGFyIGVycm9yLlxyXG4gKi9cclxudmFyIERlaHlkcmF0ZWRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERlaHlkcmF0ZWRFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZWh5ZHJhdGVkRXhjZXB0aW9uKCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0IHRvIGRldGVjdCBjaGFuZ2VzIG9uIGEgZGVoeWRyYXRlZCBkZXRlY3Rvci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBEZWh5ZHJhdGVkRXhjZXB0aW9uO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuRGVoeWRyYXRlZEV4Y2VwdGlvbiA9IERlaHlkcmF0ZWRFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBEZWJ1Z0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVidWdDb250ZXh0KGVsZW1lbnQsIGNvbXBvbmVudEVsZW1lbnQsIGRpcmVjdGl2ZSwgY29udGV4dCwgbG9jYWxzLCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRFbGVtZW50ID0gY29tcG9uZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbG9jYWxzO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBEZWJ1Z0NvbnRleHQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVidWdDb250ZXh0ID0gRGVidWdDb250ZXh0O1xyXG52YXIgQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWcoZ2VuQ2hlY2tOb0NoYW5nZXMsIGdlbkRlYnVnSW5mbywgbG9nQmluZGluZ1VwZGF0ZSwgdXNlSml0KSB7XHJcbiAgICAgICAgdGhpcy5nZW5DaGVja05vQ2hhbmdlcyA9IGdlbkNoZWNrTm9DaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMuZ2VuRGVidWdJbmZvID0gZ2VuRGVidWdJbmZvO1xyXG4gICAgICAgIHRoaXMubG9nQmluZGluZ1VwZGF0ZSA9IGxvZ0JpbmRpbmdVcGRhdGU7XHJcbiAgICAgICAgdGhpcy51c2VKaXQgPSB1c2VKaXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWc7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JHZW5Db25maWcgPSBDaGFuZ2VEZXRlY3RvckdlbkNvbmZpZztcclxudmFyIENoYW5nZURldGVjdG9yRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvckRlZmluaXRpb24oaWQsIHN0cmF0ZWd5LCB2YXJpYWJsZU5hbWVzLCBiaW5kaW5nUmVjb3JkcywgZXZlbnRSZWNvcmRzLCBkaXJlY3RpdmVSZWNvcmRzLCBnZW5Db25maWcpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IHZhcmlhYmxlTmFtZXM7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nUmVjb3JkcyA9IGJpbmRpbmdSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWNvcmRzID0gZXZlbnRSZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlUmVjb3JkcyA9IGRpcmVjdGl2ZVJlY29yZHM7XHJcbiAgICAgICAgdGhpcy5nZW5Db25maWcgPSBnZW5Db25maWc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLkNoYW5nZURldGVjdG9yRGVmaW5pdGlvbiA9IENoYW5nZURldGVjdG9yRGVmaW5pdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvcl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3InKTtcclxudmFyIEppdFByb3RvQ2hhbmdlRGV0ZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSml0UHJvdG9DaGFuZ2VEZXRlY3RvcihkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcclxuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gdGhpcy5fY3JlYXRlRmFjdG9yeShkZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIEppdFByb3RvQ2hhbmdlRGV0ZWN0b3IuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgSml0UHJvdG9DaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgeyByZXR1cm4gdGhpcy5fZmFjdG9yeShkaXNwYXRjaGVyKTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEppdFByb3RvQ2hhbmdlRGV0ZWN0b3IucHJvdG90eXBlLl9jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IGNoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvcl8xLkNoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yKGRlZmluaXRpb24sICd1dGlsJywgJ0Fic3RyYWN0Q2hhbmdlRGV0ZWN0b3InKS5nZW5lcmF0ZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBKaXRQcm90b0NoYW5nZURldGVjdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLkppdFByb3RvQ2hhbmdlRGV0ZWN0b3IgPSBKaXRQcm90b0NoYW5nZURldGVjdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qaXRfcHJvdG9fY2hhbmdlX2RldGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztmdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmlzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZV9mYWNhZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmdcIik7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb25cIik7XHJcbnZhciBBU1QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQVNUKCkge1xyXG4gICAgfVxyXG4gICAgQVNULnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQVNUXCI7IH07XHJcbiAgICByZXR1cm4gQVNUO1xyXG59KSgpO1xyXG5leHBvcnRzLkFTVCA9IEFTVDtcclxudmFyIEVtcHR5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRW1wdHlFeHByLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbXB0eUV4cHI7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuRW1wdHlFeHByID0gRW1wdHlFeHByO1xyXG52YXIgSW1wbGljaXRSZWNlaXZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEltcGxpY2l0UmVjZWl2ZXIoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBJbXBsaWNpdFJlY2VpdmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SW1wbGljaXRSZWNlaXZlcih0aGlzKTsgfTtcclxuICAgIHJldHVybiBJbXBsaWNpdFJlY2VpdmVyO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkltcGxpY2l0UmVjZWl2ZXIgPSBJbXBsaWNpdFJlY2VpdmVyO1xyXG4vKipcclxuICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxyXG4gKi9cclxudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDaGFpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENoYWluKGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG4gICAgfVxyXG4gICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGFpbih0aGlzKTsgfTtcclxuICAgIHJldHVybiBDaGFpbjtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5DaGFpbiA9IENoYWluO1xyXG52YXIgQ29uZGl0aW9uYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWwoY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XHJcbiAgICAgICAgdGhpcy5mYWxzZUV4cCA9IGZhbHNlRXhwO1xyXG4gICAgfVxyXG4gICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBDb25kaXRpb25hbDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5Db25kaXRpb25hbCA9IENvbmRpdGlvbmFsO1xyXG52YXIgSWYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKElmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSWYoY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XHJcbiAgICAgICAgdGhpcy5mYWxzZUV4cCA9IGZhbHNlRXhwO1xyXG4gICAgfVxyXG4gICAgSWYucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJZih0aGlzKTsgfTtcclxuICAgIHJldHVybiBJZjtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5JZiA9IElmO1xyXG52YXIgUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eVJlYWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVJlYWQocmVjZWl2ZXIsIG5hbWUsIGdldHRlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgfVxyXG4gICAgUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5Qcm9wZXJ0eVJlYWQgPSBQcm9wZXJ0eVJlYWQ7XHJcbnZhciBQcm9wZXJ0eVdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eVdyaXRlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJvcGVydHlXcml0ZShyZWNlaXZlciwgbmFtZSwgc2V0dGVyLCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuc2V0dGVyID0gc2V0dGVyO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIFByb3BlcnR5V3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMpOyB9O1xyXG4gICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuUHJvcGVydHlXcml0ZSA9IFByb3BlcnR5V3JpdGU7XHJcbnZhciBTYWZlUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTYWZlUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2FmZVByb3BlcnR5UmVhZChyZWNlaXZlciwgbmFtZSwgZ2V0dGVyKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBnZXR0ZXI7XHJcbiAgICB9XHJcbiAgICBTYWZlUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZVByb3BlcnR5UmVhZCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBTYWZlUHJvcGVydHlSZWFkO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLlNhZmVQcm9wZXJ0eVJlYWQgPSBTYWZlUHJvcGVydHlSZWFkO1xyXG52YXIgS2V5ZWRSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhLZXllZFJlYWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBLZXllZFJlYWQob2JqLCBrZXkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9iaiA9IG9iajtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxuICAgIEtleWVkUmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBLZXllZFJlYWQ7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuS2V5ZWRSZWFkID0gS2V5ZWRSZWFkO1xyXG52YXIgS2V5ZWRXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgS2V5ZWRXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcyk7IH07XHJcbiAgICByZXR1cm4gS2V5ZWRXcml0ZTtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5LZXllZFdyaXRlID0gS2V5ZWRXcml0ZTtcclxudmFyIEJpbmRpbmdQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKGV4cCwgbmFtZSwgYXJncykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZXhwID0gZXhwO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIEJpbmRpbmdQaXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzKTsgfTtcclxuICAgIHJldHVybiBCaW5kaW5nUGlwZTtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5CaW5kaW5nUGlwZSA9IEJpbmRpbmdQaXBlO1xyXG52YXIgTGl0ZXJhbFByaW1pdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbFByaW1pdGl2ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUodmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzKTsgfTtcclxuICAgIHJldHVybiBMaXRlcmFsUHJpbWl0aXZlO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkxpdGVyYWxQcmltaXRpdmUgPSBMaXRlcmFsUHJpbWl0aXZlO1xyXG52YXIgTGl0ZXJhbEFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaXRlcmFsQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXkoZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcbiAgICB9XHJcbiAgICBMaXRlcmFsQXJyYXkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcyk7IH07XHJcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkxpdGVyYWxBcnJheSA9IExpdGVyYWxBcnJheTtcclxudmFyIExpdGVyYWxNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpdGVyYWxNYXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwKGtleXMsIHZhbHVlcykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICB9XHJcbiAgICBMaXRlcmFsTWFwLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBMaXRlcmFsTWFwO1xyXG59KShBU1QpO1xyXG5leHBvcnRzLkxpdGVyYWxNYXAgPSBMaXRlcmFsTWFwO1xyXG52YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuICAgIH1cclxuICAgIEludGVycG9sYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcyk7IH07XHJcbiAgICByZXR1cm4gSW50ZXJwb2xhdGlvbjtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5JbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGlvbjtcclxudmFyIEJpbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmluYXJ5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmluYXJ5KG9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzKTsgfTtcclxuICAgIHJldHVybiBCaW5hcnk7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xyXG52YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVmaXhOb3QsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVmaXhOb3QoZXhwcmVzc2lvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbiAgICBQcmVmaXhOb3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmVmaXhOb3QodGhpcyk7IH07XHJcbiAgICByZXR1cm4gUHJlZml4Tm90O1xyXG59KShBU1QpO1xyXG5leHBvcnRzLlByZWZpeE5vdCA9IFByZWZpeE5vdDtcclxudmFyIE1ldGhvZENhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNZXRob2RDYWxsKHJlY2VpdmVyLCBuYW1lLCBmbiwgYXJncykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgfVxyXG4gICAgTWV0aG9kQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdE1ldGhvZENhbGwodGhpcyk7IH07XHJcbiAgICByZXR1cm4gTWV0aG9kQ2FsbDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5NZXRob2RDYWxsID0gTWV0aG9kQ2FsbDtcclxudmFyIFNhZmVNZXRob2RDYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTYWZlTWV0aG9kQ2FsbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNhZmVNZXRob2RDYWxsKHJlY2VpdmVyLCBuYW1lLCBmbiwgYXJncykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgfVxyXG4gICAgU2FmZU1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcclxufSkoQVNUKTtcclxuZXhwb3J0cy5TYWZlTWV0aG9kQ2FsbCA9IFNhZmVNZXRob2RDYWxsO1xyXG52YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkNhbGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkNhbGwodGFyZ2V0LCBhcmdzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uQ2FsbCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBGdW5jdGlvbkNhbGw7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuRnVuY3Rpb25DYWxsID0gRnVuY3Rpb25DYWxsO1xyXG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQVNUV2l0aFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgfVxyXG4gICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvcik7IH07XHJcbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc291cmNlICsgXCIgaW4gXCIgKyB0aGlzLmxvY2F0aW9uOyB9O1xyXG4gICAgcmV0dXJuIEFTVFdpdGhTb3VyY2U7XHJcbn0pKEFTVCk7XHJcbmV4cG9ydHMuQVNUV2l0aFNvdXJjZSA9IEFTVFdpdGhTb3VyY2U7XHJcbnZhciBUZW1wbGF0ZUJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nKGtleSwga2V5SXNWYXIsIG5hbWUsIGV4cHJlc3Npb24pIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZztcclxufSkoKTtcclxuZXhwb3J0cy5UZW1wbGF0ZUJpbmRpbmcgPSBUZW1wbGF0ZUJpbmRpbmc7XHJcbnZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QubGVmdC52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QucmlnaHQudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJZiA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QudGFyZ2V0LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XHJcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcclxuICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpOyB9O1xyXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgIH07XHJcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVjdXJzaXZlQXN0VmlzaXRvciA9IFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XHJcbnZhciBBc3RUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcclxuICAgIH1cclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3Q7IH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihhc3Quc3RyaW5ncywgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZShhc3QudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZChhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3QuZ2V0dGVyKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3Quc2V0dGVyLCBhc3QudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC5nZXR0ZXIpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RDYWxsKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC5mbiwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2FmZU1ldGhvZENhbGwoYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LmZuLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGFzdC50YXJnZXQudmlzaXQodGhpcyksIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkodGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5vcGVyYXRpb24sIGFzdC5sZWZ0LnZpc2l0KHRoaXMpLCBhc3QucmlnaHQudmlzaXQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpOyB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbChhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LmV4cC52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xyXG4gICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGFzdHMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gYXN0c1tpXS52aXNpdCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpOyB9O1xyXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SWYgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGZhbHNlRXhwID0gbGFuZ18xLmlzUHJlc2VudChhc3QuZmFsc2VFeHApID8gYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IElmKGFzdC5jb25kaXRpb24udmlzaXQodGhpcyksIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpLCBmYWxzZUV4cCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkFzdFRyYW5zZm9ybWVyID0gQXN0VHJhbnNmb3JtZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2RlY29yYXRvcnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvblwiKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZ1wiKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbihmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XHJcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ2hhcmFjdGVyXCJdID0gMF0gPSBcIkNoYXJhY3RlclwiO1xyXG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIklkZW50aWZpZXJcIl0gPSAxXSA9IFwiSWRlbnRpZmllclwiO1xyXG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAyXSA9IFwiS2V5d29yZFwiO1xyXG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlN0cmluZ1wiXSA9IDNdID0gXCJTdHJpbmdcIjtcclxuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJPcGVyYXRvclwiXSA9IDRdID0gXCJPcGVyYXRvclwiO1xyXG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDVdID0gXCJOdW1iZXJcIjtcclxufSkoZXhwb3J0cy5Ub2tlblR5cGUgfHwgKGV4cG9ydHMuVG9rZW5UeXBlID0ge30pKTtcclxudmFyIFRva2VuVHlwZSA9IGV4cG9ydHMuVG9rZW5UeXBlO1xyXG52YXIgTGV4ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGV4ZXIoKSB7XHJcbiAgICB9XHJcbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIHZhciBzY2FubmVyID0gbmV3IF9TY2FubmVyKHRleHQpO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcclxuICAgICAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xyXG4gICAgICAgIHdoaWxlICh0b2tlbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgfTtcclxuICAgIExleGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVjb3JhdG9yc18xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIExleGVyKTtcclxuICAgIHJldHVybiBMZXhlcjtcclxufSkoKTtcclxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xyXG52YXIgVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9rZW4oaW5kZXgsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubnVtVmFsdWUgPSBudW1WYWx1ZTtcclxuICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XHJcbiAgICB9XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlKTtcclxuICAgIH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuU3RyaW5nKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0ZXIpO1xyXG4gICAgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5JZGVudGlmaWVyKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRWYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJ2YXJcIik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcIm51bGxcIik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJ1bmRlZmluZWRcIik7XHJcbiAgICB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRydWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJ0cnVlXCIpOyB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZElmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwiaWZcIik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRWxzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcImVsc2VcIik7IH07XHJcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJmYWxzZVwiKTsgfTtcclxuICAgIFRva2VuLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAtMSBpbnN0ZWFkIG9mIE5VTEwgb2s/XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcikgPyB0aGlzLm51bVZhbHVlIDogLTE7XHJcbiAgICB9O1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkNoYXJhY3RlcjpcclxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuSWRlbnRpZmllcjpcclxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuS2V5d29yZDpcclxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuT3BlcmF0b3I6XHJcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLlN0cmluZzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xyXG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5OdW1iZXI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBUb2tlbjtcclxufSkoKTtcclxuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xyXG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgY29kZSkge1xyXG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKGNvZGUpKTtcclxufVxyXG5mdW5jdGlvbiBuZXdJZGVudGlmaWVyVG9rZW4oaW5kZXgsIHRleHQpIHtcclxuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5JZGVudGlmaWVyLCAwLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIHRleHQpIHtcclxuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5LZXl3b3JkLCAwLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRvclRva2VuKGluZGV4LCB0ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuT3BlcmF0b3IsIDAsIHRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCB0ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuU3RyaW5nLCAwLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgbikge1xyXG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk51bWJlciwgbiwgXCJcIik7XHJcbn1cclxuZXhwb3J0cy5FT0YgPSBuZXcgVG9rZW4oLTEsIFRva2VuVHlwZS5DaGFyYWN0ZXIsIDAsIFwiXCIpO1xyXG5leHBvcnRzLiRFT0YgPSAwO1xyXG5leHBvcnRzLiRUQUIgPSA5O1xyXG5leHBvcnRzLiRMRiA9IDEwO1xyXG5leHBvcnRzLiRWVEFCID0gMTE7XHJcbmV4cG9ydHMuJEZGID0gMTI7XHJcbmV4cG9ydHMuJENSID0gMTM7XHJcbmV4cG9ydHMuJFNQQUNFID0gMzI7XHJcbmV4cG9ydHMuJEJBTkcgPSAzMztcclxuZXhwb3J0cy4kRFEgPSAzNDtcclxuZXhwb3J0cy4kSEFTSCA9IDM1O1xyXG5leHBvcnRzLiQkID0gMzY7XHJcbmV4cG9ydHMuJFBFUkNFTlQgPSAzNztcclxuZXhwb3J0cy4kQU1QRVJTQU5EID0gMzg7XHJcbmV4cG9ydHMuJFNRID0gMzk7XHJcbmV4cG9ydHMuJExQQVJFTiA9IDQwO1xyXG5leHBvcnRzLiRSUEFSRU4gPSA0MTtcclxuZXhwb3J0cy4kU1RBUiA9IDQyO1xyXG5leHBvcnRzLiRQTFVTID0gNDM7XHJcbmV4cG9ydHMuJENPTU1BID0gNDQ7XHJcbmV4cG9ydHMuJE1JTlVTID0gNDU7XHJcbmV4cG9ydHMuJFBFUklPRCA9IDQ2O1xyXG5leHBvcnRzLiRTTEFTSCA9IDQ3O1xyXG5leHBvcnRzLiRDT0xPTiA9IDU4O1xyXG5leHBvcnRzLiRTRU1JQ09MT04gPSA1OTtcclxuZXhwb3J0cy4kTFQgPSA2MDtcclxuZXhwb3J0cy4kRVEgPSA2MTtcclxuZXhwb3J0cy4kR1QgPSA2MjtcclxuZXhwb3J0cy4kUVVFU1RJT04gPSA2MztcclxudmFyICQwID0gNDg7XHJcbnZhciAkOSA9IDU3O1xyXG52YXIgJEEgPSA2NSwgJEUgPSA2OSwgJFogPSA5MDtcclxuZXhwb3J0cy4kTEJSQUNLRVQgPSA5MTtcclxuZXhwb3J0cy4kQkFDS1NMQVNIID0gOTI7XHJcbmV4cG9ydHMuJFJCUkFDS0VUID0gOTM7XHJcbnZhciAkQ0FSRVQgPSA5NDtcclxudmFyICRfID0gOTU7XHJcbnZhciAkYSA9IDk3LCAkZSA9IDEwMSwgJGYgPSAxMDIsICRuID0gMTEwLCAkciA9IDExNCwgJHQgPSAxMTYsICR1ID0gMTE3LCAkdiA9IDExOCwgJHogPSAxMjI7XHJcbmV4cG9ydHMuJExCUkFDRSA9IDEyMztcclxuZXhwb3J0cy4kQkFSID0gMTI0O1xyXG5leHBvcnRzLiRSQlJBQ0UgPSAxMjU7XHJcbnZhciAkTkJTUCA9IDE2MDtcclxudmFyIFNjYW5uZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2Nhbm5lckVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2Nhbm5lckVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgU2Nhbm5lckVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcclxuICAgIHJldHVybiBTY2FubmVyRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5TY2FubmVyRXJyb3IgPSBTY2FubmVyRXJyb3I7XHJcbnZhciBfU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfU2Nhbm5lcihpbnB1dCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICB0aGlzLnBlZWsgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgIH1cclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGVlayA9XHJcbiAgICAgICAgICAgICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/IGV4cG9ydHMuJEVPRiA6IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQodGhpcy5pbnB1dCwgdGhpcy5pbmRleCk7XHJcbiAgICB9O1xyXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aCwgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cclxuICAgICAgICB3aGlsZSAocGVlayA8PSBleHBvcnRzLiRTUEFDRSkge1xyXG4gICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHBlZWsgPSBleHBvcnRzLiRFT0Y7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlZWsgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0KGlucHV0LCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZWVrID0gcGVlaztcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxyXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChwZWVrKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWJlcihpbmRleCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgc3dpdGNoIChwZWVrKSB7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUEVSSU9EOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaWdpdCh0aGlzLnBlZWspID8gdGhpcy5zY2FuTnVtYmVyKHN0YXJ0KSA6IG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCBleHBvcnRzLiRQRVJJT0QpO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJExQQVJFTjpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRSUEFSRU46XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kTEJSQUNFOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFJCUkFDRTpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRMQlJBQ0tFVDpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRSQlJBQ0tFVDpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRDT01NQTpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRDT0xPTjpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRTRU1JQ09MT046XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ2hhcmFjdGVyKHN0YXJ0LCBwZWVrKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRTUTpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiREUTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRIQVNIOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFBMVVM6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kTUlOVVM6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU1RBUjpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRTTEFTSDpcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRQRVJDRU5UOlxyXG4gICAgICAgICAgICBjYXNlICRDQVJFVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PcGVyYXRvcihzdGFydCwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRRVUVTVElPTjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICc/JywgZXhwb3J0cy4kUEVSSU9ELCAnLicpO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJExUOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJEdUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspLCBleHBvcnRzLiRFUSwgJz0nKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRCQU5HOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJEVROlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspLCBleHBvcnRzLiRFUSwgJz0nLCBleHBvcnRzLiRFUSwgJz0nKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRBTVBFUlNBTkQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnJicsIGV4cG9ydHMuJEFNUEVSU0FORCwgJyYnKTtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRCQVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsIGV4cG9ydHMuJEJBUiwgJ3wnKTtcclxuICAgICAgICAgICAgY2FzZSAkTkJTUDpcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Ub2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgW1wiICsgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspICsgXCJdXCIsIDApO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHN0YXJ0LCBjb2RlKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMucGVlayA9PSBjb2RlKTtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIGNvZGUpO1xyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnBlZWsgPT0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChzdHIsIDApKTtcclxuICAgICAgICBhc3NlcnQoY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKE9QRVJBVE9SUywgc3RyKSk7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb25cclxuICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXHJcbiAgICAgKiBAcGFyYW0gdHdvQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgc2Vjb25kIHN5bWJvbFxyXG4gICAgICogQHBhcmFtIHR3byBzZWNvbmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHRoZSBzZWNvbmQgY29kZSBwb2ludCBtYXRjaGVzKVxyXG4gICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXHJcbiAgICAgKiBAcGFyYW0gdGhyZWUgdGhpcmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHByb3ZpZGVkIGFuZCBtYXRjaGVzIHNvdXJjZSBleHByZXNzaW9uKVxyXG4gICAgICogQHJldHVybnMge1Rva2VufVxyXG4gICAgICovXHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbXBsZXhPcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgb25lLCB0d29Db2RlLCB0d28sIHRocmVlQ29kZSwgdGhyZWUpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5wZWVrID09IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQob25lLCAwKSk7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IG9uZTtcclxuICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHN0ciArPSB0d287XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRocmVlQ29kZSkgJiYgdGhpcy5wZWVrID09IHRocmVlQ29kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgc3RyICs9IHRocmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKE9QRVJBVE9SUywgc3RyKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XHJcbiAgICB9O1xyXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydChpc0lkZW50aWZpZXJTdGFydCh0aGlzLnBlZWspKTtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XHJcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhLRVlXT1JEUywgc3RyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCBzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0lkZW50aWZpZXJUb2tlbihzdGFydCwgc3RyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1iZXIgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuICAgICAgICBhc3NlcnQoaXNEaWdpdCh0aGlzLnBlZWspKTtcclxuICAgICAgICB2YXIgc2ltcGxlID0gKHRoaXMuaW5kZXggPT09IHN0YXJ0KTtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHRoaXMucGVlaykpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kUEVSSU9EKSB7XHJcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFeHBvbmVudFNpZ24odGhpcy5wZWVrKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLnBlZWspKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICB2YXIgdmFsdWUgPSBzaW1wbGUgPyBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChzdHIpIDogbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VGbG9hdChzdHIpO1xyXG4gICAgICAgIHJldHVybiBuZXdOdW1iZXJUb2tlbihzdGFydCwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kU1EgfHwgdGhpcy5wZWVrID09IGV4cG9ydHMuJERRKTtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHZhciBxdW90ZSA9IHRoaXMucGVlaztcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxyXG4gICAgICAgIHZhciBidWZmZXI7XHJcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcclxuICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kQkFDS1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IGxhbmdfMS5TdHJpbmdKb2luZXIoKTtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkQ29kZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludChoZXgsIDE2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSB1bmVzY2FwZSh0aGlzLnBlZWspO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUodW5lc2NhcGVkQ29kZSkpO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kRU9GKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgdGVybWluYXRpbmcgcXVvdGUuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdW5lc2NhcGVkIHN0cmluZyB2YWx1ZS5cclxuICAgICAgICB2YXIgdW5lc2NhcGVkID0gbGFzdDtcclxuICAgICAgICBpZiAoYnVmZmVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYnVmZmVyLmFkZChsYXN0KTtcclxuICAgICAgICAgICAgdW5lc2NhcGVkID0gYnVmZmVyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdTdHJpbmdUb2tlbihzdGFydCwgdW5lc2NhcGVkKTtcclxuICAgIH07XHJcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcclxuICAgICAgICB0aHJvdyBuZXcgU2Nhbm5lckVycm9yKFwiTGV4ZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIGF0IGNvbHVtbiBcIiArIHBvc2l0aW9uICsgXCIgaW4gZXhwcmVzc2lvbiBbXCIgKyB0aGlzLmlucHV0ICsgXCJdXCIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfU2Nhbm5lcjtcclxufSkoKTtcclxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcclxuICAgIHJldHVybiAoY29kZSA+PSBleHBvcnRzLiRUQUIgJiYgY29kZSA8PSBleHBvcnRzLiRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xyXG59XHJcbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcclxuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fCAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gZXhwb3J0cy4kJCk7XHJcbn1cclxuZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjb2RlKSB7XHJcbiAgICByZXR1cm4gKCRhIDw9IGNvZGUgJiYgY29kZSA8PSAkeikgfHwgKCRBIDw9IGNvZGUgJiYgY29kZSA8PSAkWikgfHwgKCQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOSkgfHxcclxuICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gZXhwb3J0cy4kJCk7XHJcbn1cclxuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XHJcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xyXG59XHJcbmZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xyXG59XHJcbmZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID09IGV4cG9ydHMuJE1JTlVTIHx8IGNvZGUgPT0gZXhwb3J0cy4kUExVUztcclxufVxyXG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICBjYXNlICRuOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kTEY7XHJcbiAgICAgICAgY2FzZSAkZjpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuJEZGO1xyXG4gICAgICAgIGNhc2UgJHI6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLiRDUjtcclxuICAgICAgICBjYXNlICR0OlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kVEFCO1xyXG4gICAgICAgIGNhc2UgJHY6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLiRWVEFCO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG59XHJcbnZhciBPUEVSQVRPUlMgPSBjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5jcmVhdGVGcm9tTGlzdChbXHJcbiAgICAnKycsXHJcbiAgICAnLScsXHJcbiAgICAnKicsXHJcbiAgICAnLycsXHJcbiAgICAnJScsXHJcbiAgICAnXicsXHJcbiAgICAnPScsXHJcbiAgICAnPT0nLFxyXG4gICAgJyE9JyxcclxuICAgICc9PT0nLFxyXG4gICAgJyE9PScsXHJcbiAgICAnPCcsXHJcbiAgICAnPicsXHJcbiAgICAnPD0nLFxyXG4gICAgJz49JyxcclxuICAgICcmJicsXHJcbiAgICAnfHwnLFxyXG4gICAgJyYnLFxyXG4gICAgJ3wnLFxyXG4gICAgJyEnLFxyXG4gICAgJz8nLFxyXG4gICAgJyMnLFxyXG4gICAgJz8uJ1xyXG5dKTtcclxudmFyIEtFWVdPUkRTID0gY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuY3JlYXRlRnJvbUxpc3QoWyd2YXInLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJ10pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIExvY2FscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2NhbHMocGFyZW50LCBjdXJyZW50KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcclxuICAgIH1cclxuICAgIExvY2Fscy5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNvbnRhaW5zKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTG9jYWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGZpbmQgJ1wiICsgbmFtZSArIFwiJ1wiKTtcclxuICAgIH07XHJcbiAgICBMb2NhbHMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIC8vIFRPRE8ocmFkbyk6IGNvbnNpZGVyIHJlbW92aW5nIHRoaXMgY2hlY2sgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGlzIGlzIG5vdFxyXG4gICAgICAgIC8vIGV4cG9zZWQgdG8gdGhlIHB1YmxpYyBBUEkuXHJcbiAgICAgICAgLy8gVE9ETzogdnNhdmtpbiBtYXliZSBpdCBzaG91bGQgY2hlY2sgb25seSB0aGUgbG9jYWwgbWFwXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldChuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJTZXR0aW5nIG9mIG5ldyBrZXlzIHBvc3QtY29uc3RydWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuIEtleTogXCIgKyBuYW1lICsgXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2NhbHMucHJvdG90eXBlLmNsZWFyVmFsdWVzID0gZnVuY3Rpb24gKCkgeyBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci5jbGVhclZhbHVlcyh0aGlzLmN1cnJlbnQpOyB9O1xyXG4gICAgcmV0dXJuIExvY2FscztcclxufSkoKTtcclxuZXhwb3J0cy5Mb2NhbHMgPSBMb2NhbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2Fscy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2RlY29yYXRvcnMnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxleGVyXzEgPSByZXF1aXJlKCcuL2xleGVyJyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxudmFyIGFzdF8xID0gcmVxdWlyZSgnLi9hc3QnKTtcclxudmFyIF9pbXBsaWNpdFJlY2VpdmVyID0gbmV3IGFzdF8xLkltcGxpY2l0UmVjZWl2ZXIoKTtcclxuLy8gVE9ETyh0Ym9zY2gpOiBDYW5ub3QgbWFrZSB0aGlzIGNvbnN0L2ZpbmFsIHJpZ2h0IG5vdyBiZWNhdXNlIG9mIHRoZSB0cmFuc3BpbGVyLi4uXHJcbnZhciBJTlRFUlBPTEFUSU9OX1JFR0VYUCA9IC9cXHtcXHsoLio/KVxcfVxcfS9nO1xyXG52YXIgUGFyc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhcnNlRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGFyc2VFeGNlcHRpb24obWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiUGFyc2VyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBcIiArIGVyckxvY2F0aW9uICsgXCIgW1wiICsgaW5wdXQgKyBcIl0gaW4gXCIgKyBjdHhMb2NhdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGFyc2VFeGNlcHRpb247XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxudmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJzZXIoLyoqIEBpbnRlcm5hbCAqLyBfbGV4ZXIsIHByb3ZpZGVkUmVmbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVkUmVmbGVjdG9yID09PSB2b2lkIDApIHsgcHJvdmlkZWRSZWZsZWN0b3IgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5fbGV4ZXIgPSBfbGV4ZXI7XHJcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChwcm92aWRlZFJlZmxlY3RvcikgPyBwcm92aWRlZFJlZmxlY3RvciA6IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3I7XHJcbiAgICB9XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcclxuICAgICAgICB2YXIgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgdGhpcy5fcmVmbGVjdG9yLCB0cnVlKS5wYXJzZUNoYWluKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24pO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XHJcbiAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRoaXMuX3JlZmxlY3RvciwgZmFsc2UpLnBhcnNlQ2hhaW4oKTtcclxuICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24pO1xyXG4gICAgfTtcclxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcclxuICAgICAgICB2YXIgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgdGhpcy5fcmVmbGVjdG9yLCBmYWxzZSkucGFyc2VTaW1wbGVCaW5kaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCB0aGlzLl9yZWZsZWN0b3IsIGZhbHNlKS5wYXJzZVRlbXBsYXRlQmluZGluZ3MoKTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgcGFydHMgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5zcGxpdChpbnB1dCwgSU5URVJQT0xBVElPTl9SRUdFWFApO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcclxuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHBhcnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRoaXMuX3JlZmxlY3RvciwgZmFsc2UpLnBhcnNlQ2hhaW4oKTtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goYXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgaSkgKyBcIiBpblwiLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKG5ldyBhc3RfMS5JbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zKSwgaW5wdXQsIGxvY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZShpbnB1dCksIGlucHV0LCBsb2NhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQoaW5wdXQsIElOVEVSUE9MQVRJT05fUkVHRVhQKTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ0dvdCBpbnRlcnBvbGF0aW9uICh7e319KSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZCcsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIDEpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYXJzZXIucHJvdG90eXBlLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0SW5FcnJJZHgpIHtcclxuICAgICAgICB2YXIgZXJyTG9jYXRpb24gPSAnJztcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRJbkVycklkeDsgaisrKSB7XHJcbiAgICAgICAgICAgIGVyckxvY2F0aW9uICs9IGogJSAyID09PSAwID8gcGFydHNbal0gOiBcInt7XCIgKyBwYXJ0c1tqXSArIFwifX1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVyckxvY2F0aW9uLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICBQYXJzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWNvcmF0b3JzXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtsZXhlcl8xLkxleGVyLCByZWZsZWN0aW9uXzEuUmVmbGVjdG9yXSlcclxuICAgIF0sIFBhcnNlcik7XHJcbiAgICByZXR1cm4gUGFyc2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcclxudmFyIF9QYXJzZUFTVCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHJlZmxlY3RvciwgcGFyc2VBY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xyXG4gICAgICAgIHRoaXMucGFyc2VBY3Rpb24gPSBwYXJzZUFjdGlvbjtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgIH1cclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IGxleGVyXzEuRU9GO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcIm5leHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wZWVrKDApOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcImlucHV0SW5kZXhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gdGhpcy5uZXh0LmluZGV4IDogdGhpcy5pbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5kZXgrKzsgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsS2V5d29yZFZhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wZWVrS2V5d29yZFZhcigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrS2V5d29yZFZhciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRWYXIoKSB8fCB0aGlzLm5leHQuaXNPcGVyYXRvcignIycpOyB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgXCIgKyBsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoY29kZSkpO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNPcGVyYXRvcihvcCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihvcGVyYXRvcikpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XHJcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XHJcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV4cHJzID0gW107XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xyXG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJFNFTUlDT0xPTikpIHtcclxuICAgICAgICAgICAgICAgIH0gLy8gcmVhZCBhbGwgc2VtaWNvbG9uc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHRoaXMubmV4dCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuRW1wdHlFeHByKCk7XHJcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5DaGFpbihleHBycyk7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVNpbXBsZUJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFzdCA9IHRoaXMucGFyc2VDaGFpbigpO1xyXG4gICAgICAgIGlmICghU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiU2ltcGxlIGJpbmRpbmcgZXhwcmVzc2lvbiBjYW4gb25seSBjb250YWluIGZpZWxkIGFjY2VzcyBhbmQgY29uc3RhbnRzJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzdDtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUGlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwifFwiKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNhbm5vdCBoYXZlIGEgcGlwZSBpbiBhbiBhY3Rpb24gZXhwcmVzc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTE9OKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5kaW5nUGlwZShyZXN1bHQsIG5hbWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoXCJ8XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpOyB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8nKSkge1xyXG4gICAgICAgICAgICB2YXIgeWVzID0gdGhpcy5wYXJzZVBpcGUoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTE9OKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBcIiArIGV4cHJlc3Npb24gKyBcIiByZXF1aXJlcyBhbGwgMyBleHByZXNzaW9uc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkNvbmRpdGlvbmFsKHJlc3VsdCwgeWVzLCBubyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbE9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICd8fCdcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcclxuICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8fCcpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJ3x8JywgcmVzdWx0LCB0aGlzLnBhcnNlTG9naWNhbEFuZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAnJiYnXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnJiYnLCByZXN1bHQsIHRoaXMucGFyc2VFcXVhbGl0eSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXF1YWxpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gJz09JywnIT0nLCc9PT0nLCchPT0nXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPT0nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPT0nLCByZXN1bHQsIHRoaXMucGFyc2VSZWxhdGlvbmFsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPT09JykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJz09PScsIHJlc3VsdCwgdGhpcy5wYXJzZVJlbGF0aW9uYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCchPScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCchPScsIHJlc3VsdCwgdGhpcy5wYXJzZVJlbGF0aW9uYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCchPT0nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnIT09JywgcmVzdWx0LCB0aGlzLnBhcnNlUmVsYXRpb25hbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVJlbGF0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gJzwnLCAnPicsICc8PScsICc+PSdcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPCcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc8JywgcmVzdWx0LCB0aGlzLnBhcnNlQWRkaXRpdmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc+JykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJz4nLCByZXN1bHQsIHRoaXMucGFyc2VBZGRpdGl2ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJzw9JykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJzw9JywgcmVzdWx0LCB0aGlzLnBhcnNlQWRkaXRpdmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc+PScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc+PScsIHJlc3VsdCwgdGhpcy5wYXJzZUFkZGl0aXZlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gJysnLCAnLSdcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignKycpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCcrJywgcmVzdWx0LCB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJy0nLCByZXN1bHQsIHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICcqJywgJyUnLCAnLydcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyonKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnKicsIHJlc3VsdCwgdGhpcy5wYXJzZVByZWZpeCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyUnKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnJScsIHJlc3VsdCwgdGhpcy5wYXJzZVByZWZpeCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy8nKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnLycsIHJlc3VsdCwgdGhpcy5wYXJzZVByZWZpeCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcrJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQcmVmaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5CaW5hcnkoJy0nLCBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZSgwKSwgdGhpcy5wYXJzZVByZWZpeCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCchJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5QcmVmaXhOb3QodGhpcy5wYXJzZVByZWZpeCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kUEVSSU9EKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExCUkFDS0VUKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0tFVCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwiPVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5LZXllZFdyaXRlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuS2V5ZWRSZWFkKHJlc3VsdCwga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExQQVJFTikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKGxleGVyXzEuJFJQQVJFTik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuRnVuY3Rpb25DYWxsKHJlc3VsdCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExQQVJFTikpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQaXBlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKGxleGVyXzEuJFJQQVJFTik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkgfHwgdGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxQcmltaXRpdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZEZhbHNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyc2VBY3Rpb24gJiYgdGhpcy5uZXh0LmlzS2V5d29yZElmKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKGxleGVyXzEuJExQQVJFTik7XHJcbiAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSUEFSRU4pO1xyXG4gICAgICAgICAgICB2YXIgaWZFeHAgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbk9yQmxvY2soKTtcclxuICAgICAgICAgICAgdmFyIGVsc2VFeHA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRWxzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VFeHAgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbk9yQmxvY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLklmKGNvbmRpdGlvbiwgaWZFeHAsIGVsc2VFeHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExCUkFDS0VUKSkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QobGV4ZXJfMS4kUkJSQUNLRVQpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0tFVCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbEFycmF5KGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGxleGVyXzEuJExCUkFDRSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChfaW1wbGljaXRSZWNlaXZlciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5leHQudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXRlcmFsVmFsdWUgPSB0aGlzLm5leHQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZShsaXRlcmFsVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdGhpcy5uZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXJyb3IoKSB0aHJvd3MsIHNvIHdlIGRvbid0IHJlYWNoIGhlcmUuXHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRmVsbCB0aHJvdWdoIGFsbCBjYXNlcyBpbiBwYXJzZVByaW1hcnlcIik7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24gKHRlcm1pbmF0b3IpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKCF0aGlzLm5leHQuaXNDaGFyYWN0ZXIodGVybWluYXRvcikpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0UpO1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRDT0xPTik7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRDT01NQSkpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxNYXAoa2V5cywgdmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBpc1NhZmUpIHtcclxuICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMUEFSRU4pKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKTtcclxuICAgICAgICAgICAgdmFyIGZuID0gdGhpcy5yZWZsZWN0b3IubWV0aG9kKGlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBhc3RfMS5TYWZlTWV0aG9kQ2FsbChyZWNlaXZlciwgaWQsIGZuLCBhcmdzKSA6XHJcbiAgICAgICAgICAgICAgICBuZXcgYXN0XzEuTWV0aG9kQ2FsbChyZWNlaXZlciwgaWQsIGZuLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc1NhZmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoXCI9XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlRoZSAnPy4nIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5TYWZlUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBpZCwgdGhpcy5yZWZsZWN0b3IuZ2V0dGVyKGlkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwiPVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuUHJvcGVydHlXcml0ZShyZWNlaXZlciwgaWQsIHRoaXMucmVmbGVjdG9yLnNldHRlcihpZCksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBpZCwgdGhpcy5yZWZsZWN0b3IuZ2V0dGVyKGlkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcihsZXhlcl8xLiRSUEFSRU4pKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uYWxzID0gW107XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbmFscy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xyXG4gICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpKTtcclxuICAgICAgICByZXR1cm4gcG9zaXRpb25hbHM7XHJcbiAgICB9O1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25PckJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExCUkFDRSkpIHtcclxuICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5wYXJzZUJsb2NrQ29udGVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgfTtcclxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VCbG9ja0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcclxuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiAhdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGxleGVyXzEuJFJCUkFDRSkpIHtcclxuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XHJcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuRW1wdHlFeHByKCk7XHJcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5DaGFpbihleHBycyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluYmV0d2Vlbi5cclxuICAgICAqL1xyXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHZhciBvcGVyYXRvckZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcclxuICAgICAgICAgICAgb3BlcmF0b3JGb3VuZCA9IHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpO1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcclxuICAgICAgICB2YXIgcHJlZml4ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIga2V5SXNWYXIgPSB0aGlzLm9wdGlvbmFsS2V5d29yZFZhcigpO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcclxuICAgICAgICAgICAgaWYgKCFrZXlJc1Zhcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJlZml4ICsgJy0nICsga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09MT04pO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGtleUlzVmFyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwiPVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdcXCRpbXBsaWNpdCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0ICE9PSBsZXhlcl8xLkVPRiAmJiAhdGhpcy5wZWVrS2V5d29yZFZhcigpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5wYXJzZVBpcGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbnB1dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgdGhpcy5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmluZGluZ3MucHVzaChuZXcgYXN0XzEuVGVtcGxhdGVCaW5kaW5nKGtleSwga2V5SXNWYXIsIG5hbWUsIGV4cHJlc3Npb24pKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJFNFTUlDT0xPTikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaW5kaW5ncztcclxuICAgIH07XHJcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGluZGV4KSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBcImF0IGNvbHVtbiBcIiArICh0aGlzLnRva2Vuc1tpbmRleF0uaW5kZXggKyAxKSArIFwiIGluXCIgOlxyXG4gICAgICAgICAgICBcImF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb25cIjtcclxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24obWVzc2FnZSwgdGhpcy5pbnB1dCwgbG9jYXRpb24sIHRoaXMubG9jYXRpb24pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfUGFyc2VBU1Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuX1BhcnNlQVNUID0gX1BhcnNlQVNUO1xyXG52YXIgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XHJcbiAgICAgICAgdGhpcy5zaW1wbGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2sgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHMgPSBuZXcgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKTtcclxuICAgICAgICBhc3QudmlzaXQocyk7XHJcbiAgICAgICAgcmV0dXJuIHMuc2ltcGxlO1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0KSB7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QpIHsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XHJcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUoYXN0cy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXNbaV0gPSBhc3RzW2ldLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xyXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SWYgPSBmdW5jdGlvbiAoYXN0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XHJcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gaW1wbGVtZW50c09uRGVzdHJveShwaXBlKSB7XHJcbiAgICByZXR1cm4gcGlwZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUub25EZXN0cm95O1xyXG59XHJcbmV4cG9ydHMuaW1wbGVtZW50c09uRGVzdHJveSA9IGltcGxlbWVudHNPbkRlc3Ryb3k7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGVfbGlmZWN5Y2xlX3JlZmxlY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIFNlbGVjdGVkUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3RlZFBpcGUocGlwZSwgcHVyZSkge1xyXG4gICAgICAgIHRoaXMucGlwZSA9IHBpcGU7XHJcbiAgICAgICAgdGhpcy5wdXJlID0gcHVyZTtcclxuICAgIH1cclxuICAgIHJldHVybiBTZWxlY3RlZFBpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZWN0ZWRQaXBlID0gU2VsZWN0ZWRQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGFzdF8xID0gcmVxdWlyZSgnLi9wYXJzZXIvYXN0Jyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RldGVjdGlvbl91dGlsJyk7XHJcbnZhciBkeW5hbWljX2NoYW5nZV9kZXRlY3Rvcl8xID0gcmVxdWlyZSgnLi9keW5hbWljX2NoYW5nZV9kZXRlY3RvcicpO1xyXG52YXIgZGlyZWN0aXZlX3JlY29yZF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfcmVjb3JkJyk7XHJcbnZhciBldmVudF9iaW5kaW5nXzEgPSByZXF1aXJlKCcuL2V2ZW50X2JpbmRpbmcnKTtcclxudmFyIGNvYWxlc2NlXzEgPSByZXF1aXJlKCcuL2NvYWxlc2NlJyk7XHJcbnZhciBwcm90b19yZWNvcmRfMSA9IHJlcXVpcmUoJy4vcHJvdG9fcmVjb3JkJyk7XHJcbnZhciBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvcihfZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBfZGVmaW5pdGlvbjtcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdSZWNvcmRzID0gY3JlYXRlUHJvcGVydHlSZWNvcmRzKF9kZWZpbml0aW9uKTtcclxuICAgICAgICB0aGlzLl9ldmVudEJpbmRpbmdSZWNvcmRzID0gY3JlYXRlRXZlbnRSZWNvcmRzKF9kZWZpbml0aW9uKTtcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdUYXJnZXRzID0gdGhpcy5fZGVmaW5pdGlvbi5iaW5kaW5nUmVjb3Jkcy5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIudGFyZ2V0OyB9KTtcclxuICAgICAgICB0aGlzLl9kaXJlY3RpdmVJbmRpY2VzID0gdGhpcy5fZGVmaW5pdGlvbi5kaXJlY3RpdmVSZWNvcmRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kaXJlY3RpdmVJbmRleDsgfSk7XHJcbiAgICB9XHJcbiAgICBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3Rvci5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgZHluYW1pY19jaGFuZ2VfZGV0ZWN0b3JfMS5EeW5hbWljQ2hhbmdlRGV0ZWN0b3IodGhpcy5fZGVmaW5pdGlvbi5pZCwgZGlzcGF0Y2hlciwgdGhpcy5fcHJvcGVydHlCaW5kaW5nUmVjb3Jkcy5sZW5ndGgsIHRoaXMuX3Byb3BlcnR5QmluZGluZ1RhcmdldHMsIHRoaXMuX2RpcmVjdGl2ZUluZGljZXMsIHRoaXMuX2RlZmluaXRpb24uc3RyYXRlZ3ksIHRoaXMuX3Byb3BlcnR5QmluZGluZ1JlY29yZHMsIHRoaXMuX2V2ZW50QmluZGluZ1JlY29yZHMsIHRoaXMuX2RlZmluaXRpb24uZGlyZWN0aXZlUmVjb3JkcywgdGhpcy5fZGVmaW5pdGlvbi5nZW5Db25maWcpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvcjtcclxufSkoKTtcclxuZXhwb3J0cy5EeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvciA9IER5bmFtaWNQcm90b0NoYW5nZURldGVjdG9yO1xyXG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eVJlY29yZHMoZGVmaW5pdGlvbikge1xyXG4gICAgdmFyIHJlY29yZEJ1aWxkZXIgPSBuZXcgUHJvdG9SZWNvcmRCdWlsZGVyKCk7XHJcbiAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleChkZWZpbml0aW9uLmJpbmRpbmdSZWNvcmRzLCBmdW5jdGlvbiAoYiwgaW5kZXgpIHsgcmV0dXJuIHJlY29yZEJ1aWxkZXIuYWRkKGIsIGRlZmluaXRpb24udmFyaWFibGVOYW1lcywgaW5kZXgpOyB9KTtcclxuICAgIHJldHVybiBjb2FsZXNjZV8xLmNvYWxlc2NlKHJlY29yZEJ1aWxkZXIucmVjb3Jkcyk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVQcm9wZXJ0eVJlY29yZHMgPSBjcmVhdGVQcm9wZXJ0eVJlY29yZHM7XHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50UmVjb3JkcyhkZWZpbml0aW9uKSB7XHJcbiAgICAvLyBUT0RPOiB2c2F2a2luOiByZW1vdmUgJGV2ZW50IHdoZW4gdGhlIGNvbXBpbGVyIGhhbmRsZXMgcmVuZGVyLXNpZGUgdmFyaWFibGVzIHByb3Blcmx5XHJcbiAgICB2YXIgdmFyTmFtZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29uY2F0KFsnJGV2ZW50J10sIGRlZmluaXRpb24udmFyaWFibGVOYW1lcyk7XHJcbiAgICByZXR1cm4gZGVmaW5pdGlvbi5ldmVudFJlY29yZHMubWFwKGZ1bmN0aW9uIChlcikge1xyXG4gICAgICAgIHZhciByZWNvcmRzID0gX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLmNyZWF0ZShlciwgdmFyTmFtZXMpO1xyXG4gICAgICAgIHZhciBkaXJJbmRleCA9IGVyLmltcGxpY2l0UmVjZWl2ZXIgaW5zdGFuY2VvZiBkaXJlY3RpdmVfcmVjb3JkXzEuRGlyZWN0aXZlSW5kZXggPyBlci5pbXBsaWNpdFJlY2VpdmVyIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IGV2ZW50X2JpbmRpbmdfMS5FdmVudEJpbmRpbmcoZXIudGFyZ2V0Lm5hbWUsIGVyLnRhcmdldC5lbGVtZW50SW5kZXgsIGRpckluZGV4LCByZWNvcmRzKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlRXZlbnRSZWNvcmRzID0gY3JlYXRlRXZlbnRSZWNvcmRzO1xyXG52YXIgUHJvdG9SZWNvcmRCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvUmVjb3JkQnVpbGRlcigpIHtcclxuICAgICAgICB0aGlzLnJlY29yZHMgPSBbXTtcclxuICAgIH1cclxuICAgIFByb3RvUmVjb3JkQnVpbGRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCkge1xyXG4gICAgICAgIHZhciBvbGRMYXN0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmxhc3QodGhpcy5yZWNvcmRzKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvbGRMYXN0KSAmJiBvbGRMYXN0LmJpbmRpbmdSZWNvcmQuZGlyZWN0aXZlUmVjb3JkID09IGIuZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgICAgIG9sZExhc3QubGFzdEluRGlyZWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBudW1iZXJPZlJlY29yZHNCZWZvcmUgPSB0aGlzLnJlY29yZHMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZFJlY29yZHMoYiwgdmFyaWFibGVOYW1lcywgYmluZGluZ0luZGV4KTtcclxuICAgICAgICB2YXIgbmV3TGFzdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5sYXN0KHRoaXMucmVjb3Jkcyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobmV3TGFzdCkgJiYgbmV3TGFzdCAhPT0gb2xkTGFzdCkge1xyXG4gICAgICAgICAgICBuZXdMYXN0Lmxhc3RJbkJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXdMYXN0Lmxhc3RJbkRpcmVjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEFyZ3VtZW50VG9QdXJlRnVuY3Rpb24obnVtYmVyT2ZSZWNvcmRzQmVmb3JlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUHJvdG9SZWNvcmRCdWlsZGVyLnByb3RvdHlwZS5fc2V0QXJndW1lbnRUb1B1cmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRoaXMucmVjb3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcmVjID0gdGhpcy5yZWNvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocmVjLmlzUHVyZUZ1bmN0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlYy5hcmdzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZEluZGV4KSB7IHJldHVybiBfdGhpcy5yZWNvcmRzW3JlY29yZEluZGV4IC0gMV0uYXJndW1lbnRUb1B1cmVGdW5jdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlYy5tb2RlID09PSBwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlBpcGUpIHtcclxuICAgICAgICAgICAgICAgIHJlYy5hcmdzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZEluZGV4KSB7IHJldHVybiBfdGhpcy5yZWNvcmRzW3JlY29yZEluZGV4IC0gMV0uYXJndW1lbnRUb1B1cmVGdW5jdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZHNbcmVjLmNvbnRleHRJbmRleCAtIDFdLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFByb3RvUmVjb3JkQnVpbGRlci5wcm90b3R5cGUuX2FwcGVuZFJlY29yZHMgPSBmdW5jdGlvbiAoYiwgdmFyaWFibGVOYW1lcywgYmluZGluZ0luZGV4KSB7XHJcbiAgICAgICAgaWYgKGIuaXNEaXJlY3RpdmVMaWZlY3ljbGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZHMucHVzaChuZXcgcHJvdG9fcmVjb3JkXzEuUHJvdG9SZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5EaXJlY3RpdmVMaWZlY3ljbGUsIGIubGlmZWN5Y2xlRXZlbnQsIG51bGwsIFtdLCBbXSwgLTEsIG51bGwsIHRoaXMucmVjb3Jkcy5sZW5ndGggKyAxLCBiLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLmFwcGVuZCh0aGlzLnJlY29yZHMsIGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm90b1JlY29yZEJ1aWxkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9SZWNvcmRCdWlsZGVyID0gUHJvdG9SZWNvcmRCdWlsZGVyO1xyXG52YXIgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3JkcyhfcmVjb3JkcywgX2JpbmRpbmdSZWNvcmQsIF92YXJpYWJsZU5hbWVzLCBfYmluZGluZ0luZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fcmVjb3JkcyA9IF9yZWNvcmRzO1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdSZWNvcmQgPSBfYmluZGluZ1JlY29yZDtcclxuICAgICAgICB0aGlzLl92YXJpYWJsZU5hbWVzID0gX3ZhcmlhYmxlTmFtZXM7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ0luZGV4ID0gX2JpbmRpbmdJbmRleDtcclxuICAgIH1cclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5hcHBlbmQgPSBmdW5jdGlvbiAocmVjb3JkcywgYiwgdmFyaWFibGVOYW1lcywgYmluZGluZ0luZGV4KSB7XHJcbiAgICAgICAgdmFyIGMgPSBuZXcgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzKHJlY29yZHMsIGIsIHZhcmlhYmxlTmFtZXMsIGJpbmRpbmdJbmRleCk7XHJcbiAgICAgICAgYi5hc3QudmlzaXQoYyk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChiLCB2YXJpYWJsZU5hbWVzKSB7XHJcbiAgICAgICAgdmFyIHJlYyA9IFtdO1xyXG4gICAgICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5hcHBlbmQocmVjLCBiLCB2YXJpYWJsZU5hbWVzLCBudWxsKTtcclxuICAgICAgICByZWNbcmVjLmxlbmd0aCAtIDFdLmxhc3RJbkJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiByZWM7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0aGlzLl9iaW5kaW5nUmVjb3JkLmltcGxpY2l0UmVjZWl2ZXI7IH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3Zpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludGVycG9sYXRlLCBcImludGVycG9sYXRlXCIsIF9pbnRlcnBvbGF0aW9uRm4oYXN0LnN0cmluZ3MpLCBhcmdzLCBhc3Quc3RyaW5ncywgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbnN0LCBcImxpdGVyYWxcIiwgYXN0LnZhbHVlLCBbXSwgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fdmFyaWFibGVOYW1lcykgJiYgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKHRoaXMuX3ZhcmlhYmxlTmFtZXMsIGFzdC5uYW1lKSAmJlxyXG4gICAgICAgICAgICBhc3QucmVjZWl2ZXIgaW5zdGFuY2VvZiBhc3RfMS5JbXBsaWNpdFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Mb2NhbCwgYXN0Lm5hbWUsIGFzdC5uYW1lLCBbXSwgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByb3BlcnR5UmVhZCwgYXN0Lm5hbWUsIGFzdC5nZXR0ZXIsIFtdLCBudWxsLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3ZhcmlhYmxlTmFtZXMpICYmIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyh0aGlzLl92YXJpYWJsZU5hbWVzLCBhc3QubmFtZSkgJiZcclxuICAgICAgICAgICAgYXN0LnJlY2VpdmVyIGluc3RhbmNlb2YgYXN0XzEuSW1wbGljaXRSZWNlaXZlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgcmVhc3NpZ24gYSB2YXJpYWJsZSBiaW5kaW5nIFwiICsgYXN0Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWUudmlzaXQodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5Qcm9wZXJ0eVdyaXRlLCBhc3QubmFtZSwgYXN0LnNldHRlciwgW3ZhbHVlXSwgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgb2JqID0gYXN0Lm9iai52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWUudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkV3JpdGUsIG51bGwsIG51bGwsIFtrZXksIHZhbHVlXSwgbnVsbCwgb2JqKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlNhZmVQcm9wZXJ0eSwgYXN0Lm5hbWUsIGFzdC5nZXR0ZXIsIFtdLCBudWxsLCByZWNlaXZlcik7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5fdmlzaXRBbGwoYXN0LmFyZ3MpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3ZhcmlhYmxlTmFtZXMpICYmIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyh0aGlzLl92YXJpYWJsZU5hbWVzLCBhc3QubmFtZSkpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkxvY2FsLCBhc3QubmFtZSwgYXN0Lm5hbWUsIFtdLCBudWxsLCByZWNlaXZlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnZva2VDbG9zdXJlLCBcImNsb3N1cmVcIiwgbnVsbCwgYXJncywgbnVsbCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZWNvcmQocHJvdG9fcmVjb3JkXzEuUmVjb3JkVHlwZS5JbnZva2VNZXRob2QsIGFzdC5uYW1lLCBhc3QuZm4sIGFyZ3MsIG51bGwsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcclxuICAgICAgICB2YXIgYXJncyA9IHRoaXMuX3Zpc2l0QWxsKGFzdC5hcmdzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuU2FmZU1ldGhvZEludm9rZSwgYXN0Lm5hbWUsIGFzdC5mbiwgYXJncywgbnVsbCwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGFzdC50YXJnZXQudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl92aXNpdEFsbChhc3QuYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkludm9rZUNsb3N1cmUsIFwiY2xvc3VyZVwiLCBudWxsLCBhcmdzLCBudWxsLCB0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIHByaW1pdGl2ZU5hbWUgPSBcImFycmF5Rm5cIiArIGFzdC5leHByZXNzaW9ucy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbGxlY3Rpb25MaXRlcmFsLCBwcmltaXRpdmVOYW1lLCBfYXJyYXlGbihhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKSwgdGhpcy5fdmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSwgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLkNvbGxlY3Rpb25MaXRlcmFsLCBfbWFwUHJpbWl0aXZlTmFtZShhc3Qua2V5cyksIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwubWFwRm4oYXN0LmtleXMpLCB0aGlzLl92aXNpdEFsbChhc3QudmFsdWVzKSwgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgbGVmdCA9IGFzdC5sZWZ0LnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciByaWdodCA9IGFzdC5yaWdodC52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJpbWl0aXZlT3AsIF9vcGVyYXRpb25Ub1ByaW1pdGl2ZU5hbWUoYXN0Lm9wZXJhdGlvbiksIF9vcGVyYXRpb25Ub0Z1bmN0aW9uKGFzdC5vcGVyYXRpb24pLCBbbGVmdCwgcmlnaHRdLCBudWxsLCAwKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBleHAgPSBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuUHJpbWl0aXZlT3AsIFwib3BlcmF0aW9uX25lZ2F0ZVwiLCBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9uZWdhdGUsIFtleHBdLCBudWxsLCAwKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpO1xyXG4gICAgICAgIHZhciB0ID0gYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGYgPSBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlByaW1pdGl2ZU9wLCBcImNvbmRcIiwgY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5jb25kLCBbYywgdCwgZl0sIG51bGwsIDApO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGFzdC5leHAudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl92aXNpdEFsbChhc3QuYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLlBpcGUsIGFzdC5uYW1lLCBhc3QubmFtZSwgYXJncywgbnVsbCwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGFzdC5vYmoudmlzaXQodGhpcyk7XHJcbiAgICAgICAgdmFyIGtleSA9IGFzdC5rZXkudmlzaXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlY29yZChwcm90b19yZWNvcmRfMS5SZWNvcmRUeXBlLktleWVkUmVhZCwgXCJrZXllZEFjY2Vzc1wiLCBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmtleWVkQWNjZXNzLCBba2V5XSwgbnVsbCwgb2JqKTtcclxuICAgIH07XHJcbiAgICBfQ29udmVydEFzdEludG9Qcm90b1JlY29yZHMucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYXJncyA9IGFzdC5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudmlzaXQoX3RoaXMpOyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVjb3JkKHByb3RvX3JlY29yZF8xLlJlY29yZFR5cGUuQ2hhaW4sIFwiY2hhaW5cIiwgbnVsbCwgYXJncywgbnVsbCwgMCk7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS52aXNpdElmID0gZnVuY3Rpb24gKGFzdCkgeyB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ05vdCBzdXBwb3J0ZWQnKTsgfTtcclxuICAgIF9Db252ZXJ0QXN0SW50b1Byb3RvUmVjb3Jkcy5wcm90b3R5cGUuX3Zpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcclxuICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShhc3RzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzLnByb3RvdHlwZS5fYWRkUmVjb3JkID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGZ1bmNPclZhbHVlLCBhcmdzLCBmaXhlZEFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc2VsZkluZGV4ID0gdGhpcy5fcmVjb3Jkcy5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgZGlyZWN0aXZlX3JlY29yZF8xLkRpcmVjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZHMucHVzaChuZXcgcHJvdG9fcmVjb3JkXzEuUHJvdG9SZWNvcmQodHlwZSwgbmFtZSwgZnVuY09yVmFsdWUsIGFyZ3MsIGZpeGVkQXJncywgLTEsIGNvbnRleHQsIHNlbGZJbmRleCwgdGhpcy5fYmluZGluZ1JlY29yZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRoaXMuX2JpbmRpbmdJbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVjb3Jkcy5wdXNoKG5ldyBwcm90b19yZWNvcmRfMS5Qcm90b1JlY29yZCh0eXBlLCBuYW1lLCBmdW5jT3JWYWx1ZSwgYXJncywgZml4ZWRBcmdzLCBjb250ZXh0LCBudWxsLCBzZWxmSW5kZXgsIHRoaXMuX2JpbmRpbmdSZWNvcmQsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0aGlzLl9iaW5kaW5nSW5kZXgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGZJbmRleDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX0NvbnZlcnRBc3RJbnRvUHJvdG9SZWNvcmRzO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBfYXJyYXlGbihsZW5ndGgpIHtcclxuICAgIHN3aXRjaCAobGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMDtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm4xO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjI7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuMztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm40O1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjU7XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuNjtcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLmFycmF5Rm43O1xyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwuYXJyYXlGbjg7XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5hcnJheUZuOTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJEb2VzIG5vdCBzdXBwb3J0IGxpdGVyYWwgbWFwcyB3aXRoIG1vcmUgdGhhbiA5IGVsZW1lbnRzXCIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9tYXBQcmltaXRpdmVOYW1lKGtleXMpIHtcclxuICAgIHZhciBzdHJpbmdpZmllZEtleXMgPSBrZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbGFuZ18xLmlzU3RyaW5nKGspID8gXCJcXFwiXCIgKyBrICsgXCJcXFwiXCIgOiBcIlwiICsgazsgfSkuam9pbignLCAnKTtcclxuICAgIHJldHVybiBcIm1hcEZuKFtcIiArIHN0cmluZ2lmaWVkS2V5cyArIFwiXSlcIjtcclxufVxyXG5mdW5jdGlvbiBfb3BlcmF0aW9uVG9QcmltaXRpdmVOYW1lKG9wZXJhdGlvbikge1xyXG4gICAgc3dpdGNoIChvcGVyYXRpb24pIHtcclxuICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2FkZFwiO1xyXG4gICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25fc3VidHJhY3RcIjtcclxuICAgICAgICBjYXNlICcqJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX211bHRpcGx5XCI7XHJcbiAgICAgICAgY2FzZSAnLyc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9kaXZpZGVcIjtcclxuICAgICAgICBjYXNlICclJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX3JlbWFpbmRlclwiO1xyXG4gICAgICAgIGNhc2UgJz09JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2VxdWFsc1wiO1xyXG4gICAgICAgIGNhc2UgJyE9JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX25vdF9lcXVhbHNcIjtcclxuICAgICAgICBjYXNlICc9PT0nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25faWRlbnRpY2FsXCI7XHJcbiAgICAgICAgY2FzZSAnIT09JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX25vdF9pZGVudGljYWxcIjtcclxuICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2xlc3NfdGhlblwiO1xyXG4gICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25fZ3JlYXRlcl90aGVuXCI7XHJcbiAgICAgICAgY2FzZSAnPD0nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRpb25fbGVzc19vcl9lcXVhbHNfdGhlblwiO1xyXG4gICAgICAgIGNhc2UgJz49JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2dyZWF0ZXJfb3JfZXF1YWxzX3RoZW5cIjtcclxuICAgICAgICBjYXNlICcmJic6XHJcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdGlvbl9sb2dpY2FsX2FuZFwiO1xyXG4gICAgICAgIGNhc2UgJ3x8JzpcclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0aW9uX2xvZ2ljYWxfb3JcIjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBvcGVyYXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9vcGVyYXRpb25Ub0Z1bmN0aW9uKG9wZXJhdGlvbikge1xyXG4gICAgc3dpdGNoIChvcGVyYXRpb24pIHtcclxuICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2FkZDtcclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX3N1YnRyYWN0O1xyXG4gICAgICAgIGNhc2UgJyonOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbXVsdGlwbHk7XHJcbiAgICAgICAgY2FzZSAnLyc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9kaXZpZGU7XHJcbiAgICAgICAgY2FzZSAnJSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9yZW1haW5kZXI7XHJcbiAgICAgICAgY2FzZSAnPT0nOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fZXF1YWxzO1xyXG4gICAgICAgIGNhc2UgJyE9JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX25vdF9lcXVhbHM7XHJcbiAgICAgICAgY2FzZSAnPT09JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2lkZW50aWNhbDtcclxuICAgICAgICBjYXNlICchPT0nOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbm90X2lkZW50aWNhbDtcclxuICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2xlc3NfdGhlbjtcclxuICAgICAgICBjYXNlICc+JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2dyZWF0ZXJfdGhlbjtcclxuICAgICAgICBjYXNlICc8PSc6XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5DaGFuZ2VEZXRlY3Rpb25VdGlsLm9wZXJhdGlvbl9sZXNzX29yX2VxdWFsc190aGVuO1xyXG4gICAgICAgIGNhc2UgJz49JzpcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLkNoYW5nZURldGVjdGlvblV0aWwub3BlcmF0aW9uX2dyZWF0ZXJfb3JfZXF1YWxzX3RoZW47XHJcbiAgICAgICAgY2FzZSAnJiYnOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbG9naWNhbF9hbmQ7XHJcbiAgICAgICAgY2FzZSAnfHwnOlxyXG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuQ2hhbmdlRGV0ZWN0aW9uVXRpbC5vcGVyYXRpb25fbG9naWNhbF9vcjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBvcGVyYXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHModikge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodikgPyBcIlwiICsgdiA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIF9pbnRlcnBvbGF0aW9uRm4oc3RyaW5ncykge1xyXG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xyXG4gICAgdmFyIGMwID0gbGVuZ3RoID4gMCA/IHN0cmluZ3NbMF0gOiBudWxsO1xyXG4gICAgdmFyIGMxID0gbGVuZ3RoID4gMSA/IHN0cmluZ3NbMV0gOiBudWxsO1xyXG4gICAgdmFyIGMyID0gbGVuZ3RoID4gMiA/IHN0cmluZ3NbMl0gOiBudWxsO1xyXG4gICAgdmFyIGMzID0gbGVuZ3RoID4gMyA/IHN0cmluZ3NbM10gOiBudWxsO1xyXG4gICAgdmFyIGM0ID0gbGVuZ3RoID4gNCA/IHN0cmluZ3NbNF0gOiBudWxsO1xyXG4gICAgdmFyIGM1ID0gbGVuZ3RoID4gNSA/IHN0cmluZ3NbNV0gOiBudWxsO1xyXG4gICAgdmFyIGM2ID0gbGVuZ3RoID4gNiA/IHN0cmluZ3NbNl0gOiBudWxsO1xyXG4gICAgdmFyIGM3ID0gbGVuZ3RoID4gNyA/IHN0cmluZ3NbN10gOiBudWxsO1xyXG4gICAgdmFyIGM4ID0gbGVuZ3RoID4gOCA/IHN0cmluZ3NbOF0gOiBudWxsO1xyXG4gICAgdmFyIGM5ID0gbGVuZ3RoID4gOSA/IHN0cmluZ3NbOV0gOiBudWxsO1xyXG4gICAgc3dpdGNoIChsZW5ndGggLSAxKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExKSB7IHJldHVybiBjMCArIHMoYTEpICsgYzE7IH07XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMikgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMjsgfTtcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMykgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMiArIHMoYTMpICsgYzM7IH07XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7IHJldHVybiBjMCArIHMoYTEpICsgYzEgKyBzKGEyKSArIGMyICsgcyhhMykgKyBjMyArIHMoYTQpICsgYzQ7IH07XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgcyhhMSkgKyBjMSArIHMoYTIpICsgYzIgKyBzKGEzKSArIGMzICsgcyhhNCkgKyBjNCArIHMoYTUpICsgYzU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIHMoYTEpICsgYzEgKyBzKGEyKSArIGMyICsgcyhhMykgKyBjMyArIHMoYTQpICsgYzQgKyBzKGE1KSArIGM1ICsgcyhhNikgKyBjNjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHsgcmV0dXJuIGMwICsgcyhhMSkgKyBjMSArIHMoYTIpICsgYzIgKyBzKGEzKSArIGMzICsgcyhhNCkgK1xyXG4gICAgICAgICAgICAgICAgYzQgKyBzKGE1KSArIGM1ICsgcyhhNikgKyBjNiArIHMoYTcpICsgYzc7IH07XHJcbiAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gYzAgKyBzKGExKSArIGMxICsgcyhhMikgKyBjMiArIHMoYTMpICsgYzMgKyBzKGE0KSArXHJcbiAgICAgICAgICAgICAgICBjNCArIHMoYTUpICsgYzUgKyBzKGE2KSArIGM2ICsgcyhhNykgKyBjNyArIHMoYTgpICtcclxuICAgICAgICAgICAgICAgIGM4OyB9O1xyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7IHJldHVybiBjMCArIHMoYTEpICsgYzEgKyBzKGEyKSArIGMyICsgcyhhMykgKyBjMyArXHJcbiAgICAgICAgICAgICAgICBzKGE0KSArIGM0ICsgcyhhNSkgKyBjNSArIHMoYTYpICsgYzYgKyBzKGE3KSArXHJcbiAgICAgICAgICAgICAgICBjNyArIHMoYTgpICsgYzggKyBzKGE5KSArIGM5OyB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkRvZXMgbm90IHN1cHBvcnQgbW9yZSB0aGFuIDkgZXhwcmVzc2lvbnNcIik7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdG9fY2hhbmdlX2RldGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsoZnVuY3Rpb24gKFJlY29yZFR5cGUpIHtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIlNlbGZcIl0gPSAwXSA9IFwiU2VsZlwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiQ29uc3RcIl0gPSAxXSA9IFwiQ29uc3RcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIlByaW1pdGl2ZU9wXCJdID0gMl0gPSBcIlByaW1pdGl2ZU9wXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJQcm9wZXJ0eVJlYWRcIl0gPSAzXSA9IFwiUHJvcGVydHlSZWFkXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJQcm9wZXJ0eVdyaXRlXCJdID0gNF0gPSBcIlByb3BlcnR5V3JpdGVcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIkxvY2FsXCJdID0gNV0gPSBcIkxvY2FsXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJJbnZva2VNZXRob2RcIl0gPSA2XSA9IFwiSW52b2tlTWV0aG9kXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJJbnZva2VDbG9zdXJlXCJdID0gN10gPSBcIkludm9rZUNsb3N1cmVcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIktleWVkUmVhZFwiXSA9IDhdID0gXCJLZXllZFJlYWRcIjtcclxuICAgIFJlY29yZFR5cGVbUmVjb3JkVHlwZVtcIktleWVkV3JpdGVcIl0gPSA5XSA9IFwiS2V5ZWRXcml0ZVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiUGlwZVwiXSA9IDEwXSA9IFwiUGlwZVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiSW50ZXJwb2xhdGVcIl0gPSAxMV0gPSBcIkludGVycG9sYXRlXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJTYWZlUHJvcGVydHlcIl0gPSAxMl0gPSBcIlNhZmVQcm9wZXJ0eVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiQ29sbGVjdGlvbkxpdGVyYWxcIl0gPSAxM10gPSBcIkNvbGxlY3Rpb25MaXRlcmFsXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJTYWZlTWV0aG9kSW52b2tlXCJdID0gMTRdID0gXCJTYWZlTWV0aG9kSW52b2tlXCI7XHJcbiAgICBSZWNvcmRUeXBlW1JlY29yZFR5cGVbXCJEaXJlY3RpdmVMaWZlY3ljbGVcIl0gPSAxNV0gPSBcIkRpcmVjdGl2ZUxpZmVjeWNsZVwiO1xyXG4gICAgUmVjb3JkVHlwZVtSZWNvcmRUeXBlW1wiQ2hhaW5cIl0gPSAxNl0gPSBcIkNoYWluXCI7XHJcbn0pKGV4cG9ydHMuUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5SZWNvcmRUeXBlID0ge30pKTtcclxudmFyIFJlY29yZFR5cGUgPSBleHBvcnRzLlJlY29yZFR5cGU7XHJcbnZhciBQcm90b1JlY29yZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b1JlY29yZChtb2RlLCBuYW1lLCBmdW5jT3JWYWx1ZSwgYXJncywgZml4ZWRBcmdzLCBjb250ZXh0SW5kZXgsIGRpcmVjdGl2ZUluZGV4LCBzZWxmSW5kZXgsIGJpbmRpbmdSZWNvcmQsIGxhc3RJbkJpbmRpbmcsIGxhc3RJbkRpcmVjdGl2ZSwgYXJndW1lbnRUb1B1cmVGdW5jdGlvbiwgcmVmZXJlbmNlZEJ5U2VsZiwgcHJvcGVydHlCaW5kaW5nSW5kZXgpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5mdW5jT3JWYWx1ZSA9IGZ1bmNPclZhbHVlO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICAgICAgdGhpcy5maXhlZEFyZ3MgPSBmaXhlZEFyZ3M7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0SW5kZXggPSBjb250ZXh0SW5kZXg7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVJbmRleCA9IGRpcmVjdGl2ZUluZGV4O1xyXG4gICAgICAgIHRoaXMuc2VsZkluZGV4ID0gc2VsZkluZGV4O1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1JlY29yZCA9IGJpbmRpbmdSZWNvcmQ7XHJcbiAgICAgICAgdGhpcy5sYXN0SW5CaW5kaW5nID0gbGFzdEluQmluZGluZztcclxuICAgICAgICB0aGlzLmxhc3RJbkRpcmVjdGl2ZSA9IGxhc3RJbkRpcmVjdGl2ZTtcclxuICAgICAgICB0aGlzLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gPSBhcmd1bWVudFRvUHVyZUZ1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlZEJ5U2VsZiA9IHJlZmVyZW5jZWRCeVNlbGY7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUJpbmRpbmdJbmRleCA9IHByb3BlcnR5QmluZGluZ0luZGV4O1xyXG4gICAgfVxyXG4gICAgUHJvdG9SZWNvcmQucHJvdG90eXBlLmlzUHVyZUZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IFJlY29yZFR5cGUuSW50ZXJwb2xhdGUgfHwgdGhpcy5tb2RlID09PSBSZWNvcmRUeXBlLkNvbGxlY3Rpb25MaXRlcmFsO1xyXG4gICAgfTtcclxuICAgIFByb3RvUmVjb3JkLnByb3RvdHlwZS5pc1VzZWRCeU90aGVyUmVjb3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMubGFzdEluQmluZGluZyB8fCB0aGlzLnJlZmVyZW5jZWRCeVNlbGY7IH07XHJcbiAgICBQcm90b1JlY29yZC5wcm90b3R5cGUuc2hvdWxkQmVDaGVja2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3VtZW50VG9QdXJlRnVuY3Rpb24gfHwgdGhpcy5sYXN0SW5CaW5kaW5nIHx8IHRoaXMuaXNQdXJlRnVuY3Rpb24oKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmlzUGlwZVJlY29yZCgpO1xyXG4gICAgfTtcclxuICAgIFByb3RvUmVjb3JkLnByb3RvdHlwZS5pc1BpcGVSZWNvcmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1vZGUgPT09IFJlY29yZFR5cGUuUGlwZTsgfTtcclxuICAgIFByb3RvUmVjb3JkLnByb3RvdHlwZS5pc0xpZmVDeWNsZVJlY29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PT0gUmVjb3JkVHlwZS5EaXJlY3RpdmVMaWZlY3ljbGU7IH07XHJcbiAgICByZXR1cm4gUHJvdG9SZWNvcmQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9SZWNvcmQgPSBQcm90b1JlY29yZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdG9fcmVjb3JkLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgYXBwX3Jvb3RfdXJsXzEgPSByZXF1aXJlKFwiYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYXBwX3Jvb3RfdXJsXCIpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXJcIik7XHJcbnZhciBkaV8xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2RpXCIpO1xyXG4vKipcclxuICogRXh0ZW5zaW9uIG9mIHtAbGluayBBcHBSb290VXJsfSB0aGF0IHVzZXMgYSBET00gYW5jaG9yIHRhZyB0byBzZXQgdGhlIHJvb3QgdXJsIHRvXHJcbiAqIHRoZSBjdXJyZW50IHBhZ2UncyB1cmwuXHJcbiAqL1xyXG52YXIgQW5jaG9yQmFzZWRBcHBSb290VXJsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBbmNob3JCYXNlZEFwcFJvb3RVcmwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBbmNob3JCYXNlZEFwcFJvb3RVcmwoKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJcIik7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgcm9vdCB1cmwgdG8gcGFzcyB0byBBcHBSb290VXJsXHJcbiAgICAgICAgdmFyIGEgPSBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ucmVzb2x2ZUFuZFNldEhyZWYoYSwgJy4vJywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldEhyZWYoYSk7XHJcbiAgICB9XHJcbiAgICBBbmNob3JCYXNlZEFwcFJvb3RVcmwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEFuY2hvckJhc2VkQXBwUm9vdFVybCk7XHJcbiAgICByZXR1cm4gQW5jaG9yQmFzZWRBcHBSb290VXJsO1xyXG59KShhcHBfcm9vdF91cmxfMS5BcHBSb290VXJsKTtcclxuZXhwb3J0cy5BbmNob3JCYXNlZEFwcFJvb3RVcmwgPSBBbmNob3JCYXNlZEFwcFJvb3RVcmw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuY2hvcl9iYXNlZF9hcHBfcm9vdF91cmwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyBhcHAgcm9vdCB1cmwgZm9yIHRoZSBhcHBsaWNhdGlvbi5cclxuICpcclxuICogVXNlZCBieSB0aGUge0BsaW5rIENvbXBpbGVyfSB3aGVuIHJlc29sdmluZyBIVE1MIGFuZCBDU1MgdGVtcGxhdGUgVVJMcy5cclxuICpcclxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIENvbXBpbGVyfVxyXG4gKi9cclxudmFyIEFwcFJvb3RVcmwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwUm9vdFVybCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIEFwcFJvb3RVcmwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIEFwcFJvb3RVcmwpO1xyXG4gICAgcmV0dXJuIEFwcFJvb3RVcmw7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwUm9vdFVybCA9IEFwcFJvb3RVcmw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcF9yb290X3VybC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9hc3QnKTtcclxudmFyIGludGVyZmFjZXNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9pbnRlcmZhY2VzJyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMoY29tcG9uZW50VHlwZSwgY29tcG9uZW50U3RyYXRlZ3ksIGdlbkNvbmZpZywgcGFyc2VkVGVtcGxhdGUpIHtcclxuICAgIHZhciBwdlZpc2l0b3JzID0gW107XHJcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBQcm90b1ZpZXdWaXNpdG9yKG51bGwsIHB2VmlzaXRvcnMsIGNvbXBvbmVudFN0cmF0ZWd5KTtcclxuICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgcGFyc2VkVGVtcGxhdGUpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNoYW5nZURlZmluaXRpb25zKHB2VmlzaXRvcnMsIGNvbXBvbmVudFR5cGUsIGdlbkNvbmZpZyk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVDaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zID0gY3JlYXRlQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucztcclxudmFyIFByb3RvVmlld1Zpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9WaWV3VmlzaXRvcihwYXJlbnQsIGFsbFZpc2l0b3JzLCBzdHJhdGVneSkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuYWxsVmlzaXRvcnMgPSBhbGxWaXNpdG9ycztcclxuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5ib3VuZFRleHRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gW107XHJcbiAgICAgICAgdGhpcy5iaW5kaW5nUmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVSZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy52aWV3SW5kZXggPSBhbGxWaXNpdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgYWxsVmlzaXRvcnMucHVzaCh0aGlzKTtcclxuICAgIH1cclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudENvdW50Kys7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3QuZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhc3QuZGlyZWN0aXZlc1tpXS52aXNpdCh0aGlzLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoaWxkVmlzaXRvciA9IG5ldyBQcm90b1ZpZXdWaXNpdG9yKHRoaXMsIHRoaXMuYWxsVmlzaXRvcnMsIGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0KTtcclxuICAgICAgICAvLyBBdHRlbnRpb246IHZhcmlhYmxlcyBwcmVzZW50IG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlIGNvdW50IHRvd2FyZHNcclxuICAgICAgICAvLyB0aGUgZW1iZWRkZWQgdGVtcGxhdGUgYW5kIG5vdCB0aGUgdGVtcGxhdGUgYW5jaG9yIVxyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwoY2hpbGRWaXNpdG9yLCBhc3QudmFycyk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbChjaGlsZFZpc2l0b3IsIGFzdC5jaGlsZHJlbik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChhc3QuaXNCb3VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRFbGVtZW50Q291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuaW5wdXRzLCBudWxsKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5vdXRwdXRzKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5leHBvcnRBc1ZhcnMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXN0LmRpcmVjdGl2ZXNbaV0udmlzaXQodGhpcywgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKGFzdC5uYW1lKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmdSZWNvcmQgPSBsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZVJlY29yZCkgP1xyXG4gICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVGb3JIb3N0RXZlbnQoYXN0LmhhbmRsZXIsIGFzdC5mdWxsTmFtZSwgZGlyZWN0aXZlUmVjb3JkKSA6XHJcbiAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckV2ZW50KGFzdC5oYW5kbGVyLCBhc3QuZnVsbE5hbWUsIHRoaXMuYm91bmRFbGVtZW50Q291bnQgLSAxKTtcclxuICAgICAgICB0aGlzLmV2ZW50UmVjb3Jkcy5wdXNoKGJpbmRpbmdSZWNvcmQpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgZGlyZWN0aXZlUmVjb3JkKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gdGhpcy5ib3VuZEVsZW1lbnRDb3VudCAtIDE7XHJcbiAgICAgICAgdmFyIGRpckluZGV4ID0gbGFuZ18xLmlzUHJlc2VudChkaXJlY3RpdmVSZWNvcmQpID8gZGlyZWN0aXZlUmVjb3JkLmRpcmVjdGl2ZUluZGV4IDogbnVsbDtcclxuICAgICAgICB2YXIgYmluZGluZ1JlY29yZDtcclxuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZCA9XHJcbiAgICAgICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KGRpckluZGV4KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdFByb3BlcnR5KGRpckluZGV4LCBhc3QudmFsdWUsIGFzdC5uYW1lKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudFByb3BlcnR5KGFzdC52YWx1ZSwgYm91bmRFbGVtZW50SW5kZXgsIGFzdC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXN0LnR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmQgPVxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChkaXJJbmRleCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckhvc3RBdHRyaWJ1dGUoZGlySW5kZXgsIGFzdC52YWx1ZSwgYXN0Lm5hbWUpIDpcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVGb3JFbGVtZW50QXR0cmlidXRlKGFzdC52YWx1ZSwgYm91bmRFbGVtZW50SW5kZXgsIGFzdC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXN0LnR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3MpIHtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZCA9XHJcbiAgICAgICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KGRpckluZGV4KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdENsYXNzKGRpckluZGV4LCBhc3QudmFsdWUsIGFzdC5uYW1lKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRWxlbWVudENsYXNzKGFzdC52YWx1ZSwgYm91bmRFbGVtZW50SW5kZXgsIGFzdC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXN0LnR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGUpIHtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZCA9XHJcbiAgICAgICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KGRpckluZGV4KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9ySG9zdFN0eWxlKGRpckluZGV4LCBhc3QudmFsdWUsIGFzdC5uYW1lLCBhc3QudW5pdCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMS5CaW5kaW5nUmVjb3JkLmNyZWF0ZUZvckVsZW1lbnRTdHlsZShhc3QudmFsdWUsIGJvdW5kRWxlbWVudEluZGV4LCBhc3QubmFtZSwgYXN0LnVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJpbmRpbmdSZWNvcmRzLnB1c2goYmluZGluZ1JlY29yZCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBib3VuZFRleHRJbmRleCA9IHRoaXMuYm91bmRUZXh0Q291bnQrKztcclxuICAgICAgICB0aGlzLmJpbmRpbmdSZWNvcmRzLnB1c2goY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yVGV4dE5vZGUoYXN0LnZhbHVlLCBib3VuZFRleHRJbmRleCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBQcm90b1ZpZXdWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGRpcmVjdGl2ZUluZGV4QXNOdW1iZXIpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlSW5kZXggPSBuZXcgY2hhbmdlX2RldGVjdGlvbl8xLkRpcmVjdGl2ZUluZGV4KHRoaXMuYm91bmRFbGVtZW50Q291bnQgLSAxLCBkaXJlY3RpdmVJbmRleEFzTnVtYmVyKTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlTWV0YWRhdGEgPSBhc3QuZGlyZWN0aXZlO1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmVSZWNvcmQgPSBuZXcgY2hhbmdlX2RldGVjdGlvbl8xLkRpcmVjdGl2ZVJlY29yZCh7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZUluZGV4OiBkaXJlY3RpdmVJbmRleCxcclxuICAgICAgICAgICAgY2FsbEFmdGVyQ29udGVudEluaXQ6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQpICE9PSAtMSxcclxuICAgICAgICAgICAgY2FsbEFmdGVyQ29udGVudENoZWNrZWQ6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQpICE9PSAtMSxcclxuICAgICAgICAgICAgY2FsbEFmdGVyVmlld0luaXQ6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQpICE9PSAtMSxcclxuICAgICAgICAgICAgY2FsbEFmdGVyVmlld0NoZWNrZWQ6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQpICE9PSAtMSxcclxuICAgICAgICAgICAgY2FsbE9uQ2hhbmdlczogZGlyZWN0aXZlTWV0YWRhdGEubGlmZWN5Y2xlSG9va3MuaW5kZXhPZihpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzKSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxEb0NoZWNrOiBkaXJlY3RpdmVNZXRhZGF0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5Eb0NoZWNrKSAhPT0gLTEsXHJcbiAgICAgICAgICAgIGNhbGxPbkluaXQ6IGRpcmVjdGl2ZU1ldGFkYXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uSW5pdCkgIT09IC0xLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGRpcmVjdGl2ZU1ldGFkYXRhLmNoYW5nZURldGVjdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlUmVjb3Jkcy5wdXNoKGRpcmVjdGl2ZVJlY29yZCk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuaW5wdXRzLCBkaXJlY3RpdmVSZWNvcmQpO1xyXG4gICAgICAgIHZhciBiaW5kaW5nUmVjb3JkcyA9IHRoaXMuYmluZGluZ1JlY29yZHM7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVJlY29yZC5jYWxsT25DaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdSZWNvcmRzLnB1c2goY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRGlyZWN0aXZlT25DaGFuZ2VzKGRpcmVjdGl2ZVJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aXZlUmVjb3JkLmNhbGxPbkluaXQpIHtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZHMucHVzaChjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVEaXJlY3RpdmVPbkluaXQoZGlyZWN0aXZlUmVjb3JkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVSZWNvcmQuY2FsbERvQ2hlY2spIHtcclxuICAgICAgICAgICAgYmluZGluZ1JlY29yZHMucHVzaChjaGFuZ2VfZGV0ZWN0aW9uXzEuQmluZGluZ1JlY29yZC5jcmVhdGVEaXJlY3RpdmVEb0NoZWNrKGRpcmVjdGl2ZVJlY29yZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5ob3N0UHJvcGVydGllcywgZGlyZWN0aXZlUmVjb3JkKTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5ob3N0RXZlbnRzLCBkaXJlY3RpdmVSZWNvcmQpO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmV4cG9ydEFzVmFycyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3VmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGRpcmVjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIC8vIFRPRE86IHRoZXNlIHNldHRlcnMgc2hvdWxkIGV2ZW50dWFsbHkgYmUgY3JlYXRlZCBieSBjaGFuZ2UgZGV0ZWN0aW9uLCB0byBtYWtlXHJcbiAgICAgICAgLy8gaXQgbW9ub21vcnBoaWMhXHJcbiAgICAgICAgdmFyIHNldHRlciA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3Iuc2V0dGVyKGFzdC5kaXJlY3RpdmVOYW1lKTtcclxuICAgICAgICB0aGlzLmJpbmRpbmdSZWNvcmRzLnB1c2goY2hhbmdlX2RldGVjdGlvbl8xLkJpbmRpbmdSZWNvcmQuY3JlYXRlRm9yRGlyZWN0aXZlKGFzdC52YWx1ZSwgYXN0LmRpcmVjdGl2ZU5hbWUsIHNldHRlciwgZGlyZWN0aXZlUmVjb3JkKSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb3RvVmlld1Zpc2l0b3I7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNoYW5nZURlZmluaXRpb25zKHB2VmlzaXRvcnMsIGNvbXBvbmVudFR5cGUsIGdlbkNvbmZpZykge1xyXG4gICAgdmFyIHB2VmFyaWFibGVOYW1lcyA9IF9jb2xsZWN0TmVzdGVkUHJvdG9WaWV3c1ZhcmlhYmxlTmFtZXMocHZWaXNpdG9ycyk7XHJcbiAgICByZXR1cm4gcHZWaXNpdG9ycy5tYXAoZnVuY3Rpb24gKHB2VmlzaXRvcikge1xyXG4gICAgICAgIHZhciBpZCA9IGNvbXBvbmVudFR5cGUubmFtZSArIFwiX1wiICsgcHZWaXNpdG9yLnZpZXdJbmRleDtcclxuICAgICAgICByZXR1cm4gbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvckRlZmluaXRpb24oaWQsIHB2VmlzaXRvci5zdHJhdGVneSwgcHZWYXJpYWJsZU5hbWVzW3B2VmlzaXRvci52aWV3SW5kZXhdLCBwdlZpc2l0b3IuYmluZGluZ1JlY29yZHMsIHB2VmlzaXRvci5ldmVudFJlY29yZHMsIHB2VmlzaXRvci5kaXJlY3RpdmVSZWNvcmRzLCBnZW5Db25maWcpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX2NvbGxlY3ROZXN0ZWRQcm90b1ZpZXdzVmFyaWFibGVOYW1lcyhwdlZpc2l0b3JzKSB7XHJcbiAgICB2YXIgbmVzdGVkUHZWYXJpYWJsZU5hbWVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShwdlZpc2l0b3JzLmxlbmd0aCk7XHJcbiAgICBwdlZpc2l0b3JzLmZvckVhY2goZnVuY3Rpb24gKHB2KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFZhcmlhYmxlTmFtZXMgPSBsYW5nXzEuaXNQcmVzZW50KHB2LnBhcmVudCkgPyBuZXN0ZWRQdlZhcmlhYmxlTmFtZXNbcHYucGFyZW50LnZpZXdJbmRleF0gOiBbXTtcclxuICAgICAgICBuZXN0ZWRQdlZhcmlhYmxlTmFtZXNbcHYudmlld0luZGV4XSA9IHBhcmVudFZhcmlhYmxlTmFtZXMuY29uY2F0KHB2LnZhcmlhYmxlTmFtZXMpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmVzdGVkUHZWYXJpYWJsZU5hbWVzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZWZpbml0aW9uX2ZhY3RvcnkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBzb3VyY2VfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvdXJjZV9tb2R1bGUnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3InKTtcclxudmFyIGNoYW5nZV9kZWZpbml0aW9uX2ZhY3RvcnlfMSA9IHJlcXVpcmUoJy4vY2hhbmdlX2RlZmluaXRpb25fZmFjdG9yeScpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0b3JfY29kZWdlbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL3RyYW5zZm9ybS90ZW1wbGF0ZV9jb21waWxlci9jaGFuZ2VfZGV0ZWN0b3JfY29kZWdlbicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIEFCU1RSQUNUX0NIQU5HRV9ERVRFQ1RPUiA9IFwiQWJzdHJhY3RDaGFuZ2VEZXRlY3RvclwiO1xyXG52YXIgVVRJTCA9IFwiQ2hhbmdlRGV0ZWN0aW9uVXRpbFwiO1xyXG52YXIgQUJTVFJBQ1RfQ0hBTkdFX0RFVEVDVE9SX01PRFVMRSA9IHNvdXJjZV9tb2R1bGVfMS5tb2R1bGVSZWYoXCJwYWNrYWdlOmFuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yXCIgKyB1dGlsXzEuTU9EVUxFX1NVRkZJWCk7XHJcbnZhciBVVElMX01PRFVMRSA9IHNvdXJjZV9tb2R1bGVfMS5tb2R1bGVSZWYoXCJwYWNrYWdlOmFuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl91dGlsXCIgKyB1dGlsXzEuTU9EVUxFX1NVRkZJWCk7XHJcbnZhciBQUkVHRU5fUFJPVE9fQ0hBTkdFX0RFVEVDVE9SX01PRFVMRSA9IHNvdXJjZV9tb2R1bGVfMS5tb2R1bGVSZWYoXCJwYWNrYWdlOmFuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vcHJlZ2VuX3Byb3RvX2NoYW5nZV9kZXRlY3RvclwiICsgdXRpbF8xLk1PRFVMRV9TVUZGSVgpO1xyXG52YXIgQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIoX2dlbkNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX2dlbkNvbmZpZyA9IF9nZW5Db25maWc7XHJcbiAgICB9XHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25Db21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgc3RyYXRlZ3ksIHBhcnNlZFRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyA9IGNoYW5nZV9kZWZpbml0aW9uX2ZhY3RvcnlfMS5jcmVhdGVDaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zKGNvbXBvbmVudFR5cGUsIHN0cmF0ZWd5LCB0aGlzLl9nZW5Db25maWcsIHBhcnNlZFRlbXBsYXRlKTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVDaGFuZ2VEZXRlY3RvckZhY3RvcnkoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VEZXRlY3RvckZhY3RvcnkgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmICh1dGlsXzEuSVNfREFSVCB8fCAhdGhpcy5fZ2VuQ29uZmlnLnVzZUppdCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBuZXcgY2hhbmdlX2RldGVjdGlvbl8xLkR5bmFtaWNQcm90b0NoYW5nZURldGVjdG9yKGRlZmluaXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsgcmV0dXJuIHByb3RvLmluc3RhbnRpYXRlKGRpc3BhdGNoZXIpOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjaGFuZ2VfZGV0ZWN0aW9uX2ppdF9nZW5lcmF0b3JfMS5DaGFuZ2VEZXRlY3RvckpJVEdlbmVyYXRvcihkZWZpbml0aW9uLCBVVElMLCBBQlNUUkFDVF9DSEFOR0VfREVURUNUT1IpLmdlbmVyYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50Q29kZUdlbiA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBzdHJhdGVneSwgcGFyc2VkVGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyA9IGNoYW5nZV9kZWZpbml0aW9uX2ZhY3RvcnlfMS5jcmVhdGVDaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zKGNvbXBvbmVudFR5cGUsIHN0cmF0ZWd5LCB0aGlzLl9nZW5Db25maWcsIHBhcnNlZFRlbXBsYXRlKTtcclxuICAgICAgICB2YXIgZmFjdG9yaWVzID0gW107XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlUGFydHMgPSBjaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgY29kZWdlbjtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZVBhcnQ7XHJcbiAgICAgICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGUgMiBjb2RlIGdlbmVyYXRvcnMgdG8gdGhlIHNhbWUgcGxhY2UsIG9uZSB3aXRoIC5kYXJ0IGFuZCBvbmUgd2l0aCAudHNcclxuICAgICAgICAgICAgLy8gc3VmZml4XHJcbiAgICAgICAgICAgIC8vIGFuZCBoYXZlIHRoZSBzYW1lIEFQSSBmb3IgY2FsbGluZyB0aGVtIVxyXG4gICAgICAgICAgICBpZiAodXRpbF8xLklTX0RBUlQpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVnZW4gPSBuZXcgY2hhbmdlX2RldGVjdG9yX2NvZGVnZW5fMS5Db2RlZ2VuKFBSRUdFTl9QUk9UT19DSEFOR0VfREVURUNUT1JfTU9EVUxFKTtcclxuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBkZWZpbml0aW9uLmlkO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVSZWYgPSAoaW5kZXggPT09IDAgJiYgY29tcG9uZW50VHlwZS5pc0hvc3QpID9cclxuICAgICAgICAgICAgICAgICAgICAnZHluYW1pYycgOlxyXG4gICAgICAgICAgICAgICAgICAgIFwiXCIgKyBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKGNvbXBvbmVudFR5cGUubW9kdWxlVXJsKSArIGNvbXBvbmVudFR5cGUubmFtZTtcclxuICAgICAgICAgICAgICAgIGNvZGVnZW4uZ2VuZXJhdGUodHlwZVJlZiwgY2xhc3NOYW1lLCBkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIGZhY3Rvcmllcy5wdXNoKFwiKGRpc3BhdGNoZXIpID0+IG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKGRpc3BhdGNoZXIpXCIpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlUGFydCA9IGNvZGVnZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGVnZW4gPSBuZXcgY2hhbmdlX2RldGVjdGlvbl9qaXRfZ2VuZXJhdG9yXzEuQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IoZGVmaW5pdGlvbiwgXCJcIiArIFVUSUxfTU9EVUxFICsgVVRJTCwgXCJcIiArIEFCU1RSQUNUX0NIQU5HRV9ERVRFQ1RPUl9NT0RVTEUgKyBBQlNUUkFDVF9DSEFOR0VfREVURUNUT1IpO1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yaWVzLnB1c2goXCJmdW5jdGlvbihkaXNwYXRjaGVyKSB7IHJldHVybiBuZXcgXCIgKyBjb2RlZ2VuLnR5cGVOYW1lICsgXCIoZGlzcGF0Y2hlcik7IH1cIik7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VQYXJ0ID0gY29kZWdlbi5nZW5lcmF0ZVNvdXJjZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VQYXJ0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgc291cmNlX21vZHVsZV8xLlNvdXJjZUV4cHJlc3Npb25zKHNvdXJjZVBhcnRzLCBmYWN0b3JpZXMpO1xyXG4gICAgfTtcclxuICAgIENoYW5nZURldGVjdGlvbkNvbXBpbGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvckdlbkNvbmZpZ10pXHJcbiAgICBdLCBDaGFuZ2VEZXRlY3Rpb25Db21waWxlcik7XHJcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIgPSBDaGFuZ2VEZXRlY3Rpb25Db21waWxlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciB0ZW1wbGF0ZV9jb21tYW5kc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3RlbXBsYXRlX2NvbW1hbmRzJyk7XHJcbnZhciB0ZW1wbGF0ZV9hc3RfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfYXN0Jyk7XHJcbnZhciBzb3VyY2VfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvdXJjZV9tb2R1bGUnKTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhL3ZpZXcnKTtcclxudmFyIHN0eWxlX2NvbXBpbGVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX2NvbXBpbGVyJyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG5leHBvcnRzLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgPSBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKFwicGFja2FnZTphbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdGVtcGxhdGVfY29tbWFuZHNcIiArIHV0aWxfMS5NT0RVTEVfU1VGRklYKTtcclxudmFyIElNUExJQ0lUX1RFTVBMQVRFX1ZBUiA9ICdcXCRpbXBsaWNpdCc7XHJcbnZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcclxudmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xyXG52YXIgQ29tbWFuZENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbW1hbmRDb21waWxlcigpIHtcclxuICAgIH1cclxuICAgIENvbW1hbmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBhcHBJZCwgdGVtcGxhdGVJZCwgdGVtcGxhdGUsIGNoYW5nZURldGVjdG9yRmFjdG9yaWVzLCBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBDb21tYW5kQnVpbGRlclZpc2l0b3IobmV3IFJ1bnRpbWVDb21tYW5kRmFjdG9yeShjb21wb25lbnQsIGFwcElkLCB0ZW1wbGF0ZUlkLCBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnksIGNoYW5nZURldGVjdG9yRmFjdG9yaWVzKSwgMCk7XHJcbiAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IucmVzdWx0O1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudENvZGVHZW4gPSBmdW5jdGlvbiAoY29tcG9uZW50LCBhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByLCB0ZW1wbGF0ZSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5RXhwcmVzc2lvbnMsIGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IENvbW1hbmRCdWlsZGVyVmlzaXRvcihuZXcgQ29kZWdlbkNvbW1hbmRGYWN0b3J5KGNvbXBvbmVudCwgYXBwSWRFeHByLCB0ZW1wbGF0ZUlkRXhwciwgY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5LCBjaGFuZ2VEZXRlY3RvckZhY3RvcnlFeHByZXNzaW9ucyksIDApO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgdGVtcGxhdGUpO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBcIltcIiArIHZpc2l0b3IucmVzdWx0LmpvaW4oJywnKSArIFwiXVwiO1xyXG4gICAgICAgIHJldHVybiBuZXcgc291cmNlX21vZHVsZV8xLlNvdXJjZUV4cHJlc3Npb24oW10sIHNvdXJjZSk7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZENvbXBpbGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBDb21tYW5kQ29tcGlsZXIpO1xyXG4gICAgcmV0dXJuIENvbW1hbmRDb21waWxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Db21tYW5kQ29tcGlsZXIgPSBDb21tYW5kQ29tcGlsZXI7XHJcbnZhciBSdW50aW1lQ29tbWFuZEZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUnVudGltZUNvbW1hbmRGYWN0b3J5KGNvbXBvbmVudCwgYXBwSWQsIHRlbXBsYXRlSWQsIGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXMpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUlkID0gdGVtcGxhdGVJZDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSA9IGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yRmFjdG9yaWVzID0gY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXM7XHJcbiAgICB9XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLl9tYXBEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLnR5cGUucnVudGltZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5fYWRkU3R5bGVTaGltQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyTmFtZUFuZFZhbHVlcywgbG9jYWxDb21wb25lbnQsIGxvY2FsVGVtcGxhdGVJZCkge1xyXG4gICAgICAgIHZhciBhZGRpdGlvbmFsU3R5bGVzID0gW107XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobG9jYWxDb21wb25lbnQpICYmXHJcbiAgICAgICAgICAgIGxvY2FsQ29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsU3R5bGVzLnB1c2goc3R5bGVfY29tcGlsZXJfMS5zaGltSG9zdEF0dHJpYnV0ZSh0aGlzLmFwcElkLCBsb2NhbFRlbXBsYXRlSWQpKTtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0eWxlcy5wdXNoKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsU3R5bGVzLnB1c2goc3R5bGVfY29tcGlsZXJfMS5zaGltQ29udGVudEF0dHJpYnV0ZSh0aGlzLmFwcElkLCB0aGlzLnRlbXBsYXRlSWQpKTtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0eWxlcy5wdXNoKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxTdHlsZXMuY29uY2F0KGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlX2NvbW1hbmRzXzEudGV4dCh2YWx1ZSwgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTmdDb250ZW50ID0gZnVuY3Rpb24gKGluZGV4LCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLm5nQ29udGVudChpbmRleCwgbmdDb250ZW50SW5kZXgpO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlX2NvbW1hbmRzXzEuYmVnaW5FbGVtZW50KG5hbWUsIHRoaXMuX2FkZFN0eWxlU2hpbUF0dHJpYnV0ZXMoYXR0ck5hbWVBbmRWYWx1ZXMsIG51bGwsIG51bGwpLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIHRoaXMuX21hcERpcmVjdGl2ZXMoZGlyZWN0aXZlcyksIGlzQm91bmQsIG5nQ29udGVudEluZGV4KTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLmVuZEVsZW1lbnQoKTsgfTtcclxuICAgIFJ1bnRpbWVDb21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQmVnaW5Db21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRUZW1wbGF0ZSA9IHRoaXMuY29tcG9uZW50VGVtcGxhdGVGYWN0b3J5KGRpcmVjdGl2ZXNbMF0pO1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLmJlZ2luQ29tcG9uZW50KG5hbWUsIHRoaXMuX2FkZFN0eWxlU2hpbUF0dHJpYnV0ZXMoYXR0ck5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXNbMF0sIG5lc3RlZFRlbXBsYXRlLmlkKSwgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCB0aGlzLl9tYXBEaXJlY3RpdmVzKGRpcmVjdGl2ZXMpLCBuYXRpdmVTaGFkb3csIG5nQ29udGVudEluZGV4LCBuZXN0ZWRUZW1wbGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVFbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLmVuZENvbXBvbmVudCgpOyB9O1xyXG4gICAgUnVudGltZUNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGVtYmVkZGVkVGVtcGxhdGVJbmRleCwgYXR0ck5hbWVBbmRWYWx1ZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgaXNNZXJnZWQsIG5nQ29udGVudEluZGV4LCBjaGlsZHJlbikge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZV9jb21tYW5kc18xLmVtYmVkZGVkVGVtcGxhdGUoYXR0ck5hbWVBbmRWYWx1ZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgdGhpcy5fbWFwRGlyZWN0aXZlcyhkaXJlY3RpdmVzKSwgaXNNZXJnZWQsIG5nQ29udGVudEluZGV4LCB0aGlzLmNoYW5nZURldGVjdG9yRmFjdG9yaWVzW2VtYmVkZGVkVGVtcGxhdGVJbmRleF0sIGNoaWxkcmVuKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUnVudGltZUNvbW1hbmRGYWN0b3J5O1xyXG59KSgpO1xyXG52YXIgQ29kZWdlbkNvbW1hbmRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvZGVnZW5Db21tYW5kRmFjdG9yeShjb21wb25lbnQsIGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIsIGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5RXhwcmVzc2lvbnMpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmFwcElkRXhwciA9IGFwcElkRXhwcjtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlSWRFeHByID0gdGVtcGxhdGVJZEV4cHI7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkgPSBjb21wb25lbnRUZW1wbGF0ZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3RvcnlFeHByZXNzaW9ucyA9IGNoYW5nZURldGVjdG9yRmFjdG9yeUV4cHJlc3Npb25zO1xyXG4gICAgfVxyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5fYWRkU3R5bGVTaGltQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyTmFtZUFuZFZhbHVlcywgbG9jYWxDb21wb25lbnQsIGxvY2FsVGVtcGxhdGVJZEV4cHIpIHtcclxuICAgICAgICB2YXIgYWRkaXRpb25hbFN0bHllcyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGxvY2FsQ29tcG9uZW50KSAmJlxyXG4gICAgICAgICAgICBsb2NhbENvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0bHllcy5wdXNoKG5ldyBFeHByZXNzaW9uKHN0eWxlX2NvbXBpbGVyXzEuc2hpbUhvc3RBdHRyaWJ1dGVFeHByKHRoaXMuYXBwSWRFeHByLCBsb2NhbFRlbXBsYXRlSWRFeHByKSkpO1xyXG4gICAgICAgICAgICBhZGRpdGlvbmFsU3RseWVzLnB1c2goJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKSB7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdGx5ZXMucHVzaChuZXcgRXhwcmVzc2lvbihzdHlsZV9jb21waWxlcl8xLnNoaW1Db250ZW50QXR0cmlidXRlRXhwcih0aGlzLmFwcElkRXhwciwgdGhpcy50ZW1wbGF0ZUlkRXhwcikpKTtcclxuICAgICAgICAgICAgYWRkaXRpb25hbFN0bHllcy5wdXNoKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxTdGx5ZXMuY29uY2F0KGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwidGV4dChcIiArIHV0aWxfMS5lc2NhcGVTaW5nbGVRdW90ZVN0cmluZyh2YWx1ZSkgKyBcIiwgXCIgKyBpc0JvdW5kICsgXCIsIFwiICsgbmdDb250ZW50SW5kZXggKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU5nQ29udGVudCA9IGZ1bmN0aW9uIChpbmRleCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGICsgXCJuZ0NvbnRlbnQoXCIgKyBpbmRleCArIFwiLCBcIiArIG5nQ29udGVudEluZGV4ICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVCZWdpbkVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgYXR0cnNFeHByZXNzaW9uID0gY29kZUdlbkFycmF5KHRoaXMuX2FkZFN0eWxlU2hpbUF0dHJpYnV0ZXMoYXR0ck5hbWVBbmRWYWx1ZXMsIG51bGwsIG51bGwpKTtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGICsgXCJiZWdpbkVsZW1lbnQoXCIgKyB1dGlsXzEuZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcobmFtZSkgKyBcIiwgXCIgKyBhdHRyc0V4cHJlc3Npb24gKyBcIiwgXCIgKyBjb2RlR2VuQXJyYXkoZXZlbnRUYXJnZXRBbmROYW1lcykgKyBcIiwgXCIgKyBjb2RlR2VuQXJyYXkodmFyaWFibGVOYW1lQW5kVmFsdWVzKSArIFwiLCBcIiArIGNvZGVHZW5EaXJlY3RpdmVzQXJyYXkoZGlyZWN0aXZlcykgKyBcIiwgXCIgKyBpc0JvdW5kICsgXCIsIFwiICsgbmdDb250ZW50SW5kZXggKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLlRFTVBMQVRFX0NPTU1BTkRTX01PRFVMRV9SRUYgKyBcImVuZEVsZW1lbnQoKVwiOyB9O1xyXG4gICAgQ29kZWdlbkNvbW1hbmRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVCZWdpbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyTmFtZUFuZFZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBuYXRpdmVTaGFkb3csIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZENvbXBFeHByID0gdGhpcy5jb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkoZGlyZWN0aXZlc1swXSk7XHJcbiAgICAgICAgdmFyIGF0dHJzRXhwcmVzc2lvbiA9IGNvZGVHZW5BcnJheSh0aGlzLl9hZGRTdHlsZVNoaW1BdHRyaWJ1dGVzKGF0dHJOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzWzBdLCBuZXN0ZWRDb21wRXhwciArIFwiLmlkXCIpKTtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGICsgXCJiZWdpbkNvbXBvbmVudChcIiArIHV0aWxfMS5lc2NhcGVTaW5nbGVRdW90ZVN0cmluZyhuYW1lKSArIFwiLCBcIiArIGF0dHJzRXhwcmVzc2lvbiArIFwiLCBcIiArIGNvZGVHZW5BcnJheShldmVudFRhcmdldEFuZE5hbWVzKSArIFwiLCBcIiArIGNvZGVHZW5BcnJheSh2YXJpYWJsZU5hbWVBbmRWYWx1ZXMpICsgXCIsIFwiICsgY29kZUdlbkRpcmVjdGl2ZXNBcnJheShkaXJlY3RpdmVzKSArIFwiLCBcIiArIG5hdGl2ZVNoYWRvdyArIFwiLCBcIiArIG5nQ29udGVudEluZGV4ICsgXCIsIFwiICsgbmVzdGVkQ29tcEV4cHIgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBDb2RlZ2VuQ29tbWFuZEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUVuZENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiZW5kQ29tcG9uZW50KClcIjsgfTtcclxuICAgIENvZGVnZW5Db21tYW5kRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChlbWJlZGRlZFRlbXBsYXRlSW5kZXgsIGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgY2hpbGRyZW4pIHtcclxuICAgICAgICByZXR1cm4gKGV4cG9ydHMuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiZW1iZWRkZWRUZW1wbGF0ZShcIiArIGNvZGVHZW5BcnJheShhdHRyTmFtZUFuZFZhbHVlcykgKyBcIiwgXCIgKyBjb2RlR2VuQXJyYXkodmFyaWFibGVOYW1lQW5kVmFsdWVzKSArIFwiLCBcIikgK1xyXG4gICAgICAgICAgICAoY29kZUdlbkRpcmVjdGl2ZXNBcnJheShkaXJlY3RpdmVzKSArIFwiLCBcIiArIGlzTWVyZ2VkICsgXCIsIFwiICsgbmdDb250ZW50SW5kZXggKyBcIiwgXCIgKyB0aGlzLmNoYW5nZURldGVjdG9yRmFjdG9yeUV4cHJlc3Npb25zW2VtYmVkZGVkVGVtcGxhdGVJbmRleF0gKyBcIiwgW1wiICsgY2hpbGRyZW4uam9pbignLCcpICsgXCJdKVwiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29kZWdlbkNvbW1hbmRGYWN0b3J5O1xyXG59KSgpO1xyXG5mdW5jdGlvbiB2aXNpdEFuZFJldHVybkNvbnRleHQodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xyXG4gICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCBhc3RzLCBjb250ZXh0KTtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59XHJcbnZhciBDb21tYW5kQnVpbGRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tbWFuZEJ1aWxkZXJWaXNpdG9yKGNvbW1hbmRGYWN0b3J5LCBlbWJlZGRlZFRlbXBsYXRlSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRGYWN0b3J5ID0gY29tbWFuZEZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5lbWJlZGRlZFRlbXBsYXRlSW5kZXggPSBlbWJlZGRlZFRlbXBsYXRlSW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBbXTtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpdmVOZ0NvbnRlbnRDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9yZWFkQXR0ck5hbWVBbmRWYWx1ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgYXR0ckFzdHMpIHtcclxuICAgICAgICB2YXIgYXR0cnMgPSBrZXlWYWx1ZUFycmF5VG9NYXAodmlzaXRBbmRSZXR1cm5Db250ZXh0KHRoaXMsIGF0dHJBc3RzLCBbXSkpO1xyXG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlTWV0YSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGRpcmVjdGl2ZU1ldGEuaG9zdEF0dHJpYnV0ZXMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGF0dHJzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBsYW5nXzEuaXNQcmVzZW50KHByZXZWYWx1ZSkgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXBUb0tleVZhbHVlQXJyYXkoYXR0cnMpO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlTmdDb250ZW50Q291bnQrKztcclxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlTmdDb250ZW50KGFzdC5pbmRleCwgYXN0Lm5nQ29udGVudEluZGV4KSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmVtYmVkZGVkVGVtcGxhdGVJbmRleCsrO1xyXG4gICAgICAgIHZhciBjaGlsZFZpc2l0b3IgPSBuZXcgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yKHRoaXMuY29tbWFuZEZhY3RvcnksIHRoaXMuZW1iZWRkZWRUZW1wbGF0ZUluZGV4KTtcclxuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKGNoaWxkVmlzaXRvciwgYXN0LmNoaWxkcmVuKTtcclxuICAgICAgICB2YXIgaXNNZXJnZWQgPSBjaGlsZFZpc2l0b3IudHJhbnNpdGl2ZU5nQ29udGVudENvdW50ID4gMDtcclxuICAgICAgICB2YXIgdmFyaWFibGVOYW1lQW5kVmFsdWVzID0gW107XHJcbiAgICAgICAgYXN0LnZhcnMuZm9yRWFjaChmdW5jdGlvbiAodmFyQXN0KSB7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZUFuZFZhbHVlcy5wdXNoKHZhckFzdC5uYW1lKTtcclxuICAgICAgICAgICAgdmFyaWFibGVOYW1lQW5kVmFsdWVzLnB1c2godmFyQXN0LnZhbHVlLmxlbmd0aCA+IDAgPyB2YXJBc3QudmFsdWUgOiBJTVBMSUNJVF9URU1QTEFURV9WQVIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gW107XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoYXN0LmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZUFzdC52aXNpdChfdGhpcywgbmV3IERpcmVjdGl2ZUNvbnRleHQoaW5kZXgsIFtdLCBbXSwgZGlyZWN0aXZlcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2godGhpcy5jb21tYW5kRmFjdG9yeS5jcmVhdGVFbWJlZGRlZFRlbXBsYXRlKHRoaXMuZW1iZWRkZWRUZW1wbGF0ZUluZGV4LCB0aGlzLl9yZWFkQXR0ck5hbWVBbmRWYWx1ZXMoZGlyZWN0aXZlcywgYXN0LmF0dHJzKSwgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc01lcmdlZCwgYXN0Lm5nQ29udGVudEluZGV4LCBjaGlsZFZpc2l0b3IucmVzdWx0KSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlTmdDb250ZW50Q291bnQgKz0gY2hpbGRWaXNpdG9yLnRyYW5zaXRpdmVOZ0NvbnRlbnRDb3VudDtcclxuICAgICAgICB0aGlzLmVtYmVkZGVkVGVtcGxhdGVJbmRleCA9IGNoaWxkVmlzaXRvci5lbWJlZGRlZFRlbXBsYXRlSW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gYXN0LmdldENvbXBvbmVudCgpO1xyXG4gICAgICAgIHZhciBldmVudFRhcmdldEFuZE5hbWVzID0gdmlzaXRBbmRSZXR1cm5Db250ZXh0KHRoaXMsIGFzdC5vdXRwdXRzLCBbXSk7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZUFuZFZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIGFzdC5leHBvcnRBc1ZhcnMuZm9yRWFjaChmdW5jdGlvbiAodmFyQXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMucHVzaCh2YXJBc3QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gW107XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoYXN0LmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZUFzdC52aXNpdChfdGhpcywgbmV3IERpcmVjdGl2ZUNvbnRleHQoaW5kZXgsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50VGFyZ2V0QW5kTmFtZXMgPSByZW1vdmVLZXlWYWx1ZUFycmF5RHVwbGljYXRlcyhldmVudFRhcmdldEFuZE5hbWVzKTtcclxuICAgICAgICB2YXIgYXR0ck5hbWVBbmRWYWx1ZXMgPSB0aGlzLl9yZWFkQXR0ck5hbWVBbmRWYWx1ZXMoZGlyZWN0aXZlcywgYXN0LmF0dHJzKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2godGhpcy5jb21tYW5kRmFjdG9yeS5jcmVhdGVCZWdpbkNvbXBvbmVudChhc3QubmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IHZpZXdfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUsIGFzdC5uZ0NvbnRlbnRJbmRleCkpO1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2godGhpcy5jb21tYW5kRmFjdG9yeS5jcmVhdGVFbmRDb21wb25lbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlQmVnaW5FbGVtZW50KGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBhc3QuaXNCb3VuZCgpLCBhc3QubmdDb250ZW50SW5kZXgpKTtcclxuICAgICAgICAgICAgdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHRoaXMuY29tbWFuZEZhY3RvcnkuY3JlYXRlRW5kRWxlbWVudCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBhdHRyTmFtZUFuZFZhbHVlcykge1xyXG4gICAgICAgIGF0dHJOYW1lQW5kVmFsdWVzLnB1c2goYXN0Lm5hbWUpO1xyXG4gICAgICAgIGF0dHJOYW1lQW5kVmFsdWVzLnB1c2goYXN0LnZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2godGhpcy5jb21tYW5kRmFjdG9yeS5jcmVhdGVUZXh0KG51bGwsIHRydWUsIGFzdC5uZ0NvbnRlbnRJbmRleCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2godGhpcy5jb21tYW5kRmFjdG9yeS5jcmVhdGVUZXh0KGFzdC52YWx1ZSwgZmFsc2UsIGFzdC5uZ0NvbnRlbnRJbmRleCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcclxuICAgICAgICBjdHgudGFyZ2V0RGlyZWN0aXZlcy5wdXNoKGFzdC5kaXJlY3RpdmUpO1xyXG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0Lmhvc3RFdmVudHMsIGN0eC5ldmVudFRhcmdldEFuZE5hbWVzKTtcclxuICAgICAgICBhc3QuZXhwb3J0QXNWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhckFzdCkge1xyXG4gICAgICAgICAgICBjdHgudGFyZ2V0VmFyaWFibGVOYW1lQW5kVmFsdWVzLnB1c2godmFyQXN0Lm5hbWUpO1xyXG4gICAgICAgICAgICBjdHgudGFyZ2V0VmFyaWFibGVOYW1lQW5kVmFsdWVzLnB1c2goY3R4LmluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBldmVudFRhcmdldEFuZE5hbWVzKSB7XHJcbiAgICAgICAgZXZlbnRUYXJnZXRBbmROYW1lcy5wdXNoKGFzdC50YXJnZXQpO1xyXG4gICAgICAgIGV2ZW50VGFyZ2V0QW5kTmFtZXMucHVzaChhc3QubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29tbWFuZEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIENvbW1hbmRCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgcmV0dXJuIENvbW1hbmRCdWlsZGVyVmlzaXRvcjtcclxufSkoKTtcclxuZnVuY3Rpb24gcmVtb3ZlS2V5VmFsdWVBcnJheUR1cGxpY2F0ZXMoa2V5VmFsdWVBcnJheSkge1xyXG4gICAgdmFyIGtub3duUGFpcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB2YXIgcmVzdWx0S2V5VmFsdWVBcnJheSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZUFycmF5Lmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleVZhbHVlQXJyYXlbaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0ga2V5VmFsdWVBcnJheVtpICsgMV07XHJcbiAgICAgICAgdmFyIHBhaXJJZCA9IGtleSArIFwiOlwiICsgdmFsdWU7XHJcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMoa25vd25QYWlycywgcGFpcklkKSkge1xyXG4gICAgICAgICAgICByZXN1bHRLZXlWYWx1ZUFycmF5LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0S2V5VmFsdWVBcnJheS5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAga25vd25QYWlycy5hZGQocGFpcklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0S2V5VmFsdWVBcnJheTtcclxufVxyXG5mdW5jdGlvbiBrZXlWYWx1ZUFycmF5VG9NYXAoa2V5VmFsdWVBcnIpIHtcclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlQXJyLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgZGF0YVtrZXlWYWx1ZUFycltpXV0gPSBrZXlWYWx1ZUFycltpICsgMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5mdW5jdGlvbiBtYXBUb0tleVZhbHVlQXJyYXkoZGF0YSkge1xyXG4gICAgdmFyIGVudHJ5QXJyYXkgPSBbXTtcclxuICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7IGVudHJ5QXJyYXkucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XHJcbiAgICAvLyBXZSBuZWVkIHRvIHNvcnQgdG8gZ2V0IGEgZGVmaW5lZCBvdXRwdXQgb3JkZXJcclxuICAgIC8vIGZvciB0ZXN0cyBhbmQgZm9yIGNhY2hpbmcgZ2VuZXJhdGVkIGFydGlmYWN0cy4uLlxyXG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNvcnQoZW50cnlBcnJheSwgZnVuY3Rpb24gKGVudHJ5MSwgZW50cnkyKSB7IHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5jb21wYXJlKGVudHJ5MVswXSwgZW50cnkyWzBdKTsgfSk7XHJcbiAgICB2YXIga2V5VmFsdWVBcnJheSA9IFtdO1xyXG4gICAgZW50cnlBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGtleVZhbHVlQXJyYXkucHVzaChlbnRyeVswXSk7XHJcbiAgICAgICAga2V5VmFsdWVBcnJheS5wdXNoKGVudHJ5WzFdKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGtleVZhbHVlQXJyYXk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShhdHRyTmFtZSwgYXR0clZhbHVlMSwgYXR0clZhbHVlMikge1xyXG4gICAgaWYgKGF0dHJOYW1lID09IENMQVNTX0FUVFIgfHwgYXR0ck5hbWUgPT0gU1RZTEVfQVRUUikge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUxICsgXCIgXCIgKyBhdHRyVmFsdWUyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTI7XHJcbiAgICB9XHJcbn1cclxudmFyIERpcmVjdGl2ZUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlQ29udGV4dChpbmRleCwgZXZlbnRUYXJnZXRBbmROYW1lcywgdGFyZ2V0VmFyaWFibGVOYW1lQW5kVmFsdWVzLCB0YXJnZXREaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXRBbmROYW1lcyA9IGV2ZW50VGFyZ2V0QW5kTmFtZXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXRWYXJpYWJsZU5hbWVBbmRWYWx1ZXMgPSB0YXJnZXRWYXJpYWJsZU5hbWVBbmRWYWx1ZXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXREaXJlY3RpdmVzID0gdGFyZ2V0RGlyZWN0aXZlcztcclxuICAgIH1cclxuICAgIHJldHVybiBEaXJlY3RpdmVDb250ZXh0O1xyXG59KSgpO1xyXG52YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV4cHJlc3Npb247XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGVzY2FwZVZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFuZ18xLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29kZUdlbkFycmF5KGRhdGEpIHtcclxuICAgIHJldHVybiBcIltcIiArIGRhdGEubWFwKGVzY2FwZVZhbHVlKS5qb2luKCcsJykgKyBcIl1cIjtcclxufVxyXG5mdW5jdGlvbiBjb2RlR2VuRGlyZWN0aXZlc0FycmF5KGRpcmVjdGl2ZXMpIHtcclxuICAgIHZhciBleHByZXNzaW9ucyA9IGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7IHJldHVybiAoXCJcIiArIHNvdXJjZV9tb2R1bGVfMS5tb2R1bGVSZWYoZGlyZWN0aXZlVHlwZS50eXBlLm1vZHVsZVVybCkgKyBkaXJlY3RpdmVUeXBlLnR5cGUubmFtZSk7IH0pO1xyXG4gICAgcmV0dXJuIFwiW1wiICsgZXhwcmVzc2lvbnMuam9pbignLCcpICsgXCJdXCI7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWFuZF9jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIHJ1bnRpbWVfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWVfY29tcGlsZXJcIik7XHJcbnZhciB0ZW1wbGF0ZV9jb21waWxlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9jb21waWxlcicpO1xyXG5leHBvcnRzLlRlbXBsYXRlQ29tcGlsZXIgPSB0ZW1wbGF0ZV9jb21waWxlcl8xLlRlbXBsYXRlQ29tcGlsZXI7XHJcbnZhciBkaXJlY3RpdmVfbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX21ldGFkYXRhJyk7XHJcbmV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gZGlyZWN0aXZlX21ldGFkYXRhXzEuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xyXG5leHBvcnRzLkNvbXBpbGVUeXBlTWV0YWRhdGEgPSBkaXJlY3RpdmVfbWV0YWRhdGFfMS5Db21waWxlVHlwZU1ldGFkYXRhO1xyXG5leHBvcnRzLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gZGlyZWN0aXZlX21ldGFkYXRhXzEuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XHJcbnZhciBzb3VyY2VfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvdXJjZV9tb2R1bGUnKTtcclxuZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBzb3VyY2VfbW9kdWxlXzEuU291cmNlTW9kdWxlO1xyXG5leHBvcnRzLlNvdXJjZVdpdGhJbXBvcnRzID0gc291cmNlX21vZHVsZV8xLlNvdXJjZVdpdGhJbXBvcnRzO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgdGVtcGxhdGVfcGFyc2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci90ZW1wbGF0ZV9wYXJzZXInKTtcclxudmFyIGh0bWxfcGFyc2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9odG1sX3BhcnNlcicpO1xyXG52YXIgdGVtcGxhdGVfbm9ybWFsaXplcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdGVtcGxhdGVfbm9ybWFsaXplcicpO1xyXG52YXIgcnVudGltZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvcnVudGltZV9tZXRhZGF0YScpO1xyXG52YXIgY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9jaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXInKTtcclxudmFyIHN0eWxlX2NvbXBpbGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zdHlsZV9jb21waWxlcicpO1xyXG52YXIgY29tbWFuZF9jb21waWxlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvY29tbWFuZF9jb21waWxlcicpO1xyXG52YXIgdGVtcGxhdGVfY29tcGlsZXJfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3RlbXBsYXRlX2NvbXBpbGVyJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvY29tcGlsZXInKTtcclxudmFyIHJ1bnRpbWVfY29tcGlsZXJfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3J1bnRpbWVfY29tcGlsZXInKTtcclxudmFyIGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zY2hlbWEvZWxlbWVudF9zY2hlbWFfcmVnaXN0cnknKTtcclxudmFyIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2NoZW1hL2RvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeScpO1xyXG52YXIgdXJsX3Jlc29sdmVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci91cmxfcmVzb2x2ZXInKTtcclxudmFyIGFwcF9yb290X3VybF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvYXBwX3Jvb3RfdXJsJyk7XHJcbnZhciBhbmNob3JfYmFzZWRfYXBwX3Jvb3RfdXJsXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9hbmNob3JfYmFzZWRfYXBwX3Jvb3RfdXJsJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxuZnVuY3Rpb24gY29tcGlsZXJQcm92aWRlcnMoKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGNoYW5nZV9kZXRlY3Rpb25fMi5MZXhlcixcclxuICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzIuUGFyc2VyLFxyXG4gICAgICAgIGh0bWxfcGFyc2VyXzEuSHRtbFBhcnNlcixcclxuICAgICAgICB0ZW1wbGF0ZV9wYXJzZXJfMS5UZW1wbGF0ZVBhcnNlcixcclxuICAgICAgICB0ZW1wbGF0ZV9ub3JtYWxpemVyXzEuVGVtcGxhdGVOb3JtYWxpemVyLFxyXG4gICAgICAgIHJ1bnRpbWVfbWV0YWRhdGFfMS5SdW50aW1lTWV0YWRhdGFSZXNvbHZlcixcclxuICAgICAgICBzdHlsZV9jb21waWxlcl8xLlN0eWxlQ29tcGlsZXIsXHJcbiAgICAgICAgY29tbWFuZF9jb21waWxlcl8xLkNvbW1hbmRDb21waWxlcixcclxuICAgICAgICBjaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXJfMS5DaGFuZ2VEZXRlY3Rpb25Db21waWxlcixcclxuICAgICAgICBkaV8xLnByb3ZpZGUoY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yR2VuQ29uZmlnLCB7XHJcbiAgICAgICAgICAgIHVzZVZhbHVlOiBuZXcgY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yR2VuQ29uZmlnKGxhbmdfMS5hc3NlcnRpb25zRW5hYmxlZCgpLCBsYW5nXzEuYXNzZXJ0aW9uc0VuYWJsZWQoKSwgZmFsc2UsIHRydWUpXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdGVtcGxhdGVfY29tcGlsZXJfMi5UZW1wbGF0ZUNvbXBpbGVyLFxyXG4gICAgICAgIGRpXzEucHJvdmlkZShydW50aW1lX2NvbXBpbGVyXzIuUnVudGltZUNvbXBpbGVyLCB7IHVzZUNsYXNzOiBydW50aW1lX2NvbXBpbGVyXzEuUnVudGltZUNvbXBpbGVyXyB9KSxcclxuICAgICAgICBkaV8xLnByb3ZpZGUoY29tcGlsZXJfMS5Db21waWxlciwgeyB1c2VFeGlzdGluZzogcnVudGltZV9jb21waWxlcl8yLlJ1bnRpbWVDb21waWxlciB9KSxcclxuICAgICAgICBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXHJcbiAgICAgICAgZGlfMS5wcm92aWRlKGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB7IHVzZUV4aXN0aW5nOiBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgfSksXHJcbiAgICAgICAgYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybF8xLkFuY2hvckJhc2VkQXBwUm9vdFVybCxcclxuICAgICAgICBkaV8xLnByb3ZpZGUoYXBwX3Jvb3RfdXJsXzEuQXBwUm9vdFVybCwgeyB1c2VFeGlzdGluZzogYW5jaG9yX2Jhc2VkX2FwcF9yb290X3VybF8xLkFuY2hvckJhc2VkQXBwUm9vdFVybCB9KSxcclxuICAgICAgICB1cmxfcmVzb2x2ZXJfMS5VcmxSZXNvbHZlclxyXG4gICAgXTtcclxufVxyXG5leHBvcnRzLmNvbXBpbGVyUHJvdmlkZXJzID0gY29tcGlsZXJQcm92aWRlcnM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhL3ZpZXcnKTtcclxudmFyIHNlbGVjdG9yXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9zZWxlY3RvcicpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvaW50ZXJmYWNlcycpO1xyXG4vLyBncm91cCAxOiBcInByb3BlcnR5XCIgZnJvbSBcIltwcm9wZXJ0eV1cIlxyXG4vLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxyXG52YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpJC9nO1xyXG52YXIgQ29tcGlsZVR5cGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlVHlwZU1ldGFkYXRhKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJ1bnRpbWUgPSBfYi5ydW50aW1lLCBuYW1lID0gX2IubmFtZSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBpc0hvc3QgPSBfYi5pc0hvc3Q7XHJcbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xyXG4gICAgICAgIHRoaXMuaXNIb3N0ID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNIb3N0KTtcclxuICAgIH1cclxuICAgIENvbXBpbGVUeXBlTWV0YWRhdGEuZnJvbUpzb24gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7IG5hbWU6IGRhdGFbJ25hbWUnXSwgbW9kdWxlVXJsOiBkYXRhWydtb2R1bGVVcmwnXSwgaXNIb3N0OiBkYXRhWydpc0hvc3QnXSB9KTtcclxuICAgIH07XHJcbiAgICBDb21waWxlVHlwZU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gTm90ZTogUnVudGltZSB0eXBlIGNhbid0IGJlIHNlcmlhbGl6ZWQuLi5cclxuICAgICAgICAgICAgJ25hbWUnOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICdtb2R1bGVVcmwnOiB0aGlzLm1vZHVsZVVybCxcclxuICAgICAgICAgICAgJ2lzSG9zdCc6IHRoaXMuaXNIb3N0XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcGlsZVR5cGVNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5Db21waWxlVHlwZU1ldGFkYXRhID0gQ29tcGlsZVR5cGVNZXRhZGF0YTtcclxudmFyIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgbmdDb250ZW50U2VsZWN0b3JzID0gX2IubmdDb250ZW50U2VsZWN0b3JzO1xyXG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGxhbmdfMS5pc1ByZXNlbnQoZW5jYXBzdWxhdGlvbikgPyBlbmNhcHN1bGF0aW9uIDogdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBsYW5nXzEuaXNQcmVzZW50KHN0eWxlcykgPyBzdHlsZXMgOiBbXTtcclxuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IGxhbmdfMS5pc1ByZXNlbnQoc3R5bGVVcmxzKSA/IHN0eWxlVXJscyA6IFtdO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gbGFuZ18xLmlzUHJlc2VudChuZ0NvbnRlbnRTZWxlY3RvcnMpID8gbmdDb250ZW50U2VsZWN0b3JzIDogW107XHJcbiAgICB9XHJcbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGxhbmdfMS5pc1ByZXNlbnQoZGF0YVsnZW5jYXBzdWxhdGlvbiddKSA/XHJcbiAgICAgICAgICAgICAgICB2aWV3XzEuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFU1tkYXRhWydlbmNhcHN1bGF0aW9uJ11dIDpcclxuICAgICAgICAgICAgICAgIGRhdGFbJ2VuY2Fwc3VsYXRpb24nXSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IGRhdGFbJ3RlbXBsYXRlJ10sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBkYXRhWyd0ZW1wbGF0ZVVybCddLFxyXG4gICAgICAgICAgICBzdHlsZXM6IGRhdGFbJ3N0eWxlcyddLFxyXG4gICAgICAgICAgICBzdHlsZVVybHM6IGRhdGFbJ3N0eWxlVXJscyddLFxyXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IGRhdGFbJ25nQ29udGVudFNlbGVjdG9ycyddXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnZW5jYXBzdWxhdGlvbic6IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbmNhcHN1bGF0aW9uKSA/IGxhbmdfMS5zZXJpYWxpemVFbnVtKHRoaXMuZW5jYXBzdWxhdGlvbikgOiB0aGlzLmVuY2Fwc3VsYXRpb24sXHJcbiAgICAgICAgICAgICd0ZW1wbGF0ZSc6IHRoaXMudGVtcGxhdGUsXHJcbiAgICAgICAgICAgICd0ZW1wbGF0ZVVybCc6IHRoaXMudGVtcGxhdGVVcmwsXHJcbiAgICAgICAgICAgICdzdHlsZXMnOiB0aGlzLnN0eWxlcyxcclxuICAgICAgICAgICAgJ3N0eWxlVXJscyc6IHRoaXMuc3R5bGVVcmxzLFxyXG4gICAgICAgICAgICAnbmdDb250ZW50U2VsZWN0b3JzJzogdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5Db21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xyXG52YXIgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgZHluYW1pY0xvYWRhYmxlID0gX2IuZHluYW1pY0xvYWRhYmxlLCBzZWxlY3RvciA9IF9iLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIGhvc3RMaXN0ZW5lcnMgPSBfYi5ob3N0TGlzdGVuZXJzLCBob3N0UHJvcGVydGllcyA9IF9iLmhvc3RQcm9wZXJ0aWVzLCBob3N0QXR0cmlidXRlcyA9IF9iLmhvc3RBdHRyaWJ1dGVzLCBsaWZlY3ljbGVIb29rcyA9IF9iLmxpZmVjeWNsZUhvb2tzLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0xvYWRhYmxlID0gZHluYW1pY0xvYWRhYmxlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcclxuICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xyXG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcclxuICAgICAgICB0aGlzLmhvc3RBdHRyaWJ1dGVzID0gaG9zdEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IGxpZmVjeWNsZUhvb2tzO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgIH1cclxuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIGR5bmFtaWNMb2FkYWJsZSA9IF9iLmR5bmFtaWNMb2FkYWJsZSwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0ID0gX2IuaG9zdCwgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZTtcclxuICAgICAgICB2YXIgaG9zdExpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgIHZhciBob3N0UHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIHZhciBob3N0QXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGhvc3QpKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goaG9zdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChIT1NUX1JFR19FWFAsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWF0Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoZXNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hlc1syXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzW21hdGNoZXNbMl1dID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5wdXRzTWFwID0ge307XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5wdXRzKSkge1xyXG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IGVsUHJvcGBcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHV0aWxfMS5zcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcclxuICAgICAgICAgICAgICAgIGlucHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRwdXRzTWFwID0ge307XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3V0cHV0cykpIHtcclxuICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gdXRpbF8xLnNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgaXNDb21wb25lbnQ6IGxhbmdfMS5ub3JtYWxpemVCb29sKGlzQ29tcG9uZW50KSxcclxuICAgICAgICAgICAgZHluYW1pY0xvYWRhYmxlOiBsYW5nXzEubm9ybWFsaXplQm9vbChkeW5hbWljTG9hZGFibGUpLFxyXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiBleHBvcnRBcyxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzTWFwLFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxyXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBob3N0TGlzdGVuZXJzLFxyXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogaG9zdFByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcclxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGxhbmdfMS5pc1ByZXNlbnQobGlmZWN5Y2xlSG9va3MpID8gbGlmZWN5Y2xlSG9va3MgOiBbXSwgdGVtcGxhdGU6IHRlbXBsYXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiBkYXRhWydpc0NvbXBvbmVudCddLFxyXG4gICAgICAgICAgICBkeW5hbWljTG9hZGFibGU6IGRhdGFbJ2R5bmFtaWNMb2FkYWJsZSddLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogZGF0YVsnc2VsZWN0b3InXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6IGRhdGFbJ2V4cG9ydEFzJ10sXHJcbiAgICAgICAgICAgIHR5cGU6IGxhbmdfMS5pc1ByZXNlbnQoZGF0YVsndHlwZSddKSA/IENvbXBpbGVUeXBlTWV0YWRhdGEuZnJvbUpzb24oZGF0YVsndHlwZSddKSA6IGRhdGFbJ3R5cGUnXSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBsYW5nXzEuaXNQcmVzZW50KGRhdGFbJ2NoYW5nZURldGVjdGlvbiddKSA/XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ0hBTkdFX0RFQ1RJT05fU1RSQVRFR1lfVkFMVUVTW2RhdGFbJ2NoYW5nZURldGVjdGlvbiddXSA6XHJcbiAgICAgICAgICAgICAgICBkYXRhWydjaGFuZ2VEZXRlY3Rpb24nXSxcclxuICAgICAgICAgICAgaW5wdXRzOiBkYXRhWydpbnB1dHMnXSxcclxuICAgICAgICAgICAgb3V0cHV0czogZGF0YVsnb3V0cHV0cyddLFxyXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBkYXRhWydob3N0TGlzdGVuZXJzJ10sXHJcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBkYXRhWydob3N0UHJvcGVydGllcyddLFxyXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogZGF0YVsnaG9zdEF0dHJpYnV0ZXMnXSxcclxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGRhdGFbJ2xpZmVjeWNsZUhvb2tzJ10ubWFwKGZ1bmN0aW9uIChob29rVmFsdWUpIHsgcmV0dXJuIGludGVyZmFjZXNfMS5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTW2hvb2tWYWx1ZV07IH0pLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbGFuZ18xLmlzUHJlc2VudChkYXRhWyd0ZW1wbGF0ZSddKSA/IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLmZyb21Kc29uKGRhdGFbJ3RlbXBsYXRlJ10pIDpcclxuICAgICAgICAgICAgICAgIGRhdGFbJ3RlbXBsYXRlJ11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnaXNDb21wb25lbnQnOiB0aGlzLmlzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAnZHluYW1pY0xvYWRhYmxlJzogdGhpcy5keW5hbWljTG9hZGFibGUsXHJcbiAgICAgICAgICAgICdzZWxlY3Rvcic6IHRoaXMuc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICdleHBvcnRBcyc6IHRoaXMuZXhwb3J0QXMsXHJcbiAgICAgICAgICAgICd0eXBlJzogbGFuZ18xLmlzUHJlc2VudCh0aGlzLnR5cGUpID8gdGhpcy50eXBlLnRvSnNvbigpIDogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAnY2hhbmdlRGV0ZWN0aW9uJzogbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNoYW5nZURldGVjdGlvbikgPyBsYW5nXzEuc2VyaWFsaXplRW51bSh0aGlzLmNoYW5nZURldGVjdGlvbikgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgICdpbnB1dHMnOiB0aGlzLmlucHV0cyxcclxuICAgICAgICAgICAgJ291dHB1dHMnOiB0aGlzLm91dHB1dHMsXHJcbiAgICAgICAgICAgICdob3N0TGlzdGVuZXJzJzogdGhpcy5ob3N0TGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAnaG9zdFByb3BlcnRpZXMnOiB0aGlzLmhvc3RQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAnaG9zdEF0dHJpYnV0ZXMnOiB0aGlzLmhvc3RBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAnbGlmZWN5Y2xlSG9va3MnOiB0aGlzLmxpZmVjeWNsZUhvb2tzLm1hcChmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gbGFuZ18xLnNlcmlhbGl6ZUVudW0oaG9vayk7IH0pLFxyXG4gICAgICAgICAgICAndGVtcGxhdGUnOiBsYW5nXzEuaXNQcmVzZW50KHRoaXMudGVtcGxhdGUpID8gdGhpcy50ZW1wbGF0ZS50b0pzb24oKSA6IHRoaXMudGVtcGxhdGVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xyXG5mdW5jdGlvbiBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wb25lbnRUeXBlLCBjb21wb25lbnRTZWxlY3Rvcikge1xyXG4gICAgdmFyIHRlbXBsYXRlID0gc2VsZWN0b3JfMS5Dc3NTZWxlY3Rvci5wYXJzZShjb21wb25lbnRTZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcclxuICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcclxuICAgICAgICB0eXBlOiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgIHJ1bnRpbWU6IE9iamVjdCxcclxuICAgICAgICAgICAgbmFtZTogXCJIb3N0XCIgKyBjb21wb25lbnRUeXBlLm5hbWUsXHJcbiAgICAgICAgICAgIG1vZHVsZVVybDogY29tcG9uZW50VHlwZS5tb2R1bGVVcmwsXHJcbiAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoeyB0ZW1wbGF0ZTogdGVtcGxhdGUsIHRlbXBsYXRlVXJsOiAnJywgc3R5bGVzOiBbXSwgc3R5bGVVcmxzOiBbXSwgbmdDb250ZW50U2VsZWN0b3JzOiBbXSB9KSxcclxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxyXG4gICAgICAgIGlucHV0czogW10sXHJcbiAgICAgICAgb3V0cHV0czogW10sXHJcbiAgICAgICAgaG9zdDoge30sXHJcbiAgICAgICAgbGlmZWN5Y2xlSG9va3M6IFtdLFxyXG4gICAgICAgIGlzQ29tcG9uZW50OiB0cnVlLFxyXG4gICAgICAgIGR5bmFtaWNMb2FkYWJsZTogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0b3I6ICcqJ1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVIb3N0Q29tcG9uZW50TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVfbWV0YWRhdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgSHRtbFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHRtbFRleHRBc3QodmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEh0bWxUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcclxuICAgIHJldHVybiBIdG1sVGV4dEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5IdG1sVGV4dEFzdCA9IEh0bWxUZXh0QXN0O1xyXG52YXIgSHRtbEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHRtbEF0dHJBc3QobmFtZSwgdmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgSHRtbEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpOyB9O1xyXG4gICAgcmV0dXJuIEh0bWxBdHRyQXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLkh0bWxBdHRyQXN0ID0gSHRtbEF0dHJBc3Q7XHJcbnZhciBIdG1sRWxlbWVudEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdG1sRWxlbWVudEFzdChuYW1lLCBhdHRycywgY2hpbGRyZW4sIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEh0bWxFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcclxuICAgIHJldHVybiBIdG1sRWxlbWVudEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5IdG1sRWxlbWVudEFzdCA9IEh0bWxFbGVtZW50QXN0O1xyXG5mdW5jdGlvbiBodG1sVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICB2YXIgYXN0UmVzdWx0ID0gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5odG1sVmlzaXRBbGwgPSBodG1sVmlzaXRBbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxfYXN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGh0bWxfYXN0XzEgPSByZXF1aXJlKCcuL2h0bWxfYXN0Jyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgTkdfTk9OX0JJTkRBQkxFID0gJ25nLW5vbi1iaW5kYWJsZSc7XHJcbnZhciBIdG1sUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEh0bWxQYXJzZXIoKSB7XHJcbiAgICB9XHJcbiAgICBIdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHZhciByb290ID0gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlVGVtcGxhdGUodGVtcGxhdGUpO1xyXG4gICAgICAgIHJldHVybiBwYXJzZUNoaWxkTm9kZXMocm9vdCwgc291cmNlSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgSHRtbFBhcnNlci5wcm90b3R5cGUudW5wYXJzZSA9IGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IFVucGFyc2VWaXNpdG9yKCk7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gW107XHJcbiAgICAgICAgaHRtbF9hc3RfMS5odG1sVmlzaXRBbGwodmlzaXRvciwgbm9kZXMsIHBhcnRzKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgSHRtbFBhcnNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgSHRtbFBhcnNlcik7XHJcbiAgICByZXR1cm4gSHRtbFBhcnNlcjtcclxufSkoKTtcclxuZXhwb3J0cy5IdG1sUGFyc2VyID0gSHRtbFBhcnNlcjtcclxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIGluZGV4SW5QYXJlbnQsIHBhcmVudFNvdXJjZUluZm8pIHtcclxuICAgIC8vIFRPRE8odGJvc2NoKTogYWRkIHNvdXJjZSByb3cvY29sdW1uIHNvdXJjZSBpbmZvIGZyb20gcGFyc2U1IC8gcGFja2FnZTpodG1sXHJcbiAgICB2YXIgdmFsdWUgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRUZXh0KHRleHQpO1xyXG4gICAgcmV0dXJuIG5ldyBodG1sX2FzdF8xLkh0bWxUZXh0QXN0KHZhbHVlLCBwYXJlbnRTb3VyY2VJbmZvICsgXCIgPiAjdGV4dChcIiArIHZhbHVlICsgXCIpOm50aC1jaGlsZChcIiArIGluZGV4SW5QYXJlbnQgKyBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyKGVsZW1lbnQsIHBhcmVudFNvdXJjZUluZm8sIGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcclxuICAgIC8vIFRPRE8odGJvc2NoKTogYWRkIHNvdXJjZSByb3cvY29sdW1uIHNvdXJjZSBpbmZvIGZyb20gcGFyc2U1IC8gcGFja2FnZTpodG1sXHJcbiAgICByZXR1cm4gbmV3IGh0bWxfYXN0XzEuSHRtbEF0dHJBc3QoYXR0ck5hbWUsIGF0dHJWYWx1ZSwgcGFyZW50U291cmNlSW5mbyArIFwiW1wiICsgYXR0ck5hbWUgKyBcIj1cIiArIGF0dHJWYWx1ZSArIFwiXVwiKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnQoZWxlbWVudCwgaW5kZXhJblBhcmVudCwgcGFyZW50U291cmNlSW5mbykge1xyXG4gICAgLy8gbm9ybWFsaXplIG5vZGVuYW1lIGFsd2F5cyBhcyBsb3dlciBjYXNlIHNvIHRoYXQgZm9sbG93aW5nIGJ1aWxkIHN0ZXBzXHJcbiAgICAvLyBjYW4gcmVseSBvbiB0aGlzXHJcbiAgICB2YXIgbm9kZU5hbWUgPSBkb21fYWRhcHRlcl8xLkRPTS5ub2RlTmFtZShlbGVtZW50KS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy8gVE9ETyh0Ym9zY2gpOiBhZGQgc291cmNlIHJvdy9jb2x1bW4gc291cmNlIGluZm8gZnJvbSBwYXJzZTUgLyBwYWNrYWdlOmh0bWxcclxuICAgIHZhciBzb3VyY2VJbmZvID0gcGFyZW50U291cmNlSW5mbyArIFwiID4gXCIgKyBub2RlTmFtZSArIFwiOm50aC1jaGlsZChcIiArIGluZGV4SW5QYXJlbnQgKyBcIilcIjtcclxuICAgIHZhciBhdHRycyA9IHBhcnNlQXR0cnMoZWxlbWVudCwgc291cmNlSW5mbyk7XHJcbiAgICB2YXIgY2hpbGROb2RlcyA9IHBhcnNlQ2hpbGROb2RlcyhlbGVtZW50LCBzb3VyY2VJbmZvKTtcclxuICAgIHJldHVybiBuZXcgaHRtbF9hc3RfMS5IdG1sRWxlbWVudEFzdChub2RlTmFtZSwgYXR0cnMsIGNoaWxkTm9kZXMsIHNvdXJjZUluZm8pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cnMoZWxlbWVudCwgZWxlbWVudFNvdXJjZUluZm8pIHtcclxuICAgIC8vIE5vdGU6IHNvcnQgdGhlIGF0dHJpYnV0ZXMgZWFybHkgaW4gdGhlIHBpcGVsaW5lIHRvIGdldFxyXG4gICAgLy8gY29uc2lzdGVudCByZXN1bHRzIHRocm91Z2hvdXQgdGhlIHBpcGVsaW5lLCBhcyBhdHRyaWJ1dGUgb3JkZXIgaXMgbm90IGRlZmluZWRcclxuICAgIC8vIGluIERPTSBwYXJzZXJzIVxyXG4gICAgdmFyIGF0dHJNYXAgPSBkb21fYWRhcHRlcl8xLkRPTS5hdHRyaWJ1dGVNYXAoZWxlbWVudCk7XHJcbiAgICB2YXIgYXR0ckxpc3QgPSBbXTtcclxuICAgIGF0dHJNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHsgcmV0dXJuIGF0dHJMaXN0LnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xyXG4gICAgYXR0ckxpc3Quc29ydChmdW5jdGlvbiAoZW50cnkxLCBlbnRyeTIpIHsgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNvbXBhcmUoZW50cnkxWzBdLCBlbnRyeTJbMF0pOyB9KTtcclxuICAgIHJldHVybiBhdHRyTGlzdC5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBwYXJzZUF0dHIoZWxlbWVudCwgZWxlbWVudFNvdXJjZUluZm8sIGVudHJ5WzBdLCBlbnRyeVsxXSk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ2hpbGROb2RlcyhlbGVtZW50LCBwYXJlbnRTb3VyY2VJbmZvKSB7XHJcbiAgICB2YXIgcm9vdCA9IGRvbV9hZGFwdGVyXzEuRE9NLnRlbXBsYXRlQXdhcmVSb290KGVsZW1lbnQpO1xyXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBkb21fYWRhcHRlcl8xLkRPTS5jaGlsZE5vZGVzQXNMaXN0KHJvb3QpO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIGNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNUZXh0Tm9kZShjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gY2hpbGROb2RlO1xyXG4gICAgICAgICAgICBjaGlsZFJlc3VsdCA9IHBhcnNlVGV4dCh0ZXh0LCBpbmRleCwgcGFyZW50U291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzRWxlbWVudE5vZGUoY2hpbGROb2RlKSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgIGNoaWxkUmVzdWx0ID0gcGFyc2VFbGVtZW50KGVsLCBpbmRleCwgcGFyZW50U291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoaWxkUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAvLyBXb24ndCBoYXZlIGEgY2hpbGRSZXN1bHQgZm9yIGUuZy4gY29tbWVudCBub2Rlc1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxudmFyIFVucGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVucGFyc2VWaXNpdG9yKCkge1xyXG4gICAgfVxyXG4gICAgVW5wYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcnRzKSB7XHJcbiAgICAgICAgcGFydHMucHVzaChcIjxcIiArIGFzdC5uYW1lKTtcclxuICAgICAgICB2YXIgYXR0cnMgPSBbXTtcclxuICAgICAgICBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuYXR0cnMsIGF0dHJzKTtcclxuICAgICAgICBpZiAoYXN0LmF0dHJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnICcpO1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGF0dHJzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcnRzLnB1c2goXCI+XCIpO1xyXG4gICAgICAgIGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgcGFydHMpO1xyXG4gICAgICAgIHBhcnRzLnB1c2goXCI8L1wiICsgYXN0Lm5hbWUgKyBcIj5cIik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVW5wYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIHBhcnRzKSB7XHJcbiAgICAgICAgcGFydHMucHVzaChhc3QubmFtZSArIFwiPVwiICsgdXRpbF8xLmVzY2FwZURvdWJsZVF1b3RlU3RyaW5nKGFzdC52YWx1ZSkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFVucGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJ0cykge1xyXG4gICAgICAgIHBhcnRzLnB1c2goYXN0LnZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW5wYXJzZVZpc2l0b3I7XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxfcGFyc2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9jb21waWxlcicpO1xyXG52YXIgcHJvdG9fdmlld19mYWN0b3J5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvcHJvdG9fdmlld19mYWN0b3J5Jyk7XHJcbnZhciB0ZW1wbGF0ZV9jb21waWxlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9jb21waWxlcicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBSdW50aW1lQ29tcGlsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJ1bnRpbWVDb21waWxlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJ1bnRpbWVDb21waWxlcigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSdW50aW1lQ29tcGlsZXI7XHJcbn0pKGNvbXBpbGVyXzEuQ29tcGlsZXIpO1xyXG5leHBvcnRzLlJ1bnRpbWVDb21waWxlciA9IFJ1bnRpbWVDb21waWxlcjtcclxudmFyIFJ1bnRpbWVDb21waWxlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJ1bnRpbWVDb21waWxlcl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXJfKF9wcm90b1ZpZXdGYWN0b3J5LCBfdGVtcGxhdGVDb21waWxlcikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9wcm90b1ZpZXdGYWN0b3J5KTtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbXBpbGVyID0gX3RlbXBsYXRlQ29tcGlsZXI7XHJcbiAgICB9XHJcbiAgICBSdW50aW1lQ29tcGlsZXJfLnByb3RvdHlwZS5jb21waWxlSW5Ib3N0ID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUNvbXBpbGVyLmNvbXBpbGVIb3N0Q29tcG9uZW50UnVudGltZShjb21wb25lbnRUeXBlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcGlsZWRIb3N0VGVtcGxhdGUpIHsgcmV0dXJuIGNvbXBpbGVyXzEuaW50ZXJuYWxDcmVhdGVQcm90b1ZpZXcoX3RoaXMsIGNvbXBpbGVkSG9zdFRlbXBsYXRlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbXBpbGVyXy5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbXBpbGVyLmNsZWFyQ2FjaGUoKTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lQ29tcGlsZXJfID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3Byb3RvX3ZpZXdfZmFjdG9yeV8xLlByb3RvVmlld0ZhY3RvcnksIHRlbXBsYXRlX2NvbXBpbGVyXzEuVGVtcGxhdGVDb21waWxlcl0pXHJcbiAgICBdLCBSdW50aW1lQ29tcGlsZXJfKTtcclxuICAgIHJldHVybiBSdW50aW1lQ29tcGlsZXJfO1xyXG59KShjb21waWxlcl8xLkNvbXBpbGVyXyk7XHJcbmV4cG9ydHMuUnVudGltZUNvbXBpbGVyXyA9IFJ1bnRpbWVDb21waWxlcl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWVfY29tcGlsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGNwbCA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX21ldGFkYXRhJyk7XHJcbnZhciBkaXJBbm4gPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS9kaXJlY3RpdmVzJyk7XHJcbnZhciBkaXJlY3RpdmVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci9kaXJlY3RpdmVfcmVzb2x2ZXInKTtcclxudmFyIHZpZXdfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X3Jlc29sdmVyJyk7XHJcbnZhciBkaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL2RpcmVjdGl2ZV9saWZlY3ljbGVfcmVmbGVjdG9yJyk7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvaW50ZXJmYWNlcycpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciBkaV8yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG4vLyBncm91cCAxOiBcInByb3BlcnR5XCIgZnJvbSBcIltwcm9wZXJ0eV1cIlxyXG4vLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxyXG52YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpJC9nO1xyXG52YXIgUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIoX2RpcmVjdGl2ZVJlc29sdmVyLCBfdmlld1Jlc29sdmVyKSB7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fdmlld1Jlc29sdmVyID0gX3ZpZXdSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIFJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9jYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1ldGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVBbm5vdGF0aW9uID0gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlKTtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZVVybCA9IGNhbGNNb2R1bGVVcmwoZGlyZWN0aXZlVHlwZSwgZGlyZWN0aXZlQW5ub3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGEgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlQW5ub3RhdGlvbiBpbnN0YW5jZW9mIGRpckFubi5Db21wb25lbnRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBBbm5vdGF0aW9uID0gZGlyZWN0aXZlQW5ub3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciB2aWV3QW5ub3RhdGlvbiA9IHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVNZXRhID0gbmV3IGNwbC5Db21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdmlld0Fubm90YXRpb24uZW5jYXBzdWxhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdmlld0Fubm90YXRpb24udGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHZpZXdBbm5vdGF0aW9uLnRlbXBsYXRlVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogdmlld0Fubm90YXRpb24uc3R5bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVXJsczogdmlld0Fubm90YXRpb24uc3R5bGVVcmxzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY29tcEFubm90YXRpb24uY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1ldGEgPSBjcGwuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlQW5ub3RhdGlvbi5zZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmVBbm5vdGF0aW9uLmV4cG9ydEFzLFxyXG4gICAgICAgICAgICAgICAgaXNDb21wb25lbnQ6IGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGVNZXRhKSxcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNMb2FkYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IG5ldyBjcGwuQ29tcGlsZVR5cGVNZXRhZGF0YSh7IG5hbWU6IGxhbmdfMS5zdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSksIG1vZHVsZVVybDogbW9kdWxlVXJsLCBydW50aW1lOiBkaXJlY3RpdmVUeXBlIH0pLFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGRpcmVjdGl2ZUFubm90YXRpb24uaW5wdXRzLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0czogZGlyZWN0aXZlQW5ub3RhdGlvbi5vdXRwdXRzLFxyXG4gICAgICAgICAgICAgICAgaG9zdDogZGlyZWN0aXZlQW5ub3RhdGlvbi5ob3N0LFxyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWx0ZXIoaW50ZXJmYWNlc18xLkxJRkVDWUNMRV9IT09LU19WQUxVRVMsIGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBkaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9vaywgZGlyZWN0aXZlVHlwZSk7IH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRhO1xyXG4gICAgfTtcclxuICAgIFJ1bnRpbWVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRWaWV3RGlyZWN0aXZlc01ldGFkYXRhID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZShjb21wb25lbnQpO1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gZmxhdHRlbkRpcmVjdGl2ZXModmlldyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZERpcmVjdGl2ZShkaXJlY3RpdmVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5leHBlY3RlZCBkaXJlY3RpdmUgdmFsdWUgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShkaXJlY3RpdmVzW2ldKSArIFwiJyBvbiB0aGUgVmlldyBvZiBjb21wb25lbnQgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnQpICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdmVEdXBsaWNhdGVkRGlyZWN0aXZlcyhkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuZ2V0TWV0YWRhdGEodHlwZSk7IH0pKTtcclxuICAgIH07XHJcbiAgICBSdW50aW1lTWV0YWRhdGFSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzIuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtkaXJlY3RpdmVfcmVzb2x2ZXJfMS5EaXJlY3RpdmVSZXNvbHZlciwgdmlld19yZXNvbHZlcl8xLlZpZXdSZXNvbHZlcl0pXHJcbiAgICBdLCBSdW50aW1lTWV0YWRhdGFSZXNvbHZlcik7XHJcbiAgICByZXR1cm4gUnVudGltZU1ldGFkYXRhUmVzb2x2ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUnVudGltZU1ldGFkYXRhUmVzb2x2ZXIgPSBSdW50aW1lTWV0YWRhdGFSZXNvbHZlcjtcclxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZERpcmVjdGl2ZXMoZGlyZWN0aXZlcykge1xyXG4gICAgdmFyIGRpcmVjdGl2ZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHsgZGlyZWN0aXZlc01hcC5zZXQoZGlyTWV0YS50eXBlLnJ1bnRpbWUsIGRpck1ldGEpOyB9KTtcclxuICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci52YWx1ZXMoZGlyZWN0aXZlc01hcCk7XHJcbn1cclxuZnVuY3Rpb24gZmxhdHRlbkRpcmVjdGl2ZXModmlldykge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZpZXcuZGlyZWN0aXZlcykpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBbXTtcclxuICAgIGZsYXR0ZW5MaXN0KHZpZXcuZGlyZWN0aXZlcywgZGlyZWN0aXZlcyk7XHJcbiAgICByZXR1cm4gZGlyZWN0aXZlcztcclxufVxyXG5mdW5jdGlvbiBmbGF0dGVuTGlzdCh0cmVlLCBvdXQpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBpdGVtID0gZGlfMS5yZXNvbHZlRm9yd2FyZFJlZih0cmVlW2ldKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkoaXRlbSkpIHtcclxuICAgICAgICAgICAgZmxhdHRlbkxpc3QoaXRlbSwgb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkRGlyZWN0aXZlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgJiYgKHZhbHVlIGluc3RhbmNlb2YgbGFuZ18xLlR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGNNb2R1bGVVcmwodHlwZSwgZGlyZWN0aXZlQW5ub3RhdGlvbikge1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyZWN0aXZlQW5ub3RhdGlvbi5tb2R1bGVJZCkpIHtcclxuICAgICAgICByZXR1cm4gXCJwYWNrYWdlOlwiICsgZGlyZWN0aXZlQW5ub3RhdGlvbi5tb2R1bGVJZCArIHV0aWxfMS5NT0RVTEVfU1VGRklYO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuaW1wb3J0VXJpKHR5cGUpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWVfbWV0YWRhdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMSA9IHJlcXVpcmUoJy4vZWxlbWVudF9zY2hlbWFfcmVnaXN0cnknKTtcclxudmFyIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvRWxlbWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLl9nZXRQcm90b0VsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fcHJvdG9FbGVtZW50cy5nZXQodGFnTmFtZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm90b0VsZW1lbnRzLnNldCh0YWdOYW1lLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSkge1xyXG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gY2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcclxuICAgICAgICAgICAgLy8gb25jZSBpdCBpcyBpbnN0YW50aWF0ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZWxtID0gdGhpcy5fZ2V0UHJvdG9FbGVtZW50KHRhZ05hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00uaGFzUHJvcGVydHkoZWxtLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICB2YXIgbWFwcGVkUHJvcE5hbWUgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoZG9tX2FkYXB0ZXJfMS5ET00uYXR0clRvUHJvcE1hcCwgcHJvcE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KG1hcHBlZFByb3BOYW1lKSA/IG1hcHBlZFByb3BOYW1lIDogcHJvcE5hbWU7XHJcbiAgICB9O1xyXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkpO1xyXG4gICAgcmV0dXJuIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcclxufSkoZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5FbGVtZW50U2NoZW1hUmVnaXN0cnkpO1xyXG5leHBvcnRzLkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcclxuICAgIH1cclxuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldE1hcHBlZFByb3BOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBwcm9wTmFtZTsgfTtcclxuICAgIHJldHVybiBFbGVtZW50U2NoZW1hUmVnaXN0cnk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X3NjaGVtYV9yZWdpc3RyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIF9FTVBUWV9BVFRSX1ZBTFVFID0gJyc7XHJcbi8vIFRPRE86IENhbid0IHVzZSBgY29uc3RgIGhlcmUgYXNcclxuLy8gaW4gRGFydCB0aGlzIGlzIG5vdCB0cmFuc3BpbGVkIGludG8gYGZpbmFsYCB5ZXQuLi5cclxudmFyIF9TRUxFQ1RPUl9SRUdFWFAgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJyhcXFxcOm5vdFxcXFwoKXwnICtcclxuICAgICcoWy1cXFxcd10rKXwnICtcclxuICAgICcoPzpcXFxcLihbLVxcXFx3XSspKXwnICtcclxuICAgICcoPzpcXFxcWyhbLVxcXFx3Kl0rKSg/Oj0oW15cXFxcXV0qKSk/XFxcXF0pfCcgK1xyXG4gICAgJyhcXFxcKSl8JyArXHJcbiAgICAnKFxcXFxzKixcXFxccyopJyk7IC8vIFwiLFwiXHJcbi8qKlxyXG4gKiBBIGNzcyBzZWxlY3RvciBjb250YWlucyBhbiBlbGVtZW50IG5hbWUsXHJcbiAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxyXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cclxuICovXHJcbnZhciBDc3NTZWxlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcclxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIHZhciBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XHJcbiAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgbGFuZ18xLmlzQmxhbmsoY3NzU2VsLmVsZW1lbnQpICYmXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShjc3NTZWwuY2xhc3NOYW1lcykgJiYgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkoY3NzU2VsLmF0dHJzKSkge1xyXG4gICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSBcIipcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXMucHVzaChjc3NTZWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XHJcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5tYXRjaGVyKF9TRUxFQ1RPUl9SRUdFWFAsIHNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcclxuICAgICAgICB2YXIgaW5Ob3QgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChtYXRjaCA9IGxhbmdfMS5SZWdFeHBNYXRjaGVyV3JhcHBlci5uZXh0KG1hdGNoZXIpKSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFsxXSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignTmVzdGluZyA6bm90IGlzIG5vdCBhbGxvd2VkIGluIGEgc2VsZWN0b3InKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcclxuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFszXSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFs0XSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs1XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hbNl0pKSB7XHJcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzddKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdNdWx0aXBsZSBzZWxlY3RvcnMgaW4gOm5vdCBhcmUgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3RvciA9IGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbGVtZW50KSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eSh0aGlzLmNsYXNzTmFtZXMpICYmXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pc0VtcHR5KHRoaXMuYXR0cnMpICYmIHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcclxuICAgIH07XHJcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkgeyBlbGVtZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEdldHMgYSB0ZW1wbGF0ZSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gKi9cclxuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5nZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFnTmFtZSA9IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbGVtZW50KSA/IHRoaXMuZWxlbWVudCA6ICdkaXYnO1xyXG4gICAgICAgIHZhciBjbGFzc0F0dHIgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID4gMCA/IFwiIGNsYXNzPVxcXCJcIiArIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIiA6ICcnO1xyXG4gICAgICAgIHZhciBhdHRycyA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLmF0dHJzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV0gIT09ICcnID8gXCI9XFxcIlwiICsgdGhpcy5hdHRyc1tpICsgMV0gKyBcIlxcXCJcIiA6ICcnO1xyXG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWdOYW1lICsgY2xhc3NBdHRyICsgYXR0cnMgKyBcIj48L1wiICsgdGFnTmFtZSArIFwiPlwiO1xyXG4gICAgfTtcclxuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IF9FTVBUWV9BVFRSX1ZBTFVFOyB9XHJcbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gX0VNUFRZX0FUVFJfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXR0cnMucHVzaCh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XHJcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9ICcnO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmVzICs9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jbGFzc05hbWVzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9ICcuJyArIHRoaXMuY2xhc3NOYW1lc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmF0dHJzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdGhpcy5hdHRyc1tpKytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRoaXMuYXR0cnNbaSsrXTtcclxuICAgICAgICAgICAgICAgIHJlcyArPSAnWycgKyBhdHRyTmFtZTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnPScgKyBhdHRyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJ10nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ3NzU2VsZWN0b3IgPSBDc3NTZWxlY3RvcjtcclxuLyoqXHJcbiAqIFJlYWRzIGEgbGlzdCBvZiBDc3NTZWxlY3RvcnMgYW5kIGFsbG93cyB0byBjYWxjdWxhdGUgd2hpY2ggb25lc1xyXG4gKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXHJcbiAqL1xyXG52YXIgU2VsZWN0b3JNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50TWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UGFydGlhbE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY2xhc3NNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzUGFydGlhbE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMgPSBbXTtcclxuICAgIH1cclxuICAgIFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyID0gZnVuY3Rpb24gKG5vdFNlbGVjdG9ycykge1xyXG4gICAgICAgIHZhciBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xyXG4gICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcclxuICAgIH07XHJcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XHJcbiAgICAgICAgdmFyIGxpc3RDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3JzW2ldLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cclxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrQ3R4dCBBbiBvcGFxdWUgb2JqZWN0IHRoYXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgY2FsbGJhY2sgb2YgdGhlIGBtYXRjaGAgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xyXG4gICAgICAgIHZhciBtYXRjaGVyID0gdGhpcztcclxuICAgICAgICB2YXIgZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xyXG4gICAgICAgIHZhciBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xyXG4gICAgICAgIHZhciBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjbGFzc05hbWVzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2xhc3NOYW1lcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGluZGV4ID09PSBjbGFzc05hbWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF0dHJzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXR0cnMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBpbmRleCA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGVybWluYWxNYXAuZ2V0KGF0dHJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGVybWluYWxWYWx1ZXNNYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxNYXAuc2V0KGF0dHJOYW1lLCB0ZXJtaW5hbFZhbHVlc01hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCBhdHRyVmFsdWUsIHNlbGVjdGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnR0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHBhcnR0aWFsTWFwLmdldChhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcnRpYWxWYWx1ZXNNYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxWYWx1ZXNNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0dGlhbE1hcC5zZXQoYXR0ck5hbWUsIHBhcnRpYWxWYWx1ZXNNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCBhdHRyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xyXG4gICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0ZXJtaW5hbExpc3QpKSB7XHJcbiAgICAgICAgICAgIHRlcm1pbmFsTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlcm1pbmFsTGlzdC5wdXNoKHNlbGVjdGFibGUpO1xyXG4gICAgfTtcclxuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBtYXAuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXRjaGVyKSkge1xyXG4gICAgICAgICAgICBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xyXG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIG1hdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxyXG4gICAgICogd2hvc2UgY3NzIHNlbGVjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxyXG4gICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxyXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgYSBtYXRjaCB3YXMgZm91bmRcclxuICAgICovXHJcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcclxuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHNbaV0uYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxyXG4gICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2xhc3NOYW1lcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdHRycykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJzLmxlbmd0aDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJzW2luZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlTWFwLmdldChhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhhdHRyVmFsdWUsIF9FTVBUWV9BVFRSX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIF9FTVBUWV9BVFRSX1ZBTFVFLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCBhdHRyVmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhhdHRyVmFsdWUsIF9FTVBUWV9BVFRSX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCBfRU1QVFlfQVRUUl9WQUxVRSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgYXR0clZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXApIHx8IGxhbmdfMS5pc0JsYW5rKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdGFibGVzID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICB2YXIgc3RhclNlbGVjdGFibGVzID0gbWFwLmdldChcIipcIik7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RhclNlbGVjdGFibGVzKSkge1xyXG4gICAgICAgICAgICBzZWxlY3RhYmxlcyA9IHNlbGVjdGFibGVzLmNvbmNhdChzdGFyU2VsZWN0YWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoc2VsZWN0YWJsZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdGFibGU7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2luZGV4XTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayAvKjogKGM6IENzc1NlbGVjdG9yLCBhOiBhbnkpID0+IHZvaWQqLykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXApIHx8IGxhbmdfMS5pc0JsYW5rKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobmVzdGVkU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZ2V0IHJpZCBvZiByZWN1cnNpb24gYW5kIG1lYXN1cmUgYWdhaW5cclxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBkb24ndCBwYXNzIHRoZSB3aG9sZSBzZWxlY3RvciBpbnRvIHRoZSByZWN1cnNpb24sXHJcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcclxuICAgICAgICByZXR1cm4gbmVzdGVkU2VsZWN0b3IubWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNlbGVjdG9yTWF0Y2hlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TZWxlY3Rvck1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXI7XHJcbnZhciBTZWxlY3Rvckxpc3RDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTGlzdENvbnRleHQoc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XHJcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZWN0b3JMaXN0Q29udGV4dCA9IFNlbGVjdG9yTGlzdENvbnRleHQ7XHJcbi8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXHJcbnZhciBTZWxlY3RvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0b3JDb250ZXh0KHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgIHRoaXMuY2JDb250ZXh0ID0gY2JDb250ZXh0O1xyXG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcclxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcclxuICAgIH1cclxuICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgKGxhbmdfMS5pc0JsYW5rKHRoaXMubGlzdENvbnRleHQpIHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xyXG4gICAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gIW5vdE1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0ICYmIGxhbmdfMS5pc1ByZXNlbnQoY2FsbGJhY2spICYmXHJcbiAgICAgICAgICAgIChsYW5nXzEuaXNCbGFuayh0aGlzLmxpc3RDb250ZXh0KSB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5saXN0Q29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuc2VsZWN0b3IsIHRoaXMuY2JDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGVjdG9yQ29udGV4dCA9IFNlbGVjdG9yQ29udGV4dDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFRoaXMgZmlsZSBpcyBhIHBvcnQgb2Ygc2hhZG93Q1NTIGZyb20gd2ViY29tcG9uZW50cy5qcyB0byBUeXBlU2NyaXB0LlxyXG4gKlxyXG4gKiBQbGVhc2UgbWFrZSBzdXJlIHRvIGtlZXAgdG8gZWRpdHMgaW4gc3luYyB3aXRoIHRoZSBzb3VyY2UgZmlsZS5cclxuICpcclxuICogU291cmNlOlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi80ZWZlY2Q3ZTBlL3NyYy9TaGFkb3dDU1MvU2hhZG93Q1NTLmpzXHJcbiAqXHJcbiAqIFRoZSBvcmlnaW5hbCBmaWxlIGxldmVsIGNvbW1lbnQgaXMgcmVwcm9kdWNlZCBiZWxvd1xyXG4gKi9cclxuLypcclxuICBUaGlzIGlzIGEgbGltaXRlZCBzaGltIGZvciBTaGFkb3dET00gY3NzIHN0eWxpbmcuXHJcbiAgaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy93ZWJjb21wb25lbnRzL3Jhdy1maWxlL3RpcC9zcGVjL3NoYWRvdy9pbmRleC5odG1sI3N0eWxlc1xyXG5cclxuICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxyXG4gIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcclxuICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXHJcbiAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xyXG4gIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxyXG5cclxuICBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiBzcGVjaWZpYyBTaGFkb3dET00gc3R5bGluZyBmZWF0dXJlcyBhbmQgYSBicmllZlxyXG4gIGRpc2N1c3Npb24gb2YgdGhlIGFwcHJvYWNoIHVzZWQgdG8gc2hpbS5cclxuXHJcbiAgU2hpbW1lZCBmZWF0dXJlczpcclxuXHJcbiAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxyXG4gIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxyXG4gIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxyXG4gIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXHJcbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxyXG5cclxuICAgIDpob3N0IHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgYmVjb21lczpcclxuXHJcbiAgICAuZm9vIHtcclxuICAgICAgYmFja2dyb3VuZDogcmVkO1xyXG4gICAgfVxyXG5cclxuICAqIGVuY2Fwc3VsdGlvbjogU3R5bGVzIGRlZmluZWQgd2l0aGluIFNoYWRvd0RPTSwgYXBwbHkgb25seSB0b1xyXG4gIGRvbSBpbnNpZGUgdGhlIFNoYWRvd0RPTS4gUG9seW1lciB1c2VzIG9uZSBvZiB0d28gdGVjaG5pcXVlcyB0byBpbWxlbWVudFxyXG4gIHRoaXMgZmVhdHVyZS5cclxuXHJcbiAgQnkgZGVmYXVsdCwgcnVsZXMgYXJlIHByZWZpeGVkIHdpdGggdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZVxyXG4gIGFzIGEgZGVzY2VuZGFudCBzZWxlY3Rvci4gVGhpcyBlbnN1cmVzIHN0eWxpbmcgZG9lcyBub3QgbGVhayBvdXQgb2YgdGhlICd0b3AnXHJcbiAgb2YgdGhlIGVsZW1lbnQncyBTaGFkb3dET00uIEZvciBleGFtcGxlLFxyXG5cclxuICBkaXYge1xyXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIH1cclxuXHJcbiAgYmVjb21lczpcclxuXHJcbiAgeC1mb28gZGl2IHtcclxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICB9XHJcblxyXG4gIGJlY29tZXM6XHJcblxyXG5cclxuICBBbHRlcm5hdGl2ZWx5LCBpZiBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5zdHJpY3RTdHlsaW5nIGlzIHNldCB0byB0cnVlIHRoZW5cclxuICBzZWxlY3RvcnMgYXJlIHNjb3BlZCBieSBhZGRpbmcgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHN1ZmZpeCB0byBlYWNoXHJcbiAgc2ltcGxlIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZS4gRWFjaCBlbGVtZW50XHJcbiAgaW4gdGhlIGVsZW1lbnQncyBTaGFkb3dET00gdGVtcGxhdGUgaXMgYWxzbyBnaXZlbiB0aGUgc2NvcGUgYXR0cmlidXRlLlxyXG4gIFRodXMsIHRoZXNlIHJ1bGVzIG1hdGNoIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBzY29wZSBhdHRyaWJ1dGUuXHJcbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiB4LWZvbywgYSBydWxlIGxpa2UgdGhpczpcclxuXHJcbiAgICBkaXYge1xyXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIH1cclxuXHJcbiAgYmVjb21lczpcclxuXHJcbiAgICBkaXZbeC1mb29dIHtcclxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICB9XHJcblxyXG4gIE5vdGUgdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBkeW5hbWljYWxseSBhZGRlZCB0byBhIHNjb3BlIG11c3QgaGF2ZSB0aGUgc2NvcGVcclxuICBzZWxlY3RvciBhZGRlZCB0byB0aGVtIG1hbnVhbGx5LlxyXG5cclxuICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcclxuICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxyXG4gIGluc2lkZSBhIHNoYWRvd1Jvb3QuXHJcblxyXG4gIFRoaXMgc3R5bGluZyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIFNvbWUgcG9zc2libGUgd2F5cyB0byBkbyB0aGlzIHRoYXRcclxuICB3ZXJlIHJlamVjdGVkIGR1ZSB0byBjb21wbGV4aXR5IGFuZC9vciBwZXJmb3JtYW5jZSBjb25jZXJucyBpbmNsdWRlOiAoMSkgcmVzZXRcclxuICBldmVyeSBwb3NzaWJsZSBwcm9wZXJ0eSBmb3IgZXZlcnkgcG9zc2libGUgc2VsZWN0b3IgZm9yIGEgZ2l2ZW4gc2NvcGUgbmFtZTtcclxuICAoMikgcmUtaW1wbGVtZW50IGNzcyBpbiBqYXZhc2NyaXB0LlxyXG5cclxuICBBcyBhbiBhbHRlcm5hdGl2ZSwgdXNlcnMgc2hvdWxkIG1ha2Ugc3VyZSB0byB1c2Ugc2VsZWN0b3JzXHJcbiAgc3BlY2lmaWMgdG8gdGhlIHNjb3BlIGluIHdoaWNoIHRoZXkgYXJlIHdvcmtpbmcuXHJcblxyXG4gICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxyXG4gIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcclxuICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxyXG4gIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcclxuICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XHJcblxyXG4gICAgPHN0eWxlPlxyXG4gICAgICA6OmNvbnRlbnQoZGl2KSB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xyXG4gICAgICB9XHJcbiAgICA8L3N0eWxlPlxyXG4gICAgPGNvbnRlbnQ+PC9jb250ZW50PlxyXG5cclxuICBjb3VsZCBiZWNvbWU6XHJcblxyXG4gICAgPHN0eWxlPlxyXG4gICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cclxuICAgICAgOjpjb250ZW50KGRpdikge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcclxuICAgICAgfVxyXG4gICAgPC9zdHlsZT5cclxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxyXG4gICAgICA8Y29udGVudD48L2NvbnRlbnQ+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgTm90ZSB0aGUgdXNlIG9mIEBwb2x5ZmlsbCBpbiB0aGUgY29tbWVudCBhYm92ZSBhIFNoYWRvd0RPTSBzcGVjaWZpYyBzdHlsZVxyXG4gIGRlY2xhcmF0aW9uLiBUaGlzIGlzIGEgZGlyZWN0aXZlIHRvIHRoZSBzdHlsaW5nIHNoaW0gdG8gdXNlIHRoZSBzZWxlY3RvclxyXG4gIGluIGNvbW1lbnRzIGluIGxpZXUgb2YgdGhlIG5leHQgc2VsZWN0b3Igd2hlbiBydW5uaW5nIHVuZGVyIHBvbHlmaWxsLlxyXG4qL1xyXG52YXIgU2hhZG93Q3NzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNoYWRvd0NzcygpIHtcclxuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICogU2hpbSBhIHN0eWxlIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgY3NzVGV4dCB0aGF0IGNhblxyXG4gICAgKiBiZSBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQgdmlhIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLmFkZENzc1RvRG9jdW1lbnQoY3NzKS5cclxuICAgICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChob3N0U2VsZWN0b3IgPT09IHZvaWQgMCkgeyBob3N0U2VsZWN0b3IgPSAnJzsgfVxyXG4gICAgICAgIHZhciBjc3NUZXh0ID0gZG9tX2FkYXB0ZXJfMS5ET00uZ2V0VGV4dChzdHlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpbUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICogU2hpbSBzb21lIGNzc1RleHQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgY3NzVGV4dCB0aGF0IGNhblxyXG4gICAgKiBiZSBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQgdmlhIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLmFkZENzc1RvRG9jdW1lbnQoY3NzKS5cclxuICAgICpcclxuICAgICogV2hlbiBzdHJpY3RTdHlsaW5nIGlzIHRydWU6XHJcbiAgICAqIC0gc2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIHRoZSBob3N0LFxyXG4gICAgKiAtIGhvc3RTZWxlY3RvciBpcyB0aGUgYXR0cmlidXRlIGFkZGVkIHRvIHRoZSBob3N0IGl0c2VsZi5cclxuICAgICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoaG9zdFNlbGVjdG9yID09PSB2b2lkIDApIHsgaG9zdFNlbGVjdG9yID0gJyc7IH1cclxuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGNvbnZlcnQgbmF0aXZlIFNoYWRvd0RPTSBydWxlcyB0aGF0IHdpbGwgdHJpcFxyXG4gICAgICogdXAgdGhlIGNzcyBwYXJzZXI7IHdlIHJlbHkgb24gZGVjb3JhdGluZyB0aGUgc3R5bGVzaGVldCB3aXRoIGluZXJ0IHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcclxuICAgICAqXHJcbiAgICAgKiBwb2x5ZmlsbC1uZXh0LXNlbGVjdG9yIHsgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7IH1cclxuICAgICAqIDo6Y29udGVudCBtZW51LWl0ZW0ge1xyXG4gICAgICpcclxuICAgICAqIHRvIHRoaXM6XHJcbiAgICAgKlxyXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7XHJcbiAgICAgKlxyXG4gICAgKiovXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcclxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXSArICd7JzsgfSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxyXG4gICAgICpcclxuICAgICAqIHBvbHlmaWxsLXJ1bGUge1xyXG4gICAgICogICBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJztcclxuICAgICAqIC4uLlxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHRvIHRoaXM6XHJcbiAgICAgKlxyXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7Li4ufVxyXG4gICAgICpcclxuICAgICoqL1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGNzc1RleHQsIF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF07XHJcbiAgICAgICAgICAgIHJ1bGUgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHJ1bGUsIG1bMV0sICcnKTtcclxuICAgICAgICAgICAgcnVsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocnVsZSwgbVsyXSwgJycpO1xyXG4gICAgICAgICAgICByZXR1cm4gbVszXSArIHJ1bGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogRW5zdXJlIHN0eWxlcyBhcmUgc2NvcGVkLiBQc2V1ZG8tc2NvcGluZyB0YWtlcyBhIHJ1bGUgbGlrZTpcclxuICAgICAqXHJcbiAgICAgKiAgLmZvbyB7Li4uIH1cclxuICAgICAqXHJcbiAgICAgKiAgYW5kIGNvbnZlcnRzIHRoaXMgdG9cclxuICAgICAqXHJcbiAgICAgKiAgc2NvcGVOYW1lIC5mb28geyAuLi4gfVxyXG4gICAgKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1bnNjb3BlZCA9IHRoaXMuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQoY3NzVGV4dCk7XHJcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcclxuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdChjc3NUZXh0KTtcclxuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XHJcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc2NvcGVTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgX3dpdGhDc3NSdWxlcyhjc3NUZXh0LCBmdW5jdGlvbiAocnVsZXMpIHsgY3NzVGV4dCA9IF90aGlzLl9zY29wZVJ1bGVzKHJ1bGVzLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkO1xyXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gYWRkIHJ1bGVzIHdoaWNoIHdpbGwgb25seSBhcHBseSB1bmRlciB0aGUgcG9seWZpbGxcclxuICAgICAqIGFuZCBkbyBub3QgcHJvY2VzcyB2aWEgQ1NTT00uIChDU1NPTSBpcyBkZXN0cnVjdGl2ZSB0byBydWxlcyBvbiByYXJlXHJcbiAgICAgKiBvY2Nhc2lvbnMsIGUuZy4gLXdlYmtpdC1jYWxjIG9uIFNhZmFyaS4pXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XHJcbiAgICAgKlxyXG4gICAgICogQHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUge1xyXG4gICAgICogICBjb250ZW50OiAnbWVudS1pdGVtJztcclxuICAgICAqIC4uLiB9XHJcbiAgICAgKlxyXG4gICAgICogdG8gdGhpczpcclxuICAgICAqXHJcbiAgICAgKiBtZW51LWl0ZW0gey4uLn1cclxuICAgICAqXHJcbiAgICAqKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcclxuICAgICAgICB2YXIgciA9ICcnLCBtO1xyXG4gICAgICAgIHZhciBtYXRjaGVyID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIubWF0Y2hlcihfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLCBjc3NUZXh0KTtcclxuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChtID0gbGFuZ18xLlJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQobWF0Y2hlcikpKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlID0gbVswXTtcclxuICAgICAgICAgICAgcnVsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocnVsZSwgbVsyXSwgJycpO1xyXG4gICAgICAgICAgICBydWxlID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZShydWxlLCBtWzFdLCBtWzNdKTtcclxuICAgICAgICAgICAgciArPSBydWxlICsgJ1xcblxcbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cclxuICAgICAqXHJcbiAgICAgKiB0b1xyXG4gICAgICpcclxuICAgICAqIHNjb3BlTmFtZS5mb28gPiAuYmFyXHJcbiAgICAqL1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdFJlLCB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0LWNvbnRleHQoLmZvbykgPiAuYmFyIHsgfVxyXG4gICAgICpcclxuICAgICAqIHRvXHJcbiAgICAgKlxyXG4gICAgICogc2NvcGVOYW1lLmZvbyA+IC5iYXIsIC5mb28gc2NvcGVOYW1lID4gLmJhciB7IH1cclxuICAgICAqXHJcbiAgICAgKiBhbmRcclxuICAgICAqXHJcbiAgICAgKiA6aG9zdC1jb250ZXh0KC5mb286aG9zdCkgLmJhciB7IC4uLiB9XHJcbiAgICAgKlxyXG4gICAgICogdG9cclxuICAgICAqXHJcbiAgICAgKiBzY29wZU5hbWUuZm9vIC5iYXIgeyAuLi4gfVxyXG4gICAgKi9cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25SdWxlID0gZnVuY3Rpb24gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSB7XHJcbiAgICAgICAgLy8gcDEgPSA6aG9zdCwgcDIgPSBjb250ZW50cyBvZiAoKSwgcDMgcmVzdCBvZiBydWxlXHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoY3NzVGV4dCwgcmVnRXhwLCBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbVsyXS5zcGxpdCgnLCcpLCByID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgbVszXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIgPSBmdW5jdGlvbiAoaG9zdCwgcGFydCwgc3VmZml4KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNvbnRhaW5zKHBhcnQsIF9wb2x5ZmlsbEhvc3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xyXG4gICAgICAgIHJldHVybiBob3N0ICsgbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZShwYXJ0LCBfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XHJcbiAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cclxuICAgICovXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zaGFkb3dET01TZWxlY3RvcnNSZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjc3NUZXh0ID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChjc3NUZXh0LCBfc2hhZG93RE9NU2VsZWN0b3JzUmVbaV0sICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgfTtcclxuICAgIC8vIGNoYW5nZSBhIHNlbGVjdG9yIGxpa2UgJ2RpdicgdG8gJ25hbWUgZGl2J1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVSdWxlcyA9IGZ1bmN0aW9uIChjc3NSdWxlcywgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIGNzc1RleHQgPSAnJztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjc3NSdWxlcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3NSdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBjc3NSdWxlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChkb21fYWRhcHRlcl8xLkRPTS5pc1N0eWxlUnVsZShydWxlKSB8fCBkb21fYWRhcHRlcl8xLkRPTS5pc1BhZ2VSdWxlKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSB0aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3JUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IsIHRoaXMuc3RyaWN0U3R5bGluZykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHtcXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGNzc1RleHQgKz0gdGhpcy5fcHJvcGVydGllc0Zyb21SdWxlKHJ1bGUpICsgJ1xcbn1cXG5cXG4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNNZWRpYVJ1bGUocnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9ICdAbWVkaWEgJyArIHJ1bGUubWVkaWEubWVkaWFUZXh0ICsgJyB7XFxuJztcclxuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuX3Njb3BlUnVsZXMocnVsZS5jc3NSdWxlcywgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9ICdcXG59XFxuXFxuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEtFWUZSQU1FU19SVUxFIGluIElFIHRocm93cyB3aGVuIHdlIHF1ZXJ5IGNzc1RleHRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IGNvbnRhaW5zIGEgLXdlYmtpdC0gcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBoYXBwZW5zLCB3ZSBmYWxsYmFjayB0byBjb25zdHJ1Y3RpbmcgdGhlIHJ1bGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBDU1NSdWxlU2V0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2tkZXRhaWwvdmlldy85NTU3MDMvYWNjZXNzaW5nLWNzc3RleHQtb2YtYS1rZXlmcmFtZS1ydWxlLXRoYXQtY29udGFpbnMtYS13ZWJraXQtcHJvcGVydHktdmlhLWNzc29tLWdlbmVyYXRlcy1leGNlcHRpb25cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChydWxlLmNzc1RleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9IHJ1bGUuY3NzVGV4dCArICdcXG5cXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21fYWRhcHRlcl8xLkRPTS5pc0tleWZyYW1lc1J1bGUocnVsZSkgJiYgbGFuZ18xLmlzUHJlc2VudChydWxlLmNzc1J1bGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCArPSB0aGlzLl9pZVNhZmVDc3NUZXh0RnJvbUtleUZyYW1lUnVsZShydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3NzVGV4dDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pZVNhZmVDc3NUZXh0RnJvbUtleUZyYW1lUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgdmFyIGNzc1RleHQgPSAnQGtleWZyYW1lcyAnICsgcnVsZS5uYW1lICsgJyB7JztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGUuY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBydWxlLmNzc1J1bGVzW2ldO1xyXG4gICAgICAgICAgICBjc3NUZXh0ICs9ICcgJyArIHIua2V5VGV4dCArICcgeycgKyByLnN0eWxlLmNzc1RleHQgKyAnfSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNzc1RleHQgKz0gJyB9JztcclxuICAgICAgICByZXR1cm4gY3NzVGV4dDtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IsIHN0cmljdCkge1xyXG4gICAgICAgIHZhciByID0gW10sIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoJywnKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgIHAgPSBwLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHAsIHNjb3BlU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gc3RyaWN0ICYmICFsYW5nXzEuU3RyaW5nV3JhcHBlci5jb250YWlucyhwLCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHAsIHNjb3BlU2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByLnB1c2gocCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByLmpvaW4oJywgJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2VsZWN0b3JOZWVkc1Njb3BpbmcgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiAhbGFuZ18xLmlzUHJlc2VudChsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKHJlLCBzZWxlY3RvcikpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX21ha2VTY29wZU1hdGNoZXIgPSBmdW5jdGlvbiAoc2NvcGVTZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBscmUgPSAvXFxbL2c7XHJcbiAgICAgICAgdmFyIHJyZSA9IC9cXF0vZztcclxuICAgICAgICBzY29wZVNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzY29wZVNlbGVjdG9yLCBscmUsICdcXFxcWycpO1xyXG4gICAgICAgIHNjb3BlU2VsZWN0b3IgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHNjb3BlU2VsZWN0b3IsIHJyZSwgJ1xcXFxdJyk7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHNqczogc2NvcGVTZWxlY3RvciBjb3VsZCBub3QgYmUgYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xyXG4gICAgfTtcclxuICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChfcG9seWZpbGxIb3N0UmUsIHNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IFwiW1wiICsgaG9zdFNlbGVjdG9yICsgXCJdXCIgOiBzY29wZVNlbGVjdG9yO1xyXG4gICAgICAgICAgICBzZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2Uoc2VsZWN0b3IsIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHJlcGxhY2VCeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHNlbGVjdG9yLCBfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeSArICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcclxuICAgIC8vIGUuZy4gLmZvby5iYXIgPiAuem90IGJlY29tZXMgLmZvb1tuYW1lXS5iYXJbbmFtZV0gPiAuem90W25hbWVdXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcclxuICAgICAgICBzY29wZVNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChzY29wZVNlbGVjdG9yLCBpc1JlLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXTsgfSk7XHJcbiAgICAgICAgdmFyIHNwbGl0cyA9IFsnICcsICc+JywgJysnLCAnfiddLCBzY29wZWQgPSBzZWxlY3RvciwgYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXAgPSBzcGxpdHNbaV07XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNjb3BlZC5zcGxpdChzZXApO1xyXG4gICAgICAgICAgICBzY29wZWQgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChwLnRyaW0oKSwgX3BvbHlmaWxsSG9zdFJlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPiAwICYmICFjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnMoc3BsaXRzLCB0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFsYW5nXzEuU3RyaW5nV3JhcHBlci5jb250YWlucyh0LCBhdHRyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSAvKFteOl0qKSg6KikoLiopL2c7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKHJlLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gbVsxXSArIGF0dHJOYW1lICsgbVsyXSArIG1bM107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuam9pbihzZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2NvcGVkO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzZWxlY3RvciwgX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpO1xyXG4gICAgICAgIHNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzZWxlY3RvciwgX2NvbG9uSG9zdFJlLCBfcG9seWZpbGxIb3N0KTtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fcHJvcGVydGllc0Zyb21SdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgICB2YXIgY3NzVGV4dCA9IHJ1bGUuc3R5bGUuY3NzVGV4dDtcclxuICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBTYWZhcmkgY3Nzb20gaW5jb3JyZWN0bHkgcmVtb3ZlcyBxdW90ZXMgZnJvbSB0aGUgY29udGVudFxyXG4gICAgICAgIC8vIHByb3BlcnR5LiAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExODA0NSlcclxuICAgICAgICAvLyBkb24ndCByZXBsYWNlIGF0dHIgcnVsZXNcclxuICAgICAgICB2YXIgYXR0clJlID0gL1snXCJdK3xhdHRyL2c7XHJcbiAgICAgICAgaWYgKHJ1bGUuc3R5bGUuY29udGVudC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICFsYW5nXzEuaXNQcmVzZW50KGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goYXR0clJlLCBydWxlLnN0eWxlLmNvbnRlbnQpKSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFJlID0gL2NvbnRlbnQ6W147XSo7L2c7XHJcbiAgICAgICAgICAgIGNzc1RleHQgPVxyXG4gICAgICAgICAgICAgICAgbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChjc3NUZXh0LCBjb250ZW50UmUsICdjb250ZW50OiBcXCcnICsgcnVsZS5zdHlsZS5jb250ZW50ICsgJ1xcJzsnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogd2UgY2FuIHdvcmthcm91bmQgdGhpcyBpc3N1ZSBoZXJlLCBidXQgd2UgbmVlZCBhIGxpc3RcclxuICAgICAgICAvLyBvZiB0cm91Ymxlc29tZSBwcm9wZXJ0aWVzIHRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wbGF0Zm9ybS9pc3N1ZXMvNTNcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGluaGVyaXQgcnVsZXMgY2FuIGJlIG9taXR0ZWQgZnJvbSBjc3NUZXh0XHJcbiAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogcmVtb3ZlIHdoZW4gQmxpbmsgYnVnIGlzIGZpeGVkOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTgyNzNcclxuICAgICAgICAvLyB2YXIgc3R5bGUgPSBydWxlLnN0eWxlO1xyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgdmFyIG5hbWUgPSBzdHlsZS5pdGVtKGkpO1xyXG4gICAgICAgIC8vICB2YXIgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xyXG4gICAgICAgIC8vICBpZiAodmFsdWUgPT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgLy8gICAgY3NzVGV4dCArPSBuYW1lICsgJzogaW5pdGlhbDsgJztcclxuICAgICAgICAvLyAgfVxyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFkb3dDc3M7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2hhZG93Q3NzID0gU2hhZG93Q3NzO1xyXG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj9bJ1wiXSguKj8pWydcIl1bO1xcc10qfShbXntdKj8pey9naW07XHJcbnZhciBfY3NzQ29udGVudFJ1bGVSZSA9IC8ocG9seWZpbGwtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKlsnXCJdKC4qPylbJ1wiXSlbO1xcc10qW159XSp9L2dpbTtcclxudmFyIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUgPSAvKHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUpW159XSooY29udGVudDpbXFxzXSpbJ1wiXSguKj8pWydcIl0pWztcXHNdKltefV0qfS9naW07XHJcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0JztcclxuLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cclxudmFyIF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcclxudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXHJcbiAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcclxuICAgICcpXFxcXCkpPyhbXix7XSopJztcclxudmFyIF9jc3NDb2xvbkhvc3RSZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnKCcgKyBfcG9seWZpbGxIb3N0ICsgX3BhcmVuU3VmZml4LCAnaW0nKTtcclxudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJygnICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsICdpbScpO1xyXG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xyXG52YXIgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gW1xyXG4gICAgLz4+Pi9nLFxyXG4gICAgLzo6c2hhZG93L2csXHJcbiAgICAvOjpjb250ZW50L2csXHJcbiAgICAvLyBEZXByZWNhdGVkIHNlbGVjdG9yc1xyXG4gICAgLy8gVE9ETyh2aWNiKTogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NsYW5nLWZvcm1hdC9pc3N1ZXMvMTZcclxuICAgIC8vIGNsYW5nLWZvcm1hdCBvZmZcclxuICAgIC9cXC9kZWVwXFwvL2csXHJcbiAgICAvXFwvc2hhZG93LWRlZXBcXC8vZyxcclxuICAgIC9cXC9zaGFkb3dcXC8vZyxcclxuXTtcclxudmFyIF9zZWxlY3RvclJlU3VmZml4ID0gJyhbPlxcXFxzfitcXFsuLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xyXG52YXIgX3BvbHlmaWxsSG9zdFJlID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKF9wb2x5ZmlsbEhvc3QsICdpbScpO1xyXG52YXIgX2NvbG9uSG9zdFJlID0gLzpob3N0L2dpbTtcclxudmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XHJcbmZ1bmN0aW9uIF9jc3NUb1J1bGVzKGNzc1RleHQpIHtcclxuICAgIHJldHVybiBkb21fYWRhcHRlcl8xLkRPTS5jc3NUb1J1bGVzKGNzc1RleHQpO1xyXG59XHJcbmZ1bmN0aW9uIF93aXRoQ3NzUnVsZXMoY3NzVGV4dCwgY2FsbGJhY2spIHtcclxuICAgIC8vIERpZmZlcmVuY2UgZnJvbSB3ZWJjb21wb25lbnRqczogcmVtb3ZlIHRoZSB3b3JrYXJvdW5kIGZvciBhbiBvbGQgYnVnIGluIENocm9tZVxyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNhbGxiYWNrKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgcnVsZXMgPSBfY3NzVG9SdWxlcyhjc3NUZXh0KTtcclxuICAgIGNhbGxiYWNrKHJ1bGVzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3dfY3NzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIE1PRFVMRV9SRUdFWFAgPSAvI01PRFVMRVxcWyhbXlxcXV0qKVxcXS9nO1xyXG5mdW5jdGlvbiBtb2R1bGVSZWYobW9kdWxlVXJsKSB7XHJcbiAgICByZXR1cm4gXCIjTU9EVUxFW1wiICsgbW9kdWxlVXJsICsgXCJdXCI7XHJcbn1cclxuZXhwb3J0cy5tb2R1bGVSZWYgPSBtb2R1bGVSZWY7XHJcbnZhciBTb3VyY2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU291cmNlTW9kdWxlKG1vZHVsZVVybCwgc291cmNlV2l0aE1vZHVsZVJlZnMpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcclxuICAgICAgICB0aGlzLnNvdXJjZVdpdGhNb2R1bGVSZWZzID0gc291cmNlV2l0aE1vZHVsZVJlZnM7XHJcbiAgICB9XHJcbiAgICBTb3VyY2VNb2R1bGUucHJvdG90eXBlLmdldFNvdXJjZVdpdGhJbXBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG1vZHVsZUFsaWFzZXMgPSB7fTtcclxuICAgICAgICB2YXIgaW1wb3J0cyA9IFtdO1xyXG4gICAgICAgIHZhciBuZXdTb3VyY2UgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKHRoaXMuc291cmNlV2l0aE1vZHVsZVJlZnMsIE1PRFVMRV9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgbW9kdWxlVXJsID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IG1vZHVsZUFsaWFzZXNbbW9kdWxlVXJsXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGFsaWFzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZVVybCA9PSBfdGhpcy5tb2R1bGVVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBcImltcG9ydFwiICsgaW1wb3J0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0cy5wdXNoKFttb2R1bGVVcmwsIGFsaWFzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtb2R1bGVBbGlhc2VzW21vZHVsZVVybF0gPSBhbGlhcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWxpYXMubGVuZ3RoID4gMCA/IGFsaWFzICsgXCIuXCIgOiAnJztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZVdpdGhJbXBvcnRzKG5ld1NvdXJjZSwgaW1wb3J0cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNvdXJjZU1vZHVsZTtcclxufSkoKTtcclxuZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBTb3VyY2VNb2R1bGU7XHJcbnZhciBTb3VyY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZUV4cHJlc3Npb24oZGVjbGFyYXRpb25zLCBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBTb3VyY2VFeHByZXNzaW9uO1xyXG59KSgpO1xyXG5leHBvcnRzLlNvdXJjZUV4cHJlc3Npb24gPSBTb3VyY2VFeHByZXNzaW9uO1xyXG52YXIgU291cmNlRXhwcmVzc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU291cmNlRXhwcmVzc2lvbnMoZGVjbGFyYXRpb25zLCBleHByZXNzaW9ucykge1xyXG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuICAgIH1cclxuICAgIHJldHVybiBTb3VyY2VFeHByZXNzaW9ucztcclxufSkoKTtcclxuZXhwb3J0cy5Tb3VyY2VFeHByZXNzaW9ucyA9IFNvdXJjZUV4cHJlc3Npb25zO1xyXG52YXIgU291cmNlV2l0aEltcG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU291cmNlV2l0aEltcG9ydHMoc291cmNlLCBpbXBvcnRzKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5pbXBvcnRzID0gaW1wb3J0cztcclxuICAgIH1cclxuICAgIHJldHVybiBTb3VyY2VXaXRoSW1wb3J0cztcclxufSkoKTtcclxuZXhwb3J0cy5Tb3VyY2VXaXRoSW1wb3J0cyA9IFNvdXJjZVdpdGhJbXBvcnRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2VfbW9kdWxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgc291cmNlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9zb3VyY2VfbW9kdWxlJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciB4aHJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3hocicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIHNoYWRvd19jc3NfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NoYWRvd19jc3MnKTtcclxudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXJsX3Jlc29sdmVyJyk7XHJcbnZhciBzdHlsZV91cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vc3R5bGVfdXJsX3Jlc29sdmVyJyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XHJcbnZhciBDT01QT05FTlRfUkVHRVggPSAvJUNPTVAlL2c7XHJcbnZhciBIT1NUX0FUVFIgPSBcIl9uZ2hvc3QtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XHJcbnZhciBIT1NUX0FUVFJfRVhQUiA9IFwiJ19uZ2hvc3QtJytcIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcclxudmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcclxudmFyIENPTlRFTlRfQVRUUl9FWFBSID0gXCInX25nY29udGVudC0nK1wiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xyXG52YXIgU3R5bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF94aHIsIF91cmxSZXNvbHZlcikge1xyXG4gICAgICAgIHRoaXMuX3hociA9IF94aHI7XHJcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fc3R5bGVDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9zaGFkb3dDc3MgPSBuZXcgc2hhZG93X2Nzc18xLlNoYWRvd0NzcygpO1xyXG4gICAgfVxyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUgPSBmdW5jdGlvbiAoYXBwSWQsIHRlbXBsYXRlSWQsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRlbXBsYXRlLnN0eWxlcztcclxuICAgICAgICB2YXIgc3R5bGVBYnNVcmxzID0gdGVtcGxhdGUuc3R5bGVVcmxzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkU3R5bGVzKHN0eWxlcywgc3R5bGVBYnNVcmxzLCB0ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdHlsZXMpIHsgcmV0dXJuIHN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHN0eWxlLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudElkKGFwcElkLCB0ZW1wbGF0ZUlkKSk7IH0pOyB9KTtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50Q29kZUdlbiA9IGZ1bmN0aW9uIChhcHBJZEV4cHJlc3Npb24sIHRlbXBsYXRlSWRFeHByZXNzaW9uLCB0ZW1wbGF0ZSkge1xyXG4gICAgICAgIHZhciBzaGltID0gdGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xyXG4gICAgICAgIHZhciBzdWZmaXg7XHJcbiAgICAgICAgaWYgKHNoaW0pIHtcclxuICAgICAgICAgICAgc3VmZml4ID0gdXRpbF8xLmNvZGVHZW5NYXBBcnJheShbJ3N0eWxlJ10sIFwic3R5bGVcIiArIHV0aWxfMS5jb2RlR2VuUmVwbGFjZUFsbChDT01QT05FTlRfVkFSSUFCTEUsIGNvbXBvbmVudElkRXhwcmVzc2lvbihhcHBJZEV4cHJlc3Npb24sIHRlbXBsYXRlSWRFeHByZXNzaW9uKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VmZml4ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZUNvZGVHZW4odGVtcGxhdGUuc3R5bGVzLCB0ZW1wbGF0ZS5zdHlsZVVybHMsIHNoaW0sIHN1ZmZpeCk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZVN0eWxlc2hlZXRDb2RlR2VuID0gZnVuY3Rpb24gKHN0eWxlc2hlZXRVcmwsIGNzc1RleHQpIHtcclxuICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IHN0eWxlX3VybF9yZXNvbHZlcl8xLnJlc29sdmVTdHlsZVVybHModGhpcy5fdXJsUmVzb2x2ZXIsIHN0eWxlc2hlZXRVcmwsIGNzc1RleHQpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlTW9kdWxlKHN0eWxlc2hlZXRVcmwsIGZhbHNlLCB0aGlzLl9zdHlsZUNvZGVHZW4oW3N0eWxlV2l0aEltcG9ydHMuc3R5bGVdLCBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscywgZmFsc2UsICcnKSksXHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlTW9kdWxlKHN0eWxlc2hlZXRVcmwsIHRydWUsIHRoaXMuX3N0eWxlQ29kZUdlbihbc3R5bGVXaXRoSW1wb3J0cy5zdHlsZV0sIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzLCB0cnVlLCAnJykpXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zdHlsZUNhY2hlLmNsZWFyKCk7IH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fbG9hZFN0eWxlcyA9IGZ1bmN0aW9uIChwbGFpblN0eWxlcywgYWJzVXJscywgZW5jYXBzdWxhdGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlcyA9IGFic1VybHMubWFwKGZ1bmN0aW9uIChhYnNVcmwpIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJcIiArIGFic1VybCArIChlbmNhcHN1bGF0ZSA/ICcuc2hpbScgOiAnJyk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5fc3R5bGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3RoaXMuX3hoci5nZXQoYWJzVXJsKS50aGVuKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVdpdGhJbXBvcnRzID0gc3R5bGVfdXJsX3Jlc29sdmVyXzEucmVzb2x2ZVN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIGFic1VybCwgc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZFN0eWxlcyhbc3R5bGVXaXRoSW1wb3J0cy5zdHlsZV0sIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzLCBlbmNhcHN1bGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZUNhY2hlLnNldChjYWNoZUtleSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAobmVzdGVkU3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwbGFpblN0eWxlcy5tYXAoZnVuY3Rpb24gKHBsYWluU3R5bGUpIHsgcmV0dXJuIF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgZW5jYXBzdWxhdGUpOyB9KTtcclxuICAgICAgICAgICAgbmVzdGVkU3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiByZXN1bHQucHVzaChzdHlsZSk7IH0pOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fc3R5bGVDb2RlR2VuID0gZnVuY3Rpb24gKHBsYWluU3R5bGVzLCBhYnNVcmxzLCBzaGltLCBzdWZmaXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBleHByZXNzaW9uU291cmNlID0gXCIoXCI7XHJcbiAgICAgICAgZXhwcmVzc2lvblNvdXJjZSArPVxyXG4gICAgICAgICAgICBcIltcIiArIHBsYWluU3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gdXRpbF8xLmVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KS5qb2luKCcsJykgKyBcIl1cIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFic1VybHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZVVybCA9IHRoaXMuX2NyZWF0ZU1vZHVsZVVybChhYnNVcmxzW2ldLCBzaGltKTtcclxuICAgICAgICAgICAgZXhwcmVzc2lvblNvdXJjZSArPSB1dGlsXzEuY29kZUdlbkNvbmNhdEFycmF5KHNvdXJjZV9tb2R1bGVfMS5tb2R1bGVSZWYobW9kdWxlVXJsKSArIFwiU1RZTEVTXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByZXNzaW9uU291cmNlICs9IFwiKVwiICsgc3VmZml4O1xyXG4gICAgICAgIHJldHVybiBuZXcgc291cmNlX21vZHVsZV8xLlNvdXJjZUV4cHJlc3Npb24oW10sIGV4cHJlc3Npb25Tb3VyY2UpO1xyXG4gICAgfTtcclxuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zdHlsZU1vZHVsZSA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0VXJsLCBzaGltLCBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNvdXJjZSA9IFwiXFxuICAgICAgXCIgKyBleHByZXNzaW9uLmRlY2xhcmF0aW9ucy5qb2luKCdcXG4nKSArIFwiXFxuICAgICAgXCIgKyB1dGlsXzEuY29kZUdlbkV4cG9ydFZhcmlhYmxlKCdTVFlMRVMnKSArIGV4cHJlc3Npb24uZXhwcmVzc2lvbiArIFwiO1xcbiAgICBcIjtcclxuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZV9tb2R1bGVfMS5Tb3VyY2VNb2R1bGUodGhpcy5fY3JlYXRlTW9kdWxlVXJsKHN0eWxlc2hlZXRVcmwsIHNoaW0pLCBtb2R1bGVTb3VyY2UpO1xyXG4gICAgfTtcclxuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUsIHNoaW0pIHtcclxuICAgICAgICByZXR1cm4gc2hpbSA/IHRoaXMuX3NoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDogc3R5bGU7XHJcbiAgICB9O1xyXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZU1vZHVsZVVybCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0VXJsLCBzaGltKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoaW0gPyBzdHlsZXNoZWV0VXJsICsgXCIuc2hpbVwiICsgdXRpbF8xLk1PRFVMRV9TVUZGSVggOiBcIlwiICsgc3R5bGVzaGVldFVybCArIHV0aWxfMS5NT0RVTEVfU1VGRklYO1xyXG4gICAgfTtcclxuICAgIFN0eWxlQ29tcGlsZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbeGhyXzEuWEhSLCB1cmxfcmVzb2x2ZXJfMS5VcmxSZXNvbHZlcl0pXHJcbiAgICBdLCBTdHlsZUNvbXBpbGVyKTtcclxuICAgIHJldHVybiBTdHlsZUNvbXBpbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0eWxlQ29tcGlsZXIgPSBTdHlsZUNvbXBpbGVyO1xyXG5mdW5jdGlvbiBzaGltQ29udGVudEF0dHJpYnV0ZShhcHBJZCwgdGVtcGxhdGVJZCkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoQ09OVEVOVF9BVFRSLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudElkKGFwcElkLCB0ZW1wbGF0ZUlkKSk7XHJcbn1cclxuZXhwb3J0cy5zaGltQ29udGVudEF0dHJpYnV0ZSA9IHNoaW1Db250ZW50QXR0cmlidXRlO1xyXG5mdW5jdGlvbiBzaGltQ29udGVudEF0dHJpYnV0ZUV4cHIoYXBwSWRFeHByLCB0ZW1wbGF0ZUlkRXhwcikge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoQ09OVEVOVF9BVFRSX0VYUFIsIENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50SWRFeHByZXNzaW9uKGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIpKTtcclxufVxyXG5leHBvcnRzLnNoaW1Db250ZW50QXR0cmlidXRlRXhwciA9IHNoaW1Db250ZW50QXR0cmlidXRlRXhwcjtcclxuZnVuY3Rpb24gc2hpbUhvc3RBdHRyaWJ1dGUoYXBwSWQsIHRlbXBsYXRlSWQpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKEhPU1RfQVRUUiwgQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRJZChhcHBJZCwgdGVtcGxhdGVJZCkpO1xyXG59XHJcbmV4cG9ydHMuc2hpbUhvc3RBdHRyaWJ1dGUgPSBzaGltSG9zdEF0dHJpYnV0ZTtcclxuZnVuY3Rpb24gc2hpbUhvc3RBdHRyaWJ1dGVFeHByKGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKEhPU1RfQVRUUl9FWFBSLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudElkRXhwcmVzc2lvbihhcHBJZEV4cHIsIHRlbXBsYXRlSWRFeHByKSk7XHJcbn1cclxuZXhwb3J0cy5zaGltSG9zdEF0dHJpYnV0ZUV4cHIgPSBzaGltSG9zdEF0dHJpYnV0ZUV4cHI7XHJcbmZ1bmN0aW9uIGNvbXBvbmVudElkKGFwcElkLCB0ZW1wbGF0ZUlkKSB7XHJcbiAgICByZXR1cm4gYXBwSWQgKyBcIi1cIiArIHRlbXBsYXRlSWQ7XHJcbn1cclxuZnVuY3Rpb24gY29tcG9uZW50SWRFeHByZXNzaW9uKGFwcElkRXhwcmVzc2lvbiwgdGVtcGxhdGVJZEV4cHJlc3Npb24pIHtcclxuICAgIHJldHVybiBhcHBJZEV4cHJlc3Npb24gKyBcIisnLScrXCIgKyB1dGlsXzEuY29kZUdlblRvU3RyaW5nKHRlbXBsYXRlSWRFeHByZXNzaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZV9jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gU29tZSBvZiB0aGUgY29kZSBjb21lcyBmcm9tIFdlYkNvbXBvbmVudHMuSlNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvbWFzdGVyL3NyYy9IVE1MSW1wb3J0cy9wYXRoLmpzXHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogUmV3cml0ZXMgVVJMcyBieSByZXNvbHZpbmcgJ0BpbXBvcnQnIGFuZCAndXJsKCknIFVSTHMgZnJvbSB0aGUgZ2l2ZW4gYmFzZSBVUkwsXHJcbiAqIHJlbW92ZXMgYW5kIHJldHVybnMgdGhlIEBpbXBvcnQgdXJsc1xyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xyXG4gICAgdmFyIGZvdW5kVXJscyA9IFtdO1xyXG4gICAgY3NzVGV4dCA9IGV4dHJhY3RVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0LCBmb3VuZFVybHMpO1xyXG4gICAgY3NzVGV4dCA9IHJlcGxhY2VVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KTtcclxuICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhjc3NUZXh0LCBmb3VuZFVybHMpO1xyXG59XHJcbmV4cG9ydHMucmVzb2x2ZVN0eWxlVXJscyA9IHJlc29sdmVTdHlsZVVybHM7XHJcbnZhciBTdHlsZVdpdGhJbXBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0eWxlV2l0aEltcG9ydHMoc3R5bGUsIHN0eWxlVXJscykge1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcclxuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcclxuICAgIH1cclxuICAgIHJldHVybiBTdHlsZVdpdGhJbXBvcnRzO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0eWxlV2l0aEltcG9ydHMgPSBTdHlsZVdpdGhJbXBvcnRzO1xyXG5mdW5jdGlvbiBleHRyYWN0VXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCwgZm91bmRVcmxzKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzSW1wb3J0UmUsIGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgdmFyIHVybCA9IGxhbmdfMS5pc1ByZXNlbnQobVsxXSkgPyBtWzFdIDogbVsyXTtcclxuICAgICAgICB2YXIgc2NoZW1lTWF0Y2ggPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKF91cmxXaXRoU2NoZW1hUmUsIHVybCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc2NoZW1lTWF0Y2gpICYmIHNjaGVtZU1hdGNoWzFdICE9ICdwYWNrYWdlJykge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByZXNvbHZlIG5vbi1wYWNrYWdlIGFic29sdXRlIFVSTHMgd2l0aCBVUkkgc2NoZW1lXHJcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3VuZFVybHMucHVzaChyZXNvbHZlci5yZXNvbHZlKGJhc2VVcmwsIHVybCkpO1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzVXJsUmUsIGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgdmFyIHByZSA9IG1bMV07XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsVXJsID0gbVsyXTtcclxuICAgICAgICBpZiAobGFuZ18xLlJlZ0V4cFdyYXBwZXIudGVzdChfZGF0YVVybFJlLCBvcmlnaW5hbFVybCkpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBkYXRhOiBVUkxzXHJcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChvcmlnaW5hbFVybCwgX3F1b3RlUmUsICcnKTtcclxuICAgICAgICB2YXIgcG9zdCA9IG1bM107XHJcbiAgICAgICAgdmFyIHJlc29sdmVkVXJsID0gcmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpO1xyXG4gICAgICAgIHJldHVybiBwcmUgKyBcIidcIiArIHJlc29sdmVkVXJsICsgXCInXCIgKyBwb3N0O1xyXG4gICAgfSk7XHJcbn1cclxudmFyIF9jc3NVcmxSZSA9IC8odXJsXFwoKShbXildKikoXFwpKS9nO1xyXG52YXIgX2Nzc0ltcG9ydFJlID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xyXG52YXIgX3F1b3RlUmUgPSAvWydcIl0vZztcclxudmFyIF9kYXRhVXJsUmUgPSAvXlsnXCJdP2RhdGE6L2c7XHJcbi8vIFRPRE86IGNhbid0IHVzZSAvXlteOi8/Iy5dKzovZyBkdWUgdG8gY2xhbmctZm9ybWF0IGJ1ZzpcclxuLy8gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNDU5NlxyXG52YXIgX3VybFdpdGhTY2hlbWFSZSA9IC9eWydcIl0/KFthLXpBLVpcXC1cXCtcXC5dKyk6L2c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlX3VybF9yZXNvbHZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XHJcbiAgICByZXR1cm4gVGV4dEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5UZXh0QXN0ID0gVGV4dEFzdDtcclxudmFyIEJvdW5kVGV4dEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCb3VuZFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgQm91bmRUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJvdW5kVGV4dEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5Cb3VuZFRleHRBc3QgPSBCb3VuZFRleHRBc3Q7XHJcbnZhciBBdHRyQXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF0dHJBc3QobmFtZSwgdmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgQXR0ckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHIodGhpcywgY29udGV4dCk7IH07XHJcbiAgICByZXR1cm4gQXR0ckFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5BdHRyQXN0ID0gQXR0ckFzdDtcclxudmFyIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KG5hbWUsIHR5cGUsIHZhbHVlLCB1bml0LCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5Cb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0O1xyXG52YXIgQm91bmRFdmVudEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgaGFuZGxlciwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXZlbnQodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImZ1bGxOYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQgKyBcIjpcIiArIHRoaXMubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBCb3VuZEV2ZW50QXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLkJvdW5kRXZlbnRBc3QgPSBCb3VuZEV2ZW50QXN0O1xyXG52YXIgVmFyaWFibGVBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFyaWFibGVBc3QobmFtZSwgdmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgVmFyaWFibGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFZhcmlhYmxlKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWYXJpYWJsZUFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5WYXJpYWJsZUFzdCA9IFZhcmlhYmxlQXN0O1xyXG52YXIgRWxlbWVudEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50QXN0KG5hbWUsIGF0dHJzLCBpbnB1dHMsIG91dHB1dHMsIGV4cG9ydEFzVmFycywgZGlyZWN0aXZlcywgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcclxuICAgICAgICB0aGlzLmV4cG9ydEFzVmFycyA9IGV4cG9ydEFzVmFycztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEFzdC5wcm90b3R5cGUuaXNCb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaW5wdXRzLmxlbmd0aCA+IDAgfHwgdGhpcy5vdXRwdXRzLmxlbmd0aCA+IDAgfHwgdGhpcy5leHBvcnRBc1ZhcnMubGVuZ3RoID4gMCB8fFxyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMubGVuZ3RoID4gMCk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEFzdC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGl2ZXMubGVuZ3RoID4gMCAmJiB0aGlzLmRpcmVjdGl2ZXNbMF0uZGlyZWN0aXZlLmlzQ29tcG9uZW50ID9cclxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzWzBdLmRpcmVjdGl2ZSA6XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVsZW1lbnRBc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRWxlbWVudEFzdCA9IEVsZW1lbnRBc3Q7XHJcbnZhciBFbWJlZGRlZFRlbXBsYXRlQXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVtYmVkZGVkVGVtcGxhdGVBc3QoYXR0cnMsIHZhcnMsIGRpcmVjdGl2ZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcclxuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5FbWJlZGRlZFRlbXBsYXRlQXN0ID0gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcclxudmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJlY3RpdmVOYW1lLCB0ZW1wbGF0ZU5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTmFtZTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZVByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLkJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xyXG52YXIgRGlyZWN0aXZlQXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZUFzdChkaXJlY3RpdmUsIGlucHV0cywgaG9zdFByb3BlcnRpZXMsIGhvc3RFdmVudHMsIGV4cG9ydEFzVmFycywgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xyXG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcclxuICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xyXG4gICAgICAgIHRoaXMuZXhwb3J0QXNWYXJzID0gZXhwb3J0QXNWYXJzO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW5mbyA9IHNvdXJjZUluZm87XHJcbiAgICB9XHJcbiAgICBEaXJlY3RpdmVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZSh0aGlzLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlQXN0O1xyXG59KSgpO1xyXG5leHBvcnRzLkRpcmVjdGl2ZUFzdCA9IERpcmVjdGl2ZUFzdDtcclxudmFyIE5nQ29udGVudEFzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ0NvbnRlbnRBc3QoaW5kZXgsIG5nQ29udGVudEluZGV4LCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgTmdDb250ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROZ0NvbnRlbnQodGhpcywgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nQ29udGVudEFzdDtcclxufSkoKTtcclxuZXhwb3J0cy5OZ0NvbnRlbnRBc3QgPSBOZ0NvbnRlbnRBc3Q7XHJcbihmdW5jdGlvbiAoUHJvcGVydHlCaW5kaW5nVHlwZSkge1xyXG4gICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiUHJvcGVydHlcIl0gPSAwXSA9IFwiUHJvcGVydHlcIjtcclxuICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkF0dHJpYnV0ZVwiXSA9IDFdID0gXCJBdHRyaWJ1dGVcIjtcclxuICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkNsYXNzXCJdID0gMl0gPSBcIkNsYXNzXCI7XHJcbiAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJTdHlsZVwiXSA9IDNdID0gXCJTdHlsZVwiO1xyXG59KShleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgfHwgKGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9KSk7XHJcbnZhciBQcm9wZXJ0eUJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlO1xyXG5mdW5jdGlvbiB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcclxuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgdmFyIGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhc3RSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMudGVtcGxhdGVWaXNpdEFsbCA9IHRlbXBsYXRlVmlzaXRBbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlX2FzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgdGVtcGxhdGVfY29tbWFuZHNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci90ZW1wbGF0ZV9jb21tYW5kcycpO1xyXG52YXIgZGlyZWN0aXZlX21ldGFkYXRhXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBzb3VyY2VfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvdXJjZV9tb2R1bGUnKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rvcl9jb21waWxlcl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0b3JfY29tcGlsZXInKTtcclxudmFyIHN0eWxlX2NvbXBpbGVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX2NvbXBpbGVyJyk7XHJcbnZhciBjb21tYW5kX2NvbXBpbGVyXzEgPSByZXF1aXJlKCcuL2NvbW1hbmRfY29tcGlsZXInKTtcclxudmFyIHRlbXBsYXRlX3BhcnNlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9wYXJzZXInKTtcclxudmFyIHRlbXBsYXRlX25vcm1hbGl6ZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfbm9ybWFsaXplcicpO1xyXG52YXIgcnVudGltZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9ydW50aW1lX21ldGFkYXRhJyk7XHJcbnZhciBhcHBsaWNhdGlvbl90b2tlbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2FwcGxpY2F0aW9uX3Rva2VucycpO1xyXG52YXIgY29tbWFuZF9jb21waWxlcl8yID0gcmVxdWlyZSgnLi9jb21tYW5kX2NvbXBpbGVyJyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxudmFyIGRpXzIgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgVGVtcGxhdGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUNvbXBpbGVyKF9ydW50aW1lTWV0YWRhdGFSZXNvbHZlciwgX3RlbXBsYXRlTm9ybWFsaXplciwgX3RlbXBsYXRlUGFyc2VyLCBfc3R5bGVDb21waWxlciwgX2NvbW1hbmRDb21waWxlciwgX2NkQ29tcGlsZXIsIGFwcElkKSB7XHJcbiAgICAgICAgdGhpcy5fcnVudGltZU1ldGFkYXRhUmVzb2x2ZXIgPSBfcnVudGltZU1ldGFkYXRhUmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVOb3JtYWxpemVyID0gX3RlbXBsYXRlTm9ybWFsaXplcjtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcclxuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XHJcbiAgICAgICAgdGhpcy5fY29tbWFuZENvbXBpbGVyID0gX2NvbW1hbmRDb21waWxlcjtcclxuICAgICAgICB0aGlzLl9jZENvbXBpbGVyID0gX2NkQ29tcGlsZXI7XHJcbiAgICAgICAgdGhpcy5faG9zdENhY2hlS2V5cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZURvbmUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYXBwSWQgPSBhcHBJZDtcclxuICAgIH1cclxuICAgIFRlbXBsYXRlQ29tcGlsZXIucHJvdG90eXBlLm5vcm1hbGl6ZURpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xyXG4gICAgICAgIGlmICghZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBub24gY29tcG9uZW50cyB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIG5vcm1hbGl6ZWQgeWV0LlxyXG4gICAgICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBub3JtYWxpemVkVGVtcGxhdGVQcm9taXNlO1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlUHJvbWlzZSA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIubm9ybWFsaXplVGVtcGxhdGUoZGlyZWN0aXZlLnR5cGUsIGRpcmVjdGl2ZS50ZW1wbGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVQcm9taXNlID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFRlbXBsYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkVGVtcGxhdGUpIHsgcmV0dXJuIG5ldyBkaXJlY3RpdmVfbWV0YWRhdGFfMS5Db21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICB0eXBlOiBkaXJlY3RpdmUudHlwZSxcclxuICAgICAgICAgICAgaXNDb21wb25lbnQ6IGRpcmVjdGl2ZS5pc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgZHluYW1pY0xvYWRhYmxlOiBkaXJlY3RpdmUuZHluYW1pY0xvYWRhYmxlLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgIGlucHV0czogZGlyZWN0aXZlLmlucHV0cyxcclxuICAgICAgICAgICAgb3V0cHV0czogZGlyZWN0aXZlLm91dHB1dHMsXHJcbiAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGRpcmVjdGl2ZS5ob3N0TGlzdGVuZXJzLFxyXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogZGlyZWN0aXZlLmhvc3RQcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICBsaWZlY3ljbGVIb29rczogZGlyZWN0aXZlLmxpZmVjeWNsZUhvb2tzLCB0ZW1wbGF0ZTogbm9ybWFsaXplZFRlbXBsYXRlXHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVIb3N0Q29tcG9uZW50UnVudGltZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGhvc3RDYWNoZUtleSA9IHRoaXMuX2hvc3RDYWNoZUtleXMuZ2V0KHR5cGUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhob3N0Q2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgIGhvc3RDYWNoZUtleSA9IG5ldyBPYmplY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5faG9zdENhY2hlS2V5cy5zZXQodHlwZSwgaG9zdENhY2hlS2V5KTtcclxuICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gdGhpcy5fcnVudGltZU1ldGFkYXRhUmVzb2x2ZXIuZ2V0TWV0YWRhdGEodHlwZSk7XHJcbiAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XHJcbiAgICAgICAgICAgIHZhciBob3N0TWV0YSA9IGRpcmVjdGl2ZV9tZXRhZGF0YV8xLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhLnR5cGUsIGNvbXBNZXRhLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUoaG9zdENhY2hlS2V5LCBob3N0TWV0YSwgW2NvbXBNZXRhXSwgbmV3IFNldCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lLmdldChob3N0Q2FjaGVLZXkpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb21waWxlZFRlbXBsYXRlKSB7IHJldHVybiBuZXcgdGVtcGxhdGVfY29tbWFuZHNfMS5Db21waWxlZEhvc3RUZW1wbGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb21waWxlZFRlbXBsYXRlOyB9KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9ob3N0Q2FjaGVLZXlzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlci5jbGVhckNhY2hlKCk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZURvbmUuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUgPSBmdW5jdGlvbiAoY2FjaGVLZXksIGNvbXBNZXRhLCB2aWV3RGlyZWN0aXZlcywgY29tcGlsaW5nQ29tcG9uZW50Q2FjaGVLZXlzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgICAgIHZhciBkb25lID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZURvbmUuZ2V0KGNhY2hlS2V5KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcGlsZWRUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlcztcclxuICAgICAgICAgICAgdmFyIGNoYW5nZURldGVjdG9yRmFjdG9yeTtcclxuICAgICAgICAgICAgdmFyIGNvbW1hbmRzO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVJZCA9IHRlbXBsYXRlX2NvbW1hbmRzXzEubmV4dFRlbXBsYXRlSWQoKTtcclxuICAgICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9XHJcbiAgICAgICAgICAgICAgICBuZXcgdGVtcGxhdGVfY29tbWFuZHNfMS5Db21waWxlZFRlbXBsYXRlKHRlbXBsYXRlSWQsIGZ1bmN0aW9uIChfYSwgX2IpIHsgcmV0dXJuIFtjaGFuZ2VEZXRlY3RvckZhY3RvcnksIGNvbW1hbmRzLCBzdHlsZXNdOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjYWNoZUtleSwgY29tcGlsZWRUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cy5hZGQoY2FjaGVLZXkpO1xyXG4gICAgICAgICAgICBkb25lID1cclxuICAgICAgICAgICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnRSdW50aW1lKHRoaXMuX2FwcElkLCB0ZW1wbGF0ZUlkLCBjb21wTWV0YS50ZW1wbGF0ZSlcclxuICAgICAgICAgICAgICAgIF0uY29uY2F0KHZpZXdEaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub3JtYWxpemVEaXJlY3RpdmVNZXRhZGF0YShkaXJNZXRhKTtcclxuICAgICAgICAgICAgICAgIH0pKSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3R5bGVzQW5kTm9ybWFsaXplZFZpZXdEaXJNZXRhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWaWV3RGlyTWV0YXMgPSBzdHlsZXNBbmROb3JtYWxpemVkVmlld0Rpck1ldGFzLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRUZW1wbGF0ZSA9IF90aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZSwgbm9ybWFsaXplZFZpZXdEaXJNZXRhcywgY29tcE1ldGEudHlwZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXMgPSBfdGhpcy5fY2RDb21waWxlci5jb21waWxlQ29tcG9uZW50UnVudGltZShjb21wTWV0YS50eXBlLCBjb21wTWV0YS5jaGFuZ2VEZXRlY3Rpb24sIHBhcnNlZFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RvckZhY3RvcnkgPSBjaGFuZ2VEZXRlY3RvckZhY3Rvcmllc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBzdHlsZXNBbmROb3JtYWxpemVkVmlld0Rpck1ldGFzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzID0gX3RoaXMuX2NvbXBpbGVDb21tYW5kc1J1bnRpbWUoY29tcE1ldGEsIHRlbXBsYXRlSWQsIHBhcnNlZFRlbXBsYXRlLCBjaGFuZ2VEZXRlY3RvckZhY3RvcmllcywgY29tcGlsaW5nQ29tcG9uZW50Q2FjaGVLZXlzLCBjaGlsZFByb21pc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwoY2hpbGRQcm9taXNlcyk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuZGVsZXRlKGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cywgY2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lLnNldChjYWNoZUtleSwgZG9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tbWFuZHNSdW50aW1lID0gZnVuY3Rpb24gKGNvbXBNZXRhLCB0ZW1wbGF0ZUlkLCBwYXJzZWRUZW1wbGF0ZSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3JpZXMsIGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cywgY2hpbGRQcm9taXNlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRDb21waWxlci5jb21waWxlQ29tcG9uZW50UnVudGltZShjb21wTWV0YSwgdGhpcy5fYXBwSWQsIHRlbXBsYXRlSWQsIHBhcnNlZFRlbXBsYXRlLCBjaGFuZ2VEZXRlY3RvckZhY3RvcmllcywgZnVuY3Rpb24gKGNoaWxkQ29tcG9uZW50RGlyKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZENhY2hlS2V5ID0gY2hpbGRDb21wb25lbnREaXIudHlwZS5ydW50aW1lO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRWaWV3RGlyZWN0aXZlcyA9IF90aGlzLl9ydW50aW1lTWV0YWRhdGFSZXNvbHZlci5nZXRWaWV3RGlyZWN0aXZlc01ldGFkYXRhKGNoaWxkQ29tcG9uZW50RGlyLnR5cGUucnVudGltZSk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZElzUmVjdXJzaXZlID0gY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKGNvbXBpbGluZ0NvbXBvbmVudENhY2hlS2V5cywgY2hpbGRDYWNoZUtleSk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFRlbXBsYXRlID0gX3RoaXMuX2NvbXBpbGVDb21wb25lbnRSdW50aW1lKGNoaWxkQ2FjaGVLZXksIGNoaWxkQ29tcG9uZW50RGlyLCBjaGlsZFZpZXdEaXJlY3RpdmVzLCBjb21waWxpbmdDb21wb25lbnRDYWNoZUtleXMpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkSXNSZWN1cnNpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgd2FpdCBmb3IgYSBjaGlsZCBpZiBpdCBpcyBub3QgYSBjeWNsZVxyXG4gICAgICAgICAgICAgICAgY2hpbGRQcm9taXNlcy5wdXNoKF90aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5nZXQoY2hpbGRDYWNoZUtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFRlbXBsYXRlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVUZW1wbGF0ZXNDb2RlR2VuID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ05vIGNvbXBvbmVudHMgZ2l2ZW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZUFyZ3VtZW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRNZXRhcyA9IFtdO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZUlkVmFyaWFibGUgPSAndGVtcGxhdGVJZCc7XHJcbiAgICAgICAgdmFyIGFwcElkVmFyaWFibGUgPSAnYXBwSWQnO1xyXG4gICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50V2l0aERpcnMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gY29tcG9uZW50V2l0aERpcnMuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xyXG4gICAgICAgICAgICBjb21wb25lbnRNZXRhcy5wdXNoKGNvbXBNZXRhKTtcclxuICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NUZW1wbGF0ZUNvZGVHZW4oY29tcE1ldGEsIGFwcElkVmFyaWFibGUsIHRlbXBsYXRlSWRWYXJpYWJsZSwgY29tcG9uZW50V2l0aERpcnMuZGlyZWN0aXZlcywgZGVjbGFyYXRpb25zLCB0ZW1wbGF0ZUFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGlmIChjb21wTWV0YS5keW5hbWljTG9hZGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBob3N0TWV0YSA9IGRpcmVjdGl2ZV9tZXRhZGF0YV8xLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhLnR5cGUsIGNvbXBNZXRhLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1ldGFzLnB1c2goaG9zdE1ldGEpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NUZW1wbGF0ZUNvZGVHZW4oaG9zdE1ldGEsIGFwcElkVmFyaWFibGUsIHRlbXBsYXRlSWRWYXJpYWJsZSwgW2NvbXBNZXRhXSwgZGVjbGFyYXRpb25zLCB0ZW1wbGF0ZUFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleChjb21wb25lbnRNZXRhcywgZnVuY3Rpb24gKGNvbXBNZXRhLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEYXRhRm4gPSB1dGlsXzEuY29kZUdlblZhbHVlRm4oW2FwcElkVmFyaWFibGUsIHRlbXBsYXRlSWRWYXJpYWJsZV0sIFwiW1wiICsgdGVtcGxhdGVBcmd1bWVudHNbaW5kZXhdLmpvaW4oJywnKSArIFwiXVwiKTtcclxuICAgICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGVFeHByID0gXCJuZXcgXCIgKyBjb21tYW5kX2NvbXBpbGVyXzIuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiQ29tcGlsZWRUZW1wbGF0ZShcIiArIGNvbW1hbmRfY29tcGlsZXJfMi5URU1QTEFURV9DT01NQU5EU19NT0RVTEVfUkVGICsgXCJuZXh0VGVtcGxhdGVJZCgpLFwiICsgdGVtcGxhdGVEYXRhRm4gKyBcIilcIjtcclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlVmFsdWVFeHByO1xyXG4gICAgICAgICAgICBpZiAoY29tcE1ldGEudHlwZS5pc0hvc3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3J5TmFtZSA9IFwiX2hvc3RUZW1wbGF0ZUZhY3RvcnlcIiArIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2godXRpbF8xLmNvZGVHZW5WYWx1ZUZuKFtdLCBjb21waWxlZFRlbXBsYXRlRXhwciwgZmFjdG9yeU5hbWUpICsgXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdGlvbktleXdvcmQgPSB1dGlsXzEuSVNfREFSVCA/ICdjb25zdCcgOiAnbmV3JztcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWVFeHByID1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rpb25LZXl3b3JkICsgXCIgXCIgKyBjb21tYW5kX2NvbXBpbGVyXzIuVEVNUExBVEVfQ09NTUFORFNfTU9EVUxFX1JFRiArIFwiQ29tcGlsZWRIb3N0VGVtcGxhdGUoXCIgKyBmYWN0b3J5TmFtZSArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZUV4cHIgPSBjb21waWxlZFRlbXBsYXRlRXhwcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaChcIlwiICsgdXRpbF8xLmNvZGVHZW5FeHBvcnRWYXJpYWJsZSh0ZW1wbGF0ZVZhcmlhYmxlTmFtZShjb21wTWV0YS50eXBlKSwgY29tcE1ldGEudHlwZS5pc0hvc3QpICsgdmFyaWFibGVWYWx1ZUV4cHIgKyBcIjtcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG1vZHVsZVVybCA9IGNvbXBvbmVudHNbMF0uY29tcG9uZW50LnR5cGUubW9kdWxlVXJsO1xyXG4gICAgICAgIHJldHVybiBuZXcgc291cmNlX21vZHVsZV8xLlNvdXJjZU1vZHVsZShcIlwiICsgdGVtcGxhdGVNb2R1bGVVcmwobW9kdWxlVXJsKSwgZGVjbGFyYXRpb25zLmpvaW4oJ1xcbicpKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlU3R5bGVzaGVldENvZGVHZW4gPSBmdW5jdGlvbiAoc3R5bGVzaGVldFVybCwgY3NzVGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVTdHlsZXNoZWV0Q29kZUdlbihzdHlsZXNoZWV0VXJsLCBjc3NUZXh0KTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZUNvbXBpbGVyLnByb3RvdHlwZS5fcHJvY2Vzc1RlbXBsYXRlQ29kZUdlbiA9IGZ1bmN0aW9uIChjb21wTWV0YSwgYXBwSWRFeHByLCB0ZW1wbGF0ZUlkRXhwciwgZGlyZWN0aXZlcywgdGFyZ2V0RGVjbGFyYXRpb25zLCB0YXJnZXRUZW1wbGF0ZUFyZ3VtZW50cykge1xyXG4gICAgICAgIHZhciBzdHlsZUV4cHIgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnRDb2RlR2VuKGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIsIGNvbXBNZXRhLnRlbXBsYXRlKTtcclxuICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZSwgZGlyZWN0aXZlcywgY29tcE1ldGEudHlwZS5uYW1lKTtcclxuICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0b3JzRXhwcnMgPSB0aGlzLl9jZENvbXBpbGVyLmNvbXBpbGVDb21wb25lbnRDb2RlR2VuKGNvbXBNZXRhLnR5cGUsIGNvbXBNZXRhLmNoYW5nZURldGVjdGlvbiwgcGFyc2VkVGVtcGxhdGUpO1xyXG4gICAgICAgIHZhciBjb21tYW5kc0V4cHIgPSB0aGlzLl9jb21tYW5kQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudENvZGVHZW4oY29tcE1ldGEsIGFwcElkRXhwciwgdGVtcGxhdGVJZEV4cHIsIHBhcnNlZFRlbXBsYXRlLCBjaGFuZ2VEZXRlY3RvcnNFeHBycy5leHByZXNzaW9ucywgY29kZUdlbkNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSk7XHJcbiAgICAgICAgYWRkQWxsKHN0eWxlRXhwci5kZWNsYXJhdGlvbnMsIHRhcmdldERlY2xhcmF0aW9ucyk7XHJcbiAgICAgICAgYWRkQWxsKGNoYW5nZURldGVjdG9yc0V4cHJzLmRlY2xhcmF0aW9ucywgdGFyZ2V0RGVjbGFyYXRpb25zKTtcclxuICAgICAgICBhZGRBbGwoY29tbWFuZHNFeHByLmRlY2xhcmF0aW9ucywgdGFyZ2V0RGVjbGFyYXRpb25zKTtcclxuICAgICAgICB0YXJnZXRUZW1wbGF0ZUFyZ3VtZW50cy5wdXNoKFtjaGFuZ2VEZXRlY3RvcnNFeHBycy5leHByZXNzaW9uc1swXSwgY29tbWFuZHNFeHByLmV4cHJlc3Npb24sIHN0eWxlRXhwci5leHByZXNzaW9uXSk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVDb21waWxlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oNiwgZGlfMi5JbmplY3QoYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lEKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3J1bnRpbWVfbWV0YWRhdGFfMS5SdW50aW1lTWV0YWRhdGFSZXNvbHZlciwgdGVtcGxhdGVfbm9ybWFsaXplcl8xLlRlbXBsYXRlTm9ybWFsaXplciwgdGVtcGxhdGVfcGFyc2VyXzEuVGVtcGxhdGVQYXJzZXIsIHN0eWxlX2NvbXBpbGVyXzEuU3R5bGVDb21waWxlciwgY29tbWFuZF9jb21waWxlcl8xLkNvbW1hbmRDb21waWxlciwgY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyXzEuQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIsIFN0cmluZ10pXHJcbiAgICBdLCBUZW1wbGF0ZUNvbXBpbGVyKTtcclxuICAgIHJldHVybiBUZW1wbGF0ZUNvbXBpbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlRlbXBsYXRlQ29tcGlsZXIgPSBUZW1wbGF0ZUNvbXBpbGVyO1xyXG52YXIgTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb3JtYWxpemVkQ29tcG9uZW50V2l0aFZpZXdEaXJlY3RpdmVzKGNvbXBvbmVudCwgZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcztcclxufSkoKTtcclxuZXhwb3J0cy5Ob3JtYWxpemVkQ29tcG9uZW50V2l0aFZpZXdEaXJlY3RpdmVzID0gTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcztcclxuZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcclxuICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBjb21waWxlICdcIiArIG1ldGEudHlwZS5uYW1lICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0ZW1wbGF0ZVZhcmlhYmxlTmFtZSh0eXBlKSB7XHJcbiAgICByZXR1cm4gdHlwZS5uYW1lICsgXCJUZW1wbGF0ZVwiO1xyXG59XHJcbmZ1bmN0aW9uIHRlbXBsYXRlTW9kdWxlVXJsKG1vZHVsZVVybCkge1xyXG4gICAgdmFyIHVybFdpdGhvdXRTdWZmaXggPSBtb2R1bGVVcmwuc3Vic3RyaW5nKDAsIG1vZHVsZVVybC5sZW5ndGggLSB1dGlsXzEuTU9EVUxFX1NVRkZJWC5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHVybFdpdGhvdXRTdWZmaXggKyBcIi50ZW1wbGF0ZVwiICsgdXRpbF8xLk1PRFVMRV9TVUZGSVg7XHJcbn1cclxuZnVuY3Rpb24gYWRkQWxsKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29kZUdlbkNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeShuZXN0ZWRDb21wVHlwZSkge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBzb3VyY2VfbW9kdWxlXzEubW9kdWxlUmVmKHRlbXBsYXRlTW9kdWxlVXJsKG5lc3RlZENvbXBUeXBlLnR5cGUubW9kdWxlVXJsKSkgKyB0ZW1wbGF0ZVZhcmlhYmxlTmFtZShuZXN0ZWRDb21wVHlwZS50eXBlKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpcmVjdGl2ZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfbWV0YWRhdGEnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgeGhyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci94aHInKTtcclxudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXJsX3Jlc29sdmVyJyk7XHJcbnZhciBzdHlsZV91cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vc3R5bGVfdXJsX3Jlc29sdmVyJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhL3ZpZXcnKTtcclxudmFyIGh0bWxfYXN0XzEgPSByZXF1aXJlKCcuL2h0bWxfYXN0Jyk7XHJcbnZhciBodG1sX3BhcnNlcl8xID0gcmVxdWlyZSgnLi9odG1sX3BhcnNlcicpO1xyXG52YXIgdGVtcGxhdGVfcHJlcGFyc2VyXzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX3ByZXBhcnNlcicpO1xyXG52YXIgVGVtcGxhdGVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlTm9ybWFsaXplcihfeGhyLCBfdXJsUmVzb2x2ZXIsIF9kb21QYXJzZXIpIHtcclxuICAgICAgICB0aGlzLl94aHIgPSBfeGhyO1xyXG4gICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX2RvbVBhcnNlciA9IF9kb21QYXJzZXI7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0ZW1wbGF0ZS50ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZSh0aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlLCB0ZW1wbGF0ZS50ZW1wbGF0ZSwgZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudCh0ZW1wbGF0ZS50ZW1wbGF0ZVVybCkpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUFic1VybCA9IHRoaXMuX3VybFJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmwsIHRlbXBsYXRlLnRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3hoci5nZXQoc291cmNlQWJzVXJsKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlQ29udGVudCkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUsIHRlbXBsYXRlQ29udGVudCwgc291cmNlQWJzVXJsKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIGRpcmVjdGl2ZVR5cGUubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGVNZXRhLCB0ZW1wbGF0ZSwgdGVtcGxhdGVBYnNVcmwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkb21Ob2RlcyA9IHRoaXMuX2RvbVBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgZGlyZWN0aXZlVHlwZS5uYW1lKTtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcigpO1xyXG4gICAgICAgIGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHZpc2l0b3IsIGRvbU5vZGVzKTtcclxuICAgICAgICB2YXIgYWxsU3R5bGVzID0gdGVtcGxhdGVNZXRhLnN0eWxlcy5jb25jYXQodmlzaXRvci5zdHlsZXMpO1xyXG4gICAgICAgIHZhciBhbGxTdHlsZUFic1VybHMgPSB2aXNpdG9yLnN0eWxlVXJscy5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUodGVtcGxhdGVBYnNVcmwsIHVybCk7IH0pXHJcbiAgICAgICAgICAgIC5jb25jYXQodGVtcGxhdGVNZXRhLnN0eWxlVXJscy5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmwsIHVybCk7IH0pKTtcclxuICAgICAgICB2YXIgYWxsUmVzb2x2ZWRTdHlsZXMgPSBhbGxTdHlsZXMubWFwKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IHN0eWxlX3VybF9yZXNvbHZlcl8xLnJlc29sdmVTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCB0ZW1wbGF0ZUFic1VybCwgc3R5bGUpO1xyXG4gICAgICAgICAgICBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVVybCkgeyByZXR1cm4gYWxsU3R5bGVBYnNVcmxzLnB1c2goc3R5bGVVcmwpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGVuY2Fwc3VsYXRpb24gPSB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbjtcclxuICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PT0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkICYmIGFsbFJlc29sdmVkU3R5bGVzLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICBhbGxTdHlsZUFic1VybHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb24gPSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb24uTm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkaXJlY3RpdmVfbWV0YWRhdGFfMS5Db21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGVuY2Fwc3VsYXRpb24sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsLFxyXG4gICAgICAgICAgICBzdHlsZXM6IGFsbFJlc29sdmVkU3R5bGVzLFxyXG4gICAgICAgICAgICBzdHlsZVVybHM6IGFsbFN0eWxlQWJzVXJscyxcclxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB2aXNpdG9yLm5nQ29udGVudFNlbGVjdG9yc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlTm9ybWFsaXplciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFt4aHJfMS5YSFIsIHVybF9yZXNvbHZlcl8xLlVybFJlc29sdmVyLCBodG1sX3BhcnNlcl8xLkh0bWxQYXJzZXJdKVxyXG4gICAgXSwgVGVtcGxhdGVOb3JtYWxpemVyKTtcclxuICAgIHJldHVybiBUZW1wbGF0ZU5vcm1hbGl6ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVtcGxhdGVOb3JtYWxpemVyID0gVGVtcGxhdGVOb3JtYWxpemVyO1xyXG52YXIgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gW107XHJcbiAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gdGVtcGxhdGVfcHJlcGFyc2VyXzEucHJlcGFyc2VFbGVtZW50KGFzdCk7XHJcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgYXN0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgaHRtbF9hc3RfMS5IdG1sVGV4dEFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCArPSBjaGlsZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2godGV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xyXG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIHJldHVybiBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcjtcclxufSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVfbm9ybWFsaXplci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBodG1sX3BhcnNlcl8xID0gcmVxdWlyZSgnLi9odG1sX3BhcnNlcicpO1xyXG52YXIgdGVtcGxhdGVfYXN0XzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX2FzdCcpO1xyXG52YXIgc2VsZWN0b3JfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NvbXBpbGVyL3NlbGVjdG9yJyk7XHJcbnZhciBlbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5Jyk7XHJcbnZhciB0ZW1wbGF0ZV9wcmVwYXJzZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfcHJlcGFyc2VyJyk7XHJcbnZhciBodG1sX2FzdF8xID0gcmVxdWlyZSgnLi9odG1sX2FzdCcpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcclxuLy8gR3JvdXAgMiA9IFwidmFyLVwiIG9yIFwiI1wiXHJcbi8vIEdyb3VwIDMgPSBcIm9uLVwiXHJcbi8vIEdyb3VwIDQgPSBcImJpbmRvbi1cIlxyXG4vLyBHcm91cCA1ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcInZhci0vI1wiLCBvciBcIm9uLVwiXHJcbi8vIEdyb3VwIDYgPSBpZGVuaXRpZmVyIGluc2lkZSBbKCldXHJcbi8vIEdyb3VwIDcgPSBpZGVuaXRpZmVyIGluc2lkZSBbXVxyXG4vLyBHcm91cCA4ID0gaWRlbnRpZmllciBpbnNpZGUgKClcclxudmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KHZhci18Iyl8KG9uLSl8KGJpbmRvbi0pKSguKykpfFxcW1xcKChbXlxcKV0rKVxcKVxcXXxcXFsoW15cXF1dKylcXF18XFwoKFteXFwpXSspXFwpKSQvZztcclxudmFyIFRFTVBMQVRFX0VMRU1FTlQgPSAndGVtcGxhdGUnO1xyXG52YXIgVEVNUExBVEVfQVRUUiA9ICd0ZW1wbGF0ZSc7XHJcbnZhciBURU1QTEFURV9BVFRSX1BSRUZJWCA9ICcqJztcclxudmFyIENMQVNTX0FUVFIgPSAnY2xhc3MnO1xyXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gbmV3IFJlZ0V4cCgnXFxcXC4nKTtcclxudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XHJcbnZhciBDTEFTU19QUkVGSVggPSAnY2xhc3MnO1xyXG52YXIgU1RZTEVfUFJFRklYID0gJ3N0eWxlJztcclxudmFyIFRFWFRfQ1NTX1NFTEVDVE9SID0gc2VsZWN0b3JfMS5Dc3NTZWxlY3Rvci5wYXJzZSgnKicpWzBdO1xyXG52YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIpIHtcclxuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XHJcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xyXG4gICAgfVxyXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVBhcnNlVmlzaXRvcihkaXJlY3RpdmVzLCB0aGlzLl9leHByUGFyc2VyLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHBhcnNlVmlzaXRvciwgdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgc291cmNlSW5mbyksIEVNUFRZX0NPTVBPTkVOVCk7XHJcbiAgICAgICAgaWYgKHBhcnNlVmlzaXRvci5lcnJvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBwYXJzZVZpc2l0b3IuZXJyb3JzLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY2hhbmdlX2RldGVjdGlvbl8xLlBhcnNlciwgZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5FbGVtZW50U2NoZW1hUmVnaXN0cnksIGh0bWxfcGFyc2VyXzEuSHRtbFBhcnNlcl0pXHJcbiAgICBdLCBUZW1wbGF0ZVBhcnNlcik7XHJcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVtcGxhdGVQYXJzZXIgPSBUZW1wbGF0ZVBhcnNlcjtcclxudmFyIFRlbXBsYXRlUGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VWaXNpdG9yKGRpcmVjdGl2ZXMsIF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcclxuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXRjaGVyID0gbmV3IHNlbGVjdG9yXzEuU2VsZWN0b3JNYXRjaGVyKCk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoZGlyZWN0aXZlcywgZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JfMS5Dc3NTZWxlY3Rvci5wYXJzZShkaXJlY3RpdmUuc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZXNJbmRleC5zZXQoZGlyZWN0aXZlLCBpbmRleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgdGhpcy5lcnJvcnMucHVzaChtZXNzYWdlKTsgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUpOyAvLyBzb3VyY2VJbmZvIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZSBBU1RcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlKTsgLy8gc291cmNlSW5mbyBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgQVNUXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQmluZGluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLnBhcnNlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlKTsgLy8gc291cmNlSW5mbyBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgQVNUXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh2YWx1ZSwgc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlKTsgLy8gc291cmNlSW5mbyBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgQVNUXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IGNvbXBvbmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xyXG4gICAgICAgIHZhciBleHByID0gdGhpcy5fcGFyc2VJbnRlcnBvbGF0aW9uKGFzdC52YWx1ZSwgYXN0LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4cHIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRlbXBsYXRlX2FzdF8xLlRleHRBc3QoYXN0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgYXN0LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5BdHRyQXN0KGFzdC5uYW1lLCBhc3QudmFsdWUsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xyXG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gdGVtcGxhdGVfcHJlcGFyc2VyXzEucHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxyXG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFIHx8XHJcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCkge1xyXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xyXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFuZCBzdHlsZXNoZWV0cyBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGVtXHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hhYmxlQXR0cnMgPSBbXTtcclxuICAgICAgICB2YXIgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcclxuICAgICAgICB2YXIgdmFycyA9IFtdO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZVZhcnMgPSBbXTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVNYXRjaGFibGVBdHRycyA9IFtdO1xyXG4gICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgYXR0cnMgPSBbXTtcclxuICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcclxuICAgICAgICAgICAgbWF0Y2hhYmxlQXR0cnMucHVzaChbYXR0ci5uYW1lLCBhdHRyLnZhbHVlXSk7XHJcbiAgICAgICAgICAgIHZhciBoYXNCaW5kaW5nID0gX3RoaXMuX3BhcnNlQXR0cihhdHRyLCBtYXRjaGFibGVBdHRycywgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGV2ZW50cywgdmFycyk7XHJcbiAgICAgICAgICAgIHZhciBoYXNUZW1wbGF0ZUJpbmRpbmcgPSBfdGhpcy5fcGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcoYXR0ciwgdGVtcGxhdGVNYXRjaGFibGVBdHRycywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVWYXJzKTtcclxuICAgICAgICAgICAgaWYgKCFoYXNCaW5kaW5nICYmICFoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgdGhlIGJpbmRpbmdzIGFzIGF0dHJpYnV0ZXMgYXMgd2VsbCBpbiB0aGUgQVNUXHJcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKF90aGlzLnZpc2l0QXR0cihhdHRyLCBudWxsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc1RlbXBsYXRlQmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgaGFzSW5saW5lVGVtcGxhdGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpc1RlbXBsYXRlRWxlbWVudCA9IG5vZGVOYW1lID09IFRFTVBMQVRFX0VMRU1FTlQ7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihub2RlTmFtZSwgbWF0Y2hhYmxlQXR0cnMpO1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyhlbGVtZW50Lm5hbWUsIHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGlzVGVtcGxhdGVFbGVtZW50ID8gW10gOiB2YXJzLCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIENvbXBvbmVudC5jcmVhdGUoZGlyZWN0aXZlcykpO1xyXG4gICAgICAgIHZhciBlbGVtZW50TmdDb250ZW50SW5kZXggPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogY29tcG9uZW50LmZpbmROZ0NvbnRlbnRJbmRleChlbGVtZW50Q3NzU2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBwYXJzZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcclxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9XHJcbiAgICAgICAgICAgICAgICBuZXcgdGVtcGxhdGVfYXN0XzEuTmdDb250ZW50QXN0KHRoaXMubmdDb250ZW50Q291bnQrKywgZWxlbWVudE5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IHRlbXBsYXRlX2FzdF8xLkVtYmVkZGVkVGVtcGxhdGVBc3QoYXR0cnMsIHZhcnMsIGRpcmVjdGl2ZXMsIGNoaWxkcmVuLCBlbGVtZW50TmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50KGRpcmVjdGl2ZXMsIGVsZW1lbnQuc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50RXhwb3J0QXNWYXJzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbHRlcih2YXJzLCBmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiB2YXJBc3QudmFsdWUubGVuZ3RoID09PSAwOyB9KTtcclxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9XHJcbiAgICAgICAgICAgICAgICBuZXcgdGVtcGxhdGVfYXN0XzEuRWxlbWVudEFzdChub2RlTmFtZSwgYXR0cnMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCBlbGVtZW50RXhwb3J0QXNWYXJzLCBkaXJlY3RpdmVzLCBjaGlsZHJlbiwgZWxlbWVudE5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNzc1NlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKFRFTVBMQVRFX0VMRU1FTlQsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyhlbGVtZW50Lm5hbWUsIHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgdGVtcGxhdGVDc3NTZWxlY3RvciksIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVEaXJlY3RpdmVzKTtcclxuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZXMsIHRlbXBsYXRlRWxlbWVudFByb3BzLCBbXSwgZWxlbWVudC5zb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyB0ZW1wbGF0ZV9hc3RfMS5FbWJlZGRlZFRlbXBsYXRlQXN0KFtdLCB0ZW1wbGF0ZVZhcnMsIHRlbXBsYXRlRGlyZWN0aXZlcywgW3BhcnNlZEVsZW1lbnRdLCBjb21wb25lbnQuZmluZE5nQ29udGVudEluZGV4KHRlbXBsYXRlQ3NzU2VsZWN0b3IpLCBlbGVtZW50LnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nID0gZnVuY3Rpb24gKGF0dHIsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0VmFycykge1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gbnVsbDtcclxuICAgICAgICBpZiAoYXR0ci5uYW1lID09IFRFTVBMQVRFX0FUVFIpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGgoYXR0ci5uYW1lLCBURU1QTEFURV9BVFRSX1BSRUZJWCkpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN1YnN0cmluZyhhdHRyLm5hbWUsIFRFTVBMQVRFX0FUVFJfUFJFRklYLmxlbmd0aCk7IC8vIHJlbW92ZSB0aGUgc3RhclxyXG4gICAgICAgICAgICB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gKGF0dHIudmFsdWUubGVuZ3RoID09IDApID8ga2V5IDoga2V5ICsgJyAnICsgYXR0ci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGVCaW5kaW5nc1NvdXJjZSkpIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlQmluZGluZ3NTb3VyY2UsIGF0dHIuc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZGFzaENhc2VLZXkgPSB1dGlsXzEuY2FtZWxDYXNlVG9EYXNoQ2FzZShiaW5kaW5nLmtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5rZXlJc1Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgdGVtcGxhdGVfYXN0XzEuVmFyaWFibGVBc3QodXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UoYmluZGluZy5rZXkpLCBiaW5kaW5nLm5hbWUsIGF0dHIuc291cmNlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2Rhc2hDYXNlS2V5LCBiaW5kaW5nLm5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZGluZy5leHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QoZGFzaENhc2VLZXksIGJpbmRpbmcuZXhwcmVzc2lvbiwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbZGFzaENhc2VLZXksICcnXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXR0ciA9IGZ1bmN0aW9uIChhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0VmFycykge1xyXG4gICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcclxuICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcclxuICAgICAgICB2YXIgYmluZFBhcnRzID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChCSU5EX05BTUVfUkVHRVhQLCBhdHRyTmFtZSk7XHJcbiAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHMpKSB7XHJcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5KGJpbmRQYXJ0c1s1XSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1s1XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRWYXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRQYXJ0c1szXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXZlbnQoYmluZFBhcnRzWzVdLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbNF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5KGJpbmRQYXJ0c1s1XSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbNV0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRQYXJ0c1s2XSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHkoYmluZFBhcnRzWzZdLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1s2XSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzddKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eShiaW5kUGFydHNbN10sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzhdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChiaW5kUGFydHNbOF0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRoaXMuX3BhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKGF0dHJOYW1lLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoYXNCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlTGl0ZXJhbEF0dHIoYXR0ck5hbWUsIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VJbmZvLCB0YXJnZXRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fbm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKGF0dHJOYW1lLCAnZGF0YS0nKSA/IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN1YnN0cmluZyhhdHRyTmFtZSwgNSkgOlxyXG4gICAgICAgICAgICBhdHRyTmFtZTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVmFyaWFibGUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRWYXJzKSB7XHJcbiAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyB0ZW1wbGF0ZV9hc3RfMS5WYXJpYWJsZUFzdCh1dGlsXzEuZGFzaENhc2VUb0NhbWVsQ2FzZShpZGVudGlmaWVyKSwgdmFsdWUsIHNvdXJjZUluZm8pKTtcclxuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtpZGVudGlmaWVyLCB2YWx1ZV0pO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcclxuICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VJbmZvKSwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcclxuICAgICAgICB2YXIgZXhwciA9IHRoaXMuX3BhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlSW5mbyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZXhwcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCBleHByLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xyXG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcclxuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5KG5hbWUsIGFzdCwgZmFsc2UsIHNvdXJjZUluZm8pKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZUluZm8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcclxuICAgICAgICB0aGlzLl9wYXJzZUV2ZW50KG5hbWUgKyBcIi1jaGFuZ2VcIiwgZXhwcmVzc2lvbiArIFwiPSRldmVudFwiLCBzb3VyY2VJbmZvLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlSW5mbywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xyXG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXHJcbiAgICAgICAgdmFyIHBhcnRzID0gdXRpbF8xLnNwbGl0QXRDb2xvbihuYW1lLCBbbnVsbCwgbmFtZV0pO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBwYXJ0c1swXTtcclxuICAgICAgICB2YXIgZXZlbnROYW1lID0gcGFydHNbMV07XHJcbiAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLkJvdW5kRXZlbnRBc3QodXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UoZXZlbnROYW1lKSwgdGFyZ2V0LCB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBzb3VyY2VJbmZvKSwgc291cmNlSW5mbykpO1xyXG4gICAgICAgIC8vIERvbid0IGRldGVjdCBkaXJlY3RpdmVzIGZvciBldmVudCBuYW1lcyBmb3Igbm93LFxyXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlTGl0ZXJhbEF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZUluZm8sIHRhcmdldFByb3BzKSB7XHJcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eSh1dGlsXzEuZGFzaENhc2VUb0NhbWVsQ2FzZShuYW1lKSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgc291cmNlSW5mbyksIHRydWUsIHNvdXJjZUluZm8pKTtcclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBbXTtcclxuICAgICAgICBzZWxlY3Rvck1hdGNoZXIubWF0Y2goZWxlbWVudENzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpcmVjdGl2ZSkgeyBkaXJlY3RpdmVzLnB1c2goZGlyZWN0aXZlKTsgfSk7XHJcbiAgICAgICAgLy8gTmVlZCB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIHNvIHRoYXQgd2UgZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0LFxyXG4gICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxyXG4gICAgICAgIC8vIEFsc28gbmVlZCB0byBtYWtlIGNvbXBvbmVudHMgdGhlIGZpcnN0IGRpcmVjdGl2ZSBpbiB0aGUgYXJyYXlcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc29ydChkaXJlY3RpdmVzLCBmdW5jdGlvbiAoZGlyMSwgZGlyMikge1xyXG4gICAgICAgICAgICB2YXIgZGlyMUNvbXAgPSBkaXIxLmlzQ29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgZGlyMkNvbXAgPSBkaXIyLmlzQ29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoZGlyMUNvbXAgJiYgIWRpcjJDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpcjFDb21wICYmIGRpcjJDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kaXJlY3RpdmVzSW5kZXguZ2V0KGRpcjEpIC0gX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXIyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlQXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgZGlyZWN0aXZlcywgcHJvcHMsIHBvc3NpYmxlRXhwb3J0QXNWYXJzLCBzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbWF0Y2hlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBob3N0RXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVQcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGVsZW1lbnROYW1lLCBkaXJlY3RpdmUuaG9zdFByb3BlcnRpZXMsIHNvdXJjZUluZm8sIGhvc3RQcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLmhvc3RMaXN0ZW5lcnMsIHNvdXJjZUluZm8sIGhvc3RFdmVudHMpO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlUHJvcGVydHlBc3RzKGRpcmVjdGl2ZS5pbnB1dHMsIHByb3BzLCBkaXJlY3RpdmVQcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgdmFyIGV4cG9ydEFzVmFycyA9IFtdO1xyXG4gICAgICAgICAgICBwb3NzaWJsZUV4cG9ydEFzVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJBc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICgodmFyQXN0LnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmUuaXNDb21wb25lbnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZS5leHBvcnRBcyA9PSB2YXJBc3QudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXNWYXJzLnB1c2godmFyQXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmFyaWFibGVzLmFkZCh2YXJBc3QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRlbXBsYXRlX2FzdF8xLkRpcmVjdGl2ZUFzdChkaXJlY3RpdmUsIGRpcmVjdGl2ZVByb3BlcnRpZXMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBleHBvcnRBc1ZhcnMsIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBvc3NpYmxlRXhwb3J0QXNWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhckFzdCkge1xyXG4gICAgICAgICAgICBpZiAodmFyQXN0LnZhbHVlLmxlbmd0aCA+IDAgJiYgIWNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhtYXRjaGVkVmFyaWFibGVzLCB2YXJBc3QubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZXJlIGlzIG5vIGRpcmVjdGl2ZSB3aXRoIFxcXCJleHBvcnRBc1xcXCIgc2V0IHRvIFxcXCJcIiArIHZhckFzdC52YWx1ZSArIFwiXFxcIiBhdCBcIiArIHZhckFzdC5zb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgaG9zdFByb3BzLCBzb3VyY2VJbmZvLCB0YXJnZXRQcm9wZXJ0eUFzdHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGhvc3RQcm9wcykpIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChob3N0UHJvcHMsIGZ1bmN0aW9uIChleHByZXNzaW9uLCBwcm9wTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJBc3QgPSBfdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIHNvdXJjZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJvcGVydHlBc3RzLnB1c2goX3RoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGV4cHJBc3QsIHNvdXJjZUluZm8pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChob3N0TGlzdGVuZXJzLCBzb3VyY2VJbmZvLCB0YXJnZXRFdmVudEFzdHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGhvc3RMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goaG9zdExpc3RlbmVycywgZnVuY3Rpb24gKGV4cHJlc3Npb24sIHByb3BOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlSW5mbywgW10sIHRhcmdldEV2ZW50QXN0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBib3VuZFByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyZWN0aXZlUHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kUHJvcHNCeU5hbWUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UoYm91bmRQcm9wLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGJvdW5kUHJvcHNCeU5hbWUuZ2V0KGJvdW5kUHJvcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwcmV2VmFsdWUpIHx8IHByZXZWYWx1ZS5pc0xpdGVyYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYXRuIGE9XCJiXCIgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWUuc2V0KGtleSwgYm91bmRQcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goZGlyZWN0aXZlUHJvcGVydGllcywgZnVuY3Rpb24gKGVsUHJvcCwgZGlyUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgZWxQcm9wID0gdXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UoZWxQcm9wKTtcclxuICAgICAgICAgICAgICAgIHZhciBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lLmdldChlbFByb3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJvdW5kUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLkJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyUHJvcCwgYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBib3VuZFByb3Auc291cmNlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wcywgZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudFByb3BzID0gW107XHJcbiAgICAgICAgdmFyIGJvdW5kRGlyZWN0aXZlUHJvcHNJbmRleCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmUuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kRGlyZWN0aXZlUHJvcHNJbmRleC5zZXQocHJvcC50ZW1wbGF0ZU5hbWUsIHByb3ApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJvcC5pc0xpdGVyYWwgJiYgbGFuZ18xLmlzQmxhbmsoYm91bmREaXJlY3RpdmVQcm9wc0luZGV4LmdldChwcm9wLm5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRFbGVtZW50UHJvcHMucHVzaChfdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wLm5hbWUsIHByb3AuZXhwcmVzc2lvbiwgcHJvcC5zb3VyY2VJbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYm91bmRFbGVtZW50UHJvcHM7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIG5hbWUsIGFzdCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcclxuICAgICAgICB2YXIgYmluZGluZ1R5cGU7XHJcbiAgICAgICAgdmFyIGJvdW5kUHJvcGVydHlOYW1lO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KG5hbWUsIFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKHV0aWxfMS5kYXNoQ2FzZVRvQ2FtZWxDYXNlKHBhcnRzWzBdKSk7XHJcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNQcm9wZXJ0eShlbGVtZW50TmFtZSwgYm91bmRQcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkNhbid0IGJpbmQgdG8gJ1wiICsgYm91bmRQcm9wZXJ0eU5hbWUgKyBcIicgc2luY2UgaXQgaXNuJ3QgYSBrbm93biBuYXRpdmUgcHJvcGVydHkgaW4gXCIgKyBzb3VyY2VJbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XHJcbiAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gdXRpbF8xLmRhc2hDYXNlVG9DYW1lbENhc2UocGFydHNbMV0pO1xyXG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcclxuICAgICAgICAgICAgLy8ga2VlcCBvcmlnaW5hbCBjYXNlIVxyXG4gICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xyXG4gICAgICAgICAgICB1bml0ID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogbnVsbDtcclxuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB1dGlsXzEuZGFzaENhc2VUb0NhbWVsQ2FzZShwYXJ0c1sxXSk7XHJcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lIFwiICsgbmFtZSArIFwiIGluIFwiICsgc291cmNlSW5mbyk7XHJcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5Cb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIGFzdCwgdW5pdCwgc291cmNlSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xyXG4gICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSBbXTtcclxuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSBkaXJlY3RpdmUuZGlyZWN0aXZlLnR5cGUubmFtZTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGVOYW1lcy5wdXNoKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50ID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIk1vcmUgdGhhbiBvbmUgY29tcG9uZW50OiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJykgKyBcIiBpbiBcIiArIHNvdXJjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZWxlbWVudFByb3BzLCBldmVudHMsIHNvdXJjZUluZm8pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpICsgXCIgaW4gXCIgKyBzb3VyY2VJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUgaW4gXCIgKyBwcm9wLnNvdXJjZUluZm8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJFdmVudCBiaW5kaW5nIFwiICsgZXZlbnQubmFtZSArIFwiIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlIGluIFwiICsgZXZlbnQuc291cmNlSW5mbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VWaXNpdG9yO1xyXG59KSgpO1xyXG52YXIgTm9uQmluZGFibGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcclxuICAgIH1cclxuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5wcmVwYXJzZUVsZW1lbnQoYXN0KTtcclxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcclxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxyXG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQpIHtcclxuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcclxuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGF0dHJOYW1lQW5kVmFsdWVzID0gYXN0LmF0dHJzLm1hcChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gW2F0dHJBc3QubmFtZSwgYXR0ckFzdC52YWx1ZV07IH0pO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihhc3QubmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMpO1xyXG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IGNvbXBvbmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgRU1QVFlfQ09NUE9ORU5UKTtcclxuICAgICAgICByZXR1cm4gbmV3IHRlbXBsYXRlX2FzdF8xLkVsZW1lbnRBc3QoYXN0Lm5hbWUsIGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHRoaXMsIGFzdC5hdHRycyksIFtdLCBbXSwgW10sIFtdLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgIH07XHJcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHRlbXBsYXRlX2FzdF8xLkF0dHJBc3QoYXN0Lm5hbWUsIGFzdC52YWx1ZSwgYXN0LnNvdXJjZUluZm8pO1xyXG4gICAgfTtcclxuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gY29tcG9uZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5UZXh0QXN0KGFzdC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VJbmZvKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9uQmluZGFibGVWaXNpdG9yO1xyXG59KSgpO1xyXG52YXIgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIGlzTGl0ZXJhbCwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuICAgICAgICB0aGlzLmlzTGl0ZXJhbCA9IGlzTGl0ZXJhbDtcclxuICAgICAgICB0aGlzLnNvdXJjZUluZm8gPSBzb3VyY2VJbmZvO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHk7XHJcbn0pKCk7XHJcbnZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhcnNlRXJyb3IobWVzc2FnZSwgc291cmNlSW5mbykge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VJbmZvID0gc291cmNlSW5mbztcclxuICAgIH1cclxuICAgIHJldHVybiBQYXJzZUVycm9yO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBzcGxpdENsYXNzZXMoY2xhc3NBdHRyVmFsdWUpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5zcGxpdChjbGFzc0F0dHJWYWx1ZS50cmltKCksIC9cXHMrL2cpO1xyXG59XHJcbmV4cG9ydHMuc3BsaXRDbGFzc2VzID0gc3BsaXRDbGFzc2VzO1xyXG52YXIgQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChuZ0NvbnRlbnRJbmRleE1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4TWF0Y2hlciA9IG5nQ29udGVudEluZGV4TWF0Y2hlcjtcclxuICAgICAgICB0aGlzLndpbGRjYXJkTmdDb250ZW50SW5kZXggPSB3aWxkY2FyZE5nQ29udGVudEluZGV4O1xyXG4gICAgfVxyXG4gICAgQ29tcG9uZW50LmNyZWF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwIHx8ICFkaXJlY3RpdmVzWzBdLmRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQ09NUE9ORU5UO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yTWF0Y2hlcigpO1xyXG4gICAgICAgIHZhciBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBkaXJlY3RpdmVzWzBdLmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XHJcbiAgICAgICAgdmFyIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IG5nQ29udGVudFNlbGVjdG9yc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhzZWxlY3RvciwgJyonKSkge1xyXG4gICAgICAgICAgICAgICAgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmFkZFNlbGVjdGFibGVzKHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQobWF0Y2hlciwgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5maW5kTmdDb250ZW50SW5kZXggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgbmdDb250ZW50SW5kaWNlcyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMud2lsZGNhcmROZ0NvbnRlbnRJbmRleCkpIHtcclxuICAgICAgICAgICAgbmdDb250ZW50SW5kaWNlcy5wdXNoKHRoaXMud2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXhNYXRjaGVyLm1hdGNoKHNlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG5nQ29udGVudEluZGV4KSB7IG5nQ29udGVudEluZGljZXMucHVzaChuZ0NvbnRlbnRJbmRleCk7IH0pO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5zb3J0KG5nQ29udGVudEluZGljZXMpO1xyXG4gICAgICAgIHJldHVybiBuZ0NvbnRlbnRJbmRpY2VzLmxlbmd0aCA+IDAgPyBuZ0NvbnRlbnRJbmRpY2VzWzBdIDogbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50O1xyXG59KSgpO1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIG1hdGNoYWJsZUF0dHJzKSB7XHJcbiAgICB2YXIgY3NzU2VsZWN0b3IgPSBuZXcgc2VsZWN0b3JfMS5Dc3NTZWxlY3RvcigpO1xyXG4gICAgY3NzU2VsZWN0b3Iuc2V0RWxlbWVudChlbGVtZW50TmFtZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoYWJsZUF0dHJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gbWF0Y2hhYmxlQXR0cnNbaV1bMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgYXR0clZhbHVlID0gbWF0Y2hhYmxlQXR0cnNbaV1bMV07XHJcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xyXG4gICAgICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc3BsaXRDbGFzc2VzKGF0dHJWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBjc3NTZWxlY3Rvci5hZGRDbGFzc05hbWUoY2xhc3NOYW1lKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xyXG59XHJcbnZhciBFTVBUWV9DT01QT05FTlQgPSBuZXcgQ29tcG9uZW50KG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yTWF0Y2hlcigpLCBudWxsKTtcclxudmFyIE5PTl9CSU5EQUJMRV9WSVNJVE9SID0gbmV3IE5vbkJpbmRhYmxlVmlzaXRvcigpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9wYXJzZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiA9ICdzZWxlY3QnO1xyXG52YXIgTkdfQ09OVEVOVF9FTEVNRU5UID0gJ25nLWNvbnRlbnQnO1xyXG52YXIgTElOS19FTEVNRU5UID0gJ2xpbmsnO1xyXG52YXIgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xyXG52YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XHJcbnZhciBMSU5LX1NUWUxFX1JFTF9WQUxVRSA9ICdzdHlsZXNoZWV0JztcclxudmFyIFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xyXG52YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcclxudmFyIE5HX05PTl9CSU5EQUJMRV9BVFRSID0gJ25nLW5vbi1iaW5kYWJsZSc7XHJcbmZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcclxuICAgIHZhciBzZWxlY3RBdHRyID0gbnVsbDtcclxuICAgIHZhciBocmVmQXR0ciA9IG51bGw7XHJcbiAgICB2YXIgcmVsQXR0ciA9IG51bGw7XHJcbiAgICB2YXIgbm9uQmluZGFibGUgPSBmYWxzZTtcclxuICAgIGFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XHJcbiAgICAgICAgaWYgKGF0dHIubmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdEF0dHIgPSBhdHRyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcclxuICAgICAgICAgICAgaHJlZkF0dHIgPSBhdHRyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTElOS19TVFlMRV9SRUxfQVRUUikge1xyXG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX05PTl9CSU5EQUJMRV9BVFRSKSB7XHJcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XHJcbiAgICB2YXIgbm9kZU5hbWUgPSBhc3QubmFtZTtcclxuICAgIHZhciB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XHJcbiAgICBpZiAobm9kZU5hbWUgPT0gTkdfQ09OVEVOVF9FTEVNRU5UKSB7XHJcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XHJcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcclxuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcclxuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUpO1xyXG59XHJcbmV4cG9ydHMucHJlcGFyc2VFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50O1xyXG4oZnVuY3Rpb24gKFByZXBhcnNlZEVsZW1lbnRUeXBlKSB7XHJcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xyXG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVwiXSA9IDFdID0gXCJTVFlMRVwiO1xyXG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVNIRUVUXCJdID0gMl0gPSBcIlNUWUxFU0hFRVRcIjtcclxuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xyXG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJPVEhFUlwiXSA9IDRdID0gXCJPVEhFUlwiO1xyXG59KShleHBvcnRzLlByZXBhcnNlZEVsZW1lbnRUeXBlIHx8IChleHBvcnRzLlByZXBhcnNlZEVsZW1lbnRUeXBlID0ge30pKTtcclxudmFyIFByZXBhcnNlZEVsZW1lbnRUeXBlID0gZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50VHlwZTtcclxudmFyIFByZXBhcnNlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0QXR0ciA9IHNlbGVjdEF0dHI7XHJcbiAgICAgICAgdGhpcy5ocmVmQXR0ciA9IGhyZWZBdHRyO1xyXG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcmVwYXJzZWRFbGVtZW50O1xyXG59KSgpO1xyXG5leHBvcnRzLlByZXBhcnNlZEVsZW1lbnQgPSBQcmVwYXJzZWRFbGVtZW50O1xyXG5mdW5jdGlvbiBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cikge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHNlbGVjdEF0dHIpIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcqJztcclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3RBdHRyO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlX3ByZXBhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFVzZWQgYnkgdGhlIHtAbGluayBDb21waWxlcn0gd2hlbiByZXNvbHZpbmcgSFRNTCBhbmQgQ1NTIHRlbXBsYXRlIFVSTHMuXHJcbiAqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cclxuICpcclxuICogU2VlIHtAbGluayBDb21waWxlcn1cclxuICovXHJcbnZhciBVcmxSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcmxSZXNvbHZlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgdGhlIGB1cmxgIGdpdmVuIHRoZSBgYmFzZVVybGA6XHJcbiAgICAgKiAtIHdoZW4gdGhlIGB1cmxgIGlzIG51bGwsIHRoZSBgYmFzZVVybGAgaXMgcmV0dXJuZWQsXHJcbiAgICAgKiAtIGlmIGB1cmxgIGlzIHJlbGF0aXZlICgncGF0aC90by9oZXJlJywgJy4vcGF0aC90by9oZXJlJyksIHRoZSByZXNvbHZlZCB1cmwgaXMgYSBjb21iaW5hdGlvbiBvZlxyXG4gICAgICogYGJhc2VVcmxgIGFuZCBgdXJsYCxcclxuICAgICAqIC0gaWYgYHVybGAgaXMgYWJzb2x1dGUgKGl0IGhhcyBhIHNjaGVtZTogJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nIG9yIHN0YXJ0IHdpdGggJy8nKSwgdGhlIGB1cmxgIGlzXHJcbiAgICAgKiByZXR1cm5lZCBhcyBpcyAoaWdub3JpbmcgdGhlIGBiYXNlVXJsYClcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc29sdmVkIFVSTFxyXG4gICAgICovXHJcbiAgICBVcmxSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCB1cmwpIHsgcmV0dXJuIF9yZXNvbHZlVXJsKGJhc2VVcmwsIHVybCk7IH07XHJcbiAgICBVcmxSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgVXJsUmVzb2x2ZXIpO1xyXG4gICAgcmV0dXJuIFVybFJlc29sdmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlVybFJlc29sdmVyID0gVXJsUmVzb2x2ZXI7XHJcbi8vIFRoZSBjb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSBUcmFjZXVyOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RyYWNldXItY29tcGlsZXIvYmxvYi85NTExYzFkYWZhOTcyYmYwZGUxMjAyYThhODYzYmFkMDJmMGY5NWE4L3NyYy9ydW50aW1lL3VybC5qc1xyXG4vKipcclxuICogQnVpbGRzIGEgVVJJIHN0cmluZyBmcm9tIGFscmVhZHktZW5jb2RlZCBwYXJ0cy5cclxuICpcclxuICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxyXG4gKiB1bmRlZmluZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cclxuICogQHBhcmFtIHs/c3RyaW5nPX0gb3B0X3VzZXJJbmZvIFRoZSB1c2VyIG5hbWUgYmVmb3JlIHRoZSAnQCcuXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9kb21haW4gVGhlIGRvbWFpbiBzdWNoIGFzICd3d3cuZ29vZ2xlLmNvbScsIGFscmVhZHlcclxuICogICAgIFVSSS1lbmNvZGVkLlxyXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVsbCk9fSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9wYXRoIFRoZSBwYXRoLCBhbHJlYWR5IFVSSS1lbmNvZGVkLiAgSWYgaXQgaXMgbm90XHJcbiAqICAgICBlbXB0eSwgaXQgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXHJcbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9mcmFnbWVudCBUaGUgVVJJLWVuY29kZWQgZnJhZ21lbnQgaWRlbnRpZmllci5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxyXG4gKi9cclxuZnVuY3Rpb24gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhvcHRfc2NoZW1lLCBvcHRfdXNlckluZm8sIG9wdF9kb21haW4sIG9wdF9wb3J0LCBvcHRfcGF0aCwgb3B0X3F1ZXJ5RGF0YSwgb3B0X2ZyYWdtZW50KSB7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfc2NoZW1lKSkge1xyXG4gICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X2RvbWFpbikpIHtcclxuICAgICAgICBvdXQucHVzaCgnLy8nKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfdXNlckluZm8pKSB7XHJcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5wdXNoKG9wdF9kb21haW4pO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9wb3J0KSkge1xyXG4gICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X3BhdGgpKSB7XHJcbiAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X3F1ZXJ5RGF0YSkpIHtcclxuICAgICAgICBvdXQucHVzaCgnPycgKyBvcHRfcXVlcnlEYXRhKTtcclxuICAgIH1cclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9mcmFnbWVudCkpIHtcclxuICAgICAgICBvdXQucHVzaCgnIycgKyBvcHRfZnJhZ21lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufVxyXG4vKipcclxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cclxuICpcclxuICoge0BsaW5rIGh0dHA6Ly93d3cuZ2Jpdi5jb20vcHJvdG9jb2xzL3VyaS9yZmMvcmZjMzk4Ni5odG1sI1JGQzIyMzR9IHNheXNcclxuICogQXMgdGhlIFwiZmlyc3QtbWF0Y2gtd2luc1wiIGFsZ29yaXRobSBpcyBpZGVudGljYWwgdG8gdGhlIFwiZ3JlZWR5XCJcclxuICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcclxuICogY29tbW9ucGxhY2UgdG8gdXNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBwYXJzaW5nIHRoZSBwb3RlbnRpYWwgZml2ZVxyXG4gKiBjb21wb25lbnRzIG9mIGEgVVJJIHJlZmVyZW5jZS5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyBsaW5lIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nLWRvd24gYVxyXG4gKiB3ZWxsLWZvcm1lZCBVUkkgcmVmZXJlbmNlIGludG8gaXRzIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cclxuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxyXG4gKiBpbmRpY2F0ZSB0aGUgcmVmZXJlbmNlIHBvaW50cyBmb3IgZWFjaCBzdWJleHByZXNzaW9uIChpLmUuLCBlYWNoIHBhaXJlZFxyXG4gKiBwYXJlbnRoZXNpcykuIFdlIHJlZmVyIHRvIHRoZSB2YWx1ZSBtYXRjaGVkIGZvciBzdWJleHByZXNzaW9uIDxuPiBhcyAkPG4+LlxyXG4gKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cclxuICogPHByZT5cclxuICogICAgIGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXHJcbiAqIDwvcHJlPlxyXG4gKiByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgc3ViZXhwcmVzc2lvbiBtYXRjaGVzOlxyXG4gKiA8cHJlPlxyXG4gKiAgICAkMSA9IGh0dHA6XHJcbiAqICAgICQyID0gaHR0cFxyXG4gKiAgICAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XHJcbiAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XHJcbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS9cclxuICogICAgJDYgPSA8dW5kZWZpbmVkPlxyXG4gKiAgICAkNyA9IDx1bmRlZmluZWQ+XHJcbiAqICAgICQ4ID0gI1JlbGF0ZWRcclxuICogICAgJDkgPSBSZWxhdGVkXHJcbiAqIDwvcHJlPlxyXG4gKiB3aGVyZSA8dW5kZWZpbmVkPiBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tcG9uZW50IGlzIG5vdCBwcmVzZW50LCBhcyBpcyB0aGVcclxuICogY2FzZSBmb3IgdGhlIHF1ZXJ5IGNvbXBvbmVudCBpbiB0aGUgYWJvdmUgZXhhbXBsZS4gVGhlcmVmb3JlLCB3ZSBjYW5cclxuICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXHJcbiAqIDxwcmU+XHJcbiAqICAgIHNjaGVtZSAgICA9ICQyXHJcbiAqICAgIGF1dGhvcml0eSA9ICQ0XHJcbiAqICAgIHBhdGggICAgICA9ICQ1XHJcbiAqICAgIHF1ZXJ5ICAgICA9ICQ3XHJcbiAqICAgIGZyYWdtZW50ICA9ICQ5XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcclxuICogdXNlckluZm8sIGRvbWFpbiwgYW5kIHBvcnQgc2VwYXJhdGVseSBmcm9tIHRoZSBhdXRob3JpdHkuXHJcbiAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xyXG4gKiA8cHJlPlxyXG4gKiAgICAkMSA9IGh0dHAgICAgICAgICAgICAgIHNjaGVtZVxyXG4gKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIHVzZXJJbmZvIC1cXFxyXG4gKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcclxuICogICAgJDQgPSA8dW5kZWZpbmVkPiAgICAgICBwb3J0ICAgICAtL1xyXG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvICAgIHBhdGhcclxuICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cclxuICogICAgJDcgPSBSZWxhdGVkICAgICAgICAgICBmcmFnbWVudCB3aXRob3V0ICNcclxuICogPC9wcmU+XHJcbiAqIEB0eXBlIHshUmVnRXhwfVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBfc3BsaXRSZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnXicgK1xyXG4gICAgJyg/OicgK1xyXG4gICAgJyhbXjovPyMuXSspJyArXHJcbiAgICAvLyB1c2VkIGJ5IG90aGVyIFVSTCBwYXJ0cyBzdWNoIGFzIDosXHJcbiAgICAvLyA/LCAvLCAjLCBhbmQgLlxyXG4gICAgJzopPycgK1xyXG4gICAgJyg/Oi8vJyArXHJcbiAgICAnKD86KFteLz8jXSopQCk/JyArXHJcbiAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICtcclxuICAgIC8vIGRpZ2l0cywgZGFzaGVzLCBkb3RzLCBwZXJjZW50XHJcbiAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxyXG4gICAgJyg/OjooWzAtOV0rKSk/JyArXHJcbiAgICAnKT8nICtcclxuICAgICcoW14/I10rKT8nICtcclxuICAgICcoPzpcXFxcPyhbXiNdKikpPycgK1xyXG4gICAgJyg/OiMoLiopKT8nICtcclxuICAgICckJyk7XHJcbi8qKlxyXG4gKiBUaGUgaW5kZXggb2YgZWFjaCBVUkkgY29tcG9uZW50IGluIHRoZSByZXR1cm4gdmFsdWUgb2YgZ29vZy51cmkudXRpbHMuc3BsaXQuXHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG52YXIgX0NvbXBvbmVudEluZGV4O1xyXG4oZnVuY3Rpb24gKF9Db21wb25lbnRJbmRleCkge1xyXG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlNjaGVtZVwiXSA9IDFdID0gXCJTY2hlbWVcIjtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJVc2VySW5mb1wiXSA9IDJdID0gXCJVc2VySW5mb1wiO1xyXG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkRvbWFpblwiXSA9IDNdID0gXCJEb21haW5cIjtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQb3J0XCJdID0gNF0gPSBcIlBvcnRcIjtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQYXRoXCJdID0gNV0gPSBcIlBhdGhcIjtcclxuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJRdWVyeURhdGFcIl0gPSA2XSA9IFwiUXVlcnlEYXRhXCI7XHJcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiRnJhZ21lbnRcIl0gPSA3XSA9IFwiRnJhZ21lbnRcIjtcclxufSkoX0NvbXBvbmVudEluZGV4IHx8IChfQ29tcG9uZW50SW5kZXggPSB7fSkpO1xyXG4vKipcclxuICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cclxuICpcclxuICogRWFjaCBjb21wb25lbnQgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgY29tcG9uZW50IGluZGljZXM7IGZvciBleGFtcGxlOlxyXG4gKiA8cHJlPlxyXG4gKiBnb29nLnVyaS51dGlscy5zcGxpdChzb21lU3RyKVtnb29nLnVyaS51dGlscy5Db21wb250ZW50SW5kZXguUVVFUllfREFUQV07XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpIFRoZSBVUkkgc3RyaW5nIHRvIGV4YW1pbmUuXHJcbiAqIEByZXR1cm4geyFBcnJheS48c3RyaW5nfHVuZGVmaW5lZD59IEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxyXG4gKiAgICAgRWFjaCBjb21wb25lbnQgdGhhdCBpcyBwcmVzZW50IHdpbGwgY29udGFpbiB0aGUgZW5jb2RlZCB2YWx1ZSwgd2hlcmVhc1xyXG4gKiAgICAgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcHJlc2VudCB3aWxsIGJlIHVuZGVmaW5lZCBvciBlbXB0eSwgZGVwZW5kaW5nXHJcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXHJcbiAqICAgICBhcmJpdHJhcnkgc3RyaW5ncyBtYXkgc3RpbGwgbG9vayBsaWtlIHBhdGggbmFtZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChfc3BsaXRSZSwgdXJpKTtcclxufVxyXG4vKipcclxuICAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIGluIGdpdmVuIHBhdGggY29tcG9uZW50LCBhcyBkZXNjcmliZWQgaW5cclxuICAqIFJGQyAzOTg2LCBzZWN0aW9uIDUuMi40LlxyXG4gICpcclxuICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEEgbm9uLWVtcHR5IHBhdGggY29tcG9uZW50LlxyXG4gICogQHJldHVybiB7c3RyaW5nfSBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxyXG4gICovXHJcbmZ1bmN0aW9uIF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKSB7XHJcbiAgICBpZiAocGF0aCA9PSAnLycpXHJcbiAgICAgICAgcmV0dXJuICcvJztcclxuICAgIHZhciBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xyXG4gICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xyXG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgdmFyIG91dCA9IFtdO1xyXG4gICAgdmFyIHVwID0gMDtcclxuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcclxuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XHJcbiAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJyc6XHJcbiAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJy4uJzpcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWFkaW5nU2xhc2ggPT0gJycpIHtcclxuICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcclxuICAgICAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICBvdXQucHVzaCgnLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XHJcbiAqIGFuZCB0aGVuIGpvaW5zIGFsbCB0aGUgcGFydHMuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz8+fSBwYXJ0c1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpIHtcclxuICAgIHZhciBwYXRoID0gcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xyXG4gICAgcGF0aCA9IGxhbmdfMS5pc0JsYW5rKHBhdGgpID8gJycgOiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XHJcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xyXG4gICAgcmV0dXJuIF9idWlsZEZyb21FbmNvZGVkUGFydHMocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Vc2VySW5mb10sIHBhcnRzW19Db21wb25lbnRJbmRleC5Eb21haW5dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUG9ydF0sIHBhdGgsIHBhcnRzW19Db21wb25lbnRJbmRleC5RdWVyeURhdGFdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRnJhZ21lbnRdKTtcclxufVxyXG4vKipcclxuICogUmVzb2x2ZXMgYSBVUkwuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFRoZSBVUkwgYWN0aW5nIGFzIHRoZSBiYXNlIFVSTC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRvIFRoZSBVUkwgdG8gcmVzb2x2ZS5cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XHJcbiAgICB2YXIgcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xyXG4gICAgdmFyIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdKSkge1xyXG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gX0NvbXBvbmVudEluZGV4LlNjaGVtZTsgaSA8PSBfQ29tcG9uZW50SW5kZXguUG9ydDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcnRzW2ldKSkge1xyXG4gICAgICAgICAgICBwYXJ0c1tpXSA9IGJhc2VQYXJ0c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdWzBdID09ICcvJykge1xyXG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGgpKVxyXG4gICAgICAgIHBhdGggPSAnLyc7XHJcbiAgICB2YXIgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XHJcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKSArIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcclxuICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XHJcbiAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxfcmVzb2x2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSAvKFtBLVpdKS9nO1xyXG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKFthLXpdKS9nO1xyXG52YXIgU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXCQvZztcclxudmFyIERPVUJMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFID0gL1wifFxcXFx8XFxufFxcJC9nO1xyXG5leHBvcnRzLklTX0RBUlQgPSAhbGFuZ18xLmlzSnNPYmplY3Qoe30pO1xyXG5leHBvcnRzLk1PRFVMRV9TVUZGSVggPSBleHBvcnRzLklTX0RBUlQgPyAnLmRhcnQnIDogJy5qcyc7XHJcbmZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcclxuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBDQU1FTF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5jYW1lbENhc2VUb0Rhc2hDYXNlID0gY2FtZWxDYXNlVG9EYXNoQ2FzZTtcclxuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG59XHJcbmV4cG9ydHMuZGFzaENhc2VUb0NhbWVsQ2FzZSA9IGRhc2hDYXNlVG9DYW1lbENhc2U7XHJcbmZ1bmN0aW9uIGVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nKGlucHV0KSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5wdXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCInXCIgKyBlc2NhcGVTdHJpbmcoaW5wdXQsIFNJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFKSArIFwiJ1wiO1xyXG59XHJcbmV4cG9ydHMuZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcgPSBlc2NhcGVTaW5nbGVRdW90ZVN0cmluZztcclxuZnVuY3Rpb24gZXNjYXBlRG91YmxlUXVvdGVTdHJpbmcoaW5wdXQpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnB1dCkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBcIlxcXCJcIiArIGVzY2FwZVN0cmluZyhpbnB1dCwgRE9VQkxFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUpICsgXCJcXFwiXCI7XHJcbn1cclxuZXhwb3J0cy5lc2NhcGVEb3VibGVRdW90ZVN0cmluZyA9IGVzY2FwZURvdWJsZVF1b3RlU3RyaW5nO1xyXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoaW5wdXQsIHJlKSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgcmUsIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgIGlmIChtYXRjaFswXSA9PSAnJCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSVNfREFSVCA/ICdcXFxcJCcgOiAnJCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXG4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY29kZUdlbkV4cG9ydFZhcmlhYmxlKG5hbWUsIGlzQ29uc3QpIHtcclxuICAgIGlmIChpc0NvbnN0ID09PSB2b2lkIDApIHsgaXNDb25zdCA9IGZhbHNlOyB9XHJcbiAgICB2YXIgZGVjbGFyYXRpb24gPSBleHBvcnRzLklTX0RBUlQgJiYgaXNDb25zdCA/IFwiY29uc3QgXCIgKyBuYW1lIDogXCJ2YXIgXCIgKyBuYW1lO1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuSVNfREFSVCA/IGRlY2xhcmF0aW9uICsgXCIgPSBcIiA6IGRlY2xhcmF0aW9uICsgXCIgPSBleHBvcnRzWydcIiArIG5hbWUgKyBcIiddID0gXCI7XHJcbn1cclxuZXhwb3J0cy5jb2RlR2VuRXhwb3J0VmFyaWFibGUgPSBjb2RlR2VuRXhwb3J0VmFyaWFibGU7XHJcbmZ1bmN0aW9uIGNvZGVHZW5Db25jYXRBcnJheShleHByZXNzaW9uKSB7XHJcbiAgICByZXR1cm4gKGV4cG9ydHMuSVNfREFSVCA/ICcuLmFkZEFsbCcgOiAnLmNvbmNhdCcpICsgXCIoXCIgKyBleHByZXNzaW9uICsgXCIpXCI7XHJcbn1cclxuZXhwb3J0cy5jb2RlR2VuQ29uY2F0QXJyYXkgPSBjb2RlR2VuQ29uY2F0QXJyYXk7XHJcbmZ1bmN0aW9uIGNvZGVHZW5NYXBBcnJheShhcmdOYW1lcywgY2FsbGJhY2spIHtcclxuICAgIGlmIChleHBvcnRzLklTX0RBUlQpIHtcclxuICAgICAgICByZXR1cm4gXCIubWFwKCAoXCIgKyBhcmdOYW1lcy5qb2luKCcsJykgKyBcIikgPT4gXCIgKyBjYWxsYmFjayArIFwiICkudG9MaXN0KClcIjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIi5tYXAoZnVuY3Rpb24oXCIgKyBhcmdOYW1lcy5qb2luKCcsJykgKyBcIikgeyByZXR1cm4gXCIgKyBjYWxsYmFjayArIFwiOyB9KVwiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29kZUdlbk1hcEFycmF5ID0gY29kZUdlbk1hcEFycmF5O1xyXG5mdW5jdGlvbiBjb2RlR2VuUmVwbGFjZUFsbChwYXR0ZXJuLCBleHByZXNzaW9uKSB7XHJcbiAgICBpZiAoZXhwb3J0cy5JU19EQVJUKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiLnJlcGxhY2VBbGwoJ1wiICsgcGF0dGVybiArIFwiJywgXCIgKyBleHByZXNzaW9uICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCIucmVwbGFjZSgvXCIgKyBwYXR0ZXJuICsgXCIvZywgXCIgKyBleHByZXNzaW9uICsgXCIpXCI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb2RlR2VuUmVwbGFjZUFsbCA9IGNvZGVHZW5SZXBsYWNlQWxsO1xyXG5mdW5jdGlvbiBjb2RlR2VuVmFsdWVGbihwYXJhbXMsIHZhbHVlLCBmbk5hbWUpIHtcclxuICAgIGlmIChmbk5hbWUgPT09IHZvaWQgMCkgeyBmbk5hbWUgPSAnJzsgfVxyXG4gICAgaWYgKGV4cG9ydHMuSVNfREFSVCkge1xyXG4gICAgICAgIHJldHVybiBmbk5hbWUgKyBcIihcIiArIHBhcmFtcy5qb2luKCcsJykgKyBcIikgPT4gXCIgKyB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uIFwiICsgZm5OYW1lICsgXCIoXCIgKyBwYXJhbXMuam9pbignLCcpICsgXCIpIHsgcmV0dXJuIFwiICsgdmFsdWUgKyBcIjsgfVwiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29kZUdlblZhbHVlRm4gPSBjb2RlR2VuVmFsdWVGbjtcclxuZnVuY3Rpb24gY29kZUdlblRvU3RyaW5nKGV4cHIpIHtcclxuICAgIGlmIChleHBvcnRzLklTX0RBUlQpIHtcclxuICAgICAgICByZXR1cm4gXCInJHtcIiArIGV4cHIgKyBcIn0nXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBKUyBhdXRvbWF0aWNhbGx5IGNvbnZldHMgdG8gc3RyaW5nLi4uXHJcbiAgICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb2RlR2VuVG9TdHJpbmcgPSBjb2RlR2VuVG9TdHJpbmc7XHJcbmZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xyXG4gICAgdmFyIHBhcnRzID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQoaW5wdXQudHJpbSgpLCAvXFxzKjpcXHMqL2cpO1xyXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICByZXR1cm4gcGFydHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlcztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNwbGl0QXRDb2xvbiA9IHNwbGl0QXRDb2xvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIFhIUiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBYSFIoKSB7XHJcbiAgICB9XHJcbiAgICBYSFIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICByZXR1cm4gWEhSO1xyXG59KSgpO1xyXG5leHBvcnRzLlhIUiA9IFhIUjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgeGhyXzEgPSByZXF1aXJlKCcuL3hocicpO1xyXG52YXIgWEhSSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoWEhSSW1wbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFhIUkltcGwoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBYSFJJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlciA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuY29tcGxldGVyKCk7XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xyXG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcclxuICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFhIUiBMZXZlbDIgc3BlYyAoc3VwcG9ydGVkIGJ5IElFMTApXHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGxhbmdfMS5pc1ByZXNlbnQoeGhyLnJlc3BvbnNlKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XHJcbiAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXHJcbiAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcbiAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2UgPyAyMDAgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8PSAzMDApIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyBjb21wbGV0ZXIucmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwsIG51bGwpOyB9O1xyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlci5wcm9taXNlO1xyXG4gICAgfTtcclxuICAgIFhIUkltcGwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFhIUkltcGwpO1xyXG4gICAgcmV0dXJuIFhIUkltcGw7XHJcbn0pKHhocl8xLlhIUik7XHJcbmV4cG9ydHMuWEhSSW1wbCA9IFhIUkltcGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhocl9pbXBsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgZGVidWdfZWxlbWVudF8xID0gcmVxdWlyZSgnLi9kZWJ1Zy9kZWJ1Z19lbGVtZW50Jyk7XHJcbmV4cG9ydHMuRGVidWdFbGVtZW50ID0gZGVidWdfZWxlbWVudF8xLkRlYnVnRWxlbWVudDtcclxuZXhwb3J0cy5hc05hdGl2ZUVsZW1lbnRzID0gZGVidWdfZWxlbWVudF8xLmFzTmF0aXZlRWxlbWVudHM7XHJcbmV4cG9ydHMuQnkgPSBkZWJ1Z19lbGVtZW50XzEuQnk7XHJcbmV4cG9ydHMuU2NvcGUgPSBkZWJ1Z19lbGVtZW50XzEuU2NvcGU7XHJcbmV4cG9ydHMuaW5zcGVjdEVsZW1lbnQgPSBkZWJ1Z19lbGVtZW50XzEuaW5zcGVjdEVsZW1lbnQ7XHJcbnZhciBkZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXJfMSA9IHJlcXVpcmUoJy4vZGVidWcvZGVidWdfZWxlbWVudF92aWV3X2xpc3RlbmVyJyk7XHJcbmV4cG9ydHMuaW5zcGVjdE5hdGl2ZUVsZW1lbnQgPSBkZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXJfMS5pbnNwZWN0TmF0aXZlRWxlbWVudDtcclxuZXhwb3J0cy5FTEVNRU5UX1BST0JFX1BST1ZJREVSUyA9IGRlYnVnX2VsZW1lbnRfdmlld19saXN0ZW5lcl8xLkVMRU1FTlRfUFJPQkVfUFJPVklERVJTO1xyXG5leHBvcnRzLkVMRU1FTlRfUFJPQkVfQklORElOR1MgPSBkZWJ1Z19lbGVtZW50X3ZpZXdfbGlzdGVuZXJfMS5FTEVNRU5UX1BST0JFX0JJTkRJTkdTO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19yZWYnKTtcclxuLyoqXHJcbiAqIEEgRGVidWdFbGVtZW50IGNvbnRhaW5zIGluZm9ybWF0aW9uIGZyb20gdGhlIEFuZ3VsYXIgY29tcGlsZXIgYWJvdXQgYW5cclxuICogZWxlbWVudCBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnRJbmplY3RvciBhbmRcclxuICogdW5kZXJseWluZyBET00gRWxlbWVudCwgYXMgd2VsbCBhcyBhIHdheSB0byBxdWVyeSBmb3IgY2hpbGRyZW4uXHJcbiAqL1xyXG52YXIgRGVidWdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlYnVnRWxlbWVudCgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcImNvbXBvbmVudEluc3RhbmNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudC5wcm90b3R5cGUsIFwibmF0aXZlRWxlbWVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGNoaWxkIERlYnVnRWxlbWVudHMgZnJvbSB3aXRoaW4gdGhlIExpZ2h0IERPTS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0RlYnVnRWxlbWVudFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjb21wb25lbnRWaWV3Q2hpbGRyZW5cIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgcm9vdCBEZWJ1Z0VsZW1lbnQgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQuIFJldHVybnMgYW4gZW1wdHlcclxuICAgICAgICAgKiBsaXN0IGlmIHRoZSBjdXJyZW50IERlYnVnRWxlbWVudCBpcyBub3QgYSBjb21wb25lbnQgcm9vdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0RlYnVnRWxlbWVudFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZmlyc3QgZGVzY2VuZGFudCBUZXN0RWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gcHJlZGljYXRlXHJcbiAgICAgKiBhbmQgc2NvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbjogYm9vbGVhbn0gcHJlZGljYXRlXHJcbiAgICAgKiBAcGFyYW0ge1Njb3BlfSBzY29wZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0RlYnVnRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHNjb3BlKSB7XHJcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBTY29wZS5hbGw7IH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucXVlcnlBbGwocHJlZGljYXRlLCBzY29wZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHNbMF0gOiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGRlc2NlbmRhbnQgVGVzdEVsZW1lbXRzIG1hdGNoaW5nIHRoZSBnaXZlbiBwcmVkaWNhdGVcclxuICAgICAqIGFuZCBzY29wZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uOiBib29sZWFufSBwcmVkaWNhdGVcclxuICAgICAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7RGVidWdFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnlBbGwgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBzY29wZSkge1xyXG4gICAgICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gU2NvcGUuYWxsOyB9XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzSW5TY29wZSA9IHNjb3BlKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlsdGVyKGVsZW1lbnRzSW5TY29wZSwgcHJlZGljYXRlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVidWdFbGVtZW50O1xyXG59KSgpO1xyXG5leHBvcnRzLkRlYnVnRWxlbWVudCA9IERlYnVnRWxlbWVudDtcclxudmFyIERlYnVnRWxlbWVudF8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERlYnVnRWxlbWVudF8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZWJ1Z0VsZW1lbnRfKF9wYXJlbnRWaWV3LCBfYm91bmRFbGVtZW50SW5kZXgpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wYXJlbnRWaWV3ID0gX3BhcmVudFZpZXc7XHJcbiAgICAgICAgdGhpcy5fYm91bmRFbGVtZW50SW5kZXggPSBfYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudEluamVjdG9yID0gdGhpcy5fcGFyZW50Vmlldy5lbGVtZW50SW5qZWN0b3JzW3RoaXMuX2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZSwgXCJjb21wb25lbnRJbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9lbGVtZW50SW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudEluamVjdG9yLmdldENvbXBvbmVudCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudF8ucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudF8ucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Vmlldy5lbGVtZW50UmVmc1t0aGlzLl9ib3VuZEVsZW1lbnRJbmRleF07IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudEluamVjdG9yLmdldERpcmVjdGl2ZUF0SW5kZXgoZGlyZWN0aXZlSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZEVsZW1lbnRzKHRoaXMuX3BhcmVudFZpZXcsIHRoaXMuX2JvdW5kRWxlbWVudEluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZSwgXCJjb21wb25lbnRWaWV3Q2hpbGRyZW5cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2hhZG93VmlldyA9IHRoaXMuX3BhcmVudFZpZXcuZ2V0TmVzdGVkVmlldyh0aGlzLl9ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgICAgIGlmICghbGFuZ18xLmlzUHJlc2VudChzaGFkb3dWaWV3KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZWxlbWVudCBpcyBub3QgYSBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoaWxkRWxlbWVudHMoc2hhZG93VmlldywgbnVsbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZS50cmlnZ2VyRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRPYmopIHtcclxuICAgICAgICB0aGlzLl9wYXJlbnRWaWV3LnRyaWdnZXJFdmVudEhhbmRsZXJzKGV2ZW50TmFtZSwgZXZlbnRPYmosIHRoaXMuX2JvdW5kRWxlbWVudEluZGV4KTtcclxuICAgIH07XHJcbiAgICBEZWJ1Z0VsZW1lbnRfLnByb3RvdHlwZS5oYXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICghbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9lbGVtZW50SW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRJbmplY3Rvci5oYXNEaXJlY3RpdmUodHlwZSk7XHJcbiAgICB9O1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRJbmplY3Rvci5nZXQodHlwZSk7XHJcbiAgICB9O1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5fcGFyZW50Vmlldy5sb2NhbHMuZ2V0KG5hbWUpOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRGVidWdFbGVtZW50Xy5wcm90b3R5cGUuX2dldENoaWxkRWxlbWVudHMgPSBmdW5jdGlvbiAodmlldywgcGFyZW50Qm91bmRFbGVtZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbHMgPSBbXTtcclxuICAgICAgICB2YXIgcGFyZW50RWxlbWVudEJpbmRlciA9IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50Qm91bmRFbGVtZW50SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnRCaW5kZXIgPSB2aWV3LnByb3RvLmVsZW1lbnRCaW5kZXJzW3BhcmVudEJvdW5kRWxlbWVudEluZGV4IC0gdmlldy5lbGVtZW50T2Zmc2V0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3LnByb3RvLmVsZW1lbnRCaW5kZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBiaW5kZXIgPSB2aWV3LnByb3RvLmVsZW1lbnRCaW5kZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYmluZGVyLnBhcmVudCA9PSBwYXJlbnRFbGVtZW50QmluZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBlbHMucHVzaChuZXcgRGVidWdFbGVtZW50Xyh2aWV3LCB2aWV3LmVsZW1lbnRPZmZzZXQgKyBpKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlld3MgPSB2aWV3LnZpZXdDb250YWluZXJzW3ZpZXcuZWxlbWVudE9mZnNldCArIGldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmlld3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld3Mudmlld3MuZm9yRWFjaChmdW5jdGlvbiAobmV4dFZpZXcpIHsgZWxzID0gZWxzLmNvbmNhdChfdGhpcy5fZ2V0Q2hpbGRFbGVtZW50cyhuZXh0VmlldywgbnVsbCkpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWJ1Z0VsZW1lbnRfO1xyXG59KShEZWJ1Z0VsZW1lbnQpO1xyXG5leHBvcnRzLkRlYnVnRWxlbWVudF8gPSBEZWJ1Z0VsZW1lbnRfO1xyXG4vKipcclxuICogUmV0dXJucyBhIERlYnVnRWxlbWVudCBmb3IgYSBFbGVtZW50UmVmLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnRSZWZ9OiBlbGVtZW50UmVmXHJcbiAqIEByZXR1cm4ge0RlYnVnRWxlbWVudH1cclxuICovXHJcbmZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KGVsZW1lbnRSZWYpIHtcclxuICAgIHJldHVybiBuZXcgRGVidWdFbGVtZW50Xyh2aWV3X3JlZl8xLmludGVybmFsVmlldyhlbGVtZW50UmVmLnBhcmVudFZpZXcpLCBlbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4KTtcclxufVxyXG5leHBvcnRzLmluc3BlY3RFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnQ7XHJcbmZ1bmN0aW9uIGFzTmF0aXZlRWxlbWVudHMoYXJyKSB7XHJcbiAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoZGVidWdFbCkgeyByZXR1cm4gZGVidWdFbC5uYXRpdmVFbGVtZW50OyB9KTtcclxufVxyXG5leHBvcnRzLmFzTmF0aXZlRWxlbWVudHMgPSBhc05hdGl2ZUVsZW1lbnRzO1xyXG52YXIgU2NvcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2NvcGUoKSB7XHJcbiAgICB9XHJcbiAgICBTY29wZS5hbGwgPSBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHNjb3BlID0gW107XHJcbiAgICAgICAgc2NvcGUucHVzaChkZWJ1Z0VsZW1lbnQpO1xyXG4gICAgICAgIGRlYnVnRWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gc2NvcGUgPSBzY29wZS5jb25jYXQoU2NvcGUuYWxsKGNoaWxkKSk7IH0pO1xyXG4gICAgICAgIGRlYnVnRWxlbWVudC5jb21wb25lbnRWaWV3Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIHNjb3BlID0gc2NvcGUuY29uY2F0KFNjb3BlLmFsbChjaGlsZCkpOyB9KTtcclxuICAgICAgICByZXR1cm4gc2NvcGU7XHJcbiAgICB9O1xyXG4gICAgU2NvcGUubGlnaHQgPSBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHNjb3BlID0gW107XHJcbiAgICAgICAgZGVidWdFbGVtZW50LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICBzY29wZSA9IHNjb3BlLmNvbmNhdChTY29wZS5saWdodChjaGlsZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzY29wZTtcclxuICAgIH07XHJcbiAgICBTY29wZS52aWV3ID0gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IFtdO1xyXG4gICAgICAgIGRlYnVnRWxlbWVudC5jb21wb25lbnRWaWV3Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgc2NvcGUucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUuY29uY2F0KFNjb3BlLmxpZ2h0KGNoaWxkKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTY29wZTtcclxufSkoKTtcclxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xyXG52YXIgQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnkoKSB7XHJcbiAgICB9XHJcbiAgICBCeS5hbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7IHJldHVybiB0cnVlOyB9OyB9O1xyXG4gICAgQnkuY3NzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoZGVidWdFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpID9cclxuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmVsZW1lbnRNYXRjaGVzKGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50LCBzZWxlY3RvcikgOlxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBCeS5kaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7IHJldHVybiBkZWJ1Z0VsZW1lbnQuaGFzRGlyZWN0aXZlKHR5cGUpOyB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCeTtcclxufSkoKTtcclxuZXhwb3J0cy5CeSA9IEJ5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Z19lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIHZpZXdfbGlzdGVuZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlci92aWV3X2xpc3RlbmVyJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBhcGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9hcGknKTtcclxudmFyIGRlYnVnX2VsZW1lbnRfMSA9IHJlcXVpcmUoJy4vZGVidWdfZWxlbWVudCcpO1xyXG52YXIgTkdfSURfUFJPUEVSVFkgPSAnbmdpZCc7XHJcbnZhciBJTlNQRUNUX0dMT0JBTF9OQU1FID0gJ25nLnByb2JlJztcclxudmFyIE5HX0lEX1NFUEFSQVRPUiA9ICcjJztcclxuLy8gTmVlZCB0byBrZWVwIHRoZSB2aWV3cyBpbiBhIGdsb2JhbCBNYXAgc28gdGhhdCBtdWx0aXBsZSBhbmd1bGFyIGFwcHMgYXJlIHN1cHBvcnRlZFxyXG52YXIgX2FsbElkc0J5VmlldyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbnZhciBfYWxsVmlld3NCeUlkID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxudmFyIF9uZXh0SWQgPSAwO1xyXG5mdW5jdGlvbiBfc2V0RWxlbWVudElkKGVsZW1lbnQsIGluZGljZXMpIHtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0RGF0YShlbGVtZW50LCBOR19JRF9QUk9QRVJUWSwgaW5kaWNlcy5qb2luKE5HX0lEX1NFUEFSQVRPUikpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9nZXRFbGVtZW50SWQoZWxlbWVudCkge1xyXG4gICAgdmFyIGVsSWQgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXREYXRhKGVsZW1lbnQsIE5HX0lEX1BST1BFUlRZKTtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsSWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsSWQuc3BsaXQoTkdfSURfU0VQQVJBVE9SKS5tYXAoZnVuY3Rpb24gKHBhcnRTdHIpIHsgcmV0dXJuIGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50KHBhcnRTdHIsIDEwKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnNwZWN0TmF0aXZlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICB2YXIgZWxJZCA9IF9nZXRFbGVtZW50SWQoZWxlbWVudCk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbElkKSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gX2FsbFZpZXdzQnlJZC5nZXQoZWxJZFswXSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmlldykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWJ1Z19lbGVtZW50XzEuRGVidWdFbGVtZW50Xyh2aWV3LCBlbElkWzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnRzLmluc3BlY3ROYXRpdmVFbGVtZW50ID0gaW5zcGVjdE5hdGl2ZUVsZW1lbnQ7XHJcbnZhciBEZWJ1Z0VsZW1lbnRWaWV3TGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyKF9yZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldEdsb2JhbFZhcihJTlNQRUNUX0dMT0JBTF9OQU1FLCBpbnNwZWN0TmF0aXZlRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBEZWJ1Z0VsZW1lbnRWaWV3TGlzdGVuZXIucHJvdG90eXBlLnZpZXdDcmVhdGVkID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2YXIgdmlld0lkID0gX25leHRJZCsrO1xyXG4gICAgICAgIF9hbGxWaWV3c0J5SWQuc2V0KHZpZXdJZCwgdmlldyk7XHJcbiAgICAgICAgX2FsbElkc0J5Vmlldy5zZXQodmlldywgdmlld0lkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcuZWxlbWVudFJlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gdmlldy5lbGVtZW50UmVmc1tpXTtcclxuICAgICAgICAgICAgX3NldEVsZW1lbnRJZCh0aGlzLl9yZW5kZXJlci5nZXROYXRpdmVFbGVtZW50U3luYyhlbCksIFt2aWV3SWQsIGldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyLnByb3RvdHlwZS52aWV3RGVzdHJveWVkID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2YXIgdmlld0lkID0gX2FsbElkc0J5Vmlldy5nZXQodmlldyk7XHJcbiAgICAgICAgX2FsbElkc0J5Vmlldy5kZWxldGUodmlldyk7XHJcbiAgICAgICAgX2FsbFZpZXdzQnlJZC5kZWxldGUodmlld0lkKTtcclxuICAgIH07XHJcbiAgICBEZWJ1Z0VsZW1lbnRWaWV3TGlzdGVuZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbYXBpXzEuUmVuZGVyZXJdKVxyXG4gICAgXSwgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyKTtcclxuICAgIHJldHVybiBEZWJ1Z0VsZW1lbnRWaWV3TGlzdGVuZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyID0gRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyO1xyXG5leHBvcnRzLkVMRU1FTlRfUFJPQkVfUFJPVklERVJTID0gbGFuZ18xLkNPTlNUX0VYUFIoW1xyXG4gICAgRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyLFxyXG4gICAgbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIodmlld19saXN0ZW5lcl8xLkFwcFZpZXdMaXN0ZW5lciwgeyB1c2VFeGlzdGluZzogRGVidWdFbGVtZW50Vmlld0xpc3RlbmVyIH0pKSxcclxuXSk7XHJcbmV4cG9ydHMuRUxFTUVOVF9QUk9CRV9CSU5ESU5HUyA9IGV4cG9ydHMuRUxFTUVOVF9QUk9CRV9QUk9WSURFUlM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnX2VsZW1lbnRfdmlld19saXN0ZW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgZGlgIG1vZHVsZSBwcm92aWRlcyBkZXBlbmRlbmN5IGluamVjdGlvbiBjb250YWluZXIgc2VydmljZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCcuL2RpL21ldGFkYXRhJyk7XHJcbmV4cG9ydHMuSW5qZWN0TWV0YWRhdGEgPSBtZXRhZGF0YV8xLkluamVjdE1ldGFkYXRhO1xyXG5leHBvcnRzLk9wdGlvbmFsTWV0YWRhdGEgPSBtZXRhZGF0YV8xLk9wdGlvbmFsTWV0YWRhdGE7XHJcbmV4cG9ydHMuSW5qZWN0YWJsZU1ldGFkYXRhID0gbWV0YWRhdGFfMS5JbmplY3RhYmxlTWV0YWRhdGE7XHJcbmV4cG9ydHMuU2VsZk1ldGFkYXRhID0gbWV0YWRhdGFfMS5TZWxmTWV0YWRhdGE7XHJcbmV4cG9ydHMuSG9zdE1ldGFkYXRhID0gbWV0YWRhdGFfMS5Ib3N0TWV0YWRhdGE7XHJcbmV4cG9ydHMuU2tpcFNlbGZNZXRhZGF0YSA9IG1ldGFkYXRhXzEuU2tpcFNlbGZNZXRhZGF0YTtcclxuZXhwb3J0cy5EZXBlbmRlbmN5TWV0YWRhdGEgPSBtZXRhZGF0YV8xLkRlcGVuZGVuY3lNZXRhZGF0YTtcclxuLy8gd2UgaGF2ZSB0byByZWV4cG9ydCAqIGJlY2F1c2UgRGFydCBhbmQgVFMgZXhwb3J0IHR3byBkaWZmZXJlbnQgc2V0cyBvZiB0eXBlc1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RpL2RlY29yYXRvcnMnKSk7XHJcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi9kaS9mb3J3YXJkX3JlZicpO1xyXG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkX3JlZl8xLmZvcndhcmRSZWY7XHJcbmV4cG9ydHMucmVzb2x2ZUZvcndhcmRSZWYgPSBmb3J3YXJkX3JlZl8xLnJlc29sdmVGb3J3YXJkUmVmO1xyXG52YXIgaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4vZGkvaW5qZWN0b3InKTtcclxuZXhwb3J0cy5JbmplY3RvciA9IGluamVjdG9yXzEuSW5qZWN0b3I7XHJcbnZhciBwcm92aWRlcl8xID0gcmVxdWlyZSgnLi9kaS9wcm92aWRlcicpO1xyXG5leHBvcnRzLkJpbmRpbmcgPSBwcm92aWRlcl8xLkJpbmRpbmc7XHJcbmV4cG9ydHMuUHJvdmlkZXJCdWlsZGVyID0gcHJvdmlkZXJfMS5Qcm92aWRlckJ1aWxkZXI7XHJcbmV4cG9ydHMuUmVzb2x2ZWRGYWN0b3J5ID0gcHJvdmlkZXJfMS5SZXNvbHZlZEZhY3Rvcnk7XHJcbmV4cG9ydHMuRGVwZW5kZW5jeSA9IHByb3ZpZGVyXzEuRGVwZW5kZW5jeTtcclxuZXhwb3J0cy5iaW5kID0gcHJvdmlkZXJfMS5iaW5kO1xyXG5leHBvcnRzLlByb3ZpZGVyID0gcHJvdmlkZXJfMS5Qcm92aWRlcjtcclxuZXhwb3J0cy5wcm92aWRlID0gcHJvdmlkZXJfMS5wcm92aWRlO1xyXG52YXIga2V5XzEgPSByZXF1aXJlKCcuL2RpL2tleScpO1xyXG5leHBvcnRzLktleSA9IGtleV8xLktleTtcclxuZXhwb3J0cy5UeXBlTGl0ZXJhbCA9IGtleV8xLlR5cGVMaXRlcmFsO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi9kaS9leGNlcHRpb25zJyk7XHJcbmV4cG9ydHMuTm9Qcm92aWRlckVycm9yID0gZXhjZXB0aW9uc18xLk5vUHJvdmlkZXJFcnJvcjtcclxuZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSBleGNlcHRpb25zXzEuQWJzdHJhY3RQcm92aWRlckVycm9yO1xyXG5leHBvcnRzLkN5Y2xpY0RlcGVuZGVuY3lFcnJvciA9IGV4Y2VwdGlvbnNfMS5DeWNsaWNEZXBlbmRlbmN5RXJyb3I7XHJcbmV4cG9ydHMuSW5zdGFudGlhdGlvbkVycm9yID0gZXhjZXB0aW9uc18xLkluc3RhbnRpYXRpb25FcnJvcjtcclxuZXhwb3J0cy5JbnZhbGlkUHJvdmlkZXJFcnJvciA9IGV4Y2VwdGlvbnNfMS5JbnZhbGlkUHJvdmlkZXJFcnJvcjtcclxuZXhwb3J0cy5Ob0Fubm90YXRpb25FcnJvciA9IGV4Y2VwdGlvbnNfMS5Ob0Fubm90YXRpb25FcnJvcjtcclxuZXhwb3J0cy5PdXRPZkJvdW5kc0Vycm9yID0gZXhjZXB0aW9uc18xLk91dE9mQm91bmRzRXJyb3I7XHJcbnZhciBvcGFxdWVfdG9rZW5fMSA9IHJlcXVpcmUoJy4vZGkvb3BhcXVlX3Rva2VuJyk7XHJcbmV4cG9ydHMuT3BhcXVlVG9rZW4gPSBvcGFxdWVfdG9rZW5fMS5PcGFxdWVUb2tlbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YScpO1xyXG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi4vdXRpbC9kZWNvcmF0b3JzJyk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgSW5qZWN0TWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5JbmplY3QgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuSW5qZWN0TWV0YWRhdGEpO1xyXG4vKipcclxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIE9wdGlvbmFsTWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5PcHRpb25hbCA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IobWV0YWRhdGFfMS5PcHRpb25hbE1ldGFkYXRhKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBJbmplY3RhYmxlTWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5JbmplY3RhYmxlID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3IobWV0YWRhdGFfMS5JbmplY3RhYmxlTWV0YWRhdGEpO1xyXG4vKipcclxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIFNlbGZNZXRhZGF0YX0uXHJcbiAqL1xyXG5leHBvcnRzLlNlbGYgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuU2VsZk1ldGFkYXRhKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBIb3N0TWV0YWRhdGF9LlxyXG4gKi9cclxuZXhwb3J0cy5Ib3N0ID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihtZXRhZGF0YV8xLkhvc3RNZXRhZGF0YSk7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgU2tpcFNlbGZNZXRhZGF0YX0uXHJcbiAqL1xyXG5leHBvcnRzLlNraXBTZWxmID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihtZXRhZGF0YV8xLlNraXBTZWxmTWV0YWRhdGEpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvcmF0b3JzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG5mdW5jdGlvbiBmaW5kRmlyc3RDbG9zZWRDeWNsZShrZXlzKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKHJlcywga2V5c1tpXSkpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2goa2V5c1tpXSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgoa2V5cykge1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhciByZXZlcnNlZCA9IGZpbmRGaXJzdENsb3NlZEN5Y2xlKGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZXZlcnNlZChrZXlzKSk7XHJcbiAgICAgICAgdmFyIHRva2VuU3RycyA9IHJldmVyc2VkLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbGFuZ18xLnN0cmluZ2lmeShrLnRva2VuKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIFwiIChcIiArIHRva2VuU3Rycy5qb2luKCcgLT4gJykgKyBcIilcIjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgZXJyb3JzIGFyaXNpbmcgZnJvbSBtaXNjb25maWd1cmVkIHByb3ZpZGVycy5cclxuICovXHJcbnZhciBBYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFic3RyYWN0UHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0UHJvdmlkZXJFcnJvcihpbmplY3Rvciwga2V5LCBjb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJESSBFeGNlcHRpb25cIik7XHJcbiAgICAgICAgdGhpcy5rZXlzID0gW2tleV07XHJcbiAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlKHRoaXMua2V5cyk7XHJcbiAgICB9XHJcbiAgICBBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvcnMucHVzaChpbmplY3Rvcik7XHJcbiAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RQcm92aWRlckVycm9yLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3JzW3RoaXMuaW5qZWN0b3JzLmxlbmd0aCAtIDFdLmRlYnVnQ29udGV4dCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBBYnN0cmFjdFByb3ZpZGVyRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSBBYnN0cmFjdFByb3ZpZGVyRXJyb3I7XHJcbi8qKlxyXG4gKiBUaHJvd24gd2hlbiB0cnlpbmcgdG8gcmV0cmlldmUgYSBkZXBlbmRlbmN5IGJ5IGBLZXlgIGZyb20ge0BsaW5rIEluamVjdG9yfSwgYnV0IHRoZVxyXG4gKiB7QGxpbmsgSW5qZWN0b3J9IGRvZXMgbm90IGhhdmUgYSB7QGxpbmsgUHJvdmlkZXJ9IGZvciB7QGxpbmsgS2V5fS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3ZxOEQzRlJCOWFHYm5XSnF0RVBFP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgQSB7XHJcbiAqICAgY29uc3RydWN0b3IoYjpCKSB7fVxyXG4gKiB9XHJcbiAqXHJcbiAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBOb1Byb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5vUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE5vUHJvdmlkZXJFcnJvcihpbmplY3Rvciwga2V5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gbGFuZ18xLnN0cmluZ2lmeShjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3Qoa2V5cykudG9rZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJObyBwcm92aWRlciBmb3IgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBOb1Byb3ZpZGVyRXJyb3I7XHJcbn0pKEFic3RyYWN0UHJvdmlkZXJFcnJvcik7XHJcbmV4cG9ydHMuTm9Qcm92aWRlckVycm9yID0gTm9Qcm92aWRlckVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gZGVwZW5kZW5jaWVzIGZvcm0gYSBjeWNsZS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3dZUWROb3MwVHpxbDNlaTFFVjlqP3A9aW5mbykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAqICAgcHJvdmlkZShcIm9uZVwiLCB7dXNlRmFjdG9yeTogKHR3bykgPT4gXCJ0d29cIiwgZGVwczogW1tuZXcgSW5qZWN0KFwidHdvXCIpXV19KSxcclxuICogICBwcm92aWRlKFwidHdvXCIsIHt1c2VGYWN0b3J5OiAob25lKSA9PiBcIm9uZVwiLCBkZXBzOiBbW25ldyBJbmplY3QoXCJvbmVcIildXX0pXHJcbiAqIF0pO1xyXG4gKlxyXG4gKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KFwib25lXCIpKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFJldHJpZXZpbmcgYEFgIG9yIGBCYCB0aHJvd3MgYSBgQ3ljbGljRGVwZW5kZW5jeUVycm9yYCBhcyB0aGUgZ3JhcGggYWJvdmUgY2Fubm90IGJlIGNvbnN0cnVjdGVkLlxyXG4gKi9cclxudmFyIEN5Y2xpY0RlcGVuZGVuY3lFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3ljbGljRGVwZW5kZW5jeUVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ3ljbGljRGVwZW5kZW5jeUVycm9yKGluamVjdG9yLCBrZXkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpbmplY3Rvciwga2V5LCBmdW5jdGlvbiAoa2V5cykge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEN5Y2xpY0RlcGVuZGVuY3lFcnJvcjtcclxufSkoQWJzdHJhY3RQcm92aWRlckVycm9yKTtcclxuZXhwb3J0cy5DeWNsaWNEZXBlbmRlbmN5RXJyb3IgPSBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XHJcbi8qKlxyXG4gKiBUaHJvd24gd2hlbiBhIGNvbnN0cnVjdGluZyB0eXBlIHJldHVybnMgd2l0aCBhbiBFcnJvci5cclxuICpcclxuICogVGhlIGBJbnN0YW50aWF0aW9uRXJyb3JgIGNsYXNzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBlcnJvciBwbHVzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHdoaWNoIGNhdXNlZFxyXG4gKiB0aGlzIG9iamVjdCB0byBiZSBpbnN0YW50aWF0ZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC83YVdZZGNxVFFzUDBlTnFFZFVBZj9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEEge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlJyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcclxuXHJcbiAqIHRyeSB7XHJcbiAqICAgaW5qZWN0b3IuZ2V0KEEpO1xyXG4gKiB9IGNhdGNoIChlKSB7XHJcbiAqICAgZXhwZWN0KGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpLnRvQmUodHJ1ZSk7XHJcbiAqICAgZXhwZWN0KGUub3JpZ2luYWxFeGNlcHRpb24ubWVzc2FnZSkudG9FcXVhbChcIm1lc3NhZ2VcIik7XHJcbiAqICAgZXhwZWN0KGUub3JpZ2luYWxTdGFjaykudG9CZURlZmluZWQoKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBJbnN0YW50aWF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEluc3RhbnRpYXRpb25FcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRpb25FcnJvcihpbmplY3Rvciwgb3JpZ2luYWxFeGNlcHRpb24sIG9yaWdpbmFsU3RhY2ssIGtleSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiREkgRXhjZXB0aW9uXCIsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBudWxsKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcclxuICAgICAgICB0aGlzLmluamVjdG9ycyA9IFtpbmplY3Rvcl07XHJcbiAgICB9XHJcbiAgICBJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvcnMucHVzaChpbmplY3Rvcik7XHJcbiAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJ3cmFwcGVyTWVzc2FnZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IGxhbmdfMS5zdHJpbmdpZnkoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KHRoaXMua2V5cykudG9rZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJFcnJvciBkdXJpbmcgaW5zdGFudGlhdGlvbiBvZiBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKHRoaXMua2V5cykgKyBcIi5cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLCBcImNhdXNlS2V5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5c1swXTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3JzW3RoaXMuaW5qZWN0b3JzLmxlbmd0aCAtIDFdLmRlYnVnQ29udGV4dCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBJbnN0YW50aWF0aW9uRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5JbnN0YW50aWF0aW9uRXJyb3IgPSBJbnN0YW50aWF0aW9uRXJyb3I7XHJcbi8qKlxyXG4gKiBUaHJvd24gd2hlbiBhbiBvYmplY3Qgb3RoZXIgdGhlbiB7QGxpbmsgUHJvdmlkZXJ9IChvciBgVHlwZWApIGlzIHBhc3NlZCB0byB7QGxpbmsgSW5qZWN0b3J9XHJcbiAqIGNyZWF0aW9uLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWWF0Q0ZiUEFNQ0wwSlNTUTRtdkg/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXCJub3QgYSB0eXBlXCJdKSkudG9UaHJvd0Vycm9yKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEludmFsaWRQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbnZhbGlkUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludmFsaWRQcm92aWRlckVycm9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIHByb3ZpZGVyIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogXCIgK1xyXG4gICAgICAgICAgICBwcm92aWRlci50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBJbnZhbGlkUHJvdmlkZXJFcnJvcjtcclxufSkoZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pO1xyXG5leHBvcnRzLkludmFsaWRQcm92aWRlckVycm9yID0gSW52YWxpZFByb3ZpZGVyRXJyb3I7XHJcbi8qKlxyXG4gKiBUaHJvd24gd2hlbiB0aGUgY2xhc3MgaGFzIG5vIGFubm90YXRpb24gaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIExhY2sgb2YgYW5ub3RhdGlvbiBpbmZvcm1hdGlvbiBwcmV2ZW50cyB0aGUge0BsaW5rIEluamVjdG9yfSBmcm9tIGRldGVybWluaW5nIHdoaWNoIGRlcGVuZGVuY2llc1xyXG4gKiBuZWVkIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvckhuWnRsTlM3dkpPUFE2cGNWa20/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBBIHtcclxuICogICBjb25zdHJ1Y3RvcihiKSB7fVxyXG4gKiB9XHJcbiAqXHJcbiAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBlcnJvciBpcyBhbHNvIHRocm93biB3aGVuIHRoZSBjbGFzcyBub3QgbWFya2VkIHdpdGgge0BsaW5rIEluamVjdGFibGV9IGhhcyBwYXJhbWV0ZXIgdHlwZXMuXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgQiB7fVxyXG4gKlxyXG4gKiBjbGFzcyBBIHtcclxuICogICBjb25zdHJ1Y3RvcihiOkIpIHt9IC8vIG5vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXJhbWV0ZXIgdHlwZXMgb2YgQSBpcyBhdmFpbGFibGUgYXQgcnVudGltZS5cclxuICogfVxyXG4gKlxyXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQSxCXSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBOb0Fubm90YXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTm9Bbm5vdGF0aW9uRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSh0eXBlT3JGdW5jLCBwYXJhbXMpKTtcclxuICAgIH1cclxuICAgIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIHBhcmFtcykge1xyXG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFyYW1ldGVyKSB8fCBwYXJhbWV0ZXIubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5wdXNoKCc/Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaChwYXJhbWV0ZXIubWFwKGxhbmdfMS5zdHJpbmdpZnkpLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFwiICsgbGFuZ18xLnN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiKFwiICtcclxuICAgICAgICAgICAgc2lnbmF0dXJlLmpvaW4oJywgJykgKyBcIikuIFwiICsgJ01ha2Ugc3VyZSB0aGV5IGFsbCBoYXZlIHZhbGlkIHR5cGUgb3IgYW5ub3RhdGlvbnMuJztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9Bbm5vdGF0aW9uRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5Ob0Fubm90YXRpb25FcnJvciA9IE5vQW5ub3RhdGlvbkVycm9yO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gZ2V0dGluZyBhbiBvYmplY3QgYnkgaW5kZXguXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9iUnMwU1gyT1RRaUp6cXZqZ2w4UD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEEge31cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pO1xyXG4gKlxyXG4gKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0QXQoMTAwKSkudG9UaHJvd0Vycm9yKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE91dE9mQm91bmRzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE91dE9mQm91bmRzRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBPdXRPZkJvdW5kc0Vycm9yKGluZGV4KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0LW9mLWJvdW5kcy5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT3V0T2ZCb3VuZHNFcnJvcjtcclxufSkoZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pO1xyXG5leHBvcnRzLk91dE9mQm91bmRzRXJyb3IgPSBPdXRPZkJvdW5kc0Vycm9yO1xyXG4vLyBUT0RPOiBhZGQgYSB3b3JraW5nIGV4YW1wbGUgYWZ0ZXIgYWxwaGEzOCBpcyByZWxlYXNlZFxyXG4vKipcclxuICogVGhyb3duIHdoZW4gYSBtdWx0aSBwcm92aWRlciBhbmQgYSByZWd1bGFyIHByb3ZpZGVyIGFyZSBib3VuZCB0byB0aGUgc2FtZSB0b2tlbi5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7dXNlVmFsdWU6IFwic3RyaW5nMVwiLCBtdWx0aTogdHJ1ZX0pLFxyXG4gKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwge3VzZVZhbHVlOiBcInN0cmluZzJcIiwgbXVsdGk6IGZhbHNlfSlcclxuICogXSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihwcm92aWRlcjEsIHByb3ZpZGVyMikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2Fubm90IG1peCBtdWx0aSBwcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzLCBnb3Q6IFwiICsgcHJvdmlkZXIxLnRvU3RyaW5nKCkgKyBcIiBcIiArXHJcbiAgICAgICAgICAgIHByb3ZpZGVyMi50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3I7XHJcbn0pKGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKTtcclxuZXhwb3J0cy5NaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IgPSBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogQWxsb3dzIHRvIHJlZmVyIHRvIHJlZmVyZW5jZXMgd2hpY2ggYXJlIG5vdCB5ZXQgZGVmaW5lZC5cclxuICpcclxuICogRm9yIGluc3RhbmNlLCBgZm9yd2FyZFJlZmAgaXMgdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIG5lZWQgdG8gcmVmZXIgdG8gZm9yIHRoZSBwdXJwb3NlcyBvZlxyXG4gKiBESSBpcyBkZWNsYXJlZCxcclxuICogYnV0IG5vdCB5ZXQgZGVmaW5lZC4gSXQgaXMgYWxzbyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgdXNlIHdoZW4gY3JlYXRpbmcgYSBxdWVyeSBpcyBub3RcclxuICogeWV0IGRlZmluZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9iUnMwU1gyT1RRaUp6cXZqZ2w4UD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIERvb3Ige1xyXG4gKiAgIGxvY2s6IExvY2s7XHJcbiAqICAgY29uc3RydWN0b3IoQEluamVjdChmb3J3YXJkUmVmKCgpID0+IExvY2spKSBsb2NrOkxvY2spIHtcclxuICogICAgIHRoaXMubG9jayA9IGxvY2s7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIE9ubHkgYXQgdGhpcyBwb2ludCBMb2NrIGlzIGRlZmluZWQuXHJcbiAqIGNsYXNzIExvY2sge1xyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0Rvb3IsIExvY2tdKTtcclxuICogdmFyIGRvb3IgPSBpbmplY3Rvci5nZXQoRG9vcik7XHJcbiAqIGV4cGVjdChkb29yIGluc3RhbmNlb2YgRG9vcikudG9CZSh0cnVlKTtcclxuICogZXhwZWN0KGRvb3IubG9jayBpbnN0YW5jZW9mIExvY2spLnRvQmUodHJ1ZSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gZm9yd2FyZFJlZihmb3J3YXJkUmVmRm4pIHtcclxuICAgIGZvcndhcmRSZWZGbi5fX2ZvcndhcmRfcmVmX18gPSBmb3J3YXJkUmVmO1xyXG4gICAgZm9yd2FyZFJlZkZuLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLnN0cmluZ2lmeSh0aGlzKCkpOyB9O1xyXG4gICAgcmV0dXJuIGZvcndhcmRSZWZGbjtcclxufVxyXG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xyXG4vKipcclxuICogTGF6aWx5IHJldHJpZXZlcyB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYSBmb3J3YXJkUmVmLlxyXG4gKlxyXG4gKiBBY3RzIGFzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiB3aGVuIGdpdmVuIGEgbm9uLWZvcndhcmQtcmVmIHZhbHVlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvR1U3Mm1KcmsxZmlvZENoY21pRFI/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiB2YXIgcmVmID0gZm9yd2FyZFJlZigoKSA9PiBcInJlZlZhbHVlXCIpO1xyXG4gKiBleHBlY3QocmVzb2x2ZUZvcndhcmRSZWYocmVmKSkudG9FcXVhbChcInJlZlZhbHVlXCIpO1xyXG4gKiBleHBlY3QocmVzb2x2ZUZvcndhcmRSZWYoXCJyZWd1bGFyVmFsdWVcIikpLnRvRXF1YWwoXCJyZWd1bGFyVmFsdWVcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTZWU6IHtAbGluayBmb3J3YXJkUmVmfVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUuaGFzT3duUHJvcGVydHkoJ19fZm9yd2FyZF9yZWZfXycpICYmXHJcbiAgICAgICAgdHlwZS5fX2ZvcndhcmRfcmVmX18gPT09IGZvcndhcmRSZWYpIHtcclxuICAgICAgICByZXR1cm4gdHlwZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZlRm9yd2FyZFJlZiA9IHJlc29sdmVGb3J3YXJkUmVmO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3J3YXJkX3JlZi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBwcm92aWRlcl8xID0gcmVxdWlyZSgnLi9wcm92aWRlcicpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi9leGNlcHRpb25zJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIga2V5XzEgPSByZXF1aXJlKCcuL2tleScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEnKTtcclxuLy8gVGhyZXNob2xkIGZvciB0aGUgZHluYW1pYyB2ZXJzaW9uXHJcbnZhciBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID0gMTA7XHJcbmV4cG9ydHMuVU5ERUZJTkVEID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IE9iamVjdCgpKTtcclxuLyoqXHJcbiAqIFZpc2liaWxpdHkgb2YgYSB7QGxpbmsgUHJvdmlkZXJ9LlxyXG4gKi9cclxuKGZ1bmN0aW9uIChWaXNpYmlsaXR5KSB7XHJcbiAgICAvKipcclxuICAgICAqIEEgYFB1YmxpY2Age0BsaW5rIFByb3ZpZGVyfSBpcyBvbmx5IHZpc2libGUgdG8gcmVndWxhciAoYXMgb3Bwb3NlZCB0byBob3N0KSBjaGlsZCBpbmplY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIFZpc2liaWxpdHlbVmlzaWJpbGl0eVtcIlB1YmxpY1wiXSA9IDBdID0gXCJQdWJsaWNcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBgUHJpdmF0ZWAge0BsaW5rIFByb3ZpZGVyfSBpcyBvbmx5IHZpc2libGUgdG8gaG9zdCAoYXMgb3Bwb3NlZCB0byByZWd1bGFyKSBjaGlsZCBpbmplY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIFZpc2liaWxpdHlbVmlzaWJpbGl0eVtcIlByaXZhdGVcIl0gPSAxXSA9IFwiUHJpdmF0ZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBQdWJsaWNBbmRQcml2YXRlYCB7QGxpbmsgUHJvdmlkZXJ9IGlzIHZpc2libGUgdG8gYm90aCBob3N0IGFuZCByZWd1bGFyIGNoaWxkIGluamVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgVmlzaWJpbGl0eVtWaXNpYmlsaXR5W1wiUHVibGljQW5kUHJpdmF0ZVwiXSA9IDJdID0gXCJQdWJsaWNBbmRQcml2YXRlXCI7XHJcbn0pKGV4cG9ydHMuVmlzaWJpbGl0eSB8fCAoZXhwb3J0cy5WaXNpYmlsaXR5ID0ge30pKTtcclxudmFyIFZpc2liaWxpdHkgPSBleHBvcnRzLlZpc2liaWxpdHk7XHJcbmZ1bmN0aW9uIGNhblNlZShzcmMsIGRzdCkge1xyXG4gICAgcmV0dXJuIChzcmMgPT09IGRzdCkgfHxcclxuICAgICAgICAoZHN0ID09PSBWaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUgfHwgc3JjID09PSBWaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUpO1xyXG59XHJcbnZhciBQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5KHByb3RvRUksIGJ3dikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIwID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXI2ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcjggPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXI5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkMCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkMyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQ1ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkNiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXlJZDcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5SWQ4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleUlkOSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5MCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5MSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5MiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5MyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5NCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5NSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5NiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5NyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5OCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5OSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ3di5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBid3ZbMF0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQwID0gYnd2WzBdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTAgPSBid3ZbMF0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjEgPSBid3ZbMV0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQxID0gYnd2WzFdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTEgPSBid3ZbMV0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjIgPSBid3ZbMl0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQyID0gYnd2WzJdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTIgPSBid3ZbMl0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBid3ZbM10ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQzID0gYnd2WzNdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTMgPSBid3ZbM10udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjQgPSBid3ZbNF0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ0ID0gYnd2WzRdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTQgPSBid3ZbNF0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDUpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjUgPSBid3ZbNV0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gYnd2WzVdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTUgPSBid3ZbNV0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDYpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBid3ZbNl0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ2ID0gYnd2WzZdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTYgPSBid3ZbNl0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjcgPSBid3ZbN10ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ3ID0gYnd2WzddLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTcgPSBid3ZbN10udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDgpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjggPSBid3ZbOF0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gYnd2WzhdLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTggPSBid3ZbOF0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDkpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBid3ZbOV0ucHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMua2V5SWQ5ID0gYnd2WzldLmdldEtleUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eTkgPSBid3ZbOV0udmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjA7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyMTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIyO1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAzKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjM7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyNDtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA2KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjY7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDcpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyNztcclxuICAgICAgICBpZiAoaW5kZXggPT0gOClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI4O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA5KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjk7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5PdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcclxuICAgIH07XHJcbiAgICBQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kgPSBmdW5jdGlvbiAoaW5qZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5O1xyXG52YXIgUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHByb3RvSW5qLCBid3YpIHtcclxuICAgICAgICB2YXIgbGVuID0gYnd2Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICB0aGlzLmtleUlkcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdGllcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobGVuKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzW2ldID0gYnd2W2ldLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLmtleUlkc1tpXSA9IGJ3dltpXS5nZXRLZXlJZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdGllc1tpXSA9IGJ3dltpXS52aXNpYmlsaXR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5wcm92aWRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyc1tpbmRleF07XHJcbiAgICB9O1xyXG4gICAgUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChlaSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgZWkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSBQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xyXG52YXIgUHJvdG9JbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b0luamVjdG9yKGJ3dikge1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZQcm92aWRlcnMgPSBid3YubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gYnd2Lmxlbmd0aCA+IF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVIgP1xyXG4gICAgICAgICAgICBuZXcgUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneSh0aGlzLCBid3YpIDpcclxuICAgICAgICAgICAgbmV3IFByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSh0aGlzLCBid3YpO1xyXG4gICAgfVxyXG4gICAgUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRQcm92aWRlckF0SW5kZXgoaW5kZXgpOyB9O1xyXG4gICAgcmV0dXJuIFByb3RvSW5qZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9JbmplY3RvciA9IFByb3RvSW5qZWN0b3I7XHJcbnZhciBJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHByb3RvU3RyYXRlZ3kpIHtcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcclxuICAgICAgICB0aGlzLm9iajAgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajEgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajIgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajMgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajQgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajUgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajYgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajcgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajggPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgICAgICB0aGlzLm9iajkgPSBleHBvcnRzLlVOREVGSU5FRDtcclxuICAgIH1cclxuICAgIEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XHJcbiAgICBJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCB2aXNpYmlsaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuX25ldyhwcm92aWRlciwgdmlzaWJpbGl0eSk7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhcmVudCwgaXNIb3N0KSB7XHJcbiAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3I7XHJcbiAgICAgICAgaW5qLl9wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgaW5qLl9pc0hvc3QgPSBpc0hvc3Q7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQnlLZXlJZCA9IGZ1bmN0aW9uIChrZXlJZCwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBpbmogPSB0aGlzLmluamVjdG9yO1xyXG4gICAgICAgIGlmIChwLmtleUlkMCA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTAsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajAgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajAgPSBpbmouX25ldyhwLnByb3ZpZGVyMCwgcC52aXNpYmlsaXR5MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQxID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5MSwgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqMSA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqMSA9IGluai5fbmV3KHAucHJvdmlkZXIxLCBwLnZpc2liaWxpdHkxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDIgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHkyLCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmoyID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmoyID0gaW5qLl9uZXcocC5wcm92aWRlcjIsIHAudmlzaWJpbGl0eTIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkMyA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTMsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajMgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajMgPSBpbmouX25ldyhwLnByb3ZpZGVyMywgcC52aXNpYmlsaXR5Myk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQ0ID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5NCwgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqNCA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqNCA9IGluai5fbmV3KHAucHJvdmlkZXI0LCBwLnZpc2liaWxpdHk0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDUgPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHk1LCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmo1ID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmo1ID0gaW5qLl9uZXcocC5wcm92aWRlcjUsIHAudmlzaWJpbGl0eTUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkNiA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTYsIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajYgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajYgPSBpbmouX25ldyhwLnByb3ZpZGVyNiwgcC52aXNpYmlsaXR5Nik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAua2V5SWQ3ID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXR5NywgdmlzaWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JqNyA9PT0gZXhwb3J0cy5VTkRFRklORUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqNyA9IGluai5fbmV3KHAucHJvdmlkZXI3LCBwLnZpc2liaWxpdHk3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5rZXlJZDggPT09IGtleUlkICYmIGNhblNlZShwLnZpc2liaWxpdHk4LCB2aXNpYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYmo4ID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmo4ID0gaW5qLl9uZXcocC5wcm92aWRlcjgsIHAudmlzaWJpbGl0eTgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmtleUlkOSA9PT0ga2V5SWQgJiYgY2FuU2VlKHAudmlzaWJpbGl0eTksIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajkgPT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iajkgPSBpbmouX25ldyhwLnByb3ZpZGVyOSwgcC52aXNpYmlsaXR5OSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqOTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVU5ERUZJTkVEO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMDtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMjtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMylcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMztcclxuICAgICAgICBpZiAoaW5kZXggPT0gNClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNjtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNylcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcclxuICAgICAgICBpZiAoaW5kZXggPT0gOClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqODtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqOTtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLk91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVI7IH07XHJcbiAgICByZXR1cm4gSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcclxufSkoKTtcclxuZXhwb3J0cy5JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcclxudmFyIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5KHByb3RvU3RyYXRlZ3ksIGluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5vYmpzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShwcm90b1N0cmF0ZWd5LnByb3ZpZGVycy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKHRoaXMub2JqcywgZXhwb3J0cy5VTkRFRklORUQpO1xyXG4gICAgfVxyXG4gICAgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XHJcbiAgICBJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuaW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIsIHZpc2liaWxpdHkpO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocGFyZW50LCBpc0hvc3QpIHtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcy5pbmplY3RvcjtcclxuICAgICAgICBpbmouX3BhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBpbmouX2lzSG9zdCA9IGlzSG9zdDtcclxuICAgIH07XHJcbiAgICBJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQnlLZXlJZCA9IGZ1bmN0aW9uIChrZXlJZCwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5rZXlJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHAua2V5SWRzW2ldID09PSBrZXlJZCAmJiBjYW5TZWUocC52aXNpYmlsaXRpZXNbaV0sIHZpc2liaWxpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSBleHBvcnRzLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Jqc1tpXSA9IHRoaXMuaW5qZWN0b3IuX25ldyhwLnByb3ZpZGVyc1tpXSwgcC52aXNpYmlsaXRpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Jqc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMub2Jqcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5PdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Jqc1tpbmRleF07XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub2Jqcy5sZW5ndGg7IH07XHJcbiAgICByZXR1cm4gSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSBJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcclxudmFyIFByb3ZpZGVyV2l0aFZpc2liaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShwcm92aWRlciwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgUHJvdmlkZXJXaXRoVmlzaWJpbGl0eS5wcm90b3R5cGUuZ2V0S2V5SWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnByb3ZpZGVyLmtleS5pZDsgfTtcclxuICAgIHJldHVybiBQcm92aWRlcldpdGhWaXNpYmlsaXR5O1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3ZpZGVyV2l0aFZpc2liaWxpdHkgPSBQcm92aWRlcldpdGhWaXNpYmlsaXR5O1xyXG4vKipcclxuICogQSBkZXBlbmRlbmN5IGluamVjdGlvbiBjb250YWluZXIgdXNlZCBmb3IgaW5zdGFudGlhdGluZyBvYmplY3RzIGFuZCByZXNvbHZpbmcgZGVwZW5kZW5jaWVzLlxyXG4gKlxyXG4gKiBBbiBgSW5qZWN0b3JgIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGEgYG5ld2Agb3BlcmF0b3IsIHdoaWNoIGNhbiBhdXRvbWF0aWNhbGx5IHJlc29sdmUgdGhlXHJcbiAqIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcy5cclxuICpcclxuICogSW4gdHlwaWNhbCB1c2UsIGFwcGxpY2F0aW9uIGNvZGUgYXNrcyBmb3IgdGhlIGRlcGVuZGVuY2llcyBpbiB0aGUgY29uc3RydWN0b3IgYW5kIHRoZXkgYXJlXHJcbiAqIHJlc29sdmVkIGJ5IHRoZSBgSW5qZWN0b3JgLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvanpqZWMwP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGFuIGBJbmplY3RvcmAgY29uZmlndXJlZCB0byBjcmVhdGUgYEVuZ2luZWAgYW5kIGBDYXJgLlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgRW5naW5lIHtcclxuICogfVxyXG4gKlxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIENhciB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XHJcbiAqIH1cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcclxuICogdmFyIGNhciA9IGluamVjdG9yLmdldChDYXIpO1xyXG4gKiBleHBlY3QoY2FyIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xyXG4gKiBleHBlY3QoY2FyLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGljZSwgd2UgZG9uJ3QgdXNlIHRoZSBgbmV3YCBvcGVyYXRvciBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgd2FudCB0byBoYXZlIHRoZSBgSW5qZWN0b3JgXHJcbiAqIHJlc29sdmUgYWxsIG9mIHRoZSBvYmplY3QncyBkZXBlbmRlbmNpZXMgYXV0b21hdGljYWxseS5cclxuICovXHJcbnZhciBJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSW5qZWN0b3IoX3Byb3RvIC8qIFByb3RvSW5qZWN0b3IgKi8sIF9wYXJlbnQsIF9kZXBQcm92aWRlciwgX2RlYnVnQ29udGV4dCkge1xyXG4gICAgICAgIGlmIChfcGFyZW50ID09PSB2b2lkIDApIHsgX3BhcmVudCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoX2RlcFByb3ZpZGVyID09PSB2b2lkIDApIHsgX2RlcFByb3ZpZGVyID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChfZGVidWdDb250ZXh0ID09PSB2b2lkIDApIHsgX2RlYnVnQ29udGV4dCA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLl9kZXBQcm92aWRlciA9IF9kZXBQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9kZWJ1Z0NvbnRleHQgPSBfZGVidWdDb250ZXh0O1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9pc0hvc3QgPSBmYWxzZTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5fcHJvdG8gPSBfcHJvdG87XHJcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IF9wcm90by5fc3RyYXRlZ3kuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHVybnMgYW4gYXJyYXkgb2YgcHJvdmlkZXIgZGVmaW5pdGlvbnMgaW50byBhbiBhcnJheSBvZiByZXNvbHZlZCBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQSByZXNvbHV0aW9uIGlzIGEgcHJvY2VzcyBvZiBmbGF0dGVuaW5nIG11bHRpcGxlIG5lc3RlZCBhcnJheXMgYW5kIGNvbnZlcnRpbmcgaW5kaXZpZHVhbFxyXG4gICAgICogcHJvdmlkZXJzIGludG8gYW4gYXJyYXkgb2Yge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9cy5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQWlYVEhpP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgRW5naW5lIHtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBDYXIge1xyXG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgcHJvdmlkZXJzID0gSW5qZWN0b3IucmVzb2x2ZShbQ2FyLCBbW0VuZ2luZV1dXSk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KHByb3ZpZGVycy5sZW5ndGgpLnRvRXF1YWwoMik7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KHByb3ZpZGVyc1swXSBpbnN0YW5jZW9mIFJlc29sdmVkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkNhclwiKTtcclxuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZGVwZW5kZW5jaWVzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZmFjdG9yeSkudG9CZURlZmluZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzFdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkVuZ2luZVwiKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHtAbGluayBJbmplY3RvciNmcm9tUmVzb2x2ZWRQcm92aWRlcnN9IGZvciBtb3JlIGluZm8uXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnJlc29sdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyXzEucmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGFuIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtAbGluayBQcm92aWRlcn0sXHJcbiAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZVBPY2NBP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgRW5naW5lIHtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBDYXIge1xyXG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXIsIEVuZ2luZV0pO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgZnJvbVJlc29sdmVkUHJvdmlkZXJzYFxyXG4gICAgICogYmVjYXVzZSBpdCBuZWVkcyB0byByZXNvbHZlIHRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGZpcnN0LlxyXG4gICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30uXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXJzID0gSW5qZWN0b3IucmVzb2x2ZShwcm92aWRlcnMpO1xyXG4gICAgICAgIHJldHVybiBJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocmVzb2x2ZWRQcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHByZXZpb3VzbHkgcmVzb2x2ZWQgcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tyU01jaT9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIEVuZ2luZSB7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogQEluamVjdGFibGUoKVxyXG4gICAgICogY2xhc3MgQ2FyIHtcclxuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHByb3ZpZGVycyA9IEluamVjdG9yLnJlc29sdmUoW0NhciwgRW5naW5lXSk7XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKTtcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgdmFyIGJkID0gcHJvdmlkZXJzLm1hcChmdW5jdGlvbiAoYikgeyByZXR1cm4gbmV3IFByb3ZpZGVyV2l0aFZpc2liaWxpdHkoYiwgVmlzaWJpbGl0eS5QdWJsaWMpOyB9KTtcclxuICAgICAgICB2YXIgcHJvdG8gPSBuZXcgUHJvdG9JbmplY3RvcihiZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmplY3Rvcihwcm90bywgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5mcm9tUmVzb2x2ZWRCaW5kaW5ncyA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcclxuICAgICAgICByZXR1cm4gSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmRlYnVnQ29udGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnQ29udGV4dCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgaW5qZWN0b3IgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRva2VuLlxyXG4gICAgICogVGhyb3dzIHtAbGluayBOb1Byb3ZpZGVyRXJyb3J9IGlmIG5vdCBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvSGVYU0hnP3A9cHJldmlldykpXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAgICAgKiAgIHByb3ZpZGUoXCJ2YWxpZFRva2VuXCIsIHt1c2VWYWx1ZTogXCJWYWx1ZVwifSlcclxuICAgICAqIF0pO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChcInZhbGlkVG9rZW5cIikpLnRvRXF1YWwoXCJWYWx1ZVwiKTtcclxuICAgICAqIGV4cGVjdCgoKSA9PiBpbmplY3Rvci5nZXQoXCJpbnZhbGlkVG9rZW5cIikpLnRvVGhyb3dFcnJvcigpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogYEluamVjdG9yYCByZXR1cm5zIGl0c2VsZiB3aGVuIGdpdmVuIGBJbmplY3RvcmAgYXMgYSB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtdKTtcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoSW5qZWN0b3IpKS50b0JlKGluamVjdG9yKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGtleV8xLktleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCBmYWxzZSwgVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIHRoZSBpbmplY3RvciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdG9rZW4uXHJcbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC90cEViRXk/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgcHJvdmlkZShcInZhbGlkVG9rZW5cIiwge3VzZVZhbHVlOiBcIlZhbHVlXCJ9KVxyXG4gICAgICogXSk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0T3B0aW9uYWwoXCJ2YWxpZFRva2VuXCIpKS50b0VxdWFsKFwiVmFsdWVcIik7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0T3B0aW9uYWwoXCJpbnZhbGlkVG9rZW5cIikpLnRvQmUobnVsbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBgSW5qZWN0b3JgIHJldHVybnMgaXRzZWxmIHdoZW4gZ2l2ZW4gYEluamVjdG9yYCBhcyBhIHRva2VuLlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW10pO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldE9wdGlvbmFsKEluamVjdG9yKSkudG9CZShpbmplY3Rvcik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmdldE9wdGlvbmFsID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGtleV8xLktleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCB0cnVlLCBWaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5nZXRBdCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0T2JqQXRJbmRleChpbmRleCk7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5qZWN0b3IucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyZW50IG9mIHRoaXMgaW5qZWN0b3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxyXG4gICAgICAgICAqIC0tPlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2Vvc01Hbz9wPXByZXZpZXcpKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtdKTtcclxuICAgICAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtdKTtcclxuICAgICAgICAgKiBleHBlY3QoY2hpbGQucGFyZW50KS50b0JlKHBhcmVudCk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluamVjdG9yLnByb3RvdHlwZSwgXCJpbnRlcm5hbFN0cmF0ZWd5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKiBJbnRlcm5hbC4gRG8gbm90IHVzZS5cclxuICAgICAgICAgKiBXZSByZXR1cm4gYGFueWAgbm90IHRvIGV4cG9ydCB0aGUgSW5qZWN0b3JTdHJhdGVneSB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBwcm92aWRlcnMgYW5kIGNyZWF0ZXMgYSBjaGlsZCBpbmplY3RvciBmcm9tIHRob3NlIHByb3ZpZGVycy5cclxuICAgICAqXHJcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxyXG4gICAgICogLS0+XHJcbiAgICAgKlxyXG4gICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcclxuICAgICAqIG9yIGEgcmVjdXJzaXZlIGFycmF5IG9mIG1vcmUgcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9vcEIzVDQ/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxyXG4gICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxyXG4gICAgICpcclxuICAgICAqIHZhciBwYXJlbnQgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtQYXJlbnRQcm92aWRlcl0pO1xyXG4gICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbQ2hpbGRQcm92aWRlcl0pO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KENoaWxkUHJvdmlkZXIpIGluc3RhbmNlb2YgQ2hpbGRQcm92aWRlcikudG9CZSh0cnVlKTtcclxuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpKS50b0JlKHBhcmVudC5nZXQoUGFyZW50UHJvdmlkZXIpKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkYFxyXG4gICAgICogYmVjYXVzZSBpdCBuZWVkcyB0byByZXNvbHZlIHRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGZpcnN0LlxyXG4gICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2NyZWF0ZUNoaWxkRnJvbVJlc29sdmVkfS5cclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcclxuICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlcnMgPSBJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQocmVzb2x2ZWRQcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cclxuICAgICAqIC0tPlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1ZoeWZqTj9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIFBhcmVudFByb3ZpZGVyIHt9XHJcbiAgICAgKiBjbGFzcyBDaGlsZFByb3ZpZGVyIHt9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHBhcmVudFByb3ZpZGVycyA9IEluamVjdG9yLnJlc29sdmUoW1BhcmVudFByb3ZpZGVyXSk7XHJcbiAgICAgKiB2YXIgY2hpbGRQcm92aWRlcnMgPSBJbmplY3Rvci5yZXNvbHZlKFtDaGlsZFByb3ZpZGVyXSk7XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHBhcmVudCA9IEluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwYXJlbnRQcm92aWRlcnMpO1xyXG4gICAgICogdmFyIGNoaWxkID0gcGFyZW50LmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKGNoaWxkUHJvdmlkZXJzKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xyXG4gICAgICogZXhwZWN0KGNoaWxkLmdldChDaGlsZFByb3ZpZGVyKSBpbnN0YW5jZW9mIENoaWxkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xyXG4gICAgICAgIHZhciBiZCA9IHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIG5ldyBQcm92aWRlcldpdGhWaXNpYmlsaXR5KGIsIFZpc2liaWxpdHkuUHVibGljKTsgfSk7XHJcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IFByb3RvSW5qZWN0b3IoYmQpO1xyXG4gICAgICAgIHZhciBpbmogPSBuZXcgSW5qZWN0b3IocHJvdG8sIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGluai5fcGFyZW50ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gaW5qO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgYSBwcm92aWRlciBhbmQgaW5zdGFudGlhdGVzIGFuIG9iamVjdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC95dlZYb0I/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIENhciB7XHJcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xyXG4gICAgICpcclxuICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKTtcclxuICAgICAqIGV4cGVjdChjYXIuZW5naW5lKS50b0JlKGluamVjdG9yLmdldChFbmdpbmUpKTtcclxuICAgICAqIGV4cGVjdChjYXIpLm5vdC50b0JlKGluamVjdG9yLnJlc29sdmVBbmRJbnN0YW50aWF0ZShDYXIpKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZEluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGVSZXNvbHZlZChJbmplY3Rvci5yZXNvbHZlKFtwcm92aWRlcl0pWzBdKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBvYmplY3QgdXNpbmcgYSByZXNvbHZlZCBwcm92aWRlciBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9wdENJbVE/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBASW5qZWN0YWJsZSgpXHJcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEBJbmplY3RhYmxlKClcclxuICAgICAqIGNsYXNzIENhciB7XHJcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xyXG4gICAgICogdmFyIGNhclByb3ZpZGVyID0gSW5qZWN0b3IucmVzb2x2ZShbQ2FyXSlbMF07XHJcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcik7XHJcbiAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSkudG9CZShpbmplY3Rvci5nZXQoRW5naW5lKSk7XHJcbiAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5pbnN0YW50aWF0ZVJlc29sdmVkKGNhclByb3ZpZGVyKSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlciwgVmlzaWJpbGl0eS5QdWJsaWNBbmRQcml2YXRlKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX25ldyA9IGZ1bmN0aW9uIChwcm92aWRlciwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyKysgPiB0aGlzLl9zdHJhdGVneS5nZXRNYXhOdW1iZXJPZk9iamVjdHMoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkN5Y2xpY0RlcGVuZGVuY3lFcnJvcih0aGlzLCBwcm92aWRlci5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlciwgdmlzaWJpbGl0eSk7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl9pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCB2aXNpYmlsaXR5KSB7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2ldLCB2aXNpYmlsaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlKHByb3ZpZGVyLCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllc1swXSwgdmlzaWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5faW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHJlc29sdmVkRmFjdG9yeSwgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZWRGYWN0b3J5LmZhY3Rvcnk7XHJcbiAgICAgICAgdmFyIGRlcHMgPSByZXNvbHZlZEZhY3RvcnkuZGVwZW5kZW5jaWVzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBkZXBzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3LCBkMTgsIGQxOTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkMCA9IGxlbmd0aCA+IDAgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMF0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDEgPSBsZW5ndGggPiAxID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzFdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQyID0gbGVuZ3RoID4gMiA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1syXSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMyA9IGxlbmd0aCA+IDMgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbM10sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDQgPSBsZW5ndGggPiA0ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzRdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQ1ID0gbGVuZ3RoID4gNSA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s1XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkNiA9IGxlbmd0aCA+IDYgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNl0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDcgPSBsZW5ndGggPiA3ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzddLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQ4ID0gbGVuZ3RoID4gOCA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s4XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkOSA9IGxlbmd0aCA+IDkgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOV0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDEwID0gbGVuZ3RoID4gMTAgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTBdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxMSA9IGxlbmd0aCA+IDExID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzExXSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTIgPSBsZW5ndGggPiAxMiA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMl0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDEzID0gbGVuZ3RoID4gMTMgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTNdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxNCA9IGxlbmd0aCA+IDE0ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE0XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTUgPSBsZW5ndGggPiAxNSA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNV0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDE2ID0gbGVuZ3RoID4gMTYgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTZdLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgICAgIGQxNyA9IGxlbmd0aCA+IDE3ID8gdGhpcy5fZ2V0QnlEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE3XSwgdmlzaWJpbGl0eSkgOiBudWxsO1xyXG4gICAgICAgICAgICBkMTggPSBsZW5ndGggPiAxOCA/IHRoaXMuX2dldEJ5RGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOF0sIHZpc2liaWxpdHkpIDogbnVsbDtcclxuICAgICAgICAgICAgZDE5ID0gbGVuZ3RoID4gMTkgPyB0aGlzLl9nZXRCeURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTldLCB2aXNpYmlsaXR5KSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLkFic3RyYWN0UHJvdmlkZXJFcnJvciB8fCBlIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLkluc3RhbnRpYXRpb25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5hZGRLZXkodGhpcywgcHJvdmlkZXIua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JqO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTc6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjA6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCwgZDE5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkluc3RhbnRpYXRpb25FcnJvcih0aGlzLCBlLCBlLnN0YWNrLCBwcm92aWRlci5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5fZ2V0QnlEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBkZXAsIHByb3ZpZGVyVmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBzcGVjaWFsID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9kZXBQcm92aWRlcikgP1xyXG4gICAgICAgICAgICB0aGlzLl9kZXBQcm92aWRlci5nZXREZXBlbmRlbmN5KHRoaXMsIHByb3ZpZGVyLCBkZXApIDpcclxuICAgICAgICAgICAgZXhwb3J0cy5VTkRFRklORUQ7XHJcbiAgICAgICAgaWYgKHNwZWNpYWwgIT09IGV4cG9ydHMuVU5ERUZJTkVEKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGRlcC5rZXksIGRlcC5sb3dlckJvdW5kVmlzaWJpbGl0eSwgZGVwLnVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXAub3B0aW9uYWwsIHByb3ZpZGVyVmlzaWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5fZ2V0QnlLZXkgPSBmdW5jdGlvbiAoa2V5LCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIG9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHkpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBJTkpFQ1RPUl9LRVkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cHBlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuU2VsZk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleVNlbGYoa2V5LCBvcHRpb25hbCwgcHJvdmlkZXJWaXNpYmlsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXBwZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkhvc3RNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlIb3N0KGtleSwgb3B0aW9uYWwsIHByb3ZpZGVyVmlzaWJpbGl0eSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5RGVmYXVsdChrZXksIG9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHksIGxvd2VyQm91bmRWaXNpYmlsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl90aHJvd09yTnVsbCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbmFsKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5Ob1Byb3ZpZGVyRXJyb3IodGhpcywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLl9nZXRCeUtleVNlbGYgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25hbCwgcHJvdmlkZXJWaXNpYmlsaXR5KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkLCBwcm92aWRlclZpc2liaWxpdHkpO1xyXG4gICAgICAgIHJldHVybiAob2JqICE9PSBleHBvcnRzLlVOREVGSU5FRCkgPyBvYmogOiB0aGlzLl90aHJvd09yTnVsbChrZXksIG9wdGlvbmFsKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2dldEJ5S2V5SG9zdCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbmFsLCBwcm92aWRlclZpc2liaWxpdHksIGxvd2VyQm91bmRWaXNpYmlsaXR5KSB7XHJcbiAgICAgICAgdmFyIGluaiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxvd2VyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ta2lwU2VsZk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmouX2lzSG9zdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByaXZhdGVEZXBlbmRlbmN5KGtleSwgb3B0aW9uYWwsIGluaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmogPSBpbmouX3BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaW5qICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGluai5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQsIHByb3ZpZGVyVmlzaWJpbGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChvYmogIT09IGV4cG9ydHMuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5qLl9wYXJlbnQpICYmIGluai5faXNIb3N0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJpdmF0ZURlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgaW5qKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluaiA9IGluai5fcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90aHJvd09yTnVsbChrZXksIG9wdGlvbmFsKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuX2dldFByaXZhdGVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGtleSwgb3B0aW9uYWwsIGluaikge1xyXG4gICAgICAgIHZhciBvYmogPSBpbmouX3BhcmVudC5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQsIFZpc2liaWxpdHkuUHJpdmF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIChvYmogIT09IGV4cG9ydHMuVU5ERUZJTkVEKSA/IG9iaiA6IHRoaXMuX3Rocm93T3JOdWxsKGtleSwgb3B0aW9uYWwpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEluamVjdG9yLnByb3RvdHlwZS5fZ2V0QnlLZXlEZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgb3B0aW9uYWwsIHByb3ZpZGVyVmlzaWJpbGl0eSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpIHtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcztcclxuICAgICAgICBpZiAobG93ZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLlNraXBTZWxmTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJWaXNpYmlsaXR5ID0gaW5qLl9pc0hvc3QgPyBWaXNpYmlsaXR5LlB1YmxpY0FuZFByaXZhdGUgOiBWaXNpYmlsaXR5LlB1YmxpYztcclxuICAgICAgICAgICAgaW5qID0gaW5qLl9wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbmogIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gaW5qLl9zdHJhdGVneS5nZXRPYmpCeUtleUlkKGtleS5pZCwgcHJvdmlkZXJWaXNpYmlsaXR5KTtcclxuICAgICAgICAgICAgaWYgKG9iaiAhPT0gZXhwb3J0cy5VTkRFRklORUQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICBwcm92aWRlclZpc2liaWxpdHkgPSBpbmouX2lzSG9zdCA/IFZpc2liaWxpdHkuUHVibGljQW5kUHJpdmF0ZSA6IFZpc2liaWxpdHkuUHVibGljO1xyXG4gICAgICAgICAgICBpbmogPSBpbmouX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93T3JOdWxsKGtleSwgb3B0aW9uYWwpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmplY3Rvci5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJJbmplY3Rvcihwcm92aWRlcnM6IFtcIiArIF9tYXBQcm92aWRlcnModGhpcywgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIChcIiBcXFwiXCIgKyBiLmtleS5kaXNwbGF5TmFtZSArIFwiXFxcIiBcIik7IH0pLmpvaW4oXCIsIFwiKSArIFwiXSlcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEluamVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWU7IH07XHJcbiAgICByZXR1cm4gSW5qZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5qZWN0b3IgPSBJbmplY3RvcjtcclxudmFyIElOSkVDVE9SX0tFWSA9IGtleV8xLktleS5nZXQoSW5qZWN0b3IpO1xyXG5mdW5jdGlvbiBfbWFwUHJvdmlkZXJzKGluamVjdG9yLCBmbikge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3Rvci5fcHJvdG8ubnVtYmVyT2ZQcm92aWRlcnM7ICsraSkge1xyXG4gICAgICAgIHJlcy5wdXNoKGZuKGluamVjdG9yLl9wcm90by5nZXRQcm92aWRlckF0SW5kZXgoaSkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIHR5cGVfbGl0ZXJhbF8xID0gcmVxdWlyZSgnLi90eXBlX2xpdGVyYWwnKTtcclxudmFyIGZvcndhcmRfcmVmXzEgPSByZXF1aXJlKCcuL2ZvcndhcmRfcmVmJyk7XHJcbnZhciB0eXBlX2xpdGVyYWxfMiA9IHJlcXVpcmUoJy4vdHlwZV9saXRlcmFsJyk7XHJcbmV4cG9ydHMuVHlwZUxpdGVyYWwgPSB0eXBlX2xpdGVyYWxfMi5UeXBlTGl0ZXJhbDtcclxuLyoqXHJcbiAqIEEgdW5pcXVlIG9iamVjdCB1c2VkIGZvciByZXRyaWV2aW5nIGl0ZW1zIGZyb20gdGhlIHtAbGluayBJbmplY3Rvcn0uXHJcbiAqXHJcbiAqIEtleXMgaGF2ZTpcclxuICogLSBhIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgLlxyXG4gKiAtIGEgYHRva2VuYC5cclxuICpcclxuICogYEtleWAgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBJbmplY3Rvcn0gYmVjYXVzZSBpdHMgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAgYWxsb3dzIHRoZVxyXG4gKiBpbmplY3RvciB0byBzdG9yZSBjcmVhdGVkIG9iamVjdHMgaW4gYSBtb3JlIGVmZmljaWVudCB3YXkuXHJcbiAqXHJcbiAqIGBLZXlgIHNob3VsZCBub3QgYmUgY3JlYXRlZCBkaXJlY3RseS4ge0BsaW5rIEluamVjdG9yfSBjcmVhdGVzIGtleXMgYXV0b21hdGljYWxseSB3aGVuIHJlc29sdmluZ1xyXG4gKiBwcm92aWRlcnMuXHJcbiAqL1xyXG52YXIgS2V5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBLZXkodG9rZW4sIGlkKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVG9rZW4gbXVzdCBiZSBkZWZpbmVkIScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXkucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5naWZpZWQgdG9rZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuc3RyaW5naWZ5KHRoaXMudG9rZW4pOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgYEtleWAgZm9yIGEgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIEtleS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIF9nbG9iYWxLZXlSZWdpc3RyeS5nZXQoZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZih0b2tlbikpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleSwgXCJudW1iZXJPZktleXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyByZWdpc3RlcmVkIGluIHRoZSBzeXN0ZW0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkubnVtYmVyT2ZLZXlzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBLZXk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuS2V5ID0gS2V5O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgS2V5UmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gS2V5UmVnaXN0cnkoKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsS2V5cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIEtleVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBLZXkpXHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAvLyBUT0RPOiB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxMjNcclxuICAgICAgICB2YXIgdGhlVG9rZW4gPSB0b2tlbjtcclxuICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiB0eXBlX2xpdGVyYWxfMS5UeXBlTGl0ZXJhbCkge1xyXG4gICAgICAgICAgICB0aGVUb2tlbiA9IHRva2VuLnR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuID0gdGhlVG9rZW47XHJcbiAgICAgICAgaWYgKHRoaXMuX2FsbEtleXMuaGFzKHRva2VuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsS2V5cy5nZXQodG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3S2V5ID0gbmV3IEtleSh0b2tlbiwgS2V5Lm51bWJlck9mS2V5cyk7XHJcbiAgICAgICAgdGhpcy5fYWxsS2V5cy5zZXQodG9rZW4sIG5ld0tleSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0tleTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5UmVnaXN0cnkucHJvdG90eXBlLCBcIm51bWJlck9mS2V5c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGxLZXlzLnNpemU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEtleVJlZ2lzdHJ5O1xyXG59KSgpO1xyXG5leHBvcnRzLktleVJlZ2lzdHJ5ID0gS2V5UmVnaXN0cnk7XHJcbnZhciBfZ2xvYmFsS2V5UmVnaXN0cnkgPSBuZXcgS2V5UmVnaXN0cnkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZShcImFuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nXCIpO1xyXG4vKipcclxuICogQSBwYXJhbWV0ZXIgbWV0YWRhdGEgdGhhdCBzcGVjaWZpZXMgYSBkZXBlbmRlbmN5LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvNnVIWUpLP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgRW5naW5lIHt9XHJcbiAqXHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgQ2FyIHtcclxuICogICBlbmdpbmU7XHJcbiAqICAgY29uc3RydWN0b3IoQEluamVjdChcIk15RW5naW5lXCIpIGVuZ2luZTpFbmdpbmUpIHtcclxuICogICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICogIHByb3ZpZGUoXCJNeUVuZ2luZVwiLCB7dXNlQ2xhc3M6IEVuZ2luZX0pLFxyXG4gKiAgQ2FyXHJcbiAqIF0pO1xyXG4gKlxyXG4gKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikuZW5naW5lIGluc3RhbmNlb2YgRW5naW5lKS50b0JlKHRydWUpO1xyXG4gKiBgYGBcclxuICpcclxuICogV2hlbiBgQEluamVjdCgpYCBpcyBub3QgcHJlc2VudCwge0BsaW5rIEluamVjdG9yfSB3aWxsIHVzZSB0aGUgdHlwZSBhbm5vdGF0aW9uIG9mIHRoZSBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgRW5naW5lIHt9XHJcbiAqXHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgQ2FyIHtcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOiBFbmdpbmUpIHt9IC8vc2FtZSBhcyBjb25zdHJ1Y3RvcihASW5qZWN0KEVuZ2luZSkgZW5naW5lOkVuZ2luZSlcclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmUsIENhcl0pO1xyXG4gKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikuZW5naW5lIGluc3RhbmNlb2YgRW5naW5lKS50b0JlKHRydWUpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBJbmplY3RNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmplY3RNZXRhZGF0YSh0b2tlbikge1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgIH1cclxuICAgIEluamVjdE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEluamVjdChcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIilcIjsgfTtcclxuICAgIEluamVjdE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBJbmplY3RNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gSW5qZWN0TWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5qZWN0TWV0YWRhdGEgPSBJbmplY3RNZXRhZGF0YTtcclxuLyoqXHJcbiAqIEEgcGFyYW1ldGVyIG1ldGFkYXRhIHRoYXQgbWFya3MgYSBkZXBlbmRlbmN5IGFzIG9wdGlvbmFsLiB7QGxpbmsgSW5qZWN0b3J9IHByb3ZpZGVzIGBudWxsYCBpZlxyXG4gKiB0aGUgZGVwZW5kZW5jeSBpcyBub3QgZm91bmQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9Bc3J5T20/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBFbmdpbmUge31cclxuICpcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBDYXIge1xyXG4gKiAgIGVuZ2luZTtcclxuICogICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBlbmdpbmU6RW5naW5lKSB7XHJcbiAqICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyXSk7XHJcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKS5lbmdpbmUpLnRvQmVOdWxsKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE9wdGlvbmFsTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT3B0aW9uYWxNZXRhZGF0YSgpIHtcclxuICAgIH1cclxuICAgIE9wdGlvbmFsTWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAT3B0aW9uYWwoKVwiOyB9O1xyXG4gICAgT3B0aW9uYWxNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgT3B0aW9uYWxNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gT3B0aW9uYWxNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5PcHRpb25hbE1ldGFkYXRhID0gT3B0aW9uYWxNZXRhZGF0YTtcclxuLyoqXHJcbiAqIGBEZXBlbmRlbmN5TWV0YWRhdGFgIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBleHRlbmQgREkuXHJcbiAqIFRoaXMgaXMgaW50ZXJuYWwgdG8gQW5ndWxhciBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LlxyXG4gKi9cclxudmFyIERlcGVuZGVuY3lNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXBlbmRlbmN5TWV0YWRhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVwZW5kZW5jeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJ0b2tlblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERlcGVuZGVuY3lNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRGVwZW5kZW5jeU1ldGFkYXRhKTtcclxuICAgIHJldHVybiBEZXBlbmRlbmN5TWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVwZW5kZW5jeU1ldGFkYXRhID0gRGVwZW5kZW5jeU1ldGFkYXRhO1xyXG4vKipcclxuICogQSBtYXJrZXIgbWV0YWRhdGEgdGhhdCBtYXJrcyBhIGNsYXNzIGFzIGF2YWlsYWJsZSB0byB7QGxpbmsgSW5qZWN0b3J9IGZvciBjcmVhdGlvbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1drNERNUT9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgVXNlZnVsU2VydmljZSB7fVxyXG4gKlxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIE5lZWRzU2VydmljZSB7XHJcbiAqICAgY29uc3RydWN0b3IocHVibGljIHNlcnZpY2U6VXNlZnVsU2VydmljZSkge31cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtOZWVkc1NlcnZpY2UsIFVzZWZ1bFNlcnZpY2VdKTtcclxuICogZXhwZWN0KGluamVjdG9yLmdldChOZWVkc1NlcnZpY2UpLnNlcnZpY2UgaW5zdGFuY2VvZiBVc2VmdWxTZXJ2aWNlKS50b0JlKHRydWUpO1xyXG4gKiBgYGBcclxuICoge0BsaW5rIEluamVjdG9yfSB3aWxsIHRocm93IHtAbGluayBOb0Fubm90YXRpb25FcnJvcn0gd2hlbiB0cnlpbmcgdG8gaW5zdGFudGlhdGUgYSBjbGFzcyB0aGF0XHJcbiAqIGRvZXMgbm90IGhhdmUgYEBJbmplY3RhYmxlYCBtYXJrZXIsIGFzIHNob3duIGluIHRoZSBleGFtcGxlIGJlbG93LlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIFVzZWZ1bFNlcnZpY2Uge31cclxuICpcclxuICogY2xhc3MgTmVlZHNTZXJ2aWNlIHtcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgc2VydmljZTpVc2VmdWxTZXJ2aWNlKSB7fVxyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW05lZWRzU2VydmljZSwgVXNlZnVsU2VydmljZV0pO1xyXG4gKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KE5lZWRzU2VydmljZSkpLnRvVGhyb3dFcnJvcigpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBJbmplY3RhYmxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5qZWN0YWJsZU1ldGFkYXRhKCkge1xyXG4gICAgfVxyXG4gICAgSW5qZWN0YWJsZU1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBJbmplY3RhYmxlTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIEluamVjdGFibGVNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5JbmplY3RhYmxlTWV0YWRhdGEgPSBJbmplY3RhYmxlTWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgdGhhdCBhbiB7QGxpbmsgSW5qZWN0b3J9IHNob3VsZCByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgb25seSBmcm9tIGl0c2VsZi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L05lYWdBZz9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIERlcGVuZGVuY3kge1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBJbmplY3RhYmxlKClcclxuICogY2xhc3MgTmVlZHNEZXBlbmRlbmN5IHtcclxuICogICBkZXBlbmRlbmN5O1xyXG5cclxuICogICBkZXBlbmRlbmN5O1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBTZWxmKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XHJcbiAqICAgICB0aGlzLmRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5O1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgaW5qID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRGVwZW5kZW5jeSwgTmVlZHNEZXBlbmRlbmN5XSk7XHJcbiAqIHZhciBuZCA9IGluai5nZXQoTmVlZHNEZXBlbmRlbmN5KTtcclxuICpcclxuICogZXhwZWN0KG5kLmRlcGVuZGVuY3kgaW5zdGFuY2VvZiBEZXBlbmRlbmN5KS50b0JlKHRydWUpO1xyXG4gKlxyXG4gKiB2YXIgaW5qID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRGVwZW5kZW5jeV0pO1xyXG4gKiB2YXIgY2hpbGQgPSBpbmoucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtOZWVkc0RlcGVuZGVuY3ldKTtcclxuICogZXhwZWN0KCgpID0+IGNoaWxkLmdldChOZWVkc0RlcGVuZGVuY3kpKS50b1Rocm93RXJyb3IoKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgU2VsZk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGZNZXRhZGF0YSgpIHtcclxuICAgIH1cclxuICAgIFNlbGZNZXRhZGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkBTZWxmKClcIjsgfTtcclxuICAgIFNlbGZNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgU2VsZk1ldGFkYXRhKTtcclxuICAgIHJldHVybiBTZWxmTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZk1ldGFkYXRhID0gU2VsZk1ldGFkYXRhO1xyXG4vKipcclxuICogU3BlY2lmaWVzIHRoYXQgdGhlIGRlcGVuZGVuY3kgcmVzb2x1dGlvbiBzaG91bGQgc3RhcnQgZnJvbSB0aGUgcGFyZW50IGluamVjdG9yLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvV2NoZHpiP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgRGVwZW5kZW5jeSB7XHJcbiAqIH1cclxuICpcclxuICogQEluamVjdGFibGUoKVxyXG4gKiBjbGFzcyBOZWVkc0RlcGVuZGVuY3kge1xyXG4gKiAgIGRlcGVuZGVuY3k7XHJcbiAqICAgY29uc3RydWN0b3IoQFNraXBTZWxmKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XHJcbiAqICAgICB0aGlzLmRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5O1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiB2YXIgcGFyZW50ID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRGVwZW5kZW5jeV0pO1xyXG4gKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtOZWVkc0RlcGVuZGVuY3ldKTtcclxuICogZXhwZWN0KGNoaWxkLmdldChOZWVkc0RlcGVuZGVuY3kpLmRlcGVuZGVuY3kgaW5zdGFuY2VvZiBEZXBlZGVuY3kpLnRvQmUodHJ1ZSk7XHJcbiAqXHJcbiAqIHZhciBpbmogPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtEZXBlbmRlbmN5LCBOZWVkc0RlcGVuZGVuY3ldKTtcclxuICogZXhwZWN0KCgpID0+IGluai5nZXQoTmVlZHNEZXBlbmRlbmN5KSkudG9UaHJvd0Vycm9yKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFNraXBTZWxmTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2tpcFNlbGZNZXRhZGF0YSgpIHtcclxuICAgIH1cclxuICAgIFNraXBTZWxmTWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAU2tpcFNlbGYoKVwiOyB9O1xyXG4gICAgU2tpcFNlbGZNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgU2tpcFNlbGZNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gU2tpcFNlbGZNZXRhZGF0YTtcclxufSkoKTtcclxuZXhwb3J0cy5Ta2lwU2VsZk1ldGFkYXRhID0gU2tpcFNlbGZNZXRhZGF0YTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGF0IGFuIGluamVjdG9yIHNob3VsZCByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgZnJvbSBhbnkgaW5qZWN0b3IgdW50aWwgcmVhY2hpbmcgdGhlXHJcbiAqIGNsb3Nlc3QgaG9zdC5cclxuICpcclxuICogSW4gQW5ndWxhciwgYSBjb21wb25lbnQgZWxlbWVudCBpcyBhdXRvbWF0aWNhbGx5IGRlY2xhcmVkIGFzIGEgaG9zdCBmb3IgYWxsIHRoZSBpbmplY3RvcnMgaW5cclxuICogaXRzIHZpZXcuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HWDc5cFY/cD1wcmV2aWV3KSlcclxuICpcclxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIGBBcHBgIGNvbnRhaW5zIGBQYXJlbnRDbXBgLCB3aGljaCBjb250YWlucyBgQ2hpbGREaXJlY3RpdmVgLlxyXG4gKiBTbyBgUGFyZW50Q21wYCBpcyB0aGUgaG9zdCBvZiBgQ2hpbGREaXJlY3RpdmVgLlxyXG4gKlxyXG4gKiBgQ2hpbGREaXJlY3RpdmVgIGRlcGVuZHMgb24gdHdvIHNlcnZpY2VzOiBgSG9zdFNlcnZpY2VgIGFuZCBgT3RoZXJTZXJ2aWNlYC5cclxuICogYEhvc3RTZXJ2aWNlYCBpcyBkZWZpbmVkIGF0IGBQYXJlbnRDbXBgLCBhbmQgYE90aGVyU2VydmljZWAgaXMgZGVmaW5lZCBhdCBgQXBwYC5cclxuICpcclxuICpgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE90aGVyU2VydmljZSB7fVxyXG4gKiBjbGFzcyBIb3N0U2VydmljZSB7fVxyXG4gKlxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ2NoaWxkLWRpcmVjdGl2ZSdcclxuICogfSlcclxuICogY2xhc3MgQ2hpbGREaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBIb3N0KCkgb3M6T3RoZXJTZXJ2aWNlLCBAT3B0aW9uYWwoKSBASG9zdCgpIGhzOkhvc3RTZXJ2aWNlKXtcclxuICogICAgIGNvbnNvbGUubG9nKFwib3MgaXMgbnVsbFwiLCBvcyk7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcImhzIGlzIE5PVCBudWxsXCIsIGhzKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdwYXJlbnQtY21wJyxcclxuICogICBwcm92aWRlcnM6IFtIb3N0U2VydmljZV0sXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIERpcjogPGNoaWxkLWRpcmVjdGl2ZT48L2NoaWxkLWRpcmVjdGl2ZT5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDaGlsZERpcmVjdGl2ZV1cclxuICogfSlcclxuICogY2xhc3MgUGFyZW50Q21wIHtcclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgcHJvdmlkZXJzOiBbT3RoZXJTZXJ2aWNlXSxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgUGFyZW50OiA8cGFyZW50LWNtcD48L3BhcmVudC1jbXA+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbUGFyZW50Q21wXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge1xyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHApO1xyXG4gKmBgYFxyXG4gKi9cclxudmFyIEhvc3RNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIb3N0TWV0YWRhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBIb3N0TWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJASG9zdCgpXCI7IH07XHJcbiAgICBIb3N0TWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEhvc3RNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gSG9zdE1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkhvc3RNZXRhZGF0YSA9IEhvc3RNZXRhZGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgaW4gYSBESSBQcm92aWRlci5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lzOWV6WHBqMk1ub3kzVWM4S0JwP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogdmFyIHQgPSBuZXcgT3BhcXVlVG9rZW4oXCJ2YWx1ZVwiKTtcclxuICpcclxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXHJcbiAqICAgcHJvdmlkZSh0LCB7dXNlVmFsdWU6IFwicHJvdmlkZWRWYWx1ZVwifSlcclxuICogXSk7XHJcbiAqXHJcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQodCkpLnRvRXF1YWwoXCJiaW5kaW5nVmFsdWVcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBVc2luZyBhbiBgT3BhcXVlVG9rZW5gIGlzIHByZWZlcmFibGUgdG8gdXNpbmcgc3RyaW5ncyBhcyB0b2tlbnMgYmVjYXVzZSBvZiBwb3NzaWJsZSBjb2xsaXNpb25zXHJcbiAqIGNhdXNlZCBieSBtdWx0aXBsZSBwcm92aWRlcnMgdXNpbmcgdGhlIHNhbWUgc3RyaW5nIGFzIHR3byBkaWZmZXJlbnQgdG9rZW5zLlxyXG4gKlxyXG4gKiBVc2luZyBhbiBgT3BhcXVlVG9rZW5gIGlzIHByZWZlcmFibGUgdG8gdXNpbmcgYW4gYE9iamVjdGAgYXMgdG9rZW5zIGJlY2F1c2UgaXQgcHJvdmlkZXMgYmV0dGVyXHJcbiAqIGVycm9yIG1lc3NhZ2VzLlxyXG4gKi9cclxudmFyIE9wYXF1ZVRva2VuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9wYXF1ZVRva2VuKF9kZXNjKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzYyA9IF9kZXNjO1xyXG4gICAgfVxyXG4gICAgT3BhcXVlVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUb2tlbiBcIiArIHRoaXMuX2Rlc2M7IH07XHJcbiAgICBPcGFxdWVUb2tlbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgT3BhcXVlVG9rZW4pO1xyXG4gICAgcmV0dXJuIE9wYXF1ZVRva2VuO1xyXG59KSgpO1xyXG5leHBvcnRzLk9wYXF1ZVRva2VuID0gT3BhcXVlVG9rZW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZV90b2tlbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIga2V5XzEgPSByZXF1aXJlKCcuL2tleScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEnKTtcclxudmFyIGV4Y2VwdGlvbnNfMiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9ucycpO1xyXG52YXIgZm9yd2FyZF9yZWZfMSA9IHJlcXVpcmUoJy4vZm9yd2FyZF9yZWYnKTtcclxudmFyIERlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVwZW5kZW5jeShrZXksIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XHJcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kVmlzaWJpbGl0eSA9IGxvd2VyQm91bmRWaXNpYmlsaXR5O1xyXG4gICAgICAgIHRoaXMudXBwZXJCb3VuZFZpc2liaWxpdHkgPSB1cHBlckJvdW5kVmlzaWJpbGl0eTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgRGVwZW5kZW5jeS5mcm9tS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbmV3IERlcGVuZGVuY3koa2V5LCBmYWxzZSwgbnVsbCwgbnVsbCwgW10pOyB9O1xyXG4gICAgcmV0dXJuIERlcGVuZGVuY3k7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGVwZW5kZW5jeSA9IERlcGVuZGVuY3k7XHJcbnZhciBfRU1QVFlfTElTVCA9IGxhbmdfMS5DT05TVF9FWFBSKFtdKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBob3cgdGhlIHtAbGluayBJbmplY3Rvcn0gc2hvdWxkIGluc3RhbnRpYXRlIGEgZ2l2ZW4gdG9rZW4uXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgcHJvdmlkZX0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HTkF5ajZLNlBmWWcyTkJ6Z3daNT9wJTNEcHJldmlldyZwPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gKiAgIG5ldyBQcm92aWRlcihcIm1lc3NhZ2VcIiwgeyB1c2VWYWx1ZTogJ0hlbGxvJyB9KVxyXG4gKiBdKTtcclxuICpcclxuICogZXhwZWN0KGluamVjdG9yLmdldChcIm1lc3NhZ2VcIikpLnRvRXF1YWwoJ0hlbGxvJyk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKHRva2VuLCBfYSkge1xyXG4gICAgICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMudXNlQ2xhc3MgPSB1c2VDbGFzcztcclxuICAgICAgICB0aGlzLnVzZVZhbHVlID0gdXNlVmFsdWU7XHJcbiAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xyXG4gICAgICAgIHRoaXMudXNlRmFjdG9yeSA9IHVzZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBzO1xyXG4gICAgICAgIHRoaXMuX211bHRpID0gbXVsdGk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXIucHJvdG90eXBlLCBcIm11bHRpXCIsIHtcclxuICAgICAgICAvLyBUT0RPOiBQcm92aWRlIGEgZnVsbCB3b3JraW5nIGV4YW1wbGUgYWZ0ZXIgYWxwaGEzOCBpcyByZWxlYXNlZC5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIG11bHRpcGxlIHByb3ZpZGVycyBtYXRjaGluZyB0aGUgc2FtZSB0b2tlbiAoYSBtdWx0aS1wcm92aWRlcikuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBNdWx0aS1wcm92aWRlcnMgYXJlIHVzZWQgZm9yIGNyZWF0aW5nIHBsdWdnYWJsZSBzZXJ2aWNlLCB3aGVyZSB0aGUgc3lzdGVtIGNvbWVzXHJcbiAgICAgICAgICogd2l0aCBzb21lIGRlZmF1bHQgcHJvdmlkZXJzLCBhbmQgdGhlIHVzZXIgY2FuIHJlZ2lzdGVyIGFkZGl0b25hbCBwcm92aWRlcnMuXHJcbiAgICAgICAgICogVGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBkZWZhdWx0IHByb3ZpZGVycyBhbmQgdGhlIGFkZGl0aW9uYWwgcHJvdmlkZXJzIHdpbGwgYmVcclxuICAgICAgICAgKiB1c2VkIHRvIGRyaXZlIHRoZSBiZWhhdmlvciBvZiB0aGUgc3lzdGVtLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIyMjIEV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAgICAgKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwgeyB1c2VWYWx1ZTogXCJTdHJpbmcxXCIsIG11bHRpOiB0cnVlfSksXHJcbiAgICAgICAgICogICBuZXcgUHJvdmlkZXIoXCJTdHJpbmdzXCIsIHsgdXNlVmFsdWU6IFwiU3RyaW5nMlwiLCBtdWx0aTogdHJ1ZX0pXHJcbiAgICAgICAgICogXSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KFwiU3RyaW5nc1wiKSkudG9FcXVhbChbXCJTdHJpbmcxXCIsIFwiU3RyaW5nMlwiXSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBNdWx0aS1wcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzIGNhbm5vdCBiZSBtaXhlZC4gVGhlIGZvbGxvd2luZ1xyXG4gICAgICAgICAqIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzFcIiwgbXVsdGk6IHRydWUgfSksXHJcbiAgICAgICAgICogICBuZXcgUHJvdmlkZXIoXCJTdHJpbmdzXCIsIHsgdXNlVmFsdWU6IFwiU3RyaW5nMlwifSlcclxuICAgICAgICAgKiBdKTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5ub3JtYWxpemVCb29sKHRoaXMuX211bHRpKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQcm92aWRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3QsIE9iamVjdF0pXHJcbiAgICBdLCBQcm92aWRlcik7XHJcbiAgICByZXR1cm4gUHJvdmlkZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG52YXIgQmluZGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmluZGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJpbmRpbmcodG9rZW4sIF9hKSB7XHJcbiAgICAgICAgdmFyIHRvQ2xhc3MgPSBfYS50b0NsYXNzLCB0b1ZhbHVlID0gX2EudG9WYWx1ZSwgdG9BbGlhcyA9IF9hLnRvQWxpYXMsIHRvRmFjdG9yeSA9IF9hLnRvRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdG9rZW4sIHtcclxuICAgICAgICAgICAgdXNlQ2xhc3M6IHRvQ2xhc3MsXHJcbiAgICAgICAgICAgIHVzZVZhbHVlOiB0b1ZhbHVlLFxyXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogdG9BbGlhcyxcclxuICAgICAgICAgICAgdXNlRmFjdG9yeTogdG9GYWN0b3J5LFxyXG4gICAgICAgICAgICBkZXBzOiBkZXBzLFxyXG4gICAgICAgICAgICBtdWx0aTogbXVsdGlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCaW5kaW5nLnByb3RvdHlwZSwgXCJ0b0NsYXNzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51c2VDbGFzczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9BbGlhc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXNlRXhpc3Rpbmc7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmcucHJvdG90eXBlLCBcInRvRmFjdG9yeVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXNlRmFjdG9yeTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9WYWx1ZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXNlVmFsdWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQmluZGluZyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3QsIE9iamVjdF0pXHJcbiAgICBdLCBCaW5kaW5nKTtcclxuICAgIHJldHVybiBCaW5kaW5nO1xyXG59KShQcm92aWRlcik7XHJcbmV4cG9ydHMuQmluZGluZyA9IEJpbmRpbmc7XHJcbnZhciBSZXNvbHZlZFByb3ZpZGVyXyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXNvbHZlZFByb3ZpZGVyXyhrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aVByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZhY3RvcmllcyA9IHJlc29sdmVkRmFjdG9yaWVzO1xyXG4gICAgICAgIHRoaXMubXVsdGlQcm92aWRlciA9IG11bHRpUHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb2x2ZWRQcm92aWRlcl8ucHJvdG90eXBlLCBcInJlc29sdmVkRmFjdG9yeVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlc29sdmVkRmFjdG9yaWVzWzBdOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBSZXNvbHZlZFByb3ZpZGVyXztcclxufSkoKTtcclxuZXhwb3J0cy5SZXNvbHZlZFByb3ZpZGVyXyA9IFJlc29sdmVkUHJvdmlkZXJfO1xyXG4vKipcclxuICogQW4gaW50ZXJuYWwgcmVzb2x2ZWQgcmVwcmVzZW50YXRpb24gb2YgYSBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZWQgYnkgcmVzb2x2aW5nIHtAbGluayBQcm92aWRlcn0uXHJcbiAqL1xyXG52YXIgUmVzb2x2ZWRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlc29sdmVkRmFjdG9yeShcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGEga2V5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZhY3RvcnksIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFyZ3VtZW50cyAoZGVwZW5kZW5jaWVzKSB0byB0aGUgYGZhY3RvcnlgIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzb2x2ZWRGYWN0b3J5O1xyXG59KSgpO1xyXG5leHBvcnRzLlJlc29sdmVkRmFjdG9yeSA9IFJlc29sdmVkRmFjdG9yeTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBUbyBjb25zdHJ1Y3QgYSB7QGxpbmsgUHJvdmlkZXJ9LCBiaW5kIGEgYHRva2VuYCB0byBlaXRoZXIgYSBjbGFzcywgYSB2YWx1ZSwgYSBmYWN0b3J5IGZ1bmN0aW9uLFxyXG4gKiBvclxyXG4gKiB0byBhbiBleGlzdGluZyBgdG9rZW5gLlxyXG4gKiBTZWUge0BsaW5rIFByb3ZpZGVyQnVpbGRlcn0gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogVGhlIGB0b2tlbmAgaXMgbW9zdCBjb21tb25seSBhIGNsYXNzIG9yIHtAbGluayBhbmd1bGFyMi9kaS9PcGFxdWVUb2tlbn0uXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kKHRva2VuKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb3ZpZGVyQnVpbGRlcih0b2tlbik7XHJcbn1cclxuZXhwb3J0cy5iaW5kID0gYmluZDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIFByb3ZpZGVyfSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiA8IS0tIFRPRE86IGltcHJvdmUgdGhlIGRvY3MgLS0+XHJcbiAqL1xyXG5mdW5jdGlvbiBwcm92aWRlKHRva2VuLCBfYSkge1xyXG4gICAgdmFyIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcclxuICAgIHJldHVybiBuZXcgUHJvdmlkZXIodG9rZW4sIHtcclxuICAgICAgICB1c2VDbGFzczogdXNlQ2xhc3MsXHJcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcclxuICAgICAgICB1c2VGYWN0b3J5OiB1c2VGYWN0b3J5LFxyXG4gICAgICAgIGRlcHM6IGRlcHMsXHJcbiAgICAgICAgbXVsdGk6IG11bHRpXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnByb3ZpZGUgPSBwcm92aWRlO1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciB0aGUge0BsaW5rIGJpbmR9IGZ1bmN0aW9uLlxyXG4gKi9cclxudmFyIFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm92aWRlckJ1aWxkZXIodG9rZW4pIHtcclxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYSBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWnBCQ1NZcXY2ZTJ1ZDVLWExkeFE/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBCZWNhdXNlIGB0b0FsaWFzYCBhbmQgYHRvQ2xhc3NgIGFyZSBvZnRlbiBjb25mdXNlZCwgdGhlIGV4YW1wbGUgY29udGFpbnMgYm90aCB1c2UgY2FzZXMgZm9yXHJcbiAgICAgKiBlYXN5IGNvbXBhcmlzb24uXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgVmVoaWNsZSB7fVxyXG4gICAgICpcclxuICAgICAqIGNsYXNzIENhciBleHRlbmRzIFZlaGljbGUge31cclxuICAgICAqXHJcbiAgICAgKiB2YXIgaW5qZWN0b3JDbGFzcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBDYXIsXHJcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUNsYXNzOiBDYXJ9KVxyXG4gICAgICogXSk7XHJcbiAgICAgKiB2YXIgaW5qZWN0b3JBbGlhcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBDYXIsXHJcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUV4aXN0aW5nOiBDYXJ9KVxyXG4gICAgICogXSk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KGluamVjdG9yQ2xhc3MuZ2V0KFZlaGljbGUpKS5ub3QudG9CZShpbmplY3RvckNsYXNzLmdldChDYXIpKTtcclxuICAgICAqIGV4cGVjdChpbmplY3RvckNsYXNzLmdldChWZWhpY2xlKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JBbGlhcy5nZXQoVmVoaWNsZSkpLnRvQmUoaW5qZWN0b3JBbGlhcy5nZXQoQ2FyKSk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JBbGlhcy5nZXQoVmVoaWNsZSkgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgUHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS50b0NsYXNzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1R5cGUodHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVHJ5aW5nIHRvIGNyZWF0ZSBhIGNsYXNzIHByb3ZpZGVyIGJ1dCBcXFwiXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpICsgXCJcXFwiIGlzIG5vdCBhIGNsYXNzIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlcih0aGlzLnRva2VuLCB7IHVzZUNsYXNzOiB0eXBlIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSBESSB0b2tlbiB0byBhIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HMDI0UEZIbURMMGNKRmdmWks4Tz9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBwcm92aWRlKCdtZXNzYWdlJywge3VzZVZhbHVlOiAnSGVsbG8nfSlcclxuICAgICAqIF0pO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoJ21lc3NhZ2UnKSkudG9FcXVhbCgnSGVsbG8nKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLnRvVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBQcm92aWRlcih0aGlzLnRva2VuLCB7IHVzZVZhbHVlOiB2YWx1ZSB9KTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSBESSB0b2tlbiB0byBhbiBleGlzdGluZyB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBBbmd1bGFyIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlIGFzIGlmIHRoZSBwcm92aWRlZCB0b2tlbiB3YXMgdXNlZC4gKFRoaXMgaXNcclxuICAgICAqIGluIGNvbnRyYXN0IHRvIGB1c2VDbGFzc2Agd2hlcmUgYSBzZXBhcmF0ZSBpbnN0YW5jZSBvZiBgdXNlQ2xhc3NgIHdpbGwgYmUgcmV0dXJuZWQuKVxyXG4gICAgICpcclxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC91QmFvRjJwTjVjZmM1QWZaYXBOdz9wPXByZXZpZXcpKVxyXG4gICAgICpcclxuICAgICAqIEJlY2F1c2UgYHRvQWxpYXNgIGFuZCBgdG9DbGFzc2AgYXJlIG9mdGVuIGNvbmZ1c2VkLCB0aGUgZXhhbXBsZSBjb250YWlucyBib3RoIHVzZSBjYXNlcyBmb3JcclxuICAgICAqIGVhc3lcclxuICAgICAqIGNvbXBhcmlzb24uXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgVmVoaWNsZSB7fVxyXG4gICAgICpcclxuICAgICAqIGNsYXNzIENhciBleHRlbmRzIFZlaGljbGUge31cclxuICAgICAqXHJcbiAgICAgKiB2YXIgaW5qZWN0b3JBbGlhcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBDYXIsXHJcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUV4aXN0aW5nOiBDYXJ9KVxyXG4gICAgICogXSk7XHJcbiAgICAgKiB2YXIgaW5qZWN0b3JDbGFzcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xyXG4gICAgICogICBDYXIsXHJcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUNsYXNzOiBDYXJ9KVxyXG4gICAgICogXSk7XHJcbiAgICAgKlxyXG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpKS50b0JlKGluamVjdG9yQWxpYXMuZ2V0KENhcikpO1xyXG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIGV4cGVjdChpbmplY3RvckNsYXNzLmdldChWZWhpY2xlKSkubm90LnRvQmUoaW5qZWN0b3JDbGFzcy5nZXQoQ2FyKSk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JDbGFzcy5nZXQoVmVoaWNsZSkgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgUHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS50b0FsaWFzID0gZnVuY3Rpb24gKGFsaWFzVG9rZW4pIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoYWxpYXNUb2tlbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2FuIG5vdCBhbGlhcyBcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiB0byBhIGJsYW5rIHZhbHVlIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlcih0aGlzLnRva2VuLCB7IHVzZUV4aXN0aW5nOiBhbGlhc1Rva2VuIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSBESSB0b2tlbiB0byBhIGZ1bmN0aW9uIHdoaWNoIGNvbXB1dGVzIHRoZSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvT2VqTklmVFQzemIxaUJ4YUlZT2I/cD1wcmV2aWV3KSlcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcclxuICAgICAqICAgcHJvdmlkZShOdW1iZXIsIHt1c2VGYWN0b3J5OiAoKSA9PiB7IHJldHVybiAxKzI7IH19KSxcclxuICAgICAqICAgcHJvdmlkZShTdHJpbmcsIHt1c2VGYWN0b3J5OiAodikgPT4geyByZXR1cm4gXCJWYWx1ZTogXCIgKyB2OyB9LCBkZXBzOiBbTnVtYmVyXX0pXHJcbiAgICAgKiBdKTtcclxuICAgICAqXHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KE51bWJlcikpLnRvRXF1YWwoMyk7XHJcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KFN0cmluZykpLnRvRXF1YWwoJ1ZhbHVlOiAzJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgUHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS50b0ZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNGdW5jdGlvbihmYWN0b3J5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJUcnlpbmcgdG8gY3JlYXRlIGEgZmFjdG9yeSBwcm92aWRlciBidXQgXFxcIlwiICsgbGFuZ18xLnN0cmluZ2lmeShmYWN0b3J5KSArIFwiXFxcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdmlkZXIodGhpcy50b2tlbiwgeyB1c2VGYWN0b3J5OiBmYWN0b3J5LCBkZXBzOiBkZXBlbmRlbmNpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb3ZpZGVyQnVpbGRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm92aWRlckJ1aWxkZXIgPSBQcm92aWRlckJ1aWxkZXI7XHJcbi8qKlxyXG4gKiBSZXNvbHZlIGEgc2luZ2xlIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZhY3RvcnkocHJvdmlkZXIpIHtcclxuICAgIHZhciBmYWN0b3J5Rm47XHJcbiAgICB2YXIgcmVzb2x2ZWREZXBzO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XHJcbiAgICAgICAgdmFyIHVzZUNsYXNzID0gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci51c2VDbGFzcyk7XHJcbiAgICAgICAgZmFjdG9yeUZuID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5mYWN0b3J5KHVzZUNsYXNzKTtcclxuICAgICAgICByZXNvbHZlZERlcHMgPSBfZGVwZW5kZW5jaWVzRm9yKHVzZUNsYXNzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlRXhpc3RpbmcpKSB7XHJcbiAgICAgICAgZmFjdG9yeUZuID0gZnVuY3Rpb24gKGFsaWFzSW5zdGFuY2UpIHsgcmV0dXJuIGFsaWFzSW5zdGFuY2U7IH07XHJcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gW0RlcGVuZGVuY3kuZnJvbUtleShrZXlfMS5LZXkuZ2V0KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlci51c2VGYWN0b3J5KSkge1xyXG4gICAgICAgIGZhY3RvcnlGbiA9IHByb3ZpZGVyLnVzZUZhY3Rvcnk7XHJcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gX2NvbnN0cnVjdERlcGVuZGVuY2llcyhwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXIudXNlVmFsdWU7IH07XHJcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gX0VNUFRZX0xJU1Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlc29sdmVkRmFjdG9yeShmYWN0b3J5Rm4sIHJlc29sdmVkRGVwcyk7XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZlRmFjdG9yeSA9IHJlc29sdmVGYWN0b3J5O1xyXG4vKipcclxuICogQ29udmVydHMgdGhlIHtAbGluayBQcm92aWRlcn0gaW50byB7QGxpbmsgUmVzb2x2ZWRQcm92aWRlcn0uXHJcbiAqXHJcbiAqIHtAbGluayBJbmplY3Rvcn0gaW50ZXJuYWxseSBvbmx5IHVzZXMge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9LCB7QGxpbmsgUHJvdmlkZXJ9IGNvbnRhaW5zXHJcbiAqIGNvbnZlbmllbmNlIHByb3ZpZGVyIHN5bnRheC5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlcihwcm92aWRlcikge1xyXG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlZFByb3ZpZGVyXyhrZXlfMS5LZXkuZ2V0KHByb3ZpZGVyLnRva2VuKSwgW3Jlc29sdmVGYWN0b3J5KHByb3ZpZGVyKV0sIGZhbHNlKTtcclxufVxyXG5leHBvcnRzLnJlc29sdmVQcm92aWRlciA9IHJlc29sdmVQcm92aWRlcjtcclxuLyoqXHJcbiAqIFJlc29sdmUgYSBsaXN0IG9mIFByb3ZpZGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlcnMocHJvdmlkZXJzKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IF9jcmVhdGVMaXN0T2ZQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIG5ldyBNYXAoKSkpO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQubWFwKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBfTm9ybWFsaXplZFByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQcm92aWRlcl8oYi5rZXksIFtiLnJlc29sdmVkRmFjdG9yeV0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUHJvdmlkZXJfKGFyclswXS5rZXksIGFyci5tYXAoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF8ucmVzb2x2ZWRGYWN0b3J5OyB9KSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZlUHJvdmlkZXJzID0gcmVzb2x2ZVByb3ZpZGVycztcclxuLyoqXHJcbiAqIFRoZSBhbGdvcml0aG0gd29ya3MgYXMgZm9sbG93czpcclxuICpcclxuICogW1Byb3ZpZGVyXSAtPiBbX05vcm1hbGl6ZWRQcm92aWRlcnxbX05vcm1hbGl6ZWRQcm92aWRlcl1dIC0+IFtSZXNvbHZlZFByb3ZpZGVyXVxyXG4gKlxyXG4gKiBfTm9ybWFsaXplZFByb3ZpZGVyIGlzIGVzc2VudGlhbGx5IGEgcmVzb2x2ZWQgcHJvdmlkZXIgYmVmb3JlIGl0IHdhcyBncm91cGVkIGJ5IGtleS5cclxuICovXHJcbnZhciBfTm9ybWFsaXplZFByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9Ob3JtYWxpemVkUHJvdmlkZXIoa2V5LCByZXNvbHZlZEZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnJlc29sdmVkRmFjdG9yeSA9IHJlc29sdmVkRmFjdG9yeTtcclxuICAgIH1cclxuICAgIHJldHVybiBfTm9ybWFsaXplZFByb3ZpZGVyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBfY3JlYXRlTGlzdE9mUHJvdmlkZXJzKGZsYXR0ZW5lZFByb3ZpZGVycykge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5NYXBXcmFwcGVyLnZhbHVlcyhmbGF0dGVuZWRQcm92aWRlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCByZXMpIHtcclxuICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBsYW5nXzEuVHlwZSkge1xyXG4gICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXIocHJvdmlkZShiLCB7IHVzZUNsYXNzOiBiIH0pLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVyKGIsIHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKGIsIHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBQcm92aWRlckJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5JbnZhbGlkUHJvdmlkZXJFcnJvcihiLnRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuSW52YWxpZFByb3ZpZGVyRXJyb3IoYik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIF9ub3JtYWxpemVQcm92aWRlcihiLCByZXMpIHtcclxuICAgIHZhciBrZXkgPSBrZXlfMS5LZXkuZ2V0KGIudG9rZW4pO1xyXG4gICAgdmFyIGZhY3RvcnkgPSByZXNvbHZlRmFjdG9yeShiKTtcclxuICAgIHZhciBub3JtYWxpemVkID0gbmV3IF9Ob3JtYWxpemVkUHJvdmlkZXIoa2V5LCBmYWN0b3J5KTtcclxuICAgIGlmIChiLm11bHRpKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nUHJvdmlkZXIgPSByZXMuZ2V0KGtleS5pZCk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvdmlkZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBleGlzdGluZ1Byb3ZpZGVyLnB1c2gobm9ybWFsaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0JsYW5rKGV4aXN0aW5nUHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgIHJlcy5zZXQoa2V5LmlkLCBbbm9ybWFsaXplZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5NaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IoZXhpc3RpbmdQcm92aWRlciwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nUHJvdmlkZXIgPSByZXMuZ2V0KGtleS5pZCk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvdmlkZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18yLk1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihleGlzdGluZ1Byb3ZpZGVyLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzLnNldChrZXkuaWQsIG5vcm1hbGl6ZWQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9jb25zdHJ1Y3REZXBlbmRlbmNpZXMoZmFjdG9yeUZ1bmN0aW9uLCBkZXBlbmRlbmNpZXMpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhkZXBlbmRlbmNpZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IoZmFjdG9yeUZ1bmN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBbdF07IH0pO1xyXG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZXh0cmFjdFRva2VuKGZhY3RvcnlGdW5jdGlvbiwgdCwgcGFyYW1zKTsgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2RlcGVuZGVuY2llc0Zvcih0eXBlT3JGdW5jKSB7XHJcbiAgICB2YXIgcGFyYW1zID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpO1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtcykpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgaWYgKGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5hbnkocGFyYW1zLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbGFuZ18xLmlzQmxhbmsocCk7IH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMi5Ob0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgcCwgcGFyYW1zKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCBtZXRhZGF0YSAvKmFueVtdIHwgYW55Ki8sIHBhcmFtcykge1xyXG4gICAgdmFyIGRlcFByb3BzID0gW107XHJcbiAgICB2YXIgdG9rZW4gPSBudWxsO1xyXG4gICAgdmFyIG9wdGlvbmFsID0gZmFsc2U7XHJcbiAgICBpZiAoIWxhbmdfMS5pc0FycmF5KG1ldGFkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YSwgb3B0aW9uYWwsIG51bGwsIG51bGwsIGRlcFByb3BzKTtcclxuICAgIH1cclxuICAgIHZhciBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XHJcbiAgICB2YXIgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBwYXJhbU1ldGFkYXRhID0gbWV0YWRhdGFbaV07XHJcbiAgICAgICAgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBsYW5nXzEuVHlwZSkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkluamVjdE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRva2VuID0gcGFyYW1NZXRhZGF0YS50b2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuT3B0aW9uYWxNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLlNlbGZNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkhvc3RNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLlNraXBTZWxmTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5EZXBlbmRlbmN5TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyYW1NZXRhZGF0YS50b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1NZXRhZGF0YS50b2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXBQcm9wcy5wdXNoKHBhcmFtTWV0YWRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRva2VuID0gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0b2tlbikpIHtcclxuICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4sIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpIHtcclxuICAgIHJldHVybiBuZXcgRGVwZW5kZW5jeShrZXlfMS5LZXkuZ2V0KHRva2VuKSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogVHlwZSBsaXRlcmFscyBpcyBhIERhcnQtb25seSBmZWF0dXJlLiBUaGlzIGlzIGhlcmUgb25seSBzbyB3ZSBjYW4geC1jb21waWxlXHJcbiAqIHRvIG11bHRpcGxlIGxhbmd1YWdlcy5cclxuICovXHJcbnZhciBUeXBlTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUeXBlTGl0ZXJhbCgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlTGl0ZXJhbC5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIlR5cGUgbGl0ZXJhbHMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIERhcnRcIik7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFR5cGVMaXRlcmFsO1xyXG59KSgpO1xyXG5leHBvcnRzLlR5cGVMaXRlcmFsID0gVHlwZUxpdGVyYWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVfbGl0ZXJhbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENvbW1vbiBkaXJlY3RpdmVzIHNoaXBwZWQgd2l0aCBBbmd1bGFyLlxyXG4gKi9cclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBuZ19jbGFzc18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NsYXNzJyk7XHJcbnZhciBuZ19mb3JfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3InKTtcclxudmFyIG5nX2lmXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfaWYnKTtcclxudmFyIG5nX3N0eWxlXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfc3R5bGUnKTtcclxudmFyIG5nX3N3aXRjaF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX3N3aXRjaCcpO1xyXG52YXIgbmdfY2xhc3NfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jbGFzcycpO1xyXG5leHBvcnRzLk5nQ2xhc3MgPSBuZ19jbGFzc18yLk5nQ2xhc3M7XHJcbnZhciBuZ19mb3JfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3InKTtcclxuZXhwb3J0cy5OZ0ZvciA9IG5nX2Zvcl8yLk5nRm9yO1xyXG52YXIgbmdfaWZfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19pZicpO1xyXG5leHBvcnRzLk5nSWYgPSBuZ19pZl8yLk5nSWY7XHJcbnZhciBuZ19zdHlsZV8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX3N0eWxlJyk7XHJcbmV4cG9ydHMuTmdTdHlsZSA9IG5nX3N0eWxlXzIuTmdTdHlsZTtcclxudmFyIG5nX3N3aXRjaF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX3N3aXRjaCcpO1xyXG5leHBvcnRzLk5nU3dpdGNoID0gbmdfc3dpdGNoXzIuTmdTd2l0Y2g7XHJcbmV4cG9ydHMuTmdTd2l0Y2hXaGVuID0gbmdfc3dpdGNoXzIuTmdTd2l0Y2hXaGVuO1xyXG5leHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IG5nX3N3aXRjaF8yLk5nU3dpdGNoRGVmYXVsdDtcclxuX19leHBvcnQocmVxdWlyZSgnLi9kaXJlY3RpdmVzL29ic2VydmFibGVfbGlzdF9kaWZmJykpO1xyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgY29yZSBkaXJlY3RpdmVzIHRoYXQgYXJlIGxpa2VseSB0byBiZSB1c2VkIGluIGVhY2ggYW5kIGV2ZXJ5IEFuZ3VsYXJcclxuICogYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIFRoaXMgY29sbGVjdGlvbiBjYW4gYmUgdXNlZCB0byBxdWlja2x5IGVudW1lcmF0ZSBhbGwgdGhlIGJ1aWx0LWluIGRpcmVjdGl2ZXMgaW4gdGhlIGBkaXJlY3RpdmVzYFxyXG4gKiBwcm9wZXJ0eSBvZiB0aGUgYEBWaWV3YCBhbm5vdGF0aW9uLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveWFrR3dwQ2RVa2cwcWZ6WDVtOGc/cD1wcmV2aWV3KSlcclxuICpcclxuICogSW5zdGVhZCBvZiB3cml0aW5nOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7TmdDbGFzcywgTmdJZiwgTmdGb3IsIE5nU3dpdGNoLCBOZ1N3aXRjaFdoZW4sIE5nU3dpdGNoRGVmYXVsdH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge090aGVyRGlyZWN0aXZlfSBmcm9tICcuL215RGlyZWN0aXZlcyc7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcclxuICogICB0ZW1wbGF0ZVVybDogJ215Q29tcG9uZW50Lmh0bWwnLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtOZ0NsYXNzLCBOZ0lmLCBOZ0ZvciwgTmdTd2l0Y2gsIE5nU3dpdGNoV2hlbiwgTmdTd2l0Y2hEZWZhdWx0LCBPdGhlckRpcmVjdGl2ZV1cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcclxuICogICAuLi5cclxuICogfVxyXG4gKiBgYGBcclxuICogb25lIGNvdWxkIGltcG9ydCBhbGwgdGhlIGNvcmUgZGlyZWN0aXZlcyBhdCBvbmNlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q09SRV9ESVJFQ1RJVkVTfSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7T3RoZXJEaXJlY3RpdmV9IGZyb20gJy4vbXlEaXJlY3RpdmVzJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxyXG4gKiAgIHRlbXBsYXRlVXJsOiAnbXlDb21wb25lbnQuaHRtbCcsXHJcbiAqICAgZGlyZWN0aXZlczogW0NPUkVfRElSRUNUSVZFUywgT3RoZXJEaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCB7XHJcbiAqICAgLi4uXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkNPUkVfRElSRUNUSVZFUyA9IGxhbmdfMS5DT05TVF9FWFBSKFtuZ19jbGFzc18xLk5nQ2xhc3MsIG5nX2Zvcl8xLk5nRm9yLCBuZ19pZl8xLk5nSWYsIG5nX3N0eWxlXzEuTmdTdHlsZSwgbmdfc3dpdGNoXzEuTmdTd2l0Y2gsIG5nX3N3aXRjaF8xLk5nU3dpdGNoV2hlbiwgbmdfc3dpdGNoXzEuTmdTd2l0Y2hEZWZhdWx0XSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgcmVuZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXInKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbi8qKlxyXG4gKiBUaGUgYE5nQ2xhc3NgIGRpcmVjdGl2ZSBjb25kaXRpb25hbGx5IGFkZHMgYW5kIHJlbW92ZXMgQ1NTIGNsYXNzZXMgb24gYW4gSFRNTCBlbGVtZW50IGJhc2VkIG9uXHJcbiAqIGFuIGV4cHJlc3Npb24ncyBldmFsdWF0aW9uIHJlc3VsdC5cclxuICpcclxuICogVGhlIHJlc3VsdCBvZiBhbiBleHByZXNzaW9uIGV2YWx1YXRpb24gaXMgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHR5cGUgb2ZcclxuICogdGhlIGV4cHJlc3Npb24gZXZhbHVhdGlvbiByZXN1bHQ6XHJcbiAqIC0gYHN0cmluZ2AgLSBhbGwgdGhlIENTUyBjbGFzc2VzIGxpc3RlZCBpbiBhIHN0cmluZyAoc3BhY2UgZGVsaW1pdGVkKSBhcmUgYWRkZWRcclxuICogLSBgQXJyYXlgIC0gYWxsIHRoZSBDU1MgY2xhc3NlcyAoQXJyYXkgZWxlbWVudHMpIGFyZSBhZGRlZFxyXG4gKiAtIGBPYmplY3RgIC0gZWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBDU1MgY2xhc3MgbmFtZSB3aGlsZSB2YWx1ZXMgYXJlIGludGVycHJldGVkIGFzIGV4cHJlc3Npb25zXHJcbiAqIGV2YWx1YXRpbmcgdG8gYEJvb2xlYW5gLiBJZiBhIGdpdmVuIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCBhIGNvcnJlc3BvbmRpbmcgQ1NTIGNsYXNzXHJcbiAqIGlzIGFkZGVkIC0gb3RoZXJ3aXNlIGl0IGlzIHJlbW92ZWQuXHJcbiAqXHJcbiAqIFdoaWxlIHRoZSBgTmdDbGFzc2AgZGlyZWN0aXZlIGNhbiBpbnRlcnByZXQgZXhwcmVzc2lvbnMgZXZhbHVhdGluZyB0byBgc3RyaW5nYCwgYEFycmF5YFxyXG4gKiBvciBgT2JqZWN0YCwgdGhlIGBPYmplY3RgLWJhc2VkIHZlcnNpb24gaXMgdGhlIG1vc3Qgb2Z0ZW4gdXNlZCBhbmQgaGFzIGFuIGFkdmFudGFnZSBvZiBrZWVwaW5nXHJcbiAqIGFsbCB0aGUgQ1NTIGNsYXNzIG5hbWVzIGluIGEgdGVtcGxhdGUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9hNFlkdG1XeXdoSjMzdXFmcFBQbj9wPXByZXZpZXcpKTpcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50LCBOZ0NsYXNzfSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAndG9nZ2xlLWJ1dHRvbicsXHJcbiAqICAgaW5wdXRzOiBbJ2lzRGlzYWJsZWQnXSxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25cIiBbbmctY2xhc3NdPVwie2FjdGl2ZTogaXNPbiwgZGlzYWJsZWQ6IGlzRGlzYWJsZWR9XCJcclxuICogICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSghaXNPbilcIj5cclxuICogICAgICAgICAgQ2xpY2sgbWUhXHJcbiAqICAgICAgPC9kaXY+YCxcclxuICogICBzdHlsZXM6IFtgXHJcbiAqICAgICAuYnV0dG9uIHtcclxuICogICAgICAgd2lkdGg6IDEyMHB4O1xyXG4gKiAgICAgICBib3JkZXI6IG1lZGl1bSBzb2xpZCBibGFjaztcclxuICogICAgIH1cclxuICpcclxuICogICAgIC5hY3RpdmUge1xyXG4gKiAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XHJcbiAqICAgIH1cclxuICpcclxuICogICAgIC5kaXNhYmxlZCB7XHJcbiAqICAgICAgIGNvbG9yOiBncmF5O1xyXG4gKiAgICAgICBib3JkZXI6IG1lZGl1bSBzb2xpZCBncmF5O1xyXG4gKiAgICAgfVxyXG4gKiAgIGBdXHJcbiAqICAgZGlyZWN0aXZlczogW05nQ2xhc3NdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFRvZ2dsZUJ1dHRvbiB7XHJcbiAqICAgaXNPbiA9IGZhbHNlO1xyXG4gKiAgIGlzRGlzYWJsZWQgPSBmYWxzZTtcclxuICpcclxuICogICB0b2dnbGUobmV3U3RhdGUpIHtcclxuICogICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKSB7XHJcbiAqICAgICAgIHRoaXMuaXNPbiA9IG5ld1N0YXRlO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBOZ0NsYXNzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nQ2xhc3MoX2l0ZXJhYmxlRGlmZmVycywgX2tleVZhbHVlRGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXJzID0gX2tleVZhbHVlRGlmZmVycztcclxuICAgICAgICB0aGlzLl9uZ0VsID0gX25nRWw7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NsYXNzLnByb3RvdHlwZSwgXCJpbml0aWFsQ2xhc3Nlc1wiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IGxhbmdfMS5pc1ByZXNlbnQodikgJiYgbGFuZ18xLmlzU3RyaW5nKHYpID8gdi5zcGxpdCgnICcpIDogW107XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5fcmF3Q2xhc3MsIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NsYXNzLnByb3RvdHlwZSwgXCJyYXdDbGFzc1wiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xhc3Nlcyh0aGlzLl9yYXdDbGFzcyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcodikpIHtcclxuICAgICAgICAgICAgICAgIHYgPSB2LnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmF3Q2xhc3MgPSB2O1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUodikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9pdGVyYWJsZURpZmZlcnMuZmluZCh2KS5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9ICdpdGVyYWJsZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9rZXlWYWx1ZURpZmZlcnMuZmluZCh2KS5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9ICdrZXlWYWx1ZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5kb0NoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RpZmZlcikpIHtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoYW5nZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSAnaXRlcmFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJdGVyYWJsZUNoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUtleVZhbHVlQ2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NsZWFudXBDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzKTsgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9jbGVhbnVwQ2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGx5Q2xhc3NlcyhyYXdDbGFzc1ZhbCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcyhmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5SXRlcmFibGVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgdHJ1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5pdGVtLCBmYWxzZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUluaXRpYWxDbGFzc2VzID0gZnVuY3Rpb24gKGlzQ2xlYW51cCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5Q2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCwgaXNDbGVhbnVwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChyYXdDbGFzc1ZhbCkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUocmF3Q2xhc3NWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICByYXdDbGFzc1ZhbC5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhjbGFzc05hbWUsICFpc0NsZWFudXApOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gocmF3Q2xhc3NWYWwsIGZ1bmN0aW9uIChleHBWYWwsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhjbGFzc05hbWUsICFpc0NsZWFudXApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdDbGFzcy5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZW5hYmxlZCkge1xyXG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS50cmltKCk7XHJcbiAgICAgICAgaWYgKGNsYXNzTmFtZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9uZ0VsLCBjbGFzc05hbWUsIGVuYWJsZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ0NsYXNzID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuZy1jbGFzc10nLCBpbnB1dHM6IFsncmF3Q2xhc3M6IG5nLWNsYXNzJywgJ2luaXRpYWxDbGFzc2VzOiBjbGFzcyddIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjaGFuZ2VfZGV0ZWN0aW9uXzEuSXRlcmFibGVEaWZmZXJzLCBjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzLCBsaW5rZXJfMS5FbGVtZW50UmVmLCByZW5kZXJfMS5SZW5kZXJlcl0pXHJcbiAgICBdLCBOZ0NsYXNzKTtcclxuICAgIHJldHVybiBOZ0NsYXNzO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nQ2xhc3MgPSBOZ0NsYXNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19jbGFzcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBUaGUgYE5nRm9yYCBkaXJlY3RpdmUgaW5zdGFudGlhdGVzIGEgdGVtcGxhdGUgb25jZSBwZXIgaXRlbSBmcm9tIGFuIGl0ZXJhYmxlLiBUaGUgY29udGV4dCBmb3JcclxuICogZWFjaCBpbnN0YW50aWF0ZWQgdGVtcGxhdGUgaW5oZXJpdHMgZnJvbSB0aGUgb3V0ZXIgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBsb29wIHZhcmlhYmxlIHNldFxyXG4gKiB0byB0aGUgY3VycmVudCBpdGVtIGZyb20gdGhlIGl0ZXJhYmxlLlxyXG4gKlxyXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhbGlhcyB0aGUgYGluZGV4YCB0byBhIGxvY2FsIHZhcmlhYmxlIHRoYXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgbG9vcFxyXG4gKiBpdGVyYXRpb24gaW4gdGhlIHRlbXBsYXRlIGNvbnRleHQsIGFuZCBhbHNvIHRvIGFsaWFzIHRoZSAnbGFzdCcgdG8gYSBsb2NhbCB2YXJpYWJsZSB0aGF0IHdpbGxcclxuICogYmUgc2V0IHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBpdGVtIGlzIHRoZSBsYXN0IG9uZSBpbiB0aGUgaXRlcmF0aW9uXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBpdGVyYXRvciBjaGFuZ2VzLCBgTmdGb3JgIG1ha2VzIHRoZSBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdG8gdGhlIERPTTpcclxuICpcclxuICogKiBXaGVuIGFuIGl0ZW0gaXMgYWRkZWQsIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBpcyBhZGRlZCB0byB0aGUgRE9NLlxyXG4gKiAqIFdoZW4gYW4gaXRlbSBpcyByZW1vdmVkLCBpdHMgdGVtcGxhdGUgaW5zdGFuY2UgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXHJcbiAqICogV2hlbiBpdGVtcyBhcmUgcmVvcmRlcmVkLCB0aGVpciByZXNwZWN0aXZlIHRlbXBsYXRlcyBhcmUgcmVvcmRlcmVkIGluIHRoZSBET00uXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPHVsPlxyXG4gKiAgIDxsaSAqbmctZm9yPVwiI2Vycm9yIG9mIGVycm9yczsgI2kgPSBpbmRleFwiPlxyXG4gKiAgICAgRXJyb3Ige3tpfX0gb2Yge3tlcnJvcnMubGVuZ3RofX06IHt7ZXJyb3IubWVzc2FnZX19XHJcbiAqICAgPC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqICMgU3ludGF4XHJcbiAqXHJcbiAqIC0gYDxsaSAqbmctZm9yPVwiI2l0ZW0gb2YgaXRlbXM7ICNpID0gaW5kZXhcIj4uLi48L2xpPmBcclxuICogLSBgPGxpIHRlbXBsYXRlPVwibmctZm9yICNpdGVtIG9mIGl0ZW1zOyAjaSA9IGluZGV4XCI+Li4uPC9saT5gXHJcbiAqIC0gYDx0ZW1wbGF0ZSBuZy1mb3IgI2l0ZW0gW25nLWZvci1vZl09XCJpdGVtc1wiICNpPVwiaW5kZXhcIj48bGk+Li4uPC9saT48L3RlbXBsYXRlPmBcclxuICovXHJcbnZhciBOZ0ZvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ0Zvcihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlUmVmLCBfaXRlcmFibGVEaWZmZXJzLCBfY2RyKSB7XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lciA9IF92aWV3Q29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xyXG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5fY2RyID0gX2NkcjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvci5wcm90b3R5cGUsIFwibmdGb3JPZlwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmdGb3JPZiA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fZGlmZmVyKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodmFsdWUpLmNyZWF0ZSh0aGlzLl9jZHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3IucHJvdG90eXBlLCBcIm5nRm9yVGVtcGxhdGVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3RlbXBsYXRlUmVmID0gdmFsdWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdGb3IucHJvdG90eXBlLmRvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZGlmZmVyKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuX25nRm9yT2YpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGFuZ2VzKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdGb3IucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIC8vIFRPRE8ocmFkbyk6IGNoZWNrIGlmIGNoYW5nZSBkZXRlY3Rpb24gY2FuIHByb2R1Y2UgYSBjaGFuZ2UgcmVjb3JkIHRoYXQgaXNcclxuICAgICAgICAvLyBlYXNpZXIgdG8gY29uc3VtZSB0aGFuIGN1cnJlbnQuXHJcbiAgICAgICAgdmFyIHJlY29yZFZpZXdUdXBsZXMgPSBbXTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVtb3ZlZFJlY29yZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkVmlld1R1cGxlcy5wdXNoKG5ldyBSZWNvcmRWaWV3VHVwbGUocmVtb3ZlZFJlY29yZCwgbnVsbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaE1vdmVkSXRlbShmdW5jdGlvbiAobW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZFZpZXdUdXBsZXMucHVzaChuZXcgUmVjb3JkVmlld1R1cGxlKG1vdmVkUmVjb3JkLCBudWxsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGluc2VydFR1cGxlcyA9IHRoaXMuX2J1bGtSZW1vdmUocmVjb3JkVmlld1R1cGxlcyk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChhZGRlZFJlY29yZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0VHVwbGVzLnB1c2gobmV3IFJlY29yZFZpZXdUdXBsZShhZGRlZFJlY29yZCwgbnVsbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2J1bGtJbnNlcnQoaW5zZXJ0VHVwbGVzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydFR1cGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJWaWV3Q2hhbmdlKGluc2VydFR1cGxlc1tpXS52aWV3LCBpbnNlcnRUdXBsZXNbaV0ucmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmdldChpKS5zZXRMb2NhbCgnbGFzdCcsIGkgPT09IGlsZW4gLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdGb3IucHJvdG90eXBlLl9wZXJWaWV3Q2hhbmdlID0gZnVuY3Rpb24gKHZpZXcsIHJlY29yZCkge1xyXG4gICAgICAgIHZpZXcuc2V0TG9jYWwoJ1xcJGltcGxpY2l0JywgcmVjb3JkLml0ZW0pO1xyXG4gICAgICAgIHZpZXcuc2V0TG9jYWwoJ2luZGV4JywgcmVjb3JkLmN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgdmlldy5zZXRMb2NhbCgnZXZlbicsIChyZWNvcmQuY3VycmVudEluZGV4ICUgMiA9PSAwKSk7XHJcbiAgICAgICAgdmlldy5zZXRMb2NhbCgnb2RkJywgKHJlY29yZC5jdXJyZW50SW5kZXggJSAyID09IDEpKTtcclxuICAgIH07XHJcbiAgICBOZ0Zvci5wcm90b3R5cGUuX2J1bGtSZW1vdmUgPSBmdW5jdGlvbiAodHVwbGVzKSB7XHJcbiAgICAgICAgdHVwbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucmVjb3JkLnByZXZpb3VzSW5kZXggLSBiLnJlY29yZC5wcmV2aW91c0luZGV4OyB9KTtcclxuICAgICAgICB2YXIgbW92ZWRUdXBsZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gdHVwbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciB0dXBsZSA9IHR1cGxlc1tpXTtcclxuICAgICAgICAgICAgLy8gc2VwYXJhdGUgbW92ZWQgdmlld3MgZnJvbSByZW1vdmVkIHZpZXdzLlxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0dXBsZS5yZWNvcmQuY3VycmVudEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgdHVwbGUudmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXIuZGV0YWNoKHR1cGxlLnJlY29yZC5wcmV2aW91c0luZGV4KTtcclxuICAgICAgICAgICAgICAgIG1vdmVkVHVwbGVzLnB1c2godHVwbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5yZW1vdmUodHVwbGUucmVjb3JkLnByZXZpb3VzSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb3ZlZFR1cGxlcztcclxuICAgIH07XHJcbiAgICBOZ0Zvci5wcm90b3R5cGUuX2J1bGtJbnNlcnQgPSBmdW5jdGlvbiAodHVwbGVzKSB7XHJcbiAgICAgICAgdHVwbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEucmVjb3JkLmN1cnJlbnRJbmRleCAtIGIucmVjb3JkLmN1cnJlbnRJbmRleDsgfSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0dXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHR1cGxlID0gdHVwbGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0dXBsZS52aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5pbnNlcnQodHVwbGUudmlldywgdHVwbGUucmVjb3JkLmN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0dXBsZS52aWV3ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZiwgdHVwbGUucmVjb3JkLmN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR1cGxlcztcclxuICAgIH07XHJcbiAgICBOZ0ZvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctZm9yXVtuZy1mb3Itb2ZdJywgaW5wdXRzOiBbJ25nRm9yT2YnLCAnbmdGb3JUZW1wbGF0ZSddIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtsaW5rZXJfMS5WaWV3Q29udGFpbmVyUmVmLCBsaW5rZXJfMS5UZW1wbGF0ZVJlZiwgY2hhbmdlX2RldGVjdGlvbl8xLkl0ZXJhYmxlRGlmZmVycywgY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yUmVmXSlcclxuICAgIF0sIE5nRm9yKTtcclxuICAgIHJldHVybiBOZ0ZvcjtcclxufSkoKTtcclxuZXhwb3J0cy5OZ0ZvciA9IE5nRm9yO1xyXG52YXIgUmVjb3JkVmlld1R1cGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlY29yZFZpZXdUdXBsZShyZWNvcmQsIHZpZXcpIHtcclxuICAgICAgICB0aGlzLnJlY29yZCA9IHJlY29yZDtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlY29yZFZpZXdUdXBsZTtcclxufSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfZm9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFJlbW92ZXMgb3IgcmVjcmVhdGVzIGEgcG9ydGlvbiBvZiB0aGUgRE9NIHRyZWUgYmFzZWQgb24gYW4ge2V4cHJlc3Npb259LlxyXG4gKlxyXG4gKiBJZiB0aGUgZXhwcmVzc2lvbiBhc3NpZ25lZCB0byBgbmctaWZgIGV2YWx1YXRlcyB0byBhIGZhbHNlIHZhbHVlIHRoZW4gdGhlIGVsZW1lbnRcclxuICogaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIG90aGVyd2lzZSBhIGNsb25lIG9mIHRoZSBlbGVtZW50IGlzIHJlaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZmUwa2dlbUZCdG1RT1kzMWI0dHc/cD1wcmV2aWV3KSk6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZGl2ICpuZy1pZj1cImVycm9yQ291bnQgPiAwXCIgY2xhc3M9XCJlcnJvclwiPlxyXG4gKiAgIDwhLS0gRXJyb3IgbWVzc2FnZSBkaXNwbGF5ZWQgd2hlbiB0aGUgZXJyb3JDb3VudCBwcm9wZXJ0eSBvbiB0aGUgY3VycmVudCBjb250ZXh0IGlzIGdyZWF0ZXJcclxuICogdGhhbiAwLiAtLT5cclxuICogICB7e2Vycm9yQ291bnR9fSBlcnJvcnMgZGV0ZWN0ZWRcclxuICogPC9kaXY+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIFN5bnRheFxyXG4gKlxyXG4gKiAtIGA8ZGl2ICpuZy1pZj1cImNvbmRpdGlvblwiPi4uLjwvZGl2PmBcclxuICogLSBgPGRpdiB0ZW1wbGF0ZT1cIm5nLWlmIGNvbmRpdGlvblwiPi4uLjwvZGl2PmBcclxuICogLSBgPHRlbXBsYXRlIFtuZy1pZl09XCJjb25kaXRpb25cIj48ZGl2Pi4uLjwvZGl2PjwvdGVtcGxhdGU+YFxyXG4gKi9cclxudmFyIE5nSWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdJZihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lciA9IF92aWV3Q29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xyXG4gICAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nSWYucHJvdG90eXBlLCBcIm5nSWZcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NvbmRpdGlvbiAvKiBib29sZWFuICovKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDb25kaXRpb24gJiYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX3ByZXZDb25kaXRpb24pIHx8ICF0aGlzLl9wcmV2Q29uZGl0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkNvbmRpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW5ld0NvbmRpdGlvbiAmJiAobGFuZ18xLmlzQmxhbmsodGhpcy5fcHJldkNvbmRpdGlvbikgfHwgdGhpcy5fcHJldkNvbmRpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdJZiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctaWZdJywgaW5wdXRzOiBbJ25nSWYnXSB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbGlua2VyXzEuVmlld0NvbnRhaW5lclJlZiwgbGlua2VyXzEuVGVtcGxhdGVSZWZdKVxyXG4gICAgXSwgTmdJZik7XHJcbiAgICByZXR1cm4gTmdJZjtcclxufSkoKTtcclxuZXhwb3J0cy5OZ0lmID0gTmdJZjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfaWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFRoZSBgTmdTdHlsZWAgZGlyZWN0aXZlIGNoYW5nZXMgc3R5bGVzIGJhc2VkIG9uIGEgcmVzdWx0IG9mIGV4cHJlc3Npb24gZXZhbHVhdGlvbi5cclxuICpcclxuICogQW4gZXhwcmVzc2lvbiBhc3NpZ25lZCB0byB0aGUgYG5nLXN0eWxlYCBwcm9wZXJ0eSBtdXN0IGV2YWx1YXRlIHRvIGFuIG9iamVjdCBhbmQgdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBzdHlsZXMgYXJlIHVwZGF0ZWQgYmFzZWQgb24gY2hhbmdlcyB0byB0aGlzIG9iamVjdC4gU3R5bGUgbmFtZXMgdG8gdXBkYXRlXHJcbiAqIGFyZSB0YWtlbiBmcm9tIHRoZSBvYmplY3QncyBrZXlzLCBhbmQgdmFsdWVzIC0gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBvYmplY3QncyB2YWx1ZXMuXHJcbiAqXHJcbiAqICMgU3ludGF4XHJcbiAqXHJcbiAqIC0gYDxkaXYgW25nLXN0eWxlXT1cInsnZm9udC1zdHlsZSc6IHN0eWxlfVwiPjwvZGl2PmBcclxuICogLSBgPGRpdiBbbmctc3R5bGVdPVwic3R5bGVFeHBcIj48L2Rpdj5gIC0gaGVyZSB0aGUgYHN0eWxlRXhwYCBtdXN0IGV2YWx1YXRlIHRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWWFtR1M2R2tVaDlHcVdOUWhDeU0/cD1wcmV2aWV3KSk6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgTmdTdHlsZX0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbmctc3R5bGUtZXhhbXBsZScsXHJcbiAqICB0ZW1wbGF0ZTogYFxyXG4gKiAgICA8aDEgW25nLXN0eWxlXT1cInsnZm9udC1zdHlsZSc6IHN0eWxlLCAnZm9udC1zaXplJzogc2l6ZSwgJ2ZvbnQtd2VpZ2h0Jzogd2VpZ2h0fVwiPlxyXG4gKiAgICAgIENoYW5nZSBzdHlsZSBvZiB0aGlzIHRleHQhXHJcbiAqICAgIDwvaDE+XHJcbiAqXHJcbiAqICAgIDxocj5cclxuICpcclxuICogICAgPGxhYmVsPkl0YWxpYzogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIChjaGFuZ2UpPVwiY2hhbmdlU3R5bGUoJGV2ZW50KVwiPjwvbGFiZWw+XHJcbiAqICAgIDxsYWJlbD5Cb2xkOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgKGNoYW5nZSk9XCJjaGFuZ2VXZWlnaHQoJGV2ZW50KVwiPjwvbGFiZWw+XHJcbiAqICAgIDxsYWJlbD5TaXplOiA8aW5wdXQgdHlwZT1cInRleHRcIiBbdmFsdWVdPVwic2l6ZVwiIChjaGFuZ2UpPVwic2l6ZSA9ICRldmVudC50YXJnZXQudmFsdWVcIj48L2xhYmVsPlxyXG4gKiAgYCxcclxuICogIGRpcmVjdGl2ZXM6IFtOZ1N0eWxlXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgTmdTdHlsZUV4YW1wbGUge1xyXG4gKiAgICBzdHlsZSA9ICdub3JtYWwnO1xyXG4gKiAgICB3ZWlnaHQgPSAnbm9ybWFsJztcclxuICogICAgc2l6ZSA9ICcyMHB4JztcclxuICpcclxuICogICAgY2hhbmdlU3R5bGUoJGV2ZW50OiBhbnkpIHtcclxuICogICAgICB0aGlzLnN0eWxlID0gJGV2ZW50LnRhcmdldC5jaGVja2VkID8gJ2l0YWxpYycgOiAnbm9ybWFsJztcclxuICogICAgfVxyXG4gKlxyXG4gKiAgICBjaGFuZ2VXZWlnaHQoJGV2ZW50OiBhbnkpIHtcclxuICogICAgICB0aGlzLndlaWdodCA9ICRldmVudC50YXJnZXQuY2hlY2tlZCA/ICdib2xkJyA6ICdub3JtYWwnO1xyXG4gKiAgICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSB0aGUgYGZvbnQtc3R5bGVgLCBgZm9udC1zaXplYCBhbmQgYGZvbnQtd2VpZ2h0YCBzdHlsZXMgd2lsbCBiZSB1cGRhdGVkXHJcbiAqIGJhc2VkIG9uIHRoZSBgc3R5bGVgIHByb3BlcnR5J3MgdmFsdWUgY2hhbmdlcy5cclxuICovXHJcbnZhciBOZ1N0eWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nU3R5bGUoX2RpZmZlcnMsIF9uZ0VsLCBfcmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3R5bGUucHJvdG90eXBlLCBcInJhd1N0eWxlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1N0eWxlID0gdjtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2RpZmZlcikgJiYgbGFuZ18xLmlzUHJlc2VudCh2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHRoaXMuX3Jhd1N0eWxlKS5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nU3R5bGUucHJvdG90eXBlLmRvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZGlmZmVyKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuX3Jhd1N0eWxlKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZ1N0eWxlLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIG51bGwpOyB9KTtcclxuICAgIH07XHJcbiAgICBOZ1N0eWxlLnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX25nRWwsIG5hbWUsIHZhbCk7XHJcbiAgICB9O1xyXG4gICAgTmdTdHlsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctc3R5bGVdJywgaW5wdXRzOiBbJ3Jhd1N0eWxlOiBuZy1zdHlsZSddIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzLCBsaW5rZXJfMS5FbGVtZW50UmVmLCByZW5kZXJfMS5SZW5kZXJlcl0pXHJcbiAgICBdLCBOZ1N0eWxlKTtcclxuICAgIHJldHVybiBOZ1N0eWxlO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nU3R5bGUgPSBOZ1N0eWxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19zdHlsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxpbmtlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIF9XSEVOX0RFRkFVTFQgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgT2JqZWN0KCkpO1xyXG52YXIgU3dpdGNoVmlldyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVSZWYgPSBfdGVtcGxhdGVSZWY7XHJcbiAgICB9XHJcbiAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmKTsgfTtcclxuICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY2xlYXIoKTsgfTtcclxuICAgIHJldHVybiBTd2l0Y2hWaWV3O1xyXG59KSgpO1xyXG5leHBvcnRzLlN3aXRjaFZpZXcgPSBTd2l0Y2hWaWV3O1xyXG4vKipcclxuICogVGhlIGBOZ1N3aXRjaGAgZGlyZWN0aXZlIGlzIHVzZWQgdG8gY29uZGl0aW9uYWxseSBzd2FwIERPTSBzdHJ1Y3R1cmUgb24geW91ciB0ZW1wbGF0ZSBiYXNlZCBvbiBhXHJcbiAqIHNjb3BlIGV4cHJlc3Npb24uXHJcbiAqIEVsZW1lbnRzIHdpdGhpbiBgTmdTd2l0Y2hgIGJ1dCB3aXRob3V0IGBOZ1N3aXRjaFdoZW5gIG9yIGBOZ1N3aXRjaERlZmF1bHRgIGRpcmVjdGl2ZXMgd2lsbCBiZVxyXG4gKiBwcmVzZXJ2ZWQgYXQgdGhlIGxvY2F0aW9uIGFzIHNwZWNpZmllZCBpbiB0aGUgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIGBOZ1N3aXRjaGAgc2ltcGx5IGNob29zZXMgbmVzdGVkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGVtIHZpc2libGUgYmFzZWQgb24gd2hpY2ggZWxlbWVudCBtYXRjaGVzXHJcbiAqIHRoZSB2YWx1ZSBvYnRhaW5lZCBmcm9tIHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbi4gSW4gb3RoZXIgd29yZHMsIHlvdSBkZWZpbmUgYSBjb250YWluZXIgZWxlbWVudFxyXG4gKiAod2hlcmUgeW91IHBsYWNlIHRoZSBkaXJlY3RpdmUpLCBwbGFjZSBhbiBleHByZXNzaW9uIG9uIHRoZSAqKmBbbmctc3dpdGNoXT1cIi4uLlwiYCBhdHRyaWJ1dGUqKiksXHJcbiAqIGRlZmluZSBhbnkgaW5uZXIgZWxlbWVudHMgaW5zaWRlIG9mIHRoZSBkaXJlY3RpdmUgYW5kIHBsYWNlIGEgYFtuZy1zd2l0Y2gtd2hlbl1gIGF0dHJpYnV0ZSBwZXJcclxuICogZWxlbWVudC5cclxuICogVGhlIHdoZW4gYXR0cmlidXRlIGlzIHVzZWQgdG8gaW5mb3JtIE5nU3dpdGNoIHdoaWNoIGVsZW1lbnQgdG8gZGlzcGxheSB3aGVuIHRoZSBleHByZXNzaW9uIGlzXHJcbiAqIGV2YWx1YXRlZC4gSWYgYSBtYXRjaGluZyBleHByZXNzaW9uIGlzIG5vdCBmb3VuZCB2aWEgYSB3aGVuIGF0dHJpYnV0ZSB0aGVuIGFuIGVsZW1lbnQgd2l0aCB0aGVcclxuICogZGVmYXVsdCBhdHRyaWJ1dGUgaXMgZGlzcGxheWVkLlxyXG4gKlxyXG4gKiAjIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8QU5ZIFtuZy1zd2l0Y2hdPVwiZXhwcmVzc2lvblwiPlxyXG4gKiAgIDx0ZW1wbGF0ZSBbbmctc3dpdGNoLXdoZW5dPVwid2hlbkV4cHJlc3Npb24xXCI+Li4uPC90ZW1wbGF0ZT5cclxuICogICA8dGVtcGxhdGUgW25nLXN3aXRjaC13aGVuXT1cIndoZW5FeHByZXNzaW9uMVwiPi4uLjwvdGVtcGxhdGU+XHJcbiAqICAgPHRlbXBsYXRlIG5nLXN3aXRjaC1kZWZhdWx0Pi4uLjwvdGVtcGxhdGU+XHJcbiAqIDwvQU5ZPlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBOZ1N3aXRjaCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ1N3aXRjaCgpIHtcclxuICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVWaWV3cyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1N3aXRjaC5wcm90b3R5cGUsIFwibmdTd2l0Y2hcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBjdXJyZW50bHkgYWN0aXZlIFZpZXdDb250YWluZXJzXHJcbiAgICAgICAgICAgIHRoaXMuX2VtcHR5QWxsQWN0aXZlVmlld3MoKTtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBWaWV3Q29udGFpbmVycyBtYXRjaGluZyB0aGUgdmFsdWUgKHdpdGggYSBmYWxsYmFjayB0byBkZWZhdWx0KVxyXG4gICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZpZXdzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2aWV3cyA9IGxhbmdfMS5ub3JtYWxpemVCbGFuayh0aGlzLl92YWx1ZVZpZXdzLmdldChfV0hFTl9ERUZBVUxUKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3cyh2aWV3cyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX29uV2hlblZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRXaGVuLCBuZXdXaGVuLCB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5fZGVyZWdpc3RlclZpZXcob2xkV2hlbiwgdmlldyk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJWaWV3KG5ld1doZW4sIHZpZXcpO1xyXG4gICAgICAgIGlmIChvbGRXaGVuID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xyXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hY3RpdmVWaWV3cywgdmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1doZW4gPT09IHRoaXMuX3N3aXRjaFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbXB0eUFsbEFjdGl2ZVZpZXdzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmlldy5jcmVhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MucHVzaCh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3dpdGNoIHRvIGRlZmF1bHQgd2hlbiB0aGVyZSBpcyBubyBtb3JlIGFjdGl2ZSBWaWV3Q29udGFpbmVyc1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVWaWV3cy5sZW5ndGggPT09IDAgJiYgIXRoaXMuX3VzZURlZmF1bHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3ModGhpcy5fdmFsdWVWaWV3cy5nZXQoX1dIRU5fREVGQVVMVCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2VtcHR5QWxsQWN0aXZlVmlld3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFjdGl2ZUNvbnRhaW5lcnMgPSB0aGlzLl9hY3RpdmVWaWV3cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWN0aXZlQ29udGFpbmVyc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gW107XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9hY3RpdmF0ZVZpZXdzID0gZnVuY3Rpb24gKHZpZXdzKSB7XHJcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogYXNzZXJ0KHRoaXMuX2FjdGl2ZVZpZXdzLmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmlld3MpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzW2ldLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gdmlld3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fcmVnaXN0ZXJWaWV3ID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3cykpIHtcclxuICAgICAgICAgICAgdmlld3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVWaWV3cy5zZXQodmFsdWUsIHZpZXdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2RlcmVnaXN0ZXJWaWV3ID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XHJcbiAgICAgICAgLy8gYF9XSEVOX0RFRkFVTFRgIGlzIHVzZWQgYSBtYXJrZXIgZm9yIG5vbi1yZWdpc3RlcmVkIHdoZW5zXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBfV0hFTl9ERUZBVUxUKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xyXG4gICAgICAgIGlmICh2aWV3cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVZpZXdzLmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHZpZXdzLCB2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTmdTd2l0Y2ggPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nLXN3aXRjaF0nLCBpbnB1dHM6IFsnbmdTd2l0Y2gnXSB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIE5nU3dpdGNoKTtcclxuICAgIHJldHVybiBOZ1N3aXRjaDtcclxufSkoKTtcclxuZXhwb3J0cy5OZ1N3aXRjaCA9IE5nU3dpdGNoO1xyXG4vKipcclxuICogRGVmaW5lcyBhIGNhc2Ugc3RhdGVtZW50IGFzIGFuIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIElmIG11bHRpcGxlIGBOZ1N3aXRjaFdoZW5gIG1hdGNoIHRoZSBgTmdTd2l0Y2hgIHZhbHVlLCBhbGwgb2YgdGhlbSBhcmUgZGlzcGxheWVkLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogLy8gbWF0Y2ggYWdhaW5zdCBhIGNvbnRleHQgdmFyaWFibGVcclxuICogPHRlbXBsYXRlIFtuZy1zd2l0Y2gtd2hlbl09XCJjb250ZXh0VmFyaWFibGVcIj4uLi48L3RlbXBsYXRlPlxyXG4gKlxyXG4gKiAvLyBtYXRjaCBhZ2FpbnN0IGEgY29uc3RhbnQgc3RyaW5nXHJcbiAqIDx0ZW1wbGF0ZSBuZy1zd2l0Y2gtd2hlbj1cInN0cmluZ1ZhbHVlXCI+Li4uPC90ZW1wbGF0ZT5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgTmdTd2l0Y2hXaGVuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nU3dpdGNoV2hlbih2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgX3N3aXRjaCkge1xyXG4gICAgICAgIHRoaXMuX3N3aXRjaCA9IF9zd2l0Y2g7XHJcbiAgICAgICAgLy8gYF9XSEVOX0RFRkFVTFRgIGlzIHVzZWQgYXMgYSBtYXJrZXIgZm9yIGEgbm90IHlldCBpbml0aWFsaXplZCB2YWx1ZVxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9XSEVOX0RFRkFVTFQ7XHJcbiAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBTd2l0Y2hWaWV3KHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1N3aXRjaFdoZW4ucHJvdG90eXBlLCBcIm5nU3dpdGNoV2hlblwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3dpdGNoLl9vbldoZW5WYWx1ZUNoYW5nZWQodGhpcy5fdmFsdWUsIHZhbHVlLCB0aGlzLl92aWV3KTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nU3dpdGNoV2hlbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmctc3dpdGNoLXdoZW5dJywgaW5wdXRzOiBbJ25nU3dpdGNoV2hlbiddIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgZGlfMS5Ib3N0KCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtsaW5rZXJfMS5WaWV3Q29udGFpbmVyUmVmLCBsaW5rZXJfMS5UZW1wbGF0ZVJlZiwgTmdTd2l0Y2hdKVxyXG4gICAgXSwgTmdTd2l0Y2hXaGVuKTtcclxuICAgIHJldHVybiBOZ1N3aXRjaFdoZW47XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdTd2l0Y2hXaGVuID0gTmdTd2l0Y2hXaGVuO1xyXG4vKipcclxuICogRGVmaW5lcyBhIGRlZmF1bHQgY2FzZSBzdGF0ZW1lbnQuXHJcbiAqXHJcbiAqIERlZmF1bHQgY2FzZSBzdGF0ZW1lbnRzIGFyZSBkaXNwbGF5ZWQgd2hlbiBubyBgTmdTd2l0Y2hXaGVuYCBtYXRjaCB0aGUgYG5nLXN3aXRjaGAgdmFsdWUuXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dGVtcGxhdGUgbmctc3dpdGNoLWRlZmF1bHQ+Li4uPC90ZW1wbGF0ZT5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgTmdTd2l0Y2hEZWZhdWx0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5nU3dpdGNoRGVmYXVsdCh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgc3N3aXRjaCkge1xyXG4gICAgICAgIHNzd2l0Y2guX3JlZ2lzdGVyVmlldyhfV0hFTl9ERUZBVUxULCBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZikpO1xyXG4gICAgfVxyXG4gICAgTmdTd2l0Y2hEZWZhdWx0ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuZy1zd2l0Y2gtZGVmYXVsdF0nIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgZGlfMS5Ib3N0KCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtsaW5rZXJfMS5WaWV3Q29udGFpbmVyUmVmLCBsaW5rZXJfMS5UZW1wbGF0ZVJlZiwgTmdTd2l0Y2hdKVxyXG4gICAgXSwgTmdTd2l0Y2hEZWZhdWx0KTtcclxuICAgIHJldHVybiBOZ1N3aXRjaERlZmF1bHQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdTd2l0Y2hEZWZhdWx0ID0gTmdTd2l0Y2hEZWZhdWx0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19zd2l0Y2guanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFRTIGRvZXMgbm90IGhhdmUgT2JzZXJ2YWJsZXNcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZV9saXN0X2RpZmYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCcuL2RvbV9hZGFwdGVyJyk7XHJcbnZhciBnZW5lcmljX2Jyb3dzZXJfYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9nZW5lcmljX2Jyb3dzZXJfYWRhcHRlcicpO1xyXG52YXIgX2F0dHJUb1Byb3BNYXAgPSB7XHJcbiAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcclxuICAgICdpbm5lckh0bWwnOiAnaW5uZXJIVE1MJyxcclxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXHJcbiAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnXHJcbn07XHJcbnZhciBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDM7XHJcbi8vIE1hcCB0byBjb252ZXJ0IHNvbWUga2V5IG9yIGtleUlkZW50aWZpZXIgdmFsdWVzIHRvIHdoYXQgd2lsbCBiZSByZXR1cm5lZCBieSBnZXRFdmVudEtleVxyXG52YXIgX2tleU1hcCA9IHtcclxuICAgIC8vIFRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSBoZXJlIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkgYW5kIHRvIG1hdGNoIHRoZSBXM0Mgc3RhbmRhcmRcclxuICAgIC8vIGNmIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy1rZXkvXHJcbiAgICAnXFxiJzogJ0JhY2tzcGFjZScsXHJcbiAgICAnXFx0JzogJ1RhYicsXHJcbiAgICAnXFx4N0YnOiAnRGVsZXRlJyxcclxuICAgICdcXHgxQic6ICdFc2NhcGUnLFxyXG4gICAgJ0RlbCc6ICdEZWxldGUnLFxyXG4gICAgJ0VzYyc6ICdFc2NhcGUnLFxyXG4gICAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcclxuICAgICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcclxuICAgICdVcCc6ICdBcnJvd1VwJyxcclxuICAgICdEb3duJzogJ0Fycm93RG93bicsXHJcbiAgICAnTWVudSc6ICdDb250ZXh0TWVudScsXHJcbiAgICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxyXG4gICAgJ1dpbic6ICdPUydcclxufTtcclxuLy8gVGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBudW1lcmljIGtleXBhZCBrZXlzOlxyXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XHJcbi8vIDEsIDIsIDMgLi4uIGFyZSByZXBvcnRlZCBhcyBBLCBCLCBDIC4uLlxyXG52YXIgX2Nocm9tZU51bUtleVBhZE1hcCA9IHtcclxuICAgICdBJzogJzEnLFxyXG4gICAgJ0InOiAnMicsXHJcbiAgICAnQyc6ICczJyxcclxuICAgICdEJzogJzQnLFxyXG4gICAgJ0UnOiAnNScsXHJcbiAgICAnRic6ICc2JyxcclxuICAgICdHJzogJzcnLFxyXG4gICAgJ0gnOiAnOCcsXHJcbiAgICAnSSc6ICc5JyxcclxuICAgICdKJzogJyonLFxyXG4gICAgJ0snOiAnKycsXHJcbiAgICAnTSc6ICctJyxcclxuICAgICdOJzogJy4nLFxyXG4gICAgJ08nOiAnLycsXHJcbiAgICAnXFx4NjAnOiAnMCcsXHJcbiAgICAnXFx4OTAnOiAnTnVtTG9jaydcclxufTtcclxuLyogdHNsaW50OmRpc2FibGU6cmVxdWlyZVBhcmFtZXRlclR5cGUgKi9cclxudmFyIEJyb3dzZXJEb21BZGFwdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJEb21BZGFwdGVyKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlSHRtbCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZSBub3QgaW1wbGVtZW50ZWRcIik7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5tYWtlQ3VycmVudCA9IGZ1bmN0aW9uICgpIHsgZG9tX2FkYXB0ZXJfMS5zZXRSb290RG9tQWRhcHRlcihuZXcgQnJvd3NlckRvbUFkYXB0ZXIoKSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgeyByZXR1cm4gbmFtZSBpbiBlbGVtZW50OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkgeyBlbFtuYW1lXSA9IHZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbFtuYW1lXTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZWwsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcclxuICAgICAgICBlbFttZXRob2ROYW1lXS5hcHBseShlbCwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cCA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZS5ncm91cCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5ncm91cChlcnJvcik7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZ0dyb3VwRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZS5ncm91cEVuZCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2F0dHJUb1Byb3BNYXA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVsLCBzZWxlY3RvcikgeyByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHsgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uQW5kQ2FuY2VsID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gTmVlZGVkIHRvIGZvbGxvdyBEYXJ0J3Mgc3Vic2NyaXB0aW9uIHNlbWFudGljLCB1bnRpbCBmaXggb2ZcclxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhcnQvaXNzdWVzL2RldGFpbD9pZD0xNzQwNlxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpOyB9O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQpIHsgZWwuZGlzcGF0Y2hFdmVudChldnQpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcbiAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBldnQ7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHJldHVybiBldnQuZGVmYXVsdFByZXZlbnRlZCB8fCBsYW5nXzEuaXNQcmVzZW50KGV2dC5yZXR1cm5WYWx1ZSkgJiYgIWV2dC5yZXR1cm5WYWx1ZTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pbm5lckhUTUw7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0ZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5vdXRlckhUTUw7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubm9kZU5hbWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlTmFtZTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5ub2RlVmFsdWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVmFsdWU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnR5cGU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvcGVydHkobm9kZSwgXCJjb250ZW50XCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmZpcnN0Q2hpbGQ7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm5leHRTaWJsaW5nOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnBhcmVudE5vZGU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hpbGROb2RlczsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jaGlsZE5vZGVzQXNMaXN0ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbC5jaGlsZE5vZGVzO1xyXG4gICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGNoaWxkTm9kZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gY2hpbGROb2Rlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xlYXJOb2RlcyA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwuYXBwZW5kQ2hpbGQobm9kZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucmVtb3ZlQ2hpbGQobm9kZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBuZXdDaGlsZCwgb2xkQ2hpbGQpIHsgZWwucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QWxsQmVmb3JlID0gZnVuY3Rpb24gKGVsLCBub2RlcykgeyBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7IHJldHVybiBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCBlbCk7IH0pOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGVsLm5leHRTaWJsaW5nKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmlubmVySFRNTCA9IHZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnRleHRDb250ZW50OyB9O1xyXG4gICAgLy8gVE9ETyh2aWNiKTogcmVtb3ZlZCBFbGVtZW50IHR5cGUgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdXBwb3J0IFN0eWxlRWxlbWVudFxyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnRleHRDb250ZW50ID0gdmFsdWU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC52YWx1ZSA9IHZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwuY2hlY2tlZCA9IHZhbHVlOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xyXG4gICAgICAgIHQuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBkb2MpIHtcclxuICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cclxuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gKHRleHQsIGRvYykge1xyXG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxyXG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFRhZyA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbHVlLCBkb2MpIHtcclxuICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cclxuICAgICAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnU0NSSVBUJyk7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGNzcywgZG9jKSB7XHJcbiAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XHJcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdHlsZSwgdGhpcy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNyZWF0ZVNoYWRvd1Jvb3QoKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRTaGFkb3dSb290ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5zaGFkb3dSb290OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhvc3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhvc3Q7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudC5jbGFzc0xpc3QsIDApOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzbmFtZSkgeyBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc25hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NuYW1lKSB7IHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc25hbWUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSwgc3R5bGV2YWx1ZSkge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVuYW1lXSA9IHN0eWxldmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZVN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkgeyBlbGVtZW50LnN0eWxlW3N0eWxlbmFtZV0gPSBudWxsOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkgeyByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnRhZ05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC50YWdOYW1lOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZU1hcCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB2YXIgZWxBdHRycyA9IGVsZW1lbnQuYXR0cmlidXRlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsQXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYiA9IGVsQXR0cnNbaV07XHJcbiAgICAgICAgICAgIHJlcy5zZXQoYXR0cmliLm5hbWUsIGF0dHJpYi52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHsgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkgeyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHsgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHsgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS50ZW1wbGF0ZUF3YXJlUm9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gdGhpcy5pc1RlbXBsYXRlRWxlbWVudChlbCkgPyB0aGlzLmNvbnRlbnQoZWwpIDogZWw7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlSHRtbERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ2Zha2VUaXRsZScpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kZWZhdWx0RG9jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQ7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQudGl0bGU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAobmV3VGl0bGUpIHsgZG9jdW1lbnQudGl0bGUgPSBuZXdUaXRsZSB8fCAnJzsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5lbGVtZW50TWF0Y2hlcyA9IGZ1bmN0aW9uIChuLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAobi5tYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gbi5tYXRjaGVzKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuLm1zTWF0Y2hlc1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gbi5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobi53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBuLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZWwubm9kZU5hbWUgPT0gXCJURU1QTEFURVwiO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RleHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNTaGFkb3dSb290ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBsYW5nXzEuaXNQcmVzZW50KG5vZGUuc2hhZG93Um9vdCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNTaGFkb3dSb290ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmltcG9ydEludG9Eb2MgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0b0ltcG9ydCA9IG5vZGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgdG9JbXBvcnQgPSB0aGlzLmNvbnRlbnQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5pbXBvcnROb2RlKHRvSW1wb3J0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYWRvcHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGRvY3VtZW50LmFkb3B0Tm9kZShub2RlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1BhZ2VSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudHlwZSA9PT0gQ1NTUnVsZS5QQUdFX1JVTEU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNTdHlsZVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkgeyByZXR1cm4gcnVsZS50eXBlID09PSBDU1NSdWxlLlNUWUxFX1JVTEU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNNZWRpYVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkgeyByZXR1cm4gcnVsZS50eXBlID09PSBDU1NSdWxlLk1FRElBX1JVTEU7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNLZXlmcmFtZXNSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudHlwZSA9PT0gQ1NTUnVsZS5LRVlGUkFNRVNfUlVMRTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ocmVmOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEV2ZW50S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoa2V5KSkge1xyXG4gICAgICAgICAgICBrZXkgPSBldmVudC5rZXlJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAvLyBrZXlJZGVudGlmaWVyIGlzIGRlZmluZWQgaW4gdGhlIG9sZCBkcmFmdCBvZiBET00gTGV2ZWwgMyBFdmVudHMgaW1wbGVtZW50ZWQgYnkgQ2hyb21lIGFuZFxyXG4gICAgICAgICAgICAvLyBTYWZhcmlcclxuICAgICAgICAgICAgLy8gY2ZcclxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEvZXZlbnRzLmh0bWwjRXZlbnRzLUtleWJvYXJkRXZlbnRzLUludGVyZmFjZXNcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5pZGVudGlmaWVkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ1UrJykpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2V5LnN1YnN0cmluZygyKSwgMTYpKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5sb2NhdGlvbiA9PT0gRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgJiYgX2Nocm9tZU51bUtleVBhZE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBudW1lcmljIGtleXBhZCBrZXlzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcclxuICAgICAgICAgICAgICAgICAgICAvLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBfY2hyb21lTnVtS2V5UGFkTWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9rZXlNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBrZXkgPSBfa2V5TWFwW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEdsb2JhbEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gXCJ3aW5kb3dcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT0gXCJkb2N1bWVudFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09IFwiYm9keVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5oaXN0b3J5OyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBocmVmID0gZ2V0QmFzZUVsZW1lbnRIcmVmKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGhyZWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoKGhyZWYpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXNldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyBiYXNlRWxlbWVudCA9IG51bGw7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtJyArIG5hbWUpOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTsgfTtcclxuICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGlzIGludG8gYSBzZXBhcmF0ZSBlbnZpcm9ubWVudCBjbGFzcyBvbmNlIHdlIGhhdmUgaXRcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRHbG9iYWxWYXIgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHsgbGFuZ18xLnNldFZhbHVlT25QYXRoKGxhbmdfMS5nbG9iYWwsIHBhdGgsIHZhbHVlKTsgfTtcclxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spOyB9O1xyXG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7IH07XHJcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcGVyZm9ybWFuY2Uubm93KCkgaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnMsIHNlZVxyXG4gICAgICAgIC8vIGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBlcmZvcm1hbmNlLm5vd1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHdpbmRvdy5wZXJmb3JtYW5jZSkgJiYgbGFuZ18xLmlzUHJlc2VudCh3aW5kb3cucGVyZm9ybWFuY2Uubm93KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5EYXRlV3JhcHBlci50b01pbGxpcyhsYW5nXzEuRGF0ZVdyYXBwZXIubm93KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQnJvd3NlckRvbUFkYXB0ZXI7XHJcbn0pKGdlbmVyaWNfYnJvd3Nlcl9hZGFwdGVyXzEuR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyKTtcclxuZXhwb3J0cy5Ccm93c2VyRG9tQWRhcHRlciA9IEJyb3dzZXJEb21BZGFwdGVyO1xyXG52YXIgYmFzZUVsZW1lbnQgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRCYXNlRWxlbWVudEhyZWYoKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoYmFzZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGJhc2VFbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmFzZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XHJcbn1cclxuLy8gYmFzZWQgb24gdXJsVXRpbHMuanMgaW4gQW5ndWxhckpTIDFcclxudmFyIHVybFBhcnNpbmdOb2RlID0gbnVsbDtcclxuZnVuY3Rpb24gcmVsYXRpdmVQYXRoKHVybCkge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHVybFBhcnNpbmdOb2RlKSkge1xyXG4gICAgICAgIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICB9XHJcbiAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xyXG4gICAgcmV0dXJuICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgPyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XHJcbiAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWU7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9hZGFwdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZnVuY3Rpb24gc2V0Um9vdERvbUFkYXB0ZXIoYWRhcHRlcikge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGV4cG9ydHMuRE9NKSkge1xyXG4gICAgICAgIGV4cG9ydHMuRE9NID0gYWRhcHRlcjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNldFJvb3REb21BZGFwdGVyID0gc2V0Um9vdERvbUFkYXB0ZXI7XHJcbi8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbiBlbnZpcm9ubWVudC1hZ25vc3RpYyB3YXkuXHJcbiAqL1xyXG52YXIgRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEb21BZGFwdGVyKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERvbUFkYXB0ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRG9tQWRhcHRlciA9IERvbUFkYXB0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV9hZGFwdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9kb21fYWRhcHRlcicpO1xyXG4vKipcclxuICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW55IGJyb3dzZXIgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG52YXIgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLmRlZmF1bHREb2MoKSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuZ2V0U3R5bGUoZWxlbWVudCwgJ2FuaW1hdGlvbk5hbWUnKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvbVByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tUHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnQsIGRvbVByZWZpeGVzW2ldICsgJ0FuaW1hdGlvbk5hbWUnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJy0nICsgbGFuZ18xLlN0cmluZ1dyYXBwZXIudG9Mb3dlckNhc2UoZG9tUHJlZml4ZXNbaV0pICsgJy0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcclxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAgICAgICAgIE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcclxuICAgICAgICAgICAgICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godHJhbnNFbmRFdmVudE5hbWVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3RoaXMuZ2V0U3R5bGUoZWxlbWVudCwga2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJhbnNpdGlvbkVuZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXREaXN0cmlidXRlZE5vZGVzID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5nZXREaXN0cmlidXRlZE5vZGVzKCk7IH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlc29sdmVBbmRTZXRIcmVmID0gZnVuY3Rpb24gKGVsLCBiYXNlVXJsLCBocmVmKSB7XHJcbiAgICAgICAgZWwuaHJlZiA9IGhyZWYgPT0gbnVsbCA/IGJhc2VVcmwgOiBiYXNlVXJsICsgJy8uLi8nICsgaHJlZjtcclxuICAgIH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNzc1RvUnVsZXMgPSBmdW5jdGlvbiAoY3NzKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoY3NzKTtcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuZGVmYXVsdERvYygpLmhlYWQsIHN0eWxlKTtcclxuICAgICAgICB2YXIgcnVsZXMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdHlsZS5zaGVldCkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogRmlyZWZveCB0aHJvd3Mgd2hlbiBhY2Nlc3NpbmcgdGhlIHJ1bGVzIG9mIGEgc3R5bGVzaGVldFxyXG4gICAgICAgICAgICAvLyB3aXRoIGFuIEBpbXBvcnRcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjI1MDEzXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmF3UnVsZXMgPSBzdHlsZS5zaGVldC5jc3NSdWxlcztcclxuICAgICAgICAgICAgICAgIHJ1bGVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShyYXdSdWxlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdSdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldID0gcmF3UnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW1vdmUoc3R5bGUpO1xyXG4gICAgICAgIHJldHVybiBydWxlcztcclxuICAgIH07XHJcbiAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzRE9NRXZlbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNOYXRpdmVTaGFkb3dET00gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc0Z1bmN0aW9uKHRoaXMuZGVmYXVsdERvYygpLmJvZHkuY3JlYXRlU2hhZG93Um9vdCk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c1VucHJlZml4ZWRDc3NBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5kZWZhdWx0RG9jKCkuYm9keS5zdHlsZSkgJiZcclxuICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudCh0aGlzLmRlZmF1bHREb2MoKS5ib2R5LnN0eWxlLmFuaW1hdGlvbk5hbWUpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uUHJlZml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgPyB0aGlzLl9hbmltYXRpb25QcmVmaXggOiBcIlwiO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fdHJhbnNpdGlvbkVuZCkgPyB0aGlzLl90cmFuc2l0aW9uRW5kIDogXCJcIjsgfTtcclxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fYW5pbWF0aW9uUHJlZml4KSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3RyYW5zaXRpb25FbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXI7XHJcbn0pKGRvbV9hZGFwdGVyXzEuRG9tQWRhcHRlcik7XHJcbmV4cG9ydHMuR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyID0gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmljX2Jyb3dzZXJfYWRhcHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gUHVibGljIEFQSSBmb3IgRmFjYWRlXHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9sYW5nJyk7XHJcbmV4cG9ydHMuVHlwZSA9IGxhbmdfMS5UeXBlO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4vZmFjYWRlL2FzeW5jJyk7XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IGFzeW5jXzEuT2JzZXJ2YWJsZTtcclxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBhc3luY18xLkV2ZW50RW1pdHRlcjtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuZXhwb3J0cy5XcmFwcGVkRXhjZXB0aW9uID0gZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY2FkZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8vIFRPRE8oamVmZmJjcm9zcyk6IHVzZSBFUzYgaW1wb3J0IG9uY2UgdHlwaW5ncyBhcmUgYXZhaWxhYmxlXHJcbnZhciBTdWJqZWN0ID0gcmVxdWlyZSgnQHJlYWN0aXZleC9yeGpzL2Rpc3QvY2pzL1N1YmplY3QnKTtcclxudmFyIFByb21pc2VXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb21pc2VXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgUHJvbWlzZVdyYXBwZXIucmVzb2x2ZSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmopOyB9O1xyXG4gICAgUHJvbWlzZVdyYXBwZXIucmVqZWN0ID0gZnVuY3Rpb24gKG9iaiwgXykgeyByZXR1cm4gUHJvbWlzZS5yZWplY3Qob2JqKTsgfTtcclxuICAgIC8vIE5vdGU6IFdlIGNhbid0IHJlbmFtZSB0aGlzIG1ldGhvZCBpbnRvIGBjYXRjaGAsIGFzIHRoaXMgaXMgbm90IGEgdmFsaWRcclxuICAgIC8vIG1ldGhvZCBuYW1lIGluIERhcnQuXHJcbiAgICBQcm9taXNlV3JhcHBlci5jYXRjaEVycm9yID0gZnVuY3Rpb24gKHByb21pc2UsIG9uRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcclxuICAgIH07XHJcbiAgICBQcm9taXNlV3JhcHBlci5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcclxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICB9O1xyXG4gICAgUHJvbWlzZVdyYXBwZXIudGhlbiA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdWNjZXNzLCByZWplY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIHJlamVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUHJvbWlzZVdyYXBwZXIud3JhcCA9IGZ1bmN0aW9uIChjb21wdXRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlcyhjb21wdXRhdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvbWlzZVdyYXBwZXIuY29tcGxldGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXNvbHZlO1xyXG4gICAgICAgIHZhciByZWplY3Q7XHJcbiAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcclxuICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7IHByb21pc2U6IHAsIHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0IH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb21pc2VXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb21pc2VXcmFwcGVyID0gUHJvbWlzZVdyYXBwZXI7XHJcbnZhciBUaW1lcldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGltZXJXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgVGltZXJXcmFwcGVyLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZm4sIG1pbGxpcykge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuZ2xvYmFsLnNldFRpbWVvdXQoZm4sIG1pbGxpcyk7XHJcbiAgICB9O1xyXG4gICAgVGltZXJXcmFwcGVyLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChpZCkgeyBsYW5nXzEuZ2xvYmFsLmNsZWFyVGltZW91dChpZCk7IH07XHJcbiAgICBUaW1lcldyYXBwZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoZm4sIG1pbGxpcykge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuZ2xvYmFsLnNldEludGVydmFsKGZuLCBtaWxsaXMpO1xyXG4gICAgfTtcclxuICAgIFRpbWVyV3JhcHBlci5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGlkKSB7IGxhbmdfMS5nbG9iYWwuY2xlYXJJbnRlcnZhbChpZCk7IH07XHJcbiAgICByZXR1cm4gVGltZXJXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlRpbWVyV3JhcHBlciA9IFRpbWVyV3JhcHBlcjtcclxudmFyIE9ic2VydmFibGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyh2c2F2a2luKTogd2hlbiB3ZSB1c2UgcnhuZXh0LCB0cnkgaW5mZXJyaW5nIHRoZSBnZW5lcmljIHR5cGUgZnJvbSB0aGUgZmlyc3QgYXJnXHJcbiAgICBPYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZW1pdHRlciwgb25OZXh0LCBvblRocm93LCBvblJldHVybikge1xyXG4gICAgICAgIGlmIChvblRocm93ID09PSB2b2lkIDApIHsgb25UaHJvdyA9IG51bGw7IH1cclxuICAgICAgICBpZiAob25SZXR1cm4gPT09IHZvaWQgMCkgeyBvblJldHVybiA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gZW1pdHRlci5vYnNlcnZlcih7IG5leHQ6IG9uTmV4dCwgdGhyb3c6IG9uVGhyb3csIHJldHVybjogb25SZXR1cm4gfSk7XHJcbiAgICB9O1xyXG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIuaXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZTsgfTtcclxuICAgIE9ic2VydmFibGVXcmFwcGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xyXG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdmFsdWUpIHsgZW1pdHRlci5uZXh0KHZhbHVlKTsgfTtcclxuICAgIE9ic2VydmFibGVXcmFwcGVyLmNhbGxUaHJvdyA9IGZ1bmN0aW9uIChlbWl0dGVyLCBlcnJvcikgeyBlbWl0dGVyLnRocm93KGVycm9yKTsgfTtcclxuICAgIE9ic2VydmFibGVXcmFwcGVyLmNhbGxSZXR1cm4gPSBmdW5jdGlvbiAoZW1pdHRlcikgeyBlbWl0dGVyLnJldHVybihudWxsKTsgfTtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5PYnNlcnZhYmxlV3JhcHBlciA9IE9ic2VydmFibGVXcmFwcGVyO1xyXG4vLyBUT0RPOiB2c2F2a2luIGNoYW5nZSB0byBpbnRlcmZhY2VcclxudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZSgpIHtcclxuICAgIH1cclxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLm9ic2VydmVyID0gZnVuY3Rpb24gKGdlbmVyYXRvcikgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlO1xyXG59KSgpO1xyXG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xyXG4vKipcclxuICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXHJcbiAqIHRpdGxlIGdldHMgY2xpY2tlZDpcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnemlwcHknLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgPGRpdiBjbGFzcz1cInppcHB5XCI+XHJcbiAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxyXG4gKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XHJcbiAqICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgPC9kaXY+YH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBaaXBweSB7XHJcbiAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XHJcbiAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICogICBAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICpcclxuICogICB0b2dnbGUoKSB7XHJcbiAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xyXG4gKiAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xyXG4gKiAgICAgICB0aGlzLm9wZW4ubmV4dChudWxsKTtcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgIHRoaXMuY2xvc2UubmV4dChudWxsKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFVzZSBSeC5PYnNlcnZhYmxlIGJ1dCBwcm92aWRlcyBhbiBhZGFwdGVyIHRvIG1ha2UgaXQgd29yayBhcyBzcGVjaWZpZWQgaGVyZTpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXHJcbiAqXHJcbiAqIE9uY2UgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWMgaXMgYXZhaWxhYmxlLCBzd2l0Y2ggdG8gaXQuXHJcbiAqL1xyXG52YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFdmVudEVtaXR0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgfVxyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vYnNlcnZlciA9IGZ1bmN0aW9uIChnZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdC5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yLm5leHQodmFsdWUpOyB9KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBnZW5lcmF0b3IudGhyb3cgPyBnZW5lcmF0b3IudGhyb3coZXJyb3IpIDogbnVsbDsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yLnJldHVybiA/IGdlbmVyYXRvci5yZXR1cm4oKSA6IG51bGw7IH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudG9SeCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1YmplY3Q7IH07XHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fc3ViamVjdC5uZXh0KHZhbHVlKTsgfTtcclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgdGhpcy5fc3ViamVjdC5lcnJvcihlcnJvcik7IH07XHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9zdWJqZWN0LmNvbXBsZXRlKCk7IH07XHJcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xyXG59KShPYnNlcnZhYmxlKTtcclxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZXhwb3J0cy5NYXAgPSBsYW5nXzEuZ2xvYmFsLk1hcDtcclxuZXhwb3J0cy5TZXQgPSBsYW5nXzEuZ2xvYmFsLlNldDtcclxuLy8gU2FmYXJpIGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkbyBub3Qgc3VwcG9ydCB0aGUgaXRlcmFibGUgcGFyYW1ldGVyIHRvIHRoZVxyXG4vLyBNYXAgY29uc3RydWN0b3IuICBXZSB3b3JrIGFyb3VuZCB0aGF0IGJ5IG1hbnVhbGx5IGFkZGluZyB0aGUgaXRlbXMuXHJcbnZhciBjcmVhdGVNYXBGcm9tUGFpcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAobmV3IGV4cG9ydHMuTWFwKFtbMSwgMl1dKS5zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBGcm9tUGFpcnMocGFpcnMpIHsgcmV0dXJuIG5ldyBleHBvcnRzLk1hcChwYWlycyk7IH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBBbmRQb3B1bGF0ZUZyb21QYWlycyhwYWlycykge1xyXG4gICAgICAgIHZhciBtYXAgPSBuZXcgZXhwb3J0cy5NYXAoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgY3JlYXRlTWFwRnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChuZXcgZXhwb3J0cy5NYXAobmV3IGV4cG9ydHMuTWFwKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBGcm9tTWFwKG0pIHsgcmV0dXJuIG5ldyBleHBvcnRzLk1hcChtKTsgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hcEFuZFBvcHVsYXRlRnJvbU1hcChtKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBleHBvcnRzLk1hcCgpO1xyXG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyBtYXAuc2V0KGssIHYpOyB9KTtcclxuICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9jbGVhclZhbHVlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoKG5ldyBleHBvcnRzLk1hcCgpKS5rZXlzKCkubmV4dCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXMobSkge1xyXG4gICAgICAgICAgICB2YXIga2V5SXRlcmF0b3IgPSBtLmtleXMoKTtcclxuICAgICAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgICAgIHdoaWxlICghKChrID0ga2V5SXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xyXG4gICAgICAgICAgICAgICAgbS5zZXQoay52YWx1ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhclZhbHVlc1dpdGhGb3JlRWFjaChtKSB7XHJcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyBtLnNldChrLCBudWxsKTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufSkoKTtcclxuLy8gU2FmYXJpIGRvZXNuJ3QgaW1wbGVtZW50IE1hcEl0ZXJhdG9yLm5leHQoKSwgd2hpY2ggaXMgdXNlZCBpcyBUcmFjZXVyJ3MgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxyXG4vLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXHJcbnZhciBfYXJyYXlGcm9tTWFwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKChuZXcgZXhwb3J0cy5NYXAoKSkudmFsdWVzKCkubmV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykgeyByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IExpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShtLnNpemUpLCBpID0gMDtcclxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIE1hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWFwV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIE1hcFdyYXBwZXIuY2xvbmUgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gY3JlYXRlTWFwRnJvbU1hcChtKTsgfTtcclxuICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IGV4cG9ydHMuTWFwKCk7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHJpbmdNYXApIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChwcm9wLCBzdHJpbmdNYXBbcHJvcF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE1hcFdyYXBwZXIudG9TdHJpbmdNYXAgPSBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIHZhciByID0ge307XHJcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiByW2tdID0gdjsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG4gICAgTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMgPSBmdW5jdGlvbiAocGFpcnMpIHsgcmV0dXJuIGNyZWF0ZU1hcEZyb21QYWlycyhwYWlycyk7IH07XHJcbiAgICBNYXBXcmFwcGVyLmNsZWFyVmFsdWVzID0gZnVuY3Rpb24gKG0pIHsgX2NsZWFyVmFsdWVzKG0pOyB9O1xyXG4gICAgTWFwV3JhcHBlci5pdGVyYWJsZSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtOyB9O1xyXG4gICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xyXG4gICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcclxuICAgIHJldHVybiBNYXBXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLk1hcFdyYXBwZXIgPSBNYXBXcmFwcGVyO1xyXG4vKipcclxuICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXHJcbiAqL1xyXG52YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gTm90ZTogV2UgYXJlIG5vdCB1c2luZyBPYmplY3QuY3JlYXRlKG51bGwpIGhlcmUgZHVlIHRvXHJcbiAgICAgICAgLy8gcGVyZm9ybWFuY2UhXHJcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vbmcyLW9iamVjdC1jcmVhdGUtbnVsbFxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIuZ2V0ID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5zZXQgPSBmdW5jdGlvbiAobWFwLCBrZXksIHZhbHVlKSB7IG1hcFtrZXldID0gdmFsdWU7IH07XHJcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmtleXMgPSBmdW5jdGlvbiAobWFwKSB7IHJldHVybiBPYmplY3Qua2V5cyhtYXApOyB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5kZWxldGUgPSBmdW5jdGlvbiAobWFwLCBrZXkpIHsgZGVsZXRlIG1hcFtrZXldOyB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoID0gZnVuY3Rpb24gKG1hcCwgY2FsbGJhY2spIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xyXG4gICAgICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtYXBbcHJvcF0sIHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0cmluZ01hcFdyYXBwZXIubWVyZ2UgPSBmdW5jdGlvbiAobTEsIG0yKSB7XHJcbiAgICAgICAgdmFyIG0gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIG0xKSB7XHJcbiAgICAgICAgICAgIGlmIChtMS5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgbVthdHRyXSA9IG0xW2F0dHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gbTIpIHtcclxuICAgICAgICAgICAgaWYgKG0yLmhhc093blByb3BlcnR5KGF0dHIpKSB7XHJcbiAgICAgICAgICAgICAgICBtW2F0dHJdID0gbTJbYXR0cl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XHJcbiAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xyXG4gICAgICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKG0yKTtcclxuICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBrZXkgPSBrMVtpXTtcclxuICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TdHJpbmdNYXBXcmFwcGVyID0gU3RyaW5nTWFwV3JhcHBlcjtcclxudmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgLy8gSlMgaGFzIG5vIHdheSB0byBleHByZXNzIGEgc3RhdGljYWxseSBmaXhlZCBzaXplIGxpc3QsIGJ1dCBkYXJ0IGRvZXMgc28gd2VcclxuICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxyXG4gICAgTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcclxuICAgIExpc3RXcmFwcGVyLmNyZWF0ZUdyb3dhYmxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24gKGFycmF5LCBmbikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIGlmICghYXJyYXkpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHJldHVybiBhcnJheVswXTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5sYXN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLmZpbmQgPSBmdW5jdGlvbiAobGlzdCwgcHJlZCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZChsaXN0W2ldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCB2YWx1ZSwgc3RhcnRJbmRleCkge1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IDA7IH1cclxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSwgc3RhcnRJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIucmVkdWNlID0gZnVuY3Rpb24gKGxpc3QsIGZuLCBpbml0KSB7XHJcbiAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKGZuLCBpbml0KTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5maWx0ZXIgPSBmdW5jdGlvbiAoYXJyYXksIHByZWQpIHsgcmV0dXJuIGFycmF5LmZpbHRlcihwcmVkKTsgfTtcclxuICAgIExpc3RXcmFwcGVyLmFueSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkKGxpc3RbaV0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChsaXN0LCBlbCkgeyByZXR1cm4gbGlzdC5pbmRleE9mKGVsKSAhPT0gLTE7IH07XHJcbiAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHZhciBhID0gTGlzdFdyYXBwZXIuY2xvbmUoYXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBhLnJldmVyc2UoKTtcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH07XHJcbiAgICBMaXN0V3JhcHBlci5pbnNlcnQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgsIHZhbHVlKSB7IGxpc3Quc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xyXG4gICAgICAgIHZhciByZXMgPSBsaXN0W2luZGV4XTtcclxuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XHJcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuY2xlYXIgPSBmdW5jdGlvbiAobGlzdCkgeyBsaXN0Lmxlbmd0aCA9IDA7IH07XHJcbiAgICBMaXN0V3JhcHBlci5pc0VtcHR5ID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QubGVuZ3RoID09IDA7IH07XHJcbiAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cclxuICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxyXG4gICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBsLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xyXG4gICAgfTtcclxuICAgIExpc3RXcmFwcGVyLnNwbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCBsZW5ndGgpIHsgcmV0dXJuIGwuc3BsaWNlKGZyb20sIGxlbmd0aCk7IH07XHJcbiAgICBMaXN0V3JhcHBlci5zb3J0ID0gZnVuY3Rpb24gKGwsIGNvbXBhcmVGbikge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBhcmVGbikpIHtcclxuICAgICAgICAgICAgbC5zb3J0KGNvbXBhcmVGbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsLnNvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlzdFdyYXBwZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbC50b1N0cmluZygpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIudG9KU09OID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9O1xyXG4gICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvbHV0aW9uID0gbnVsbDtcclxuICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBsaXN0W2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNhbmRpZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb2x1dGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdFdyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTGlzdFdyYXBwZXIgPSBMaXN0V3JhcHBlcjtcclxuZnVuY3Rpb24gaXNMaXN0TGlrZUl0ZXJhYmxlKG9iaikge1xyXG4gICAgaWYgKCFsYW5nXzEuaXNKc09iamVjdChvYmopKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBsYW5nXzEuaXNBcnJheShvYmopIHx8XHJcbiAgICAgICAgKCEob2JqIGluc3RhbmNlb2YgZXhwb3J0cy5NYXApICYmXHJcbiAgICAgICAgICAgIGxhbmdfMS5nZXRTeW1ib2xJdGVyYXRvcigpIGluIG9iaik7IC8vIEpTIEl0ZXJhYmxlIGhhdmUgYSBTeW1ib2wuaXRlcmF0b3IgcHJvcFxyXG59XHJcbmV4cG9ydHMuaXNMaXN0TGlrZUl0ZXJhYmxlID0gaXNMaXN0TGlrZUl0ZXJhYmxlO1xyXG5mdW5jdGlvbiBpdGVyYXRlTGlzdExpa2Uob2JqLCBmbikge1xyXG4gICAgaWYgKGxhbmdfMS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBmbihvYmpbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IG9ialtsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcclxuICAgICAgICB2YXIgaXRlbTtcclxuICAgICAgICB3aGlsZSAoISgoaXRlbSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcclxuICAgICAgICAgICAgZm4oaXRlbS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuaXRlcmF0ZUxpc3RMaWtlID0gaXRlcmF0ZUxpc3RMaWtlO1xyXG4vLyBTYWZhcmkgYW5kIEludGVybmV0IEV4cGxvcmVyIGRvIG5vdCBzdXBwb3J0IHRoZSBpdGVyYWJsZSBwYXJhbWV0ZXIgdG8gdGhlXHJcbi8vIFNldCBjb25zdHJ1Y3Rvci4gIFdlIHdvcmsgYXJvdW5kIHRoYXQgYnkgbWFudWFsbHkgYWRkaW5nIHRoZSBpdGVtcy5cclxudmFyIGNyZWF0ZVNldEZyb21MaXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0ZXN0ID0gbmV3IGV4cG9ydHMuU2V0KFsxLCAyLCAzXSk7XHJcbiAgICBpZiAodGVzdC5zaXplID09PSAzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNldEZyb21MaXN0KGxzdCkgeyByZXR1cm4gbmV3IGV4cG9ydHMuU2V0KGxzdCk7IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2V0QW5kUG9wdWxhdGVGcm9tTGlzdChsc3QpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBleHBvcnRzLlNldChsc3QpO1xyXG4gICAgICAgICAgICBpZiAocmVzLnNpemUgIT09IGxzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmFkZChsc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufSkoKTtcclxudmFyIFNldFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2V0V3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFNldFdyYXBwZXIuY3JlYXRlRnJvbUxpc3QgPSBmdW5jdGlvbiAobHN0KSB7IHJldHVybiBjcmVhdGVTZXRGcm9tTGlzdChsc3QpOyB9O1xyXG4gICAgU2V0V3JhcHBlci5oYXMgPSBmdW5jdGlvbiAocywga2V5KSB7IHJldHVybiBzLmhhcyhrZXkpOyB9O1xyXG4gICAgU2V0V3JhcHBlci5kZWxldGUgPSBmdW5jdGlvbiAobSwgaykgeyBtLmRlbGV0ZShrKTsgfTtcclxuICAgIHJldHVybiBTZXRXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNldFdyYXBwZXIgPSBTZXRXcmFwcGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgX0FycmF5TG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9BcnJheUxvZ2dlcigpIHtcclxuICAgICAgICB0aGlzLnJlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAocykgeyB0aGlzLnJlcy5wdXNoKHMpOyB9O1xyXG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChzKSB7IHRoaXMucmVzLnB1c2gocyk7IH07XHJcbiAgICBfQXJyYXlMb2dnZXIucHJvdG90eXBlLmxvZ0dyb3VwID0gZnVuY3Rpb24gKHMpIHsgdGhpcy5yZXMucHVzaChzKTsgfTtcclxuICAgIF9BcnJheUxvZ2dlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gX0FycmF5TG9nZ2VyO1xyXG59KSgpO1xyXG4vKipcclxuICogUHJvdmlkZXMgYSBob29rIGZvciBjZW50cmFsaXplZCBleGNlcHRpb24gaGFuZGxpbmcuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBFeGNlcHRpb25IYW5kbGVyYCBwcmludHMgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIGBDb25zb2xlYC4gVG9cclxuICogaW50ZXJjZXB0IGVycm9yIGhhbmRsaW5nLFxyXG4gKiB3cml0ZSBhIGN1c3RvbSBleGNlcHRpb24gaGFuZGxlciB0aGF0IHJlcGxhY2VzIHRoaXMgZGVmYXVsdCBhcyBhcHByb3ByaWF0ZSBmb3IgeW91ciBhcHAuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqXHJcbiAqIGNsYXNzIE15RXhjZXB0aW9uSGFuZGxlciBpbXBsZW1lbnRzIEV4Y2VwdGlvbkhhbmRsZXIge1xyXG4gKiAgIGNhbGwoZXJyb3IsIHN0YWNrVHJhY2UgPSBudWxsLCByZWFzb24gPSBudWxsKSB7XHJcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXhjZXB0aW9uXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChNeUFwcCwgW3Byb3ZpZGUoRXhjZXB0aW9uSGFuZGxlciwge3VzZUNsYXNzOiBNeUV4Y2VwdGlvbkhhbmRsZXJ9KV0pXHJcbiAqXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEV4Y2VwdGlvbkhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXhjZXB0aW9uSGFuZGxlcihfbG9nZ2VyLCBfcmV0aHJvd0V4Y2VwdGlvbikge1xyXG4gICAgICAgIGlmIChfcmV0aHJvd0V4Y2VwdGlvbiA9PT0gdm9pZCAwKSB7IF9yZXRocm93RXhjZXB0aW9uID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IF9sb2dnZXI7XHJcbiAgICAgICAgdGhpcy5fcmV0aHJvd0V4Y2VwdGlvbiA9IF9yZXRocm93RXhjZXB0aW9uO1xyXG4gICAgfVxyXG4gICAgRXhjZXB0aW9uSGFuZGxlci5leGNlcHRpb25Ub1N0cmluZyA9IGZ1bmN0aW9uIChleGNlcHRpb24sIHN0YWNrVHJhY2UsIHJlYXNvbikge1xyXG4gICAgICAgIGlmIChzdGFja1RyYWNlID09PSB2b2lkIDApIHsgc3RhY2tUcmFjZSA9IG51bGw7IH1cclxuICAgICAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHsgcmVhc29uID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBsID0gbmV3IF9BcnJheUxvZ2dlcigpO1xyXG4gICAgICAgIHZhciBlID0gbmV3IEV4Y2VwdGlvbkhhbmRsZXIobCwgZmFsc2UpO1xyXG4gICAgICAgIGUuY2FsbChleGNlcHRpb24sIHN0YWNrVHJhY2UsIHJlYXNvbik7XHJcbiAgICAgICAgcmV0dXJuIGwucmVzLmpvaW4oXCJcXG5cIik7XHJcbiAgICB9O1xyXG4gICAgRXhjZXB0aW9uSGFuZGxlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChleGNlcHRpb24sIHN0YWNrVHJhY2UsIHJlYXNvbikge1xyXG4gICAgICAgIGlmIChzdGFja1RyYWNlID09PSB2b2lkIDApIHsgc3RhY2tUcmFjZSA9IG51bGw7IH1cclxuICAgICAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHsgcmVhc29uID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbEV4Y2VwdGlvbiA9IHRoaXMuX2ZpbmRPcmlnaW5hbEV4Y2VwdGlvbihleGNlcHRpb24pO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbFN0YWNrID0gdGhpcy5fZmluZE9yaWdpbmFsU3RhY2soZXhjZXB0aW9uKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2ZpbmRDb250ZXh0KGV4Y2VwdGlvbik7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0dyb3VwKFwiRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKGV4Y2VwdGlvbikpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0YWNrVHJhY2UpICYmIGxhbmdfMS5pc0JsYW5rKG9yaWdpbmFsU3RhY2spKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIlNUQUNLVFJBQ0U6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IodGhpcy5fbG9uZ1N0YWNrVHJhY2Uoc3RhY2tUcmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChyZWFzb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIlJFQVNPTjogXCIgKyByZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcmlnaW5hbEV4Y2VwdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKFwiT1JJR0lOQUwgRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKG9yaWdpbmFsRXhjZXB0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9yaWdpbmFsU3RhY2spKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIk9SSUdJTkFMIFNUQUNLVFJBQ0U6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IodGhpcy5fbG9uZ1N0YWNrVHJhY2Uob3JpZ2luYWxTdGFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJFUlJPUiBDT05URVhUOlwiKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIubG9nR3JvdXBFbmQoKTtcclxuICAgICAgICAvLyBXZSByZXRocm93IGV4Y2VwdGlvbnMsIHNvIG9wZXJhdGlvbnMgbGlrZSAnYm9vdHN0cmFwJyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclxyXG4gICAgICAgIC8vIHdoZW4gYW4gZXhjZXB0aW9uIGhhcHBlbnMuIElmIHdlIGRvIG5vdCByZXRocm93LCBib290c3RyYXAgd2lsbCBhbHdheXMgc3VjY2VlZC5cclxuICAgICAgICBpZiAodGhpcy5fcmV0aHJvd0V4Y2VwdGlvbilcclxuICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcclxuICAgICAgICByZXR1cm4gZXhjZXB0aW9uIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24gPyBleGNlcHRpb24ud3JhcHBlck1lc3NhZ2UgOiBleGNlcHRpb24udG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fbG9uZ1N0YWNrVHJhY2UgPSBmdW5jdGlvbiAoc3RhY2tUcmFjZSkge1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKHN0YWNrVHJhY2UpID8gc3RhY2tUcmFjZS5qb2luKFwiXFxuXFxuLS0tLS1hc3luYyBnYXAtLS0tLVxcblwiKSA6XHJcbiAgICAgICAgICAgIHN0YWNrVHJhY2UudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZmluZENvbnRleHQgPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCEoZXhjZXB0aW9uIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGV4Y2VwdGlvbi5jb250ZXh0KSA/IGV4Y2VwdGlvbi5jb250ZXh0IDpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb250ZXh0KGV4Y2VwdGlvbi5vcmlnaW5hbEV4Y2VwdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIGV4Y2VwdGlvbi5jb250ZXh0IGNhbiB0aHJvdyBhbiBleGNlcHRpb24uIGlmIGl0IGhhcHBlbnMsIHdlIGlnbm9yZSB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgaWYgKCEoZXhjZXB0aW9uIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24pKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB2YXIgZSA9IGV4Y2VwdGlvbi5vcmlnaW5hbEV4Y2VwdGlvbjtcclxuICAgICAgICB3aGlsZSAoZSBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5XcmFwcGVkRXhjZXB0aW9uICYmIGxhbmdfMS5pc1ByZXNlbnQoZS5vcmlnaW5hbEV4Y2VwdGlvbikpIHtcclxuICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFeGNlcHRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxTdGFjayA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcclxuICAgICAgICBpZiAoIShleGNlcHRpb24gaW5zdGFuY2VvZiBleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbikpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBlID0gZXhjZXB0aW9uO1xyXG4gICAgICAgIHZhciBzdGFjayA9IGV4Y2VwdGlvbi5vcmlnaW5hbFN0YWNrO1xyXG4gICAgICAgIHdoaWxlIChlIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24gJiYgbGFuZ18xLmlzUHJlc2VudChlLm9yaWdpbmFsRXhjZXB0aW9uKSkge1xyXG4gICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV4Y2VwdGlvbjtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbiAmJiBsYW5nXzEuaXNQcmVzZW50KGUub3JpZ2luYWxFeGNlcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjayA9IGUub3JpZ2luYWxTdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhY2s7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV4Y2VwdGlvbkhhbmRsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRXhjZXB0aW9uSGFuZGxlciA9IEV4Y2VwdGlvbkhhbmRsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbl9oYW5kbGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZXhjZXB0aW9uX2hhbmRsZXJfMSA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uX2hhbmRsZXInKTtcclxudmFyIGV4Y2VwdGlvbl9oYW5kbGVyXzIgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbl9oYW5kbGVyJyk7XHJcbmV4cG9ydHMuRXhjZXB0aW9uSGFuZGxlciA9IGV4Y2VwdGlvbl9oYW5kbGVyXzIuRXhjZXB0aW9uSGFuZGxlcjtcclxudmFyIEJhc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhc2VFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBcIi0tXCI7IH1cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztcclxuICAgIH1cclxuICAgIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9O1xyXG4gICAgcmV0dXJuIEJhc2VFeGNlcHRpb247XHJcbn0pKEVycm9yKTtcclxuZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gQmFzZUV4Y2VwdGlvbjtcclxudmFyIFdyYXBwZWRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdyYXBwZWRFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXcmFwcGVkRXhjZXB0aW9uKF93cmFwcGVyTWVzc2FnZSwgX29yaWdpbmFsRXhjZXB0aW9uLCBfb3JpZ2luYWxTdGFjaywgX2NvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfd3JhcHBlck1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dyYXBwZXJNZXNzYWdlID0gX3dyYXBwZXJNZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsRXhjZXB0aW9uID0gX29yaWdpbmFsRXhjZXB0aW9uO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsU3RhY2sgPSBfb3JpZ2luYWxTdGFjaztcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YWNrID0gKG5ldyBFcnJvcihfd3JhcHBlck1lc3NhZ2UpKS5zdGFjaztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGVyTWVzc2FnZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl93cmFwcGVyTWVzc2FnZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwid3JhcHBlclN0YWNrXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3dyYXBwZXJTdGFjazsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwib3JpZ2luYWxFeGNlcHRpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb3JpZ2luYWxFeGNlcHRpb247IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsU3RhY2tcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb3JpZ2luYWxTdGFjazsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZXh0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbl9oYW5kbGVyXzEuRXhjZXB0aW9uSGFuZGxlci5leGNlcHRpb25Ub1N0cmluZyh0aGlzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcclxuICAgIHJldHVybiBXcmFwcGVkRXhjZXB0aW9uO1xyXG59KShFcnJvcik7XHJcbmV4cG9ydHMuV3JhcHBlZEV4Y2VwdGlvbiA9IFdyYXBwZWRFeGNlcHRpb247XHJcbmZ1bmN0aW9uIG1ha2VUeXBlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuZXhwb3J0cy5tYWtlVHlwZUVycm9yID0gbWFrZVR5cGVFcnJvcjtcclxuZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcclxuICAgIHRocm93IG5ldyBCYXNlRXhjZXB0aW9uKCd1bmltcGxlbWVudGVkJyk7XHJcbn1cclxuZXhwb3J0cy51bmltcGxlbWVudGVkID0gdW5pbXBsZW1lbnRlZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7KGZ1bmN0aW9uIChOdW1iZXJGb3JtYXRTdHlsZSkge1xyXG4gICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJEZWNpbWFsXCJdID0gMF0gPSBcIkRlY2ltYWxcIjtcclxuICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiUGVyY2VudFwiXSA9IDFdID0gXCJQZXJjZW50XCI7XHJcbiAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIkN1cnJlbmN5XCJdID0gMl0gPSBcIkN1cnJlbmN5XCI7XHJcbn0pKGV4cG9ydHMuTnVtYmVyRm9ybWF0U3R5bGUgfHwgKGV4cG9ydHMuTnVtYmVyRm9ybWF0U3R5bGUgPSB7fSkpO1xyXG52YXIgTnVtYmVyRm9ybWF0U3R5bGUgPSBleHBvcnRzLk51bWJlckZvcm1hdFN0eWxlO1xyXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE51bWJlckZvcm1hdHRlcigpIHtcclxuICAgIH1cclxuICAgIE51bWJlckZvcm1hdHRlci5mb3JtYXQgPSBmdW5jdGlvbiAobnVtYmVyLCBsb2NhbGUsIHN0eWxlLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLm1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gX2IubWluaW11bUZyYWN0aW9uRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBfZSA9IF9iLm1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gX2UgPT09IHZvaWQgMCA/IDMgOiBfZSwgY3VycmVuY3kgPSBfYi5jdXJyZW5jeSwgX2YgPSBfYi5jdXJyZW5jeUFzU3ltYm9sLCBjdXJyZW5jeUFzU3ltYm9sID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Y7XHJcbiAgICAgICAgdmFyIGludGxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluaW11bUludGVnZXJEaWdpdHMsXHJcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbWluaW11bUZyYWN0aW9uRGlnaXRzLFxyXG4gICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG1heGltdW1GcmFjdGlvbkRpZ2l0c1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW50bE9wdGlvbnMuc3R5bGUgPSBOdW1iZXJGb3JtYXRTdHlsZVtzdHlsZV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoc3R5bGUgPT0gTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpIHtcclxuICAgICAgICAgICAgaW50bE9wdGlvbnMuY3VycmVuY3kgPSBjdXJyZW5jeTtcclxuICAgICAgICAgICAgaW50bE9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ID0gY3VycmVuY3lBc1N5bWJvbCA/ICdzeW1ib2wnIDogJ2NvZGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgaW50bE9wdGlvbnMpLmZvcm1hdChudW1iZXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTnVtYmVyRm9ybWF0dGVyID0gTnVtYmVyRm9ybWF0dGVyO1xyXG5mdW5jdGlvbiBkaWdpdENvbmRpdGlvbihsZW4pIHtcclxuICAgIHJldHVybiBsZW4gPT0gMiA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJztcclxufVxyXG5mdW5jdGlvbiBuYW1lQ29uZGl0aW9uKGxlbikge1xyXG4gICAgcmV0dXJuIGxlbiA8IDQgPyAnc2hvcnQnIDogJ2xvbmcnO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RDb21wb25lbnRzKHBhdHRlcm4pIHtcclxuICAgIHZhciByZXQgPSB7fTtcclxuICAgIHZhciBpID0gMCwgajtcclxuICAgIHdoaWxlIChpIDwgcGF0dGVybi5sZW5ndGgpIHtcclxuICAgICAgICBqID0gaTtcclxuICAgICAgICB3aGlsZSAoaiA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm5bal0gPT0gcGF0dGVybltpXSlcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIHZhciBsZW4gPSBqIC0gaTtcclxuICAgICAgICBzd2l0Y2ggKHBhdHRlcm5baV0pIHtcclxuICAgICAgICAgICAgY2FzZSAnRyc6XHJcbiAgICAgICAgICAgICAgICByZXQuZXJhID0gbmFtZUNvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICAgICAgcmV0LnllYXIgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+PSAzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldC5tb250aCA9IG5hbWVDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXQubW9udGggPSBkaWdpdENvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgcmV0LmRheSA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICAgICAgICByZXQud2Vla2RheSA9IG5hbWVDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdqJzpcclxuICAgICAgICAgICAgICAgIHJldC5ob3VyID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgIHJldC5ob3VyID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIHJldC5ob3VyMTIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgcmV0LmhvdXIgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0LmhvdXIxMiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICAgICAgcmV0Lm1pbnV0ZSA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICByZXQuc2Vjb25kID0gZGlnaXRDb25kaXRpb24obGVuKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd6JzpcclxuICAgICAgICAgICAgICAgIHJldC50aW1lWm9uZU5hbWUgPSAnbG9uZyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgICAgICAgICByZXQudGltZVpvbmVOYW1lID0gJ3Nob3J0JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpID0gajtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxudmFyIGRhdGVGb3JtYXR0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcclxudmFyIERhdGVGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZUZvcm1hdHRlcigpIHtcclxuICAgIH1cclxuICAgIERhdGVGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgcGF0dGVybikge1xyXG4gICAgICAgIHZhciBrZXkgPSBsb2NhbGUgKyBwYXR0ZXJuO1xyXG4gICAgICAgIGlmIChkYXRlRm9ybWF0dGVyQ2FjaGUuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXR0ZXJDYWNoZS5nZXQoa2V5KS5mb3JtYXQoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGV4dHJhY3RDb21wb25lbnRzKHBhdHRlcm4pKTtcclxuICAgICAgICBkYXRlRm9ybWF0dGVyQ2FjaGUuc2V0KGtleSwgZm9ybWF0dGVyKTtcclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChkYXRlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZUZvcm1hdHRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRlRm9ybWF0dGVyID0gRGF0ZUZvcm1hdHRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50bC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGdsb2JhbFNjb3BlO1xyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xyXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcclxuICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcclxuICAgIH1cclxufVxyXG5lbHNlIHtcclxuICAgIGdsb2JhbFNjb3BlID0gd2luZG93O1xyXG59XHJcbjtcclxuLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XHJcbi8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXHJcbnZhciBfZ2xvYmFsID0gZ2xvYmFsU2NvcGU7XHJcbmV4cG9ydHMuZ2xvYmFsID0gX2dsb2JhbDtcclxuZXhwb3J0cy5UeXBlID0gRnVuY3Rpb247XHJcbmZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcclxuICAgIHJldHVybiB0eXBlWyduYW1lJ107XHJcbn1cclxuZXhwb3J0cy5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyA9IGdldFR5cGVOYW1lRm9yRGVidWdnaW5nO1xyXG5leHBvcnRzLk1hdGggPSBfZ2xvYmFsLk1hdGg7XHJcbmV4cG9ydHMuRGF0ZSA9IF9nbG9iYWwuRGF0ZTtcclxudmFyIGFzc2VydGlvbnNFbmFibGVkXyA9IHR5cGVvZiBfZ2xvYmFsWydhc3NlcnQnXSAhPT0gJ3VuZGVmaW5lZCc7XHJcbmZ1bmN0aW9uIGFzc2VydGlvbnNFbmFibGVkKCkge1xyXG4gICAgcmV0dXJuIGFzc2VydGlvbnNFbmFibGVkXztcclxufVxyXG5leHBvcnRzLmFzc2VydGlvbnNFbmFibGVkID0gYXNzZXJ0aW9uc0VuYWJsZWQ7XHJcbi8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxyXG4vLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcclxuLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcclxuX2dsb2JhbC5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoYXNzZXJ0aW9uc0VuYWJsZWRfKSB7XHJcbiAgICAgICAgX2dsb2JhbFsnYXNzZXJ0J10uY2FsbChjb25kaXRpb24pO1xyXG4gICAgfVxyXG59O1xyXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG5lZWRlZCBvbmx5IHRvIHByb3Blcmx5IHN1cHBvcnQgRGFydCdzIGNvbnN0IGV4cHJlc3Npb25zXHJcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci90czJkYXJ0L3B1bGwvMTUxIGZvciBtb3JlIGluZm9cclxuZnVuY3Rpb24gQ09OU1RfRVhQUihleHByKSB7XHJcbiAgICByZXR1cm4gZXhwcjtcclxufVxyXG5leHBvcnRzLkNPTlNUX0VYUFIgPSBDT05TVF9FWFBSO1xyXG5mdW5jdGlvbiBDT05TVCgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQ7IH07XHJcbn1cclxuZXhwb3J0cy5DT05TVCA9IENPTlNUO1xyXG5mdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXNQcmVzZW50ID0gaXNQcmVzZW50O1xyXG5mdW5jdGlvbiBpc0JsYW5rKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzQmxhbmsgPSBpc0JsYW5rO1xyXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xyXG59XHJcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcclxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcclxuZnVuY3Rpb24gaXNUeXBlKG9iaikge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqKTtcclxufVxyXG5leHBvcnRzLmlzVHlwZSA9IGlzVHlwZTtcclxuZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXNTdHJpbmdNYXAgPSBpc1N0cmluZ01hcDtcclxuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIF9nbG9iYWwuUHJvbWlzZTtcclxufVxyXG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcclxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XHJcbn1cclxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcclxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xyXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgZXhwb3J0cy5EYXRlICYmICFpc05hTihvYmoudmFsdWVPZigpKTtcclxufVxyXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcclxuZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XHJcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgIH1cclxuICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4ubmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XHJcbiAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoXCJcXG5cIik7XHJcbiAgICByZXR1cm4gKG5ld0xpbmVJbmRleCA9PT0gLTEpID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xyXG4vLyBzZXJpYWxpemUgLyBkZXNlcmlhbGl6ZSBlbnVtIGV4aXN0IG9ubHkgZm9yIGNvbnNpc3RlbmN5IHdpdGggZGFydCBBUElcclxuLy8gZW51bXMgaW4gdHlwZXNjcmlwdCBkb24ndCBuZWVkIHRvIGJlIHNlcmlhbGl6ZWRcclxuZnVuY3Rpb24gc2VyaWFsaXplRW51bSh2YWwpIHtcclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZXhwb3J0cy5zZXJpYWxpemVFbnVtID0gc2VyaWFsaXplRW51bTtcclxuZnVuY3Rpb24gZGVzZXJpYWxpemVFbnVtKHZhbCwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbmV4cG9ydHMuZGVzZXJpYWxpemVFbnVtID0gZGVzZXJpYWxpemVFbnVtO1xyXG52YXIgU3RyaW5nV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTsgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdCA9IGZ1bmN0aW9uIChzLCBpbmRleCkgeyByZXR1cm4gcy5jaGFyQ29kZUF0KGluZGV4KTsgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChzLCBzMikgeyByZXR1cm4gcyA9PT0gczI7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xyXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcclxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7IGZyb20gPSAwOyB9XHJcbiAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nV3JhcHBlci50b1VwcGVyQ2FzZSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnRvTG93ZXJDYXNlID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTsgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzLCBzdGFydCkgeyByZXR1cm4gcy5zdGFydHNXaXRoKHN0YXJ0KTsgfTtcclxuICAgIFN0cmluZ1dyYXBwZXIuc3Vic3RyaW5nID0gZnVuY3Rpb24gKHMsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBzLnN1YnN0cmluZyhzdGFydCwgZW5kID09PSBudWxsID8gdW5kZWZpbmVkIDogZW5kKTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQgPSBmdW5jdGlvbiAocywgZnJvbSwgY2IpIHtcclxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNldCAmIHN0cmluZyBmcm9tIHRoZSByZXN1bHQgYXJyYXlcclxuICAgICAgICAgICAgbWF0Y2hlcy5zcGxpY2UoLTIsIDIpO1xyXG4gICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbWF0Y2gsIHAxLCAuLi4sIHBuXHJcbiAgICAgICAgICAgIHJldHVybiBjYihtYXRjaGVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKHMsIHN1YnN0cikgeyByZXR1cm4gcy5pbmRleE9mKHN1YnN0cikgIT0gLTE7IH07XHJcbiAgICBTdHJpbmdXcmFwcGVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0cmluZ1dyYXBwZXIgPSBTdHJpbmdXcmFwcGVyO1xyXG52YXIgU3RyaW5nSm9pbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0cmluZ0pvaW5lcihwYXJ0cykge1xyXG4gICAgICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7IHBhcnRzID0gW107IH1cclxuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXJ0KSB7IHRoaXMucGFydHMucHVzaChwYXJ0KTsgfTtcclxuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnRzLmpvaW4oXCJcIik7IH07XHJcbiAgICByZXR1cm4gU3RyaW5nSm9pbmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0cmluZ0pvaW5lciA9IFN0cmluZ0pvaW5lcjtcclxudmFyIE51bWJlclBhcnNlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE51bWJlclBhcnNlRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOdW1iZXJQYXJzZUVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgTnVtYmVyUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lc3NhZ2U7IH07XHJcbiAgICByZXR1cm4gTnVtYmVyUGFyc2VFcnJvcjtcclxufSkoRXJyb3IpO1xyXG5leHBvcnRzLk51bWJlclBhcnNlRXJyb3IgPSBOdW1iZXJQYXJzZUVycm9yO1xyXG52YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xyXG4gICAgTnVtYmVyV3JhcHBlci5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09PSBiOyB9O1xyXG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xyXG4gICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOdW1iZXJQYXJzZUVycm9yKFwiSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nIFwiICsgdGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUludCA9IGZ1bmN0aW9uICh0ZXh0LCByYWRpeCkge1xyXG4gICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xyXG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOV0rJC8udGVzdCh0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyYWRpeCA9PSAxNikge1xyXG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOdW1iZXJQYXJzZUVycm9yKFwiSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nIFwiICsgdGV4dCArIFwiIGluIGJhc2UgXCIgK1xyXG4gICAgICAgICAgICByYWRpeCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogTmFOIGlzIGEgdmFsaWQgbGl0ZXJhbCBidXQgaXMgcmV0dXJuZWQgYnkgcGFyc2VGbG9hdCB0byBpbmRpY2F0ZSBhbiBlcnJvci5cclxuICAgIE51bWJlcldyYXBwZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBwYXJzZUZsb2F0KHRleHQpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5hTjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOdW1iZXJXcmFwcGVyLmlzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTih2YWx1ZSk7IH07XHJcbiAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XHJcbiAgICByZXR1cm4gTnVtYmVyV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5OdW1iZXJXcmFwcGVyID0gTnVtYmVyV3JhcHBlcjtcclxuZXhwb3J0cy5SZWdFeHAgPSBfZ2xvYmFsLlJlZ0V4cDtcclxudmFyIFJlZ0V4cFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVnRXhwV3JhcHBlcigpIHtcclxuICAgIH1cclxuICAgIFJlZ0V4cFdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHJlZ0V4cFN0ciwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9ICcnOyB9XHJcbiAgICAgICAgZmxhZ3MgPSBmbGFncy5yZXBsYWNlKC9nL2csICcnKTtcclxuICAgICAgICByZXR1cm4gbmV3IF9nbG9iYWwuUmVnRXhwKHJlZ0V4cFN0ciwgZmxhZ3MgKyAnZycpO1xyXG4gICAgfTtcclxuICAgIFJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XHJcbiAgICAgICAgLy8gUmVzZXQgbXVsdGltYXRjaCByZWdleCBzdGF0ZVxyXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiByZWdFeHAuZXhlYyhpbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgUmVnRXhwV3JhcHBlci50ZXN0ID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcclxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4gcmVnRXhwLnRlc3QoaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFJlZ0V4cFdyYXBwZXIubWF0Y2hlciA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XHJcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggc3RhdGUgZm9yIHRoZSBjYXNlXHJcbiAgICAgICAgLy8gc29tZW9uZSBkaWQgbm90IGxvb3Agb3ZlciBhbGwgbWF0Y2hlc1xyXG4gICAgICAgIC8vIGxhc3QgdGltZS5cclxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4geyByZTogcmVnRXhwLCBpbnB1dDogaW5wdXQgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVnRXhwV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZWdFeHBXcmFwcGVyID0gUmVnRXhwV3JhcHBlcjtcclxudmFyIFJlZ0V4cE1hdGNoZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZ0V4cE1hdGNoZXJXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgUmVnRXhwTWF0Y2hlcldyYXBwZXIubmV4dCA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIucmUuZXhlYyhtYXRjaGVyLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVnRXhwTWF0Y2hlcldyYXBwZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVnRXhwTWF0Y2hlcldyYXBwZXIgPSBSZWdFeHBNYXRjaGVyV3JhcHBlcjtcclxudmFyIEZ1bmN0aW9uV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdW5jdGlvbldyYXBwZXIoKSB7XHJcbiAgICB9XHJcbiAgICBGdW5jdGlvbldyYXBwZXIuYXBwbHkgPSBmdW5jdGlvbiAoZm4sIHBvc0FyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KG51bGwsIHBvc0FyZ3MpOyB9O1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uV3JhcHBlcjtcclxufSkoKTtcclxuZXhwb3J0cy5GdW5jdGlvbldyYXBwZXIgPSBGdW5jdGlvbldyYXBwZXI7XHJcbi8vIEpTIGhhcyBOYU4gIT09IE5hTlxyXG5mdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcclxufVxyXG5leHBvcnRzLmxvb3NlSWRlbnRpY2FsID0gbG9vc2VJZGVudGljYWw7XHJcbi8vIEpTIGNvbnNpZGVycyBOYU4gaXMgdGhlIHNhbWUgYXMgTmFOIGZvciBtYXAgS2V5ICh3aGlsZSBOYU4gIT09IE5hTiBvdGhlcndpc2UpXHJcbi8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXBcclxuZnVuY3Rpb24gZ2V0TWFwS2V5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZXhwb3J0cy5nZXRNYXBLZXkgPSBnZXRNYXBLZXk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsYW5rKG9iaikge1xyXG4gICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IG51bGwgOiBvYmo7XHJcbn1cclxuZXhwb3J0cy5ub3JtYWxpemVCbGFuayA9IG5vcm1hbGl6ZUJsYW5rO1xyXG5mdW5jdGlvbiBub3JtYWxpemVCb29sKG9iaikge1xyXG4gICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IGZhbHNlIDogb2JqO1xyXG59XHJcbmV4cG9ydHMubm9ybWFsaXplQm9vbCA9IG5vcm1hbGl6ZUJvb2w7XHJcbmZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xyXG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIpO1xyXG59XHJcbmV4cG9ydHMuaXNKc09iamVjdCA9IGlzSnNPYmplY3Q7XHJcbmZ1bmN0aW9uIHByaW50KG9iaikge1xyXG4gICAgY29uc29sZS5sb2cob2JqKTtcclxufVxyXG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XHJcbi8vIENhbid0IGJlIGFsbCB1cHBlcmNhc2UgYXMgb3VyIHRyYW5zcGlsZXIgd291bGQgdGhpbmsgaXQgaXMgYSBzcGVjaWFsIGRpcmVjdGl2ZS4uLlxyXG52YXIgSnNvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKc29uKCkge1xyXG4gICAgfVxyXG4gICAgSnNvbi5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBfZ2xvYmFsLkpTT04ucGFyc2Uocyk7IH07XHJcbiAgICBKc29uLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gX2dsb2JhbC5KU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSnNvbjtcclxufSkoKTtcclxuZXhwb3J0cy5Kc29uID0gSnNvbjtcclxudmFyIERhdGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGVXcmFwcGVyKCkge1xyXG4gICAgfVxyXG4gICAgRGF0ZVdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIGlmIChtb250aCA9PT0gdm9pZCAwKSB7IG1vbnRoID0gMTsgfVxyXG4gICAgICAgIGlmIChkYXkgPT09IHZvaWQgMCkgeyBkYXkgPSAxOyB9XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IHZvaWQgMCkgeyBob3VyID0gMDsgfVxyXG4gICAgICAgIGlmIChtaW51dGVzID09PSB2b2lkIDApIHsgbWludXRlcyA9IDA7IH1cclxuICAgICAgICBpZiAoc2Vjb25kcyA9PT0gdm9pZCAwKSB7IHNlY29uZHMgPSAwOyB9XHJcbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwKSB7IG1pbGxpc2Vjb25kcyA9IDA7IH1cclxuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlV3JhcHBlci5mcm9tSVNPU3RyaW5nID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZShzdHIpOyB9O1xyXG4gICAgRGF0ZVdyYXBwZXIuZnJvbU1pbGxpcyA9IGZ1bmN0aW9uIChtcykgeyByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZShtcyk7IH07XHJcbiAgICBEYXRlV3JhcHBlci50b01pbGxpcyA9IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfTtcclxuICAgIERhdGVXcmFwcGVyLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoKTsgfTtcclxuICAgIERhdGVXcmFwcGVyLnRvSnNvbiA9IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnRvSlNPTigpOyB9O1xyXG4gICAgcmV0dXJuIERhdGVXcmFwcGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkRhdGVXcmFwcGVyID0gRGF0ZVdyYXBwZXI7XHJcbmZ1bmN0aW9uIHNldFZhbHVlT25QYXRoKGdsb2JhbCwgcGF0aCwgdmFsdWUpIHtcclxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHZhciBvYmogPSBnbG9iYWw7XHJcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICBvYmogPSB7fTtcclxuICAgIH1cclxuICAgIG9ialtwYXJ0cy5zaGlmdCgpXSA9IHZhbHVlO1xyXG59XHJcbmV4cG9ydHMuc2V0VmFsdWVPblBhdGggPSBzZXRWYWx1ZU9uUGF0aDtcclxudmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xyXG4gICAgaWYgKGlzQmxhbmsoX3N5bWJvbEl0ZXJhdG9yKSkge1xyXG4gICAgICAgIGlmIChpc1ByZXNlbnQoU3ltYm9sKSAmJiBpc1ByZXNlbnQoU3ltYm9sLml0ZXJhdG9yKSkge1xyXG4gICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcC5wcm90b3R5cGUpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xyXG59XHJcbmV4cG9ydHMuZ2V0U3ltYm9sSXRlcmF0b3IgPSBnZXRTeW1ib2xJdGVyYXRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbmV4cG9ydHMuTWF0aCA9IGxhbmdfMS5nbG9iYWwuTWF0aDtcclxuZXhwb3J0cy5OYU4gPSB0eXBlb2YgZXhwb3J0cy5OYU47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGlzIG1vZHVsZSBpcyB1c2VkIGZvciBoYW5kbGluZyB1c2VyIGlucHV0LCBieSBkZWZpbmluZyBhbmQgYnVpbGRpbmcgYSB7QGxpbmsgQ29udHJvbEdyb3VwfSB0aGF0XHJcbiAqIGNvbnNpc3RzIG9mXHJcbiAqIHtAbGluayBDb250cm9sfSBvYmplY3RzLCBhbmQgbWFwcGluZyB0aGVtIG9udG8gdGhlIERPTS4ge0BsaW5rIENvbnRyb2x9IG9iamVjdHMgY2FuIHRoZW4gYmUgdXNlZFxyXG4gKiB0byByZWFkIGluZm9ybWF0aW9uXHJcbiAqIGZyb20gdGhlIGZvcm0gRE9NIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGBhbmd1bGFyMmAgbW9kdWxlOyB5b3UgbXVzdCBpbXBvcnQgdGhlIGZvcm1zIG1vZHVsZVxyXG4gKiBleHBsaWNpdGx5LlxyXG4gKlxyXG4gKi9cclxudmFyIG1vZGVsXzEgPSByZXF1aXJlKCcuL2Zvcm1zL21vZGVsJyk7XHJcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sID0gbW9kZWxfMS5BYnN0cmFjdENvbnRyb2w7XHJcbmV4cG9ydHMuQ29udHJvbCA9IG1vZGVsXzEuQ29udHJvbDtcclxuZXhwb3J0cy5Db250cm9sR3JvdXAgPSBtb2RlbF8xLkNvbnRyb2xHcm91cDtcclxuZXhwb3J0cy5Db250cm9sQXJyYXkgPSBtb2RlbF8xLkNvbnRyb2xBcnJheTtcclxudmFyIGFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUnKTtcclxuZXhwb3J0cy5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSBhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcclxudmFyIGNvbnRyb2xfY29udGFpbmVyXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvY29udHJvbF9jb250YWluZXInKTtcclxuZXhwb3J0cy5Db250cm9sQ29udGFpbmVyID0gY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyO1xyXG52YXIgbmdfY29udHJvbF9uYW1lXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9uYW1lJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sTmFtZSA9IG5nX2NvbnRyb2xfbmFtZV8xLk5nQ29udHJvbE5hbWU7XHJcbnZhciBuZ19mb3JtX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX2NvbnRyb2wnKTtcclxuZXhwb3J0cy5OZ0Zvcm1Db250cm9sID0gbmdfZm9ybV9jb250cm9sXzEuTmdGb3JtQ29udHJvbDtcclxudmFyIG5nX21vZGVsXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfbW9kZWwnKTtcclxuZXhwb3J0cy5OZ01vZGVsID0gbmdfbW9kZWxfMS5OZ01vZGVsO1xyXG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2wnKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2wgPSBuZ19jb250cm9sXzEuTmdDb250cm9sO1xyXG52YXIgbmdfY29udHJvbF9ncm91cF8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAnKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xHcm91cCA9IG5nX2NvbnRyb2xfZ3JvdXBfMS5OZ0NvbnRyb2xHcm91cDtcclxudmFyIG5nX2Zvcm1fbW9kZWxfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX21vZGVsJyk7XHJcbmV4cG9ydHMuTmdGb3JtTW9kZWwgPSBuZ19mb3JtX21vZGVsXzEuTmdGb3JtTW9kZWw7XHJcbnZhciBuZ19mb3JtXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfZm9ybScpO1xyXG5leHBvcnRzLk5nRm9ybSA9IG5nX2Zvcm1fMS5OZ0Zvcm07XHJcbnZhciBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvZGVmYXVsdF92YWx1ZV9hY2Nlc3NvcicpO1xyXG5leHBvcnRzLkRlZmF1bHRWYWx1ZUFjY2Vzc29yID0gZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xLkRlZmF1bHRWYWx1ZUFjY2Vzc29yO1xyXG52YXIgbmdfY29udHJvbF9zdGF0dXNfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX3N0YXR1cycpO1xyXG5leHBvcnRzLk5nQ29udHJvbFN0YXR1cyA9IG5nX2NvbnRyb2xfc3RhdHVzXzEuTmdDb250cm9sU3RhdHVzO1xyXG52YXIgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9jaGVja2JveF92YWx1ZV9hY2Nlc3NvcicpO1xyXG5leHBvcnRzLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8xLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbnZhciBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL3NlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbmV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5nU2VsZWN0T3B0aW9uO1xyXG5leHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcclxudmFyIGRpcmVjdGl2ZXNfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcycpO1xyXG5leHBvcnRzLkZPUk1fRElSRUNUSVZFUyA9IGRpcmVjdGl2ZXNfMS5GT1JNX0RJUkVDVElWRVM7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuL2Zvcm1zL3ZhbGlkYXRvcnMnKTtcclxuZXhwb3J0cy5OR19WQUxJREFUT1JTID0gdmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlM7XHJcbmV4cG9ydHMuVmFsaWRhdG9ycyA9IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzO1xyXG52YXIgdmFsaWRhdG9yc18yID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMnKTtcclxuZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5SZXF1aXJlZFZhbGlkYXRvcjtcclxuZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuTWluTGVuZ3RoVmFsaWRhdG9yO1xyXG5leHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5NYXhMZW5ndGhWYWxpZGF0b3I7XHJcbnZhciBmb3JtX2J1aWxkZXJfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZm9ybV9idWlsZGVyJyk7XHJcbmV4cG9ydHMuRm9ybUJ1aWxkZXIgPSBmb3JtX2J1aWxkZXJfMS5Gb3JtQnVpbGRlcjtcclxudmFyIGZvcm1fYnVpbGRlcl8yID0gcmVxdWlyZSgnLi9mb3Jtcy9mb3JtX2J1aWxkZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vZmFjYWRlL2xhbmcnKTtcclxuLyoqXHJcbiAqIFNob3J0aGFuZCBzZXQgb2YgcHJvdmlkZXJzIHVzZWQgZm9yIGJ1aWxkaW5nIEFuZ3VsYXIgZm9ybXMuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGJvb3RzdHJhcChNeUFwcCwgW0ZPUk1fUFJPVklERVJTXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5GT1JNX1BST1ZJREVSUyA9IGxhbmdfMS5DT05TVF9FWFBSKFtmb3JtX2J1aWxkZXJfMi5Gb3JtQnVpbGRlcl0pO1xyXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmV4cG9ydHMuRk9STV9CSU5ESU5HUyA9IGV4cG9ydHMuRk9STV9QUk9WSURFUlM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1zLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIG5nX2NvbnRyb2xfbmFtZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfbmFtZScpO1xyXG52YXIgbmdfZm9ybV9jb250cm9sXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9ybV9jb250cm9sJyk7XHJcbnZhciBuZ19tb2RlbF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX21vZGVsJyk7XHJcbnZhciBuZ19jb250cm9sX2dyb3VwXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9ncm91cCcpO1xyXG52YXIgbmdfZm9ybV9tb2RlbF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fbW9kZWwnKTtcclxudmFyIG5nX2Zvcm1fMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3JtJyk7XHJcbnZhciBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZGVmYXVsdF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9jaGVja2JveF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgbmdfY29udHJvbF9zdGF0dXNfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sX3N0YXR1cycpO1xyXG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMnKTtcclxudmFyIG5nX2NvbnRyb2xfbmFtZV8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfbmFtZScpO1xyXG5leHBvcnRzLk5nQ29udHJvbE5hbWUgPSBuZ19jb250cm9sX25hbWVfMi5OZ0NvbnRyb2xOYW1lO1xyXG52YXIgbmdfZm9ybV9jb250cm9sXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9ybV9jb250cm9sJyk7XHJcbmV4cG9ydHMuTmdGb3JtQ29udHJvbCA9IG5nX2Zvcm1fY29udHJvbF8yLk5nRm9ybUNvbnRyb2w7XHJcbnZhciBuZ19tb2RlbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX21vZGVsJyk7XHJcbmV4cG9ydHMuTmdNb2RlbCA9IG5nX21vZGVsXzIuTmdNb2RlbDtcclxudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sID0gbmdfY29udHJvbF8xLk5nQ29udHJvbDtcclxudmFyIG5nX2NvbnRyb2xfZ3JvdXBfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sX2dyb3VwJyk7XHJcbmV4cG9ydHMuTmdDb250cm9sR3JvdXAgPSBuZ19jb250cm9sX2dyb3VwXzIuTmdDb250cm9sR3JvdXA7XHJcbnZhciBuZ19mb3JtX21vZGVsXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9ybV9tb2RlbCcpO1xyXG5leHBvcnRzLk5nRm9ybU1vZGVsID0gbmdfZm9ybV9tb2RlbF8yLk5nRm9ybU1vZGVsO1xyXG52YXIgbmdfZm9ybV8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm0nKTtcclxuZXhwb3J0cy5OZ0Zvcm0gPSBuZ19mb3JtXzIuTmdGb3JtO1xyXG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcclxuZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMi5EZWZhdWx0VmFsdWVBY2Nlc3NvcjtcclxudmFyIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvY2hlY2tib3hfdmFsdWVfYWNjZXNzb3InKTtcclxuZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMi5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xyXG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG5leHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMi5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcclxuZXhwb3J0cy5OZ1NlbGVjdE9wdGlvbiA9IHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzIuTmdTZWxlY3RPcHRpb247XHJcbnZhciB2YWxpZGF0b3JzXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycycpO1xyXG5leHBvcnRzLlJlcXVpcmVkVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLlJlcXVpcmVkVmFsaWRhdG9yO1xyXG5leHBvcnRzLk1pbkxlbmd0aFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5NaW5MZW5ndGhWYWxpZGF0b3I7XHJcbmV4cG9ydHMuTWF4TGVuZ3RoVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLk1heExlbmd0aFZhbGlkYXRvcjtcclxudmFyIG5nX2NvbnRyb2xfc3RhdHVzXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9zdGF0dXMnKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBuZ19jb250cm9sX3N0YXR1c18yLk5nQ29udHJvbFN0YXR1cztcclxuLyoqXHJcbiAqXHJcbiAqIEEgbGlzdCBvZiBhbGwgdGhlIGZvcm0gZGlyZWN0aXZlcyB1c2VkIGFzIHBhcnQgb2YgYSBgQFZpZXdgIGFubm90YXRpb24uXHJcbiAqXHJcbiAqICBUaGlzIGlzIGEgc2hvcnRoYW5kIGZvciBpbXBvcnRpbmcgdGhlbSBlYWNoIGluZGl2aWR1YWxseS5cclxuICpcclxuICogIyMjIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIE15QXBwIHt9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5GT1JNX0RJUkVDVElWRVMgPSBsYW5nXzEuQ09OU1RfRVhQUihbXHJcbiAgICBuZ19jb250cm9sX25hbWVfMS5OZ0NvbnRyb2xOYW1lLFxyXG4gICAgbmdfY29udHJvbF9ncm91cF8xLk5nQ29udHJvbEdyb3VwLFxyXG4gICAgbmdfZm9ybV9jb250cm9sXzEuTmdGb3JtQ29udHJvbCxcclxuICAgIG5nX21vZGVsXzEuTmdNb2RlbCxcclxuICAgIG5nX2Zvcm1fbW9kZWxfMS5OZ0Zvcm1Nb2RlbCxcclxuICAgIG5nX2Zvcm1fMS5OZ0Zvcm0sXHJcbiAgICBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5nU2VsZWN0T3B0aW9uLFxyXG4gICAgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xLkRlZmF1bHRWYWx1ZUFjY2Vzc29yLFxyXG4gICAgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMS5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxyXG4gICAgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcixcclxuICAgIG5nX2NvbnRyb2xfc3RhdHVzXzEuTmdDb250cm9sU3RhdHVzLFxyXG4gICAgdmFsaWRhdG9yc18xLlJlcXVpcmVkVmFsaWRhdG9yLFxyXG4gICAgdmFsaWRhdG9yc18xLk1pbkxlbmd0aFZhbGlkYXRvcixcclxuICAgIHZhbGlkYXRvcnNfMS5NYXhMZW5ndGhWYWxpZGF0b3JcclxuXSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC52YWxpZCA6IG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5lcnJvcnMgOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnByaXN0aW5lIDogbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wuZGlydHkgOiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnRvdWNoZWQgOiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudW50b3VjaGVkIDogbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xyXG59KSgpO1xyXG5leHBvcnRzLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIHJlbmRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVuZGVyJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XHJcbnZhciBDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUiwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLCBtdWx0aTogdHJ1ZSB9KSk7XHJcbi8qKlxyXG4gKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxyXG4gKlxyXG4gKiAgIyBFeGFtcGxlXHJcbiAqICBgYGBcclxuICogIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbbmctY29udHJvbF09XCJyZW1lbWJlckxvZ2luXCI+XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcclxuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH1cclxuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgc2hhcmVkXzEuc2V0UHJvcGVydHkodGhpcy5fcmVuZGVyZXIsIHRoaXMuX2VsZW1lbnRSZWYsIFwiY2hlY2tlZFwiLCB2YWx1ZSk7IH07XHJcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcclxuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XHJcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW25nLWNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nLWZvcm0tY29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmctbW9kZWxdJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC5jaGVja2VkKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXHJcbiAgICAgICAgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JlbmRlcl8xLlJlbmRlcmVyLCBsaW5rZXJfMS5FbGVtZW50UmVmXSlcclxuICAgIF0sIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IpO1xyXG4gICAgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoJy4vYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUnKTtcclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHRoYXQgY29udGFpbnMgbXVsdGlwbGUge0BsaW5rIE5nQ29udHJvbH0uXHJcbiAqXHJcbiAqIE9ubHkgdXNlZCBieSB0aGUgZm9ybXMgbW9kdWxlLlxyXG4gKi9cclxudmFyIENvbnRyb2xDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRyb2xDb250YWluZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250cm9sQ29udGFpbmVyKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbENvbnRhaW5lci5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBDb250cm9sQ29udGFpbmVyO1xyXG59KShhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSk7XHJcbmV4cG9ydHMuQ29udHJvbENvbnRhaW5lciA9IENvbnRyb2xDb250YWluZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyb2xfY29udGFpbmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG5leHBvcnRzLk5HX1ZBTFVFX0FDQ0VTU09SID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJOZ1ZhbHVlQWNjZXNzb3JcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sX3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBsaW5rZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2xpbmtlcicpO1xyXG52YXIgcmVuZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXInKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgREVGQVVMVF9WQUxVRV9BQ0NFU1NPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUiwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yOyB9KSwgbXVsdGk6IHRydWUgfSkpO1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxyXG4gKiB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBOZ0Zvcm1Db250cm9sfSwgYW5kIHtAbGluayBOZ0NvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxyXG4gKlxyXG4gKiAgIyBFeGFtcGxlXHJcbiAqICBgYGBcclxuICogIDxpbnB1dCB0eXBlPVwidGV4dFwiIFsobmctbW9kZWwpXT1cInNlYXJjaFF1ZXJ5XCI+XHJcbiAqICBgYGBcclxuICovXHJcbnZhciBEZWZhdWx0VmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZWZhdWx0VmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xyXG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gbGFuZ18xLmlzQmxhbmsodmFsdWUpID8gJycgOiB2YWx1ZTtcclxuICAgICAgICBzaGFyZWRfMS5zZXRQcm9wZXJ0eSh0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudFJlZiwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XHJcbiAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcclxuICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tuZy1jb250cm9sXSxbbmctbW9kZWxdLFtuZy1mb3JtLWNvbnRyb2xdJyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcclxuICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcclxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cclxuICAgICAgICB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbcmVuZGVyXzEuUmVuZGVyZXIsIGxpbmtlcl8xLkVsZW1lbnRSZWZdKVxyXG4gICAgXSwgRGVmYXVsdFZhbHVlQWNjZXNzb3IpO1xyXG4gICAgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLkRlZmF1bHRWYWx1ZUFjY2Vzc29yID0gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRfdmFsdWVfYWNjZXNzb3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xID0gcmVxdWlyZSgnLi9hYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZScpO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIGNvbnRyb2wgZGlyZWN0aXZlIGV4dGVuZC5cclxuICogSXQgYmluZHMgYSB7QGxpbmsgQ29udHJvbH0gb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXHJcbiAqL1xyXG4vLyBDYW5ub3QgY3VycmVudGx5IGJlIGFic3RyYWN0IGJlY2F1c2UgaXQgd291bGQgY29udGFpblxyXG4vLyBhbiBhYnN0cmFjdCBtZXRob2QgaW4gdGhlIHB1YmxpYyBBUEksIGFuZCB3ZSBjYW5ub3QgcmVmbGVjdFxyXG4vLyBvbiB0aGF0IGluIERhcnQgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJ0LWxhbmcvc2RrL2lzc3Vlcy8xODcyMVxyXG4vLyBBbHNvIHdlIGRvbid0IGhhdmUgYWJzdHJhY3Qgc2V0dGVycywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDY2OVxyXG52YXIgTmdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0NvbnRyb2wsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ0NvbnRyb2woKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nQ29udHJvbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHsgfTtcclxuICAgIHJldHVybiBOZ0NvbnRyb2w7XHJcbn0pKGFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlXzEuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKTtcclxuZXhwb3J0cy5OZ0NvbnRyb2wgPSBOZ0NvbnRyb2w7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2NvbnRyb2wuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcclxudmFyIGNvbnRyb2xHcm91cEJpbmRpbmcgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0NvbnRyb2xHcm91cDsgfSkgfSkpO1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgYmluZHMgYSBjb250cm9sIGdyb3VwIHRvIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgYXMgYSBjaGlsZCBvZiB7QGxpbmsgTmdGb3JtfSBvciB7QGxpbmsgTmdGb3JtTW9kZWx9LlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgdGhlIGNyZWRlbnRpYWxzIGFuZCBwZXJzb25hbCBjb250cm9sIGdyb3Vwcy5cclxuICogV2UgY2FuIHdvcmsgd2l0aCBlYWNoIGdyb3VwIHNlcGFyYXRlbHk6IGNoZWNrIGl0cyB2YWxpZGl0eSwgZ2V0IGl0cyB2YWx1ZSwgbGlzdGVuIHRvIGl0cyBjaGFuZ2VzLlxyXG4gKlxyXG4gKiAgYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICAgIHNlbGVjdG9yOiBcInNpZ251cC1jb21wXCIsXHJcbiAqICAgICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU10sXHJcbiAqICAgICAgdGVtcGxhdGU6IGBcclxuICogICAgICAgICAgICAgIDxmb3JtICNmPVwiZm9ybVwiIChzdWJtaXQpPSdvblNpZ25VcChmLnZhbHVlKSc+XHJcbiAqICAgICAgICAgICAgICAgIDxkaXYgbmctY29udHJvbC1ncm91cD0nY3JlZGVudGlhbHMnICNjcmVkZW50aWFscz1cImZvcm1cIj5cclxuICogICAgICAgICAgICAgICAgICBMb2dpbiA8aW5wdXQgdHlwZT0ndGV4dCcgbmctY29udHJvbD0nbG9naW4nPlxyXG4gKiAgICAgICAgICAgICAgICAgIFBhc3N3b3JkIDxpbnB1dCB0eXBlPSdwYXNzd29yZCcgbmctY29udHJvbD0ncGFzc3dvcmQnPlxyXG4gKiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICogICAgICAgICAgICAgICAgPGRpdiAqbmctaWY9XCIhY3JlZGVudGlhbHMudmFsaWRcIj5DcmVkZW50aWFscyBhcmUgaW52YWxpZDwvZGl2PlxyXG4gKlxyXG4gKiAgICAgICAgICAgICAgICA8ZGl2IG5nLWNvbnRyb2wtZ3JvdXA9J3BlcnNvbmFsJz5cclxuICogICAgICAgICAgICAgICAgICBOYW1lIDxpbnB1dCB0eXBlPSd0ZXh0JyBuZy1jb250cm9sPSduYW1lJz5cclxuICogICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAqICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nc3VibWl0Jz5TaWduIFVwITwvYnV0dG9uPlxyXG4gKiAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gKiAgICAgIGB9KVxyXG4gKiBjbGFzcyBTaWdudXBDb21wIHtcclxuICogIG9uU2lnblVwKHZhbHVlKSB7XHJcbiAqICAgIC8vIHZhbHVlID09PSB7XHJcbiAqICAgIC8vICBwZXJzb25hbDoge25hbWU6ICdzb21lIG5hbWUnfSxcclxuICogICAgLy8gIGNyZWRlbnRpYWxzOiB7bG9naW46ICdzb21lIGxvZ2luJywgcGFzc3dvcmQ6ICdzb21lIHBhc3N3b3JkJ319XHJcbiAqICB9XHJcbiAqIH1cclxuICpcclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nQ29udHJvbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0NvbnRyb2xHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE5nQ29udHJvbEdyb3VwKF9wYXJlbnQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xyXG4gICAgfVxyXG4gICAgTmdDb250cm9sR3JvdXAucHJvdG90eXBlLm9uSW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2xHcm91cCh0aGlzKTsgfTtcclxuICAgIE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sR3JvdXAodGhpcyk7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sR3JvdXAucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldENvbnRyb2xHcm91cCh0aGlzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sR3JvdXAucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0NvbnRyb2xHcm91cCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctY29udHJvbC1ncm91cF0nLFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW2NvbnRyb2xHcm91cEJpbmRpbmddLFxyXG4gICAgICAgICAgICBpbnB1dHM6IFsnbmFtZTogbmctY29udHJvbC1ncm91cCddLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ2Zvcm0nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLkhvc3QoKSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLlNraXBTZWxmKCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXJdKVxyXG4gICAgXSwgTmdDb250cm9sR3JvdXApO1xyXG4gICAgcmV0dXJuIE5nQ29udHJvbEdyb3VwO1xyXG59KShjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIpO1xyXG5leHBvcnRzLk5nQ29udHJvbEdyb3VwID0gTmdDb250cm9sR3JvdXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2NvbnRyb2xfZ3JvdXAuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcclxudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vbmdfY29udHJvbCcpO1xyXG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XHJcbnZhciBjb250cm9sTmFtZUJpbmRpbmcgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihuZ19jb250cm9sXzEuTmdDb250cm9sLCB7IHVzZUV4aXN0aW5nOiBkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdDb250cm9sTmFtZTsgfSkgfSkpO1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgYmluZHMgYSBjb250cm9sIHdpdGggYSBzcGVjaWZpZWQgbmFtZSB0byBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge0BsaW5rIE5nRm9ybX0gb3Ige0BsaW5rIE5nRm9ybU1vZGVsfS5cclxuXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSB0aGUgbG9naW4gYW5kIHBhc3N3b3JkIGNvbnRyb2xzLlxyXG4gKiBXZSBjYW4gd29yayB3aXRoIGVhY2ggY29udHJvbCBzZXBhcmF0ZWx5OiBjaGVjayBpdHMgdmFsaWRpdHksIGdldCBpdHMgdmFsdWUsIGxpc3RlbiB0byBpdHNcclxuICogY2hhbmdlcy5cclxuICpcclxuICogIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICAgICBzZWxlY3RvcjogXCJsb2dpbi1jb21wXCIsXHJcbiAqICAgICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU10sXHJcbiAqICAgICAgdGVtcGxhdGU6IGBcclxuICogICAgICAgIDxmb3JtICNmPVwiZm9ybVwiIChzdWJtaXQpPSdvbkxvZ0luKGYudmFsdWUpJz5cclxuICogICAgICAgICAgTG9naW4gPGlucHV0IHR5cGU9J3RleHQnIG5nLWNvbnRyb2w9J2xvZ2luJyAjbD1cImZvcm1cIj5cclxuICogICAgICAgICAgPGRpdiAqbmctaWY9XCIhbC52YWxpZFwiPkxvZ2luIGlzIGludmFsaWQ8L2Rpdj5cclxuICpcclxuICogICAgICAgICAgUGFzc3dvcmQgPGlucHV0IHR5cGU9J3Bhc3N3b3JkJyBuZy1jb250cm9sPSdwYXNzd29yZCc+XHJcbiAqICAgICAgICAgIDxidXR0b24gdHlwZT0nc3VibWl0Jz5Mb2cgaW4hPC9idXR0b24+XHJcbiAqICAgICAgICA8L2Zvcm0+XHJcbiAqICAgICAgYH0pXHJcbiAqIGNsYXNzIExvZ2luQ29tcCB7XHJcbiAqICBvbkxvZ0luKHZhbHVlKTogdm9pZCB7XHJcbiAqICAgIC8vIHZhbHVlID09PSB7bG9naW46ICdzb21lIGxvZ2luJywgcGFzc3dvcmQ6ICdzb21lIHBhc3N3b3JkJ31cclxuICogIH1cclxuICogfVxyXG4gKiAgYGBgXHJcbiAqXHJcbiAqIFdlIGNhbiBhbHNvIHVzZSBuZy1tb2RlbCB0byBiaW5kIGEgZG9tYWluIG1vZGVsIHRvIHRoZSBmb3JtLlxyXG4gKlxyXG4gKiAgYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgICAgIHNlbGVjdG9yOiBcImxvZ2luLWNvbXBcIixcclxuICogICAgICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXSxcclxuICogICAgICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgICAgPGZvcm0gKHN1Ym1pdCk9J29uTG9nSW4oKSc+XHJcbiAqICAgICAgICAgIExvZ2luIDxpbnB1dCB0eXBlPSd0ZXh0JyBuZy1jb250cm9sPSdsb2dpbicgWyhuZy1tb2RlbCldPVwiY3JlZGVudGlhbHMubG9naW5cIj5cclxuICogICAgICAgICAgUGFzc3dvcmQgPGlucHV0IHR5cGU9J3Bhc3N3b3JkJyBuZy1jb250cm9sPSdwYXNzd29yZCdcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFsobmctbW9kZWwpXT1cImNyZWRlbnRpYWxzLnBhc3N3b3JkXCI+XHJcbiAqICAgICAgICAgIDxidXR0b24gdHlwZT0nc3VibWl0Jz5Mb2cgaW4hPC9idXR0b24+XHJcbiAqICAgICAgICA8L2Zvcm0+XHJcbiAqICAgICAgYH0pXHJcbiAqIGNsYXNzIExvZ2luQ29tcCB7XHJcbiAqICBjcmVkZW50aWFsczoge2xvZ2luOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nfTtcclxuICpcclxuICogIG9uTG9nSW4oKTogdm9pZCB7XHJcbiAqICAgIC8vIHRoaXMuY3JlZGVudGlhbHMubG9naW4gPT09IFwic29tZSBsb2dpblwiXHJcbiAqICAgIC8vIHRoaXMuY3JlZGVudGlhbHMucGFzc3dvcmQgPT09IFwic29tZSBwYXNzd29yZFwiXHJcbiAqICB9XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nQ29udHJvbE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5nQ29udHJvbE5hbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ0NvbnRyb2xOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xyXG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNoYXJlZF8xLnNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xyXG4gICAgfVxyXG4gICAgTmdDb250cm9sTmFtZS5wcm90b3R5cGUub25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFyZWRfMS5pc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5nQ29udHJvbE5hbWUucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7IH07XHJcbiAgICBOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XHJcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dCh0aGlzLnVwZGF0ZSwgbmV3VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8xLmNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sTmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sTmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Q29udHJvbCh0aGlzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sTmFtZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLmNvbXBvc2UodGhpcy52YWxpZGF0b3JzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0NvbnRyb2xOYW1lID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tuZy1jb250cm9sXScsXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbY29udHJvbE5hbWVCaW5kaW5nXSxcclxuICAgICAgICAgICAgaW5wdXRzOiBbJ25hbWU6IG5nQ29udHJvbCcsICdtb2RlbDogbmdNb2RlbCddLFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBbJ3VwZGF0ZTogbmdNb2RlbENoYW5nZSddLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ2Zvcm0nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLkhvc3QoKSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLlNraXBTZWxmKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgZGlfMS5PcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGRpXzEuSW5qZWN0KHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTKSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBkaV8xLk9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgZGlfMS5JbmplY3QoY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lciwgQXJyYXksIEFycmF5XSlcclxuICAgIF0sIE5nQ29udHJvbE5hbWUpO1xyXG4gICAgcmV0dXJuIE5nQ29udHJvbE5hbWU7XHJcbn0pKG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wpO1xyXG5leHBvcnRzLk5nQ29udHJvbE5hbWUgPSBOZ0NvbnRyb2xOYW1lO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19jb250cm9sX25hbWUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL25nX2NvbnRyb2wnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBOZ0NvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XHJcbiAgICAgICAgdGhpcy5fY2QgPSBjZDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NVbnRvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wudW50b3VjaGVkIDogZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVG91Y2hlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC50b3VjaGVkIDogZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzUHJpc3RpbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wucHJpc3RpbmUgOiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NEaXJ0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC5kaXJ0eSA6IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ZhbGlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzSW52YWxpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gIXRoaXMuX2NkLmNvbnRyb2wudmFsaWQgOiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nQ29udHJvbFN0YXR1cyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctY29udHJvbF0sW25nLW1vZGVsXSxbbmctZm9ybS1jb250cm9sXScsXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctdW50b3VjaGVkXSc6ICduZ0NsYXNzVW50b3VjaGVkJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnbmdDbGFzc1RvdWNoZWQnLFxyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctZGlydHldJzogJ25nQ2xhc3NEaXJ0eScsXHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICduZ0NsYXNzVmFsaWQnLFxyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5TZWxmKCkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtuZ19jb250cm9sXzEuTmdDb250cm9sXSlcclxuICAgIF0sIE5nQ29udHJvbFN0YXR1cyk7XHJcbiAgICByZXR1cm4gTmdDb250cm9sU3RhdHVzO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nQ29udHJvbFN0YXR1cyA9IE5nQ29udHJvbFN0YXR1cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfY29udHJvbF9zdGF0dXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb250cm9sX2NvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX2NvbnRhaW5lcicpO1xyXG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoJy4uL21vZGVsJyk7XHJcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XHJcbnZhciBmb3JtRGlyZWN0aXZlUHJvdmlkZXIgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIsIHsgdXNlRXhpc3Rpbmc6IGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm07IH0pIH0pKTtcclxuLyoqXHJcbiAqIElmIGBOZ0Zvcm1gIGlzIGJvdW5kIGluIGEgY29tcG9uZW50LCBgPGZvcm0+YCBlbGVtZW50cyBpbiB0aGF0IGNvbXBvbmVudCB3aWxsIGJlXHJcbiAqIHVwZ3JhZGVkIHRvIHVzZSB0aGUgQW5ndWxhciBmb3JtIHN5c3RlbS5cclxuICpcclxuICogIyBUeXBpY2FsIFVzZVxyXG4gKlxyXG4gKiBJbmNsdWRlIGBGT1JNX0RJUkVDVElWRVNgIGluIHRoZSBgZGlyZWN0aXZlc2Agc2VjdGlvbiBvZiBhIHtAbGluayBWaWV3fSBhbm5vdGF0aW9uXHJcbiAqIHRvIHVzZSBgTmdGb3JtYCBhbmQgaXRzIGFzc29jaWF0ZWQgY29udHJvbHMuXHJcbiAqXHJcbiAqICMgU3RydWN0dXJlXHJcbiAqXHJcbiAqIEFuIEFuZ3VsYXIgZm9ybSBpcyBhIGNvbGxlY3Rpb24gb2YgYENvbnRyb2xgcyBpbiBzb21lIGhpZXJhcmNoeS5cclxuICogYENvbnRyb2xgcyBjYW4gYmUgYXQgdGhlIHRvcCBsZXZlbCBvciBjYW4gYmUgb3JnYW5pemVkIGluIGBDb250cm9sR3JvdXBgc1xyXG4gKiBvciBgQ29udHJvbEFycmF5YHMuIFRoaXMgaGllcmFyY2h5IGlzIHJlZmxlY3RlZCBpbiB0aGUgZm9ybSdzIGB2YWx1ZWAsIGFcclxuICogSlNPTiBvYmplY3QgdGhhdCBtaXJyb3JzIHRoZSBmb3JtIHN0cnVjdHVyZS5cclxuICpcclxuICogIyBTdWJtaXNzaW9uXHJcbiAqXHJcbiAqIFRoZSBgbmctc3VibWl0YCBldmVudCBzaWduYWxzIHdoZW4gdGhlIHVzZXIgdHJpZ2dlcnMgYSBmb3JtIHN1Ym1pc3Npb24uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9sdGRnWWo0UDBpWTY0QVI3MUVwTD9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiAgYGBgdHlwZXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxkaXY+XHJcbiAqICAgICAgIDxwPlN1Ym1pdCB0aGUgZm9ybSB0byBzZWUgdGhlIGRhdGEgb2JqZWN0IEFuZ3VsYXIgYnVpbGRzPC9wPlxyXG4gKiAgICAgICA8aDI+TmdGb3JtIGRlbW88L2gyPlxyXG4gKiAgICAgICA8Zm9ybSAjZj1cImZvcm1cIiAobmctc3VibWl0KT1cIm9uU3VibWl0KGYudmFsdWUpXCI+XHJcbiAqICAgICAgICAgPGgzPkNvbnRyb2wgZ3JvdXA6IGNyZWRlbnRpYWxzPC9oMz5cclxuICogICAgICAgICA8ZGl2IG5nLWNvbnRyb2wtZ3JvdXA9XCJjcmVkZW50aWFsc1wiPlxyXG4gKiAgICAgICAgICAgPHA+TG9naW46IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLWNvbnRyb2w9XCJsb2dpblwiPjwvcD5cclxuICogICAgICAgICAgIDxwPlBhc3N3b3JkOiA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgbmctY29udHJvbD1cInBhc3N3b3JkXCI+PC9wPlxyXG4gKiAgICAgICAgIDwvZGl2PlxyXG4gKiAgICAgICAgIDxoMz5Db250cm9sIGdyb3VwOiBwZXJzb248L2gzPlxyXG4gKiAgICAgICAgIDxkaXYgbmctY29udHJvbC1ncm91cD1cInBlcnNvblwiPlxyXG4gKiAgICAgICAgICAgPHA+Rmlyc3QgbmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctY29udHJvbD1cImZpcnN0TmFtZVwiPjwvcD5cclxuICogICAgICAgICAgIDxwPkxhc3QgbmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctY29udHJvbD1cImxhc3ROYW1lXCI+PC9wPlxyXG4gKiAgICAgICAgIDwvZGl2PlxyXG4gKiAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiPlN1Ym1pdCBGb3JtPC9idXR0b24+XHJcbiAqICAgICAgIDxwPkZvcm0gZGF0YSBzdWJtaXR0ZWQ6PC9wPlxyXG4gKiAgICAgICA8L2Zvcm0+XHJcbiAqICAgICAgIDxwcmU+e3tkYXRhfX08L3ByZT5cclxuICogICAgIDwvZGl2PlxyXG4gKiBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDT1JFX0RJUkVDVElWRVMsIEZPUk1fRElSRUNUSVZFU11cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIEFwcCB7XHJcbiAqICAgY29uc3RydWN0b3IoKSB7fVxyXG4gKlxyXG4gKiAgIGRhdGE6IHN0cmluZztcclxuICpcclxuICogICBvblN1Ym1pdChkYXRhKSB7XHJcbiAqICAgICB0aGlzLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcclxuICogICB9XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nRm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmdGb3JtLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmdGb3JtKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZm9ybSA9IG5ldyBtb2RlbF8xLkNvbnRyb2xHcm91cCh7fSk7XHJcbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2xhdGVyKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XHJcbiAgICAgICAgICAgIHZhciBjdHJsID0gbmV3IG1vZGVsXzEuQ29udHJvbCgpO1xyXG4gICAgICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2woY3RybCwgZGlyKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENvbnRyb2woZGlyLm5hbWUsIGN0cmwpO1xyXG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpOyB9O1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXIoZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZENvbnRyb2xHcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2xhdGVyKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBtb2RlbF8xLkNvbnRyb2xHcm91cCh7fSk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDb250cm9sKGRpci5uYW1lLCBncm91cCk7XHJcbiAgICAgICAgICAgIGdyb3VwLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sYXRlcihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb250YWluZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIudXBkYXRlVmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Q29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sYXRlcihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICB2YXIgY3RybCA9IF90aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XHJcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dCh0aGlzLm5nU3VibWl0LCBudWxsKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgTmdGb3JtLnByb3RvdHlwZS5fZmluZENvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgcGF0aC5wb3AoKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkgPyB0aGlzLmZvcm0gOiB0aGlzLmZvcm0uZmluZChwYXRoKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLl9sYXRlciA9IGZ1bmN0aW9uIChmbikgeyBhc3luY18xLlByb21pc2VXcmFwcGVyLnRoZW4oYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKG51bGwpLCBmbiwgZnVuY3Rpb24gKF8pIHsgfSk7IH07XHJcbiAgICBOZ0Zvcm0gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nLW5vLWZvcm1dKTpub3QoW25nLWZvcm0tbW9kZWxdKSxuZy1mb3JtLFtuZy1mb3JtXScsXHJcbiAgICAgICAgICAgIGJpbmRpbmdzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyXSxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJyhzdWJtaXQpJzogJ29uU3VibWl0KCknLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnZm9ybSdcclxuICAgICAgICB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIE5nRm9ybSk7XHJcbiAgICByZXR1cm4gTmdGb3JtO1xyXG59KShjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIpO1xyXG5leHBvcnRzLk5nRm9ybSA9IE5nRm9ybTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfZm9ybS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL25nX2NvbnRyb2wnKTtcclxudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcclxudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgZm9ybUNvbnRyb2xCaW5kaW5nID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIobmdfY29udHJvbF8xLk5nQ29udHJvbCwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybUNvbnRyb2w7IH0pIH0pKTtcclxuLyoqXHJcbiAqIEJpbmRzIGFuIGV4aXN0aW5nIHtAbGluayBDb250cm9sfSB0byBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvamNRbFoydFRoMjJCWloydWNOQVQ/cD1wcmV2aWV3KSlcclxuICpcclxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSBiaW5kIHRoZSBjb250cm9sIHRvIGFuIGlucHV0IGVsZW1lbnQuIFdoZW4gdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBlbGVtZW50XHJcbiAqIGNoYW5nZXMsIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCB3aWxsIHJlZmxlY3QgdGhhdCBjaGFuZ2UuIExpa2V3aXNlLCBpZiB0aGUgdmFsdWUgb2YgdGhlXHJcbiAqIGNvbnRyb2wgY2hhbmdlcywgdGhlIGlucHV0IGVsZW1lbnQgcmVmbGVjdHMgdGhhdCBjaGFuZ2UuXHJcbiAqXHJcbiAqICBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGRpdj5cclxuICogICAgICAgPGgyPk5nRm9ybUNvbnRyb2wgRXhhbXBsZTwvaDI+XHJcbiAqICAgICAgIDxmb3JtPlxyXG4gKiAgICAgICAgIDxwPkVsZW1lbnQgd2l0aCBleGlzdGluZyBjb250cm9sOiA8aW5wdXQgdHlwZT1cInRleHRcIlxyXG4gKiBbbmctZm9ybS1jb250cm9sXT1cImxvZ2luQ29udHJvbFwiPjwvcD5cclxuICogICAgICAgICA8cD5WYWx1ZSBvZiBleGlzdGluZyBjb250cm9sOiB7e2xvZ2luQ29udHJvbC52YWx1ZX19PC9wPlxyXG4gKiAgICAgICA8L2Zvcm0+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDT1JFX0RJUkVDVElWRVMsIEZPUk1fRElSRUNUSVZFU11cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIEFwcCB7XHJcbiAqICAgbG9naW5Db250cm9sOiBDb250cm9sID0gbmV3IENvbnRyb2woJycpO1xyXG4gKiB9XHJcbiAqICBgYGBcclxuICpcclxuICogIyBuZy1tb2RlbFxyXG4gKlxyXG4gKiBXZSBjYW4gYWxzbyB1c2UgYG5nLW1vZGVsYCB0byBiaW5kIGEgZG9tYWluIG1vZGVsIHRvIHRoZSBmb3JtLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveUhNTHVITzdETmdUOFh2dGpUREg/cD1wcmV2aWV3KSlcclxuICpcclxuICogIGBgYHR5cGVzY3JpcHRcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgICAgc2VsZWN0b3I6IFwibG9naW4tY29tcFwiLFxyXG4gKiAgICAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdLFxyXG4gKiAgICAgIHRlbXBsYXRlOiBcIjxpbnB1dCB0eXBlPSd0ZXh0JyBbbmctZm9ybS1jb250cm9sXT0nbG9naW5Db250cm9sJyBbKG5nLW1vZGVsKV09J2xvZ2luJz5cIlxyXG4gKiAgICAgIH0pXHJcbiAqIGNsYXNzIExvZ2luQ29tcCB7XHJcbiAqICBsb2dpbkNvbnRyb2w6IENvbnRyb2wgPSBuZXcgQ29udHJvbCgnJyk7XHJcbiAqICBsb2dpbjpzdHJpbmc7XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nRm9ybUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5nRm9ybUNvbnRyb2wsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ0Zvcm1Db250cm9sKHZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xyXG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNoYXJlZF8xLnNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xyXG4gICAgfVxyXG4gICAgTmdGb3JtQ29udHJvbC5wcm90b3R5cGUub25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKSB7XHJcbiAgICAgICAgICAgIHNoYXJlZF8xLnNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcmVkXzEuaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybS51cGRhdGVWYWx1ZSh0aGlzLm1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtQ29udHJvbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtQ29udHJvbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlKHRoaXMudmFsaWRhdG9ycyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmdGb3JtQ29udHJvbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQodGhpcy51cGRhdGUsIG5ld1ZhbHVlKTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm1Db250cm9sID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tuZy1mb3JtLWNvbnRyb2xdJyxcclxuICAgICAgICAgICAgYmluZGluZ3M6IFtmb3JtQ29udHJvbEJpbmRpbmddLFxyXG4gICAgICAgICAgICBpbnB1dHM6IFsnZm9ybTogbmdGb3JtQ29udHJvbCcsICdtb2RlbDogbmdNb2RlbCddLFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBbJ3VwZGF0ZTogbmdNb2RlbENoYW5nZSddLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ2Zvcm0nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLk9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5JbmplY3QodmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlMpKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGRpXzEuT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLkluamVjdChjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXksIEFycmF5XSlcclxuICAgIF0sIE5nRm9ybUNvbnRyb2wpO1xyXG4gICAgcmV0dXJuIE5nRm9ybUNvbnRyb2w7XHJcbn0pKG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wpO1xyXG5leHBvcnRzLk5nRm9ybUNvbnRyb2wgPSBOZ0Zvcm1Db250cm9sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19mb3JtX2NvbnRyb2wuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb250cm9sX2NvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX2NvbnRhaW5lcicpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIoY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyLCB7IHVzZUV4aXN0aW5nOiBkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdGb3JtTW9kZWw7IH0pIH0pKTtcclxuLyoqXHJcbiAqIEJpbmRzIGFuIGV4aXN0aW5nIGNvbnRyb2wgZ3JvdXAgdG8gYSBET00gZWxlbWVudC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2pxclZpcnVkWThhbkp4VE1ValRQP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSwgd2UgYmluZCB0aGUgY29udHJvbCBncm91cCB0byB0aGUgZm9ybSBlbGVtZW50LCBhbmQgd2UgYmluZCB0aGUgbG9naW4gYW5kXHJcbiAqIHBhc3N3b3JkIGNvbnRyb2xzIHRvIHRoZSBsb2dpbiBhbmQgcGFzc3dvcmQgZWxlbWVudHMuXHJcbiAqXHJcbiAqICBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGRpdj5cclxuICogICAgICAgPGgyPk5nRm9ybU1vZGVsIEV4YW1wbGU8L2gyPlxyXG4gKiAgICAgICA8Zm9ybSBbbmctZm9ybS1tb2RlbF09XCJsb2dpbkZvcm1cIj5cclxuICogICAgICAgICA8cD5Mb2dpbjogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctY29udHJvbD1cImxvZ2luXCI+PC9wPlxyXG4gKiAgICAgICAgIDxwPlBhc3N3b3JkOiA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgbmctY29udHJvbD1cInBhc3N3b3JkXCI+PC9wPlxyXG4gKiAgICAgICA8L2Zvcm0+XHJcbiAqICAgICAgIDxwPlZhbHVlOjwvcD5cclxuICogICAgICAgPHByZT57e3ZhbHVlfX08L3ByZT5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU11cclxuICogfSlcclxuICogZXhwb3J0IGNsYXNzIEFwcCB7XHJcbiAqICAgbG9naW5Gb3JtOiBDb250cm9sR3JvdXA7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoKSB7XHJcbiAqICAgICB0aGlzLmxvZ2luRm9ybSA9IG5ldyBDb250cm9sR3JvdXAoe1xyXG4gKiAgICAgICBsb2dpbjogbmV3IENvbnRyb2woXCJcIiksXHJcbiAqICAgICAgIHBhc3N3b3JkOiBuZXcgQ29udHJvbChcIlwiKVxyXG4gKiAgICAgfSk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xyXG4gKiAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMubG9naW5Gb3JtLnZhbHVlLCBudWxsLCAyKTtcclxuICogICB9XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKlxyXG4gKiBXZSBjYW4gYWxzbyB1c2UgbmctbW9kZWwgdG8gYmluZCBhIGRvbWFpbiBtb2RlbCB0byB0aGUgZm9ybS5cclxuICpcclxuICogIGBgYHR5cGVzY3JpcHRcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgICAgc2VsZWN0b3I6IFwibG9naW4tY29tcFwiLFxyXG4gKiAgICAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdLFxyXG4gKiAgICAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICAgICA8Zm9ybSBbbmctZm9ybS1tb2RlbF09J2xvZ2luRm9ybSc+XHJcbiAqICAgICAgICAgIExvZ2luIDxpbnB1dCB0eXBlPSd0ZXh0JyBuZy1jb250cm9sPSdsb2dpbicgWyhuZy1tb2RlbCldPSdjcmVkZW50aWFscy5sb2dpbic+XHJcbiAqICAgICAgICAgIFBhc3N3b3JkIDxpbnB1dCB0eXBlPSdwYXNzd29yZCcgbmctY29udHJvbD0ncGFzc3dvcmQnXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nLW1vZGVsKV09J2NyZWRlbnRpYWxzLnBhc3N3b3JkJz5cclxuICogICAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVwib25Mb2dpbigpXCI+TG9naW48L2J1dHRvbj5cclxuICogICAgICAgIDwvZm9ybT5gXHJcbiAqICAgICAgfSlcclxuICogY2xhc3MgTG9naW5Db21wIHtcclxuICogIGNyZWRlbnRpYWxzOiB7bG9naW46IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZ307XHJcbiAqICBsb2dpbkZvcm06IENvbnRyb2xHcm91cDtcclxuICpcclxuICogIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICB0aGlzLmxvZ2luRm9ybSA9IG5ldyBDb250cm9sR3JvdXAoe1xyXG4gKiAgICAgIGxvZ2luOiBuZXcgQ29udHJvbChcIlwiKSxcclxuICogICAgICBwYXNzd29yZDogbmV3IENvbnRyb2woXCJcIilcclxuICogICAgfSk7XHJcbiAqICB9XHJcbiAqXHJcbiAqICBvbkxvZ2luKCk6IHZvaWQge1xyXG4gKiAgICAvLyB0aGlzLmNyZWRlbnRpYWxzLmxvZ2luID09PSAnc29tZSBsb2dpbidcclxuICogICAgLy8gdGhpcy5jcmVkZW50aWFscy5wYXNzd29yZCA9PT0gJ3NvbWUgcGFzc3dvcmQnXHJcbiAqICB9XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nRm9ybU1vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0Zvcm1Nb2RlbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE5nRm9ybU1vZGVsKCkge1xyXG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZm9ybSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLm9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChfKSB7IHRoaXMuX3VwZGF0ZURvbVZhbHVlKCk7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtTW9kZWwucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtTW9kZWwucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5maW5kKGRpci5wYXRoKTtcclxuICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2woY3RybCwgZGlyKTtcclxuICAgICAgICBjdHJsLnVwZGF0ZVZhbGlkaXR5KCk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyKTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5maW5kKGRpci5wYXRoKTsgfTtcclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuZGlyZWN0aXZlcywgZGlyKTsgfTtcclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5hZGRDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IH07XHJcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQ29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyB9O1xyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLmdldENvbnRyb2xHcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xyXG4gICAgfTtcclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XHJcbiAgICAgICAgY3RybC51cGRhdGVWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbE5leHQodGhpcy5uZ1N1Ym1pdCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5fdXBkYXRlRG9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHJsID0gX3RoaXMuZm9ybS5maW5kKGRpci5wYXRoKTtcclxuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjdHJsLnZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZ0Zvcm1Nb2RlbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctZm9ybS1tb2RlbF0nLFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlcl0sXHJcbiAgICAgICAgICAgIGlucHV0czogWydmb3JtOiBuZy1mb3JtLW1vZGVsJ10sXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCknIH0sXHJcbiAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdmb3JtJ1xyXG4gICAgICAgIH0pLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgTmdGb3JtTW9kZWwpO1xyXG4gICAgcmV0dXJuIE5nRm9ybU1vZGVsO1xyXG59KShjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIpO1xyXG5leHBvcnRzLk5nRm9ybU1vZGVsID0gTmdGb3JtTW9kZWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2Zvcm1fbW9kZWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL25nX2NvbnRyb2wnKTtcclxudmFyIG1vZGVsXzEgPSByZXF1aXJlKCcuLi9tb2RlbCcpO1xyXG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgZm9ybUNvbnRyb2xCaW5kaW5nID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIobmdfY29udHJvbF8xLk5nQ29udHJvbCwgeyB1c2VFeGlzdGluZzogZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWw7IH0pIH0pKTtcclxuLyoqXHJcbiAqIEJpbmRzIGEgZG9tYWluIG1vZGVsIHRvIGEgZm9ybSBjb250cm9sLlxyXG4gKlxyXG4gKiAjIFVzYWdlXHJcbiAqXHJcbiAqIGBuZy1tb2RlbGAgYmluZHMgYW4gZXhpc3RpbmcgZG9tYWluIG1vZGVsIHRvIGEgZm9ybSBjb250cm9sLiBGb3IgYVxyXG4gKiB0d28td2F5IGJpbmRpbmcsIHVzZSBgWyhuZy1tb2RlbCldYCB0byBlbnN1cmUgdGhlIG1vZGVsIHVwZGF0ZXMgaW5cclxuICogYm90aCBkaXJlY3Rpb25zLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUjNVWDVxRGFVcUZPMlZZUjBVekg/cD1wcmV2aWV3KSlcclxuICogIGBgYHR5cGVzY3JpcHRcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgICAgc2VsZWN0b3I6IFwic2VhcmNoLWNvbXBcIixcclxuICogICAgICBkaXJlY3RpdmVzOiBbRk9STV9ESVJFQ1RJVkVTXSxcclxuICogICAgICB0ZW1wbGF0ZTogYDxpbnB1dCB0eXBlPSd0ZXh0JyBbKG5nLW1vZGVsKV09XCJzZWFyY2hRdWVyeVwiPmBcclxuICogICAgICB9KVxyXG4gKiBjbGFzcyBTZWFyY2hDb21wIHtcclxuICogIHNlYXJjaFF1ZXJ5OiBzdHJpbmc7XHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxudmFyIE5nTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5nTW9kZWwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOZ01vZGVsKHZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NvbnRyb2wgPSBuZXcgbW9kZWxfMS5Db250cm9sKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xyXG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNoYXJlZF8xLnNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xyXG4gICAgfVxyXG4gICAgTmdNb2RlbC5wcm90b3R5cGUub25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKSB7XHJcbiAgICAgICAgICAgIHNoYXJlZF8xLnNldFVwQ29udHJvbCh0aGlzLl9jb250cm9sLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVWYWxpZGl0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFyZWRfMS5pc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVWYWx1ZSh0aGlzLm1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZSh0aGlzLnZhbGlkYXRvcnMpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5nTW9kZWwucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcclxuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0KHRoaXMudXBkYXRlLCBuZXdWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmdNb2RlbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmctbW9kZWxdOm5vdChbbmctY29udHJvbF0pOm5vdChbbmctZm9ybS1jb250cm9sXSknLFxyXG4gICAgICAgICAgICBiaW5kaW5nczogW2Zvcm1Db250cm9sQmluZGluZ10sXHJcbiAgICAgICAgICAgIGlucHV0czogWydtb2RlbDogbmdNb2RlbCddLFxyXG4gICAgICAgICAgICBvdXRwdXRzOiBbJ3VwZGF0ZTogbmdNb2RlbENoYW5nZSddLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ2Zvcm0nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLk9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5JbmplY3QodmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlMpKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGRpXzEuT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBkaV8xLkluamVjdChjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXksIEFycmF5XSlcclxuICAgIF0sIE5nTW9kZWwpO1xyXG4gICAgcmV0dXJuIE5nTW9kZWw7XHJcbn0pKG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wpO1xyXG5leHBvcnRzLk5nTW9kZWwgPSBOZ01vZGVsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19tb2RlbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlcicpO1xyXG52YXIgbGlua2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXInKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xyXG52YXIgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIoY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SLCB7IHVzZUV4aXN0aW5nOiBkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLCBtdWx0aTogdHJ1ZSB9KSk7XHJcbi8qKlxyXG4gKiBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXHJcbiAqXHJcbiAqICNFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPHNlbGVjdCBuZy1jb250cm9sPVwiY2l0eVwiPlxyXG4gKiAgIDxvcHRpb24gKm5nLWZvcj1cIiNjIG9mIGNpdGllc1wiIFt2YWx1ZV09XCJjXCI+PC9vcHRpb24+XHJcbiAqIDwvc2VsZWN0PlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBOZ1NlbGVjdE9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ1NlbGVjdE9wdGlvbigpIHtcclxuICAgIH1cclxuICAgIE5nU2VsZWN0T3B0aW9uID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ29wdGlvbicgfSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBOZ1NlbGVjdE9wdGlvbik7XHJcbiAgICByZXR1cm4gTmdTZWxlY3RPcHRpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBOZ1NlbGVjdE9wdGlvbjtcclxuLyoqXHJcbiAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIHNlbGVjdCBlbGVtZW50LlxyXG4gKi9cclxudmFyIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYsIHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xyXG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlV2hlbkxpc3RPZk9wdGlvbnNDaGFuZ2VzKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHNoYXJlZF8xLnNldFByb3BlcnR5KHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9lbGVtZW50UmVmLCBcInZhbHVlXCIsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XHJcbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcclxuICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVXaGVuTGlzdE9mT3B0aW9uc0NoYW5nZXMgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlKHF1ZXJ5LmNoYW5nZXMsIGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy53cml0ZVZhbHVlKF90aGlzLnZhbHVlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0W25nLWNvbnRyb2xdLHNlbGVjdFtuZy1mb3JtLWNvbnRyb2xdLHNlbGVjdFtuZy1tb2RlbF0nLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxyXG4gICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxyXG4gICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYmluZGluZ3M6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBtZXRhZGF0YV8xLlF1ZXJ5KE5nU2VsZWN0T3B0aW9uLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbcmVuZGVyXzEuUmVuZGVyZXIsIGxpbmtlcl8xLkVsZW1lbnRSZWYsIGxpbmtlcl8xLlF1ZXJ5TGlzdF0pXHJcbiAgICBdLCBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcik7XHJcbiAgICByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XHJcbnZhciBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcclxudmFyIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XHJcbnZhciBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xyXG5mdW5jdGlvbiBjb250cm9sUGF0aChuYW1lLCBwYXJlbnQpIHtcclxuICAgIHZhciBwID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5wYXRoKTtcclxuICAgIHAucHVzaChuYW1lKTtcclxuICAgIHJldHVybiBwO1xyXG59XHJcbmV4cG9ydHMuY29udHJvbFBhdGggPSBjb250cm9sUGF0aDtcclxuZnVuY3Rpb24gc2V0VXBDb250cm9sKGNvbnRyb2wsIGRpcikge1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbnRyb2wpKVxyXG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgXCJDYW5ub3QgZmluZCBjb250cm9sXCIpO1xyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGRpci52YWx1ZUFjY2Vzc29yKSlcclxuICAgICAgICBfdGhyb3dFcnJvcihkaXIsIFwiTm8gdmFsdWUgYWNjZXNzb3IgZm9yXCIpO1xyXG4gICAgY29udHJvbC52YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xyXG4gICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjb250cm9sLnZhbHVlKTtcclxuICAgIC8vIHZpZXcgLT4gbW9kZWxcclxuICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcclxuICAgICAgICBjb250cm9sLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlLCB7IGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UgfSk7XHJcbiAgICAgICAgY29udHJvbC5tYXJrQXNEaXJ0eSgpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBtb2RlbCAtPiB2aWV3XHJcbiAgICBjb250cm9sLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7IHJldHVybiBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKG5ld1ZhbHVlKTsgfSk7XHJcbiAgICAvLyB0b3VjaGVkXHJcbiAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLm1hcmtBc1RvdWNoZWQoKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5zZXRVcENvbnRyb2wgPSBzZXRVcENvbnRyb2w7XHJcbmZ1bmN0aW9uIF90aHJvd0Vycm9yKGRpciwgbWVzc2FnZSkge1xyXG4gICAgdmFyIHBhdGggPSBkaXIucGF0aC5qb2luKFwiIC0+IFwiKTtcclxuICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihtZXNzYWdlICsgXCIgJ1wiICsgcGF0aCArIFwiJ1wiKTtcclxufVxyXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eShyZW5kZXJlciwgZWxlbWVudFJlZiwgcHJvcE5hbWUsIHByb3BWYWx1ZSkge1xyXG4gICAgcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KGVsZW1lbnRSZWYsIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xyXG59XHJcbmV4cG9ydHMuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcclxuZnVuY3Rpb24gaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdmlld01vZGVsKSB7XHJcbiAgICBpZiAoIWNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKGNoYW5nZXMsIFwibW9kZWxcIikpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbXCJtb2RlbFwiXTtcclxuICAgIGlmIChjaGFuZ2UuaXNGaXJzdENoYW5nZSgpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuICFsYW5nXzEubG9vc2VJZGVudGljYWwodmlld01vZGVsLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcclxufVxyXG5leHBvcnRzLmlzUHJvcGVydHlVcGRhdGVkID0gaXNQcm9wZXJ0eVVwZGF0ZWQ7XHJcbi8vIFRPRE86IHZzYXZraW4gcmVtb3ZlIGl0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxyXG5mdW5jdGlvbiBzZWxlY3RWYWx1ZUFjY2Vzc29yKGRpciwgdmFsdWVBY2Nlc3NvcnMpIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZUFjY2Vzc29ycykpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgZGVmYXVsdEFjY2Vzc29yO1xyXG4gICAgdmFyIGJ1aWx0aW5BY2Nlc3NvcjtcclxuICAgIHZhciBjdXN0b21BY2Nlc3NvcjtcclxuICAgIHZhbHVlQWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMS5EZWZhdWx0VmFsdWVBY2Nlc3Nvcikge1xyXG4gICAgICAgICAgICBkZWZhdWx0QWNjZXNzb3IgPSB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMS5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yIHx8XHJcbiAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBzZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJ1aWx0aW5BY2Nlc3NvcikpXHJcbiAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsIFwiTW9yZSB0aGFuIG9uZSBidWlsdC1pbiB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzXCIpO1xyXG4gICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY3VzdG9tQWNjZXNzb3IpKVxyXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIk1vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXNcIik7XHJcbiAgICAgICAgICAgIGN1c3RvbUFjY2Vzc29yID0gdjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGN1c3RvbUFjY2Vzc29yKSlcclxuICAgICAgICByZXR1cm4gY3VzdG9tQWNjZXNzb3I7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChidWlsdGluQWNjZXNzb3IpKVxyXG4gICAgICAgIHJldHVybiBidWlsdGluQWNjZXNzb3I7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZWZhdWx0QWNjZXNzb3IpKVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XHJcbiAgICBfdGhyb3dFcnJvcihkaXIsIFwiTm8gdmFsaWQgdmFsdWUgYWNjZXNzb3IgZm9yXCIpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5zZWxlY3RWYWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3NvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcclxudmFyIGxhbmdfMiA9IHJlcXVpcmUoXCJhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZ1wiKTtcclxudmFyIFJFUVVJUkVEX1ZBTElEQVRPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLCB7IHVzZVZhbHVlOiB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5yZXF1aXJlZCwgbXVsdGk6IHRydWUgfSkpO1xyXG52YXIgUmVxdWlyZWRWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVxdWlyZWRWYWxpZGF0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBSZXF1aXJlZFZhbGlkYXRvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbcmVxdWlyZWRdW25nLWNvbnRyb2xdLFtyZXF1aXJlZF1bbmctZm9ybS1jb250cm9sXSxbcmVxdWlyZWRdW25nLW1vZGVsXScsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1JFUVVJUkVEX1ZBTElEQVRPUl1cclxuICAgICAgICB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFJlcXVpcmVkVmFsaWRhdG9yKTtcclxuICAgIHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IFJlcXVpcmVkVmFsaWRhdG9yO1xyXG5mdW5jdGlvbiBjcmVhdGVNaW5MZW5ndGhWYWxpZGF0b3IoZGlyKSB7XHJcbiAgICByZXR1cm4gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMubWluTGVuZ3RoKGRpci5taW5MZW5ndGgpO1xyXG59XHJcbnZhciBNSU5fTEVOR1RIX1ZBTElEQVRPUiA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBkaV8xLlByb3ZpZGVyKHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLCB7XHJcbiAgICB1c2VGYWN0b3J5OiBjcmVhdGVNaW5MZW5ndGhWYWxpZGF0b3IsXHJcbiAgICBkZXBzOiBbZGlfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjsgfSldLFxyXG4gICAgbXVsdGk6IHRydWVcclxufSkpO1xyXG52YXIgTWluTGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1pbkxlbmd0aFZhbGlkYXRvcihtaW5MZW5ndGgpIHtcclxuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IGxhbmdfMi5OdW1iZXJXcmFwcGVyLnBhcnNlSW50KG1pbkxlbmd0aCwgMTApO1xyXG4gICAgfVxyXG4gICAgTWluTGVuZ3RoVmFsaWRhdG9yID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5EaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW25nLWNvbnRyb2xdLFttaW5sZW5ndGhdW25nLWZvcm0tY29udHJvbF0sW21pbmxlbmd0aF1bbmctbW9kZWxdJyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgwLCBtZXRhZGF0YV8xLkF0dHJpYnV0ZShcIm1pbmxlbmd0aFwiKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXHJcbiAgICBdLCBNaW5MZW5ndGhWYWxpZGF0b3IpO1xyXG4gICAgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjtcclxufSkoKTtcclxuZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSBNaW5MZW5ndGhWYWxpZGF0b3I7XHJcbmZ1bmN0aW9uIGNyZWF0ZU1heExlbmd0aFZhbGlkYXRvcihkaXIpIHtcclxuICAgIHJldHVybiB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5tYXhMZW5ndGgoZGlyLm1heExlbmd0aCk7XHJcbn1cclxudmFyIE1BWF9MRU5HVEhfVkFMSURBVE9SID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGRpXzEuUHJvdmlkZXIodmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlMsIHtcclxuICAgIHVzZUZhY3Rvcnk6IGNyZWF0ZU1heExlbmd0aFZhbGlkYXRvcixcclxuICAgIGRlcHM6IFtkaV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yOyB9KV0sXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59KSk7XHJcbnZhciBNYXhMZW5ndGhWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWF4TGVuZ3RoVmFsaWRhdG9yKG1heExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbGFuZ18yLk51bWJlcldyYXBwZXIucGFyc2VJbnQobWF4TGVuZ3RoLCAxMCk7XHJcbiAgICB9XHJcbiAgICBNYXhMZW5ndGhWYWxpZGF0b3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLkRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bbmctY29udHJvbF0sW21heGxlbmd0aF1bbmctZm9ybS1jb250cm9sXSxbbWF4bGVuZ3RoXVtuZy1tb2RlbF0nLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDAsIG1ldGFkYXRhXzEuQXR0cmlidXRlKFwibWF4bGVuZ3RoXCIpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcclxuICAgIF0sIE1heExlbmd0aFZhbGlkYXRvcik7XHJcbiAgICByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yO1xyXG59KSgpO1xyXG5leHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IE1heExlbmd0aFZhbGlkYXRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9ycy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBtb2RlbE1vZHVsZSA9IHJlcXVpcmUoJy4vbW9kZWwnKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmb3JtIG9iamVjdCBmcm9tIGEgdXNlci1zcGVjaWZpZWQgY29uZmlndXJhdGlvbi5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgYm9vdHN0cmFwfSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7Rm9ybUJ1aWxkZXIsIFZhbGlkYXRvcnMsIEZPUk1fRElSRUNUSVZFUywgQ29udHJvbEdyb3VwfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdsb2dpbi1jb21wJyxcclxuICogICB2aWV3UHJvdmlkZXJzOiBbRm9ybUJ1aWxkZXJdLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8Zm9ybSBbY29udHJvbC1ncm91cF09XCJsb2dpbkZvcm1cIj5cclxuICogICAgICAgTG9naW4gPGlucHV0IGNvbnRyb2w9XCJsb2dpblwiPlxyXG4gKlxyXG4gKiAgICAgICA8ZGl2IGNvbnRyb2wtZ3JvdXA9XCJwYXNzd29yZFJldHJ5XCI+XHJcbiAqICAgICAgICAgUGFzc3dvcmQgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGNvbnRyb2w9XCJwYXNzd29yZFwiPlxyXG4gKiAgICAgICAgIENvbmZpcm0gcGFzc3dvcmQgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGNvbnRyb2w9XCJwYXNzd29yZENvbmZpcm1hdGlvblwiPlxyXG4gKiAgICAgICA8L2Rpdj5cclxuICogICAgIDwvZm9ybT5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVNdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIExvZ2luQ29tcCB7XHJcbiAqICAgbG9naW5Gb3JtOiBDb250cm9sR3JvdXA7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoYnVpbGRlcjogRm9ybUJ1aWxkZXIpIHtcclxuICogICAgIHRoaXMubG9naW5Gb3JtID0gYnVpbGRlci5ncm91cCh7XHJcbiAqICAgICAgIGxvZ2luOiBbXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXHJcbiAqXHJcbiAqICAgICAgIHBhc3N3b3JkUmV0cnk6IGJ1aWxkZXIuZ3JvdXAoe1xyXG4gKiAgICAgICAgIHBhc3N3b3JkOiBbXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXHJcbiAqICAgICAgICAgcGFzc3dvcmRDb25maXJtYXRpb246IFtcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkXVxyXG4gKiAgICAgICB9KVxyXG4gKiAgICAgfSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChMb2dpbkNvbXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSB7QGxpbmsgQ29udHJvbEdyb3VwfSB0aGF0IGNvbnNpc3RzIG9mIGEgYGxvZ2luYCB7QGxpbmsgQ29udHJvbH0sIGFuZCBhXHJcbiAqIG5lc3RlZCB7QGxpbmsgQ29udHJvbEdyb3VwfSB0aGF0IGRlZmluZXMgYSBgcGFzc3dvcmRgIGFuZCBhIGBwYXNzd29yZENvbmZpcm1hdGlvbmBcclxuICoge0BsaW5rIENvbnRyb2x9OlxyXG4gKlxyXG4gKiBgYGBcclxuICogIHZhciBsb2dpbkZvcm0gPSBidWlsZGVyLmdyb3VwKHtcclxuICogICAgbG9naW46IFtcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkXSxcclxuICpcclxuICogICAgcGFzc3dvcmRSZXRyeTogYnVpbGRlci5ncm91cCh7XHJcbiAqICAgICAgcGFzc3dvcmQ6IFtcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkXSxcclxuICogICAgICBwYXNzd29yZENvbmZpcm1hdGlvbjogW1wiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWRdXHJcbiAqICAgIH0pXHJcbiAqICB9KTtcclxuICpcclxuICogIGBgYFxyXG4gKi9cclxudmFyIEZvcm1CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvcm1CdWlsZGVyKCkge1xyXG4gICAgfVxyXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCBleHRyYSkge1xyXG4gICAgICAgIGlmIChleHRyYSA9PT0gdm9pZCAwKSB7IGV4dHJhID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuX3JlZHVjZUNvbnRyb2xzKGNvbnRyb2xzQ29uZmlnKTtcclxuICAgICAgICB2YXIgb3B0aW9uYWxzID0gbGFuZ18xLmlzUHJlc2VudChleHRyYSkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoZXh0cmEsIFwib3B0aW9uYWxzXCIpIDogbnVsbDtcclxuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbGFuZ18xLmlzUHJlc2VudChleHRyYSkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoZXh0cmEsIFwidmFsaWRhdG9yXCIpIDogbnVsbDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbW9kZWxNb2R1bGUuQ29udHJvbEdyb3VwKGNvbnRyb2xzLCBvcHRpb25hbHMsIHZhbGlkYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2xHcm91cChjb250cm9scywgb3B0aW9uYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRvcikge1xyXG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2wodmFsdWUsIHZhbGlkYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2wodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcsIHZhbGlkYXRvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cclxuICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sc0NvbmZpZy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVDb250cm9sKGMpOyB9KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbW9kZWxNb2R1bGUuQ29udHJvbEFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbE1vZHVsZS5Db250cm9sQXJyYXkoY29udHJvbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX3JlZHVjZUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29udHJvbHMgPSB7fTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGNvbnRyb2xzQ29uZmlnLCBmdW5jdGlvbiAoY29udHJvbENvbmZpZywgY29udHJvbE5hbWUpIHtcclxuICAgICAgICAgICAgY29udHJvbHNbY29udHJvbE5hbWVdID0gX3RoaXMuX2NyZWF0ZUNvbnRyb2woY29udHJvbENvbmZpZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sQ29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBtb2RlbE1vZHVsZS5Db250cm9sIHx8XHJcbiAgICAgICAgICAgIGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBtb2RlbE1vZHVsZS5Db250cm9sR3JvdXAgfHxcclxuICAgICAgICAgICAgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIG1vZGVsTW9kdWxlLkNvbnRyb2xBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbENvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzQXJyYXkoY29udHJvbENvbmZpZykpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbENvbmZpZ1swXTtcclxuICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMSA/IGNvbnRyb2xDb25maWdbMV0gOiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKHZhbHVlLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbChjb250cm9sQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRm9ybUJ1aWxkZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEZvcm1CdWlsZGVyKTtcclxuICAgIHJldHVybiBGb3JtQnVpbGRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Gb3JtQnVpbGRlciA9IEZvcm1CdWlsZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtX2J1aWxkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4vdmFsaWRhdG9ycycpO1xyXG4vKipcclxuICogSW5kaWNhdGVzIHRoYXQgYSBDb250cm9sIGlzIHZhbGlkLCBpLmUuIHRoYXQgbm8gZXJyb3JzIGV4aXN0IGluIHRoZSBpbnB1dCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydHMuVkFMSUQgPSBcIlZBTElEXCI7XHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIENvbnRyb2wgaXMgaW52YWxpZCwgaS5lLiB0aGF0IGFuIGVycm9yIGV4aXN0cyBpbiB0aGUgaW5wdXQgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnRzLklOVkFMSUQgPSBcIklOVkFMSURcIjtcclxuZnVuY3Rpb24gaXNDb250cm9sKGNvbnRyb2wpIHtcclxuICAgIHJldHVybiBjb250cm9sIGluc3RhbmNlb2YgQWJzdHJhY3RDb250cm9sO1xyXG59XHJcbmV4cG9ydHMuaXNDb250cm9sID0gaXNDb250cm9sO1xyXG5mdW5jdGlvbiBfZmluZChjb250cm9sLCBwYXRoKSB7XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsocGF0aCkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIvXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBBcnJheSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShwYXRoKSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVkdWNlKHBhdGgsIGZ1bmN0aW9uICh2LCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBDb250cm9sR3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodi5jb250cm9sc1tuYW1lXSkgPyB2LmNvbnRyb2xzW25hbWVdIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIENvbnRyb2xBcnJheSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBuYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2LmF0KGluZGV4KSkgPyB2LmF0KGluZGV4KSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LCBjb250cm9sKTtcclxufVxyXG4vKipcclxuICogT21pdHRpbmcgZnJvbSBleHRlcm5hbCBBUEkgZG9jIGFzIHRoaXMgaXMgcmVhbGx5IGFuIGFic3RyYWN0IGludGVybmFsIGNvbmNlcHQuXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RDb250cm9sID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbCh2YWxpZGF0b3IpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gZXhwb3J0cy5WQUxJRDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZXJyb3JzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByaXN0aW5lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnByaXN0aW5lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdG91Y2hlZDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuX3RvdWNoZWQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlQ2hhbmdlczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1RvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3RvdWNoZWQgPSB0cnVlOyB9O1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNEaXJ0eSA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XHJcbiAgICAgICAgb25seVNlbGYgPSBsYW5nXzEubm9ybWFsaXplQm9vbChvbmx5U2VsZik7XHJcbiAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzRGlydHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkgeyB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7IH07XHJcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnVwZGF0ZVZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcclxuICAgICAgICBvbmx5U2VsZiA9IGxhbmdfMS5ub3JtYWxpemVCb29sKG9ubHlTZWxmKTtcclxuICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLnZhbGlkYXRvcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2Vycm9ycykgPyBleHBvcnRzLklOVkFMSUQgOiBleHBvcnRzLlZBTElEO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3BhcmVudCkgJiYgIW9ubHlTZWxmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcclxuICAgICAgICBvbmx5U2VsZiA9IGxhbmdfMS5ub3JtYWxpemVCb29sKG9ubHlTZWxmKTtcclxuICAgICAgICBlbWl0RXZlbnQgPSBsYW5nXzEuaXNQcmVzZW50KGVtaXRFdmVudCkgPyBlbWl0RXZlbnQgOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XHJcbiAgICAgICAgaWYgKGVtaXRFdmVudCkge1xyXG4gICAgICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0KHRoaXMuX3ZhbHVlQ2hhbmdlcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLnZhbGlkYXRvcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2Vycm9ycykgPyBleHBvcnRzLklOVkFMSUQgOiBleHBvcnRzLlZBTElEO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3BhcmVudCkgJiYgIW9ubHlTZWxmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgpOyB9O1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2wgPSBsYW5nXzEuaXNQcmVzZW50KHBhdGgpICYmICFjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShwYXRoKSA/IHRoaXMuZmluZChwYXRoKSA6IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udHJvbCkgJiYgbGFuZ18xLmlzUHJlc2VudChjb250cm9sLl9lcnJvcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoY29udHJvbC5fZXJyb3JzLCBlcnJvckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sO1xyXG59KSgpO1xyXG5leHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IEFic3RyYWN0Q29udHJvbDtcclxuLyoqXHJcbiAqIERlZmluZXMgYSBwYXJ0IG9mIGEgZm9ybSB0aGF0IGNhbm5vdCBiZSBkaXZpZGVkIGludG8gb3RoZXIgY29udHJvbHMuIGBDb250cm9sYHMgaGF2ZSB2YWx1ZXMgYW5kXHJcbiAqIHZhbGlkYXRpb24gc3RhdGUsIHdoaWNoIGlzIGRldGVybWluZWQgYnkgYW4gb3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbi5cclxuICpcclxuICogYENvbnRyb2xgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsIGFsb25nXHJcbiAqIHdpdGgge0BsaW5rIENvbnRyb2xHcm91cH0gYW5kIHtAbGluayBDb250cm9sQXJyYXl9LlxyXG4gKlxyXG4gKiAjIFVzYWdlXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIGEgYENvbnRyb2xgIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGA8aW5wdXQ+YCBvciBvdGhlciBmb3JtIGNvbXBvbmVudC5cclxuICogV2l0aCB7QGxpbmsgTmdGb3JtQ29udHJvbH0gb3Ige0BsaW5rIE5nRm9ybU1vZGVsfSBhbiBleGlzdGluZyB7QGxpbmsgQ29udHJvbH0gY2FuIGJlXHJcbiAqIGJvdW5kIHRvIGEgRE9NIGVsZW1lbnQgaW5zdGVhZC4gVGhpcyBgQ29udHJvbGAgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIGN1c3RvbVxyXG4gKiB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvMjNERVNPcGJObkJwQkhadDFCUjQ/cD1wcmV2aWV3KSlcclxuICovXHJcbnZhciBDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLm51bGxWYWxpZGF0b3I7IH1cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcyA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIHRvIGB2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYG9ubHlTZWxmYCBpcyBgdHJ1ZWAsIHRoaXMgY2hhbmdlIHdpbGwgb25seSBhZmZlY3QgdGhlIHZhbGlkYXRpb24gb2YgdGhpcyBgQ29udHJvbGBcclxuICAgICAqIGFuZCBub3QgaXRzIHBhcmVudCBjb21wb25lbnQuIElmIGBlbWl0RXZlbnRgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBjYXVzZSBhXHJcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYCBldmVudCBvbiB0aGUgYENvbnRyb2xgIHRvIGJlIGVtaXR0ZWQuIEJvdGggb2YgdGhlc2Ugb3B0aW9ucyBkZWZhdWx0IHRvXHJcbiAgICAgKiBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIElmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIGB0cnVlYCwgdGhlIHZpZXcgd2lsbCBiZSBub3RpZmllZCBhYm91dCB0aGUgbmV3IHZhbHVlXHJcbiAgICAgKiB2aWEgYW4gYG9uQ2hhbmdlYCBldmVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBub3RcclxuICAgICAqIHNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgQ29udHJvbC5wcm90b3R5cGUudXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudCwgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlID0gX2IuZW1pdE1vZGVsVG9WaWV3Q2hhbmdlO1xyXG4gICAgICAgIGVtaXRNb2RlbFRvVmlld0NoYW5nZSA9IGxhbmdfMS5pc1ByZXNlbnQoZW1pdE1vZGVsVG9WaWV3Q2hhbmdlKSA/IGVtaXRNb2RlbFRvVmlld0NoYW5nZSA6IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9vbkNoYW5nZSkgJiYgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlKVxyXG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGNoYW5nZSBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIENvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcclxuICAgIHJldHVybiBDb250cm9sO1xyXG59KShBYnN0cmFjdENvbnRyb2wpO1xyXG5leHBvcnRzLkNvbnRyb2wgPSBDb250cm9sO1xyXG4vKipcclxuICogRGVmaW5lcyBhIHBhcnQgb2YgYSBmb3JtLCBvZiBmaXhlZCBsZW5ndGgsIHRoYXQgY2FuIGNvbnRhaW4gb3RoZXIgY29udHJvbHMuXHJcbiAqXHJcbiAqIEEgYENvbnRyb2xHcm91cGAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIGFuZCBlcnJvcnMgb2YgZWFjaCB7QGxpbmsgQ29udHJvbH0gaW4gdGhlIGdyb3VwLiBUaHVzLCBpZlxyXG4gKiBvbmUgb2YgdGhlIGNvbnRyb2xzIGluIGEgZ3JvdXAgaXMgaW52YWxpZCwgdGhlIGVudGlyZSBncm91cCBpcyBpbnZhbGlkLiBTaW1pbGFybHksIGlmIGEgY29udHJvbFxyXG4gKiBjaGFuZ2VzIGl0cyB2YWx1ZSwgdGhlIGVudGlyZSBncm91cCBjaGFuZ2VzIGFzIHdlbGwuXHJcbiAqXHJcbiAqIGBDb250cm9sR3JvdXBgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsXHJcbiAqIGFsb25nIHdpdGgge0BsaW5rIENvbnRyb2x9IGFuZCB7QGxpbmsgQ29udHJvbEFycmF5fS4ge0BsaW5rIENvbnRyb2xBcnJheX0gY2FuIGFsc28gY29udGFpbiBvdGhlclxyXG4gKiBjb250cm9scywgYnV0IGlzIG9mIHZhcmlhYmxlIGxlbmd0aC5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzIzREVTT3BiTm5CcEJIWnQxQlI0P3A9cHJldmlldykpXHJcbiAqL1xyXG52YXIgQ29udHJvbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250cm9sR3JvdXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250cm9sR3JvdXAoY29udHJvbHMsIG9wdGlvbmFscywgdmFsaWRhdG9yKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbmFscyA9PT0gdm9pZCAwKSB7IG9wdGlvbmFscyA9IG51bGw7IH1cclxuICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuZ3JvdXA7IH1cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcclxuICAgICAgICB0aGlzLl9vcHRpb25hbHMgPSBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbmFscykgPyBvcHRpb25hbHMgOiB7fTtcclxuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9zZXRQYXJlbnRGb3JDb250cm9scygpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVkdWNlVmFsdWUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xyXG4gICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0gPSBjb250cm9sO1xyXG4gICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmRlbGV0ZSh0aGlzLmNvbnRyb2xzLCBuYW1lKTsgfTtcclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuaW5jbHVkZSA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldCh0aGlzLl9vcHRpb25hbHMsIGNvbnRyb2xOYW1lLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcclxuICAgIH07XHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQodGhpcy5fb3B0aW9uYWxzLCBjb250cm9sTmFtZSwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xyXG4gICAgfTtcclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKHRoaXMuY29udHJvbHMsIGNvbnRyb2xOYW1lKTtcclxuICAgICAgICByZXR1cm4gYyAmJiB0aGlzLl9pbmNsdWRlZChjb250cm9sTmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5fc2V0UGFyZW50Rm9yQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHRoaXMuY29udHJvbHMsIGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7IGNvbnRyb2wuc2V0UGFyZW50KF90aGlzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVkdWNlVmFsdWUoKTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3JlZHVjZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xyXG4gICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3JlZHVjZUNoaWxkcmVuID0gZnVuY3Rpb24gKGluaXRWYWx1ZSwgZm4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXMgPSBpbml0VmFsdWU7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0aGlzLmNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2luY2x1ZGVkKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9pbmNsdWRlZCA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xyXG4gICAgICAgIHZhciBpc09wdGlvbmFsID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnModGhpcy5fb3B0aW9uYWxzLCBjb250cm9sTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuICFpc09wdGlvbmFsIHx8IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldCh0aGlzLl9vcHRpb25hbHMsIGNvbnRyb2xOYW1lKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29udHJvbEdyb3VwO1xyXG59KShBYnN0cmFjdENvbnRyb2wpO1xyXG5leHBvcnRzLkNvbnRyb2xHcm91cCA9IENvbnRyb2xHcm91cDtcclxuLyoqXHJcbiAqIERlZmluZXMgYSBwYXJ0IG9mIGEgZm9ybSwgb2YgdmFyaWFibGUgbGVuZ3RoLCB0aGF0IGNhbiBjb250YWluIG90aGVyIGNvbnRyb2xzLlxyXG4gKlxyXG4gKiBBIGBDb250cm9sQXJyYXlgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBhbmQgZXJyb3JzIG9mIGVhY2gge0BsaW5rIENvbnRyb2x9IGluIHRoZSBncm91cC4gVGh1cywgaWZcclxuICogb25lIG9mIHRoZSBjb250cm9scyBpbiBhIGdyb3VwIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgZ3JvdXAgaXMgaW52YWxpZC4gU2ltaWxhcmx5LCBpZiBhIGNvbnRyb2xcclxuICogY2hhbmdlcyBpdHMgdmFsdWUsIHRoZSBlbnRpcmUgZ3JvdXAgY2hhbmdlcyBhcyB3ZWxsLlxyXG4gKlxyXG4gKiBgQ29udHJvbEFycmF5YCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxyXG4gKiBhbG9uZyB3aXRoIHtAbGluayBDb250cm9sfSBhbmQge0BsaW5rIENvbnRyb2xHcm91cH0uIHtAbGluayBDb250cm9sR3JvdXB9IGNhbiBhbHNvIGNvbnRhaW5cclxuICogb3RoZXIgY29udHJvbHMsIGJ1dCBpcyBvZiBmaXhlZCBsZW5ndGguXHJcbiAqXHJcbiAqICMgQWRkaW5nIG9yIHJlbW92aW5nIGNvbnRyb2xzXHJcbiAqXHJcbiAqIFRvIGNoYW5nZSB0aGUgY29udHJvbHMgaW4gdGhlIGFycmF5LCB1c2UgdGhlIGBwdXNoYCwgYGluc2VydGAsIG9yIGByZW1vdmVBdGAgbWV0aG9kc1xyXG4gKiBpbiBgQ29udHJvbEFycmF5YCBpdHNlbGYuIFRoZXNlIG1ldGhvZHMgZW5zdXJlIHRoZSBjb250cm9scyBhcmUgcHJvcGVybHkgdHJhY2tlZCBpbiB0aGVcclxuICogZm9ybSdzIGhpZXJhcmNoeS4gRG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgb2YgYEFic3RyYWN0Q29udHJvbGBzIHVzZWQgdG8gaW5zdGFudGlhdGVcclxuICogdGhlIGBDb250cm9sQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHdpbGwgcmVzdWx0IGluIHN0cmFuZ2UgYW5kIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc3VjaFxyXG4gKiBhcyBicm9rZW4gY2hhbmdlIGRldGVjdGlvbi5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzIzREVTT3BiTm5CcEJIWnQxQlI0P3A9cHJldmlldykpXHJcbiAqL1xyXG52YXIgQ29udHJvbEFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250cm9sQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250cm9sQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvcikge1xyXG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5hcnJheTsgfVxyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvcik7XHJcbiAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcyA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3NldFBhcmVudEZvckNvbnRyb2xzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IGEgbmV3IHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMucHVzaChjb250cm9sKTtcclxuICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIENvbnRyb2xBcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmluc2VydCh0aGlzLmNvbnRyb2xzLCBpbmRleCwgY29udHJvbCk7XHJcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZUF0KHRoaXMuY29udHJvbHMsIGluZGV4KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbEFycmF5LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sIGFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5jb250cm9scy5tYXAoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudmFsdWU7IH0pOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5fc2V0UGFyZW50Rm9yQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5zZXRQYXJlbnQoX3RoaXMpOyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29udHJvbEFycmF5O1xyXG59KShBYnN0cmFjdENvbnRyb2wpO1xyXG5leHBvcnRzLkNvbnRyb2xBcnJheSA9IENvbnRyb2xBcnJheTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgbGFuZ18yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuZXhwb3J0cy5OR19WQUxJREFUT1JTID0gbGFuZ18yLkNPTlNUX0VYUFIobmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJOZ1ZhbGlkYXRvcnNcIikpO1xyXG4vKipcclxuICogUHJvdmlkZXMgYSBzZXQgb2YgdmFsaWRhdG9ycyB1c2VkIGJ5IGZvcm0gY29udHJvbHMuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxvZ2luQ29udHJvbCA9IG5ldyBDb250cm9sKFwiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWQpXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFZhbGlkYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdG9ycygpIHtcclxuICAgIH1cclxuICAgIFZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhjb250cm9sLnZhbHVlKSB8fCBjb250cm9sLnZhbHVlID09IFwiXCIgPyB7IFwicmVxdWlyZWRcIjogdHJ1ZSB9IDogbnVsbDtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChtaW5MZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHYgPSBjb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPCBtaW5MZW5ndGggP1xyXG4gICAgICAgICAgICAgICAgeyBcIm1pbmxlbmd0aFwiOiB7IFwicmVxdWlyZWRMZW5ndGhcIjogbWluTGVuZ3RoLCBcImFjdHVhbExlbmd0aFwiOiB2Lmxlbmd0aCB9IH0gOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRvcnMubWF4TGVuZ3RoID0gZnVuY3Rpb24gKG1heExlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChWYWxpZGF0b3JzLnJlcXVpcmVkKGNvbnRyb2wpKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGNvbnRyb2wudmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2Lmxlbmd0aCA+IG1heExlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICB7IFwibWF4bGVuZ3RoXCI6IHsgXCJyZXF1aXJlZExlbmd0aFwiOiBtYXhMZW5ndGgsIFwiYWN0dWFsTGVuZ3RoXCI6IHYubGVuZ3RoIH0gfSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdG9ycy5udWxsVmFsaWRhdG9yID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBWYWxpZGF0b3JzLmNvbXBvc2UgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWxpZGF0b3JzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvcjtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZWR1Y2UodmFsaWRhdG9ycywgZnVuY3Rpb24gKHJlcywgdmFsaWRhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gdmFsaWRhdG9yKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoZXJyb3JzKSA/IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHJlcywgZXJyb3JzKSA6IHJlcztcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuaXNFbXB0eShyZXMpID8gbnVsbCA6IHJlcztcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRvcnMuZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICB2YXIgcmVzID0ge307XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChncm91cC5jb250cm9scywgZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwLmNvbnRhaW5zKG5hbWUpICYmIGxhbmdfMS5pc1ByZXNlbnQoY29udHJvbC5lcnJvcnMpKSB7XHJcbiAgICAgICAgICAgICAgICBWYWxpZGF0b3JzLl9tZXJnZUVycm9ycyhjb250cm9sLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmlzRW1wdHkocmVzKSA/IG51bGwgOiByZXM7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdG9ycy5hcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICBhcnJheS5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRyb2wuZXJyb3JzKSkge1xyXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5fbWVyZ2VFcnJvcnMoY29udHJvbCwgcmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5pc0VtcHR5KHJlcykgPyBudWxsIDogcmVzO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRvcnMuX21lcmdlRXJyb3JzID0gZnVuY3Rpb24gKGNvbnRyb2wsIHJlcykge1xyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goY29udHJvbC5lcnJvcnMsIGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhyZXMsIGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzW2Vycm9yXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gcmVzW2Vycm9yXTtcclxuICAgICAgICAgICAgY3VycmVudC5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWYWxpZGF0b3JzO1xyXG59KSgpO1xyXG5leHBvcnRzLlZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4uL3Byb2ZpbGUvcHJvZmlsZScpO1xyXG4vKipcclxuICogUHJvdmlkZXMgYWNjZXNzIHRvIGV4cGxpY2l0bHkgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGluIGFuIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBgWm9uZWAgdHJpZ2dlcnMgY2hhbmdlIGRldGVjdGlvbiBpbiBBbmd1bGFyIG9uIGVhY2ggdmlydHVhbCBtYWNoaW5lIChWTSkgdHVybi4gV2hlblxyXG4gKiB0ZXN0aW5nLCBvciBpbiBzb21lXHJcbiAqIGxpbWl0ZWQgYXBwbGljYXRpb24gdXNlIGNhc2VzLCBhIGRldmVsb3BlciBjYW4gYWxzbyB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gd2l0aCB0aGVcclxuICogYGxpZmVjeWNsZS50aWNrKClgIG1ldGhvZC5cclxuICpcclxuICogRWFjaCBBbmd1bGFyIGFwcGxpY2F0aW9uIGhhcyBhIHNpbmdsZSBgTGlmZUN5Y2xlYCBpbnN0YW5jZS5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBjb250cml2ZWQgZXhhbXBsZSwgc2luY2UgdGhlIGJvb3RzdHJhcCBhdXRvbWF0aWNhbGx5IHJ1bnMgaW5zaWRlIG9mIHRoZSBgWm9uZWAsIHdoaWNoXHJcbiAqIGludm9rZXNcclxuICogYGxpZmVjeWNsZS50aWNrKClgIG9uIHlvdXIgYmVoYWxmLlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGJvb3RzdHJhcChNeUFwcCkudGhlbigocmVmOkNvbXBvbmVudFJlZikgPT4ge1xyXG4gKiAgIHZhciBsaWZlQ3ljbGUgPSByZWYuaW5qZWN0b3IuZ2V0KExpZmVDeWNsZSk7XHJcbiAqICAgdmFyIG15QXBwID0gcmVmLmluc3RhbmNlO1xyXG4gKlxyXG4gKiAgIHJlZi5kb1NvbWV0aGluZygpO1xyXG4gKiAgIGxpZmVjeWNsZS50aWNrKCk7XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBMaWZlQ3ljbGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGlmZUN5Y2xlKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExpZmVDeWNsZTtcclxufSkoKTtcclxuZXhwb3J0cy5MaWZlQ3ljbGUgPSBMaWZlQ3ljbGU7XHJcbnZhciBMaWZlQ3ljbGVfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaWZlQ3ljbGVfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlmZUN5Y2xlXyhjaGFuZ2VEZXRlY3RvciwgZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xyXG4gICAgICAgIGlmIChjaGFuZ2VEZXRlY3RvciA9PT0gdm9pZCAwKSB7IGNoYW5nZURldGVjdG9yID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChlbmZvcmNlTm9OZXdDaGFuZ2VzID09PSB2b2lkIDApIHsgZW5mb3JjZU5vTmV3Q2hhbmdlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JzID0gW107XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlRGV0ZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9ycy5wdXNoKGNoYW5nZURldGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcyA9IGVuZm9yY2VOb05ld0NoYW5nZXM7XHJcbiAgICB9XHJcbiAgICBMaWZlQ3ljbGVfLnByb3RvdHlwZS5yZWdpc3RlcldpdGggPSBmdW5jdGlvbiAoem9uZSwgY2hhbmdlRGV0ZWN0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjaGFuZ2VEZXRlY3RvciA9PT0gdm9pZCAwKSB7IGNoYW5nZURldGVjdG9yID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNoYW5nZURldGVjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvcnMucHVzaChjaGFuZ2VEZXRlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHpvbmUub3ZlcnJpZGVPblR1cm5Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpY2soKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTGlmZUN5Y2xlXy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcnVubmluZ1RpY2spIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTGlmZUN5Y2xlLnRpY2sgaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcyA9IExpZmVDeWNsZV8uX3RpY2tTY29wZSgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRldGVjdG9yKSB7IHJldHVybiBkZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7IH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRldGVjdG9yKSB7IHJldHVybiBkZXRlY3Rvci5jaGVja05vQ2hhbmdlcygpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgcHJvZmlsZV8xLnd0ZkxlYXZlKHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaWZlQ3ljbGVfLl90aWNrU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0xpZmVDeWNsZSN0aWNrKCknKTtcclxuICAgIExpZmVDeWNsZV8gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0LCBCb29sZWFuXSlcclxuICAgIF0sIExpZmVDeWNsZV8pO1xyXG4gICAgcmV0dXJuIExpZmVDeWNsZV87XHJcbn0pKExpZmVDeWNsZSk7XHJcbmV4cG9ydHMuTGlmZUN5Y2xlXyA9IExpZmVDeWNsZV87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZmVfY3ljbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFB1YmxpYyBBUEkgZm9yIExpZmVDeWNsZVxyXG52YXIgbGlmZV9jeWNsZV8xID0gcmVxdWlyZSgnLi9saWZlX2N5Y2xlL2xpZmVfY3ljbGUnKTtcclxuZXhwb3J0cy5MaWZlQ3ljbGUgPSBsaWZlX2N5Y2xlXzEuTGlmZUN5Y2xlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlY3ljbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8vIFB1YmxpYyBBUEkgZm9yIGNvbXBpbGVyXHJcbnZhciBkaXJlY3RpdmVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2RpcmVjdGl2ZV9yZXNvbHZlcicpO1xyXG5leHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gZGlyZWN0aXZlX3Jlc29sdmVyXzEuRGlyZWN0aXZlUmVzb2x2ZXI7XHJcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvY29tcGlsZXInKTtcclxuZXhwb3J0cy5Db21waWxlciA9IGNvbXBpbGVyXzEuQ29tcGlsZXI7XHJcbnZhciB2aWV3X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfbWFuYWdlcicpO1xyXG5leHBvcnRzLkFwcFZpZXdNYW5hZ2VyID0gdmlld19tYW5hZ2VyXzEuQXBwVmlld01hbmFnZXI7XHJcbnZhciBxdWVyeV9saXN0XzEgPSByZXF1aXJlKCcuL2xpbmtlci9xdWVyeV9saXN0Jyk7XHJcbmV4cG9ydHMuUXVlcnlMaXN0ID0gcXVlcnlfbGlzdF8xLlF1ZXJ5TGlzdDtcclxudmFyIGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvZHluYW1pY19jb21wb25lbnRfbG9hZGVyJyk7XHJcbmV4cG9ydHMuRHluYW1pY0NvbXBvbmVudExvYWRlciA9IGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8xLkR5bmFtaWNDb21wb25lbnRMb2FkZXI7XHJcbnZhciBlbGVtZW50X3JlZl8xID0gcmVxdWlyZSgnLi9saW5rZXIvZWxlbWVudF9yZWYnKTtcclxuZXhwb3J0cy5FbGVtZW50UmVmID0gZWxlbWVudF9yZWZfMS5FbGVtZW50UmVmO1xyXG52YXIgdGVtcGxhdGVfcmVmXzEgPSByZXF1aXJlKCcuL2xpbmtlci90ZW1wbGF0ZV9yZWYnKTtcclxuZXhwb3J0cy5UZW1wbGF0ZVJlZiA9IHRlbXBsYXRlX3JlZl8xLlRlbXBsYXRlUmVmO1xyXG52YXIgdmlld19yZWZfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfcmVmJyk7XHJcbmV4cG9ydHMuVmlld1JlZiA9IHZpZXdfcmVmXzEuVmlld1JlZjtcclxuZXhwb3J0cy5Qcm90b1ZpZXdSZWYgPSB2aWV3X3JlZl8xLlByb3RvVmlld1JlZjtcclxudmFyIHZpZXdfY29udGFpbmVyX3JlZl8xID0gcmVxdWlyZSgnLi9saW5rZXIvdmlld19jb250YWluZXJfcmVmJyk7XHJcbmV4cG9ydHMuVmlld0NvbnRhaW5lclJlZiA9IHZpZXdfY29udGFpbmVyX3JlZl8xLlZpZXdDb250YWluZXJSZWY7XHJcbnZhciBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMiA9IHJlcXVpcmUoJy4vbGlua2VyL2R5bmFtaWNfY29tcG9uZW50X2xvYWRlcicpO1xyXG5leHBvcnRzLkNvbXBvbmVudFJlZiA9IGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8yLkNvbXBvbmVudFJlZjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlua2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgcHJvdG9fdmlld19mYWN0b3J5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvcHJvdG9fdmlld19mYWN0b3J5Jyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciB0ZW1wbGF0ZV9jb21tYW5kc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbGlua2VyL3RlbXBsYXRlX2NvbW1hbmRzJyk7XHJcbi8qKlxyXG4gKiBMb3ctbGV2ZWwgc2VydmljZSBmb3IgY29tcGlsaW5nIHtAbGluayBDb21wb25lbnR9cyBpbnRvIHtAbGluayBQcm90b1ZpZXdSZWYgUHJvdG9WaWV3c31zLCB3aGljaFxyXG4gKiBjYW4gbGF0ZXIgYmUgdXNlZCB0byBjcmVhdGUgYW5kIHJlbmRlciBhIENvbXBvbmVudCBpbnN0YW5jZS5cclxuICpcclxuICogTW9zdCBhcHBsaWNhdGlvbnMgc2hvdWxkIGluc3RlYWQgdXNlIGhpZ2hlci1sZXZlbCB7QGxpbmsgRHluYW1pY0NvbXBvbmVudExvYWRlcn0gc2VydmljZSwgd2hpY2hcclxuICogYm90aCBjb21waWxlcyBhbmQgaW5zdGFudGlhdGVzIGEgQ29tcG9uZW50LlxyXG4gKi9cclxudmFyIENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBpbGVyKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbXBpbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7XHJcbnZhciBDb21waWxlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbXBpbGVyXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbXBpbGVyXyhfcHJvdG9WaWV3RmFjdG9yeSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkgPSBfcHJvdG9WaWV3RmFjdG9yeTtcclxuICAgIH1cclxuICAgIENvbXBpbGVyXy5wcm90b3R5cGUuY29tcGlsZUluSG9zdCA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhcyA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuYW5ub3RhdGlvbnMoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgdmFyIGNvbXBpbGVkSG9zdFRlbXBsYXRlID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBtZXRhZGF0YXNbaV07XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIHRlbXBsYXRlX2NvbW1hbmRzXzEuQ29tcGlsZWRIb3N0VGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVkSG9zdFRlbXBsYXRlID0gbWV0YWRhdGE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcGlsZWRIb3N0VGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vIHByZWNvbXBpbGVkIHRlbXBsYXRlIGZvciBjb21wb25lbnQgXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGNvbXBvbmVudFR5cGUpICsgXCIgZm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodGhpcy5fY3JlYXRlUHJvdG9WaWV3KGNvbXBpbGVkSG9zdFRlbXBsYXRlKSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcGlsZXJfLnByb3RvdHlwZS5fY3JlYXRlUHJvdG9WaWV3ID0gZnVuY3Rpb24gKGNvbXBpbGVkSG9zdFRlbXBsYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkuY3JlYXRlSG9zdChjb21waWxlZEhvc3RUZW1wbGF0ZSkucmVmO1xyXG4gICAgfTtcclxuICAgIENvbXBpbGVyXy5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcHJvdG9WaWV3RmFjdG9yeS5jbGVhckNhY2hlKCk7IH07XHJcbiAgICBDb21waWxlcl8gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbcHJvdG9fdmlld19mYWN0b3J5XzEuUHJvdG9WaWV3RmFjdG9yeV0pXHJcbiAgICBdLCBDb21waWxlcl8pO1xyXG4gICAgcmV0dXJuIENvbXBpbGVyXztcclxufSkoQ29tcGlsZXIpO1xyXG5leHBvcnRzLkNvbXBpbGVyXyA9IENvbXBpbGVyXztcclxuZnVuY3Rpb24gaW50ZXJuYWxDcmVhdGVQcm90b1ZpZXcoY29tcGlsZXIsIGNvbXBpbGVkSG9zdFRlbXBsYXRlKSB7XHJcbiAgICByZXR1cm4gY29tcGlsZXIuX2NyZWF0ZVByb3RvVmlldyhjb21waWxlZEhvc3RUZW1wbGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5pbnRlcm5hbENyZWF0ZVByb3RvVmlldyA9IGludGVybmFsQ3JlYXRlUHJvdG9WaWV3O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMnKTtcclxuZnVuY3Rpb24gaGFzTGlmZWN5Y2xlSG9vayhsY0ludGVyZmFjZSwgdG9rZW4pIHtcclxuICAgIGlmICghKHRva2VuIGluc3RhbmNlb2YgbGFuZ18xLlR5cGUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IHRva2VuLnByb3RvdHlwZTtcclxuICAgIHN3aXRjaCAobGNJbnRlcmZhY2UpIHtcclxuICAgICAgICBjYXNlIGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0OlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5hZnRlckNvbnRlbnRJbml0O1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQ6XHJcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLmFmdGVyQ29udGVudENoZWNrZWQ7XHJcbiAgICAgICAgY2FzZSBpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdDpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8uYWZ0ZXJWaWV3SW5pdDtcclxuICAgICAgICBjYXNlIGludGVyZmFjZXNfMS5MaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkOlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5hZnRlclZpZXdDaGVja2VkO1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlczpcclxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8ub25DaGFuZ2VzO1xyXG4gICAgICAgIGNhc2UgaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XHJcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLmRvQ2hlY2s7XHJcbiAgICAgICAgY2FzZSBpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5vbkRlc3Ryb3k7XHJcbiAgICAgICAgY2FzZSBpbnRlcmZhY2VzXzEuTGlmZWN5Y2xlSG9va3MuT25Jbml0OlxyXG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5vbkluaXQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuaGFzTGlmZWN5Y2xlSG9vayA9IGhhc0xpZmVjeWNsZUhvb2s7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZV9saWZlY3ljbGVfcmVmbGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG4vKlxyXG4gKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9LlxyXG4gKlxyXG4gKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XHJcbiAqL1xyXG52YXIgRGlyZWN0aXZlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9IGZvciBhIGdpdmVuIGBUeXBlYC5cclxuICAgICAqL1xyXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGRpXzEucmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTWV0YWRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHR5cGVNZXRhZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuRGlyZWN0aXZlTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNZXRhZGF0YSA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IucHJvcE1ldGFkYXRhKHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhKG1ldGFkYXRhLCBwcm9wZXJ0eU1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBEaXJlY3RpdmUgYW5ub3RhdGlvbiBmb3VuZCBvbiBcIiArIGxhbmdfMS5zdHJpbmdpZnkodHlwZSkpO1xyXG4gICAgfTtcclxuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YSA9IGZ1bmN0aW9uIChkbSwgcHJvcGVydHlNZXRhZGF0YSkge1xyXG4gICAgICAgIHZhciBpbnB1dHMgPSBbXTtcclxuICAgICAgICB2YXIgb3V0cHV0cyA9IFtdO1xyXG4gICAgICAgIHZhciBob3N0ID0ge307XHJcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSB7fTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHByb3BlcnR5TWV0YWRhdGEsIGZ1bmN0aW9uIChtZXRhZGF0YSwgcHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLklucHV0TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgYS5iaW5kaW5nUHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuT3V0cHV0TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIGEuYmluZGluZ1Byb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Ib3N0QmluZGluZ01ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYS5ob3N0UHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIGEuaG9zdFByb3BlcnR5TmFtZSArIFwiXVwiKV0gPSBwcm9wTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RbKFwiW1wiICsgcHJvcE5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkhvc3RMaXN0ZW5lck1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBsYW5nXzEuaXNQcmVzZW50KGEuYXJncykgPyBhLmFyZ3Muam9pbignLCAnKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RbKFwiKFwiICsgYS5ldmVudE5hbWUgKyBcIilcIildID0gcHJvcE5hbWUgKyBcIihcIiArIGFyZ3MgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5WaWV3Q2hpbGRyZW5NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5Db250ZW50Q2hpbGRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5WaWV3Q2hpbGRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMpO1xyXG4gICAgfTtcclxuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2UgPSBmdW5jdGlvbiAoZG0sIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcykge1xyXG4gICAgICAgIHZhciBtZXJnZWRJbnB1dHMgPSBsYW5nXzEuaXNQcmVzZW50KGRtLmlucHV0cykgPyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29uY2F0KGRtLmlucHV0cywgaW5wdXRzKSA6IGlucHV0cztcclxuICAgICAgICB2YXIgbWVyZ2VkT3V0cHV0cyA9IGxhbmdfMS5pc1ByZXNlbnQoZG0ub3V0cHV0cykgPyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29uY2F0KGRtLm91dHB1dHMsIG91dHB1dHMpIDogb3V0cHV0cztcclxuICAgICAgICB2YXIgbWVyZ2VkSG9zdCA9IGxhbmdfMS5pc1ByZXNlbnQoZG0uaG9zdCkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5tZXJnZShkbS5ob3N0LCBob3N0KSA6IGhvc3Q7XHJcbiAgICAgICAgdmFyIG1lcmdlZFF1ZXJpZXMgPSBsYW5nXzEuaXNQcmVzZW50KGRtLnF1ZXJpZXMpID8gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIubWVyZ2UoZG0ucXVlcmllcywgcXVlcmllcykgOiBxdWVyaWVzO1xyXG4gICAgICAgIGlmIChkbSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuQ29tcG9uZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZXRhZGF0YV8xLkNvbXBvbmVudE1ldGFkYXRhKHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkbS5zZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcclxuICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZG0uZXhwb3J0QXMsXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogZG0ubW9kdWxlSWQsXHJcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkbS5jaGFuZ2VEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRtLnByb3ZpZGVycyxcclxuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRtLnZpZXdQcm92aWRlcnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1ldGFkYXRhXzEuRGlyZWN0aXZlTWV0YWRhdGEoe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRtLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxyXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcclxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkbS5leHBvcnRBcyxcclxuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBkbS5tb2R1bGVJZCxcclxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRtLnByb3ZpZGVyc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIERpcmVjdGl2ZVJlc29sdmVyKTtcclxuICAgIHJldHVybiBEaXJlY3RpdmVSZXNvbHZlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVSZXNvbHZlciA9IERpcmVjdGl2ZVJlc29sdmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVfcmVzb2x2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCcuL2NvbXBpbGVyJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgdmlld19tYW5hZ2VyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvdmlld19tYW5hZ2VyJyk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGEgQ29tcG9uZW50IGNyZWF0ZWQgdmlhIHtAbGluayBEeW5hbWljQ29tcG9uZW50TG9hZGVyfS5cclxuICpcclxuICogYENvbXBvbmVudFJlZmAgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBDb21wb25lbnQgSW5zdGFuY2UgYXMgd2VsbCBvdGhlciBvYmplY3RzIHJlbGF0ZWQgdG8gdGhpc1xyXG4gKiBDb21wb25lbnQgSW5zdGFuY2UgYW5kIGFsbG93cyB5b3UgdG8gZGVzdHJveSB0aGUgQ29tcG9uZW50IEluc3RhbmNlIHZpYSB0aGUge0BsaW5rICNkaXNwb3NlfVxyXG4gKiBtZXRob2QuXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZigpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUge0BsaW5rIFZpZXdSZWZ9IG9mIHRoZSBIb3N0IFZpZXcgb2YgdGhpcyBDb21wb25lbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxvY2F0aW9uLnBhcmVudFZpZXc7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaG9zdENvbXBvbmVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRPRE8oaSk6IHRoaXMgYXBpIHNob3VsZCBiZSByZW1vdmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluc3RhbmNlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBDb21wb25lbnRSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcG9uZW50UmVmID0gQ29tcG9uZW50UmVmO1xyXG52YXIgQ29tcG9uZW50UmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29tcG9uZW50UmVmXywgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogVE9ETyhpKTogcmVmYWN0b3IgaW50byBwdWJsaWMvcHJpdmF0ZSBmaWVsZHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmXyhsb2NhdGlvbiwgaW5zdGFuY2UsIGNvbXBvbmVudFR5cGUsIGluamVjdG9yLCBfZGlzcG9zZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2UgPSBfZGlzcG9zZTtcclxuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImhvc3RDb21wb25lbnRUeXBlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhpcyBDb21wb25lbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUT0RPKGkpOiB0aGlzIGFwaSBzaG91bGQgYmUgcmVtb3ZlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb21wb25lbnRUeXBlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2Rpc3Bvc2UoKTsgfTtcclxuICAgIHJldHVybiBDb21wb25lbnRSZWZfO1xyXG59KShDb21wb25lbnRSZWYpO1xyXG5leHBvcnRzLkNvbXBvbmVudFJlZl8gPSBDb21wb25lbnRSZWZfO1xyXG4vKipcclxuICogU2VydmljZSBmb3IgaW5zdGFudGlhdGluZyBhIENvbXBvbmVudCBhbmQgYXR0YWNoaW5nIGl0IHRvIGEgVmlldyBhdCBhIHNwZWNpZmllZCBsb2NhdGlvbi5cclxuICovXHJcbnZhciBEeW5hbWljQ29tcG9uZW50TG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIER5bmFtaWNDb21wb25lbnRMb2FkZXIoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRHluYW1pY0NvbXBvbmVudExvYWRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EeW5hbWljQ29tcG9uZW50TG9hZGVyID0gRHluYW1pY0NvbXBvbmVudExvYWRlcjtcclxudmFyIER5bmFtaWNDb21wb25lbnRMb2FkZXJfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEeW5hbWljQ29tcG9uZW50TG9hZGVyXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIER5bmFtaWNDb21wb25lbnRMb2FkZXJfKF9jb21waWxlciwgX3ZpZXdNYW5hZ2VyKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZXIgPSBfY29tcGlsZXI7XHJcbiAgICAgICAgdGhpcy5fdmlld01hbmFnZXIgPSBfdmlld01hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBEeW5hbWljQ29tcG9uZW50TG9hZGVyXy5wcm90b3R5cGUubG9hZEFzUm9vdCA9IGZ1bmN0aW9uICh0eXBlLCBvdmVycmlkZVNlbGVjdG9yLCBpbmplY3Rvciwgb25EaXNwb3NlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZXIuY29tcGlsZUluSG9zdCh0eXBlKS50aGVuKGZ1bmN0aW9uIChob3N0UHJvdG9WaWV3UmVmKSB7XHJcbiAgICAgICAgICAgIHZhciBob3N0Vmlld1JlZiA9IF90aGlzLl92aWV3TWFuYWdlci5jcmVhdGVSb290SG9zdFZpZXcoaG9zdFByb3RvVmlld1JlZiwgb3ZlcnJpZGVTZWxlY3RvciwgaW5qZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgbmV3TG9jYXRpb24gPSBfdGhpcy5fdmlld01hbmFnZXIuZ2V0SG9zdEVsZW1lbnQoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuX3ZpZXdNYW5hZ2VyLmdldENvbXBvbmVudChuZXdMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBkaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3ZpZXdNYW5hZ2VyLmRlc3Ryb3lSb290SG9zdFZpZXcoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob25EaXNwb3NlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudFJlZl8obmV3TG9jYXRpb24sIGNvbXBvbmVudCwgdHlwZSwgaW5qZWN0b3IsIGRpc3Bvc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfLnByb3RvdHlwZS5sb2FkSW50b0xvY2F0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGhvc3RMb2NhdGlvbiwgYW5jaG9yTmFtZSwgcHJvdmlkZXJzKSB7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHByb3ZpZGVycyA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkTmV4dFRvTG9jYXRpb24odHlwZSwgdGhpcy5fdmlld01hbmFnZXIuZ2V0TmFtZWRFbGVtZW50SW5Db21wb25lbnRWaWV3KGhvc3RMb2NhdGlvbiwgYW5jaG9yTmFtZSksIHByb3ZpZGVycyk7XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY0NvbXBvbmVudExvYWRlcl8ucHJvdG90eXBlLmxvYWROZXh0VG9Mb2NhdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBsb2NhdGlvbiwgcHJvdmlkZXJzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAocHJvdmlkZXJzID09PSB2b2lkIDApIHsgcHJvdmlkZXJzID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlci5jb21waWxlSW5Ib3N0KHR5cGUpLnRoZW4oZnVuY3Rpb24gKGhvc3RQcm90b1ZpZXdSZWYpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBfdGhpcy5fdmlld01hbmFnZXIuZ2V0Vmlld0NvbnRhaW5lcihsb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBob3N0Vmlld1JlZiA9IHZpZXdDb250YWluZXIuY3JlYXRlSG9zdFZpZXcoaG9zdFByb3RvVmlld1JlZiwgdmlld0NvbnRhaW5lci5sZW5ndGgsIHByb3ZpZGVycyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdMb2NhdGlvbiA9IF90aGlzLl92aWV3TWFuYWdlci5nZXRIb3N0RWxlbWVudChob3N0Vmlld1JlZik7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5fdmlld01hbmFnZXIuZ2V0Q29tcG9uZW50KG5ld0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2aWV3Q29udGFpbmVyLmluZGV4T2YoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXIucmVtb3ZlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRSZWZfKG5ld0xvY2F0aW9uLCBjb21wb25lbnQsIHR5cGUsIG51bGwsIGRpc3Bvc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NvbXBpbGVyXzEuQ29tcGlsZXIsIHZpZXdfbWFuYWdlcl8xLkFwcFZpZXdNYW5hZ2VyXSlcclxuICAgIF0sIER5bmFtaWNDb21wb25lbnRMb2FkZXJfKTtcclxuICAgIHJldHVybiBEeW5hbWljQ29tcG9uZW50TG9hZGVyXztcclxufSkoRHluYW1pY0NvbXBvbmVudExvYWRlcik7XHJcbmV4cG9ydHMuRHluYW1pY0NvbXBvbmVudExvYWRlcl8gPSBEeW5hbWljQ29tcG9uZW50TG9hZGVyXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pY19jb21wb25lbnRfbG9hZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBFbGVtZW50QmluZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRCaW5kZXIoaW5kZXgsIHBhcmVudCwgZGlzdGFuY2VUb1BhcmVudCwgcHJvdG9FbGVtZW50SW5qZWN0b3IsIGNvbXBvbmVudERpcmVjdGl2ZSwgbmVzdGVkUHJvdG9WaWV3KSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudCA9IGRpc3RhbmNlVG9QYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wcm90b0VsZW1lbnRJbmplY3RvciA9IHByb3RvRWxlbWVudEluamVjdG9yO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlyZWN0aXZlID0gY29tcG9uZW50RGlyZWN0aXZlO1xyXG4gICAgICAgIHRoaXMubmVzdGVkUHJvdG9WaWV3ID0gbmVzdGVkUHJvdG9WaWV3O1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbmRleCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdudWxsIGluZGV4IG5vdCBhbGxvd2VkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBFbGVtZW50QmluZGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkVsZW1lbnRCaW5kZXIgPSBFbGVtZW50QmluZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X2JpbmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgaW5qZWN0b3JfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpL2luamVjdG9yJyk7XHJcbnZhciBwcm92aWRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGkvcHJvdmlkZXInKTtcclxudmFyIGRpXzIgPSByZXF1aXJlKCcuLi9tZXRhZGF0YS9kaScpO1xyXG52YXIgYXZtTW9kdWxlID0gcmVxdWlyZSgnLi92aWV3X21hbmFnZXInKTtcclxudmFyIHZpZXdfY29udGFpbmVyX3JlZl8xID0gcmVxdWlyZSgnLi92aWV3X2NvbnRhaW5lcl9yZWYnKTtcclxudmFyIGVsZW1lbnRfcmVmXzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfcmVmJyk7XHJcbnZhciB0ZW1wbGF0ZV9yZWZfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfcmVmJyk7XHJcbnZhciBkaXJlY3RpdmVzXzEgPSByZXF1aXJlKCcuLi9tZXRhZGF0YS9kaXJlY3RpdmVzJyk7XHJcbnZhciBkaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3RvcicpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XHJcbnZhciBxdWVyeV9saXN0XzEgPSByZXF1aXJlKCcuL3F1ZXJ5X2xpc3QnKTtcclxudmFyIHJlZmxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xyXG52YXIgZXZlbnRfY29uZmlnXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9saW5rZXIvZXZlbnRfY29uZmlnJyk7XHJcbnZhciBwaXBlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9waXBlcy9waXBlX3Byb3ZpZGVyJyk7XHJcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMnKTtcclxudmFyIHZpZXdfY29udGFpbmVyX3JlZl8yID0gcmVxdWlyZShcIi4vdmlld19jb250YWluZXJfcmVmXCIpO1xyXG52YXIgX3N0YXRpY0tleXM7XHJcbnZhciBTdGF0aWNLZXlzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXRpY0tleXMoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TWFuYWdlcklkID0gZGlfMS5LZXkuZ2V0KGF2bU1vZHVsZS5BcHBWaWV3TWFuYWdlcikuaWQ7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZklkID0gZGlfMS5LZXkuZ2V0KHRlbXBsYXRlX3JlZl8xLlRlbXBsYXRlUmVmKS5pZDtcclxuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJJZCA9IGRpXzEuS2V5LmdldCh2aWV3X2NvbnRhaW5lcl9yZWZfMS5WaWV3Q29udGFpbmVyUmVmKS5pZDtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmSWQgPSBkaV8xLktleS5nZXQoY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yUmVmKS5pZDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRSZWZJZCA9IGRpXzEuS2V5LmdldChlbGVtZW50X3JlZl8xLkVsZW1lbnRSZWYpLmlkO1xyXG4gICAgfVxyXG4gICAgU3RhdGljS2V5cy5pbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoX3N0YXRpY0tleXMpKVxyXG4gICAgICAgICAgICBfc3RhdGljS2V5cyA9IG5ldyBTdGF0aWNLZXlzKCk7XHJcbiAgICAgICAgcmV0dXJuIF9zdGF0aWNLZXlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdGF0aWNLZXlzO1xyXG59KSgpO1xyXG5leHBvcnRzLlN0YXRpY0tleXMgPSBTdGF0aWNLZXlzO1xyXG52YXIgVHJlZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZU5vZGUocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50KSkge1xyXG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkgeyBjaGlsZC5fcGFyZW50ID0gdGhpczsgfTtcclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BhcmVudCA9IG51bGw7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZU5vZGUucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFRyZWVOb2RlO1xyXG59KSgpO1xyXG5leHBvcnRzLlRyZWVOb2RlID0gVHJlZU5vZGU7XHJcbnZhciBEaXJlY3RpdmVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEaXJlY3RpdmVEZXBlbmRlbmN5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlRGVwZW5kZW5jeShrZXksIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIHByb3BlcnRpZXMsIGF0dHJpYnV0ZU5hbWUsIHF1ZXJ5RGVjb3JhdG9yKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywga2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgIHRoaXMucXVlcnlEZWNvcmF0b3IgPSBxdWVyeURlY29yYXRvcjtcclxuICAgICAgICB0aGlzLl92ZXJpZnkoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERpcmVjdGl2ZURlcGVuZGVuY3kucHJvdG90eXBlLl92ZXJpZnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5RGVjb3JhdG9yKSlcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmF0dHJpYnV0ZU5hbWUpKVxyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIGlmIChjb3VudCA+IDEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignQSBkaXJlY3RpdmUgaW5qZWN0YWJsZSBjYW4gY29udGFpbiBvbmx5IG9uZSBvZiB0aGUgZm9sbG93aW5nIEBBdHRyaWJ1dGUgb3IgQFF1ZXJ5LicpO1xyXG4gICAgfTtcclxuICAgIERpcmVjdGl2ZURlcGVuZGVuY3kuY3JlYXRlRnJvbSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVEZXBlbmRlbmN5KGQua2V5LCBkLm9wdGlvbmFsLCBkLmxvd2VyQm91bmRWaXNpYmlsaXR5LCBkLnVwcGVyQm91bmRWaXNpYmlsaXR5LCBkLnByb3BlcnRpZXMsIERpcmVjdGl2ZURlcGVuZGVuY3kuX2F0dHJpYnV0ZU5hbWUoZC5wcm9wZXJ0aWVzKSwgRGlyZWN0aXZlRGVwZW5kZW5jeS5fcXVlcnkoZC5wcm9wZXJ0aWVzKSk7XHJcbiAgICB9O1xyXG4gICAgRGlyZWN0aXZlRGVwZW5kZW5jeS5fYXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIHAgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmluZChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcCBpbnN0YW5jZW9mIGRpXzIuQXR0cmlidXRlTWV0YWRhdGE7IH0pO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHApID8gcC5hdHRyaWJ1dGVOYW1lIDogbnVsbDtcclxuICAgIH07XHJcbiAgICBEaXJlY3RpdmVEZXBlbmRlbmN5Ll9xdWVyeSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maW5kKHByb3BlcnRpZXMsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwIGluc3RhbmNlb2YgZGlfMi5RdWVyeU1ldGFkYXRhOyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlRGVwZW5kZW5jeTtcclxufSkoZGlfMS5EZXBlbmRlbmN5KTtcclxuZXhwb3J0cy5EaXJlY3RpdmVEZXBlbmRlbmN5ID0gRGlyZWN0aXZlRGVwZW5kZW5jeTtcclxudmFyIERpcmVjdGl2ZVByb3ZpZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEaXJlY3RpdmVQcm92aWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVByb3ZpZGVyKGtleSwgZmFjdG9yeSwgZGVwcywgbWV0YWRhdGEsIHByb3ZpZGVycywgdmlld1Byb3ZpZGVycykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGtleSwgW25ldyBwcm92aWRlcl8xLlJlc29sdmVkRmFjdG9yeShmYWN0b3J5LCBkZXBzKV0sIGZhbHNlKTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XHJcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gdmlld1Byb3ZpZGVycztcclxuICAgICAgICB0aGlzLmNhbGxPbkRlc3Ryb3kgPSBkaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaW50ZXJmYWNlc18xLkxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSwga2V5LnRva2VuKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVQcm92aWRlci5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXkuZGlzcGxheU5hbWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJxdWVyaWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMubWV0YWRhdGEucXVlcmllcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0aGlzLm1ldGFkYXRhLnF1ZXJpZXMsIGZ1bmN0aW9uIChtZXRhLCBmaWVsZE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLnNldHRlcihmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2gobmV3IFF1ZXJ5TWV0YWRhdGFXaXRoU2V0dGVyKHNldHRlciwgbWV0YSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVQcm92aWRlci5wcm90b3R5cGUsIFwiZXZlbnRFbWl0dGVyc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMubWV0YWRhdGEpICYmIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5tZXRhZGF0YS5vdXRwdXRzKSA/IHRoaXMubWV0YWRhdGEub3V0cHV0cyA6XHJcbiAgICAgICAgICAgICAgICBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERpcmVjdGl2ZVByb3ZpZGVyLmNyZWF0ZUZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgbWV0YSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtZXRhKSkge1xyXG4gICAgICAgICAgICBtZXRhID0gbmV3IGRpcmVjdGl2ZXNfMS5EaXJlY3RpdmVNZXRhZGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmIgPSBwcm92aWRlcl8xLnJlc29sdmVQcm92aWRlcihwcm92aWRlcik7XHJcbiAgICAgICAgdmFyIHJmID0gcmIucmVzb2x2ZWRGYWN0b3JpZXNbMF07XHJcbiAgICAgICAgdmFyIGRlcHMgPSByZi5kZXBlbmRlbmNpZXMubWFwKERpcmVjdGl2ZURlcGVuZGVuY3kuY3JlYXRlRnJvbSk7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVycyA9IGxhbmdfMS5pc1ByZXNlbnQobWV0YS5wcm92aWRlcnMpID8gbWV0YS5wcm92aWRlcnMgOiBbXTtcclxuICAgICAgICB2YXIgdmlld0JpbmRpZ3MgPSBtZXRhIGluc3RhbmNlb2YgZGlyZWN0aXZlc18xLkNvbXBvbmVudE1ldGFkYXRhICYmIGxhbmdfMS5pc1ByZXNlbnQobWV0YS52aWV3UHJvdmlkZXJzKSA/XHJcbiAgICAgICAgICAgIG1ldGEudmlld1Byb3ZpZGVycyA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlUHJvdmlkZXIocmIua2V5LCByZi5mYWN0b3J5LCBkZXBzLCBtZXRhLCBwcm92aWRlcnMsIHZpZXdCaW5kaWdzKTtcclxuICAgIH07XHJcbiAgICBEaXJlY3RpdmVQcm92aWRlci5jcmVhdGVGcm9tVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBhbm5vdGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IGRpXzEuUHJvdmlkZXIodHlwZSwgeyB1c2VDbGFzczogdHlwZSB9KTtcclxuICAgICAgICByZXR1cm4gRGlyZWN0aXZlUHJvdmlkZXIuY3JlYXRlRnJvbVByb3ZpZGVyKHByb3ZpZGVyLCBhbm5vdGF0aW9uKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlUHJvdmlkZXI7XHJcbn0pKHByb3ZpZGVyXzEuUmVzb2x2ZWRQcm92aWRlcl8pO1xyXG5leHBvcnRzLkRpcmVjdGl2ZVByb3ZpZGVyID0gRGlyZWN0aXZlUHJvdmlkZXI7XHJcbi8vIFRPRE8ocmFkbyk6IGJlbmNobWFyayBhbmQgY29uc2lkZXIgcm9sbGluZyBpbiBhcyBFbGVtZW50SW5qZWN0b3IgZmllbGRzLlxyXG52YXIgUHJlQnVpbHRPYmplY3RzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZUJ1aWx0T2JqZWN0cyh2aWV3TWFuYWdlciwgdmlldywgZWxlbWVudFJlZiwgdGVtcGxhdGVSZWYpIHtcclxuICAgICAgICB0aGlzLnZpZXdNYW5hZ2VyID0gdmlld01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgICAgICB0aGlzLm5lc3RlZFZpZXcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByZUJ1aWx0T2JqZWN0cztcclxufSkoKTtcclxuZXhwb3J0cy5QcmVCdWlsdE9iamVjdHMgPSBQcmVCdWlsdE9iamVjdHM7XHJcbnZhciBRdWVyeU1ldGFkYXRhV2l0aFNldHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRdWVyeU1ldGFkYXRhV2l0aFNldHRlcihzZXR0ZXIsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFF1ZXJ5TWV0YWRhdGFXaXRoU2V0dGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlF1ZXJ5TWV0YWRhdGFXaXRoU2V0dGVyID0gUXVlcnlNZXRhZGF0YVdpdGhTZXR0ZXI7XHJcbnZhciBFdmVudEVtaXR0ZXJBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXJBY2Nlc3NvcihldmVudE5hbWUsIGdldHRlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xyXG4gICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgfVxyXG4gICAgRXZlbnRFbWl0dGVyQWNjZXNzb3IucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh2aWV3LCBib3VuZEVsZW1lbnRJbmRleCwgZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gdGhpcy5nZXR0ZXIoZGlyZWN0aXZlKTtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUoZXZlbnRFbWl0dGVyLCBmdW5jdGlvbiAoZXZlbnRPYmopIHsgcmV0dXJuIHZpZXcudHJpZ2dlckV2ZW50SGFuZGxlcnMoX3RoaXMuZXZlbnROYW1lLCBldmVudE9iaiwgYm91bmRFbGVtZW50SW5kZXgpOyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyQWNjZXNzb3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRXZlbnRFbWl0dGVyQWNjZXNzb3IgPSBFdmVudEVtaXR0ZXJBY2Nlc3NvcjtcclxuZnVuY3Rpb24gX2NyZWF0ZUV2ZW50RW1pdHRlckFjY2Vzc29ycyhid3YpIHtcclxuICAgIHZhciBwcm92aWRlciA9IGJ3di5wcm92aWRlcjtcclxuICAgIGlmICghKHByb3ZpZGVyIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIpKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIHZhciBkYiA9IHByb3ZpZGVyO1xyXG4gICAgcmV0dXJuIGRiLmV2ZW50RW1pdHRlcnMubWFwKGZ1bmN0aW9uIChldmVudENvbmZpZykge1xyXG4gICAgICAgIHZhciBwYXJzZWRFdmVudCA9IGV2ZW50X2NvbmZpZ18xLkV2ZW50Q29uZmlnLnBhcnNlKGV2ZW50Q29uZmlnKTtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RW1pdHRlckFjY2Vzc29yKHBhcnNlZEV2ZW50LmV2ZW50TmFtZSwgcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5nZXR0ZXIocGFyc2VkRXZlbnQuZmllbGROYW1lKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlUHJvdG9RdWVyeVJlZnMocHJvdmlkZXJzKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleChwcm92aWRlcnMsIGZ1bmN0aW9uIChiLCBpKSB7XHJcbiAgICAgICAgaWYgKGIucHJvdmlkZXIgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlcikge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlUHJvdmlkZXIgPSBiLnByb3ZpZGVyO1xyXG4gICAgICAgICAgICAvLyBmaWVsZCBxdWVyaWVzXHJcbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gZGlyZWN0aXZlUHJvdmlkZXIucXVlcmllcztcclxuICAgICAgICAgICAgcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxKSB7IHJldHVybiByZXMucHVzaChuZXcgUHJvdG9RdWVyeVJlZihpLCBxLnNldHRlciwgcS5tZXRhZGF0YSkpOyB9KTtcclxuICAgICAgICAgICAgLy8gcXVlcmllcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFmdGVyIGNvbnN0cnVjdG9yIHF1ZXJpZXMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgdmFyIGRlcHMgPSBkaXJlY3RpdmVQcm92aWRlci5yZXNvbHZlZEZhY3RvcnkuZGVwZW5kZW5jaWVzO1xyXG4gICAgICAgICAgICBkZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGQucXVlcnlEZWNvcmF0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5ldyBQcm90b1F1ZXJ5UmVmKGksIG51bGwsIGQucXVlcnlEZWNvcmF0b3IpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbnZhciBQcm90b0VsZW1lbnRJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b0VsZW1lbnRJbmplY3RvcihwYXJlbnQsIGluZGV4LCBid3YsIGRpc3RhbmNlVG9QYXJlbnQsIF9maXJzdFByb3ZpZGVySXNDb21wb25lbnQsIGRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50ID0gZGlzdGFuY2VUb1BhcmVudDtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3MgPSBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCA9IF9maXJzdFByb3ZpZGVySXNDb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ3di5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5wcm90b0luamVjdG9yID0gbmV3IGluamVjdG9yXzEuUHJvdG9JbmplY3Rvcihid3YpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyQWNjZXNzb3JzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShsZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXJBY2Nlc3NvcnNbaV0gPSBfY3JlYXRlRXZlbnRFbWl0dGVyQWNjZXNzb3JzKGJ3dltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvdG9RdWVyeVJlZnMgPSBfY3JlYXRlUHJvdG9RdWVyeVJlZnMoYnd2KTtcclxuICAgIH1cclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGluZGV4LCBwcm92aWRlcnMsIGZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCwgZGlzdGFuY2VUb1BhcmVudCwgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncykge1xyXG4gICAgICAgIHZhciBiZCA9IFtdO1xyXG4gICAgICAgIFByb3RvRWxlbWVudEluamVjdG9yLl9jcmVhdGVEaXJlY3RpdmVQcm92aWRlcldpdGhWaXNpYmlsaXR5KHByb3ZpZGVycywgYmQsIGZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlVmlld1Byb3ZpZGVyc1dpdGhWaXNpYmlsaXR5KHByb3ZpZGVycywgYmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlUHJvdmlkZXJzV2l0aFZpc2liaWxpdHkocHJvdmlkZXJzLCBiZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm90b0VsZW1lbnRJbmplY3RvcihwYXJlbnQsIGluZGV4LCBiZCwgZGlzdGFuY2VUb1BhcmVudCwgZmlyc3RQcm92aWRlcklzQ29tcG9uZW50LCBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzKTtcclxuICAgIH07XHJcbiAgICBQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlRGlyZWN0aXZlUHJvdmlkZXJXaXRoVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChkaXJQcm92aWRlcnMsIGJkLCBmaXJzdFByb3ZpZGVySXNDb21wb25lbnQpIHtcclxuICAgICAgICBkaXJQcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgYmQucHVzaChQcm90b0VsZW1lbnRJbmplY3Rvci5fY3JlYXRlUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShmaXJzdFByb3ZpZGVySXNDb21wb25lbnQsIGRpclByb3ZpZGVyLCBkaXJQcm92aWRlcnMsIGRpclByb3ZpZGVyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9FbGVtZW50SW5qZWN0b3IuX2NyZWF0ZVByb3ZpZGVyc1dpdGhWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKGRpclByb3ZpZGVycywgYmQpIHtcclxuICAgICAgICB2YXIgcHJvdmlkZXJzRnJvbUFsbERpcmVjdGl2ZXMgPSBbXTtcclxuICAgICAgICBkaXJQcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzRnJvbUFsbERpcmVjdGl2ZXMgPVxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChwcm92aWRlcnNGcm9tQWxsRGlyZWN0aXZlcywgZGlyUHJvdmlkZXIucHJvdmlkZXJzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBkaV8xLkluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzRnJvbUFsbERpcmVjdGl2ZXMpO1xyXG4gICAgICAgIHJlc29sdmVkLmZvckVhY2goZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGJkLnB1c2gobmV3IGluamVjdG9yXzEuUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShiLCBpbmplY3Rvcl8xLlZpc2liaWxpdHkuUHVibGljKSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLl9jcmVhdGVQcm92aWRlcldpdGhWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKGZpcnN0UHJvdmlkZXJJc0NvbXBvbmVudCwgZGlyUHJvdmlkZXIsIGRpclByb3ZpZGVycywgcHJvdmlkZXIpIHtcclxuICAgICAgICB2YXIgaXNDb21wb25lbnQgPSBmaXJzdFByb3ZpZGVySXNDb21wb25lbnQgJiYgZGlyUHJvdmlkZXJzWzBdID09PSBkaXJQcm92aWRlcjtcclxuICAgICAgICByZXR1cm4gbmV3IGluamVjdG9yXzEuUHJvdmlkZXJXaXRoVmlzaWJpbGl0eShwcm92aWRlciwgaXNDb21wb25lbnQgPyBpbmplY3Rvcl8xLlZpc2liaWxpdHkuUHVibGljQW5kUHJpdmF0ZSA6IGluamVjdG9yXzEuVmlzaWJpbGl0eS5QdWJsaWMpO1xyXG4gICAgfTtcclxuICAgIFByb3RvRWxlbWVudEluamVjdG9yLl9jcmVhdGVWaWV3UHJvdmlkZXJzV2l0aFZpc2liaWxpdHkgPSBmdW5jdGlvbiAoZGlyUHJvdmlkZXJzLCBiZCkge1xyXG4gICAgICAgIHZhciByZXNvbHZlZFZpZXdQcm92aWRlcnMgPSBkaV8xLkluamVjdG9yLnJlc29sdmUoZGlyUHJvdmlkZXJzWzBdLnZpZXdQcm92aWRlcnMpO1xyXG4gICAgICAgIHJlc29sdmVkVmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7IHJldHVybiBiZC5wdXNoKG5ldyBpbmplY3Rvcl8xLlByb3ZpZGVyV2l0aFZpc2liaWxpdHkoYiwgaW5qZWN0b3JfMS5WaXNpYmlsaXR5LlByaXZhdGUpKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9FbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudEluamVjdG9yKHRoaXMsIHBhcmVudCk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9FbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmRpcmVjdFBhcmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BhcmVudCA8IDIgPyB0aGlzLnBhcmVudCA6IG51bGw7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdG9FbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLCBcImhhc0JpbmRpbmdzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyQWNjZXNzb3JzLmxlbmd0aCA+IDA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUHJvdG9FbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5wcm90b0luamVjdG9yLmdldFByb3ZpZGVyQXRJbmRleChpbmRleCk7IH07XHJcbiAgICByZXR1cm4gUHJvdG9FbGVtZW50SW5qZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9FbGVtZW50SW5qZWN0b3IgPSBQcm90b0VsZW1lbnRJbmplY3RvcjtcclxudmFyIF9Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9Db250ZXh0KGVsZW1lbnQsIGNvbXBvbmVudEVsZW1lbnQsIGluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudEVsZW1lbnQgPSBjb21wb25lbnRFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBfQ29udGV4dDtcclxufSkoKTtcclxudmFyIEVsZW1lbnRJbmplY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRWxlbWVudEluamVjdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9yKF9wcm90bywgcGFyZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJvdG8gPSBfcHJvdG87XHJcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPVxyXG4gICAgICAgICAgICBuZXcgZGlfMS5JbmplY3Rvcih0aGlzLl9wcm90by5wcm90b0luamVjdG9yLCBudWxsLCB0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVidWdDb250ZXh0KCk7IH0pO1xyXG4gICAgICAgIC8vIHdlIGNvdXBsZSBvdXJzZWx2ZXMgdG8gdGhlIGluamVjdG9yIHN0cmF0ZWd5IHRvIGF2b2lkIHBvbHltb3ByaGljIGNhbGxzXHJcbiAgICAgICAgdmFyIGluamVjdG9yU3RyYXRlZ3kgPSB0aGlzLl9pbmplY3Rvci5pbnRlcm5hbFN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gaW5qZWN0b3JTdHJhdGVneSBpbnN0YW5jZW9mIGluamVjdG9yXzEuSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA/XHJcbiAgICAgICAgICAgIG5ldyBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneShpbmplY3RvclN0cmF0ZWd5LCB0aGlzKSA6XHJcbiAgICAgICAgICAgIG5ldyBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3koaW5qZWN0b3JTdHJhdGVneSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5oeWRyYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5U3RyYXRlZ3kgPSB0aGlzLl9idWlsZFF1ZXJ5U3RyYXRlZ3koKTtcclxuICAgIH1cclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wcmVCdWlsdE9iamVjdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5LmNhbGxPbkRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5kZWh5ZHJhdGUoKTtcclxuICAgICAgICB0aGlzLl9xdWVyeVN0cmF0ZWd5LmRlaHlkcmF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uIChpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IsIGhvc3QsIHByZUJ1aWx0T2JqZWN0cykge1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xyXG4gICAgICAgIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cyA9IHByZUJ1aWx0T2JqZWN0cztcclxuICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9ycyhpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5U3RyYXRlZ3kuaHlkcmF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5Lmh5ZHJhdGUoKTtcclxuICAgICAgICB0aGlzLmh5ZHJhdGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLl9kZWJ1Z0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcmVCdWlsdE9iamVjdHM7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcC5lbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4IC0gcC52aWV3LmVsZW1lbnRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9wcmVCdWlsdE9iamVjdHMudmlldy5nZXREZWJ1Z0NvbnRleHQoaW5kZXgsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGMpID8gbmV3IF9Db250ZXh0KGMuZWxlbWVudCwgYy5jb21wb25lbnRFbGVtZW50LCBjLmluamVjdG9yKSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fcmVhdHRhY2hJbmplY3RvcnMgPSBmdW5jdGlvbiAoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKSB7XHJcbiAgICAgICAgLy8gRHluYW1pY2FsbHktbG9hZGVkIGNvbXBvbmVudCBpbiB0aGUgdGVtcGxhdGUuIE5vdCBhIHJvb3QgRWxlbWVudEluamVjdG9yLlxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3BhcmVudCkpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGltcGVyYXRpdmUgaW5qZWN0b3IgaXMgc2ltaWxhciB0byBoYXZpbmcgYW4gZWxlbWVudCBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZHluYW1pYy1sb2FkZWQgY29tcG9uZW50IGFuZCBpdHMgcGFyZW50ID0+IG5vIGJvdW5kYXJpZXMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKHRoaXMuX2luamVjdG9yLCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYXR0YWNoSW5qZWN0b3IoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCB0aGlzLl9wYXJlbnQuX2luamVjdG9yLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKHRoaXMuX2luamVjdG9yLCB0aGlzLl9wYXJlbnQuX2luamVjdG9yLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9ob3N0KSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW1wZXJhdGl2ZSBpbmplY3RvciBpcyBzaW1pbGFyIHRvIGhhdmluZyBhbiBlbGVtZW50IGJldHdlZW5cclxuICAgICAgICAgICAgLy8gdGhlIGR5bmFtaWMtbG9hZGVkIGNvbXBvbmVudCBhbmQgaXRzIHBhcmVudCA9PiBubyBib3VuZGFyeSBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgYW5kIGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3Rvci5cclxuICAgICAgICAgICAgLy8gQnV0IHNpbmNlIGl0IGlzIGEgcm9vdCBFbGVtZW50SW5qZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgYm91bmRhcnlcclxuICAgICAgICAgICAgLy8gYmV0d2VlbiBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IgYW5kIF9ob3N0LlxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKHRoaXMuX2luamVjdG9yLCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYXR0YWNoSW5qZWN0b3IoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCB0aGlzLl9ob3N0Ll9pbmplY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWF0dGFjaEluamVjdG9yKHRoaXMuX2luamVjdG9yLCB0aGlzLl9ob3N0Ll9pbmplY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYXR0YWNoSW5qZWN0b3IodGhpcy5faW5qZWN0b3IsIGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fcmVhdHRhY2hJbmplY3RvciA9IGZ1bmN0aW9uIChpbmplY3RvciwgcGFyZW50SW5qZWN0b3IsIGlzQm91bmRhcnkpIHtcclxuICAgICAgICBpbmplY3Rvci5pbnRlcm5hbFN0cmF0ZWd5LmF0dGFjaChwYXJlbnRJbmplY3RvciwgaXNCb3VuZGFyeSk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5oYXNWYXJpYWJsZUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB2YiA9IHRoaXMuX3Byb3RvLmRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3M7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodmIpICYmIHZiLmhhcyhuYW1lKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldFZhcmlhYmxlQmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcHJvdG8uZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncy5nZXQobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoaW5kZXgpID8gdGhpcy5nZXREaXJlY3RpdmVBdEluZGV4KGluZGV4KSA6IHRoaXMuZ2V0RWxlbWVudFJlZigpO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0aGlzLl9pbmplY3Rvci5nZXQodG9rZW4pOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5oYXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9pbmplY3Rvci5nZXRPcHRpb25hbCh0eXBlKSk7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldEV2ZW50RW1pdHRlckFjY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3RvLmV2ZW50RW1pdHRlckFjY2Vzc29yczsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG8uZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncztcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmdldENvbXBvbmVudCgpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRJbmplY3RvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXRFbGVtZW50UmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJlQnVpbHRPYmplY3RzLmVsZW1lbnRSZWY7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldFZpZXdDb250YWluZXJSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2aWV3X2NvbnRhaW5lcl9yZWZfMi5WaWV3Q29udGFpbmVyUmVmXyh0aGlzLl9wcmVCdWlsdE9iamVjdHMudmlld01hbmFnZXIsIHRoaXMuZ2V0RWxlbWVudFJlZigpKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldE5lc3RlZFZpZXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmVCdWlsdE9iamVjdHMubmVzdGVkVmlldzsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy52aWV3OyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5kaXJlY3RQYXJlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm90by5kaXN0YW5jZVRvUGFyZW50IDwgMiA/IHRoaXMucGFyZW50IDogbnVsbDsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuaXNDb21wb25lbnRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5pc0NvbXBvbmVudEtleShrZXkpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBwcm92aWRlciwgZGVwKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRlcC5rZXk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdmFyIGRpckRlcCA9IGRlcDtcclxuICAgICAgICAgICAgdmFyIGRpclByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgICAgIHZhciBzdGF0aWNLZXlzID0gU3RhdGljS2V5cy5pbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmlkID09PSBzdGF0aWNLZXlzLnZpZXdNYW5hZ2VySWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXdNYW5hZ2VyO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkaXJEZXAuYXR0cmlidXRlTmFtZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRBdHRyaWJ1dGUoZGlyRGVwKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyRGVwLnF1ZXJ5RGVjb3JhdG9yKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVN0cmF0ZWd5LmZpbmRRdWVyeShkaXJEZXAucXVlcnlEZWNvcmF0b3IpLmxpc3Q7XHJcbiAgICAgICAgICAgIGlmIChkaXJEZXAua2V5LmlkID09PSBTdGF0aWNLZXlzLmluc3RhbmNlKCkuY2hhbmdlRGV0ZWN0b3JSZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcHJvdmlkZSB0aGUgY29tcG9uZW50J3MgdmlldyBjaGFuZ2UgZGV0ZWN0b3IgdG8gY29tcG9uZW50cyBhbmRcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdXJyb3VuZGluZyBjb21wb25lbnQncyBjaGFuZ2UgZGV0ZWN0b3IgdG8gZGlyZWN0aXZlcy5cclxuICAgICAgICAgICAgICAgIGlmIChkaXJQcm92aWRlci5tZXRhZGF0YSBpbnN0YW5jZW9mIGRpcmVjdGl2ZXNfMS5Db21wb25lbnRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRWaWV3ID0gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXcuZ2V0TmVzdGVkVmlldyh0aGlzLl9wcmVCdWlsdE9iamVjdHMuZWxlbWVudFJlZi5ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFZpZXcuY2hhbmdlRGV0ZWN0b3IucmVmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy52aWV3LmNoYW5nZURldGVjdG9yLnJlZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyRGVwLmtleS5pZCA9PT0gU3RhdGljS2V5cy5pbnN0YW5jZSgpLmVsZW1lbnRSZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudFJlZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJEZXAua2V5LmlkID09PSBTdGF0aWNLZXlzLmluc3RhbmNlKCkudmlld0NvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3Q29udGFpbmVyUmVmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpckRlcC5rZXkuaWQgPT09IFN0YXRpY0tleXMuaW5zdGFuY2UoKS50ZW1wbGF0ZVJlZklkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fcHJlQnVpbHRPYmplY3RzLnRlbXBsYXRlUmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJEZXAub3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBkaV8xLk5vUHJvdmlkZXJFcnJvcihudWxsLCBkaXJEZXAua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVCdWlsdE9iamVjdHMudGVtcGxhdGVSZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBwaXBlX3Byb3ZpZGVyXzEuUGlwZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXAua2V5LmlkID09PSBTdGF0aWNLZXlzLmluc3RhbmNlKCkuY2hhbmdlRGV0ZWN0b3JSZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSB0aGlzLl9wcmVCdWlsdE9iamVjdHMudmlldy5nZXROZXN0ZWRWaWV3KHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy5lbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRWaWV3LmNoYW5nZURldGVjdG9yLnJlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5qZWN0b3JfMS5VTkRFRklORUQ7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5fYnVpbGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZGVwKSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLl9wcm90by5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF0dHJpYnV0ZXMpICYmIGF0dHJpYnV0ZXMuaGFzKGRlcC5hdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5nZXQoZGVwLmF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuYWRkRGlyZWN0aXZlc01hdGNoaW5nUXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIGxpc3QpIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGVSZWYgPSBsYW5nXzEuaXNCbGFuayh0aGlzLl9wcmVCdWlsdE9iamVjdHMpID8gbnVsbCA6IHRoaXMuX3ByZUJ1aWx0T2JqZWN0cy50ZW1wbGF0ZVJlZjtcclxuICAgICAgICBpZiAocXVlcnkuc2VsZWN0b3IgPT09IHRlbXBsYXRlX3JlZl8xLlRlbXBsYXRlUmVmICYmIGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGVSZWYpKSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaCh0ZW1wbGF0ZVJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5LmFkZERpcmVjdGl2ZXNNYXRjaGluZ1F1ZXJ5KHF1ZXJ5LCBsaXN0KTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLl9idWlsZFF1ZXJ5U3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvLnByb3RvUXVlcnlSZWZzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5UXVlcnlTdHJhdGVneTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcHJvdG8ucHJvdG9RdWVyeVJlZnMubGVuZ3RoIDw9XHJcbiAgICAgICAgICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kuTlVNQkVSX09GX1NVUFBPUlRFRF9RVUVSSUVTKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lUXVlcnlTdHJhdGVneSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRHluYW1pY1F1ZXJ5U3RyYXRlZ3kodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgcGFyZW50LmFkZENoaWxkKHRoaXMpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiAoKSB7IHRoaXMucmVtb3ZlKCk7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldERpcmVjdGl2ZUF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yLmdldEF0KGluZGV4KTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuaGFzSW5zdGFuY2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvdG8uaGFzQmluZGluZ3MgJiYgdGhpcy5oeWRyYXRlZDsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0SG9zdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3Q7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldEJvdW5kRWxlbWVudEluZGV4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvdG8uaW5kZXg7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldFJvb3RWaWV3SW5qZWN0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oeWRyYXRlZClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fcHJlQnVpbHRPYmplY3RzLnZpZXc7XHJcbiAgICAgICAgdmFyIG5lc3RlZFZpZXcgPSB2aWV3LmdldE5lc3RlZFZpZXcodmlldy5lbGVtZW50T2Zmc2V0ICsgdGhpcy5nZXRCb3VuZEVsZW1lbnRJbmRleCgpKTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChuZXN0ZWRWaWV3KSA/IG5lc3RlZFZpZXcucm9vdEVsZW1lbnRJbmplY3RvcnMgOiBbXTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmFmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3F1ZXJ5U3RyYXRlZ3kudXBkYXRlVmlld1F1ZXJpZXMoKTsgfTtcclxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuYWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcXVlcnlTdHJhdGVneS51cGRhdGVDb250ZW50UXVlcmllcygpOyB9O1xyXG4gICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS50cmF2ZXJzZUFuZFNldFF1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmogPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KGluaikpIHtcclxuICAgICAgICAgICAgaW5qLl9zZXRRdWVyaWVzQXNEaXJ0eSgpO1xyXG4gICAgICAgICAgICBpbmogPSBpbmoucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLl9zZXRRdWVyaWVzQXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9xdWVyeVN0cmF0ZWd5LnNldENvbnRlbnRRdWVyaWVzQXNEaXJ0eSgpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2hvc3QpKVxyXG4gICAgICAgICAgICB0aGlzLl9ob3N0Ll9xdWVyeVN0cmF0ZWd5LnNldFZpZXdRdWVyaWVzQXNEaXJ0eSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbGVtZW50SW5qZWN0b3I7XHJcbn0pKFRyZWVOb2RlKTtcclxuZXhwb3J0cy5FbGVtZW50SW5qZWN0b3IgPSBFbGVtZW50SW5qZWN0b3I7XHJcbnZhciBfRW1wdHlRdWVyeVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9FbXB0eVF1ZXJ5U3RyYXRlZ3koKSB7XHJcbiAgICB9XHJcbiAgICBfRW1wdHlRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5zZXRDb250ZW50UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBfRW1wdHlRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5zZXRWaWV3UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBfRW1wdHlRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5oeWRyYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgX0VtcHR5UXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlQ29udGVudFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBfRW1wdHlRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS51cGRhdGVWaWV3UXVlcmllcyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIF9FbXB0eVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmZpbmRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIHF1ZXJ5IGZvciBkaXJlY3RpdmUgXCIgKyBxdWVyeSArIFwiLlwiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX0VtcHR5UXVlcnlTdHJhdGVneTtcclxufSkoKTtcclxudmFyIF9lbXB0eVF1ZXJ5U3RyYXRlZ3kgPSBuZXcgX0VtcHR5UXVlcnlTdHJhdGVneSgpO1xyXG52YXIgSW5saW5lUXVlcnlTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmxpbmVRdWVyeVN0cmF0ZWd5KGVpKSB7XHJcbiAgICAgICAgdmFyIHByb3RvUmVmcyA9IGVpLl9wcm90by5wcm90b1F1ZXJ5UmVmcztcclxuICAgICAgICBpZiAocHJvdG9SZWZzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkwID0gbmV3IFF1ZXJ5UmVmKHByb3RvUmVmc1swXSwgZWkpO1xyXG4gICAgICAgIGlmIChwcm90b1JlZnMubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTEgPSBuZXcgUXVlcnlSZWYocHJvdG9SZWZzWzFdLCBlaSk7XHJcbiAgICAgICAgaWYgKHByb3RvUmVmcy5sZW5ndGggPiAyKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MiA9IG5ldyBRdWVyeVJlZihwcm90b1JlZnNbMl0sIGVpKTtcclxuICAgIH1cclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLnNldENvbnRlbnRRdWVyaWVzQXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MCkgJiYgIXRoaXMucXVlcnkwLmlzVmlld1F1ZXJ5KVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpICYmICF0aGlzLnF1ZXJ5MS5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTEuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSAmJiAhdGhpcy5xdWVyeTIuaXNWaWV3UXVlcnkpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkyLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBJbmxpbmVRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5zZXRWaWV3UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApICYmIHRoaXMucXVlcnkwLmlzVmlld1F1ZXJ5KVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpICYmIHRoaXMucXVlcnkxLmlzVmlld1F1ZXJ5KVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTIpICYmIHRoaXMucXVlcnkyLmlzVmlld1F1ZXJ5KVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Mi5kaXJ0eSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MCkpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkwLmh5ZHJhdGUoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MSkpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkxLmh5ZHJhdGUoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MikpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkyLmh5ZHJhdGUoKTtcclxuICAgIH07XHJcbiAgICBJbmxpbmVRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5kZWh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApKVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC5kZWh5ZHJhdGUoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MSkpXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkxLmRlaHlkcmF0ZSgpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSlcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTIuZGVoeWRyYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlQ29udGVudFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApICYmICF0aGlzLnF1ZXJ5MC5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MC51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpICYmICF0aGlzLnF1ZXJ5MS5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5MS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTIpICYmICF0aGlzLnF1ZXJ5Mi5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Mi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUudXBkYXRlVmlld1F1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApICYmIHRoaXMucXVlcnkwLmlzVmlld1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkwLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnF1ZXJ5MSkgJiYgdGhpcy5xdWVyeTEuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeTEudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMucXVlcnkyKSAmJiB0aGlzLnF1ZXJ5Mi5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Mi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5saW5lUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuZmluZFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTApICYmIHRoaXMucXVlcnkwLnByb3RvUXVlcnlSZWYucXVlcnkgPT09IHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTEpICYmIHRoaXMucXVlcnkxLnByb3RvUXVlcnlSZWYucXVlcnkgPT09IHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5xdWVyeTIpICYmIHRoaXMucXVlcnkyLnByb3RvUXVlcnlSZWYucXVlcnkgPT09IHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5MjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGZpbmQgcXVlcnkgZm9yIGRpcmVjdGl2ZSBcIiArIHF1ZXJ5ICsgXCIuXCIpO1xyXG4gICAgfTtcclxuICAgIElubGluZVF1ZXJ5U3RyYXRlZ3kuTlVNQkVSX09GX1NVUFBPUlRFRF9RVUVSSUVTID0gMztcclxuICAgIHJldHVybiBJbmxpbmVRdWVyeVN0cmF0ZWd5O1xyXG59KSgpO1xyXG52YXIgRHluYW1pY1F1ZXJ5U3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHluYW1pY1F1ZXJ5U3RyYXRlZ3koZWkpIHtcclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBlaS5fcHJvdG8ucHJvdG9RdWVyeVJlZnMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgUXVlcnlSZWYocCwgZWkpOyB9KTtcclxuICAgIH1cclxuICAgIER5bmFtaWNRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5zZXRDb250ZW50UXVlcmllc0FzRGlydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnF1ZXJpZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghcS5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgICAgIHEuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuc2V0Vmlld1F1ZXJpZXNBc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xdWVyaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAocS5pc1ZpZXdRdWVyeSlcclxuICAgICAgICAgICAgICAgIHEuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEeW5hbWljUXVlcnlTdHJhdGVneS5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucXVlcmllc1tpXTtcclxuICAgICAgICAgICAgcS5oeWRyYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIER5bmFtaWNRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS5kZWh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnF1ZXJpZXNbaV07XHJcbiAgICAgICAgICAgIHEuZGVoeWRyYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIER5bmFtaWNRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS51cGRhdGVDb250ZW50UXVlcmllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucXVlcmllc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFxLmlzVmlld1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBxLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIER5bmFtaWNRdWVyeVN0cmF0ZWd5LnByb3RvdHlwZS51cGRhdGVWaWV3UXVlcmllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucXVlcmllc1tpXTtcclxuICAgICAgICAgICAgaWYgKHEuaXNWaWV3UXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHEudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHluYW1pY1F1ZXJ5U3RyYXRlZ3kucHJvdG90eXBlLmZpbmRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xdWVyaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAocS5wcm90b1F1ZXJ5UmVmLnF1ZXJ5ID09PSBxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGZpbmQgcXVlcnkgZm9yIGRpcmVjdGl2ZSBcIiArIHF1ZXJ5ICsgXCIuXCIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEeW5hbWljUXVlcnlTdHJhdGVneTtcclxufSkoKTtcclxuLyoqXHJcbiAqIFN0cmF0ZWd5IHVzZWQgYnkgdGhlIGBFbGVtZW50SW5qZWN0b3JgIHdoZW4gdGhlIG51bWJlciBvZiBwcm92aWRlcnMgaXMgMTAgb3IgbGVzcy5cclxuICogSW4gc3VjaCBhIGNhc2UsIGlubGluaW5nIGZpZWxkcyBpcyBiZW5lZmljaWFsIGZvciBwZXJmb3JtYW5jZXMuXHJcbiAqL1xyXG52YXIgRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3JTdHJhdGVneSwgX2VpKSB7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvclN0cmF0ZWd5ID0gaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB0aGlzLl9laSA9IF9laTtcclxuICAgIH1cclxuICAgIEVsZW1lbnRJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5oeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBwID0gaS5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGkucmVzZXRDb25zdHJ1Y3Rpb25Db3VudGVyKCk7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXIwIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkMCkgJiYgaS5vYmowID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmowID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXIwLCBwLnZpc2liaWxpdHkwKTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjEgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQxKSAmJiBpLm9iajEgPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajEgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjEsIHAudmlzaWJpbGl0eTEpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMiBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDIpICYmIGkub2JqMiA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqMiA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMiwgcC52aXNpYmlsaXR5Mik7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXIzIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkMykgJiYgaS5vYmozID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmozID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXIzLCBwLnZpc2liaWxpdHkzKTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjQgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQ0KSAmJiBpLm9iajQgPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajQgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjQsIHAudmlzaWJpbGl0eTQpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyNSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDUpICYmIGkub2JqNSA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqNSA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNSwgcC52aXNpYmlsaXR5NSk7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI2IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkNikgJiYgaS5vYmo2ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmo2ID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXI2LCBwLnZpc2liaWxpdHk2KTtcclxuICAgICAgICBpZiAocC5wcm92aWRlcjcgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJiBsYW5nXzEuaXNQcmVzZW50KHAua2V5SWQ3KSAmJiBpLm9iajcgPT09IGluamVjdG9yXzEuVU5ERUZJTkVEKVxyXG4gICAgICAgICAgICBpLm9iajcgPSBpLmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcjcsIHAudmlzaWJpbGl0eTcpO1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyOCBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmIGxhbmdfMS5pc1ByZXNlbnQocC5rZXlJZDgpICYmIGkub2JqOCA9PT0gaW5qZWN0b3JfMS5VTkRFRklORUQpXHJcbiAgICAgICAgICAgIGkub2JqOCA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyOCwgcC52aXNpYmlsaXR5OCk7XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI5IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkOSkgJiYgaS5vYmo5ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgaS5vYmo5ID0gaS5pbnN0YW50aWF0ZVByb3ZpZGVyKHAucHJvdmlkZXI5LCBwLnZpc2liaWxpdHk5KTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIGkub2JqMCA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqMSA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqMiA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqMyA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqNCA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqNSA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqNiA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqNyA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqOCA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgICAgIGkub2JqOSA9IGluamVjdG9yXzEuVU5ERUZJTkVEO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jYWxsT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBwID0gaS5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMCBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXIwLmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmowLm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjEgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyMS5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqMS5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXIyIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjIuY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajIub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyMyBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXIzLmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmozLm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjQgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyNC5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqNC5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI1IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjUuY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajUub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyNiBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXI2LmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmo2Lm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocC5wcm92aWRlcjcgaW5zdGFuY2VvZiBEaXJlY3RpdmVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICBwLnByb3ZpZGVyNy5jYWxsT25EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGkub2JqNy5vbkRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAucHJvdmlkZXI4IGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgcC5wcm92aWRlcjguY2FsbE9uRGVzdHJveSkge1xyXG4gICAgICAgICAgICBpLm9iajgub25EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnByb3ZpZGVyOSBpbnN0YW5jZW9mIERpcmVjdGl2ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHAucHJvdmlkZXI5LmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgaS5vYmo5Lm9uRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmplY3RvclN0cmF0ZWd5Lm9iajA7IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuaXNDb21wb25lbnRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VpLl9wcm90by5fZmlyc3RQcm92aWRlcklzQ29tcG9uZW50ICYmIGxhbmdfMS5pc1ByZXNlbnQoa2V5KSAmJlxyXG4gICAgICAgICAgICBrZXkuaWQgPT09IHRoaXMuaW5qZWN0b3JTdHJhdGVneS5wcm90b1N0cmF0ZWd5LmtleUlkMDtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuYWRkRGlyZWN0aXZlc01hdGNoaW5nUXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIGxpc3QpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGkucHJvdG9TdHJhdGVneTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyMCkgJiYgcC5wcm92aWRlcjAua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmowID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqMCA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMCwgcC52aXNpYmlsaXR5MCk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyMSkgJiYgcC5wcm92aWRlcjEua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmoxID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqMSA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMSwgcC52aXNpYmlsaXR5MSk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyMikgJiYgcC5wcm92aWRlcjIua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmoyID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqMiA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMiwgcC52aXNpYmlsaXR5Mik7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyMykgJiYgcC5wcm92aWRlcjMua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmozID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqMyA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyMywgcC52aXNpYmlsaXR5Myk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyNCkgJiYgcC5wcm92aWRlcjQua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo0ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqNCA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNCwgcC52aXNpYmlsaXR5NCk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyNSkgJiYgcC5wcm92aWRlcjUua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo1ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqNSA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNSwgcC52aXNpYmlsaXR5NSk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyNikgJiYgcC5wcm92aWRlcjYua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo2ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqNiA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNiwgcC52aXNpYmlsaXR5Nik7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyNykgJiYgcC5wcm92aWRlcjcua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo3ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqNyA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyNywgcC52aXNpYmlsaXR5Nyk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyOCkgJiYgcC5wcm92aWRlcjgua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo4ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqOCA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyOCwgcC52aXNpYmlsaXR5OCk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwLnByb3ZpZGVyOSkgJiYgcC5wcm92aWRlcjkua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoaS5vYmo5ID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRClcclxuICAgICAgICAgICAgICAgIGkub2JqOSA9IGkuaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyOSwgcC52aXNpYmlsaXR5OSk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChpLm9iajkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRWxlbWVudEluamVjdG9ySW5saW5lU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBTdHJhdGVneSB1c2VkIGJ5IHRoZSBgRWxlbWVudEluamVjdG9yYCB3aGVuIHRoZSBudW1iZXIgb2YgcHJvdmlkZXJzIGlzIDEwIG9yIGxlc3MuXHJcbiAqIEluIHN1Y2ggYSBjYXNlLCBpbmxpbmluZyBmaWVsZHMgaXMgYmVuZWZpY2lhbCBmb3IgcGVyZm9ybWFuY2VzLlxyXG4gKi9cclxudmFyIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3koaW5qZWN0b3JTdHJhdGVneSwgX2VpKSB7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvclN0cmF0ZWd5ID0gaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB0aGlzLl9laSA9IF9laTtcclxuICAgIH1cclxuICAgIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5qID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBwID0gaW5qLnByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgaW5qLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlcigpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5rZXlJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHAucHJvdmlkZXJzW2ldIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiYgbGFuZ18xLmlzUHJlc2VudChwLmtleUlkc1tpXSkgJiZcclxuICAgICAgICAgICAgICAgIGluai5vYmpzW2ldID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgaW5qLm9ianNbaV0gPSBpbmouaW5zdGFudGlhdGVQcm92aWRlcihwLnByb3ZpZGVyc1tpXSwgcC52aXNpYmlsaXRpZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmogPSB0aGlzLmluamVjdG9yU3RyYXRlZ3k7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbGwoaW5qLm9ianMsIGluamVjdG9yXzEuVU5ERUZJTkVEKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmNhbGxPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzdCA9IHRoaXMuaW5qZWN0b3JTdHJhdGVneTtcclxuICAgICAgICB2YXIgcCA9IGlzdC5wcm90b1N0cmF0ZWd5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHAucHJvdmlkZXJzW2ldIGluc3RhbmNlb2YgRGlyZWN0aXZlUHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgICAgIHAucHJvdmlkZXJzW2ldLmNhbGxPbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgIGlzdC5vYmpzW2ldLm9uRGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmplY3RvclN0cmF0ZWd5Lm9ianNbMF07IH07XHJcbiAgICBFbGVtZW50SW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmlzQ29tcG9uZW50S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5LnByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VpLl9wcm90by5fZmlyc3RQcm92aWRlcklzQ29tcG9uZW50ICYmIGxhbmdfMS5pc1ByZXNlbnQoa2V5KSAmJiBrZXkuaWQgPT09IHAua2V5SWRzWzBdO1xyXG4gICAgfTtcclxuICAgIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuYWRkRGlyZWN0aXZlc01hdGNoaW5nUXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIGxpc3QpIHtcclxuICAgICAgICB2YXIgaXN0ID0gdGhpcy5pbmplY3RvclN0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBwID0gaXN0LnByb3RvU3RyYXRlZ3k7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLnByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocC5wcm92aWRlcnNbaV0ua2V5LnRva2VuID09PSBxdWVyeS5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzdC5vYmpzW2ldID09PSBpbmplY3Rvcl8xLlVOREVGSU5FRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzdC5vYmpzW2ldID0gaXN0Lmluc3RhbnRpYXRlUHJvdmlkZXIocC5wcm92aWRlcnNbaV0sIHAudmlzaWJpbGl0aWVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChpc3Qub2Jqc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVsZW1lbnRJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcclxufSkoKTtcclxudmFyIFByb3RvUXVlcnlSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9RdWVyeVJlZihkaXJJbmRleCwgc2V0dGVyLCBxdWVyeSkge1xyXG4gICAgICAgIHRoaXMuZGlySW5kZXggPSBkaXJJbmRleDtcclxuICAgICAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdG9RdWVyeVJlZi5wcm90b3R5cGUsIFwidXNlc1Byb3BlcnR5U3ludGF4XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5zZXR0ZXIpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm90b1F1ZXJ5UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvUXVlcnlSZWYgPSBQcm90b1F1ZXJ5UmVmO1xyXG52YXIgUXVlcnlSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVlcnlSZWYocHJvdG9RdWVyeVJlZiwgb3JpZ2luYXRvcikge1xyXG4gICAgICAgIHRoaXMucHJvdG9RdWVyeVJlZiA9IHByb3RvUXVlcnlSZWY7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hdG9yID0gb3JpZ2luYXRvcjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeVJlZi5wcm90b3R5cGUsIFwiaXNWaWV3UXVlcnlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcm90b1F1ZXJ5UmVmLnF1ZXJ5LmlzVmlld1F1ZXJ5OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFRPRE8gZGVsZXRlIHRoZSBjaGVjayBvbmNlIG9ubHkgZmllbGQgcXVlcmllcyBhcmUgc3VwcG9ydGVkXHJcbiAgICAgICAgaWYgKHRoaXMucHJvdG9RdWVyeVJlZi51c2VzUHJvcGVydHlTeW50YXgpIHtcclxuICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMub3JpZ2luYXRvci5nZXREaXJlY3RpdmVBdEluZGV4KHRoaXMucHJvdG9RdWVyeVJlZi5kaXJJbmRleCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3RvUXVlcnlSZWYucXVlcnkuZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9RdWVyeVJlZi5zZXR0ZXIoZGlyLCB0aGlzLmxpc3QubGVuZ3RoID4gMCA/IHRoaXMubGlzdC5maXJzdCA6IG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b1F1ZXJ5UmVmLnNldHRlcihkaXIsIHRoaXMubGlzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0Lm5vdGlmeU9uQ2hhbmdlcygpO1xyXG4gICAgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZ2dyZWdhdG9yID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMucHJvdG9RdWVyeVJlZi5xdWVyeS5pc1ZpZXdRdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMub3JpZ2luYXRvci5nZXRWaWV3KCk7XHJcbiAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgc2tpcHBpbmcgb3JpZ2luYXRvciBmb3IgdmlldyBxdWVyaWVzLlxyXG4gICAgICAgICAgICB2YXIgbmVzdGVkVmlldyA9IHZpZXcuZ2V0TmVzdGVkVmlldyh2aWV3LmVsZW1lbnRPZmZzZXQgKyB0aGlzLm9yaWdpbmF0b3IuZ2V0Qm91bmRFbGVtZW50SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5lc3RlZFZpZXcpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRWaWV3KG5lc3RlZFZpZXcsIGFnZ3JlZ2F0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXQodGhpcy5vcmlnaW5hdG9yLCBhZ2dyZWdhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0LnJlc2V0KGFnZ3JlZ2F0b3IpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fdmlzaXQgPSBmdW5jdGlvbiAoaW5qLCBhZ2dyZWdhdG9yKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSBpbmouZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBzdGFydElkeCA9IHZpZXcuZWxlbWVudE9mZnNldCArIGluai5fcHJvdG8uaW5kZXg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SWR4OyBpIDwgdmlldy5lbGVtZW50T2Zmc2V0ICsgdmlldy5vd25CaW5kZXJzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY3VySW5qID0gdmlldy5lbGVtZW50SW5qZWN0b3JzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY3VySW5qKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgaW5qZWN0b3IgYWZ0ZXIgaW5qLCB0aGF0IGlzIG91dHNpZGUgdGhlIHN1YnRyZWUgcm9vdGVkIGF0XHJcbiAgICAgICAgICAgIC8vIGluaiBoYXMgdG8gaGF2ZSBhIG51bGwgcGFyZW50IG9yIGEgcGFyZW50IHRoYXQgaXMgYW4gYW5jZXN0b3Igb2YgaW5qLlxyXG4gICAgICAgICAgICBpZiAoaSA+IHN0YXJ0SWR4ICYmIChsYW5nXzEuaXNCbGFuayhjdXJJbmopIHx8IGxhbmdfMS5pc0JsYW5rKGN1ckluai5wYXJlbnQpIHx8XHJcbiAgICAgICAgICAgICAgICB2aWV3LmVsZW1lbnRPZmZzZXQgKyBjdXJJbmoucGFyZW50Ll9wcm90by5pbmRleCA8IHN0YXJ0SWR4KSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3RvUXVlcnlSZWYucXVlcnkuZGVzY2VuZGFudHMgJiZcclxuICAgICAgICAgICAgICAgICEoY3VySW5qLnBhcmVudCA9PSB0aGlzLm9yaWdpbmF0b3IgfHwgY3VySW5qID09IHRoaXMub3JpZ2luYXRvcikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgLy8gV2UgdmlzaXQgdGhlIHZpZXcgY29udGFpbmVyKFZDKSB2aWV3cyByaWdodCBhZnRlciB0aGUgaW5qZWN0b3IgdGhhdCBjb250YWluc1xyXG4gICAgICAgICAgICAvLyB0aGUgVkMuIFRoZW9yZXRpY2FsbHksIHRoYXQgbWlnaHQgbm90IGJlIHRoZSByaWdodCBvcmRlciBpZiB0aGVyZSBhcmVcclxuICAgICAgICAgICAgLy8gY2hpbGQgaW5qZWN0b3JzIG9mIHNhaWQgaW5qZWN0b3IuIE5vdCBjbGVhciB3aGV0aGVyIGlmIHN1Y2ggY2FzZSBjYW5cclxuICAgICAgICAgICAgLy8gZXZlbiBiZSBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBjdXJyZW50IGFwaXMuXHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0SW5qZWN0b3IoY3VySW5qLCBhZ2dyZWdhdG9yKTtcclxuICAgICAgICAgICAgdmFyIHZjID0gdmlldy52aWV3Q29udGFpbmVyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmMpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRWaWV3Q29udGFpbmVyKHZjLCBhZ2dyZWdhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUXVlcnlSZWYucHJvdG90eXBlLl92aXNpdEluamVjdG9yID0gZnVuY3Rpb24gKGluaiwgYWdncmVnYXRvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3RvUXVlcnlSZWYucXVlcnkuaXNWYXJCaW5kaW5nUXVlcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWdncmVnYXRlVmFyaWFibGVCaW5kaW5nKGluaiwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hZ2dyZWdhdGVEaXJlY3RpdmUoaW5qLCBhZ2dyZWdhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUXVlcnlSZWYucHJvdG90eXBlLl92aXNpdFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAodmMsIGFnZ3JlZ2F0b3IpIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZjLnZpZXdzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Vmlldyh2Yy52aWV3c1tqXSwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fdmlzaXRWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIGFnZ3JlZ2F0b3IpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gdmlldy5lbGVtZW50T2Zmc2V0OyBpIDwgdmlldy5lbGVtZW50T2Zmc2V0ICsgdmlldy5vd25CaW5kZXJzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW5qID0gdmlldy5lbGVtZW50SW5qZWN0b3JzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5qKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdEluamVjdG9yKGluaiwgYWdncmVnYXRvcik7XHJcbiAgICAgICAgICAgIHZhciB2YyA9IHZpZXcudmlld0NvbnRhaW5lcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZjKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0Vmlld0NvbnRhaW5lcih2YywgYWdncmVnYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFF1ZXJ5UmVmLnByb3RvdHlwZS5fYWdncmVnYXRlVmFyaWFibGVCaW5kaW5nID0gZnVuY3Rpb24gKGluaiwgYWdncmVnYXRvcikge1xyXG4gICAgICAgIHZhciB2YiA9IHRoaXMucHJvdG9RdWVyeVJlZi5xdWVyeS52YXJCaW5kaW5ncztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZiLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmouaGFzVmFyaWFibGVCaW5kaW5nKHZiW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgYWdncmVnYXRvci5wdXNoKGluai5nZXRWYXJpYWJsZUJpbmRpbmcodmJbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuX2FnZ3JlZ2F0ZURpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpbmosIGFnZ3JlZ2F0b3IpIHtcclxuICAgICAgICBpbmouYWRkRGlyZWN0aXZlc01hdGNoaW5nUXVlcnkodGhpcy5wcm90b1F1ZXJ5UmVmLnF1ZXJ5LCBhZ2dyZWdhdG9yKTtcclxuICAgIH07XHJcbiAgICBRdWVyeVJlZi5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmxpc3QgPSBudWxsOyB9O1xyXG4gICAgUXVlcnlSZWYucHJvdG90eXBlLmh5ZHJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IHF1ZXJ5X2xpc3RfMS5RdWVyeUxpc3QoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUXVlcnlSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUXVlcnlSZWYgPSBRdWVyeVJlZjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF9pbmplY3Rvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSBWaWV3IHRoYXQgaGFzIGFuIGluamVjdGlvbiwgY2hhbmdlLWRldGVjdGlvbiBhbmQgcmVuZGVyIGNvbnRleHRcclxuICogYXNzb2NpYXRlZCB3aXRoIGl0LlxyXG4gKlxyXG4gKiBBbiBgRWxlbWVudFJlZmAgaXMgY3JlYXRlZCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBUZW1wbGF0ZSB0aGF0IGNvbnRhaW5zIGEgRGlyZWN0aXZlLCBDb21wb25lbnRcclxuICogb3IgZGF0YS1iaW5kaW5nLlxyXG4gKlxyXG4gKiBBbiBgRWxlbWVudFJlZmAgaXMgYmFja2VkIGJ5IGEgcmVuZGVyLXNwZWNpZmljIGVsZW1lbnQuIEluIHRoZSBicm93c2VyLCB0aGlzIGlzIHVzdWFsbHkgYSBET01cclxuICogZWxlbWVudC5cclxuICovXHJcbnZhciBFbGVtZW50UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudFJlZi5wcm90b3R5cGUsIFwibmF0aXZlRWxlbWVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgbmF0aXZlIGVsZW1lbnQgb3IgYG51bGxgIGlmIGRpcmVjdCBhY2Nlc3MgdG8gbmF0aXZlIGVsZW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgKiAoZS5nLiB3aGVuIHRoZSBhcHBsaWNhdGlvbiBydW5zIGluIGEgd2ViIHdvcmtlcikuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiA8ZGl2IGNsYXNzPVwiY2FsbG91dCBpcy1jcml0aWNhbFwiPlxyXG4gICAgICAgICAqICAgPGhlYWRlcj5Vc2Ugd2l0aCBjYXV0aW9uPC9oZWFkZXI+XHJcbiAgICAgICAgICogICA8cD5cclxuICAgICAgICAgKiAgICBVc2UgdGhpcyBBUEkgYXMgdGhlIGxhc3QgcmVzb3J0IHdoZW4gZGlyZWN0IGFjY2VzcyB0byBET00gaXMgbmVlZGVkLiBVc2UgdGVtcGxhdGluZyBhbmRcclxuICAgICAgICAgKiAgICBkYXRhLWJpbmRpbmcgcHJvdmlkZWQgYnkgQW5ndWxhciBpbnN0ZWFkLiBBbHRlcm5hdGl2ZWx5IHlvdSB0YWtlIGEgbG9vayBhdCB7QGxpbmsgUmVuZGVyZXJ9XHJcbiAgICAgICAgICogICAgd2hpY2ggcHJvdmlkZXMgQVBJIHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGV2ZW4gd2hlbiBkaXJlY3QgYWNjZXNzIHRvIG5hdGl2ZSBlbGVtZW50cyBpcyBub3RcclxuICAgICAgICAgKiAgICBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICogICA8L3A+XHJcbiAgICAgICAgICogICA8cD5cclxuICAgICAgICAgKiAgICBSZWx5aW5nIG9uIGRpcmVjdCBET00gYWNjZXNzIGNyZWF0ZXMgdGlnaHQgY291cGxpbmcgYmV0d2VlbiB5b3VyIGFwcGxpY2F0aW9uIGFuZCByZW5kZXJpbmdcclxuICAgICAgICAgKiAgICBsYXllcnMgd2hpY2ggd2lsbCBtYWtlIGl0IGltcG9zc2libGUgdG8gc2VwYXJhdGUgdGhlIHR3byBhbmQgZGVwbG95IHlvdXIgYXBwbGljYXRpb24gaW50byBhXHJcbiAgICAgICAgICogICAgd2ViIHdvcmtlci5cclxuICAgICAgICAgKiAgIDwvcD5cclxuICAgICAgICAgKiA8L2Rpdj5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnRSZWYucHJvdG90eXBlLCBcInJlbmRlclZpZXdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRWxlbWVudFJlZjtcclxufSkoKTtcclxuZXhwb3J0cy5FbGVtZW50UmVmID0gRWxlbWVudFJlZjtcclxudmFyIEVsZW1lbnRSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbGVtZW50UmVmXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWZfKHBhcmVudFZpZXcsIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGV4IG9mIHRoZSBlbGVtZW50IGluc2lkZSB0aGUge0BsaW5rIFZpZXdSZWZ9LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIEFuZ3VsYXIgZnJhbWV3b3JrIHRvIGxvY2F0ZSBlbGVtZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBib3VuZEVsZW1lbnRJbmRleCwgX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudEluZGV4ID0gYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudFJlZl8ucHJvdG90eXBlLCBcInJlbmRlclZpZXdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRWaWV3LnJlbmRlcjsgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50UmVmXy5wcm90b3R5cGUsIFwibmF0aXZlRWxlbWVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJlci5nZXROYXRpdmVFbGVtZW50U3luYyh0aGlzKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRWxlbWVudFJlZl87XHJcbn0pKEVsZW1lbnRSZWYpO1xyXG5leHBvcnRzLkVsZW1lbnRSZWZfID0gRWxlbWVudFJlZl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZXhwb3J0cy5FVkVOVF9UQVJHRVRfU0VQQVJBVE9SID0gJzonO1xyXG52YXIgRXZlbnRDb25maWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRDb25maWcoZmllbGROYW1lLCBldmVudE5hbWUsIGlzTG9uZ0Zvcm0pIHtcclxuICAgICAgICB0aGlzLmZpZWxkTmFtZSA9IGZpZWxkTmFtZTtcclxuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcclxuICAgICAgICB0aGlzLmlzTG9uZ0Zvcm0gPSBpc0xvbmdGb3JtO1xyXG4gICAgfVxyXG4gICAgRXZlbnRDb25maWcucGFyc2UgPSBmdW5jdGlvbiAoZXZlbnRDb25maWcpIHtcclxuICAgICAgICB2YXIgZmllbGROYW1lID0gZXZlbnRDb25maWcsIGV2ZW50TmFtZSA9IGV2ZW50Q29uZmlnLCBpc0xvbmdGb3JtID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRvcklkeCA9IGV2ZW50Q29uZmlnLmluZGV4T2YoZXhwb3J0cy5FVkVOVF9UQVJHRVRfU0VQQVJBVE9SKTtcclxuICAgICAgICBpZiAoc2VwYXJhdG9ySWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgLy8gbG9uZyBmb3JtYXQ6ICdmaWVsZE5hbWU6IGV2ZW50TmFtZSdcclxuICAgICAgICAgICAgZmllbGROYW1lID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3Vic3RyaW5nKGV2ZW50Q29uZmlnLCAwLCBzZXBhcmF0b3JJZHgpLnRyaW0oKTtcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3Vic3RyaW5nKGV2ZW50Q29uZmlnLCBzZXBhcmF0b3JJZHggKyAxKS50cmltKCk7XHJcbiAgICAgICAgICAgIGlzTG9uZ0Zvcm0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50Q29uZmlnKGZpZWxkTmFtZSwgZXZlbnROYW1lLCBpc0xvbmdGb3JtKTtcclxuICAgIH07XHJcbiAgICBFdmVudENvbmZpZy5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb25nRm9ybSA/IFwiXCIgKyB0aGlzLmZpZWxkTmFtZSArIGV4cG9ydHMuRVZFTlRfVEFSR0VUX1NFUEFSQVRPUiArIHRoaXMuZXZlbnROYW1lIDpcclxuICAgICAgICAgICAgdGhpcy5ldmVudE5hbWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50Q29uZmlnO1xyXG59KSgpO1xyXG5leHBvcnRzLkV2ZW50Q29uZmlnID0gRXZlbnRDb25maWc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50X2NvbmZpZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7KGZ1bmN0aW9uIChMaWZlY3ljbGVIb29rcykge1xyXG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkluaXRcIl0gPSAwXSA9IFwiT25Jbml0XCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uRGVzdHJveVwiXSA9IDFdID0gXCJPbkRlc3Ryb3lcIjtcclxuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiRG9DaGVja1wiXSA9IDJdID0gXCJEb0NoZWNrXCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uQ2hhbmdlc1wiXSA9IDNdID0gXCJPbkNoYW5nZXNcIjtcclxuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50SW5pdFwiXSA9IDRdID0gXCJBZnRlckNvbnRlbnRJbml0XCI7XHJcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudENoZWNrZWRcIl0gPSA1XSA9IFwiQWZ0ZXJDb250ZW50Q2hlY2tlZFwiO1xyXG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlclZpZXdJbml0XCJdID0gNl0gPSBcIkFmdGVyVmlld0luaXRcIjtcclxuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3Q2hlY2tlZFwiXSA9IDddID0gXCJBZnRlclZpZXdDaGVja2VkXCI7XHJcbn0pKGV4cG9ydHMuTGlmZWN5Y2xlSG9va3MgfHwgKGV4cG9ydHMuTGlmZWN5Y2xlSG9va3MgPSB7fSkpO1xyXG52YXIgTGlmZWN5Y2xlSG9va3MgPSBleHBvcnRzLkxpZmVjeWNsZUhvb2tzO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnRzLkxJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXHJcbiAgICBMaWZlY3ljbGVIb29rcy5PbkluaXQsXHJcbiAgICBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksXHJcbiAgICBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrLFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzLFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdCxcclxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQsXHJcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0LFxyXG4gICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZFxyXG5dO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2VzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbi8qKlxyXG4gKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgUGlwZU1ldGFkYXRhfS5cclxuICpcclxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIENvbXBpbGVyfVxyXG4gKi9cclxudmFyIFBpcGVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaXBlUmVzb2x2ZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB7QGxpbmsgUGlwZU1ldGFkYXRhfSBmb3IgYSBnaXZlbiBgVHlwZWAuXHJcbiAgICAgKi9cclxuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIG1ldGFzID0gcmVmbGVjdGlvbl8xLnJlZmxlY3Rvci5hbm5vdGF0aW9ucyhkaV8xLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtZXRhcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBtZXRhc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5QaXBlTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIGxhbmdfMS5zdHJpbmdpZnkodHlwZSkpO1xyXG4gICAgfTtcclxuICAgIFBpcGVSZXNvbHZlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgUGlwZVJlc29sdmVyKTtcclxuICAgIHJldHVybiBQaXBlUmVzb2x2ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGlwZVJlc29sdmVyID0gUGlwZVJlc29sdmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlX3Jlc29sdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgcGlwZV9wcm92aWRlcl8xID0gcmVxdWlyZSgnLi4vcGlwZXMvcGlwZV9wcm92aWRlcicpO1xyXG52YXIgcGlwZXNfMSA9IHJlcXVpcmUoJy4uL3BpcGVzL3BpcGVzJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCcuL3ZpZXcnKTtcclxudmFyIGVsZW1lbnRfYmluZGVyXzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfYmluZGVyJyk7XHJcbnZhciBlbGVtZW50X2luamVjdG9yXzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfaW5qZWN0b3InKTtcclxudmFyIGRpcmVjdGl2ZV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVfcmVzb2x2ZXInKTtcclxudmFyIHZpZXdfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vdmlld19yZXNvbHZlcicpO1xyXG52YXIgcGlwZV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9waXBlX3Jlc29sdmVyJyk7XHJcbnZhciBwaXBlc18yID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcGlwZXMnKTtcclxudmFyIHRlbXBsYXRlX2NvbW1hbmRzXzEgPSByZXF1aXJlKCcuL3RlbXBsYXRlX2NvbW1hbmRzJyk7XHJcbnZhciByZW5kZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3JlbmRlcicpO1xyXG52YXIgYXBwbGljYXRpb25fdG9rZW5zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9hcHBsaWNhdGlvbl90b2tlbnMnKTtcclxudmFyIFByb3RvVmlld0ZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvdG9WaWV3RmFjdG9yeShfcmVuZGVyZXIsIGRlZmF1bHRQaXBlcywgX2RpcmVjdGl2ZVJlc29sdmVyLCBfdmlld1Jlc29sdmVyLCBfcGlwZVJlc29sdmVyLCBhcHBJZCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyID0gX2RpcmVjdGl2ZVJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdSZXNvbHZlciA9IF92aWV3UmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyID0gX3BpcGVSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0UGlwZXMgPSBkZWZhdWx0UGlwZXM7XHJcbiAgICAgICAgdGhpcy5fYXBwSWQgPSBhcHBJZDtcclxuICAgIH1cclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NhY2hlLmNsZWFyKCk7IH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVIb3N0ID0gZnVuY3Rpb24gKGNvbXBpbGVkSG9zdFRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBjb21waWxlZEhvc3RUZW1wbGF0ZS5nZXRUZW1wbGF0ZSgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jYWNoZS5nZXQoY29tcGlsZWRUZW1wbGF0ZS5pZCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGF0YSA9IGNvbXBpbGVkVGVtcGxhdGUuZ2V0RGF0YSh0aGlzLl9hcHBJZCk7XHJcbiAgICAgICAgICAgIHZhciBlbXB0eU1hcCA9IHt9O1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgdmlld18xLkFwcFByb3RvVmlldyh0ZW1wbGF0ZURhdGEuY29tbWFuZHMsIHZpZXdfMS5WaWV3VHlwZS5IT1NULCB0cnVlLCB0ZW1wbGF0ZURhdGEuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBudWxsLCBuZXcgcGlwZXNfMS5Qcm90b1BpcGVzKGVtcHR5TWFwKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLnNldChjb21waWxlZFRlbXBsYXRlLmlkLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLl9jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY21kKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbmVzdGVkUHJvdG9WaWV3ID0gdGhpcy5fY2FjaGUuZ2V0KGNtZC50ZW1wbGF0ZUlkKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobmVzdGVkUHJvdG9WaWV3KSkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY21kLmRpcmVjdGl2ZXNbMF07XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlld1Jlc29sdmVyLnJlc29sdmUoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGVEYXRhID0gY21kLnRlbXBsYXRlLmdldERhdGEodGhpcy5fYXBwSWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZWdpc3RlckNvbXBvbmVudFRlbXBsYXRlKGNtZC50ZW1wbGF0ZUlkLCBjb21waWxlZFRlbXBsYXRlRGF0YS5jb21tYW5kcywgY29tcGlsZWRUZW1wbGF0ZURhdGEuc3R5bGVzLCBjbWQubmF0aXZlU2hhZG93KTtcclxuICAgICAgICAgICAgdmFyIGJvdW5kUGlwZXMgPSB0aGlzLl9mbGF0dGVuUGlwZXModmlldykubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fYmluZFBpcGUocGlwZSk7IH0pO1xyXG4gICAgICAgICAgICBuZXN0ZWRQcm90b1ZpZXcgPSBuZXcgdmlld18xLkFwcFByb3RvVmlldyhjb21waWxlZFRlbXBsYXRlRGF0YS5jb21tYW5kcywgdmlld18xLlZpZXdUeXBlLkNPTVBPTkVOVCwgdHJ1ZSwgY29tcGlsZWRUZW1wbGF0ZURhdGEuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBudWxsLCBwaXBlc18xLlByb3RvUGlwZXMuZnJvbVByb3ZpZGVycyhib3VuZFBpcGVzKSk7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBjYWNoZSBpcyB1cGRhdGVkIGJlZm9yZSByZWN1cnNpbmdcclxuICAgICAgICAgICAgLy8gdG8gYmUgYWJsZSB0byByZXNvbHZlIGN5Y2xlc1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoY21kLnRlbXBsYXRlLmlkLCBuZXN0ZWRQcm90b1ZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvdG9WaWV3KG5lc3RlZFByb3RvVmlldywgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXN0ZWRQcm90b1ZpZXc7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3RmFjdG9yeS5wcm90b3R5cGUuX2NyZWF0ZUVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoY21kLCBwYXJlbnQpIHtcclxuICAgICAgICB2YXIgbmVzdGVkUHJvdG9WaWV3ID0gbmV3IHZpZXdfMS5BcHBQcm90b1ZpZXcoY21kLmNoaWxkcmVuLCB2aWV3XzEuVmlld1R5cGUuRU1CRURERUQsIGNtZC5pc01lcmdlZCwgY21kLmNoYW5nZURldGVjdG9yRmFjdG9yeSwgYXJyYXlUb01hcChjbWQudmFyaWFibGVOYW1lQW5kVmFsdWVzLCB0cnVlKSwgbmV3IHBpcGVzXzEuUHJvdG9QaXBlcyhwYXJlbnQucGlwZXMuY29uZmlnKSk7XHJcbiAgICAgICAgaWYgKGNtZC5pc01lcmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVQcm90b1ZpZXdJZk5lZWRlZChuZXN0ZWRQcm90b1ZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmVzdGVkUHJvdG9WaWV3O1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLmluaXRpYWxpemVQcm90b1ZpZXdJZk5lZWRlZCA9IGZ1bmN0aW9uIChwcm90b1ZpZXcpIHtcclxuICAgICAgICBpZiAoIXByb3RvVmlldy5pc0luaXRpYWxpemVkKCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlciA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZVByb3RvVmlldyhwcm90b1ZpZXcudGVtcGxhdGVDbWRzKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvVmlldyhwcm90b1ZpZXcsIHJlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkucHJvdG90eXBlLl9pbml0aWFsaXplUHJvdG9WaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlldywgcmVuZGVyKSB7XHJcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gbmV3IF9Qcm90b1ZpZXdJbml0aWFsaXplcihwcm90b1ZpZXcsIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLCB0aGlzKTtcclxuICAgICAgICB0ZW1wbGF0ZV9jb21tYW5kc18xLnZpc2l0QWxsQ29tbWFuZHMoaW5pdGlhbGl6ZXIsIHByb3RvVmlldy50ZW1wbGF0ZUNtZHMpO1xyXG4gICAgICAgIHZhciBtZXJnZUluZm8gPSBuZXcgdmlld18xLkFwcFByb3RvVmlld01lcmdlSW5mbyhpbml0aWFsaXplci5tZXJnZUVtYmVkZGVkVmlld0NvdW50LCBpbml0aWFsaXplci5tZXJnZUVsZW1lbnRDb3VudCwgaW5pdGlhbGl6ZXIubWVyZ2VWaWV3Q291bnQpO1xyXG4gICAgICAgIHByb3RvVmlldy5pbml0KHJlbmRlciwgaW5pdGlhbGl6ZXIuZWxlbWVudEJpbmRlcnMsIGluaXRpYWxpemVyLmJvdW5kVGV4dENvdW50LCBtZXJnZUluZm8sIGluaXRpYWxpemVyLnZhcmlhYmxlTG9jYXRpb25zKTtcclxuICAgIH07XHJcbiAgICBQcm90b1ZpZXdGYWN0b3J5LnByb3RvdHlwZS5fYmluZFBpcGUgPSBmdW5jdGlvbiAodHlwZU9yUHJvdmlkZXIpIHtcclxuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuX3BpcGVSZXNvbHZlci5yZXNvbHZlKHR5cGVPclByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcGlwZV9wcm92aWRlcl8xLlBpcGVQcm92aWRlci5jcmVhdGVGcm9tVHlwZSh0eXBlT3JQcm92aWRlciwgbWV0YSk7XHJcbiAgICB9O1xyXG4gICAgUHJvdG9WaWV3RmFjdG9yeS5wcm90b3R5cGUuX2ZsYXR0ZW5QaXBlcyA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZpZXcucGlwZXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFBpcGVzO1xyXG4gICAgICAgIHZhciBwaXBlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbG9uZSh0aGlzLl9kZWZhdWx0UGlwZXMpO1xyXG4gICAgICAgIF9mbGF0dGVuTGlzdCh2aWV3LnBpcGVzLCBwaXBlcyk7XHJcbiAgICAgICAgcmV0dXJuIHBpcGVzO1xyXG4gICAgfTtcclxuICAgIFByb3RvVmlld0ZhY3RvcnkgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGRpXzEuSW5qZWN0KHBpcGVzXzIuREVGQVVMVF9QSVBFU19UT0tFTikpLFxyXG4gICAgICAgIF9fcGFyYW0oNSwgZGlfMS5JbmplY3QoYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lEKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JlbmRlcl8xLlJlbmRlcmVyLCBBcnJheSwgZGlyZWN0aXZlX3Jlc29sdmVyXzEuRGlyZWN0aXZlUmVzb2x2ZXIsIHZpZXdfcmVzb2x2ZXJfMS5WaWV3UmVzb2x2ZXIsIHBpcGVfcmVzb2x2ZXJfMS5QaXBlUmVzb2x2ZXIsIFN0cmluZ10pXHJcbiAgICBdLCBQcm90b1ZpZXdGYWN0b3J5KTtcclxuICAgIHJldHVybiBQcm90b1ZpZXdGYWN0b3J5O1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvVmlld0ZhY3RvcnkgPSBQcm90b1ZpZXdGYWN0b3J5O1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocHJvdG9WaWV3RmFjdG9yeSwgY21kKSB7XHJcbiAgICByZXR1cm4gcHJvdG9WaWV3RmFjdG9yeS5fY3JlYXRlQ29tcG9uZW50KGNtZCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkZWRUZW1wbGF0ZShwcm90b1ZpZXdGYWN0b3J5LCBjbWQsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIHByb3RvVmlld0ZhY3RvcnkuX2NyZWF0ZUVtYmVkZGVkVGVtcGxhdGUoY21kLCBwYXJlbnQpO1xyXG59XHJcbnZhciBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX1Byb3RvVmlld0luaXRpYWxpemVyKF9wcm90b1ZpZXcsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3Byb3RvVmlld0ZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXcgPSBfcHJvdG9WaWV3O1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyID0gX2RpcmVjdGl2ZVJlc29sdmVyO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkgPSBfcHJvdG9WaWV3RmFjdG9yeTtcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTG9jYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuYm91bmRUZXh0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYm91bmRFbGVtZW50SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEJpbmRlclN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50RWxlbWVudEJpbmRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IgPSAwO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEJpbmRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLm1lcmdlRW1iZWRkZWRWaWV3Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubWVyZ2VFbGVtZW50Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubWVyZ2VWaWV3Q291bnQgPSAxO1xyXG4gICAgfVxyXG4gICAgX1Byb3RvVmlld0luaXRpYWxpemVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNtZC5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0Q291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgX1Byb3RvVmlld0luaXRpYWxpemVyLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLnZpc2l0QmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChjbWQuaXNCb3VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdEJlZ2luQm91bmRFbGVtZW50KGNtZCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdEJlZ2luRWxlbWVudChjbWQsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLnZpc2l0RW5kRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiB0aGlzLl92aXNpdEVuZEVsZW1lbnQoKTsgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUudmlzaXRCZWdpbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgbmVzdGVkUHJvdG9WaWV3ID0gY3JlYXRlQ29tcG9uZW50KHRoaXMuX3Byb3RvVmlld0ZhY3RvcnksIGNtZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0QmVnaW5Cb3VuZEVsZW1lbnQoY21kLCBuZXN0ZWRQcm90b1ZpZXcpO1xyXG4gICAgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUudmlzaXRFbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gdGhpcy5fdmlzaXRFbmRFbGVtZW50KCk7IH07XHJcbiAgICBfUHJvdG9WaWV3SW5pdGlhbGl6ZXIucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgbmVzdGVkUHJvdG9WaWV3ID0gY3JlYXRlRW1iZWRkZWRUZW1wbGF0ZSh0aGlzLl9wcm90b1ZpZXdGYWN0b3J5LCBjbWQsIHRoaXMuX3Byb3RvVmlldyk7XHJcbiAgICAgICAgaWYgKGNtZC5pc01lcmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlRW1iZWRkZWRWaWV3Q291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmlzaXRCZWdpbkJvdW5kRWxlbWVudChjbWQsIG5lc3RlZFByb3RvVmlldyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0RW5kRWxlbWVudCgpO1xyXG4gICAgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUuX3Zpc2l0QmVnaW5Cb3VuZEVsZW1lbnQgPSBmdW5jdGlvbiAoY21kLCBuZXN0ZWRQcm90b1ZpZXcpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChuZXN0ZWRQcm90b1ZpZXcpICYmIG5lc3RlZFByb3RvVmlldy5pc01lcmdhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VFbGVtZW50Q291bnQgKz0gbmVzdGVkUHJvdG9WaWV3Lm1lcmdlSW5mby5lbGVtZW50Q291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VWaWV3Q291bnQgKz0gbmVzdGVkUHJvdG9WaWV3Lm1lcmdlSW5mby52aWV3Q291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VFbWJlZGRlZFZpZXdDb3VudCArPSBuZXN0ZWRQcm90b1ZpZXcubWVyZ2VJbmZvLmVtYmVkZGVkVmlld0NvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWxlbWVudEJpbmRlciA9IF9jcmVhdGVFbGVtZW50QmluZGVyKHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLCBuZXN0ZWRQcm90b1ZpZXcsIHRoaXMuZWxlbWVudEJpbmRlclN0YWNrLCB0aGlzLmJvdW5kRWxlbWVudEluZGV4LCB0aGlzLmRpc3RhbmNlVG9QYXJlbnRFbGVtZW50QmluZGVyLCB0aGlzLmRpc3RhbmNlVG9QYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciwgY21kKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJzLnB1c2goZWxlbWVudEJpbmRlcik7XHJcbiAgICAgICAgdmFyIHByb3RvRWxlbWVudEluamVjdG9yID0gZWxlbWVudEJpbmRlci5wcm90b0VsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtZC52YXJpYWJsZU5hbWVBbmRWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZUxvY2F0aW9ucy5zZXQoY21kLnZhcmlhYmxlTmFtZUFuZFZhbHVlc1tpXSwgdGhpcy5ib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRFbGVtZW50SW5kZXgrKztcclxuICAgICAgICB0aGlzLm1lcmdlRWxlbWVudENvdW50Kys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0QmVnaW5FbGVtZW50KGNtZCwgZWxlbWVudEJpbmRlciwgcHJvdG9FbGVtZW50SW5qZWN0b3IpO1xyXG4gICAgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUuX3Zpc2l0QmVnaW5FbGVtZW50ID0gZnVuY3Rpb24gKGNtZCwgZWxlbWVudEJpbmRlciwgcHJvdG9FbGVtZW50SW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnRFbGVtZW50QmluZGVyID1cclxuICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChlbGVtZW50QmluZGVyKSA/IDEgOiB0aGlzLmRpc3RhbmNlVG9QYXJlbnRFbGVtZW50QmluZGVyICsgMTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciA9XHJcbiAgICAgICAgICAgIGxhbmdfMS5pc1ByZXNlbnQocHJvdG9FbGVtZW50SW5qZWN0b3IpID8gMSA6IHRoaXMuZGlzdGFuY2VUb1BhcmVudFByb3RvRWxlbWVudEluamVjdG9yICsgMTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJTdGFjay5wdXNoKGVsZW1lbnRCaW5kZXIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIF9Qcm90b1ZpZXdJbml0aWFsaXplci5wcm90b3R5cGUuX3Zpc2l0RW5kRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50RWxlbWVudEJpbmRlciA9IHRoaXMuZWxlbWVudEJpbmRlclN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHZhciBwYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQocGFyZW50RWxlbWVudEJpbmRlcikgPyBwYXJlbnRFbGVtZW50QmluZGVyLnByb3RvRWxlbWVudEluamVjdG9yIDogbnVsbDtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlVG9QYXJlbnRFbGVtZW50QmluZGVyID0gbGFuZ18xLmlzUHJlc2VudChwYXJlbnRFbGVtZW50QmluZGVyKSA/XHJcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnRCaW5kZXIuZGlzdGFuY2VUb1BhcmVudCA6XHJcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudEVsZW1lbnRCaW5kZXIgLSAxO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VUb1BhcmVudFByb3RvRWxlbWVudEluamVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChwYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvcikgP1xyXG4gICAgICAgICAgICBwYXJlbnRQcm90b0VsZW1lbnRJbmplY3Rvci5kaXN0YW5jZVRvUGFyZW50IDpcclxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVRvUGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IgLSAxO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfUHJvdG9WaWV3SW5pdGlhbGl6ZXI7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50QmluZGVyKGRpcmVjdGl2ZVJlc29sdmVyLCBuZXN0ZWRQcm90b1ZpZXcsIGVsZW1lbnRCaW5kZXJTdGFjaywgYm91bmRFbGVtZW50SW5kZXgsIGRpc3RhbmNlVG9QYXJlbnRCaW5kZXIsIGRpc3RhbmNlVG9QYXJlbnRQZWksIGJlZ2luRWxlbWVudENtZCkge1xyXG4gICAgdmFyIHBhcmVudEVsZW1lbnRCaW5kZXIgPSBudWxsO1xyXG4gICAgdmFyIHBhcmVudFByb3RvRWxlbWVudEluamVjdG9yID0gbnVsbDtcclxuICAgIGlmIChkaXN0YW5jZVRvUGFyZW50QmluZGVyID4gMCkge1xyXG4gICAgICAgIHBhcmVudEVsZW1lbnRCaW5kZXIgPSBlbGVtZW50QmluZGVyU3RhY2tbZWxlbWVudEJpbmRlclN0YWNrLmxlbmd0aCAtIGRpc3RhbmNlVG9QYXJlbnRCaW5kZXJdO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmVudEVsZW1lbnRCaW5kZXIpKSB7XHJcbiAgICAgICAgZGlzdGFuY2VUb1BhcmVudEJpbmRlciA9IC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc3RhbmNlVG9QYXJlbnRQZWkgPiAwKSB7XHJcbiAgICAgICAgdmFyIHBlaUJpbmRlciA9IGVsZW1lbnRCaW5kZXJTdGFja1tlbGVtZW50QmluZGVyU3RhY2subGVuZ3RoIC0gZGlzdGFuY2VUb1BhcmVudFBlaV07XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGVpQmluZGVyKSkge1xyXG4gICAgICAgICAgICBwYXJlbnRQcm90b0VsZW1lbnRJbmplY3RvciA9IHBlaUJpbmRlci5wcm90b0VsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IpKSB7XHJcbiAgICAgICAgZGlzdGFuY2VUb1BhcmVudFBlaSA9IC0xO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvbmVudERpcmVjdGl2ZVByb3ZpZGVyID0gbnVsbDtcclxuICAgIHZhciBpc0VtYmVkZGVkVGVtcGxhdGUgPSBmYWxzZTtcclxuICAgIHZhciBkaXJlY3RpdmVQcm92aWRlcnMgPSBiZWdpbkVsZW1lbnRDbWQuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHByb3ZpZGVEaXJlY3RpdmUoZGlyZWN0aXZlUmVzb2x2ZXIsIHR5cGUpOyB9KTtcclxuICAgIGlmIChiZWdpbkVsZW1lbnRDbWQgaW5zdGFuY2VvZiB0ZW1wbGF0ZV9jb21tYW5kc18xLkJlZ2luQ29tcG9uZW50Q21kKSB7XHJcbiAgICAgICAgY29tcG9uZW50RGlyZWN0aXZlUHJvdmlkZXIgPSBkaXJlY3RpdmVQcm92aWRlcnNbMF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiZWdpbkVsZW1lbnRDbWQgaW5zdGFuY2VvZiB0ZW1wbGF0ZV9jb21tYW5kc18xLkVtYmVkZGVkVGVtcGxhdGVDbWQpIHtcclxuICAgICAgICBpc0VtYmVkZGVkVGVtcGxhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3RvRWxlbWVudEluamVjdG9yID0gbnVsbDtcclxuICAgIC8vIENyZWF0ZSBhIHByb3RvRWxlbWVudEluamVjdG9yIGZvciBhbnkgZWxlbWVudCB0aGF0IGVpdGhlciBoYXMgYmluZGluZ3MgKm9yKiBoYXMgb25lXHJcbiAgICAvLyBvciBtb3JlIHZhci0gZGVmaW5lZCAqb3IqIGZvciA8dGVtcGxhdGU+IGVsZW1lbnRzOlxyXG4gICAgLy8gLSBFbGVtZW50cyB3aXRoIGEgdmFyLSBkZWZpbmVkIG5lZWQgYSB0aGVpciBvd24gZWxlbWVudCBpbmplY3RvclxyXG4gICAgLy8gICBzbyB0aGF0LCB3aGVuIGh5ZHJhdGluZywgJGltcGxpY2l0IGNhbiBiZSBzZXQgdG8gdGhlIGVsZW1lbnQuXHJcbiAgICAvLyAtIDx0ZW1wbGF0ZT4gZWxlbWVudHMgbmVlZCB0aGVpciBvd24gRWxlbWVudEluamVjdG9yIHNvIHRoYXQgd2UgY2FuIHF1ZXJ5IHRoZWlyIFRlbXBsYXRlUmVmXHJcbiAgICB2YXIgaGFzVmFyaWFibGVzID0gYmVnaW5FbGVtZW50Q21kLnZhcmlhYmxlTmFtZUFuZFZhbHVlcy5sZW5ndGggPiAwO1xyXG4gICAgaWYgKGRpcmVjdGl2ZVByb3ZpZGVycy5sZW5ndGggPiAwIHx8IGhhc1ZhcmlhYmxlcyB8fCBpc0VtYmVkZGVkVGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAoIWlzRW1iZWRkZWRUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzID0gY3JlYXRlRGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyhiZWdpbkVsZW1lbnRDbWQudmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVQcm92aWRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90b0VsZW1lbnRJbmplY3RvciA9IGVsZW1lbnRfaW5qZWN0b3JfMS5Qcm90b0VsZW1lbnRJbmplY3Rvci5jcmVhdGUocGFyZW50UHJvdG9FbGVtZW50SW5qZWN0b3IsIGJvdW5kRWxlbWVudEluZGV4LCBkaXJlY3RpdmVQcm92aWRlcnMsIGxhbmdfMS5pc1ByZXNlbnQoY29tcG9uZW50RGlyZWN0aXZlUHJvdmlkZXIpLCBkaXN0YW5jZVRvUGFyZW50UGVpLCBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzKTtcclxuICAgICAgICBwcm90b0VsZW1lbnRJbmplY3Rvci5hdHRyaWJ1dGVzID0gYXJyYXlUb01hcChiZWdpbkVsZW1lbnRDbWQuYXR0ck5hbWVBbmRWYWx1ZXMsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgZWxlbWVudF9iaW5kZXJfMS5FbGVtZW50QmluZGVyKGJvdW5kRWxlbWVudEluZGV4LCBwYXJlbnRFbGVtZW50QmluZGVyLCBkaXN0YW5jZVRvUGFyZW50QmluZGVyLCBwcm90b0VsZW1lbnRJbmplY3RvciwgY29tcG9uZW50RGlyZWN0aXZlUHJvdmlkZXIsIG5lc3RlZFByb3RvVmlldyk7XHJcbn1cclxuZnVuY3Rpb24gcHJvdmlkZURpcmVjdGl2ZShkaXJlY3RpdmVSZXNvbHZlciwgdHlwZSkge1xyXG4gICAgdmFyIGFubm90YXRpb24gPSBkaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKHR5cGUpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnRfaW5qZWN0b3JfMS5EaXJlY3RpdmVQcm92aWRlci5jcmVhdGVGcm9tVHlwZSh0eXBlLCBhbm5vdGF0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzKHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlUHJvdmlkZXJzKSB7XHJcbiAgICB2YXIgZGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVOYW1lQW5kVmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHZhcmlhYmxlTmFtZUFuZFZhbHVlc1tpXTtcclxuICAgICAgICB2YXIgZGlySW5kZXggPSB2YXJpYWJsZU5hbWVBbmRWYWx1ZXNbaSArIDFdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNOdW1iZXIoZGlySW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3Muc2V0KHRlbXBsYXRlTmFtZSwgZGlySW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYSB2YXJpYWJsZSB3aXRob3V0IGEgZGlyZWN0aXZlIGluZGV4IC0+IHJlZmVyZW5jZSB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzLnNldCh0ZW1wbGF0ZU5hbWUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaXJlY3RpdmVWYXJpYWJsZUJpbmRpbmdzO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlRGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncyA9IGNyZWF0ZURpcmVjdGl2ZVZhcmlhYmxlQmluZGluZ3M7XHJcbmZ1bmN0aW9uIGFycmF5VG9NYXAoYXJyLCBpbnZlcnNlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICBpZiAoaW52ZXJzZSkge1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGFycltpICsgMV0sIGFycltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGFycltpXSwgYXJyW2kgKyAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBfZmxhdHRlbkxpc3QodHJlZSwgb3V0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGRpXzEucmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIF9mbGF0dGVuTGlzdChpdGVtLCBvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvX3ZpZXdfZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG4vKipcclxuICogQW4gdW5tb2RpZmlhYmxlIGxpc3Qgb2YgaXRlbXMgdGhhdCBBbmd1bGFyIGtlZXBzIHVwIHRvIGRhdGUgd2hlbiB0aGUgc3RhdGVcclxuICogb2YgdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFRoZSB0eXBlIG9mIG9iamVjdCB0aGF0IHtAbGluayBRdWVyeU1ldGFkYXRhfSBhbmQge0BsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfSBwcm92aWRlLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRzIGFuIGl0ZXJhYmxlIGludGVyZmFjZSwgdGhlcmVmb3JlIGl0IGNhbiBiZSB1c2VkIGluIGJvdGggRVM2XHJcbiAqIGphdmFzY3JpcHQgYGZvciAodmFyIGkgb2YgaXRlbXMpYCBsb29wcyBhcyB3ZWxsIGFzIGluIEFuZ3VsYXIgdGVtcGxhdGVzIHdpdGhcclxuICogYCpuZy1mb3I9XCIjaSBvZiBteUxpc3RcImAuXHJcbiAqXHJcbiAqIENoYW5nZXMgY2FuIGJlIG9ic2VydmVkIGJ5IHN1YnNjcmliaW5nIHRvIHRoZSBjaGFuZ2VzIGBPYnNlcnZhYmxlYC5cclxuICpcclxuICogTk9URTogSW4gdGhlIGZ1dHVyZSB0aGlzIGNsYXNzIHdpbGwgaW1wbGVtZW50IGFuIGBPYnNlcnZhYmxlYCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9SWDhzSm5RWWw5Rld1U0NXbWU1ej9wPXByZXZpZXcpKVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoey4uLn0pXHJcbiAqIGNsYXNzIENvbnRhaW5lciB7XHJcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KEl0ZW0pIGl0ZW1zOiBRdWVyeUxpc3Q8SXRlbT4pIHtcclxuICogICAgIGl0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKF8gPT4gY29uc29sZS5sb2coaXRlbXMubGVuZ3RoKSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIFF1ZXJ5TGlzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRdWVyeUxpc3QoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImNoYW5nZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW1pdHRlcjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5sZW5ndGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KHRoaXMuX3Jlc3VsdHMpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxhc3RcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmxhc3QodGhpcy5fcmVzdWx0cyk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aCB0aGUgcGFzc3NlZCBpbiBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubWFwKGZuKTsgfTtcclxuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGVbbGFuZ18xLmdldFN5bWJvbEl0ZXJhdG9yKCldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1tsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTsgfTtcclxuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnRvU3RyaW5nKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHJlcykgeyB0aGlzLl9yZXN1bHRzID0gcmVzOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2VtaXR0ZXIubmV4dCh0aGlzKTsgfTtcclxuICAgIHJldHVybiBRdWVyeUxpc3Q7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUXVlcnlMaXN0ID0gUXVlcnlMaXN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeV9saXN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIF9uZXh0VGVtcGxhdGVJZCA9IDA7XHJcbmZ1bmN0aW9uIG5leHRUZW1wbGF0ZUlkKCkge1xyXG4gICAgcmV0dXJuIF9uZXh0VGVtcGxhdGVJZCsrO1xyXG59XHJcbmV4cG9ydHMubmV4dFRlbXBsYXRlSWQgPSBuZXh0VGVtcGxhdGVJZDtcclxuLyoqXHJcbiAqIEEgY29tcGlsZWQgaG9zdCB0ZW1wbGF0ZS5cclxuICpcclxuICogVGhpcyBpcyBjb25zdCBhcyB3ZSBhcmUgc3RvcmluZyBpdCBhcyBhbm5vdGF0aW9uXHJcbiAqIGZvciB0aGUgY29tcGlsZWQgY29tcG9uZW50IHR5cGUuXHJcbiAqL1xyXG52YXIgQ29tcGlsZWRIb3N0VGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gTm90ZTogX3RlbXBsYXRlR2V0dGVyIGlzIGEgZnVuY3Rpb24gc28gdGhhdCBDb21waWxlZEhvc3RUZW1wbGF0ZSBjYW4gYmVcclxuICAgIC8vIGEgY29uc3QhXHJcbiAgICBmdW5jdGlvbiBDb21waWxlZEhvc3RUZW1wbGF0ZShfdGVtcGxhdGVHZXR0ZXIpIHtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUdldHRlciA9IF90ZW1wbGF0ZUdldHRlcjtcclxuICAgIH1cclxuICAgIENvbXBpbGVkSG9zdFRlbXBsYXRlLnByb3RvdHlwZS5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RlbXBsYXRlR2V0dGVyKCk7IH07XHJcbiAgICBDb21waWxlZEhvc3RUZW1wbGF0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtGdW5jdGlvbl0pXHJcbiAgICBdLCBDb21waWxlZEhvc3RUZW1wbGF0ZSk7XHJcbiAgICByZXR1cm4gQ29tcGlsZWRIb3N0VGVtcGxhdGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZWRIb3N0VGVtcGxhdGUgPSBDb21waWxlZEhvc3RUZW1wbGF0ZTtcclxuLyoqXHJcbiAqIEEgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAqL1xyXG52YXIgQ29tcGlsZWRUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBOb3RlOiBwYXJhbUdldHRlciBpcyBhIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIGhhdmUgY3ljbGVzIGJldHdlZW4gdGVtcGxhdGVzIVxyXG4gICAgLy8gcGFyYW1HZXR0ZXIgcmV0dXJucyBhIHR1cGxlIHdpdGg6XHJcbiAgICAvLyAtIENoYW5nZURldGVjdG9yIGZhY3RvcnkgZnVuY3Rpb25cclxuICAgIC8vIC0gVGVtcGxhdGVDbWRbXVxyXG4gICAgLy8gLSBzdHlsZXNcclxuICAgIGZ1bmN0aW9uIENvbXBpbGVkVGVtcGxhdGUoaWQsIF9kYXRhR2V0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX2RhdGFHZXR0ZXIgPSBfZGF0YUdldHRlcjtcclxuICAgIH1cclxuICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoYXBwSWQpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGFHZXR0ZXIoYXBwSWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRUZW1wbGF0ZURhdGEoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZWRUZW1wbGF0ZSA9IENvbXBpbGVkVGVtcGxhdGU7XHJcbnZhciBDb21waWxlZFRlbXBsYXRlRGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlRGF0YShjaGFuZ2VEZXRlY3RvckZhY3RvcnksIGNvbW1hbmRzLCBzdHlsZXMpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yRmFjdG9yeSA9IGNoYW5nZURldGVjdG9yRmFjdG9yeTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gY29tbWFuZHM7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29tcGlsZWRUZW1wbGF0ZURhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tcGlsZWRUZW1wbGF0ZURhdGEgPSBDb21waWxlZFRlbXBsYXRlRGF0YTtcclxudmFyIEVNUFRZX0FSUiA9IGxhbmdfMS5DT05TVF9FWFBSKFtdKTtcclxudmFyIFRleHRDbWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGV4dENtZCh2YWx1ZSwgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gaXNCb3VuZDtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICB9XHJcbiAgICBUZXh0Q21kLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUZXh0Q21kO1xyXG59KSgpO1xyXG5leHBvcnRzLlRleHRDbWQgPSBUZXh0Q21kO1xyXG5mdW5jdGlvbiB0ZXh0KHZhbHVlLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0Q21kKHZhbHVlLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCk7XHJcbn1cclxuZXhwb3J0cy50ZXh0ID0gdGV4dDtcclxudmFyIE5nQ29udGVudENtZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ0NvbnRlbnRDbWQoaW5kZXgsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIE5nQ29udGVudENtZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ0NvbnRlbnRDbWQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTmdDb250ZW50Q21kID0gTmdDb250ZW50Q21kO1xyXG5mdW5jdGlvbiBuZ0NvbnRlbnQoaW5kZXgsIG5nQ29udGVudEluZGV4KSB7XHJcbiAgICByZXR1cm4gbmV3IE5nQ29udGVudENtZChpbmRleCwgbmdDb250ZW50SW5kZXgpO1xyXG59XHJcbmV4cG9ydHMubmdDb250ZW50ID0gbmdDb250ZW50O1xyXG52YXIgQmVnaW5FbGVtZW50Q21kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJlZ2luRWxlbWVudENtZChuYW1lLCBhdHRyTmFtZUFuZFZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBpc0JvdW5kLCBuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hdHRyTmFtZUFuZFZhbHVlcyA9IGF0dHJOYW1lQW5kVmFsdWVzO1xyXG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXRBbmROYW1lcyA9IGV2ZW50VGFyZ2V0QW5kTmFtZXM7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVBbmRWYWx1ZXMgPSB2YXJpYWJsZU5hbWVBbmRWYWx1ZXM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgICAgICB0aGlzLmlzQm91bmQgPSBpc0JvdW5kO1xyXG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcclxuICAgIH1cclxuICAgIEJlZ2luRWxlbWVudENtZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmVnaW5FbGVtZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCZWdpbkVsZW1lbnRDbWQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQmVnaW5FbGVtZW50Q21kID0gQmVnaW5FbGVtZW50Q21kO1xyXG5mdW5jdGlvbiBiZWdpbkVsZW1lbnQobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgaXNCb3VuZCwgbmdDb250ZW50SW5kZXgpIHtcclxuICAgIHJldHVybiBuZXcgQmVnaW5FbGVtZW50Q21kKG5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzLCBldmVudFRhcmdldEFuZE5hbWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzQm91bmQsIG5nQ29udGVudEluZGV4KTtcclxufVxyXG5leHBvcnRzLmJlZ2luRWxlbWVudCA9IGJlZ2luRWxlbWVudDtcclxudmFyIEVuZEVsZW1lbnRDbWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW5kRWxlbWVudENtZCgpIHtcclxuICAgIH1cclxuICAgIEVuZEVsZW1lbnRDbWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVuZEVsZW1lbnQoY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVuZEVsZW1lbnRDbWQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRW5kRWxlbWVudENtZCA9IEVuZEVsZW1lbnRDbWQ7XHJcbmZ1bmN0aW9uIGVuZEVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IEVuZEVsZW1lbnRDbWQoKTtcclxufVxyXG5leHBvcnRzLmVuZEVsZW1lbnQgPSBlbmRFbGVtZW50O1xyXG52YXIgQmVnaW5Db21wb25lbnRDbWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmVnaW5Db21wb25lbnRDbWQobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMsIGV2ZW50VGFyZ2V0QW5kTmFtZXMsIHZhcmlhYmxlTmFtZUFuZFZhbHVlcywgZGlyZWN0aXZlcywgbmF0aXZlU2hhZG93LCBuZ0NvbnRlbnRJbmRleCwgdGVtcGxhdGUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYXR0ck5hbWVBbmRWYWx1ZXMgPSBhdHRyTmFtZUFuZFZhbHVlcztcclxuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0QW5kTmFtZXMgPSBldmVudFRhcmdldEFuZE5hbWVzO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lQW5kVmFsdWVzID0gdmFyaWFibGVOYW1lQW5kVmFsdWVzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgdGhpcy5uYXRpdmVTaGFkb3cgPSBuYXRpdmVTaGFkb3c7XHJcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVJZCA9IHRlbXBsYXRlLmlkO1xyXG4gICAgfVxyXG4gICAgQmVnaW5Db21wb25lbnRDbWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJlZ2luQ29tcG9uZW50KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCZWdpbkNvbXBvbmVudENtZDtcclxufSkoKTtcclxuZXhwb3J0cy5CZWdpbkNvbXBvbmVudENtZCA9IEJlZ2luQ29tcG9uZW50Q21kO1xyXG5mdW5jdGlvbiBiZWdpbkNvbXBvbmVudChuYW1lLCBhdHRyTmFtZUFuc1ZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBuYXRpdmVTaGFkb3csIG5nQ29udGVudEluZGV4LCB0ZW1wbGF0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBCZWdpbkNvbXBvbmVudENtZChuYW1lLCBhdHRyTmFtZUFuc1ZhbHVlcywgZXZlbnRUYXJnZXRBbmROYW1lcywgdmFyaWFibGVOYW1lQW5kVmFsdWVzLCBkaXJlY3RpdmVzLCBuYXRpdmVTaGFkb3csIG5nQ29udGVudEluZGV4LCB0ZW1wbGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5iZWdpbkNvbXBvbmVudCA9IGJlZ2luQ29tcG9uZW50O1xyXG52YXIgRW5kQ29tcG9uZW50Q21kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVuZENvbXBvbmVudENtZCgpIHtcclxuICAgIH1cclxuICAgIEVuZENvbXBvbmVudENtZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW5kQ29tcG9uZW50KGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbmRDb21wb25lbnRDbWQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRW5kQ29tcG9uZW50Q21kID0gRW5kQ29tcG9uZW50Q21kO1xyXG5mdW5jdGlvbiBlbmRDb21wb25lbnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IEVuZENvbXBvbmVudENtZCgpO1xyXG59XHJcbmV4cG9ydHMuZW5kQ29tcG9uZW50ID0gZW5kQ29tcG9uZW50O1xyXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUNtZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQ21kKGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuYXR0ck5hbWVBbmRWYWx1ZXMgPSBhdHRyTmFtZUFuZFZhbHVlcztcclxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZUFuZFZhbHVlcyA9IHZhcmlhYmxlTmFtZUFuZFZhbHVlcztcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG4gICAgICAgIHRoaXMuaXNNZXJnZWQgPSBpc01lcmdlZDtcclxuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvckZhY3RvcnkgPSBjaGFuZ2VEZXRlY3RvckZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0QW5kTmFtZXMgPSBFTVBUWV9BUlI7XHJcbiAgICB9XHJcbiAgICBFbWJlZGRlZFRlbXBsYXRlQ21kLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbWJlZGRlZFRlbXBsYXRlKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbWJlZGRlZFRlbXBsYXRlQ21kO1xyXG59KSgpO1xyXG5leHBvcnRzLkVtYmVkZGVkVGVtcGxhdGVDbWQgPSBFbWJlZGRlZFRlbXBsYXRlQ21kO1xyXG5mdW5jdGlvbiBlbWJlZGRlZFRlbXBsYXRlKGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBjaGlsZHJlbikge1xyXG4gICAgcmV0dXJuIG5ldyBFbWJlZGRlZFRlbXBsYXRlQ21kKGF0dHJOYW1lQW5kVmFsdWVzLCB2YXJpYWJsZU5hbWVBbmRWYWx1ZXMsIGRpcmVjdGl2ZXMsIGlzTWVyZ2VkLCBuZ0NvbnRlbnRJbmRleCwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCBjaGlsZHJlbik7XHJcbn1cclxuZXhwb3J0cy5lbWJlZGRlZFRlbXBsYXRlID0gZW1iZWRkZWRUZW1wbGF0ZTtcclxuZnVuY3Rpb24gdmlzaXRBbGxDb21tYW5kcyh2aXNpdG9yLCBjbWRzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbWRzW2ldLnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMudmlzaXRBbGxDb21tYW5kcyA9IHZpc2l0QWxsQ29tbWFuZHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlX2NvbW1hbmRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgdmlld19yZWZfMSA9IHJlcXVpcmUoJy4vdmlld19yZWYnKTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gRW1iZWRkZWQgVGVtcGxhdGUgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnN0YW50aWF0ZSBFbWJlZGRlZCBWaWV3cy5cclxuICpcclxuICogWW91IGNhbiBhY2Nlc3MgYSBgVGVtcGxhdGVSZWZgLCBpbiB0d28gd2F5cy4gVmlhIGEgZGlyZWN0aXZlIHBsYWNlZCBvbiBhIGA8dGVtcGxhdGU+YCBlbGVtZW50IChvclxyXG4gKiBkaXJlY3RpdmUgcHJlZml4ZWQgd2l0aCBgKmApIGFuZCBoYXZlIHRoZSBgVGVtcGxhdGVSZWZgIGZvciB0aGlzIEVtYmVkZGVkIFZpZXcgaW5qZWN0ZWQgaW50byB0aGVcclxuICogY29uc3RydWN0b3Igb2YgdGhlIGRpcmVjdGl2ZSB1c2luZyB0aGUgYFRlbXBsYXRlUmVmYCBUb2tlbi4gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHF1ZXJ5IGZvciB0aGVcclxuICogYFRlbXBsYXRlUmVmYCBmcm9tIGEgQ29tcG9uZW50IG9yIGEgRGlyZWN0aXZlIHZpYSB7QGxpbmsgUXVlcnl9LlxyXG4gKlxyXG4gKiBUbyBpbnN0YW50aWF0ZSBFbWJlZGRlZCBWaWV3cyBiYXNlZCBvbiBhIFRlbXBsYXRlLCB1c2VcclxuICoge0BsaW5rIFZpZXdDb250YWluZXJSZWYjY3JlYXRlRW1iZWRkZWRWaWV3fSwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIFZpZXcgYW5kIGF0dGFjaCBpdCB0byB0aGVcclxuICogVmlldyBDb250YWluZXIuXHJcbiAqL1xyXG52YXIgVGVtcGxhdGVSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVSZWYoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGVtcGxhdGVSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVtcGxhdGVSZWYgPSBUZW1wbGF0ZVJlZjtcclxudmFyIFRlbXBsYXRlUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVSZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVSZWZfKGVsZW1lbnRSZWYpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xyXG4gICAgfVxyXG4gICAgVGVtcGxhdGVSZWZfLnByb3RvdHlwZS5fZ2V0UHJvdG9WaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50UmVmID0gdGhpcy5lbGVtZW50UmVmO1xyXG4gICAgICAgIHZhciBwYXJlbnRWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoZWxlbWVudFJlZi5wYXJlbnRWaWV3KTtcclxuICAgICAgICByZXR1cm4gcGFyZW50Vmlldy5wcm90by5lbGVtZW50QmluZGVyc1tlbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4IC0gcGFyZW50Vmlldy5lbGVtZW50T2Zmc2V0XVxyXG4gICAgICAgICAgICAubmVzdGVkUHJvdG9WaWV3O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVJlZl8ucHJvdG90eXBlLCBcInByb3RvVmlld1JlZlwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBQcm90b1ZpZXcgdXNlZCBmb3IgY3JlYXRpbmcgRW1iZWRkZWQgVmlld3MgdGhhdCBhcmUgYmFzZWQgb24gdGhlIGNvbXBpbGVkXHJcbiAgICAgICAgICogRW1iZWRkZWQgVGVtcGxhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9nZXRQcm90b1ZpZXcoKS5yZWY7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVGVtcGxhdGVSZWZfLnByb3RvdHlwZS5oYXNMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3RvVmlldygpLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncy5oYXMobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRlbXBsYXRlUmVmXztcclxufSkoVGVtcGxhdGVSZWYpO1xyXG5leHBvcnRzLlRlbXBsYXRlUmVmXyA9IFRlbXBsYXRlUmVmXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVfcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xyXG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9pbnRlcmZhY2VzJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVmJyk7XHJcbnZhciB1dGlsXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZW5kZXIvZG9tL3V0aWwnKTtcclxudmFyIHZpZXdfcmVmXzIgPSByZXF1aXJlKFwiLi92aWV3X3JlZlwiKTtcclxudmFyIGludGVyZmFjZXNfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vaW50ZXJmYWNlcycpO1xyXG5leHBvcnRzLkRlYnVnQ29udGV4dCA9IGludGVyZmFjZXNfMi5EZWJ1Z0NvbnRleHQ7XHJcbnZhciBSRUZMRUNUX1BSRUZJWCA9ICduZy1yZWZsZWN0LSc7XHJcbihmdW5jdGlvbiAoVmlld1R5cGUpIHtcclxuICAgIC8vIEEgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgd2l0aCBib3VuZCBjb21wb25lbnQgZGlyZWN0aXZlLlxyXG4gICAgLy8gQ29udGFpbnMgYSBDT01QT05FTlQgdmlld1xyXG4gICAgVmlld1R5cGVbVmlld1R5cGVbXCJIT1NUXCJdID0gMF0gPSBcIkhPU1RcIjtcclxuICAgIC8vIFRoZSB2aWV3IG9mIHRoZSBjb21wb25lbnRcclxuICAgIC8vIENhbiBjb250YWluIDAgdG8gbiBFTUJFRERFRCB2aWV3c1xyXG4gICAgVmlld1R5cGVbVmlld1R5cGVbXCJDT01QT05FTlRcIl0gPSAxXSA9IFwiQ09NUE9ORU5UXCI7XHJcbiAgICAvLyBBIHZpZXcgdGhhdCBpcyBlbWJlZGRlZCBpbnRvIGFub3RoZXIgVmlldyB2aWEgYSA8dGVtcGxhdGU+IGVsZW1lbnRcclxuICAgIC8vIGluc2lkZSBvZiBhIENPTVBPTkVOVCB2aWV3XHJcbiAgICBWaWV3VHlwZVtWaWV3VHlwZVtcIkVNQkVEREVEXCJdID0gMl0gPSBcIkVNQkVEREVEXCI7XHJcbn0pKGV4cG9ydHMuVmlld1R5cGUgfHwgKGV4cG9ydHMuVmlld1R5cGUgPSB7fSkpO1xyXG52YXIgVmlld1R5cGUgPSBleHBvcnRzLlZpZXdUeXBlO1xyXG52YXIgQXBwVmlld0NvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBWaWV3Q29udGFpbmVyKCkge1xyXG4gICAgICAgIC8vIFRoZSBvcmRlciBpbiB0aGlzIGxpc3QgbWF0Y2hlcyB0aGUgRE9NIG9yZGVyLlxyXG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBBcHBWaWV3Q29udGFpbmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFZpZXdDb250YWluZXIgPSBBcHBWaWV3Q29udGFpbmVyO1xyXG4vKipcclxuICogQ29zdCBvZiBtYWtpbmcgb2JqZWN0czogaHR0cDovL2pzcGVyZi5jb20vaW5zdGFudGlhdGUtc2l6ZS1vZi1vYmplY3RcclxuICpcclxuICovXHJcbnZhciBBcHBWaWV3ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFZpZXcocmVuZGVyZXIsIHByb3RvLCB2aWV3T2Zmc2V0LCBlbGVtZW50T2Zmc2V0LCB0ZXh0T2Zmc2V0LCBwcm90b0xvY2FscywgcmVuZGVyLCByZW5kZXJGcmFnbWVudCwgY29udGFpbmVyRWxlbWVudEluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMucHJvdG8gPSBwcm90bztcclxuICAgICAgICB0aGlzLnZpZXdPZmZzZXQgPSB2aWV3T2Zmc2V0O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudE9mZnNldCA9IGVsZW1lbnRPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy50ZXh0T2Zmc2V0ID0gdGV4dE9mZnNldDtcclxuICAgICAgICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuICAgICAgICB0aGlzLnJlbmRlckZyYWdtZW50ID0gcmVuZGVyRnJhZ21lbnQ7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50SW5qZWN0b3IgPSBjb250YWluZXJFbGVtZW50SW5qZWN0b3I7XHJcbiAgICAgICAgLy8gQXBwVmlld3MgdGhhdCBoYXZlIGJlZW4gbWVyZ2VkIGluIGRlcHRoIGZpcnN0IG9yZGVyLlxyXG4gICAgICAgIC8vIFRoaXMgbGlzdCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgbWVyZ2VkIHZpZXdzLiBVc2UgdGhpcy5lbGVtZW50T2Zmc2V0IHRvIGdldCB0aGUgbG9jYWxcclxuICAgICAgICAvLyBlbnRyaWVzLlxyXG4gICAgICAgIHRoaXMudmlld3MgPSBudWxsO1xyXG4gICAgICAgIC8vIEVsZW1lbnRJbmplY3RvcnMgb2YgYWxsIEFwcFZpZXdzIGluIHZpZXdzIGdyb3VwZWQgYnkgdmlldy5cclxuICAgICAgICAvLyBUaGlzIGxpc3QgaXMgc2hhcmVkIGJldHdlZW4gYWxsIG1lcmdlZCB2aWV3cy4gVXNlIHRoaXMuZWxlbWVudE9mZnNldCB0byBnZXQgdGhlIGxvY2FsXHJcbiAgICAgICAgLy8gZW50cmllcy5cclxuICAgICAgICB0aGlzLmVsZW1lbnRJbmplY3RvcnMgPSBudWxsO1xyXG4gICAgICAgIC8vIFZpZXdDb250YWluZXJzIG9mIGFsbCBBcHBWaWV3cyBpbiB2aWV3cyBncm91cGVkIGJ5IHZpZXcuXHJcbiAgICAgICAgLy8gVGhpcyBsaXN0IGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBtZXJnZWQgdmlld3MuIFVzZSB0aGlzLmVsZW1lbnRPZmZzZXQgdG8gZ2V0IHRoZSBsb2NhbFxyXG4gICAgICAgIC8vIGVudHJpZXMuXHJcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVycyA9IG51bGw7XHJcbiAgICAgICAgLy8gUHJlQnVpbHRPYmplY3RzIG9mIGFsbCBBcHBWaWV3cyBpbiB2aWV3cyBncm91cGVkIGJ5IHZpZXcuXHJcbiAgICAgICAgLy8gVGhpcyBsaXN0IGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBtZXJnZWQgdmlld3MuIFVzZSB0aGlzLmVsZW1lbnRPZmZzZXQgdG8gZ2V0IHRoZSBsb2NhbFxyXG4gICAgICAgIC8vIGVudHJpZXMuXHJcbiAgICAgICAgdGhpcy5wcmVCdWlsdE9iamVjdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb250ZXh0IGFnYWluc3Qgd2hpY2ggZGF0YS1iaW5kaW5nIGV4cHJlc3Npb25zIGluIHRoaXMgdmlldyBhcmUgZXZhbHVhdGVkIGFnYWluc3QuXHJcbiAgICAgICAgICogVGhpcyBpcyBhbHdheXMgYSBjb21wb25lbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlZiA9IG5ldyB2aWV3X3JlZl8yLlZpZXdSZWZfKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5Mb2NhbHMobnVsbCwgY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIuY2xvbmUocHJvdG9Mb2NhbHMpKTsgLy8gVE9ETyBvcHRpbWl6ZSB0aGlzXHJcbiAgICB9XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yLCBlbGVtZW50SW5qZWN0b3JzLCByb290RWxlbWVudEluamVjdG9ycywgcHJlQnVpbHRPYmplY3RzLCB2aWV3cywgZWxlbWVudFJlZnMsIHZpZXdDb250YWluZXJzKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEluamVjdG9ycyA9IGVsZW1lbnRJbmplY3RvcnM7XHJcbiAgICAgICAgdGhpcy5yb290RWxlbWVudEluamVjdG9ycyA9IHJvb3RFbGVtZW50SW5qZWN0b3JzO1xyXG4gICAgICAgIHRoaXMucHJlQnVpbHRPYmplY3RzID0gcHJlQnVpbHRPYmplY3RzO1xyXG4gICAgICAgIHRoaXMudmlld3MgPSB2aWV3cztcclxuICAgICAgICB0aGlzLmVsZW1lbnRSZWZzID0gZWxlbWVudFJlZnM7XHJcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVycyA9IHZpZXdDb250YWluZXJzO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLnNldExvY2FsID0gZnVuY3Rpb24gKGNvbnRleHROYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5oeWRyYXRlZCgpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0Nhbm5vdCBzZXQgbG9jYWxzIG9uIGRlaHlkcmF0ZWQgdmlldy4nKTtcclxuICAgICAgICBpZiAoIXRoaXMucHJvdG8udGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzLmhhcyhjb250ZXh0TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGVtcGxhdGVOYW1lID0gdGhpcy5wcm90by50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuZ2V0KGNvbnRleHROYW1lKTtcclxuICAgICAgICB0aGlzLmxvY2Fscy5zZXQodGVtcGxhdGVOYW1lLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuaHlkcmF0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udGV4dCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIHRoZSBldmVudCBoYW5kbGVycyBmb3IgdGhlIGVsZW1lbnQgYW5kIHRoZSBkaXJlY3RpdmVzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIGRpcmVjdGl2ZSBFdmVudEVtaXR0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7Kn0gZXZlbnRPYmpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZEVsZW1lbnRJbmRleFxyXG4gICAgICovXHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqLCBib3VuZEVsZW1lbnRJbmRleCkge1xyXG4gICAgICAgIHZhciBsb2NhbHMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIGxvY2Fscy5zZXQoJyRldmVudCcsIGV2ZW50T2JqKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgbG9jYWxzKTtcclxuICAgIH07XHJcbiAgICAvLyBkaXNwYXRjaCB0byBlbGVtZW50IGluamVjdG9yIG9yIHRleHQgbm9kZXMgYmFzZWQgb24gY29udGV4dFxyXG4gICAgQXBwVmlldy5wcm90b3R5cGUubm90aWZ5T25CaW5kaW5nID0gZnVuY3Rpb24gKGIsIGN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChiLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFRleHQodGhpcy5yZW5kZXIsIGIuZWxlbWVudEluZGV4ICsgdGhpcy50ZXh0T2Zmc2V0LCBjdXJyZW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRSZWYgPSB0aGlzLmVsZW1lbnRSZWZzW3RoaXMuZWxlbWVudE9mZnNldCArIGIuZWxlbWVudEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGIuaXNFbGVtZW50UHJvcGVydHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkoZWxlbWVudFJlZiwgYi5uYW1lLCBjdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGIuaXNFbGVtZW50QXR0cmlidXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudEF0dHJpYnV0ZShlbGVtZW50UmVmLCBiLm5hbWUsIGxhbmdfMS5pc1ByZXNlbnQoY3VycmVudFZhbHVlKSA/IFwiXCIgKyBjdXJyZW50VmFsdWUgOiBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChiLmlzRWxlbWVudENsYXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnRSZWYsIGIubmFtZSwgY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChiLmlzRWxlbWVudFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gbGFuZ18xLmlzUHJlc2VudChiLnVuaXQpID8gYi51bml0IDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZShlbGVtZW50UmVmLCBiLm5hbWUsIFwiXCIgKyBjdXJyZW50VmFsdWUgKyB1bml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZGlyZWN0aXZlIHJlY29yZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmxvZ0JpbmRpbmdVcGRhdGUgPSBmdW5jdGlvbiAoYiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoYi5pc0RpcmVjdGl2ZSgpIHx8IGIuaXNFbGVtZW50UHJvcGVydHkoKSkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFJlZiA9IHRoaXMuZWxlbWVudFJlZnNbdGhpcy5lbGVtZW50T2Zmc2V0ICsgYi5lbGVtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRBdHRyaWJ1dGUoZWxlbWVudFJlZiwgXCJcIiArIFJFRkxFQ1RfUFJFRklYICsgdXRpbF8xLmNhbWVsQ2FzZVRvRGFzaENhc2UoYi5uYW1lKSwgXCJcIiArIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUubm90aWZ5QWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWlDb3VudCA9IHRoaXMucHJvdG8uZWxlbWVudEJpbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBlaSA9IHRoaXMuZWxlbWVudEluamVjdG9ycztcclxuICAgICAgICBmb3IgKHZhciBpID0gZWlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVpW2kgKyB0aGlzLmVsZW1lbnRPZmZzZXRdKSlcclxuICAgICAgICAgICAgICAgIGVpW2kgKyB0aGlzLmVsZW1lbnRPZmZzZXRdLmFmdGVyQ29udGVudENoZWNrZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUubm90aWZ5QWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWlDb3VudCA9IHRoaXMucHJvdG8uZWxlbWVudEJpbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBlaSA9IHRoaXMuZWxlbWVudEluamVjdG9ycztcclxuICAgICAgICBmb3IgKHZhciBpID0gZWlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVpW2kgKyB0aGlzLmVsZW1lbnRPZmZzZXRdKSlcclxuICAgICAgICAgICAgICAgIGVpW2kgKyB0aGlzLmVsZW1lbnRPZmZzZXRdLmFmdGVyVmlld0NoZWNrZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlRm9yID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3IgPSB0aGlzLmVsZW1lbnRJbmplY3RvcnNbdGhpcy5lbGVtZW50T2Zmc2V0ICsgZGlyZWN0aXZlLmVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJbmplY3Rvci5nZXREaXJlY3RpdmVBdEluZGV4KGRpcmVjdGl2ZS5kaXJlY3RpdmVJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZ2V0TmVzdGVkVmlldyA9IGZ1bmN0aW9uIChib3VuZEVsZW1lbnRJbmRleCkge1xyXG4gICAgICAgIHZhciBlbGkgPSB0aGlzLmVsZW1lbnRJbmplY3RvcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGVsaSkgPyBlbGkuZ2V0TmVzdGVkVmlldygpIDogbnVsbDtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udGFpbmVyRWxlbWVudEluamVjdG9yKSA/XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudEluamVjdG9yLmdldEVsZW1lbnRSZWYoKSA6XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZ2V0RGVidWdDb250ZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnRJbmRleCwgZGlyZWN0aXZlSW5kZXgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0dGVkSW5kZXggPSB0aGlzLmVsZW1lbnRPZmZzZXQgKyBlbGVtZW50SW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBoYXNSZWZGb3JJbmRleCA9IG9mZnNldHRlZEluZGV4IDwgdGhpcy5lbGVtZW50UmVmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50UmVmID0gaGFzUmVmRm9ySW5kZXggPyB0aGlzLmVsZW1lbnRSZWZzW3RoaXMuZWxlbWVudE9mZnNldCArIGVsZW1lbnRJbmRleF0gOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXJFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIHZhciBlaSA9IGhhc1JlZkZvckluZGV4ID8gdGhpcy5lbGVtZW50SW5qZWN0b3JzW3RoaXMuZWxlbWVudE9mZnNldCArIGVsZW1lbnRJbmRleF0gOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudFJlZikgPyBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50RWxlbWVudCA9IGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyKSA/IGNvbnRhaW5lci5uYXRpdmVFbGVtZW50IDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IGxhbmdfMS5pc1ByZXNlbnQoZGlyZWN0aXZlSW5kZXgpID8gdGhpcy5nZXREaXJlY3RpdmVGb3IoZGlyZWN0aXZlSW5kZXgpIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGluamVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChlaSkgPyBlaS5nZXRJbmplY3RvcigpIDogbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRlcmZhY2VzXzEuRGVidWdDb250ZXh0KGVsZW1lbnQsIGNvbXBvbmVudEVsZW1lbnQsIGRpcmVjdGl2ZSwgdGhpcy5jb250ZXh0LCBfbG9jYWxzVG9TdHJpbmdNYXAodGhpcy5sb2NhbHMpLCBpbmplY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gbG9nIHRoZSBleGNlcHRpb24gb25jZSB3ZSBoYXZlIGEgZ29vZCB3YXkgdG8gbG9nIGVycm9ycyBhbmQgd2FybmluZ3NcclxuICAgICAgICAgICAgLy8gaWYgYW4gZXJyb3IgaGFwcGVucyBkdXJpbmcgZ2V0dGluZyB0aGUgZGVidWcgY29udGV4dCwgd2UgcmV0dXJuIG51bGwuXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5nZXREZXRlY3RvckZvciA9IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcclxuICAgICAgICB2YXIgY2hpbGRWaWV3ID0gdGhpcy5nZXROZXN0ZWRWaWV3KHRoaXMuZWxlbWVudE9mZnNldCArIGRpcmVjdGl2ZS5lbGVtZW50SW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGNoaWxkVmlldykgPyBjaGlsZFZpZXcuY2hhbmdlRGV0ZWN0b3IgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAoZWxlbWVudEluZGV4LCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuZWxlbWVudFJlZnNbZWxlbWVudEluZGV4XSwgbWV0aG9kTmFtZSwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgUmVuZGVyRXZlbnREaXNwYXRjaGVyI2Rpc3BhdGNoUmVuZGVyRXZlbnRcclxuICAgIEFwcFZpZXcucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiAoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgbG9jYWxzKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRSZWYgPSB0aGlzLmVsZW1lbnRSZWZzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGVsZW1lbnRSZWYucGFyZW50Vmlldyk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXcuZGlzcGF0Y2hFdmVudChlbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGxvY2Fscyk7XHJcbiAgICB9O1xyXG4gICAgLy8gcmV0dXJucyBmYWxzZSBpZiBwcmV2ZW50RGVmYXVsdCBtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIERPTSBldmVudFxyXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBsb2NhbHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oeWRyYXRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlRGV0ZWN0b3IuaGFuZGxlRXZlbnQoZXZlbnROYW1lLCBib3VuZEVsZW1lbnRJbmRleCAtIHRoaXMuZWxlbWVudE9mZnNldCwgbmV3IGNoYW5nZV9kZXRlY3Rpb25fMS5Mb2NhbHModGhpcy5sb2NhbHMsIGxvY2FscykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldERlYnVnQ29udGV4dChib3VuZEVsZW1lbnRJbmRleCAtIHRoaXMuZWxlbWVudE9mZnNldCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbGFuZ18xLmlzUHJlc2VudChjKSA/IG5ldyBfQ29udGV4dChjLmVsZW1lbnQsIGMuY29tcG9uZW50RWxlbWVudCwgYy5jb250ZXh0LCBjLmxvY2FscywgYy5pbmplY3RvcikgOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZW50RXZhbHVhdGlvbkVycm9yKGV2ZW50TmFtZSwgZSwgZS5zdGFjaywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJvd25CaW5kZXJzQ291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcm90by5lbGVtZW50QmluZGVycy5sZW5ndGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFwcFZpZXc7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwVmlldyA9IEFwcFZpZXc7XHJcbmZ1bmN0aW9uIF9sb2NhbHNUb1N0cmluZ01hcChsb2NhbHMpIHtcclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIHZhciBjID0gbG9jYWxzO1xyXG4gICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQoYykpIHtcclxuICAgICAgICByZXMgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5tZXJnZShyZXMsIGNvbGxlY3Rpb25fMS5NYXBXcmFwcGVyLnRvU3RyaW5nTWFwKGMuY3VycmVudCkpO1xyXG4gICAgICAgIGMgPSBjLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIEVycm9yIGNvbnRleHQgaW5jbHVkZWQgd2hlbiBhbiBldmVudCBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAqL1xyXG52YXIgX0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX0NvbnRleHQoZWxlbWVudCwgY29tcG9uZW50RWxlbWVudCwgY29udGV4dCwgbG9jYWxzLCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRFbGVtZW50ID0gY29tcG9uZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMubG9jYWxzID0gbG9jYWxzO1xyXG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBfQ29udGV4dDtcclxufSkoKTtcclxuLyoqXHJcbiAqIFdyYXBzIGFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYW4gZXZlbnQgaGFuZGxlci5cclxuICovXHJcbnZhciBFdmVudEV2YWx1YXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXZlbnRFdmFsdWF0aW9uRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudEV2YWx1YXRpb25FcnJvcihldmVudE5hbWUsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJFcnJvciBkdXJpbmcgZXZhbHVhdGlvbiBvZiBcXFwiXCIgKyBldmVudE5hbWUgKyBcIlxcXCJcIiwgb3JpZ2luYWxFeGNlcHRpb24sIG9yaWdpbmFsU3RhY2ssIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50RXZhbHVhdGlvbkVycm9yO1xyXG59KShleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbik7XHJcbnZhciBBcHBQcm90b1ZpZXdNZXJnZUluZm8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwUHJvdG9WaWV3TWVyZ2VJbmZvKGVtYmVkZGVkVmlld0NvdW50LCBlbGVtZW50Q291bnQsIHZpZXdDb3VudCkge1xyXG4gICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3Q291bnQgPSBlbWJlZGRlZFZpZXdDb3VudDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IGVsZW1lbnRDb3VudDtcclxuICAgICAgICB0aGlzLnZpZXdDb3VudCA9IHZpZXdDb3VudDtcclxuICAgIH1cclxuICAgIHJldHVybiBBcHBQcm90b1ZpZXdNZXJnZUluZm87XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwUHJvdG9WaWV3TWVyZ2VJbmZvID0gQXBwUHJvdG9WaWV3TWVyZ2VJbmZvO1xyXG4vKipcclxuICpcclxuICovXHJcbnZhciBBcHBQcm90b1ZpZXcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwUHJvdG9WaWV3KHRlbXBsYXRlQ21kcywgdHlwZSwgaXNNZXJnYWJsZSwgY2hhbmdlRGV0ZWN0b3JGYWN0b3J5LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MsIHBpcGVzKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNtZHMgPSB0ZW1wbGF0ZUNtZHM7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmlzTWVyZ2FibGUgPSBpc01lcmdhYmxlO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JGYWN0b3J5ID0gY2hhbmdlRGV0ZWN0b3JGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzID0gdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcclxuICAgICAgICB0aGlzLmVsZW1lbnRCaW5kZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1lcmdlSW5mbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZUxvY2F0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZXh0QmluZGluZ0NvdW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWYgPSBuZXcgdmlld19yZWZfMi5Qcm90b1ZpZXdSZWZfKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgQXBwUHJvdG9WaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJlbmRlciwgZWxlbWVudEJpbmRlcnMsIHRleHRCaW5kaW5nQ291bnQsIG1lcmdlSW5mbywgdmFyaWFibGVMb2NhdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEJpbmRlcnMgPSBlbGVtZW50QmluZGVycztcclxuICAgICAgICB0aGlzLnRleHRCaW5kaW5nQ291bnQgPSB0ZXh0QmluZGluZ0NvdW50O1xyXG4gICAgICAgIHRoaXMubWVyZ2VJbmZvID0gbWVyZ2VJbmZvO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVMb2NhdGlvbnMgPSB2YXJpYWJsZUxvY2F0aW9ucztcclxuICAgICAgICB0aGlzLnByb3RvTG9jYWxzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncykpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAodGVtcGxhdGVOYW1lLCBfKSB7IF90aGlzLnByb3RvTG9jYWxzLnNldCh0ZW1wbGF0ZU5hbWUsIG51bGwpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFyaWFibGVMb2NhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB2aWV3J3MgbG9jYWxzIG5lZWRzIHRvIGhhdmUgYSBmdWxsIHNldCBvZiB2YXJpYWJsZSBuYW1lcyBhdCBjb25zdHJ1Y3Rpb24gdGltZVxyXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB0byBwcmV2ZW50IG5ldyB2YXJpYWJsZXMgZnJvbSBiZWluZyBzZXQgbGF0ZXIgaW4gdGhlIGxpZmVjeWNsZS4gU2luY2Ugd2UgZG9uJ3RcclxuICAgICAgICAgICAgLy8gd2FudFxyXG4gICAgICAgICAgICAvLyB0byBhY3R1YWxseSBjcmVhdGUgdmFyaWFibGUgYmluZGluZ3MgZm9yIHRoZSAkaW1wbGljaXQgYmluZGluZ3MsIGFkZCB0byB0aGVcclxuICAgICAgICAgICAgLy8gcHJvdG9Mb2NhbHMgbWFudWFsbHkuXHJcbiAgICAgICAgICAgIHZhcmlhYmxlTG9jYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKF8sIHRlbXBsYXRlTmFtZSkgeyBfdGhpcy5wcm90b0xvY2Fscy5zZXQodGVtcGxhdGVOYW1lLCBudWxsKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFwcFByb3RvVmlldy5wcm90b3R5cGUuaXNJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbGVtZW50QmluZGVycyk7IH07XHJcbiAgICByZXR1cm4gQXBwUHJvdG9WaWV3O1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFByb3RvVmlldyA9IEFwcFByb3RvVmlldztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVmJyk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29udGFpbmVyIHdoZXJlIG9uZSBvciBtb3JlIFZpZXdzIGNhbiBiZSBhdHRhY2hlZC5cclxuICpcclxuICogVGhlIGNvbnRhaW5lciBjYW4gY29udGFpbiB0d28ga2luZHMgb2YgVmlld3MuIEhvc3QgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhXHJcbiAqIHtAbGluayBDb21wb25lbnR9IHZpYSB7QGxpbmsgI2NyZWF0ZUhvc3RWaWV3fSwgYW5kIEVtYmVkZGVkIFZpZXdzLCBjcmVhdGVkIGJ5IGluc3RhbnRpYXRpbmcgYW5cclxuICoge0BsaW5rIFRlbXBsYXRlUmVmIEVtYmVkZGVkIFRlbXBsYXRlfSB2aWEge0BsaW5rICNjcmVhdGVFbWJlZGRlZFZpZXd9LlxyXG4gKlxyXG4gKiBUaGUgbG9jYXRpb24gb2YgdGhlIFZpZXcgQ29udGFpbmVyIHdpdGhpbiB0aGUgY29udGFpbmluZyBWaWV3IGlzIHNwZWNpZmllZCBieSB0aGUgQW5jaG9yXHJcbiAqIGBlbGVtZW50YC4gRWFjaCBWaWV3IENvbnRhaW5lciBjYW4gaGF2ZSBvbmx5IG9uZSBBbmNob3IgRWxlbWVudCBhbmQgZWFjaCBBbmNob3IgRWxlbWVudCBjYW4gb25seVxyXG4gKiBoYXZlIGEgc2luZ2xlIFZpZXcgQ29udGFpbmVyLlxyXG4gKlxyXG4gKiBSb290IGVsZW1lbnRzIG9mIFZpZXdzIGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyIGJlY29tZSBzaWJsaW5ncyBvZiB0aGUgQW5jaG9yIEVsZW1lbnQgaW5cclxuICogdGhlIFJlbmRlcmVkIFZpZXcuXHJcbiAqXHJcbiAqIFRvIGFjY2VzcyBhIGBWaWV3Q29udGFpbmVyUmVmYCBvZiBhbiBFbGVtZW50LCB5b3UgY2FuIGVpdGhlciBwbGFjZSBhIHtAbGluayBEaXJlY3RpdmV9IGluamVjdGVkXHJcbiAqIHdpdGggYFZpZXdDb250YWluZXJSZWZgIG9uIHRoZSBFbGVtZW50LCBvciB5b3Ugb2J0YWluIGl0IHZpYVxyXG4gKiB7QGxpbmsgQXBwVmlld01hbmFnZXIjZ2V0Vmlld0NvbnRhaW5lcn0uXHJcbiAqXHJcbiAqIDwhLS0gVE9ETyhpKTogd2UgYXJlIGFsc28gY29uc2lkZXJpbmcgRWxlbWVudFJlZiN2aWV3Q29udGFpbmVyIGFwaSAtLT5cclxuICovXHJcbnZhciBWaWV3Q29udGFpbmVyUmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIGFsbCBWaWV3cyBpbiB0aGlzIGNvbnRhaW5lci5cclxuICAgICAqL1xyXG4gICAgVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBWaWV3cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIHJldHVybiBWaWV3Q29udGFpbmVyUmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlZpZXdDb250YWluZXJSZWYgPSBWaWV3Q29udGFpbmVyUmVmO1xyXG52YXIgVmlld0NvbnRhaW5lclJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZpZXdDb250YWluZXJSZWZfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lclJlZl8odmlld01hbmFnZXIsIGVsZW1lbnQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpZXdNYW5hZ2VyID0gdmlld01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgIH1cclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5fZ2V0Vmlld3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIHZjID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoZWxlbWVudC5wYXJlbnRWaWV3KS52aWV3Q29udGFpbmVyc1tlbGVtZW50LmJvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2YykgPyB2Yy52aWV3cyA6IFtdO1xyXG4gICAgfTtcclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX2dldFZpZXdzKClbaW5kZXhdLnJlZjsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2dldFZpZXdzKCkubGVuZ3RoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8vIFRPRE8ocmFkbyk6IHByb2ZpbGUgYW5kIGRlY2lkZSB3aGV0aGVyIGJvdW5kcyBjaGVja3Mgc2hvdWxkIGJlIGFkZGVkXHJcbiAgICAvLyB0byB0aGUgbWV0aG9kcyBiZWxvdy5cclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAodGVtcGxhdGVSZWYsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFuYWdlci5jcmVhdGVFbWJlZGRlZFZpZXdJbkNvbnRhaW5lcih0aGlzLmVsZW1lbnQsIGluZGV4LCB0ZW1wbGF0ZVJlZik7XHJcbiAgICB9O1xyXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUhvc3RWaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlld1JlZiwgaW5kZXgsIGR5bmFtaWNhbGx5Q3JlYXRlZFByb3ZpZGVycykge1xyXG4gICAgICAgIGlmIChwcm90b1ZpZXdSZWYgPT09IHZvaWQgMCkgeyBwcm90b1ZpZXdSZWYgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgIGlmIChkeW5hbWljYWxseUNyZWF0ZWRQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBkeW5hbWljYWxseUNyZWF0ZWRQcm92aWRlcnMgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdNYW5hZ2VyLmNyZWF0ZUhvc3RWaWV3SW5Db250YWluZXIodGhpcy5lbGVtZW50LCBpbmRleCwgcHJvdG9WaWV3UmVmLCBkeW5hbWljYWxseUNyZWF0ZWRQcm92aWRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZpZXdSZWYsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFuYWdlci5hdHRhY2hWaWV3SW5Db250YWluZXIodGhpcy5lbGVtZW50LCBpbmRleCwgdmlld1JlZik7XHJcbiAgICB9O1xyXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodmlld1JlZikge1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaW5kZXhPZih0aGlzLl9nZXRWaWV3cygpLCB2aWV3X3JlZl8xLmludGVybmFsVmlldyh2aWV3UmVmKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETyhpKTogcmVuYW1lIHRvIGRlc3Ryb3lcclxuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB0aGlzLnZpZXdNYW5hZ2VyLmRlc3Ryb3lWaWV3SW5Db250YWluZXIodGhpcy5lbGVtZW50LCBpbmRleCk7XHJcbiAgICAgICAgLy8gdmlldyBpcyBpbnRlbnRpb25hbGx5IG5vdCByZXR1cm5lZCB0byB0aGUgY2xpZW50LlxyXG4gICAgfTtcclxuICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01hbmFnZXIuZGV0YWNoVmlld0luQ29udGFpbmVyKHRoaXMuZWxlbWVudCwgaW5kZXgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3Q29udGFpbmVyUmVmXztcclxufSkoVmlld0NvbnRhaW5lclJlZik7XHJcbmV4cG9ydHMuVmlld0NvbnRhaW5lclJlZl8gPSBWaWV3Q29udGFpbmVyUmVmXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19jb250YWluZXJfcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbi8qKlxyXG4gKiBMaXN0ZW5lciBmb3IgdmlldyBjcmVhdGlvbiAvIGRlc3RydWN0aW9uLlxyXG4gKi9cclxudmFyIEFwcFZpZXdMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBWaWV3TGlzdGVuZXIoKSB7XHJcbiAgICB9XHJcbiAgICBBcHBWaWV3TGlzdGVuZXIucHJvdG90eXBlLnZpZXdDcmVhdGVkID0gZnVuY3Rpb24gKHZpZXcpIHsgfTtcclxuICAgIEFwcFZpZXdMaXN0ZW5lci5wcm90b3R5cGUudmlld0Rlc3Ryb3llZCA9IGZ1bmN0aW9uICh2aWV3KSB7IH07XHJcbiAgICBBcHBWaWV3TGlzdGVuZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEFwcFZpZXdMaXN0ZW5lcik7XHJcbiAgICByZXR1cm4gQXBwVmlld0xpc3RlbmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkFwcFZpZXdMaXN0ZW5lciA9IEFwcFZpZXdMaXN0ZW5lcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19saXN0ZW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIHZpZXdNb2R1bGUgPSByZXF1aXJlKCcuL3ZpZXcnKTtcclxudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVmJyk7XHJcbnZhciBhcGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3JlbmRlci9hcGknKTtcclxudmFyIHZpZXdfbWFuYWdlcl91dGlsc18xID0gcmVxdWlyZSgnLi92aWV3X21hbmFnZXJfdXRpbHMnKTtcclxudmFyIHZpZXdfcG9vbF8xID0gcmVxdWlyZSgnLi92aWV3X3Bvb2wnKTtcclxudmFyIHZpZXdfbGlzdGVuZXJfMSA9IHJlcXVpcmUoJy4vdmlld19saXN0ZW5lcicpO1xyXG52YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi4vcHJvZmlsZS9wcm9maWxlJyk7XHJcbnZhciBwcm90b192aWV3X2ZhY3RvcnlfMSA9IHJlcXVpcmUoJy4vcHJvdG9fdmlld19mYWN0b3J5Jyk7XHJcbi8qKlxyXG4gKiBTZXJ2aWNlIGV4cG9zaW5nIGxvdyBsZXZlbCBBUEkgZm9yIGNyZWF0aW5nLCBtb3ZpbmcgYW5kIGRlc3Ryb3lpbmcgVmlld3MuXHJcbiAqXHJcbiAqIE1vc3QgYXBwbGljYXRpb25zIHNob3VsZCB1c2UgaGlnaGVyLWxldmVsIGFic3RyYWN0aW9ucyBsaWtlIHtAbGluayBEeW5hbWljQ29tcG9uZW50TG9hZGVyfSBhbmRcclxuICoge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IGluc3RlYWQuXHJcbiAqL1xyXG52YXIgQXBwVmlld01hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBwVmlld01hbmFnZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBFbGVtZW50UmVmfSB0aGF0IG1ha2VzIHVwIHRoZSBzcGVjaWZpZWQgSG9zdCBWaWV3LlxyXG4gICAgICovXHJcbiAgICBBcHBWaWV3TWFuYWdlci5wcm90b3R5cGUuZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoaG9zdFZpZXdSZWYpIHtcclxuICAgICAgICB2YXIgaG9zdFZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyhob3N0Vmlld1JlZik7XHJcbiAgICAgICAgaWYgKGhvc3RWaWV3LnByb3RvLnR5cGUgIT09IHZpZXdNb2R1bGUuVmlld1R5cGUuSE9TVCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1RoaXMgb3BlcmF0aW9uIGlzIG9ubHkgYWxsb3dlZCBvbiBob3N0IHZpZXdzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0Vmlldy5lbGVtZW50UmVmc1tob3N0Vmlldy5lbGVtZW50T2Zmc2V0XTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXBwVmlld01hbmFnZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXBwVmlld01hbmFnZXIgPSBBcHBWaWV3TWFuYWdlcjtcclxudmFyIEFwcFZpZXdNYW5hZ2VyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXBwVmlld01hbmFnZXJfLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXBwVmlld01hbmFnZXJfKF92aWV3UG9vbCwgX3ZpZXdMaXN0ZW5lciwgX3V0aWxzLCBfcmVuZGVyZXIsIF9wcm90b1ZpZXdGYWN0b3J5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdmlld1Bvb2wgPSBfdmlld1Bvb2w7XHJcbiAgICAgICAgdGhpcy5fdmlld0xpc3RlbmVyID0gX3ZpZXdMaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLl91dGlscyA9IF91dGlscztcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlUm9vdEhvc3RWaWV3U2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0FwcFZpZXdNYW5hZ2VyI2NyZWF0ZVJvb3RIb3N0VmlldygpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lSb290SG9zdFZpZXdTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnQXBwVmlld01hbmFnZXIjZGVzdHJveVJvb3RIb3N0VmlldygpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVtYmVkZGVkVmlld0luQ29udGFpbmVyU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0FwcFZpZXdNYW5hZ2VyI2NyZWF0ZUVtYmVkZGVkVmlld0luQ29udGFpbmVyKCknKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlSG9zdFZpZXdJbkNvbnRhaW5lclNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYWdlciNjcmVhdGVIb3N0Vmlld0luQ29udGFpbmVyKCknKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fZGVzdHJveVZpZXdJbkNvbnRhaW5lclNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYW5nZXIjZGVzdHJveVZpZXdJbkNvbnRhaW5lcigpJyk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2F0dGFjaFZpZXdJbkNvbnRhaW5lclNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdBcHBWaWV3TWFuYW5nZXIjYXR0YWNoVmlld0luQ29udGFpbmVyKCknKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fZGV0YWNoVmlld0luQ29udGFpbmVyU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0FwcFZpZXdNYW5hbmdlciNkZXRhY2hWaWV3SW5Db250YWluZXIoKScpO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvVmlld0ZhY3RvcnkgPSBfcHJvdG9WaWV3RmFjdG9yeTtcclxuICAgIH1cclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuZ2V0Vmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xyXG4gICAgICAgIHZhciBob3N0VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KGxvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHJldHVybiBob3N0Vmlldy5lbGVtZW50SW5qZWN0b3JzW2xvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4XVxyXG4gICAgICAgICAgICAuZ2V0Vmlld0NvbnRhaW5lclJlZigpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuZ2V0TmFtZWRFbGVtZW50SW5Db21wb25lbnRWaWV3ID0gZnVuY3Rpb24gKGhvc3RMb2NhdGlvbiwgdmFyaWFibGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIGhvc3RWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoaG9zdExvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IGhvc3RMb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IGhvc3RWaWV3LmdldE5lc3RlZFZpZXcoYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnRWaWV3KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJUaGVyZSBpcyBubyBjb21wb25lbnQgZGlyZWN0aXZlIGF0IGVsZW1lbnQgXCIgKyBib3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiaW5kZXJJZHggPSBjb21wb25lbnRWaWV3LnByb3RvLnZhcmlhYmxlTG9jYXRpb25zLmdldCh2YXJpYWJsZU5hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhiaW5kZXJJZHgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBmaW5kIHZhcmlhYmxlIFwiICsgdmFyaWFibGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFZpZXcuZWxlbWVudFJlZnNbY29tcG9uZW50Vmlldy5lbGVtZW50T2Zmc2V0ICsgYmluZGVySWR4XTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIChob3N0TG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgaG9zdFZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyhob3N0TG9jYXRpb24ucGFyZW50Vmlldyk7XHJcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gaG9zdExvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91dGlscy5nZXRDb21wb25lbnRJbnN0YW5jZShob3N0VmlldywgYm91bmRFbGVtZW50SW5kZXgpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuY3JlYXRlUm9vdEhvc3RWaWV3ID0gZnVuY3Rpb24gKGhvc3RQcm90b1ZpZXdSZWYsIG92ZXJyaWRlU2VsZWN0b3IsIGluamVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9jcmVhdGVSb290SG9zdFZpZXdTY29wZSgpO1xyXG4gICAgICAgIHZhciBob3N0UHJvdG9WaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFByb3RvVmlldyhob3N0UHJvdG9WaWV3UmVmKTtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5LmluaXRpYWxpemVQcm90b1ZpZXdJZk5lZWRlZChob3N0UHJvdG9WaWV3KTtcclxuICAgICAgICB2YXIgaG9zdEVsZW1lbnRTZWxlY3RvciA9IG92ZXJyaWRlU2VsZWN0b3I7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGhvc3RFbGVtZW50U2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIGhvc3RFbGVtZW50U2VsZWN0b3IgPSBob3N0UHJvdG9WaWV3LmVsZW1lbnRCaW5kZXJzWzBdLmNvbXBvbmVudERpcmVjdGl2ZS5tZXRhZGF0YS5zZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzID0gdGhpcy5fcmVuZGVyZXIuY3JlYXRlUm9vdEhvc3RWaWV3KGhvc3RQcm90b1ZpZXcucmVuZGVyLCBob3N0UHJvdG9WaWV3Lm1lcmdlSW5mby5lbWJlZGRlZFZpZXdDb3VudCArIDEsIGhvc3RFbGVtZW50U2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBob3N0VmlldyA9IHRoaXMuX2NyZWF0ZU1haW5WaWV3KGhvc3RQcm90b1ZpZXcsIHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5oeWRyYXRlVmlldyhob3N0Vmlldy5yZW5kZXIpO1xyXG4gICAgICAgIHRoaXMuX3V0aWxzLmh5ZHJhdGVSb290SG9zdFZpZXcoaG9zdFZpZXcsIGluamVjdG9yKTtcclxuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIGhvc3RWaWV3LnJlZik7XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5kZXN0cm95Um9vdEhvc3RWaWV3ID0gZnVuY3Rpb24gKGhvc3RWaWV3UmVmKSB7XHJcbiAgICAgICAgLy8gTm90ZTogRG9uJ3QgcHV0IHRoZSBob3N0VmlldyBpbnRvIHRoZSB2aWV3IHBvb2xcclxuICAgICAgICAvLyBhcyBpdCBpcyBkZXBlbmRpbmcgb24gdGhlIGVsZW1lbnQgZm9yIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxyXG4gICAgICAgIHZhciBzID0gdGhpcy5fZGVzdHJveVJvb3RIb3N0Vmlld1Njb3BlKCk7XHJcbiAgICAgICAgdmFyIGhvc3RWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoaG9zdFZpZXdSZWYpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmRldGFjaEZyYWdtZW50KGhvc3RWaWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZWh5ZHJhdGVWaWV3KGhvc3RWaWV3LnJlbmRlcik7XHJcbiAgICAgICAgdGhpcy5fdmlld0RlaHlkcmF0ZVJlY3Vyc2UoaG9zdFZpZXcpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdMaXN0ZW5lci52aWV3RGVzdHJveWVkKGhvc3RWaWV3KTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0Vmlldy5yZW5kZXIpO1xyXG4gICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgsIHRlbXBsYXRlUmVmKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9jcmVhdGVFbWJlZGRlZFZpZXdJbkNvbnRhaW5lclNjb3BlKCk7XHJcbiAgICAgICAgdmFyIHByb3RvVmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxQcm90b1ZpZXcodGVtcGxhdGVSZWYucHJvdG9WaWV3UmVmKTtcclxuICAgICAgICBpZiAocHJvdG9WaWV3LnR5cGUgIT09IHZpZXdNb2R1bGUuVmlld1R5cGUuRU1CRURERUQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdUaGlzIG1ldGhvZCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBlbWJlZGRlZCBQcm90b1ZpZXdzIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXdGYWN0b3J5LmluaXRpYWxpemVQcm90b1ZpZXdJZk5lZWRlZChwcm90b1ZpZXcpO1xyXG4gICAgICAgIHJldHVybiBwcm9maWxlXzEud3RmTGVhdmUocywgdGhpcy5fY3JlYXRlVmlld0luQ29udGFpbmVyKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgsIHByb3RvVmlldywgdGVtcGxhdGVSZWYuZWxlbWVudFJlZiwgbnVsbCkpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuY3JlYXRlSG9zdFZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uICh2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4LCBwcm90b1ZpZXdSZWYsIGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3Rvcikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlSG9zdFZpZXdJbkNvbnRhaW5lclNjb3BlKCk7XHJcbiAgICAgICAgdmFyIHByb3RvVmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxQcm90b1ZpZXcocHJvdG9WaWV3UmVmKTtcclxuICAgICAgICBpZiAocHJvdG9WaWV3LnR5cGUgIT09IHZpZXdNb2R1bGUuVmlld1R5cGUuSE9TVCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1RoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGhvc3QgUHJvdG9WaWV3cyEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvdG9WaWV3RmFjdG9yeS5pbml0aWFsaXplUHJvdG9WaWV3SWZOZWVkZWQocHJvdG9WaWV3KTtcclxuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHRoaXMuX2NyZWF0ZVZpZXdJbkNvbnRhaW5lcih2aWV3Q29udGFpbmVyTG9jYXRpb24sIGluZGV4LCBwcm90b1ZpZXcsIHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHtAbGluayBBcHBWaWV3TWFuYWdlciNkZXN0cm95Vmlld0luQ29udGFpbmVyfS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLl9jcmVhdGVWaWV3SW5Db250YWluZXIgPSBmdW5jdGlvbiAodmlld0NvbnRhaW5lckxvY2F0aW9uLCBpbmRleCwgcHJvdG9WaWV3LCBjb250ZXh0LCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpIHtcclxuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KHZpZXdDb250YWluZXJMb2NhdGlvbi5wYXJlbnRWaWV3KTtcclxuICAgICAgICB2YXIgYm91bmRFbGVtZW50SW5kZXggPSB2aWV3Q29udGFpbmVyTG9jYXRpb24uYm91bmRFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgdmFyIGNvbnRleHRWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcoY29udGV4dC5wYXJlbnRWaWV3KTtcclxuICAgICAgICB2YXIgY29udGV4dEJvdW5kRWxlbWVudEluZGV4ID0gY29udGV4dC5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB2YXIgZW1iZWRkZWRGcmFnbWVudFZpZXcgPSBjb250ZXh0Vmlldy5nZXROZXN0ZWRWaWV3KGNvbnRleHRCb3VuZEVsZW1lbnRJbmRleCk7XHJcbiAgICAgICAgdmFyIHZpZXc7XHJcbiAgICAgICAgaWYgKHByb3RvVmlldy50eXBlID09PSB2aWV3TW9kdWxlLlZpZXdUeXBlLkVNQkVEREVEICYmIGxhbmdfMS5pc1ByZXNlbnQoZW1iZWRkZWRGcmFnbWVudFZpZXcpICYmXHJcbiAgICAgICAgICAgICFlbWJlZGRlZEZyYWdtZW50Vmlldy5oeWRyYXRlZCgpKSB7XHJcbiAgICAgICAgICAgIC8vIENhc2UgMTogaW5zdGFudGlhdGUgdGhlIGZpcnN0IHZpZXcgb2YgYSB0ZW1wbGF0ZSB0aGF0IGhhcyBiZWVuIG1lcmdlZCBpbnRvIGEgcGFyZW50XHJcbiAgICAgICAgICAgIHZpZXcgPSBlbWJlZGRlZEZyYWdtZW50VmlldztcclxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUmVuZGVyVmlldyhwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FzZSAyOiBpbnN0YW50aWF0ZSBhbm90aGVyIGNvcHkgb2YgdGhlIHRlbXBsYXRlIG9yIGEgaG9zdCBQcm90b1ZpZXcuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzZXBhcmF0ZSBjYXNlXHJcbiAgICAgICAgICAgIC8vIGFzIHdlIG9ubHkgaW5saW5lIG9uZSBjb3B5IG9mIHRoZSB0ZW1wbGF0ZSBpbnRvIHRoZSBwYXJlbnQgdmlldy5cclxuICAgICAgICAgICAgdmlldyA9IHRoaXMuX2NyZWF0ZVBvb2xlZFZpZXcocHJvdG9WaWV3KTtcclxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUmVuZGVyVmlldyhwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5oeWRyYXRlVmlldyh2aWV3LnJlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3V0aWxzLmF0dGFjaFZpZXdJbkNvbnRhaW5lcihwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgY29udGV4dFZpZXcsIGNvbnRleHRCb3VuZEVsZW1lbnRJbmRleCwgaW5kZXgsIHZpZXcpO1xyXG4gICAgICAgIHRoaXMuX3V0aWxzLmh5ZHJhdGVWaWV3SW5Db250YWluZXIocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGNvbnRleHRWaWV3LCBjb250ZXh0Qm91bmRFbGVtZW50SW5kZXgsIGluZGV4LCBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiB2aWV3LnJlZjtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLl9hdHRhY2hSZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBpbmRleCwgdmlldykge1xyXG4gICAgICAgIHZhciBlbGVtZW50UmVmID0gcGFyZW50Vmlldy5lbGVtZW50UmVmc1tib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmF0dGFjaEZyYWdtZW50QWZ0ZXJFbGVtZW50KGVsZW1lbnRSZWYsIHZpZXcucmVuZGVyRnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHByZXZWaWV3ID0gcGFyZW50Vmlldy52aWV3Q29udGFpbmVyc1tib3VuZEVsZW1lbnRJbmRleF0udmlld3NbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXR0YWNoRnJhZ21lbnRBZnRlckZyYWdtZW50KHByZXZWaWV3LnJlbmRlckZyYWdtZW50LCB2aWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5kZXN0cm95Vmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2Rlc3Ryb3lWaWV3SW5Db250YWluZXJTY29wZSgpO1xyXG4gICAgICAgIHZhciBwYXJlbnRWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcodmlld0NvbnRhaW5lckxvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IHZpZXdDb250YWluZXJMb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB0aGlzLl9kZXN0cm95Vmlld0luQ29udGFpbmVyKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgcHJvZmlsZV8xLnd0ZkxlYXZlKHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGRldGFjaFZpZXdJbkNvbnRhaW5lcithdHRhY2hWaWV3SW5Db250YWluZXIgdG8gbW92ZVZpZXdJbkNvbnRhaW5lclxyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5hdHRhY2hWaWV3SW5Db250YWluZXIgPSBmdW5jdGlvbiAodmlld0NvbnRhaW5lckxvY2F0aW9uLCBpbmRleCwgdmlld1JlZikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fYXR0YWNoVmlld0luQ29udGFpbmVyU2NvcGUoKTtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdfcmVmXzEuaW50ZXJuYWxWaWV3KHZpZXdSZWYpO1xyXG4gICAgICAgIHZhciBwYXJlbnRWaWV3ID0gdmlld19yZWZfMS5pbnRlcm5hbFZpZXcodmlld0NvbnRhaW5lckxvY2F0aW9uLnBhcmVudFZpZXcpO1xyXG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IHZpZXdDb250YWluZXJMb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICAvLyBUT0RPKHRib3NjaCk6IHRoZSBwdWJsaWMgbWV0aG9kcyBhdHRhY2hWaWV3SW5Db250YWluZXIvZGV0YWNoVmlld0luQ29udGFpbmVyXHJcbiAgICAgICAgLy8gYXJlIHVzZWQgZm9yIG1vdmluZyBlbGVtZW50cyB3aXRob3V0IHRoZSBzYW1lIGNvbnRhaW5lci5cclxuICAgICAgICAvLyBXZSB3aWxsIGNoYW5nZSB0aGlzIGludG8gYW4gYXRvbWljIGBtb3ZlYCBvcGVyYXRpb24sIHdoaWNoIHNob3VsZCBwcmVzZXJ2ZSB0aGVcclxuICAgICAgICAvLyBwcmV2aW91cyBwYXJlbnQgaW5qZWN0b3IgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xMzc3KS5cclxuICAgICAgICAvLyBSaWdodCBub3cgd2UgYXJlIGRlc3Ryb3lpbmcgYW55IHNwZWNpYWxcclxuICAgICAgICAvLyBjb250ZXh0IHZpZXcgdGhhdCBtaWdodCBoYXZlIGJlZW4gdXNlZC5cclxuICAgICAgICB0aGlzLl91dGlscy5hdHRhY2hWaWV3SW5Db250YWluZXIocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIG51bGwsIG51bGwsIGluZGV4LCB2aWV3KTtcclxuICAgICAgICB0aGlzLl9hdHRhY2hSZW5kZXJWaWV3KHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBpbmRleCwgdmlldyk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVfMS53dGZMZWF2ZShzLCB2aWV3UmVmKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPKGkpOiByZWZhY3RvciBkZXRhY2hWaWV3SW5Db250YWluZXIrYXR0YWNoVmlld0luQ29udGFpbmVyIHRvIG1vdmVWaWV3SW5Db250YWluZXJcclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuZGV0YWNoVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXJMb2NhdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuX2RldGFjaFZpZXdJbkNvbnRhaW5lclNjb3BlKCk7XHJcbiAgICAgICAgdmFyIHBhcmVudFZpZXcgPSB2aWV3X3JlZl8xLmludGVybmFsVmlldyh2aWV3Q29udGFpbmVyTG9jYXRpb24ucGFyZW50Vmlldyk7XHJcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gdmlld0NvbnRhaW5lckxvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gcGFyZW50Vmlldy52aWV3Q29udGFpbmVyc1tib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3Q29udGFpbmVyLnZpZXdzW2luZGV4XTtcclxuICAgICAgICB0aGlzLl91dGlscy5kZXRhY2hWaWV3SW5Db250YWluZXIocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgsIGluZGV4KTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXRhY2hGcmFnbWVudCh2aWV3LnJlbmRlckZyYWdtZW50KTtcclxuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHZpZXcucmVmKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLl9jcmVhdGVNYWluVmlldyA9IGZ1bmN0aW9uIChwcm90b1ZpZXcsIHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzKSB7XHJcbiAgICAgICAgdmFyIG1lcmdlZFBhcmVudFZpZXcgPSB0aGlzLl91dGlscy5jcmVhdGVWaWV3KHByb3RvVmlldywgcmVuZGVyVmlld1dpdGhGcmFnbWVudHMsIHRoaXMsIHRoaXMuX3JlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFdmVudERpc3BhdGNoZXIobWVyZ2VkUGFyZW50Vmlldy5yZW5kZXIsIG1lcmdlZFBhcmVudFZpZXcpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdMaXN0ZW5lci52aWV3Q3JlYXRlZChtZXJnZWRQYXJlbnRWaWV3KTtcclxuICAgICAgICByZXR1cm4gbWVyZ2VkUGFyZW50VmlldztcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlcl8ucHJvdG90eXBlLl9jcmVhdGVQb29sZWRWaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlldykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlld1Bvb2wuZ2V0Vmlldyhwcm90b1ZpZXcpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3KSkge1xyXG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5fY3JlYXRlTWFpblZpZXcocHJvdG9WaWV3LCB0aGlzLl9yZW5kZXJlci5jcmVhdGVWaWV3KHByb3RvVmlldy5yZW5kZXIsIHByb3RvVmlldy5tZXJnZUluZm8uZW1iZWRkZWRWaWV3Q291bnQgKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3O1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFwcFZpZXdNYW5hZ2VyXy5wcm90b3R5cGUuX2Rlc3Ryb3lQb29sZWRWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2YXIgd2FzUmV0dXJuZWQgPSB0aGlzLl92aWV3UG9vbC5yZXR1cm5WaWV3KHZpZXcpO1xyXG4gICAgICAgIGlmICghd2FzUmV0dXJuZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlld0xpc3RlbmVyLnZpZXdEZXN0cm95ZWQodmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmRlc3Ryb3lWaWV3KHZpZXcucmVuZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fZGVzdHJveVZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHBhcmVudFZpZXcudmlld0NvbnRhaW5lcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdmlld0NvbnRhaW5lci52aWV3c1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5fdmlld0RlaHlkcmF0ZVJlY3Vyc2Uodmlldyk7XHJcbiAgICAgICAgdGhpcy5fdXRpbHMuZGV0YWNoVmlld0luQ29udGFpbmVyKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgaWYgKHZpZXcudmlld09mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBhIHZpZXcgdGhhdCBpcyBwYXJ0IG9mIGFub3RoZXIgdmlldy5cclxuICAgICAgICAgICAgLy8gSnVzdCBkZXRhY2ggdGhlIGZyYWdtZW50XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmRldGFjaEZyYWdtZW50KHZpZXcucmVuZGVyRnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FzZSAyOiBhIHZpZXcgdGhhdCBpcyBub3QgcGFydCBvZiBhbm90aGVyIHZpZXcuXHJcbiAgICAgICAgICAgIC8vIGRlaHlkcmF0ZSBhbmQgZGVzdHJveSBpdC5cclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGVoeWRyYXRlVmlldyh2aWV3LnJlbmRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmRldGFjaEZyYWdtZW50KHZpZXcucmVuZGVyRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UG9vbGVkVmlldyh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJfLnByb3RvdHlwZS5fdmlld0RlaHlkcmF0ZVJlY3Vyc2UgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIGlmICh2aWV3Lmh5ZHJhdGVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXRpbHMuZGVoeWRyYXRlVmlldyh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXJzID0gdmlldy52aWV3Q29udGFpbmVycztcclxuICAgICAgICB2YXIgc3RhcnRWaWV3T2Zmc2V0ID0gdmlldy52aWV3T2Zmc2V0O1xyXG4gICAgICAgIHZhciBlbmRWaWV3T2Zmc2V0ID0gdmlldy52aWV3T2Zmc2V0ICsgdmlldy5wcm90by5tZXJnZUluZm8udmlld0NvdW50IC0gMTtcclxuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IHZpZXcuZWxlbWVudE9mZnNldDtcclxuICAgICAgICBmb3IgKHZhciB2aWV3SWR4ID0gc3RhcnRWaWV3T2Zmc2V0OyB2aWV3SWR4IDw9IGVuZFZpZXdPZmZzZXQ7IHZpZXdJZHgrKykge1xyXG4gICAgICAgICAgICB2YXIgY3VyclZpZXcgPSB2aWV3LnZpZXdzW3ZpZXdJZHhdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiaW5kZXJJZHggPSAwOyBiaW5kZXJJZHggPCBjdXJyVmlldy5wcm90by5lbGVtZW50QmluZGVycy5sZW5ndGg7IGJpbmRlcklkeCsrLCBlbGVtZW50T2Zmc2V0KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YyA9IHZpZXdDb250YWluZXJzW2VsZW1lbnRPZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHZjLnZpZXdzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lWaWV3SW5Db250YWluZXIoY3VyclZpZXcsIGVsZW1lbnRPZmZzZXQsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlcl8gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDQsIGRpXzEuSW5qZWN0KGRpXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b192aWV3X2ZhY3RvcnlfMS5Qcm90b1ZpZXdGYWN0b3J5OyB9KSkpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFt2aWV3X3Bvb2xfMS5BcHBWaWV3UG9vbCwgdmlld19saXN0ZW5lcl8xLkFwcFZpZXdMaXN0ZW5lciwgdmlld19tYW5hZ2VyX3V0aWxzXzEuQXBwVmlld01hbmFnZXJVdGlscywgYXBpXzEuUmVuZGVyZXIsIE9iamVjdF0pXHJcbiAgICBdLCBBcHBWaWV3TWFuYWdlcl8pO1xyXG4gICAgcmV0dXJuIEFwcFZpZXdNYW5hZ2VyXztcclxufSkoQXBwVmlld01hbmFnZXIpO1xyXG5leHBvcnRzLkFwcFZpZXdNYW5hZ2VyXyA9IEFwcFZpZXdNYW5hZ2VyXztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19tYW5hZ2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZWxpID0gcmVxdWlyZSgnLi9lbGVtZW50X2luamVjdG9yJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgdmlld01vZHVsZSA9IHJlcXVpcmUoJy4vdmlldycpO1xyXG52YXIgZWxlbWVudF9yZWZfMSA9IHJlcXVpcmUoJy4vZWxlbWVudF9yZWYnKTtcclxudmFyIHRlbXBsYXRlX3JlZl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9yZWYnKTtcclxudmFyIHBpcGVzXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9waXBlcy9waXBlcycpO1xyXG52YXIgQXBwVmlld01hbmFnZXJVdGlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBWaWV3TWFuYWdlclV0aWxzKCkge1xyXG4gICAgfVxyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuZ2V0Q29tcG9uZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAocGFyZW50VmlldywgYm91bmRFbGVtZW50SW5kZXgpIHtcclxuICAgICAgICB2YXIgZWxpID0gcGFyZW50Vmlldy5lbGVtZW50SW5qZWN0b3JzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICByZXR1cm4gZWxpLmdldENvbXBvbmVudCgpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAobWVyZ2VkUGFyZW50Vmlld1Byb3RvLCByZW5kZXJWaWV3V2l0aEZyYWdtZW50cywgdmlld01hbmFnZXIsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlckZyYWdtZW50cyA9IHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzLmZyYWdtZW50UmVmcztcclxuICAgICAgICB2YXIgcmVuZGVyVmlldyA9IHJlbmRlclZpZXdXaXRoRnJhZ21lbnRzLnZpZXdSZWY7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRDb3VudCA9IG1lcmdlZFBhcmVudFZpZXdQcm90by5tZXJnZUluZm8uZWxlbWVudENvdW50O1xyXG4gICAgICAgIHZhciB2aWV3Q291bnQgPSBtZXJnZWRQYXJlbnRWaWV3UHJvdG8ubWVyZ2VJbmZvLnZpZXdDb3VudDtcclxuICAgICAgICB2YXIgZWxlbWVudFJlZnMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGVsZW1lbnRDb3VudCk7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXJzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShlbGVtZW50Q291bnQpO1xyXG4gICAgICAgIHZhciBwcmVCdWlsdE9iamVjdHMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGVsZW1lbnRDb3VudCk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRJbmplY3RvcnMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGVsZW1lbnRDb3VudCk7XHJcbiAgICAgICAgdmFyIHZpZXdzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSh2aWV3Q291bnQpO1xyXG4gICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgdGV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50SWR4ID0gMDtcclxuICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudEluZGljZXNCeVZpZXdJbmRleCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodmlld0NvdW50KTtcclxuICAgICAgICBmb3IgKHZhciB2aWV3T2Zmc2V0ID0gMDsgdmlld09mZnNldCA8IHZpZXdDb3VudDsgdmlld09mZnNldCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50SW5kZXggPSBjb250YWluZXJFbGVtZW50SW5kaWNlc0J5Vmlld0luZGV4W3ZpZXdPZmZzZXRdO1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudEluamVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChjb250YWluZXJFbGVtZW50SW5kZXgpID8gZWxlbWVudEluamVjdG9yc1tjb250YWluZXJFbGVtZW50SW5kZXhdIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFZpZXcgPSBsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lckVsZW1lbnRJbmplY3RvcikgPyBwcmVCdWlsdE9iamVjdHNbY29udGFpbmVyRWxlbWVudEluZGV4XS52aWV3IDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIHByb3RvVmlldyA9IGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyRWxlbWVudEluZGV4KSA/XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRWaWV3LnByb3RvLmVsZW1lbnRCaW5kZXJzW2NvbnRhaW5lckVsZW1lbnRJbmRleCAtIHBhcmVudFZpZXcuZWxlbWVudE9mZnNldF1cclxuICAgICAgICAgICAgICAgICAgICAubmVzdGVkUHJvdG9WaWV3IDpcclxuICAgICAgICAgICAgICAgIG1lcmdlZFBhcmVudFZpZXdQcm90bztcclxuICAgICAgICAgICAgdmFyIHJlbmRlckZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHZpZXdPZmZzZXQgPT09IDAgfHwgcHJvdG9WaWV3LnR5cGUgPT09IHZpZXdNb2R1bGUuVmlld1R5cGUuRU1CRURERUQpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlckZyYWdtZW50ID0gcmVuZGVyRnJhZ21lbnRzW2ZyYWdtZW50SWR4KytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmlldyA9IG5ldyB2aWV3TW9kdWxlLkFwcFZpZXcocmVuZGVyZXIsIHByb3RvVmlldywgdmlld09mZnNldCwgZWxlbWVudE9mZnNldCwgdGV4dE9mZnNldCwgcHJvdG9WaWV3LnByb3RvTG9jYWxzLCByZW5kZXJWaWV3LCByZW5kZXJGcmFnbWVudCwgY29udGFpbmVyRWxlbWVudEluamVjdG9yKTtcclxuICAgICAgICAgICAgdmlld3Nbdmlld09mZnNldF0gPSBjdXJyZW50VmlldztcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udGFpbmVyRWxlbWVudEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgcHJlQnVpbHRPYmplY3RzW2NvbnRhaW5lckVsZW1lbnRJbmRleF0ubmVzdGVkVmlldyA9IGN1cnJlbnRWaWV3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudEluamVjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbmVzdGVkVmlld09mZnNldCA9IHZpZXdPZmZzZXQgKyAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiaW5kZXJJZHggPSAwOyBiaW5kZXJJZHggPCBwcm90b1ZpZXcuZWxlbWVudEJpbmRlcnMubGVuZ3RoOyBiaW5kZXJJZHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRlciA9IHByb3RvVmlldy5lbGVtZW50QmluZGVyc1tiaW5kZXJJZHhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gZWxlbWVudE9mZnNldCArIGJpbmRlcklkeDtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZGVyLm5lc3RlZFByb3RvVmlldykgJiYgYmluZGVyLm5lc3RlZFByb3RvVmlldy5pc01lcmdhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudEluZGljZXNCeVZpZXdJbmRleFtuZXN0ZWRWaWV3T2Zmc2V0XSA9IGJvdW5kRWxlbWVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdPZmZzZXQgKz0gYmluZGVyLm5lc3RlZFByb3RvVmlldy5tZXJnZUluZm8udmlld0NvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudEluamVjdG9ycyBhbmQgcm9vdEVsZW1lbnRJbmplY3RvcnNcclxuICAgICAgICAgICAgICAgIHZhciBwcm90b0VsZW1lbnRJbmplY3RvciA9IGJpbmRlci5wcm90b0VsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3RvRWxlbWVudEluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3RvRWxlbWVudEluamVjdG9yLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRJbmplY3RvciA9IGVsZW1lbnRJbmplY3RvcnNbZWxlbWVudE9mZnNldCArIHByb3RvRWxlbWVudEluamVjdG9yLnBhcmVudC5pbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJbmplY3RvciA9IHByb3RvRWxlbWVudEluamVjdG9yLmluc3RhbnRpYXRlKHBhcmVudEVsZW1lbnRJbmplY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5qZWN0b3IgPSBwcm90b0VsZW1lbnRJbmplY3Rvci5pbnN0YW50aWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnRJbmplY3RvcnMucHVzaChlbGVtZW50SW5qZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnRJbmplY3RvcnNbYm91bmRFbGVtZW50SW5kZXhdID0gZWxlbWVudEluamVjdG9yO1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudFJlZnNcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9IG5ldyBlbGVtZW50X3JlZl8xLkVsZW1lbnRSZWZfKGN1cnJlbnRWaWV3LnJlZiwgYm91bmRFbGVtZW50SW5kZXgsIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRSZWZzW2VsLmJvdW5kRWxlbWVudEluZGV4XSA9IGVsO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlQnVpbHRPYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50SW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUmVmID0gbGFuZ18xLmlzUHJlc2VudChiaW5kZXIubmVzdGVkUHJvdG9WaWV3KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXIubmVzdGVkUHJvdG9WaWV3LnR5cGUgPT09IHZpZXdNb2R1bGUuVmlld1R5cGUuRU1CRURERUQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgdGVtcGxhdGVfcmVmXzEuVGVtcGxhdGVSZWZfKGVsKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlQnVpbHRPYmplY3RzW2JvdW5kRWxlbWVudEluZGV4XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBlbGkuUHJlQnVpbHRPYmplY3RzKHZpZXdNYW5hZ2VyLCBjdXJyZW50VmlldywgZWwsIHRlbXBsYXRlUmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50Vmlldy5pbml0KHByb3RvVmlldy5jaGFuZ2VEZXRlY3RvckZhY3RvcnkoY3VycmVudFZpZXcpLCBlbGVtZW50SW5qZWN0b3JzLCByb290RWxlbWVudEluamVjdG9ycywgcHJlQnVpbHRPYmplY3RzLCB2aWV3cywgZWxlbWVudFJlZnMsIHZpZXdDb250YWluZXJzKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50VmlldykgJiYgcHJvdG9WaWV3LnR5cGUgPT09IHZpZXdNb2R1bGUuVmlld1R5cGUuQ09NUE9ORU5UKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRWaWV3LmNoYW5nZURldGVjdG9yLmFkZFNoYWRvd0RvbUNoaWxkKGN1cnJlbnRWaWV3LmNoYW5nZURldGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtZW50T2Zmc2V0ICs9IHByb3RvVmlldy5lbGVtZW50QmluZGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gcHJvdG9WaWV3LnRleHRCaW5kaW5nQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3c1swXTtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5oeWRyYXRlUm9vdEhvc3RWaWV3ID0gZnVuY3Rpb24gKGhvc3RWaWV3LCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMuX2h5ZHJhdGVWaWV3KGhvc3RWaWV3LCBpbmplY3RvciwgbnVsbCwgbmV3IE9iamVjdCgpLCBudWxsKTtcclxuICAgIH07XHJcbiAgICAvLyBNaXNub21lcjogdGhpcyBtZXRob2QgaXMgYXR0YWNoaW5nIG5leHQgdG8gdGhlIHZpZXcgY29udGFpbmVyLlxyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuYXR0YWNoVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBjb250ZXh0VmlldywgY29udGV4dEJvdW5kRWxlbWVudEluZGV4LCBpbmRleCwgdmlldykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb250ZXh0VmlldykpIHtcclxuICAgICAgICAgICAgY29udGV4dFZpZXcgPSBwYXJlbnRWaWV3O1xyXG4gICAgICAgICAgICBjb250ZXh0Qm91bmRFbGVtZW50SW5kZXggPSBib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50Vmlldy5jaGFuZ2VEZXRlY3Rvci5hZGRDaGlsZCh2aWV3LmNoYW5nZURldGVjdG9yKTtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHBhcmVudFZpZXcudmlld0NvbnRhaW5lcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3Q29udGFpbmVyKSkge1xyXG4gICAgICAgICAgICB2aWV3Q29udGFpbmVyID0gbmV3IHZpZXdNb2R1bGUuQXBwVmlld0NvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICBwYXJlbnRWaWV3LnZpZXdDb250YWluZXJzW2JvdW5kRWxlbWVudEluZGV4XSA9IHZpZXdDb250YWluZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pbnNlcnQodmlld0NvbnRhaW5lci52aWV3cywgaW5kZXgsIHZpZXcpO1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3IgPSBjb250ZXh0Vmlldy5lbGVtZW50SW5qZWN0b3JzW2NvbnRleHRCb3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHZpZXcucm9vdEVsZW1lbnRJbmplY3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudEluamVjdG9yLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcucm9vdEVsZW1lbnRJbmplY3RvcnNbaV0ubGluayhlbGVtZW50SW5qZWN0b3IucGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50SW5qZWN0b3IudHJhdmVyc2VBbmRTZXRRdWVyaWVzQXNEaXJ0eSgpO1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLmRldGFjaFZpZXdJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRWaWV3LCBib3VuZEVsZW1lbnRJbmRleCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHBhcmVudFZpZXcudmlld0NvbnRhaW5lcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdmlld0NvbnRhaW5lci52aWV3c1tpbmRleF07XHJcbiAgICAgICAgcGFyZW50Vmlldy5lbGVtZW50SW5qZWN0b3JzW2JvdW5kRWxlbWVudEluZGV4XS50cmF2ZXJzZUFuZFNldFF1ZXJpZXNBc0RpcnR5KCk7XHJcbiAgICAgICAgdmlldy5jaGFuZ2VEZXRlY3Rvci5yZW1vdmUoKTtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlQXQodmlld0NvbnRhaW5lci52aWV3cywgaW5kZXgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5yb290RWxlbWVudEluamVjdG9ycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5qID0gdmlldy5yb290RWxlbWVudEluamVjdG9yc1tpXTtcclxuICAgICAgICAgICAgaW5qLnVubGluaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5oeWRyYXRlVmlld0luQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudFZpZXcsIGJvdW5kRWxlbWVudEluZGV4LCBjb250ZXh0VmlldywgY29udGV4dEJvdW5kRWxlbWVudEluZGV4LCBpbmRleCwgaW1wZXJhdGl2ZWx5Q3JlYXRlZFByb3ZpZGVycykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb250ZXh0VmlldykpIHtcclxuICAgICAgICAgICAgY29udGV4dFZpZXcgPSBwYXJlbnRWaWV3O1xyXG4gICAgICAgICAgICBjb250ZXh0Qm91bmRFbGVtZW50SW5kZXggPSBib3VuZEVsZW1lbnRJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBwYXJlbnRWaWV3LnZpZXdDb250YWluZXJzW2JvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdDb250YWluZXIudmlld3NbaW5kZXhdO1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5qZWN0b3IgPSBjb250ZXh0Vmlldy5lbGVtZW50SW5qZWN0b3JzW2NvbnRleHRCb3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIGluamVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChpbXBlcmF0aXZlbHlDcmVhdGVkUHJvdmlkZXJzKSA/XHJcbiAgICAgICAgICAgIGRpXzEuSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKGltcGVyYXRpdmVseUNyZWF0ZWRQcm92aWRlcnMpIDpcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB0aGlzLl9oeWRyYXRlVmlldyh2aWV3LCBpbmplY3RvciwgZWxlbWVudEluamVjdG9yLmdldEhvc3QoKSwgY29udGV4dFZpZXcuY29udGV4dCwgY29udGV4dFZpZXcubG9jYWxzKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5faHlkcmF0ZVZpZXcgPSBmdW5jdGlvbiAoaW5pdFZpZXcsIGltcGVyYXRpdmVseUNyZWF0ZWRJbmplY3RvciwgaG9zdEVsZW1lbnRJbmplY3RvciwgY29udGV4dCwgcGFyZW50TG9jYWxzKSB7XHJcbiAgICAgICAgdmFyIHZpZXdJZHggPSBpbml0Vmlldy52aWV3T2Zmc2V0O1xyXG4gICAgICAgIHZhciBlbmRWaWV3T2Zmc2V0ID0gdmlld0lkeCArIGluaXRWaWV3LnByb3RvLm1lcmdlSW5mby52aWV3Q291bnQgLSAxO1xyXG4gICAgICAgIHdoaWxlICh2aWV3SWR4IDw9IGVuZFZpZXdPZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJWaWV3ID0gaW5pdFZpZXcudmlld3Nbdmlld0lkeF07XHJcbiAgICAgICAgICAgIHZhciBjdXJyUHJvdG9WaWV3ID0gY3VyclZpZXcucHJvdG87XHJcbiAgICAgICAgICAgIGlmIChjdXJyVmlldyAhPT0gaW5pdFZpZXcgJiYgY3VyclZpZXcucHJvdG8udHlwZSA9PT0gdmlld01vZHVsZS5WaWV3VHlwZS5FTUJFRERFRCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaHlkcmF0ZSBjb21wb25lbnRzIG9mIGVtYmVkZGVkIGZyYWdtZW50IHZpZXdzLlxyXG4gICAgICAgICAgICAgICAgdmlld0lkeCArPSBjdXJyVmlldy5wcm90by5tZXJnZUluZm8udmlld0NvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJWaWV3ICE9PSBpbml0Vmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh5ZHJhdGUgYSBuZXN0ZWQgY29tcG9uZW50IHZpZXdcclxuICAgICAgICAgICAgICAgICAgICBpbXBlcmF0aXZlbHlDcmVhdGVkSW5qZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudExvY2FscyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRJbmplY3RvciA9IGN1cnJWaWV3LmNvbnRhaW5lckVsZW1lbnRJbmplY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gaG9zdEVsZW1lbnRJbmplY3Rvci5nZXRDb21wb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJWaWV3LmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgY3VyclZpZXcubG9jYWxzLnBhcmVudCA9IHBhcmVudExvY2FscztcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kZXJzID0gY3VyclByb3RvVmlldy5lbGVtZW50QmluZGVycztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGJpbmRlcklkeCA9IDA7IGJpbmRlcklkeCA8IGJpbmRlcnMubGVuZ3RoOyBiaW5kZXJJZHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZEVsZW1lbnRJbmRleCA9IGJpbmRlcklkeCArIGN1cnJWaWV3LmVsZW1lbnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmplY3RvciA9IGluaXRWaWV3LmVsZW1lbnRJbmplY3RvcnNbYm91bmRFbGVtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnRJbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEluamVjdG9yLmh5ZHJhdGUoaW1wZXJhdGl2ZWx5Q3JlYXRlZEluamVjdG9yLCBob3N0RWxlbWVudEluamVjdG9yLCBjdXJyVmlldy5wcmVCdWlsdE9iamVjdHNbYm91bmRFbGVtZW50SW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdWxhdGVWaWV3TG9jYWxzKGN1cnJWaWV3LCBlbGVtZW50SW5qZWN0b3IsIGJvdW5kRWxlbWVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBFdmVudEVtaXR0ZXJzKGN1cnJWaWV3LCBlbGVtZW50SW5qZWN0b3IsIGJvdW5kRWxlbWVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGlwZXMgPSBsYW5nXzEuaXNQcmVzZW50KGhvc3RFbGVtZW50SW5qZWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICBuZXcgcGlwZXNfMS5QaXBlcyhjdXJyVmlldy5wcm90by5waXBlcywgaG9zdEVsZW1lbnRJbmplY3Rvci5nZXRJbmplY3RvcigpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgICAgIGN1cnJWaWV3LmNoYW5nZURldGVjdG9yLmh5ZHJhdGUoY3VyclZpZXcuY29udGV4dCwgY3VyclZpZXcubG9jYWxzLCBjdXJyVmlldywgcGlwZXMpO1xyXG4gICAgICAgICAgICAgICAgdmlld0lkeCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFwcFZpZXdNYW5hZ2VyVXRpbHMucHJvdG90eXBlLl9wb3B1bGF0ZVZpZXdMb2NhbHMgPSBmdW5jdGlvbiAodmlldywgZWxlbWVudEluamVjdG9yLCBib3VuZEVsZW1lbnRJZHgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50SW5qZWN0b3IuZ2V0RGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncygpKSkge1xyXG4gICAgICAgICAgICBlbGVtZW50SW5qZWN0b3IuZ2V0RGlyZWN0aXZlVmFyaWFibGVCaW5kaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZUluZGV4LCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoZGlyZWN0aXZlSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5sb2NhbHMuc2V0KG5hbWUsIHZpZXcuZWxlbWVudFJlZnNbYm91bmRFbGVtZW50SWR4XS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcubG9jYWxzLnNldChuYW1lLCBlbGVtZW50SW5qZWN0b3IuZ2V0RGlyZWN0aXZlQXRJbmRleChkaXJlY3RpdmVJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscy5wcm90b3R5cGUuX3NldFVwRXZlbnRFbWl0dGVycyA9IGZ1bmN0aW9uICh2aWV3LCBlbGVtZW50SW5qZWN0b3IsIGJvdW5kRWxlbWVudEluZGV4KSB7XHJcbiAgICAgICAgdmFyIGVtaXR0ZXJzID0gZWxlbWVudEluamVjdG9yLmdldEV2ZW50RW1pdHRlckFjY2Vzc29ycygpO1xyXG4gICAgICAgIGZvciAodmFyIGRpcmVjdGl2ZUluZGV4ID0gMDsgZGlyZWN0aXZlSW5kZXggPCBlbWl0dGVycy5sZW5ndGg7ICsrZGlyZWN0aXZlSW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUVtaXR0ZXJzID0gZW1pdHRlcnNbZGlyZWN0aXZlSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gZWxlbWVudEluamVjdG9yLmdldERpcmVjdGl2ZUF0SW5kZXgoZGlyZWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudEluZGV4ID0gMDsgZXZlbnRJbmRleCA8IGRpcmVjdGl2ZUVtaXR0ZXJzLmxlbmd0aDsgKytldmVudEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRFbWl0dGVyQWNjZXNzb3IgPSBkaXJlY3RpdmVFbWl0dGVyc1tldmVudEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlckFjY2Vzc29yLnN1YnNjcmliZSh2aWV3LCBib3VuZEVsZW1lbnRJbmRleCwgZGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcHBWaWV3TWFuYWdlclV0aWxzLnByb3RvdHlwZS5kZWh5ZHJhdGVWaWV3ID0gZnVuY3Rpb24gKGluaXRWaWV3KSB7XHJcbiAgICAgICAgdmFyIGVuZFZpZXdPZmZzZXQgPSBpbml0Vmlldy52aWV3T2Zmc2V0ICsgaW5pdFZpZXcucHJvdG8ubWVyZ2VJbmZvLnZpZXdDb3VudCAtIDE7XHJcbiAgICAgICAgZm9yICh2YXIgdmlld0lkeCA9IGluaXRWaWV3LnZpZXdPZmZzZXQ7IHZpZXdJZHggPD0gZW5kVmlld09mZnNldDsgdmlld0lkeCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyVmlldyA9IGluaXRWaWV3LnZpZXdzW3ZpZXdJZHhdO1xyXG4gICAgICAgICAgICBpZiAoY3VyclZpZXcuaHlkcmF0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY3VyclZpZXcubG9jYWxzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJWaWV3LmxvY2Fscy5jbGVhclZhbHVlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VyclZpZXcuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjdXJyVmlldy5jaGFuZ2VEZXRlY3Rvci5kZWh5ZHJhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kZXJzID0gY3VyclZpZXcucHJvdG8uZWxlbWVudEJpbmRlcnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaW5kZXJJZHggPSAwOyBiaW5kZXJJZHggPCBiaW5kZXJzLmxlbmd0aDsgYmluZGVySWR4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxpID0gaW5pdFZpZXcuZWxlbWVudEluamVjdG9yc1tjdXJyVmlldy5lbGVtZW50T2Zmc2V0ICsgYmluZGVySWR4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsaS5kZWh5ZHJhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXBwVmlld01hbmFnZXJVdGlscyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgQXBwVmlld01hbmFnZXJVdGlscyk7XHJcbiAgICByZXR1cm4gQXBwVmlld01hbmFnZXJVdGlscztcclxufSkoKTtcclxuZXhwb3J0cy5BcHBWaWV3TWFuYWdlclV0aWxzID0gQXBwVmlld01hbmFnZXJVdGlscztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19tYW5hZ2VyX3V0aWxzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG5leHBvcnRzLkFQUF9WSUVXX1BPT0xfQ0FQQUNJVFkgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5PcGFxdWVUb2tlbignQXBwVmlld1Bvb2wudmlld1Bvb2xDYXBhY2l0eScpKTtcclxudmFyIEFwcFZpZXdQb29sID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcFZpZXdQb29sKHBvb2xDYXBhY2l0eVBlclByb3RvVmlldykge1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9wb29sZWRWaWV3c1BlclByb3RvVmlldyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fcG9vbENhcGFjaXR5UGVyUHJvdG9WaWV3ID0gcG9vbENhcGFjaXR5UGVyUHJvdG9WaWV3O1xyXG4gICAgfVxyXG4gICAgQXBwVmlld1Bvb2wucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAocHJvdG9WaWV3KSB7XHJcbiAgICAgICAgdmFyIHBvb2xlZFZpZXdzID0gdGhpcy5fcG9vbGVkVmlld3NQZXJQcm90b1ZpZXcuZ2V0KHByb3RvVmlldyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocG9vbGVkVmlld3MpICYmIHBvb2xlZFZpZXdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvb2xlZFZpZXdzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBBcHBWaWV3UG9vbC5wcm90b3R5cGUucmV0dXJuVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmFyIHByb3RvVmlldyA9IHZpZXcucHJvdG87XHJcbiAgICAgICAgdmFyIHBvb2xlZFZpZXdzID0gdGhpcy5fcG9vbGVkVmlld3NQZXJQcm90b1ZpZXcuZ2V0KHByb3RvVmlldyk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBvb2xlZFZpZXdzKSkge1xyXG4gICAgICAgICAgICBwb29sZWRWaWV3cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9wb29sZWRWaWV3c1BlclByb3RvVmlldy5zZXQocHJvdG9WaWV3LCBwb29sZWRWaWV3cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXZlUmVtYWluaW5nQ2FwYWNpdHkgPSBwb29sZWRWaWV3cy5sZW5ndGggPCB0aGlzLl9wb29sQ2FwYWNpdHlQZXJQcm90b1ZpZXc7XHJcbiAgICAgICAgaWYgKGhhdmVSZW1haW5pbmdDYXBhY2l0eSkge1xyXG4gICAgICAgICAgICBwb29sZWRWaWV3cy5wdXNoKHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGF2ZVJlbWFpbmluZ0NhcGFjaXR5O1xyXG4gICAgfTtcclxuICAgIEFwcFZpZXdQb29sID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19wYXJhbSgwLCBkaV8xLkluamVjdChleHBvcnRzLkFQUF9WSUVXX1BPT0xfQ0FQQUNJVFkpKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIEFwcFZpZXdQb29sKTtcclxuICAgIHJldHVybiBBcHBWaWV3UG9vbDtcclxufSkoKTtcclxuZXhwb3J0cy5BcHBWaWV3UG9vbCA9IEFwcFZpZXdQb29sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3X3Bvb2wuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHByaXZhY3kgaW4gRGFydCBhcyB3ZSBkb24ndCBoYXZlIGxpYnJhcnkgcGFydHNcclxuZnVuY3Rpb24gaW50ZXJuYWxWaWV3KHZpZXdSZWYpIHtcclxuICAgIHJldHVybiB2aWV3UmVmLl92aWV3O1xyXG59XHJcbmV4cG9ydHMuaW50ZXJuYWxWaWV3ID0gaW50ZXJuYWxWaWV3O1xyXG4vLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgcHJpdmFjeSBpbiBEYXJ0IGFzIHdlIGRvbid0IGhhdmUgbGlicmFyeSBwYXJ0c1xyXG5mdW5jdGlvbiBpbnRlcm5hbFByb3RvVmlldyhwcm90b1ZpZXdSZWYpIHtcclxuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHByb3RvVmlld1JlZikgPyBwcm90b1ZpZXdSZWYuX3Byb3RvVmlldyA6IG51bGw7XHJcbn1cclxuZXhwb3J0cy5pbnRlcm5hbFByb3RvVmlldyA9IGludGVybmFsUHJvdG9WaWV3O1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBBbmd1bGFyIFZpZXcuXHJcbiAqXHJcbiAqIDwhLS0gVE9ETzogbW92ZSB0aGUgbmV4dCB0d28gcGFyYWdyYXBocyB0byB0aGUgZGV2IGd1aWRlIC0tPlxyXG4gKiBBIFZpZXcgaXMgYSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9jayBvZiB0aGUgYXBwbGljYXRpb24gVUkuIEl0IGlzIHRoZSBzbWFsbGVzdCBncm91cGluZyBvZlxyXG4gKiBFbGVtZW50cyB3aGljaCBhcmUgY3JlYXRlZCBhbmQgZGVzdHJveWVkIHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGVsZW1lbnRzIGluIGEgVmlldyBjYW4gY2hhbmdlLCBidXQgdGhlIHN0cnVjdHVyZSAobnVtYmVyIGFuZCBvcmRlcikgb2YgZWxlbWVudHMgaW5cclxuICogYSBWaWV3IGNhbm5vdC4gQ2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvZiBFbGVtZW50cyBjYW4gb25seSBiZSBkb25lIGJ5IGluc2VydGluZywgbW92aW5nIG9yXHJcbiAqIHJlbW92aW5nIG5lc3RlZCBWaWV3cyB2aWEgYSB7QGxpbmsgVmlld0NvbnRhaW5lcn0uIEVhY2ggVmlldyBjYW4gY29udGFpbiBtYW55IFZpZXcgQ29udGFpbmVycy5cclxuICogPCEtLSAvVE9ETyAtLT5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBHaXZlbiB0aGlzIHRlbXBsYXRlLi4uXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICpuZy1mb3I9XCJ2YXIgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIC4uLiB3ZSBoYXZlIHR3byB7QGxpbmsgUHJvdG9WaWV3UmVmfXM6XHJcbiAqXHJcbiAqIE91dGVyIHtAbGluayBQcm90b1ZpZXdSZWZ9OlxyXG4gKiBgYGBcclxuICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSBuZy1mb3IgdmFyLWl0ZW0gW25nLWZvci1vZl09XCJpdGVtc1wiPjwvdGVtcGxhdGU+XHJcbiAqIDwvdWw+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBJbm5lciB7QGxpbmsgUHJvdG9WaWV3UmVmfTpcclxuICogYGBgXHJcbiAqICAgPGxpPnt7aXRlbX19PC9saT5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSB7QGxpbmsgUHJvdG9WaWV3UmVmfXMuXHJcbiAqXHJcbiAqIFRoZSBvdXRlci9pbm5lciB7QGxpbmsgUHJvdG9WaWV3UmVmfXMgYXJlIHRoZW4gYXNzZW1ibGVkIGludG8gdmlld3MgbGlrZSBzbzpcclxuICpcclxuICogYGBgXHJcbiAqIDwhLS0gVmlld1JlZjogb3V0ZXItMCAtLT5cclxuICogQ291bnQ6IDJcclxuICogPHVsPlxyXG4gKiAgIDx0ZW1wbGF0ZSB2aWV3LWNvbnRhaW5lci1yZWY+PC90ZW1wbGF0ZT5cclxuICogICA8IS0tIFZpZXdSZWY6IGlubmVyLTEgLS0+PGxpPmZpcnN0PC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0xIC0tPlxyXG4gKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMiAtLT48bGk+c2Vjb25kPC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0yIC0tPlxyXG4gKiA8L3VsPlxyXG4gKiA8IS0tIC9WaWV3UmVmOiBvdXRlci0wIC0tPlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBWaWV3UmVmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdSZWYoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZi5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gVmlld1JlZjtcclxufSkoKTtcclxuZXhwb3J0cy5WaWV3UmVmID0gVmlld1JlZjtcclxudmFyIFZpZXdSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWaWV3UmVmXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpZXdSZWZfKF92aWV3KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicmVuZGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYFJlbmRlclZpZXdSZWZgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LnJlbmRlcjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcInJlbmRlckZyYWdtZW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYFJlbmRlckZyYWdtZW50UmVmYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5yZW5kZXJGcmFnbWVudDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYENoYW5nZURldGVjdG9yUmVmYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gdGhpcy5fdmlldy5jaGFuZ2VEZXRlY3Rvci5yZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVmlld1JlZl8ucHJvdG90eXBlLnNldExvY2FsID0gZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHsgdGhpcy5fdmlldy5zZXRMb2NhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKTsgfTtcclxuICAgIHJldHVybiBWaWV3UmVmXztcclxufSkoVmlld1JlZik7XHJcbmV4cG9ydHMuVmlld1JlZl8gPSBWaWV3UmVmXztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBQcm90b1ZpZXcuXHJcbiAqXHJcbiAqIEEgUHJvdG9WaWV3IGlzIGEgcHJvdG90eXBpY2FsIHtAbGluayBWaWV3UmVmIFZpZXd9IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBUZW1wbGF0ZSBjb21waWxhdGlvbiBhbmRcclxuICogaXMgdXNlZCBieSBBbmd1bGFyIHRvIGVmZmljaWVudGx5IGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIFZpZXcgYmFzZWQgb24gdGhlIGNvbXBpbGVkIFRlbXBsYXRlLlxyXG4gKlxyXG4gKiBNb3N0IFByb3RvVmlld3MgYXJlIGNyZWF0ZWQgYW5kIHVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyIGFuZCB5b3UgZG9uJ3QgbmVlZCB0byBrbm93IGFib3V0IHRoZW0sXHJcbiAqIGV4Y2VwdCBpbiBhZHZhbmNlZCB1c2UtY2FzZXMgd2hlcmUgeW91IGNvbXBpbGUgY29tcG9uZW50cyB5b3Vyc2VsZiB2aWEgdGhlIGxvdy1sZXZlbFxyXG4gKiB7QGxpbmsgQ29tcGlsZXIjY29tcGlsZUluSG9zdH0gQVBJLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEdpdmVuIHRoaXMgdGVtcGxhdGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICpuZy1mb3I9XCJ2YXIgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19PC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEFuZ3VsYXIgZGVzdWdhcnMgYW5kIGNvbXBpbGVzIHRoZSB0ZW1wbGF0ZSBpbnRvIHR3byBQcm90b1ZpZXdzOlxyXG4gKlxyXG4gKiBPdXRlciBQcm90b1ZpZXc6XHJcbiAqIGBgYFxyXG4gKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxyXG4gKiA8dWw+XHJcbiAqICAgPHRlbXBsYXRlIG5nLWZvciB2YXItaXRlbSBbbmctZm9yLW9mXT1cIml0ZW1zXCI+PC90ZW1wbGF0ZT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIElubmVyIFByb3RvVmlldzpcclxuICogYGBgXHJcbiAqICAgPGxpPnt7aXRlbX19PC9saT5cclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSBQcm90b1ZpZXdzLlxyXG4gKi9cclxudmFyIFByb3RvVmlld1JlZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm90b1ZpZXdSZWYoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvdG9WaWV3UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlByb3RvVmlld1JlZiA9IFByb3RvVmlld1JlZjtcclxudmFyIFByb3RvVmlld1JlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByb3RvVmlld1JlZl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcm90b1ZpZXdSZWZfKF9wcm90b1ZpZXcpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wcm90b1ZpZXcgPSBfcHJvdG9WaWV3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb3RvVmlld1JlZl87XHJcbn0pKFByb3RvVmlld1JlZik7XHJcbmV4cG9ydHMuUHJvdG9WaWV3UmVmXyA9IFByb3RvVmlld1JlZl87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfcmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciB2aWV3XzEgPSByZXF1aXJlKCcuLi9tZXRhZGF0YS92aWV3Jyk7XHJcbnZhciBkaXJlY3RpdmVzXzEgPSByZXF1aXJlKCcuLi9tZXRhZGF0YS9kaXJlY3RpdmVzJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9yZWZsZWN0aW9uL3JlZmxlY3Rpb24nKTtcclxudmFyIFZpZXdSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3UmVzb2x2ZXIoKSB7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgIH1cclxuICAgIFZpZXdSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2NhY2hlLmdldChjb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3KSkge1xyXG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5fcmVzb2x2ZShjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoY29tcG9uZW50LCB2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgVmlld1Jlc29sdmVyLnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgY29tcE1ldGE7XHJcbiAgICAgICAgdmFyIHZpZXdNZXRhO1xyXG4gICAgICAgIHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuYW5ub3RhdGlvbnMoY29tcG9uZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIGlmIChtIGluc3RhbmNlb2Ygdmlld18xLlZpZXdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmlld01ldGEgPSBtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtIGluc3RhbmNlb2YgZGlyZWN0aXZlc18xLkNvbXBvbmVudE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wTWV0YSA9IG07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBNZXRhLnRlbXBsYXRlKSAmJiBsYW5nXzEuaXNCbGFuayhjb21wTWV0YS50ZW1wbGF0ZVVybCkgJiYgbGFuZ18xLmlzQmxhbmsodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb21wb25lbnQgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnQpICsgXCInIG11c3QgaGF2ZSBlaXRoZXIgJ3RlbXBsYXRlJywgJ3RlbXBsYXRlVXJsJywgb3IgJ0BWaWV3JyBzZXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEudGVtcGxhdGUpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJ0ZW1wbGF0ZVwiLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEudGVtcGxhdGVVcmwpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJ0ZW1wbGF0ZVVybFwiLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEuZGlyZWN0aXZlcykgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudChcImRpcmVjdGl2ZXNcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLnBpcGVzKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwicGlwZXNcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLmVuY2Fwc3VsYXRpb24pICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJlbmNhcHN1bGF0aW9uXCIsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS5zdHlsZXMpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJzdHlsZXNcIiwgY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLnN0eWxlVXJscykgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudChcInN0eWxlVXJsc1wiLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlld01ldGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZpZXdfMS5WaWV3TWV0YWRhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBjb21wTWV0YS50ZW1wbGF0ZVVybCxcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogY29tcE1ldGEudGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogY29tcE1ldGEuZGlyZWN0aXZlcyxcclxuICAgICAgICAgICAgICAgICAgICBwaXBlczogY29tcE1ldGEucGlwZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogY29tcE1ldGEuZW5jYXBzdWxhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGNvbXBNZXRhLnN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGNvbXBNZXRhLnN0eWxlVXJsc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3TWV0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vIFZpZXcgZGVjb3JhdG9yIGZvdW5kIG9uIGNvbXBvbmVudCAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGNvbXBvbmVudCkgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlld01ldGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgVmlld1Jlc29sdmVyLnByb3RvdHlwZS5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50ICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50KSArIFwiJyBjYW5ub3QgaGF2ZSBib3RoICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBhbmQgJ0BWaWV3JyBzZXQgYXQgdGhlIHNhbWUgdGltZVxcXCJcIik7XHJcbiAgICB9O1xyXG4gICAgVmlld1Jlc29sdmVyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBWaWV3UmVzb2x2ZXIpO1xyXG4gICAgcmV0dXJuIFZpZXdSZXNvbHZlcjtcclxufSkoKTtcclxuZXhwb3J0cy5WaWV3UmVzb2x2ZXIgPSBWaWV3UmVzb2x2ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfcmVzb2x2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnOy8qKlxyXG4gKiBUaGlzIGluZGlyZWN0aW9uIGlzIG5lZWRlZCB0byBmcmVlIHVwIENvbXBvbmVudCwgZXRjIHN5bWJvbHMgaW4gdGhlIHB1YmxpYyBBUElcclxuICogdG8gYmUgdXNlZCBieSB0aGUgZGVjb3JhdG9yIHZlcnNpb25zIG9mIHRoZXNlIGFubm90YXRpb25zLlxyXG4gKi9cclxudmFyIGRpXzEgPSByZXF1aXJlKCcuL21ldGFkYXRhL2RpJyk7XHJcbmV4cG9ydHMuUXVlcnlNZXRhZGF0YSA9IGRpXzEuUXVlcnlNZXRhZGF0YTtcclxuZXhwb3J0cy5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IGRpXzEuQ29udGVudENoaWxkcmVuTWV0YWRhdGE7XHJcbmV4cG9ydHMuQ29udGVudENoaWxkTWV0YWRhdGEgPSBkaV8xLkNvbnRlbnRDaGlsZE1ldGFkYXRhO1xyXG5leHBvcnRzLlZpZXdDaGlsZHJlbk1ldGFkYXRhID0gZGlfMS5WaWV3Q2hpbGRyZW5NZXRhZGF0YTtcclxuZXhwb3J0cy5WaWV3UXVlcnlNZXRhZGF0YSA9IGRpXzEuVmlld1F1ZXJ5TWV0YWRhdGE7XHJcbmV4cG9ydHMuVmlld0NoaWxkTWV0YWRhdGEgPSBkaV8xLlZpZXdDaGlsZE1ldGFkYXRhO1xyXG5leHBvcnRzLkF0dHJpYnV0ZU1ldGFkYXRhID0gZGlfMS5BdHRyaWJ1dGVNZXRhZGF0YTtcclxudmFyIGRpcmVjdGl2ZXNfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xyXG5leHBvcnRzLkNvbXBvbmVudE1ldGFkYXRhID0gZGlyZWN0aXZlc18xLkNvbXBvbmVudE1ldGFkYXRhO1xyXG5leHBvcnRzLkRpcmVjdGl2ZU1ldGFkYXRhID0gZGlyZWN0aXZlc18xLkRpcmVjdGl2ZU1ldGFkYXRhO1xyXG5leHBvcnRzLlBpcGVNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5QaXBlTWV0YWRhdGE7XHJcbmV4cG9ydHMuSW5wdXRNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5JbnB1dE1ldGFkYXRhO1xyXG5leHBvcnRzLk91dHB1dE1ldGFkYXRhID0gZGlyZWN0aXZlc18xLk91dHB1dE1ldGFkYXRhO1xyXG5leHBvcnRzLkhvc3RCaW5kaW5nTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSG9zdEJpbmRpbmdNZXRhZGF0YTtcclxuZXhwb3J0cy5Ib3N0TGlzdGVuZXJNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5Ib3N0TGlzdGVuZXJNZXRhZGF0YTtcclxudmFyIHZpZXdfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEvdmlldycpO1xyXG5leHBvcnRzLlZpZXdNZXRhZGF0YSA9IHZpZXdfMS5WaWV3TWV0YWRhdGE7XHJcbmV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gPSB2aWV3XzEuVmlld0VuY2Fwc3VsYXRpb247XHJcbnZhciBkaV8yID0gcmVxdWlyZSgnLi9tZXRhZGF0YS9kaScpO1xyXG52YXIgZGlyZWN0aXZlc18yID0gcmVxdWlyZSgnLi9tZXRhZGF0YS9kaXJlY3RpdmVzJyk7XHJcbnZhciB2aWV3XzIgPSByZXF1aXJlKCcuL21ldGFkYXRhL3ZpZXcnKTtcclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJy4vdXRpbC9kZWNvcmF0b3JzJyk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gQ29tcG9uZW50TWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBEZWNsYXJlIHJldXNhYmxlIFVJIGJ1aWxkaW5nIGJsb2NrcyBmb3IgYW4gYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIEVhY2ggQW5ndWxhciBjb21wb25lbnQgcmVxdWlyZXMgYSBzaW5nbGUgYEBDb21wb25lbnRgIGFuZCBhdCBsZWFzdCBvbmUgYEBWaWV3YCBhbm5vdGF0aW9uLiBUaGVcclxuICogYEBDb21wb25lbnRgXHJcbiAqIGFubm90YXRpb24gc3BlY2lmaWVzIHdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCBhbmQgd2hpY2ggcHJvcGVydGllcyBhbmQgaG9zdExpc3RlbmVycyBpdFxyXG4gKiBiaW5kcyB0by5cclxuICpcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIEFuZ3VsYXJcclxuICogLSBjcmVhdGVzIGEgc2hhZG93IERPTSBmb3IgdGhlIGNvbXBvbmVudC5cclxuICogLSBsb2FkcyB0aGUgc2VsZWN0ZWQgdGVtcGxhdGUgaW50byB0aGUgc2hhZG93IERPTS5cclxuICogLSBjcmVhdGVzIGFsbCB0aGUgaW5qZWN0YWJsZSBvYmplY3RzIGNvbmZpZ3VyZWQgd2l0aCBgcHJvdmlkZXJzYCBhbmQgYHZpZXdQcm92aWRlcnNgLlxyXG4gKlxyXG4gKiBBbGwgdGVtcGxhdGUgZXhwcmVzc2lvbnMgYW5kIHN0YXRlbWVudHMgYXJlIHRoZW4gZXZhbHVhdGVkIGFnYWluc3QgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICpcclxuICogRm9yIGRldGFpbHMgb24gdGhlIGBAVmlld2AgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBWaWV3TWV0YWRhdGF9LlxyXG4gKlxyXG4gKiAjIyBMaWZlY3ljbGUgaG9va3NcclxuICpcclxuICogV2hlbiB0aGUgY29tcG9uZW50IGNsYXNzIGltcGxlbWVudHMgc29tZSB7QGxpbmsgYW5ndWxhcjIvbGlmZWN5Y2xlX2hvb2tzfSB0aGUgY2FsbGJhY2tzIGFyZVxyXG4gKiBjYWxsZWQgYnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gYXQgZGVmaW5lZCBwb2ludHMgaW4gdGltZSBkdXJpbmcgdGhlIGxpZmUgb2YgdGhlIGNvbXBvbmVudC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdncmVldCcsXHJcbiAqICAgdGVtcGxhdGU6ICdIZWxsbyB7e25hbWV9fSEnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEdyZWV0IHtcclxuICogICBuYW1lOiBzdHJpbmc7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoKSB7XHJcbiAqICAgICB0aGlzLm5hbWUgPSAnV29ybGQnO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbmV4cG9ydHMuQ29tcG9uZW50ID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3IoZGlyZWN0aXZlc18yLkNvbXBvbmVudE1ldGFkYXRhLCBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuLlZpZXcgPSBleHBvcnRzLlZpZXc7IH0pO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIERpcmVjdGl2ZU1ldGFkYXRhLlxyXG4vKipcclxuICogRGlyZWN0aXZlcyBhbGxvdyB5b3UgdG8gYXR0YWNoIGJlaGF2aW9yIHRvIGVsZW1lbnRzIGluIHRoZSBET00uXHJcbiAqXHJcbiAqIHtAbGluayBEaXJlY3RpdmVNZXRhZGF0YX1zIHdpdGggYW4gZW1iZWRkZWQgdmlldyBhcmUgY2FsbGVkIHtAbGluayBDb21wb25lbnRNZXRhZGF0YX1zLlxyXG4gKlxyXG4gKiBBIGRpcmVjdGl2ZSBjb25zaXN0cyBvZiBhIHNpbmdsZSBkaXJlY3RpdmUgYW5ub3RhdGlvbiBhbmQgYSBjb250cm9sbGVyIGNsYXNzLiBXaGVuIHRoZVxyXG4gKiBkaXJlY3RpdmUncyBgc2VsZWN0b3JgIG1hdGNoZXNcclxuICogZWxlbWVudHMgaW4gdGhlIERPTSwgdGhlIGZvbGxvd2luZyBzdGVwcyBvY2N1cjpcclxuICpcclxuICogMS4gRm9yIGVhY2ggZGlyZWN0aXZlLCB0aGUgYEVsZW1lbnRJbmplY3RvcmAgYXR0ZW1wdHMgdG8gcmVzb2x2ZSB0aGUgZGlyZWN0aXZlJ3MgY29uc3RydWN0b3JcclxuICogYXJndW1lbnRzLlxyXG4gKiAyLiBBbmd1bGFyIGluc3RhbnRpYXRlcyBkaXJlY3RpdmVzIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCB1c2luZyBgRWxlbWVudEluamVjdG9yYCBpbiBhXHJcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLFxyXG4gKiAgICBhcyBkZWNsYXJlZCBpbiB0aGUgSFRNTC5cclxuICpcclxuICogIyMgVW5kZXJzdGFuZGluZyBIb3cgSW5qZWN0aW9uIFdvcmtzXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgb2YgaW5qZWN0aW9uIHJlc29sdXRpb24uXHJcbiAqIC0gKlByZS1leGlzdGluZyBJbmplY3RvcnMqOlxyXG4gKiAgIC0gVGhlIHRlcm1pbmFsIHtAbGluayBJbmplY3Rvcn0gY2Fubm90IHJlc29sdmUgZGVwZW5kZW5jaWVzLiBJdCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yIG9yLCBpZlxyXG4gKiB0aGUgZGVwZW5kZW5jeSB3YXNcclxuICogICAgIHNwZWNpZmllZCBhcyBgQE9wdGlvbmFsYCwgcmV0dXJucyBgbnVsbGAuXHJcbiAqICAgLSBUaGUgcGxhdGZvcm0gaW5qZWN0b3IgcmVzb2x2ZXMgYnJvd3NlciBzaW5nbGV0b24gcmVzb3VyY2VzLCBzdWNoIGFzOiBjb29raWVzLCB0aXRsZSxcclxuICogbG9jYXRpb24sIGFuZCBvdGhlcnMuXHJcbiAqIC0gKkNvbXBvbmVudCBJbmplY3RvcnMqOiBFYWNoIGNvbXBvbmVudCBpbnN0YW5jZSBoYXMgaXRzIG93biB7QGxpbmsgSW5qZWN0b3J9LCBhbmQgdGhleSBmb2xsb3dcclxuICogdGhlIHNhbWUgcGFyZW50LWNoaWxkIGhpZXJhcmNoeVxyXG4gKiAgICAgYXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZXMgaW4gdGhlIERPTS5cclxuICogLSAqRWxlbWVudCBJbmplY3RvcnMqOiBFYWNoIGNvbXBvbmVudCBpbnN0YW5jZSBoYXMgYSBTaGFkb3cgRE9NLiBXaXRoaW4gdGhlIFNoYWRvdyBET00gZWFjaFxyXG4gKiBlbGVtZW50IGhhcyBhbiBgRWxlbWVudEluamVjdG9yYFxyXG4gKiAgICAgd2hpY2ggZm9sbG93IHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHkgYXMgdGhlIERPTSBlbGVtZW50cyB0aGVtc2VsdmVzLlxyXG4gKlxyXG4gKiBXaGVuIGEgdGVtcGxhdGUgaXMgaW5zdGFudGlhdGVkLCBpdCBhbHNvIG11c3QgaW5zdGFudGlhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZGlyZWN0aXZlcyBpbiBhXHJcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLiBUaGVcclxuICogY3VycmVudCBgRWxlbWVudEluamVjdG9yYCByZXNvbHZlcyB0aGUgY29uc3RydWN0b3IgZGVwZW5kZW5jaWVzIGZvciBlYWNoIGRpcmVjdGl2ZS5cclxuICpcclxuICogQW5ndWxhciB0aGVuIHJlc29sdmVzIGRlcGVuZGVuY2llcyBhcyBmb2xsb3dzLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZVxyXG4gKiB7QGxpbmsgVmlld01ldGFkYXRhfTpcclxuICpcclxuICogMS4gRGVwZW5kZW5jaWVzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcclxuICogMi4gRGVwZW5kZW5jaWVzIG9uIGVsZW1lbnQgaW5qZWN0b3JzIGFuZCB0aGVpciBwYXJlbnRzIHVudGlsIGl0IGVuY291bnRlcnMgYSBTaGFkb3cgRE9NIGJvdW5kYXJ5XHJcbiAqIDMuIERlcGVuZGVuY2llcyBvbiBjb21wb25lbnQgaW5qZWN0b3JzIGFuZCB0aGVpciBwYXJlbnRzIHVudGlsIGl0IGVuY291bnRlcnMgdGhlIHJvb3QgY29tcG9uZW50XHJcbiAqIDQuIERlcGVuZGVuY2llcyBvbiBwcmUtZXhpc3RpbmcgaW5qZWN0b3JzXHJcbiAqXHJcbiAqXHJcbiAqIFRoZSBgRWxlbWVudEluamVjdG9yYCBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBvciBpdCBjYW5cclxuICogZGVsZWdhdGUgdG8gdGhlIHBhcmVudFxyXG4gKiBpbmplY3Rvci5cclxuICpcclxuICogVG8gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGRlY2xhcmUgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBhczpcclxuICogLSBgZGlyZWN0aXZlOkRpcmVjdGl2ZVR5cGVgOiBhIGRpcmVjdGl2ZSBvbiB0aGUgY3VycmVudCBlbGVtZW50IG9ubHlcclxuICogLSBgQEhvc3QoKSBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGFueSBkaXJlY3RpdmUgdGhhdCBtYXRjaGVzIHRoZSB0eXBlIGJldHdlZW4gdGhlIGN1cnJlbnRcclxuICogZWxlbWVudCBhbmQgdGhlXHJcbiAqICAgIFNoYWRvdyBET00gcm9vdC5cclxuICogLSBgQFF1ZXJ5KERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZFxyXG4gKiBkaXJlY3RpdmVzLlxyXG4gKiAtIGBAUXVlcnlEZXNjZW5kYW50cyhEaXJlY3RpdmVUeXBlKSBxdWVyeTpRdWVyeUxpc3Q8RGlyZWN0aXZlVHlwZT5gOiBBIGxpdmUgY29sbGVjdGlvbiBvZiBhbnlcclxuICogY2hpbGQgZGlyZWN0aXZlcy5cclxuICpcclxuICogVG8gaW5qZWN0IGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XHJcbiAqIC0gYGVsZW1lbnQ6IEVsZW1lbnRSZWZgIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byBsb2dpY2FsIGVsZW1lbnQgaW4gdGhlIHZpZXcuXHJcbiAqIC0gYHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWZgIHRvIGNvbnRyb2wgY2hpbGQgdGVtcGxhdGUgaW5zdGFudGlhdGlvbiwgZm9yXHJcbiAqIHtAbGluayBEaXJlY3RpdmVNZXRhZGF0YX0gZGlyZWN0aXZlcyBvbmx5XHJcbiAqIC0gYGJpbmRpbmdQcm9wYWdhdGlvbjogQmluZGluZ1Byb3BhZ2F0aW9uYCB0byBjb250cm9sIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBtb3JlIGdyYW51bGFyIHdheS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVtb25zdHJhdGVzIGhvdyBkZXBlbmRlbmN5IGluamVjdGlvbiByZXNvbHZlcyBjb25zdHJ1Y3RvciBhcmd1bWVudHMgaW5cclxuICogcHJhY3RpY2UuXHJcbiAqXHJcbiAqXHJcbiAqIEFzc3VtZSB0aGlzIEhUTUwgdGVtcGxhdGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZGl2IGRlcGVuZGVuY3k9XCIxXCI+XHJcbiAqICAgPGRpdiBkZXBlbmRlbmN5PVwiMlwiPlxyXG4gKiAgICAgPGRpdiBkZXBlbmRlbmN5PVwiM1wiIG15LWRpcmVjdGl2ZT5cclxuICogICAgICAgPGRpdiBkZXBlbmRlbmN5PVwiNFwiPlxyXG4gKiAgICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjVcIj48L2Rpdj5cclxuICogICAgICAgPC9kaXY+XHJcbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjZcIj48L2Rpdj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIDwvZGl2PlxyXG4gKiA8L2Rpdj5cclxuICogYGBgXHJcbiAqXHJcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBgZGVwZW5kZW5jeWAgZGVjb3JhdG9yIGFuZCBgU29tZVNlcnZpY2VgIGluamVjdGFibGUgY2xhc3MuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIFNvbWVTZXJ2aWNlIHtcclxuICogfVxyXG4gKlxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ1tkZXBlbmRlbmN5XScsXHJcbiAqICAgaW5wdXRzOiBbXHJcbiAqICAgICAnaWQ6IGRlcGVuZGVuY3knXHJcbiAqICAgXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBEZXBlbmRlbmN5IHtcclxuICogICBpZDpzdHJpbmc7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIExldCdzIHN0ZXAgdGhyb3VnaCB0aGUgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggYE15RGlyZWN0aXZlYCBjb3VsZCBiZSBkZWNsYXJlZC4uLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgTm8gaW5qZWN0aW9uXHJcbiAqXHJcbiAqIEhlcmUgdGhlIGNvbnN0cnVjdG9yIGlzIGRlY2xhcmVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGVyZWZvcmUgbm90aGluZyBpcyBpbmplY3RlZCBpbnRvXHJcbiAqIGBNeURpcmVjdGl2ZWAuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggbm8gZGVwZW5kZW5jaWVzLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgQ29tcG9uZW50LWxldmVsIGluamVjdGlvblxyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3QgYW55IGluamVjdGFibGUgaW5zdGFuY2UgZnJvbSB0aGUgY2xvc2VzdCBjb21wb25lbnQgaW5qZWN0b3Igb3IgYW55IG9mIGl0c1xyXG4gKiBwYXJlbnRzLlxyXG4gKlxyXG4gKiBIZXJlLCB0aGUgY29uc3RydWN0b3IgZGVjbGFyZXMgYSBwYXJhbWV0ZXIsIGBzb21lU2VydmljZWAsIGFuZCBpbmplY3RzIHRoZSBgU29tZVNlcnZpY2VgIHR5cGVcclxuICogZnJvbSB0aGUgcGFyZW50XHJcbiAqIGNvbXBvbmVudCdzIGluamVjdG9yLlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3Rvcihzb21lU2VydmljZTogU29tZVNlcnZpY2UpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgZGVwZW5kZW5jeSBvbiBgU29tZVNlcnZpY2VgLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgZGlyZWN0aXZlIGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XHJcbiAqICAgICBleHBlY3QoZGVwZW5kZW5jeS5pZCkudG9FcXVhbCgzKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGBEZXBlbmRlbmN5YCBkZWNsYXJlZCBhdCB0aGUgc2FtZSBlbGVtZW50LCBpbiB0aGlzIGNhc2VcclxuICogYGRlcGVuZGVuY3k9XCIzXCJgLlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgZGlyZWN0aXZlIGZyb20gYW55IGFuY2VzdG9yIGVsZW1lbnRzXHJcbiAqXHJcbiAqIERpcmVjdGl2ZXMgY2FuIGluamVjdCBvdGhlciBkaXJlY3RpdmVzIGRlY2xhcmVkIG9uIGFueSBhbmNlc3RvciBlbGVtZW50IChpbiB0aGUgY3VycmVudCBTaGFkb3dcclxuICogRE9NKSwgaS5lLiBvbiB0aGUgY3VycmVudCBlbGVtZW50LCB0aGVcclxuICogcGFyZW50IGVsZW1lbnQsIG9yIGl0cyBwYXJlbnRzLlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihASG9zdCgpIGRlcGVuZGVuY3k6IERlcGVuZGVuY3kpIHtcclxuICogICAgIGV4cGVjdChkZXBlbmRlbmN5LmlkKS50b0VxdWFsKDIpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogYEBIb3N0YCBjaGVja3MgdGhlIGN1cnJlbnQgZWxlbWVudCwgdGhlIHBhcmVudCwgYXMgd2VsbCBhcyBpdHMgcGFyZW50cyByZWN1cnNpdmVseS4gSWZcclxuICogYGRlcGVuZGVuY3k9XCIyXCJgIGRpZG4ndFxyXG4gKiBleGlzdCBvbiB0aGUgZGlyZWN0IHBhcmVudCwgdGhpcyBpbmplY3Rpb24gd291bGRcclxuICogaGF2ZSByZXR1cm5lZFxyXG4gKiBgZGVwZW5kZW5jeT1cIjFcImAuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyBJbmplY3RpbmcgYSBsaXZlIGNvbGxlY3Rpb24gb2YgZGlyZWN0IGNoaWxkIGRpcmVjdGl2ZXNcclxuICpcclxuICpcclxuICogQSBkaXJlY3RpdmUgY2FuIGFsc28gcXVlcnkgZm9yIG90aGVyIGNoaWxkIGRpcmVjdGl2ZXMuIFNpbmNlIHBhcmVudCBkaXJlY3RpdmVzIGFyZSBpbnN0YW50aWF0ZWRcclxuICogYmVmb3JlIGNoaWxkIGRpcmVjdGl2ZXMsIGEgZGlyZWN0aXZlIGNhbid0IHNpbXBseSBpbmplY3QgdGhlIGxpc3Qgb2YgY2hpbGQgZGlyZWN0aXZlcy4gSW5zdGVhZCxcclxuICogdGhlIGRpcmVjdGl2ZSBpbmplY3RzIGEge0BsaW5rIFF1ZXJ5TGlzdH0sIHdoaWNoIHVwZGF0ZXMgaXRzIGNvbnRlbnRzIGFzIGNoaWxkcmVuIGFyZSBhZGRlZCxcclxuICogcmVtb3ZlZCwgb3IgbW92ZWQgYnkgYSBkaXJlY3RpdmUgdGhhdCB1c2VzIGEge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IHN1Y2ggYXMgYSBgbmctZm9yYCwgYW5cclxuICogYG5nLWlmYCwgb3IgYW4gYG5nLXN3aXRjaGAuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShEZXBlbmRlbmN5KSBkZXBlbmRlbmNpZXM6UXVlcnlMaXN0PERlcGVuZGVuY3k+KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIHtAbGluayBRdWVyeUxpc3R9IHdoaWNoIGNvbnRhaW5zIGBEZXBlbmRlbmN5YCA0IGFuZFxyXG4gKiA2LiBIZXJlLCBgRGVwZW5kZW5jeWAgNSB3b3VsZCBub3QgYmUgaW5jbHVkZWQsIGJlY2F1c2UgaXQgaXMgbm90IGEgZGlyZWN0IGNoaWxkLlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRlc2NlbmRhbnQgZGlyZWN0aXZlc1xyXG4gKlxyXG4gKiBCeSBwYXNzaW5nIHRoZSBkZXNjZW5kYW50IGZsYWcgdG8gYEBRdWVyeWAgYWJvdmUsIHdlIGNhbiBpbmNsdWRlIHRoZSBjaGlsZHJlbiBvZiB0aGUgY2hpbGRcclxuICogZWxlbWVudHMuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShEZXBlbmRlbmN5LCB7ZGVzY2VuZGFudHM6IHRydWV9KSBkZXBlbmRlbmNpZXM6UXVlcnlMaXN0PERlcGVuZGVuY3k+KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIFF1ZXJ5IHdoaWNoIHdvdWxkIGNvbnRhaW4gYERlcGVuZGVuY3lgIDQsIDUgYW5kIDYuXHJcbiAqXHJcbiAqICMjIyBPcHRpb25hbCBpbmplY3Rpb25cclxuICpcclxuICogVGhlIG5vcm1hbCBiZWhhdmlvciBvZiBkaXJlY3RpdmVzIGlzIHRvIHJldHVybiBhbiBlcnJvciB3aGVuIGEgc3BlY2lmaWVkIGRlcGVuZGVuY3kgY2Fubm90IGJlXHJcbiAqIHJlc29sdmVkLiBJZiB5b3VcclxuICogd291bGQgbGlrZSB0byBpbmplY3QgYG51bGxgIG9uIHVucmVzb2x2ZWQgZGVwZW5kZW5jeSBpbnN0ZWFkLCB5b3UgY2FuIGFubm90YXRlIHRoYXQgZGVwZW5kZW5jeVxyXG4gKiB3aXRoIGBAT3B0aW9uYWwoKWAuXHJcbiAqIFRoaXMgZXhwbGljaXRseSBwZXJtaXRzIHRoZSBhdXRob3Igb2YgYSB0ZW1wbGF0ZSB0byB0cmVhdCBzb21lIG9mIHRoZSBzdXJyb3VuZGluZyBkaXJlY3RpdmVzIGFzXHJcbiAqIG9wdGlvbmFsLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBkZXBlbmRlbmN5OkRlcGVuZGVuY3kpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgYERlcGVuZGVuY3lgIGRpcmVjdGl2ZSBmb3VuZCBvbiB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gKiBJZiBub25lIGNhbiBiZVxyXG4gKiBmb3VuZCwgdGhlIGluamVjdG9yIHN1cHBsaWVzIGBudWxsYCBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEhlcmUgd2UgdXNlIGEgZGVjb3JhdG9yIGRpcmVjdGl2ZSB0byBzaW1wbHkgZGVmaW5lIGJhc2ljIHRvb2wtdGlwIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdbdG9vbHRpcF0nLFxyXG4gKiAgIGlucHV0czogW1xyXG4gKiAgICAgJ3RleHQ6IHRvb2x0aXAnXHJcbiAqICAgXSxcclxuICogICBob3N0OiB7XHJcbiAqICAgICAnKG1vdXNlZW50ZXIpJzogJ29uTW91c2VFbnRlcigpJyxcclxuICogICAgICcobW91c2VsZWF2ZSknOiAnb25Nb3VzZUxlYXZlKCknXHJcbiAqICAgfVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBUb29sdGlwe1xyXG4gKiAgIHRleHQ6c3RyaW5nO1xyXG4gKiAgIG92ZXJsYXk6T3ZlcmxheTsgLy8gTk9UIFlFVCBJTVBMRU1FTlRFRFxyXG4gKiAgIG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyOyAvLyBOT1QgWUVUIElNUExFTUVOVEVEXHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3Iob3ZlcmxheU1hbmFnZXI6T3ZlcmxheU1hbmFnZXIpIHtcclxuICogICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIG9uTW91c2VFbnRlcigpIHtcclxuICogICAgIC8vIGV4YWN0IHNpZ25hdHVyZSB0byBiZSBkZXRlcm1pbmVkXHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSB0aGlzLm92ZXJsYXlNYW5hZ2VyLm9wZW4odGV4dCwgLi4uKTtcclxuICogICB9XHJcbiAqXHJcbiAqICAgb25Nb3VzZUxlYXZlKCkge1xyXG4gKiAgICAgdGhpcy5vdmVybGF5LmNsb3NlKCk7XHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICogSW4gb3VyIEhUTUwgdGVtcGxhdGUsIHdlIGNhbiB0aGVuIGFkZCB0aGlzIGJlaGF2aW9yIHRvIGEgYDxkaXY+YCBvciBhbnkgb3RoZXIgZWxlbWVudCB3aXRoIHRoZVxyXG4gKiBgdG9vbHRpcGAgc2VsZWN0b3IsXHJcbiAqIGxpa2Ugc286XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZGl2IHRvb2x0aXA9XCJzb21lIHRleHQgaGVyZVwiPjwvZGl2PlxyXG4gKiBgYGBcclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gYWxzbyBjb250cm9sIHRoZSBpbnN0YW50aWF0aW9uLCBkZXN0cnVjdGlvbiwgYW5kIHBvc2l0aW9uaW5nIG9mIGlubGluZSB0ZW1wbGF0ZVxyXG4gKiBlbGVtZW50czpcclxuICpcclxuICogQSBkaXJlY3RpdmUgdXNlcyBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSB0byBpbnN0YW50aWF0ZSwgaW5zZXJ0LCBtb3ZlLCBhbmQgZGVzdHJveSB2aWV3cyBhdFxyXG4gKiBydW50aW1lLlxyXG4gKiBUaGUge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IGlzIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQsIGFuZCByZXByZXNlbnRzIGFcclxuICogbG9jYXRpb24gaW4gdGhlIGN1cnJlbnQgdmlld1xyXG4gKiB3aGVyZSB0aGVzZSBhY3Rpb25zIGFyZSBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIFZpZXdzIGFyZSBhbHdheXMgY3JlYXRlZCBhcyBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCB7QGxpbmsgVmlld01ldGFkYXRhfSwgYW5kIGFzIHNpYmxpbmdzIG9mIHRoZVxyXG4gKiBgPHRlbXBsYXRlPmAgZWxlbWVudC4gVGh1cyBhXHJcbiAqIGRpcmVjdGl2ZSBpbiBhIGNoaWxkIHZpZXcgY2Fubm90IGluamVjdCB0aGUgZGlyZWN0aXZlIHRoYXQgY3JlYXRlZCBpdC5cclxuICpcclxuICogU2luY2UgZGlyZWN0aXZlcyB0aGF0IGNyZWF0ZSB2aWV3cyB2aWEgVmlld0NvbnRhaW5lcnMgYXJlIGNvbW1vbiBpbiBBbmd1bGFyLCBhbmQgdXNpbmcgdGhlIGZ1bGxcclxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgc3ludGF4IGlzIHdvcmR5LCBBbmd1bGFyXHJcbiAqIGFsc28gc3VwcG9ydHMgYSBzaG9ydGhhbmQgbm90YXRpb246IGA8bGkgKmZvbz1cImJhclwiPmAgYW5kIGA8bGkgdGVtcGxhdGU9XCJmb286IGJhclwiPmAgYXJlXHJcbiAqIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqIFRodXMsXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICpmb289XCJiYXJcIiB0aXRsZT1cInRleHRcIj48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogRXhwYW5kcyBpbiB1c2UgdG86XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPHRlbXBsYXRlIFtmb29dPVwiYmFyXCI+XHJcbiAqICAgICA8bGkgdGl0bGU9XCJ0ZXh0XCI+PC9saT5cclxuICogICA8L3RlbXBsYXRlPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogTm90aWNlIHRoYXQgYWx0aG91Z2ggdGhlIHNob3J0aGFuZCBwbGFjZXMgYCpmb289XCJiYXJcImAgd2l0aGluIHRoZSBgPGxpPmAgZWxlbWVudCwgdGhlIGJpbmRpbmcgZm9yXHJcbiAqIHRoZSBkaXJlY3RpdmVcclxuICogY29udHJvbGxlciBpcyBjb3JyZWN0bHkgaW5zdGFudGlhdGVkIG9uIHRoZSBgPHRlbXBsYXRlPmAgZWxlbWVudCByYXRoZXIgdGhhbiB0aGUgYDxsaT5gIGVsZW1lbnQuXHJcbiAqXHJcbiAqICMjIExpZmVjeWNsZSBob29rc1xyXG4gKlxyXG4gKiBXaGVuIHRoZSBkaXJlY3RpdmUgY2xhc3MgaW1wbGVtZW50cyBzb21lIHtAbGluayBhbmd1bGFyMi9saWZlY3ljbGVfaG9va3N9IHRoZSBjYWxsYmFja3MgYXJlXHJcbiAqIGNhbGxlZCBieSB0aGUgY2hhbmdlIGRldGVjdGlvbiBhdCBkZWZpbmVkIHBvaW50cyBpbiB0aW1lIGR1cmluZyB0aGUgbGlmZSBvZiB0aGUgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIExldCdzIHN1cHBvc2Ugd2Ugd2FudCB0byBpbXBsZW1lbnQgdGhlIGB1bmxlc3NgIGJlaGF2aW9yLCB0byBjb25kaXRpb25hbGx5IGluY2x1ZGUgYSB0ZW1wbGF0ZS5cclxuICpcclxuICogSGVyZSBpcyBhIHNpbXBsZSBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VycyBvbiBhbiBgdW5sZXNzYCBzZWxlY3RvcjpcclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnW3VubGVzc10nLFxyXG4gKiAgIGlucHV0czogWyd1bmxlc3MnXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgVW5sZXNzIHtcclxuICogICB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gKiAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjtcclxuICogICBwcmV2Q29uZGl0aW9uOiBib29sZWFuO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZikge1xyXG4gKiAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcclxuICogICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICogICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IG51bGw7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIHNldCB1bmxlc3MobmV3Q29uZGl0aW9uKSB7XHJcbiAqICAgICBpZiAobmV3Q29uZGl0aW9uICYmIChpc0JsYW5rKHRoaXMucHJldkNvbmRpdGlvbikgfHwgIXRoaXMucHJldkNvbmRpdGlvbikpIHtcclxuICogICAgICAgdGhpcy5wcmV2Q29uZGl0aW9uID0gdHJ1ZTtcclxuICogICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XHJcbiAqICAgICB9IGVsc2UgaWYgKCFuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5wcmV2Q29uZGl0aW9uKSB8fCB0aGlzLnByZXZDb25kaXRpb24pKSB7XHJcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IGZhbHNlO1xyXG4gKiAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlKHRoaXMudGVtcGxhdGVSZWYpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogV2UgY2FuIHRoZW4gdXNlIHRoaXMgYHVubGVzc2Agc2VsZWN0b3IgaW4gYSB0ZW1wbGF0ZTpcclxuICogYGBgXHJcbiAqIDx1bD5cclxuICogICA8bGkgKnVubGVzcz1cImV4cHJcIj48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogT25jZSB0aGUgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyB0aGUgY2hpbGQgdmlldywgdGhlIHNob3J0aGFuZCBub3RhdGlvbiBmb3IgdGhlIHRlbXBsYXRlIGV4cGFuZHNcclxuICogYW5kIHRoZSByZXN1bHQgaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPHRlbXBsYXRlIFt1bmxlc3NdPVwiZXhwXCI+XHJcbiAqICAgICA8bGk+PC9saT5cclxuICogICA8L3RlbXBsYXRlPlxyXG4gKiAgIDxsaT48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSBhbHNvIHRoYXQgYWx0aG91Z2ggdGhlIGA8bGk+PC9saT5gIHRlbXBsYXRlIHN0aWxsIGV4aXN0cyBpbnNpZGUgdGhlIGA8dGVtcGxhdGU+PC90ZW1wbGF0ZT5gLFxyXG4gKiB0aGUgaW5zdGFudGlhdGVkXHJcbiAqIHZpZXcgb2NjdXJzIG9uIHRoZSBzZWNvbmQgYDxsaT48L2xpPmAgd2hpY2ggaXMgYSBzaWJsaW5nIHRvIHRoZSBgPHRlbXBsYXRlPmAgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydHMuRGlyZWN0aXZlID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3IoZGlyZWN0aXZlc18yLkRpcmVjdGl2ZU1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBWaWV3TWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXHJcbiAqXHJcbiAqIEVhY2ggQW5ndWxhciBjb21wb25lbnQgcmVxdWlyZXMgYSBzaW5nbGUgYEBDb21wb25lbnRgIGFuZCBhdCBsZWFzdCBvbmUgYEBWaWV3YCBhbm5vdGF0aW9uLiBUaGVcclxuICogYEBWaWV3YCBhbm5vdGF0aW9uIHNwZWNpZmllcyB0aGUgSFRNTCB0ZW1wbGF0ZSB0byB1c2UsIGFuZCBsaXN0cyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBhY3RpdmVcclxuICogd2l0aGluIHRoZSB0ZW1wbGF0ZS5cclxuICpcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgaW50byB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QsIGFuZFxyXG4gKiB0aGUgZXhwcmVzc2lvbnMgYW5kIHN0YXRlbWVudHMgaW4gdGhlIHRlbXBsYXRlIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBDb21wb25lbnRgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2dyZWV0JyxcclxuICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXHJcbiAqICAgZGlyZWN0aXZlczogW0dyZWV0VXNlciwgQm9sZF1cclxuICogfSlcclxuICogY2xhc3MgR3JlZXQge1xyXG4gKiAgIG5hbWU6IHN0cmluZztcclxuICpcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5WaWV3ID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3Iodmlld18yLlZpZXdNZXRhZGF0YSwgZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5WaWV3ID0gZXhwb3J0cy5WaWV3OyB9KTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBBdHRyaWJ1dGVNZXRhZGF0YS5cclxuLyoqXHJcbiAqIE1ldGFkYXRhIHByb3BlcnRpZXMgYXZhaWxhYmxlIGZvciBjb25maWd1cmluZyBWaWV3cy5cclxuICpcclxuICogRWFjaCBBbmd1bGFyIGNvbXBvbmVudCByZXF1aXJlcyBhIHNpbmdsZSBgQENvbXBvbmVudGAgYW5kIGF0IGxlYXN0IG9uZSBgQFZpZXdgIGFubm90YXRpb24uIFRoZVxyXG4gKiBgQFZpZXdgIGFubm90YXRpb24gc3BlY2lmaWVzIHRoZSBIVE1MIHRlbXBsYXRlIHRvIHVzZSwgYW5kIGxpc3RzIHRoZSBkaXJlY3RpdmVzIHRoYXQgYXJlIGFjdGl2ZVxyXG4gKiB3aXRoaW4gdGhlIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgdGhlIHRlbXBsYXRlIGlzIGxvYWRlZCBpbnRvIHRoZSBjb21wb25lbnQncyBzaGFkb3cgcm9vdCwgYW5kXHJcbiAqIHRoZSBleHByZXNzaW9ucyBhbmQgc3RhdGVtZW50cyBpbiB0aGUgdGVtcGxhdGUgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQENvbXBvbmVudGAgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBDb21wb25lbnRNZXRhZGF0YX0uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJyxcclxuICogICBkaXJlY3RpdmVzOiBbR3JlZXRVc2VyLCBCb2xkXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBHcmVldCB7XHJcbiAqICAgbmFtZTogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkF0dHJpYnV0ZSA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IoZGlfMi5BdHRyaWJ1dGVNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gUXVlcnlNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGFuIGluamVjdGFibGUgcGFyYW1ldGVyIHRvIGJlIGEgbGl2ZSBsaXN0IG9mIGRpcmVjdGl2ZXMgb3IgdmFyaWFibGVcclxuICogYmluZGluZ3MgZnJvbSB0aGUgY29udGVudCBjaGlsZHJlbiBvZiBhIGRpcmVjdGl2ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2xZOW04SEx5N3owNnZEb1VhU04yP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEFzc3VtZSB0aGF0IGA8dGFicz5gIGNvbXBvbmVudCB3b3VsZCBsaWtlIHRvIGdldCBhIGxpc3QgaXRzIGNoaWxkcmVuIGA8cGFuZT5gXHJcbiAqIGNvbXBvbmVudHMgYXMgc2hvd24gaW4gdGhpcyBleGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDx0YWJzPlxyXG4gKiAgIDxwYW5lIHRpdGxlPVwiT3ZlcnZpZXdcIj4uLi48L3BhbmU+XHJcbiAqICAgPHBhbmUgKm5nLWZvcj1cIiNvIG9mIG9iamVjdHNcIiBbdGl0bGVdPVwiby50aXRsZVwiPnt7by50ZXh0fX08L3BhbmU+XHJcbiAqIDwvdGFicz5cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBwcmVmZXJyZWQgc29sdXRpb24gaXMgdG8gcXVlcnkgZm9yIGBQYW5lYCBkaXJlY3RpdmVzIHVzaW5nIHRoaXMgZGVjb3JhdG9yLlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAncGFuZScsXHJcbiAqICAgaW5wdXRzOiBbJ3RpdGxlJ11cclxuICogfSlcclxuICogY2xhc3MgUGFuZSB7XHJcbiAqICAgdGl0bGU6c3RyaW5nO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICd0YWJzJyxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx1bD5cclxuICogICAgICA8bGkgKm5nLWZvcj1cIiNwYW5lIG9mIHBhbmVzXCI+e3twYW5lLnRpdGxlfX08L2xpPlxyXG4gKiAgICA8L3VsPlxyXG4gKiAgICA8Y29udGVudD48L2NvbnRlbnQ+XHJcbiAqICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFRhYnMge1xyXG4gKiAgIHBhbmVzOiBRdWVyeUxpc3Q8UGFuZT47XHJcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KFBhbmUpIHBhbmVzOlF1ZXJ5TGlzdDxQYW5lPikge1xyXG4gKiAgICAgdGhpcy5wYW5lcyA9IHBhbmVzO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQSBxdWVyeSBjYW4gbG9vayBmb3IgdmFyaWFibGUgYmluZGluZ3MgYnkgcGFzc2luZyBpbiBhIHN0cmluZyB3aXRoIGRlc2lyZWQgYmluZGluZyBzeW1ib2wuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9zVDJqMjVjSDFkVVJBeUJSQ0t4MT9wPXByZXZpZXcpKVxyXG4gKiBgYGBodG1sXHJcbiAqIDxzZWVrZXI+XHJcbiAqICAgPGRpdiAjZmluZG1lPi4uLjwvZGl2PlxyXG4gKiA8L3NlZWtlcj5cclxuICpcclxuICogQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnZm9vJyB9KVxyXG4gKiBjbGFzcyBzZWVrZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZG1lJykgZWxMaXN0OiBRdWVyeUxpc3Q8RWxlbWVudFJlZj4pIHsuLi59XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEluIHRoaXMgY2FzZSB0aGUgb2JqZWN0IHRoYXQgaXMgaW5qZWN0ZWQgZGVwZW5kIG9uIHRoZSB0eXBlIG9mIHRoZSB2YXJpYWJsZVxyXG4gKiBiaW5kaW5nLiBJdCBjYW4gYmUgYW4gRWxlbWVudFJlZiwgYSBkaXJlY3RpdmUgb3IgYSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiB2YXJpYWJsZSBiaW5kaW5ncyB3aWxsIHF1ZXJ5IGZvciBhbGwgb2YgdGhlbS5cclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8c2Vla2VyPlxyXG4gKiAgIDxkaXYgI2ZpbmQtbWU+Li4uPC9kaXY+XHJcbiAqICAgPGRpdiAjZmluZC1tZS10b28+Li4uPC9kaXY+XHJcbiAqIDwvc2Vla2VyPlxyXG4gKlxyXG4gKiAgQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdmb28nXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNlZWtlciB7XHJcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KCdmaW5kTWUsIGZpbmRNZVRvbycpIGVsTGlzdDogUXVlcnlMaXN0PEVsZW1lbnRSZWY+KSB7Li4ufVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDb25maWd1cmUgd2hldGhlciBxdWVyeSBsb29rcyBmb3IgZGlyZWN0IGNoaWxkcmVuIG9yIGFsbCBkZXNjZW5kYW50c1xyXG4gKiBvZiB0aGUgcXVlcnlpbmcgZWxlbWVudCwgYnkgdXNpbmcgdGhlIGBkZXNjZW5kYW50c2AgcGFyYW1ldGVyLlxyXG4gKiBJdCBpcyBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd3RHZUI5NzdidjdxdkE1RlRZbDk/cD1wcmV2aWV3KSlcclxuICogYGBgaHRtbFxyXG4gKiA8Y29udGFpbmVyICNmaXJzdD5cclxuICogICA8aXRlbT5hPC9pdGVtPlxyXG4gKiAgIDxpdGVtPmI8L2l0ZW0+XHJcbiAqICAgPGNvbnRhaW5lciAjc2Vjb25kPlxyXG4gKiAgICAgPGl0ZW0+YzwvaXRlbT5cclxuICogICA8L2NvbnRhaW5lcj5cclxuICogPC9jb250YWluZXI+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBXaGVuIHF1ZXJ5aW5nIGZvciBpdGVtcywgdGhlIGZpcnN0IGNvbnRhaW5lciB3aWxsIHNlZSBvbmx5IGBhYCBhbmQgYGJgIGJ5IGRlZmF1bHQsXHJcbiAqIGJ1dCB3aXRoIGBRdWVyeShUZXh0RGlyZWN0aXZlLCB7ZGVzY2VuZGFudHM6IHRydWV9KWAgaXQgd2lsbCBzZWUgYGNgIHRvby5cclxuICpcclxuICogVGhlIHF1ZXJpZWQgZGlyZWN0aXZlcyBhcmUga2VwdCBpbiBhIGRlcHRoLWZpcnN0IHByZS1vcmRlciB3aXRoIHJlc3BlY3QgdG8gdGhlaXJcclxuICogcG9zaXRpb25zIGluIHRoZSBET00uXHJcbiAqXHJcbiAqIFF1ZXJ5IGRvZXMgbm90IGxvb2sgZGVlcCBpbnRvIGFueSBzdWJjb21wb25lbnQgdmlld3MuXHJcbiAqXHJcbiAqIFF1ZXJ5IGlzIHVwZGF0ZWQgYXMgcGFydCBvZiB0aGUgY2hhbmdlLWRldGVjdGlvbiBjeWNsZS4gU2luY2UgY2hhbmdlIGRldGVjdGlvblxyXG4gKiBoYXBwZW5zIGFmdGVyIGNvbnN0cnVjdGlvbiBvZiBhIGRpcmVjdGl2ZSwgUXVlcnlMaXN0IHdpbGwgYWx3YXlzIGJlIGVtcHR5IHdoZW4gb2JzZXJ2ZWQgaW4gdGhlXHJcbiAqIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBUaGUgaW5qZWN0ZWQgb2JqZWN0IGlzIGFuIHVubW9kaWZpYWJsZSBsaXZlIGxpc3QuXHJcbiAqIFNlZSB7QGxpbmsgUXVlcnlMaXN0fSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuZXhwb3J0cy5RdWVyeSA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IoZGlfMi5RdWVyeU1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YS5cclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxyXG4gKlxyXG4gKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBDb250ZW50Q2hpbGRyZW4oQ2hpbGREaXJlY3RpdmUpIGNvbnRlbnRDaGlsZHJlbjogUXVlcnlMaXN0PENoaWxkRGlyZWN0aXZlPjtcclxuICpcclxuICogICBhZnRlckNvbnRlbnRJbml0KCkge1xyXG4gKiAgICAgLy8gY29udGVudENoaWxkcmVuIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuQ29udGVudENoaWxkcmVuID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpXzIuQ29udGVudENoaWxkcmVuTWV0YWRhdGEpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIENvbnRlbnRDaGlsZE1ldGFkYXRhLlxyXG4vKipcclxuICogQ29uZmlndXJlcyBhIGNvbnRlbnQgcXVlcnkuXHJcbiAqXHJcbiAqIENvbnRlbnQgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYGFmdGVyQ29udGVudEluaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnc29tZURpcidcclxuICogfSlcclxuICogY2xhc3MgU29tZURpciB7XHJcbiAqICAgQENvbnRlbnRDaGlsZChDaGlsZERpcmVjdGl2ZSkgY29udGVudENoaWxkO1xyXG4gKlxyXG4gKiAgIGFmdGVyQ29udGVudEluaXQoKSB7XHJcbiAqICAgICAvLyBjb250ZW50Q2hpbGQgaXMgc2V0XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5Db250ZW50Q2hpbGQgPSBkZWNvcmF0b3JzXzEubWFrZVByb3BEZWNvcmF0b3IoZGlfMi5Db250ZW50Q2hpbGRNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld0NoaWxkcmVuTWV0YWRhdGEuXHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIGEgdmlldyBxdWVyeS5cclxuICpcclxuICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgYWZ0ZXJWaWV3SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJyxcclxuICogICB0ZW1wbGF0ZVVybDogJ3NvbWVUZW1wbGF0ZScsXHJcbiAqICAgZGlyZWN0aXZlczogW0l0ZW1EaXJlY3RpdmVdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBWaWV3Q2hpbGRyZW4oSXRlbURpcmVjdGl2ZSkgdmlld0NoaWxkcmVuOiBRdWVyeUxpc3Q8SXRlbURpcmVjdGl2ZT47XHJcbiAqXHJcbiAqICAgYWZ0ZXJWaWV3SW5pdCgpIHtcclxuICogICAgIC8vIHZpZXdDaGlsZHJlbiBpcyBzZXRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLlZpZXdDaGlsZHJlbiA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLlZpZXdDaGlsZHJlbk1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBWaWV3Q2hpbGRNZXRhZGF0YS5cclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSB2aWV3IHF1ZXJ5LlxyXG4gKlxyXG4gKiBWaWV3IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInLFxyXG4gKiAgIHRlbXBsYXRlVXJsOiAnc29tZVRlbXBsYXRlJyxcclxuICogICBkaXJlY3RpdmVzOiBbSXRlbURpcmVjdGl2ZV1cclxuICogfSlcclxuICogY2xhc3MgU29tZURpciB7XHJcbiAqICAgQFZpZXdDaGlsZChJdGVtRGlyZWN0aXZlKSB2aWV3Q2hpbGQ6SXRlbURpcmVjdGl2ZTtcclxuICpcclxuICogICBhZnRlclZpZXdJbml0KCkge1xyXG4gKiAgICAgLy8gdmlld0NoaWxkIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuVmlld0NoaWxkID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpXzIuVmlld0NoaWxkTWV0YWRhdGEpO1xyXG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFZpZXdRdWVyeU1ldGFkYXRhLlxyXG4vKipcclxuICogU2ltaWxhciB0byB7QGxpbmsgUXVlcnlNZXRhZGF0YX0sIGJ1dCBxdWVyeWluZyB0aGUgY29tcG9uZW50IHZpZXcsIGluc3RlYWQgb2ZcclxuICogdGhlIGNvbnRlbnQgY2hpbGRyZW4uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lTnNGSERmN1lqeU02SXpLeE0xaj9wPXByZXZpZXcpKVxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoey4uLn0pXHJcbiAqIEBWaWV3KHtcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgPGl0ZW0+IGEgPC9pdGVtPlxyXG4gKiAgICAgPGl0ZW0+IGIgPC9pdGVtPlxyXG4gKiAgICAgPGl0ZW0+IGMgPC9pdGVtPlxyXG4gKiAgIGBcclxuICogfSlcclxuICogY2xhc3MgTXlDb21wb25lbnQge1xyXG4gKiAgIHNob3duOiBib29sZWFuO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgQFF1ZXJ5KEl0ZW0pIGl0ZW1zOlF1ZXJ5TGlzdDxJdGVtPikge1xyXG4gKiAgICAgaXRlbXMub25DaGFuZ2UoKCkgPT4gY29uc29sZS5sb2coaXRlbXMubGVuZ3RoKSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTdXBwb3J0cyB0aGUgc2FtZSBxdWVyeWluZyBwYXJhbWV0ZXJzIGFzIHtAbGluayBRdWVyeU1ldGFkYXRhfSwgZXhjZXB0XHJcbiAqIGBkZXNjZW5kYW50c2AuIFRoaXMgYWx3YXlzIHF1ZXJpZXMgdGhlIHdob2xlIHZpZXcuXHJcbiAqXHJcbiAqIEFzIGBzaG93bmAgaXMgZmxpcHBlZCBiZXR3ZWVuIHRydWUgYW5kIGZhbHNlLCBpdGVtcyB3aWxsIGNvbnRhaW4gemVybyBvZiBvbmVcclxuICogaXRlbXMuXHJcbiAqXHJcbiAqIFNwZWNpZmllcyB0aGF0IGEge0BsaW5rIFF1ZXJ5TGlzdH0gc2hvdWxkIGJlIGluamVjdGVkLlxyXG4gKlxyXG4gKiBUaGUgaW5qZWN0ZWQgb2JqZWN0IGlzIGFuIGl0ZXJhYmxlIGFuZCBvYnNlcnZhYmxlIGxpdmUgbGlzdC5cclxuICogU2VlIHtAbGluayBRdWVyeUxpc3R9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5leHBvcnRzLlZpZXdRdWVyeSA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IoZGlfMi5WaWV3UXVlcnlNZXRhZGF0YSk7XHJcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gUGlwZU1ldGFkYXRhLlxyXG4vKipcclxuICogRGVjbGFyZSByZXVzYWJsZSBwaXBlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAUGlwZSh7XHJcbiAqICAgbmFtZTogJ2xvd2VyY2FzZSdcclxuICogfSlcclxuICogY2xhc3MgTG93ZXJjYXNlIHtcclxuICogICB0cmFuc2Zvcm0odiwgYXJncykgeyByZXR1cm4gdi50b0xvd2VyQ2FzZSgpOyB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLlBpcGUgPSBkZWNvcmF0b3JzXzEubWFrZURlY29yYXRvcihkaXJlY3RpdmVzXzIuUGlwZU1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBJbnB1dE1ldGFkYXRhLlxyXG4vKipcclxuICogRGVjbGFyZXMgYSBkYXRhLWJvdW5kIGlucHV0IHByb3BlcnR5LlxyXG4gKlxyXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyBkYXRhLWJvdW5kIHByb3BlcnRpZXMgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAqXHJcbiAqIGBJbnB1dE1ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWVcclxuICogdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCB3aXRoIHR3byBpbnB1dCBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYmFuay1hY2NvdW50JyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgQmFuayBOYW1lOiB7e2JhbmtOYW1lfX1cclxuICogICAgIEFjY291bnQgSWQ6IHt7aWR9fVxyXG4gKiAgIGBcclxuICogfSlcclxuICogY2xhc3MgQmFua0FjY291bnQge1xyXG4gKiAgIEBJbnB1dCgpIGJhbmtOYW1lOiBzdHJpbmc7XHJcbiAqICAgQElucHV0KCdhY2NvdW50LWlkJykgaWQ6IHN0cmluZztcclxuICpcclxuICogICAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCBib3VuZCwgYW5kIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSBBbmd1bGFyXHJcbiAqICAgbm9ybWFsaXplZEJhbmtOYW1lOiBzdHJpbmc7XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8YmFuay1hY2NvdW50IGJhbmstbmFtZT1cIlJCQ1wiIGFjY291bnQtaWQ9XCI0NzQ3XCI+PC9iYW5rLWFjY291bnQ+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbQmFua0FjY291bnRdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7fVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLklucHV0ID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5JbnB1dE1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBPdXRwdXRNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGFuIGV2ZW50LWJvdW5kIG91dHB1dCBwcm9wZXJ0eS5cclxuICpcclxuICogV2hlbiBhbiBvdXRwdXQgcHJvcGVydHkgZW1pdHMgYW4gZXZlbnQsIGFuIGV2ZW50IGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudFxyXG4gKiB0aGUgdGVtcGxhdGUgaXMgaW52b2tlZC5cclxuICpcclxuICogYE91dHB1dE1ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWVcclxuICogdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnaW50ZXJ2YWwtZGlyJyxcclxuICogfSlcclxuICogY2xhc3MgSW50ZXJ2YWxEaXIge1xyXG4gKiAgIEBPdXRwdXQoKSBldmVyeVNlY29uZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICogICBAT3V0cHV0KCdldmVyeUZpdmVTZWNvbmRzJykgZml2ZTVTZWNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ldmVyeVNlY29uZC5uZXh0KFwiZXZlbnRcIiksIDEwMDApO1xyXG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5maXZlNVNlY3MubmV4dChcImV2ZW50XCIpLCA1MDAwKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8aW50ZXJ2YWwtZGlyIChldmVyeS1zZWNvbmQpPVwiZXZlcnlTZWNvbmQoKVwiIChldmVyeS1maXZlLXNlY29uZHMpPVwiZXZlcnlGaXZlU2Vjb25kcygpXCI+XHJcbiAqICAgICA8L2ludGVydmFsLWRpcj5cclxuICogICBgLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtJbnRlcnZhbERpcl1cclxuICogfSlcclxuICogY2xhc3MgQXBwIHtcclxuICogICBldmVyeVNlY29uZCgpIHsgY29uc29sZS5sb2coJ3NlY29uZCcpOyB9XHJcbiAqICAgZXZlcnlGaXZlU2Vjb25kcygpIHsgY29uc29sZS5sb2coJ2ZpdmUgc2Vjb25kcycpOyB9XHJcbiAqIH1cclxuICogYm9vdHN0cmFwKEFwcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5PdXRwdXQgPSBkZWNvcmF0b3JzXzEubWFrZVByb3BEZWNvcmF0b3IoZGlyZWN0aXZlc18yLk91dHB1dE1ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBIb3N0QmluZGluZ01ldGFkYXRhLlxyXG4vKipcclxuICogRGVjbGFyZXMgYSBob3N0IHByb3BlcnR5IGJpbmRpbmcuXHJcbiAqXHJcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSBjaGVja3MgaG9zdCBwcm9wZXJ0eSBiaW5kaW5ncyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cclxuICogSWYgYSBiaW5kaW5nIGNoYW5nZXMsIGl0IHdpbGwgdXBkYXRlIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIGRpcmVjdGl2ZS5cclxuICpcclxuICogYEhvc3RCaW5kaW5nTWV0YWRhdGFgIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgcHJvcGVydHlcclxuICogbmFtZSBvZiB0aGUgaG9zdCBlbGVtZW50IHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIGNsYXNzIHByb3BlcnR5IG5hbWUgaXMgdXNlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBkaXJlY3RpdmUgdGhhdCBzZXRzIHRoZSBgdmFsaWRgIGFuZCBgaW52YWxpZGAgY2xhc3Nlc1xyXG4gKiBvbiB0aGUgRE9NIGVsZW1lbnQgdGhhdCBoYXMgbmctbW9kZWwgZGlyZWN0aXZlIG9uIGl0LlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW25nLW1vZGVsXSd9KVxyXG4gKiBjbGFzcyBOZ01vZGVsU3RhdHVzIHtcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgY29udHJvbDpOZ01vZGVsKSB7fVxyXG4gKiAgIEBIb3N0QmluZGluZygnW2NsYXNzLnZhbGlkXScpIGdldCB2YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wudmFsaWQ7IH1cclxuICogICBASG9zdEJpbmRpbmcoJ1tjbGFzcy5pbnZhbGlkXScpIGdldCBpbnZhbGlkIHsgcmV0dXJuIHRoaXMuY29udHJvbC5pbnZhbGlkOyB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgPGlucHV0IFsobmctbW9kZWwpXT1cInByb3BcIj5gLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVMsIE5nTW9kZWxTdGF0dXNdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7XHJcbiAqICAgcHJvcDtcclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkhvc3RCaW5kaW5nID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5Ib3N0QmluZGluZ01ldGFkYXRhKTtcclxuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBIb3N0TGlzdGVuZXJNZXRhZGF0YS5cclxuLyoqXHJcbiAqIERlY2xhcmVzIGEgaG9zdCBsaXN0ZW5lci5cclxuICpcclxuICogQW5ndWxhciB3aWxsIGludm9rZSB0aGUgZGVjb3JhdGVkIG1ldGhvZCB3aGVuIHRoZSBob3N0IGVsZW1lbnQgZW1pdHMgdGhlIHNwZWNpZmllZCBldmVudC5cclxuICpcclxuICogSWYgdGhlIGRlY29yYXRlZCBtZXRob2QgcmV0dXJucyBgZmFsc2VgLCB0aGVuIGBwcmV2ZW50RGVmYXVsdGAgaXMgYXBwbGllZCBvbiB0aGUgRE9NXHJcbiAqIGV2ZW50LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVjbGFyZXMgYSBkaXJlY3RpdmUgdGhhdCBhdHRhY2hlcyBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBidXR0b24gYW5kXHJcbiAqIGNvdW50cyBjbGlja3MuXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdidXR0b25bY291bnRpbmddJ30pXHJcbiAqIGNsYXNzIENvdW50Q2xpY2tzIHtcclxuICogICBudW1iZXJPZkNsaWNrcyA9IDA7XHJcbiAqXHJcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcclxuICogICBvbkNsaWNrKGJ0bikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJidXR0b25cIiwgYnRuLCBcIm51bWJlciBvZiBjbGlja3M6XCIsIHRoaXMubnVtYmVyT2ZDbGlja3MrKyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICogICB0ZW1wbGF0ZTogYDxidXR0b24gY291bnRpbmc+SW5jcmVtZW50PC9idXR0b24+YCxcclxuICogICBkaXJlY3RpdmVzOiBbQ291bnRDbGlja3NdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7fVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkhvc3RMaXN0ZW5lciA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuSG9zdExpc3RlbmVyTWV0YWRhdGEpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9tZXRhZGF0YScpO1xyXG4vKipcclxuICogU3BlY2lmaWVzIHRoYXQgYSBjb25zdGFudCBhdHRyaWJ1dGUgdmFsdWUgc2hvdWxkIGJlIGluamVjdGVkLlxyXG4gKlxyXG4gKiBUaGUgZGlyZWN0aXZlIGNhbiBpbmplY3QgY29uc3RhbnQgc3RyaW5nIGxpdGVyYWxzIG9mIGhvc3QgZWxlbWVudCBhdHRyaWJ1dGVzLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIFN1cHBvc2Ugd2UgaGF2ZSBhbiBgPGlucHV0PmAgZWxlbWVudCBhbmQgd2FudCB0byBrbm93IGl0cyBgdHlwZWAuXHJcbiAqXHJcbiAqIGBgYGh0bWxcclxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBIGRlY29yYXRvciBjYW4gaW5qZWN0IHN0cmluZyBsaXRlcmFsIGB0ZXh0YCBsaWtlIHNvOlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiBgaW5wdXQnXHJcbiAqIH0pXHJcbiAqIGNsYXNzIElucHV0RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAQXR0cmlidXRlKCd0eXBlJykgdHlwZSkge1xyXG4gKiAgICAgLy8gdHlwZSB3b3VsZCBiZSBgdGV4dGAgaW4gdGhpcyBleGFtcGxlXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEF0dHJpYnV0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBdHRyaWJ1dGVNZXRhZGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZU1ldGFkYXRhKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF0dHJpYnV0ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJ0b2tlblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IG9uZSB3b3VsZCBkZWZhdWx0IGEgdG9rZW4gdG8gYSB0eXBlIG9mIGFuIGluamVjdGVkIHZhbHVlIGJ1dCBoZXJlXHJcbiAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIGEgdmFyaWFibGUgaXMgXCJzdHJpbmdcIiBhbmQgd2UgY2FuJ3QgdXNlIHByaW1pdGl2ZSB0eXBlIGFzIGEgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIHVzZSBpbnN0YW5jZSBvZiBBdHRyaWJ1dGUgaW5zdGVhZC4gVGhpcyBkb2Vzbid0IG1hdHRlciBtdWNoIGluIHByYWN0aWNlIGFzIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAvLyB3aXRoIEBBdHRyaWJ1dGUgYW5ub3RhdGlvbiBhcmUgaW5qZWN0ZWQgYnkgRWxlbWVudEluamVjdG9yIHRoYXQgZG9lc24ndCB0YWtlIHRva2VucyBpbnRvXHJcbiAgICAgICAgICAgIC8vIGFjY291bnQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQXR0cmlidXRlTWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAQXR0cmlidXRlKFwiICsgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLmF0dHJpYnV0ZU5hbWUpICsgXCIpXCI7IH07XHJcbiAgICBBdHRyaWJ1dGVNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgQXR0cmlidXRlTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIEF0dHJpYnV0ZU1ldGFkYXRhO1xyXG59KShtZXRhZGF0YV8xLkRlcGVuZGVuY3lNZXRhZGF0YSk7XHJcbmV4cG9ydHMuQXR0cmlidXRlTWV0YWRhdGEgPSBBdHRyaWJ1dGVNZXRhZGF0YTtcclxuLyoqXHJcbiAqIERlY2xhcmVzIGFuIGluamVjdGFibGUgcGFyYW1ldGVyIHRvIGJlIGEgbGl2ZSBsaXN0IG9mIGRpcmVjdGl2ZXMgb3IgdmFyaWFibGVcclxuICogYmluZGluZ3MgZnJvbSB0aGUgY29udGVudCBjaGlsZHJlbiBvZiBhIGRpcmVjdGl2ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2xZOW04SEx5N3owNnZEb1VhU04yP3A9cHJldmlldykpXHJcbiAqXHJcbiAqIEFzc3VtZSB0aGF0IGA8dGFicz5gIGNvbXBvbmVudCB3b3VsZCBsaWtlIHRvIGdldCBhIGxpc3QgaXRzIGNoaWxkcmVuIGA8cGFuZT5gXHJcbiAqIGNvbXBvbmVudHMgYXMgc2hvd24gaW4gdGhpcyBleGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDx0YWJzPlxyXG4gKiAgIDxwYW5lIHRpdGxlPVwiT3ZlcnZpZXdcIj4uLi48L3BhbmU+XHJcbiAqICAgPHBhbmUgKm5nLWZvcj1cIiNvIG9mIG9iamVjdHNcIiBbdGl0bGVdPVwiby50aXRsZVwiPnt7by50ZXh0fX08L3BhbmU+XHJcbiAqIDwvdGFicz5cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBwcmVmZXJyZWQgc29sdXRpb24gaXMgdG8gcXVlcnkgZm9yIGBQYW5lYCBkaXJlY3RpdmVzIHVzaW5nIHRoaXMgZGVjb3JhdG9yLlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAncGFuZScsXHJcbiAqICAgaW5wdXRzOiBbJ3RpdGxlJ11cclxuICogfSlcclxuICogY2xhc3MgUGFuZSB7XHJcbiAqICAgdGl0bGU6c3RyaW5nO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICd0YWJzJyxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx1bD5cclxuICogICAgICA8bGkgKm5nLWZvcj1cIiNwYW5lIG9mIHBhbmVzXCI+e3twYW5lLnRpdGxlfX08L2xpPlxyXG4gKiAgICA8L3VsPlxyXG4gKiAgICA8Y29udGVudD48L2NvbnRlbnQ+XHJcbiAqICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFRhYnMge1xyXG4gKiAgIHBhbmVzOiBRdWVyeUxpc3Q8UGFuZT47XHJcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KFBhbmUpIHBhbmVzOlF1ZXJ5TGlzdDxQYW5lPikge1xyXG4gICogICAgdGhpcy5wYW5lcyA9IHBhbmVzO1xyXG4gICogIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQSBxdWVyeSBjYW4gbG9vayBmb3IgdmFyaWFibGUgYmluZGluZ3MgYnkgcGFzc2luZyBpbiBhIHN0cmluZyB3aXRoIGRlc2lyZWQgYmluZGluZyBzeW1ib2wuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9zVDJqMjVjSDFkVVJBeUJSQ0t4MT9wPXByZXZpZXcpKVxyXG4gKiBgYGBodG1sXHJcbiAqIDxzZWVrZXI+XHJcbiAqICAgPGRpdiAjZmluZG1lPi4uLjwvZGl2PlxyXG4gKiA8L3NlZWtlcj5cclxuICpcclxuICogQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnZm9vJyB9KVxyXG4gKiBjbGFzcyBzZWVrZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZG1lJykgZWxMaXN0OiBRdWVyeUxpc3Q8RWxlbWVudFJlZj4pIHsuLi59XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEluIHRoaXMgY2FzZSB0aGUgb2JqZWN0IHRoYXQgaXMgaW5qZWN0ZWQgZGVwZW5kIG9uIHRoZSB0eXBlIG9mIHRoZSB2YXJpYWJsZVxyXG4gKiBiaW5kaW5nLiBJdCBjYW4gYmUgYW4gRWxlbWVudFJlZiwgYSBkaXJlY3RpdmUgb3IgYSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiB2YXJpYWJsZSBiaW5kaW5ncyB3aWxsIHF1ZXJ5IGZvciBhbGwgb2YgdGhlbS5cclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8c2Vla2VyPlxyXG4gKiAgIDxkaXYgI2ZpbmQtbWU+Li4uPC9kaXY+XHJcbiAqICAgPGRpdiAjZmluZC1tZS10b28+Li4uPC9kaXY+XHJcbiAqIDwvc2Vla2VyPlxyXG4gKlxyXG4gKiAgQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdmb28nXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNlZWtlciB7XHJcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KCdmaW5kTWUsIGZpbmRNZVRvbycpIGVsTGlzdDogUXVlcnlMaXN0PEVsZW1lbnRSZWY+KSB7Li4ufVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDb25maWd1cmUgd2hldGhlciBxdWVyeSBsb29rcyBmb3IgZGlyZWN0IGNoaWxkcmVuIG9yIGFsbCBkZXNjZW5kYW50c1xyXG4gKiBvZiB0aGUgcXVlcnlpbmcgZWxlbWVudCwgYnkgdXNpbmcgdGhlIGBkZXNjZW5kYW50c2AgcGFyYW1ldGVyLlxyXG4gKiBJdCBpcyBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd3RHZUI5NzdidjdxdkE1RlRZbDk/cD1wcmV2aWV3KSlcclxuICogYGBgaHRtbFxyXG4gKiA8Y29udGFpbmVyICNmaXJzdD5cclxuICogICA8aXRlbT5hPC9pdGVtPlxyXG4gKiAgIDxpdGVtPmI8L2l0ZW0+XHJcbiAqICAgPGNvbnRhaW5lciAjc2Vjb25kPlxyXG4gKiAgICAgPGl0ZW0+YzwvaXRlbT5cclxuICogICA8L2NvbnRhaW5lcj5cclxuICogPC9jb250YWluZXI+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBXaGVuIHF1ZXJ5aW5nIGZvciBpdGVtcywgdGhlIGZpcnN0IGNvbnRhaW5lciB3aWxsIHNlZSBvbmx5IGBhYCBhbmQgYGJgIGJ5IGRlZmF1bHQsXHJcbiAqIGJ1dCB3aXRoIGBRdWVyeShUZXh0RGlyZWN0aXZlLCB7ZGVzY2VuZGFudHM6IHRydWV9KWAgaXQgd2lsbCBzZWUgYGNgIHRvby5cclxuICpcclxuICogVGhlIHF1ZXJpZWQgZGlyZWN0aXZlcyBhcmUga2VwdCBpbiBhIGRlcHRoLWZpcnN0IHByZS1vcmRlciB3aXRoIHJlc3BlY3QgdG8gdGhlaXJcclxuICogcG9zaXRpb25zIGluIHRoZSBET00uXHJcbiAqXHJcbiAqIFF1ZXJ5IGRvZXMgbm90IGxvb2sgZGVlcCBpbnRvIGFueSBzdWJjb21wb25lbnQgdmlld3MuXHJcbiAqXHJcbiAqIFF1ZXJ5IGlzIHVwZGF0ZWQgYXMgcGFydCBvZiB0aGUgY2hhbmdlLWRldGVjdGlvbiBjeWNsZS4gU2luY2UgY2hhbmdlIGRldGVjdGlvblxyXG4gKiBoYXBwZW5zIGFmdGVyIGNvbnN0cnVjdGlvbiBvZiBhIGRpcmVjdGl2ZSwgUXVlcnlMaXN0IHdpbGwgYWx3YXlzIGJlIGVtcHR5IHdoZW4gb2JzZXJ2ZWQgaW4gdGhlXHJcbiAqIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBUaGUgaW5qZWN0ZWQgb2JqZWN0IGlzIGFuIHVubW9kaWZpYWJsZSBsaXZlIGxpc3QuXHJcbiAqIFNlZSB7QGxpbmsgUXVlcnlMaXN0fSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxudmFyIFF1ZXJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFF1ZXJ5TWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBRdWVyeU1ldGFkYXRhKF9zZWxlY3RvciwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5kZXNjZW5kYW50cywgZGVzY2VuZGFudHMgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYi5maXJzdCwgZmlyc3QgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IF9zZWxlY3RvcjtcclxuICAgICAgICB0aGlzLmRlc2NlbmRhbnRzID0gZGVzY2VuZGFudHM7XHJcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TWV0YWRhdGEucHJvdG90eXBlLCBcImlzVmlld1F1ZXJ5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBhbHdheXMgYGZhbHNlYCB0byBkaWZmZXJlbnRpYXRlIGl0IHdpdGgge0BsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJzZWxlY3RvclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogd2hhdCB0aGlzIGlzIHF1ZXJ5aW5nIGZvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpXzEucmVzb2x2ZUZvcndhcmRSZWYodGhpcy5fc2VsZWN0b3IpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpc1ZhckJpbmRpbmdRdWVyeVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogd2hldGhlciB0aGlzIGlzIHF1ZXJ5aW5nIGZvciBhIHZhcmlhYmxlIGJpbmRpbmcgb3IgYSBkaXJlY3RpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNTdHJpbmcodGhpcy5zZWxlY3Rvcik7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TWV0YWRhdGEucHJvdG90eXBlLCBcInZhckJpbmRpbmdzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZXR1cm5zIGEgbGlzdCBvZiB2YXJpYWJsZSBiaW5kaW5ncyB0aGlzIGlzIHF1ZXJ5aW5nIGZvci5cclxuICAgICAgICAgKiBPbmx5IGFwcGxpY2FibGUgaWYgdGhpcyBpcyBhIHZhcmlhYmxlIGJpbmRpbmdzIHF1ZXJ5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQodGhpcy5zZWxlY3RvciwgbmV3IFJlZ0V4cChcIixcIikpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFF1ZXJ5TWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAUXVlcnkoXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHRoaXMuc2VsZWN0b3IpICsgXCIpXCI7IH07XHJcbiAgICBRdWVyeU1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdCwgT2JqZWN0XSlcclxuICAgIF0sIFF1ZXJ5TWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIFF1ZXJ5TWV0YWRhdGE7XHJcbn0pKG1ldGFkYXRhXzEuRGVwZW5kZW5jeU1ldGFkYXRhKTtcclxuZXhwb3J0cy5RdWVyeU1ldGFkYXRhID0gUXVlcnlNZXRhZGF0YTtcclxuLy8gVE9ETzogYWRkIGFuIGV4YW1wbGUgYWZ0ZXIgQ29udGVudENoaWxkcmVuIGFuZCBWaWV3Q2hpbGRyZW4gYXJlIGluIG1hc3RlclxyXG4vKipcclxuICogQ29uZmlndXJlcyBhIGNvbnRlbnQgcXVlcnkuXHJcbiAqXHJcbiAqIENvbnRlbnQgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYGFmdGVyQ29udGVudEluaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnc29tZURpcidcclxuICogfSlcclxuICogY2xhc3MgU29tZURpciB7XHJcbiAqICAgQENvbnRlbnRDaGlsZHJlbihDaGlsZERpcmVjdGl2ZSkgY29udGVudENoaWxkcmVuOiBRdWVyeUxpc3Q8Q2hpbGREaXJlY3RpdmU+O1xyXG4gKlxyXG4gKiAgIGFmdGVyQ29udGVudEluaXQoKSB7XHJcbiAqICAgICAvLyBjb250ZW50Q2hpbGRyZW4gaXMgc2V0XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250ZW50Q2hpbGRyZW5NZXRhZGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhKF9zZWxlY3RvciwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9zZWxlY3RvciwgeyBkZXNjZW5kYW50czogZGVzY2VuZGFudHMgfSk7XHJcbiAgICB9XHJcbiAgICBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3QsIE9iamVjdF0pXHJcbiAgICBdLCBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gQ29udGVudENoaWxkcmVuTWV0YWRhdGE7XHJcbn0pKFF1ZXJ5TWV0YWRhdGEpO1xyXG5leHBvcnRzLkNvbnRlbnRDaGlsZHJlbk1ldGFkYXRhID0gQ29udGVudENoaWxkcmVuTWV0YWRhdGE7XHJcbi8vIFRPRE86IGFkZCBhbiBleGFtcGxlIGFmdGVyIENvbnRlbnRDaGlsZCBhbmQgVmlld0NoaWxkIGFyZSBpbiBtYXN0ZXJcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxyXG4gKlxyXG4gKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFNvbWVEaXIge1xyXG4gKiAgIEBDb250ZW50Q2hpbGQoQ2hpbGREaXJlY3RpdmUpIGNvbnRlbnRDaGlsZDtcclxuICpcclxuICogICBhZnRlckNvbnRlbnRJbml0KCkge1xyXG4gKiAgICAgLy8gY29udGVudENoaWxkIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBDb250ZW50Q2hpbGRNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udGVudENoaWxkTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250ZW50Q2hpbGRNZXRhZGF0YShfc2VsZWN0b3IpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IHRydWUsIGZpcnN0OiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgQ29udGVudENoaWxkTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIENvbnRlbnRDaGlsZE1ldGFkYXRhKTtcclxuICAgIHJldHVybiBDb250ZW50Q2hpbGRNZXRhZGF0YTtcclxufSkoUXVlcnlNZXRhZGF0YSk7XHJcbmV4cG9ydHMuQ29udGVudENoaWxkTWV0YWRhdGEgPSBDb250ZW50Q2hpbGRNZXRhZGF0YTtcclxuLyoqXHJcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LCBidXQgcXVlcnlpbmcgdGhlIGNvbXBvbmVudCB2aWV3LCBpbnN0ZWFkIG9mXHJcbiAqIHRoZSBjb250ZW50IGNoaWxkcmVuLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZU5zRkhEZjdZanlNNkl6S3hNMWo/cD1wcmV2aWV3KSlcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBAQ29tcG9uZW50KHsuLi59KVxyXG4gKiBAVmlldyh7XHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxpdGVtPiBhIDwvaXRlbT5cclxuICogICAgIDxpdGVtPiBiIDwvaXRlbT5cclxuICogICAgIDxpdGVtPiBjIDwvaXRlbT5cclxuICogICBgXHJcbiAqIH0pXHJcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcclxuICogICBzaG93bjogYm9vbGVhbjtcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIEBRdWVyeShJdGVtKSBpdGVtczpRdWVyeUxpc3Q8SXRlbT4pIHtcclxuICogICAgIGl0ZW1zLm9uQ2hhbmdlKCgpID0+IGNvbnNvbGUubG9nKGl0ZW1zLmxlbmd0aCkpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogU3VwcG9ydHMgdGhlIHNhbWUgcXVlcnlpbmcgcGFyYW1ldGVycyBhcyB7QGxpbmsgUXVlcnlNZXRhZGF0YX0sIGV4Y2VwdFxyXG4gKiBgZGVzY2VuZGFudHNgLiBUaGlzIGFsd2F5cyBxdWVyaWVzIHRoZSB3aG9sZSB2aWV3LlxyXG4gKlxyXG4gKiBBcyBgc2hvd25gIGlzIGZsaXBwZWQgYmV0d2VlbiB0cnVlIGFuZCBmYWxzZSwgaXRlbXMgd2lsbCBjb250YWluIHplcm8gb2Ygb25lXHJcbiAqIGl0ZW1zLlxyXG4gKlxyXG4gKiBTcGVjaWZpZXMgdGhhdCBhIHtAbGluayBRdWVyeUxpc3R9IHNob3VsZCBiZSBpbmplY3RlZC5cclxuICpcclxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiBpdGVyYWJsZSBhbmQgb2JzZXJ2YWJsZSBsaXZlIGxpc3QuXHJcbiAqIFNlZSB7QGxpbmsgUXVlcnlMaXN0fSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxudmFyIFZpZXdRdWVyeU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWaWV3UXVlcnlNZXRhZGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpZXdRdWVyeU1ldGFkYXRhKF9zZWxlY3RvciwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5kZXNjZW5kYW50cywgZGVzY2VuZGFudHMgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYi5maXJzdCwgZmlyc3QgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IGRlc2NlbmRhbnRzLCBmaXJzdDogZmlyc3QgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1F1ZXJ5TWV0YWRhdGEucHJvdG90eXBlLCBcImlzVmlld1F1ZXJ5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBhbHdheXMgYHRydWVgIHRvIGRpZmZlcmVudGlhdGUgaXQgd2l0aCB7QGxpbmsgUXVlcnlNZXRhZGF0YX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFZpZXdRdWVyeU1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQFZpZXdRdWVyeShcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5zZWxlY3RvcikgKyBcIilcIjsgfTtcclxuICAgIFZpZXdRdWVyeU1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdCwgT2JqZWN0XSlcclxuICAgIF0sIFZpZXdRdWVyeU1ldGFkYXRhKTtcclxuICAgIHJldHVybiBWaWV3UXVlcnlNZXRhZGF0YTtcclxufSkoUXVlcnlNZXRhZGF0YSk7XHJcbmV4cG9ydHMuVmlld1F1ZXJ5TWV0YWRhdGEgPSBWaWV3UXVlcnlNZXRhZGF0YTtcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSB2aWV3IHF1ZXJ5LlxyXG4gKlxyXG4gKiBWaWV3IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInLFxyXG4gKiAgIHRlbXBsYXRlVXJsOiAnc29tZVRlbXBsYXRlJyxcclxuICogICBkaXJlY3RpdmVzOiBbSXRlbURpcmVjdGl2ZV1cclxuICogfSlcclxuICogY2xhc3MgU29tZURpciB7XHJcbiAqICAgQFZpZXdDaGlsZHJlbihJdGVtRGlyZWN0aXZlKSB2aWV3Q2hpbGRyZW46IFF1ZXJ5TGlzdDxJdGVtRGlyZWN0aXZlPjtcclxuICpcclxuICogICBhZnRlclZpZXdJbml0KCkge1xyXG4gKiAgICAgLy8gdmlld0NoaWxkcmVuIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBWaWV3Q2hpbGRyZW5NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlld0NoaWxkcmVuTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3Q2hpbGRyZW5NZXRhZGF0YShfc2VsZWN0b3IpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBWaWV3Q2hpbGRyZW5NZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgVmlld0NoaWxkcmVuTWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIFZpZXdDaGlsZHJlbk1ldGFkYXRhO1xyXG59KShWaWV3UXVlcnlNZXRhZGF0YSk7XHJcbmV4cG9ydHMuVmlld0NoaWxkcmVuTWV0YWRhdGEgPSBWaWV3Q2hpbGRyZW5NZXRhZGF0YTtcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgYSB2aWV3IHF1ZXJ5LlxyXG4gKlxyXG4gKiBWaWV3IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBhZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ3NvbWVEaXInLFxyXG4gKiAgIHRlbXBsYXRlVXJsOiAnc29tZVRlbXBsYXRlJyxcclxuICogICBkaXJlY3RpdmVzOiBbSXRlbURpcmVjdGl2ZV1cclxuICogfSlcclxuICogY2xhc3MgU29tZURpciB7XHJcbiAqICAgQFZpZXdDaGlsZChJdGVtRGlyZWN0aXZlKSB2aWV3Q2hpbGQ6SXRlbURpcmVjdGl2ZTtcclxuICpcclxuICogICBhZnRlclZpZXdJbml0KCkge1xyXG4gKiAgICAgLy8gdmlld0NoaWxkIGlzIHNldFxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBWaWV3Q2hpbGRNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlld0NoaWxkTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3Q2hpbGRNZXRhZGF0YShfc2VsZWN0b3IpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IHRydWUsIGZpcnN0OiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgVmlld0NoaWxkTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIFZpZXdDaGlsZE1ldGFkYXRhKTtcclxuICAgIHJldHVybiBWaWV3Q2hpbGRNZXRhZGF0YTtcclxufSkoVmlld1F1ZXJ5TWV0YWRhdGEpO1xyXG5leHBvcnRzLlZpZXdDaGlsZE1ldGFkYXRhID0gVmlld0NoaWxkTWV0YWRhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaS9tZXRhZGF0YScpO1xyXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbicpO1xyXG4vKipcclxuICogRGlyZWN0aXZlcyBhbGxvdyB5b3UgdG8gYXR0YWNoIGJlaGF2aW9yIHRvIGVsZW1lbnRzIGluIHRoZSBET00uXHJcbiAqXHJcbiAqIHtAbGluayBEaXJlY3RpdmVNZXRhZGF0YX1zIHdpdGggYW4gZW1iZWRkZWQgdmlldyBhcmUgY2FsbGVkIHtAbGluayBDb21wb25lbnRNZXRhZGF0YX1zLlxyXG4gKlxyXG4gKiBBIGRpcmVjdGl2ZSBjb25zaXN0cyBvZiBhIHNpbmdsZSBkaXJlY3RpdmUgYW5ub3RhdGlvbiBhbmQgYSBjb250cm9sbGVyIGNsYXNzLiBXaGVuIHRoZVxyXG4gKiBkaXJlY3RpdmUncyBgc2VsZWN0b3JgIG1hdGNoZXNcclxuICogZWxlbWVudHMgaW4gdGhlIERPTSwgdGhlIGZvbGxvd2luZyBzdGVwcyBvY2N1cjpcclxuICpcclxuICogMS4gRm9yIGVhY2ggZGlyZWN0aXZlLCB0aGUgYEVsZW1lbnRJbmplY3RvcmAgYXR0ZW1wdHMgdG8gcmVzb2x2ZSB0aGUgZGlyZWN0aXZlJ3MgY29uc3RydWN0b3JcclxuICogYXJndW1lbnRzLlxyXG4gKiAyLiBBbmd1bGFyIGluc3RhbnRpYXRlcyBkaXJlY3RpdmVzIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCB1c2luZyBgRWxlbWVudEluamVjdG9yYCBpbiBhXHJcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLFxyXG4gKiAgICBhcyBkZWNsYXJlZCBpbiB0aGUgSFRNTC5cclxuICpcclxuICogIyMgVW5kZXJzdGFuZGluZyBIb3cgSW5qZWN0aW9uIFdvcmtzXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgb2YgaW5qZWN0aW9uIHJlc29sdXRpb24uXHJcbiAqIC0gKlByZS1leGlzdGluZyBJbmplY3RvcnMqOlxyXG4gKiAgIC0gVGhlIHRlcm1pbmFsIHtAbGluayBJbmplY3Rvcn0gY2Fubm90IHJlc29sdmUgZGVwZW5kZW5jaWVzLiBJdCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yIG9yLCBpZlxyXG4gKiB0aGUgZGVwZW5kZW5jeSB3YXNcclxuICogICAgIHNwZWNpZmllZCBhcyBgQE9wdGlvbmFsYCwgcmV0dXJucyBgbnVsbGAuXHJcbiAqICAgLSBUaGUgcGxhdGZvcm0gaW5qZWN0b3IgcmVzb2x2ZXMgYnJvd3NlciBzaW5nbGV0b24gcmVzb3VyY2VzLCBzdWNoIGFzOiBjb29raWVzLCB0aXRsZSxcclxuICogbG9jYXRpb24sIGFuZCBvdGhlcnMuXHJcbiAqIC0gKkNvbXBvbmVudCBJbmplY3RvcnMqOiBFYWNoIGNvbXBvbmVudCBpbnN0YW5jZSBoYXMgaXRzIG93biB7QGxpbmsgSW5qZWN0b3J9LCBhbmQgdGhleSBmb2xsb3dcclxuICogdGhlIHNhbWUgcGFyZW50LWNoaWxkIGhpZXJhcmNoeVxyXG4gKiAgICAgYXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZXMgaW4gdGhlIERPTS5cclxuICogLSAqRWxlbWVudCBJbmplY3RvcnMqOiBFYWNoIGNvbXBvbmVudCBpbnN0YW5jZSBoYXMgYSBTaGFkb3cgRE9NLiBXaXRoaW4gdGhlIFNoYWRvdyBET00gZWFjaFxyXG4gKiBlbGVtZW50IGhhcyBhbiBgRWxlbWVudEluamVjdG9yYFxyXG4gKiAgICAgd2hpY2ggZm9sbG93IHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHkgYXMgdGhlIERPTSBlbGVtZW50cyB0aGVtc2VsdmVzLlxyXG4gKlxyXG4gKiBXaGVuIGEgdGVtcGxhdGUgaXMgaW5zdGFudGlhdGVkLCBpdCBhbHNvIG11c3QgaW5zdGFudGlhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZGlyZWN0aXZlcyBpbiBhXHJcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLiBUaGVcclxuICogY3VycmVudCBgRWxlbWVudEluamVjdG9yYCByZXNvbHZlcyB0aGUgY29uc3RydWN0b3IgZGVwZW5kZW5jaWVzIGZvciBlYWNoIGRpcmVjdGl2ZS5cclxuICpcclxuICogQW5ndWxhciB0aGVuIHJlc29sdmVzIGRlcGVuZGVuY2llcyBhcyBmb2xsb3dzLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZVxyXG4gKiB7QGxpbmsgVmlld01ldGFkYXRhfTpcclxuICpcclxuICogMS4gRGVwZW5kZW5jaWVzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcclxuICogMi4gRGVwZW5kZW5jaWVzIG9uIGVsZW1lbnQgaW5qZWN0b3JzIGFuZCB0aGVpciBwYXJlbnRzIHVudGlsIGl0IGVuY291bnRlcnMgYSBTaGFkb3cgRE9NIGJvdW5kYXJ5XHJcbiAqIDMuIERlcGVuZGVuY2llcyBvbiBjb21wb25lbnQgaW5qZWN0b3JzIGFuZCB0aGVpciBwYXJlbnRzIHVudGlsIGl0IGVuY291bnRlcnMgdGhlIHJvb3QgY29tcG9uZW50XHJcbiAqIDQuIERlcGVuZGVuY2llcyBvbiBwcmUtZXhpc3RpbmcgaW5qZWN0b3JzXHJcbiAqXHJcbiAqXHJcbiAqIFRoZSBgRWxlbWVudEluamVjdG9yYCBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBvciBpdCBjYW5cclxuICogZGVsZWdhdGUgdG8gdGhlIHBhcmVudFxyXG4gKiBpbmplY3Rvci5cclxuICpcclxuICogVG8gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGRlY2xhcmUgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBhczpcclxuICogLSBgZGlyZWN0aXZlOkRpcmVjdGl2ZVR5cGVgOiBhIGRpcmVjdGl2ZSBvbiB0aGUgY3VycmVudCBlbGVtZW50IG9ubHlcclxuICogLSBgQEhvc3QoKSBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGFueSBkaXJlY3RpdmUgdGhhdCBtYXRjaGVzIHRoZSB0eXBlIGJldHdlZW4gdGhlIGN1cnJlbnRcclxuICogZWxlbWVudCBhbmQgdGhlXHJcbiAqICAgIFNoYWRvdyBET00gcm9vdC5cclxuICogLSBgQFF1ZXJ5KERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZFxyXG4gKiBkaXJlY3RpdmVzLlxyXG4gKiAtIGBAUXVlcnlEZXNjZW5kYW50cyhEaXJlY3RpdmVUeXBlKSBxdWVyeTpRdWVyeUxpc3Q8RGlyZWN0aXZlVHlwZT5gOiBBIGxpdmUgY29sbGVjdGlvbiBvZiBhbnlcclxuICogY2hpbGQgZGlyZWN0aXZlcy5cclxuICpcclxuICogVG8gaW5qZWN0IGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XHJcbiAqIC0gYGVsZW1lbnQ6IEVsZW1lbnRSZWZgIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byBsb2dpY2FsIGVsZW1lbnQgaW4gdGhlIHZpZXcuXHJcbiAqIC0gYHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWZgIHRvIGNvbnRyb2wgY2hpbGQgdGVtcGxhdGUgaW5zdGFudGlhdGlvbiwgZm9yXHJcbiAqIHtAbGluayBEaXJlY3RpdmVNZXRhZGF0YX0gZGlyZWN0aXZlcyBvbmx5XHJcbiAqIC0gYGJpbmRpbmdQcm9wYWdhdGlvbjogQmluZGluZ1Byb3BhZ2F0aW9uYCB0byBjb250cm9sIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBtb3JlIGdyYW51bGFyIHdheS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVtb25zdHJhdGVzIGhvdyBkZXBlbmRlbmN5IGluamVjdGlvbiByZXNvbHZlcyBjb25zdHJ1Y3RvciBhcmd1bWVudHMgaW5cclxuICogcHJhY3RpY2UuXHJcbiAqXHJcbiAqXHJcbiAqIEFzc3VtZSB0aGlzIEhUTUwgdGVtcGxhdGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZGl2IGRlcGVuZGVuY3k9XCIxXCI+XHJcbiAqICAgPGRpdiBkZXBlbmRlbmN5PVwiMlwiPlxyXG4gKiAgICAgPGRpdiBkZXBlbmRlbmN5PVwiM1wiIG15LWRpcmVjdGl2ZT5cclxuICogICAgICAgPGRpdiBkZXBlbmRlbmN5PVwiNFwiPlxyXG4gKiAgICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjVcIj48L2Rpdj5cclxuICogICAgICAgPC9kaXY+XHJcbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjZcIj48L2Rpdj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIDwvZGl2PlxyXG4gKiA8L2Rpdj5cclxuICogYGBgXHJcbiAqXHJcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBgZGVwZW5kZW5jeWAgZGVjb3JhdG9yIGFuZCBgU29tZVNlcnZpY2VgIGluamVjdGFibGUgY2xhc3MuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBASW5qZWN0YWJsZSgpXHJcbiAqIGNsYXNzIFNvbWVTZXJ2aWNlIHtcclxuICogfVxyXG4gKlxyXG4gKiBARGlyZWN0aXZlKHtcclxuICogICBzZWxlY3RvcjogJ1tkZXBlbmRlbmN5XScsXHJcbiAqICAgaW5wdXRzOiBbXHJcbiAqICAgICAnaWQ6IGRlcGVuZGVuY3knXHJcbiAqICAgXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBEZXBlbmRlbmN5IHtcclxuICogICBpZDpzdHJpbmc7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIExldCdzIHN0ZXAgdGhyb3VnaCB0aGUgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggYE15RGlyZWN0aXZlYCBjb3VsZCBiZSBkZWNsYXJlZC4uLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgTm8gaW5qZWN0aW9uXHJcbiAqXHJcbiAqIEhlcmUgdGhlIGNvbnN0cnVjdG9yIGlzIGRlY2xhcmVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGVyZWZvcmUgbm90aGluZyBpcyBpbmplY3RlZCBpbnRvXHJcbiAqIGBNeURpcmVjdGl2ZWAuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggbm8gZGVwZW5kZW5jaWVzLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgQ29tcG9uZW50LWxldmVsIGluamVjdGlvblxyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3QgYW55IGluamVjdGFibGUgaW5zdGFuY2UgZnJvbSB0aGUgY2xvc2VzdCBjb21wb25lbnQgaW5qZWN0b3Igb3IgYW55IG9mIGl0c1xyXG4gKiBwYXJlbnRzLlxyXG4gKlxyXG4gKiBIZXJlLCB0aGUgY29uc3RydWN0b3IgZGVjbGFyZXMgYSBwYXJhbWV0ZXIsIGBzb21lU2VydmljZWAsIGFuZCBpbmplY3RzIHRoZSBgU29tZVNlcnZpY2VgIHR5cGVcclxuICogZnJvbSB0aGUgcGFyZW50XHJcbiAqIGNvbXBvbmVudCdzIGluamVjdG9yLlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3Rvcihzb21lU2VydmljZTogU29tZVNlcnZpY2UpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgZGVwZW5kZW5jeSBvbiBgU29tZVNlcnZpY2VgLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgZGlyZWN0aXZlIGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxyXG4gKlxyXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XHJcbiAqICAgICBleHBlY3QoZGVwZW5kZW5jeS5pZCkudG9FcXVhbCgzKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGBEZXBlbmRlbmN5YCBkZWNsYXJlZCBhdCB0aGUgc2FtZSBlbGVtZW50LCBpbiB0aGlzIGNhc2VcclxuICogYGRlcGVuZGVuY3k9XCIzXCJgLlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgZGlyZWN0aXZlIGZyb20gYW55IGFuY2VzdG9yIGVsZW1lbnRzXHJcbiAqXHJcbiAqIERpcmVjdGl2ZXMgY2FuIGluamVjdCBvdGhlciBkaXJlY3RpdmVzIGRlY2xhcmVkIG9uIGFueSBhbmNlc3RvciBlbGVtZW50IChpbiB0aGUgY3VycmVudCBTaGFkb3dcclxuICogRE9NKSwgaS5lLiBvbiB0aGUgY3VycmVudCBlbGVtZW50LCB0aGVcclxuICogcGFyZW50IGVsZW1lbnQsIG9yIGl0cyBwYXJlbnRzLlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihASG9zdCgpIGRlcGVuZGVuY3k6IERlcGVuZGVuY3kpIHtcclxuICogICAgIGV4cGVjdChkZXBlbmRlbmN5LmlkKS50b0VxdWFsKDIpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogYEBIb3N0YCBjaGVja3MgdGhlIGN1cnJlbnQgZWxlbWVudCwgdGhlIHBhcmVudCwgYXMgd2VsbCBhcyBpdHMgcGFyZW50cyByZWN1cnNpdmVseS4gSWZcclxuICogYGRlcGVuZGVuY3k9XCIyXCJgIGRpZG4ndFxyXG4gKiBleGlzdCBvbiB0aGUgZGlyZWN0IHBhcmVudCwgdGhpcyBpbmplY3Rpb24gd291bGRcclxuICogaGF2ZSByZXR1cm5lZFxyXG4gKiBgZGVwZW5kZW5jeT1cIjFcImAuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyBJbmplY3RpbmcgYSBsaXZlIGNvbGxlY3Rpb24gb2YgZGlyZWN0IGNoaWxkIGRpcmVjdGl2ZXNcclxuICpcclxuICpcclxuICogQSBkaXJlY3RpdmUgY2FuIGFsc28gcXVlcnkgZm9yIG90aGVyIGNoaWxkIGRpcmVjdGl2ZXMuIFNpbmNlIHBhcmVudCBkaXJlY3RpdmVzIGFyZSBpbnN0YW50aWF0ZWRcclxuICogYmVmb3JlIGNoaWxkIGRpcmVjdGl2ZXMsIGEgZGlyZWN0aXZlIGNhbid0IHNpbXBseSBpbmplY3QgdGhlIGxpc3Qgb2YgY2hpbGQgZGlyZWN0aXZlcy4gSW5zdGVhZCxcclxuICogdGhlIGRpcmVjdGl2ZSBpbmplY3RzIGEge0BsaW5rIFF1ZXJ5TGlzdH0sIHdoaWNoIHVwZGF0ZXMgaXRzIGNvbnRlbnRzIGFzIGNoaWxkcmVuIGFyZSBhZGRlZCxcclxuICogcmVtb3ZlZCwgb3IgbW92ZWQgYnkgYSBkaXJlY3RpdmUgdGhhdCB1c2VzIGEge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IHN1Y2ggYXMgYSBgbmctZm9yYCwgYW5cclxuICogYG5nLWlmYCwgb3IgYW4gYG5nLXN3aXRjaGAuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShEZXBlbmRlbmN5KSBkZXBlbmRlbmNpZXM6UXVlcnlMaXN0PERlcGVuZGVuY3k+KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIHtAbGluayBRdWVyeUxpc3R9IHdoaWNoIGNvbnRhaW5zIGBEZXBlbmRlbmN5YCA0IGFuZFxyXG4gKiA2LiBIZXJlLCBgRGVwZW5kZW5jeWAgNSB3b3VsZCBub3QgYmUgaW5jbHVkZWQsIGJlY2F1c2UgaXQgaXMgbm90IGEgZGlyZWN0IGNoaWxkLlxyXG4gKlxyXG4gKiAjIyMgSW5qZWN0aW5nIGEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRlc2NlbmRhbnQgZGlyZWN0aXZlc1xyXG4gKlxyXG4gKiBCeSBwYXNzaW5nIHRoZSBkZXNjZW5kYW50IGZsYWcgdG8gYEBRdWVyeWAgYWJvdmUsIHdlIGNhbiBpbmNsdWRlIHRoZSBjaGlsZHJlbiBvZiB0aGUgY2hpbGRcclxuICogZWxlbWVudHMuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcclxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShEZXBlbmRlbmN5LCB7ZGVzY2VuZGFudHM6IHRydWV9KSBkZXBlbmRlbmNpZXM6UXVlcnlMaXN0PERlcGVuZGVuY3k+KSB7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIFF1ZXJ5IHdoaWNoIHdvdWxkIGNvbnRhaW4gYERlcGVuZGVuY3lgIDQsIDUgYW5kIDYuXHJcbiAqXHJcbiAqICMjIyBPcHRpb25hbCBpbmplY3Rpb25cclxuICpcclxuICogVGhlIG5vcm1hbCBiZWhhdmlvciBvZiBkaXJlY3RpdmVzIGlzIHRvIHJldHVybiBhbiBlcnJvciB3aGVuIGEgc3BlY2lmaWVkIGRlcGVuZGVuY3kgY2Fubm90IGJlXHJcbiAqIHJlc29sdmVkLiBJZiB5b3VcclxuICogd291bGQgbGlrZSB0byBpbmplY3QgYG51bGxgIG9uIHVucmVzb2x2ZWQgZGVwZW5kZW5jeSBpbnN0ZWFkLCB5b3UgY2FuIGFubm90YXRlIHRoYXQgZGVwZW5kZW5jeVxyXG4gKiB3aXRoIGBAT3B0aW9uYWwoKWAuXHJcbiAqIFRoaXMgZXhwbGljaXRseSBwZXJtaXRzIHRoZSBhdXRob3Igb2YgYSB0ZW1wbGF0ZSB0byB0cmVhdCBzb21lIG9mIHRoZSBzdXJyb3VuZGluZyBkaXJlY3RpdmVzIGFzXHJcbiAqIG9wdGlvbmFsLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXHJcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcclxuICogICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBkZXBlbmRlbmN5OkRlcGVuZGVuY3kpIHtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgYERlcGVuZGVuY3lgIGRpcmVjdGl2ZSBmb3VuZCBvbiB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gKiBJZiBub25lIGNhbiBiZVxyXG4gKiBmb3VuZCwgdGhlIGluamVjdG9yIHN1cHBsaWVzIGBudWxsYCBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEhlcmUgd2UgdXNlIGEgZGVjb3JhdG9yIGRpcmVjdGl2ZSB0byBzaW1wbHkgZGVmaW5lIGJhc2ljIHRvb2wtdGlwIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBgYGBcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdbdG9vbHRpcF0nLFxyXG4gKiAgIGlucHV0czogW1xyXG4gKiAgICAgJ3RleHQ6IHRvb2x0aXAnXHJcbiAqICAgXSxcclxuICogICBob3N0OiB7XHJcbiAqICAgICAnKG1vdXNlZW50ZXIpJzogJ29uTW91c2VFbnRlcigpJyxcclxuICogICAgICcobW91c2VsZWF2ZSknOiAnb25Nb3VzZUxlYXZlKCknXHJcbiAqICAgfVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBUb29sdGlwe1xyXG4gKiAgIHRleHQ6c3RyaW5nO1xyXG4gKiAgIG92ZXJsYXk6T3ZlcmxheTsgLy8gTk9UIFlFVCBJTVBMRU1FTlRFRFxyXG4gKiAgIG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyOyAvLyBOT1QgWUVUIElNUExFTUVOVEVEXHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3Iob3ZlcmxheU1hbmFnZXI6T3ZlcmxheU1hbmFnZXIpIHtcclxuICogICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIG9uTW91c2VFbnRlcigpIHtcclxuICogICAgIC8vIGV4YWN0IHNpZ25hdHVyZSB0byBiZSBkZXRlcm1pbmVkXHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSB0aGlzLm92ZXJsYXlNYW5hZ2VyLm9wZW4odGV4dCwgLi4uKTtcclxuICogICB9XHJcbiAqXHJcbiAqICAgb25Nb3VzZUxlYXZlKCkge1xyXG4gKiAgICAgdGhpcy5vdmVybGF5LmNsb3NlKCk7XHJcbiAqICAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICogSW4gb3VyIEhUTUwgdGVtcGxhdGUsIHdlIGNhbiB0aGVuIGFkZCB0aGlzIGJlaGF2aW9yIHRvIGEgYDxkaXY+YCBvciBhbnkgb3RoZXIgZWxlbWVudCB3aXRoIHRoZVxyXG4gKiBgdG9vbHRpcGAgc2VsZWN0b3IsXHJcbiAqIGxpa2Ugc286XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZGl2IHRvb2x0aXA9XCJzb21lIHRleHQgaGVyZVwiPjwvZGl2PlxyXG4gKiBgYGBcclxuICpcclxuICogRGlyZWN0aXZlcyBjYW4gYWxzbyBjb250cm9sIHRoZSBpbnN0YW50aWF0aW9uLCBkZXN0cnVjdGlvbiwgYW5kIHBvc2l0aW9uaW5nIG9mIGlubGluZSB0ZW1wbGF0ZVxyXG4gKiBlbGVtZW50czpcclxuICpcclxuICogQSBkaXJlY3RpdmUgdXNlcyBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSB0byBpbnN0YW50aWF0ZSwgaW5zZXJ0LCBtb3ZlLCBhbmQgZGVzdHJveSB2aWV3cyBhdFxyXG4gKiBydW50aW1lLlxyXG4gKiBUaGUge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IGlzIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQsIGFuZCByZXByZXNlbnRzIGFcclxuICogbG9jYXRpb24gaW4gdGhlIGN1cnJlbnQgdmlld1xyXG4gKiB3aGVyZSB0aGVzZSBhY3Rpb25zIGFyZSBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIFZpZXdzIGFyZSBhbHdheXMgY3JlYXRlZCBhcyBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCB7QGxpbmsgVmlld01ldGFkYXRhfSwgYW5kIGFzIHNpYmxpbmdzIG9mIHRoZVxyXG4gKiBgPHRlbXBsYXRlPmAgZWxlbWVudC4gVGh1cyBhXHJcbiAqIGRpcmVjdGl2ZSBpbiBhIGNoaWxkIHZpZXcgY2Fubm90IGluamVjdCB0aGUgZGlyZWN0aXZlIHRoYXQgY3JlYXRlZCBpdC5cclxuICpcclxuICogU2luY2UgZGlyZWN0aXZlcyB0aGF0IGNyZWF0ZSB2aWV3cyB2aWEgVmlld0NvbnRhaW5lcnMgYXJlIGNvbW1vbiBpbiBBbmd1bGFyLCBhbmQgdXNpbmcgdGhlIGZ1bGxcclxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgc3ludGF4IGlzIHdvcmR5LCBBbmd1bGFyXHJcbiAqIGFsc28gc3VwcG9ydHMgYSBzaG9ydGhhbmQgbm90YXRpb246IGA8bGkgKmZvbz1cImJhclwiPmAgYW5kIGA8bGkgdGVtcGxhdGU9XCJmb286IGJhclwiPmAgYXJlXHJcbiAqIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqIFRodXMsXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPGxpICpmb289XCJiYXJcIiB0aXRsZT1cInRleHRcIj48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogRXhwYW5kcyBpbiB1c2UgdG86XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPHRlbXBsYXRlIFtmb29dPVwiYmFyXCI+XHJcbiAqICAgICA8bGkgdGl0bGU9XCJ0ZXh0XCI+PC9saT5cclxuICogICA8L3RlbXBsYXRlPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogTm90aWNlIHRoYXQgYWx0aG91Z2ggdGhlIHNob3J0aGFuZCBwbGFjZXMgYCpmb289XCJiYXJcImAgd2l0aGluIHRoZSBgPGxpPmAgZWxlbWVudCwgdGhlIGJpbmRpbmcgZm9yXHJcbiAqIHRoZSBkaXJlY3RpdmVcclxuICogY29udHJvbGxlciBpcyBjb3JyZWN0bHkgaW5zdGFudGlhdGVkIG9uIHRoZSBgPHRlbXBsYXRlPmAgZWxlbWVudCByYXRoZXIgdGhhbiB0aGUgYDxsaT5gIGVsZW1lbnQuXHJcbiAqXHJcbiAqICMjIExpZmVjeWNsZSBob29rc1xyXG4gKlxyXG4gKiBXaGVuIHRoZSBkaXJlY3RpdmUgY2xhc3MgaW1wbGVtZW50cyBzb21lIHtAbGluayBhbmd1bGFyMi9saWZlY3ljbGVfaG9va3N9IHRoZSBjYWxsYmFja3MgYXJlXHJcbiAqIGNhbGxlZCBieSB0aGUgY2hhbmdlIGRldGVjdGlvbiBhdCBkZWZpbmVkIHBvaW50cyBpbiB0aW1lIGR1cmluZyB0aGUgbGlmZSBvZiB0aGUgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIExldCdzIHN1cHBvc2Ugd2Ugd2FudCB0byBpbXBsZW1lbnQgdGhlIGB1bmxlc3NgIGJlaGF2aW9yLCB0byBjb25kaXRpb25hbGx5IGluY2x1ZGUgYSB0ZW1wbGF0ZS5cclxuICpcclxuICogSGVyZSBpcyBhIHNpbXBsZSBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VycyBvbiBhbiBgdW5sZXNzYCBzZWxlY3RvcjpcclxuICpcclxuICogYGBgXHJcbiAqIEBEaXJlY3RpdmUoe1xyXG4gKiAgIHNlbGVjdG9yOiAnW3VubGVzc10nLFxyXG4gKiAgIGlucHV0czogWyd1bmxlc3MnXVxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgVW5sZXNzIHtcclxuICogICB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gKiAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjtcclxuICogICBwcmV2Q29uZGl0aW9uOiBib29sZWFuO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZikge1xyXG4gKiAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcclxuICogICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICogICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IG51bGw7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIHNldCB1bmxlc3MobmV3Q29uZGl0aW9uKSB7XHJcbiAqICAgICBpZiAobmV3Q29uZGl0aW9uICYmIChpc0JsYW5rKHRoaXMucHJldkNvbmRpdGlvbikgfHwgIXRoaXMucHJldkNvbmRpdGlvbikpIHtcclxuICogICAgICAgdGhpcy5wcmV2Q29uZGl0aW9uID0gdHJ1ZTtcclxuICogICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XHJcbiAqICAgICB9IGVsc2UgaWYgKCFuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5wcmV2Q29uZGl0aW9uKSB8fCB0aGlzLnByZXZDb25kaXRpb24pKSB7XHJcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IGZhbHNlO1xyXG4gKiAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlKHRoaXMudGVtcGxhdGVSZWYpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogV2UgY2FuIHRoZW4gdXNlIHRoaXMgYHVubGVzc2Agc2VsZWN0b3IgaW4gYSB0ZW1wbGF0ZTpcclxuICogYGBgXHJcbiAqIDx1bD5cclxuICogICA8bGkgKnVubGVzcz1cImV4cHJcIj48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogT25jZSB0aGUgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyB0aGUgY2hpbGQgdmlldywgdGhlIHNob3J0aGFuZCBub3RhdGlvbiBmb3IgdGhlIHRlbXBsYXRlIGV4cGFuZHNcclxuICogYW5kIHRoZSByZXN1bHQgaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8dWw+XHJcbiAqICAgPHRlbXBsYXRlIFt1bmxlc3NdPVwiZXhwXCI+XHJcbiAqICAgICA8bGk+PC9saT5cclxuICogICA8L3RlbXBsYXRlPlxyXG4gKiAgIDxsaT48L2xpPlxyXG4gKiA8L3VsPlxyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSBhbHNvIHRoYXQgYWx0aG91Z2ggdGhlIGA8bGk+PC9saT5gIHRlbXBsYXRlIHN0aWxsIGV4aXN0cyBpbnNpZGUgdGhlIGA8dGVtcGxhdGU+PC90ZW1wbGF0ZT5gLFxyXG4gKiB0aGUgaW5zdGFudGlhdGVkXHJcbiAqIHZpZXcgb2NjdXJzIG9uIHRoZSBzZWNvbmQgYDxsaT48L2xpPmAgd2hpY2ggaXMgYSBzaWJsaW5nIHRvIHRoZSBgPHRlbXBsYXRlPmAgZWxlbWVudC5cclxuICovXHJcbnZhciBEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGlyZWN0aXZlTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBzZWxlY3RvciA9IF9iLnNlbGVjdG9yLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBwcm9wZXJ0aWVzID0gX2IucHJvcGVydGllcywgZXZlbnRzID0gX2IuZXZlbnRzLCBob3N0ID0gX2IuaG9zdCwgYmluZGluZ3MgPSBfYi5iaW5kaW5ncywgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBtb2R1bGVJZCA9IF9iLm1vZHVsZUlkLCBxdWVyaWVzID0gX2IucXVlcmllcztcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5faW5wdXRzID0gaW5wdXRzO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuX291dHB1dHMgPSBvdXRwdXRzO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50cztcclxuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xyXG4gICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcclxuICAgICAgICB0aGlzLm1vZHVsZUlkID0gbW9kdWxlSWQ7XHJcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gcXVlcmllcztcclxuICAgICAgICB0aGlzLl9wcm92aWRlcnMgPSBwcm92aWRlcnM7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBiaW5kaW5ncztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUsIFwiaW5wdXRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbnVtZXJhdGVzIHRoZSBzZXQgb2YgZGF0YS1ib3VuZCBpbnB1dCBwcm9wZXJ0aWVzIGZvciBhIGRpcmVjdGl2ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgaW5wdXQgcHJvcGVydGllcyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBgaW5wdXRzYCBwcm9wZXJ0eSBkZWZpbmVzIGEgc2V0IG9mIGBkaXJlY3RpdmVQcm9wZXJ0eWAgdG8gYGJpbmRpbmdQcm9wZXJ0eWBcclxuICAgICAgICAgKiBjb25maWd1cmF0aW9uOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBgZGlyZWN0aXZlUHJvcGVydHlgIHNwZWNpZmllcyB0aGUgY29tcG9uZW50IHByb3BlcnR5IHdoZXJlIHRoZSB2YWx1ZSBpcyB3cml0dGVuLlxyXG4gICAgICAgICAqIC0gYGJpbmRpbmdQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBET00gcHJvcGVydHkgd2hlcmUgdGhlIHZhbHVlIGlzIHJlYWQgZnJvbS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYGJpbmRpbmdQcm9wZXJ0eWAgaXMgbm90IHByb3ZpZGVkLCBpdCBpcyBhc3N1bWVkIHRvIGJlIGVxdWFsIHRvIGBkaXJlY3RpdmVQcm9wZXJ0eWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvaXZoZlhZP3A9cHJldmlldykpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCB3aXRoIHR3byBkYXRhLWJvdW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgICAgICogQENvbXBvbmVudCh7XHJcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2JhbmstYWNjb3VudCcsXHJcbiAgICAgICAgICogICBpbnB1dHM6IFsnYmFua05hbWUnLCAnaWQ6IGFjY291bnQtaWQnXSxcclxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgICogICAgIEJhbmsgTmFtZToge3tiYW5rTmFtZX19XHJcbiAgICAgICAgICogICAgIEFjY291bnQgSWQ6IHt7aWR9fVxyXG4gICAgICAgICAqICAgYFxyXG4gICAgICAgICAqIH0pXHJcbiAgICAgICAgICogY2xhc3MgQmFua0FjY291bnQge1xyXG4gICAgICAgICAqICAgYmFua05hbWU6IHN0cmluZztcclxuICAgICAgICAgKiAgIGlkOiBzdHJpbmc7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgIC8vIHRoaXMgcHJvcGVydHkgaXMgbm90IGJvdW5kLCBhbmQgd29uJ3QgYmUgYXV0b21hdGljYWxseSB1cGRhdGVkIGJ5IEFuZ3VsYXJcclxuICAgICAgICAgKiAgIG5vcm1hbGl6ZWRCYW5rTmFtZTogc3RyaW5nO1xyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xyXG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGBcclxuICAgICAgICAgKiAgICAgPGJhbmstYWNjb3VudCBiYW5rLW5hbWU9XCJSQkNcIiBhY2NvdW50LWlkPVwiNDc0N1wiPjwvYmFuay1hY2NvdW50PlxyXG4gICAgICAgICAqICAgYCxcclxuICAgICAgICAgKiAgIGRpcmVjdGl2ZXM6IFtCYW5rQWNjb3VudF1cclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqIGNsYXNzIEFwcCB7fVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYm9vdHN0cmFwKEFwcCk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcHJvcGVydGllcykgJiYgdGhpcy5fcHJvcGVydGllcy5sZW5ndGggPiAwID8gdGhpcy5fcHJvcGVydGllcyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcInByb3BlcnRpZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbnB1dHM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJvdXRwdXRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbnVtZXJhdGVzIHRoZSBzZXQgb2YgZXZlbnQtYm91bmQgb3V0cHV0IHByb3BlcnRpZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGFuIG91dHB1dCBwcm9wZXJ0eSBlbWl0cyBhbiBldmVudCwgYW4gZXZlbnQgaGFuZGxlciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50XHJcbiAgICAgICAgICogdGhlIHRlbXBsYXRlIGlzIGludm9rZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgYG91dHB1dHNgIHByb3BlcnR5IGRlZmluZXMgYSBzZXQgb2YgYGRpcmVjdGl2ZVByb3BlcnR5YCB0byBgYmluZGluZ1Byb3BlcnR5YFxyXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb246XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtIGBkaXJlY3RpdmVQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBjb21wb25lbnQgcHJvcGVydHkgdGhhdCBlbWl0cyBldmVudHMuXHJcbiAgICAgICAgICogLSBgYmluZGluZ1Byb3BlcnR5YCBzcGVjaWZpZXMgdGhlIERPTSBwcm9wZXJ0eSB0aGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB0by5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9kNUNOcTc/cD1wcmV2aWV3KSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAgICAgKiBARGlyZWN0aXZlKHtcclxuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnaW50ZXJ2YWwtZGlyJyxcclxuICAgICAgICAgKiAgIG91dHB1dHM6IFsnZXZlcnlTZWNvbmQnLCAnZml2ZTVTZWNzOiBldmVyeUZpdmVTZWNvbmRzJ11cclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqIGNsYXNzIEludGVydmFsRGlyIHtcclxuICAgICAgICAgKiAgIGV2ZXJ5U2Vjb25kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgICAqICAgZml2ZTVTZWNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ldmVyeVNlY29uZC5uZXh0KFwiZXZlbnRcIiksIDEwMDApO1xyXG4gICAgICAgICAqICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmZpdmU1U2Vjcy5uZXh0KFwiZXZlbnRcIiksIDUwMDApO1xyXG4gICAgICAgICAqICAgfVxyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xyXG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGBcclxuICAgICAgICAgKiAgICAgPGludGVydmFsLWRpciAoZXZlcnktc2Vjb25kKT1cImV2ZXJ5U2Vjb25kKClcIiAoZXZlcnktZml2ZS1zZWNvbmRzKT1cImV2ZXJ5Rml2ZVNlY29uZHMoKVwiPlxyXG4gICAgICAgICAqICAgICA8L2ludGVydmFsLWRpcj5cclxuICAgICAgICAgKiAgIGAsXHJcbiAgICAgICAgICogICBkaXJlY3RpdmVzOiBbSW50ZXJ2YWxEaXJdXHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiBjbGFzcyBBcHAge1xyXG4gICAgICAgICAqICAgZXZlcnlTZWNvbmQoKSB7IGNvbnNvbGUubG9nKCdzZWNvbmQnKTsgfVxyXG4gICAgICAgICAqICAgZXZlcnlGaXZlU2Vjb25kcygpIHsgY29uc29sZS5sb2coJ2ZpdmUgc2Vjb25kcycpOyB9XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqIGJvb3RzdHJhcChBcHApO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2V2ZW50cykgJiYgdGhpcy5fZXZlbnRzLmxlbmd0aCA+IDAgPyB0aGlzLl9ldmVudHMgOiB0aGlzLl9vdXRwdXRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJldmVudHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vdXRwdXRzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUsIFwicHJvdmlkZXJzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBzZXQgb2YgaW5qZWN0YWJsZSBvYmplY3RzIHRoYXQgYXJlIHZpc2libGUgdG8gYSBEaXJlY3RpdmUgYW5kIGl0cyBsaWdodCBET01cclxuICAgICAgICAgKiBjaGlsZHJlbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBjbGFzcyB0aGF0IGNhbiBiZSBpbmplY3RlZDpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqIGNsYXNzIEdyZWV0ZXIge1xyXG4gICAgICAgICAqICAgIGdyZWV0KG5hbWU6c3RyaW5nKSB7XHJcbiAgICAgICAgICogICAgICByZXR1cm4gJ0hlbGxvICcgKyBuYW1lICsgJyEnO1xyXG4gICAgICAgICAqICAgIH1cclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBARGlyZWN0aXZlKHtcclxuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gICAgICAgICAqICAgYmluZGluZ3M6IFtcclxuICAgICAgICAgKiAgICAgR3JlZXRlclxyXG4gICAgICAgICAqICAgXVxyXG4gICAgICAgICAqIH0pXHJcbiAgICAgICAgICogY2xhc3MgSGVsbG9Xb3JsZCB7XHJcbiAgICAgICAgICogICBncmVldGVyOkdyZWV0ZXI7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKGdyZWV0ZXI6R3JlZXRlcikge1xyXG4gICAgICAgICAqICAgICB0aGlzLmdyZWV0ZXIgPSBncmVldGVyO1xyXG4gICAgICAgICAqICAgfVxyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fYmluZGluZ3MpICYmIHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA+IDAgPyB0aGlzLl9iaW5kaW5ncyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImJpbmRpbmdzXCIsIHtcclxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJvdmlkZXJzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERpcmVjdGl2ZU1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBEaXJlY3RpdmVNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gRGlyZWN0aXZlTWV0YWRhdGE7XHJcbn0pKG1ldGFkYXRhXzEuSW5qZWN0YWJsZU1ldGFkYXRhKTtcclxuZXhwb3J0cy5EaXJlY3RpdmVNZXRhZGF0YSA9IERpcmVjdGl2ZU1ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZSByZXVzYWJsZSBVSSBidWlsZGluZyBibG9ja3MgZm9yIGFuIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBFYWNoIEFuZ3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGEgc2luZ2xlIGBAQ29tcG9uZW50YCBhbmQgYXQgbGVhc3Qgb25lIGBAVmlld2AgYW5ub3RhdGlvbi4gVGhlXHJcbiAqIGBAQ29tcG9uZW50YFxyXG4gKiBhbm5vdGF0aW9uIHNwZWNpZmllcyB3aGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgYW5kIHdoaWNoIHByb3BlcnRpZXMgYW5kIGhvc3RMaXN0ZW5lcnMgaXRcclxuICogYmluZHMgdG8uXHJcbiAqXHJcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCBBbmd1bGFyXHJcbiAqIC0gY3JlYXRlcyBhIHNoYWRvdyBET00gZm9yIHRoZSBjb21wb25lbnQuXHJcbiAqIC0gbG9hZHMgdGhlIHNlbGVjdGVkIHRlbXBsYXRlIGludG8gdGhlIHNoYWRvdyBET00uXHJcbiAqIC0gY3JlYXRlcyBhbGwgdGhlIGluamVjdGFibGUgb2JqZWN0cyBjb25maWd1cmVkIHdpdGggYHByb3ZpZGVyc2AgYW5kIGB2aWV3UHJvdmlkZXJzYC5cclxuICpcclxuICogQWxsIHRlbXBsYXRlIGV4cHJlc3Npb25zIGFuZCBzdGF0ZW1lbnRzIGFyZSB0aGVuIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQFZpZXdgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgVmlld01ldGFkYXRhfS5cclxuICpcclxuICogIyMgTGlmZWN5Y2xlIGhvb2tzXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGNvbXBvbmVudCBjbGFzcyBpbXBsZW1lbnRzIHNvbWUge0BsaW5rIGFuZ3VsYXIyL2xpZmVjeWNsZV9ob29rc30gdGhlIGNhbGxiYWNrcyBhcmVcclxuICogY2FsbGVkIGJ5IHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGF0IGRlZmluZWQgcG9pbnRzIGluIHRpbWUgZHVyaW5nIHRoZSBsaWZlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJ1xyXG4gKiB9KVxyXG4gKiBjbGFzcyBHcmVldCB7XHJcbiAqICAgbmFtZTogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50TWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbXBvbmVudE1ldGFkYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50TWV0YWRhdGEoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgcHJvcGVydGllcyA9IF9iLnByb3BlcnRpZXMsIGV2ZW50cyA9IF9iLmV2ZW50cywgaG9zdCA9IF9iLmhvc3QsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIG1vZHVsZUlkID0gX2IubW9kdWxlSWQsIGJpbmRpbmdzID0gX2IuYmluZGluZ3MsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld0JpbmRpbmdzID0gX2Iudmlld0JpbmRpbmdzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgX2MgPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGNoYW5nZURldGVjdGlvbiA9IF9jID09PSB2b2lkIDAgPyBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCA6IF9jLCBxdWVyaWVzID0gX2IucXVlcmllcywgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzLCBzdHlsZXMgPSBfYi5zdHlsZXMsIGRpcmVjdGl2ZXMgPSBfYi5kaXJlY3RpdmVzLCBwaXBlcyA9IF9iLnBpcGVzLCBlbmNhcHN1bGF0aW9uID0gX2IuZW5jYXBzdWxhdGlvbjtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcclxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXHJcbiAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHMsXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxyXG4gICAgICAgICAgICBob3N0OiBob3N0LFxyXG4gICAgICAgICAgICBleHBvcnRBczogZXhwb3J0QXMsXHJcbiAgICAgICAgICAgIG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuICAgICAgICAgICAgYmluZGluZ3M6IGJpbmRpbmdzLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcclxuICAgICAgICAgICAgcXVlcmllczogcXVlcmllc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdQcm92aWRlcnMgPSB2aWV3UHJvdmlkZXJzO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdCaW5kaW5ncyA9IHZpZXdCaW5kaW5ncztcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xyXG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50TWV0YWRhdGEucHJvdG90eXBlLCBcInZpZXdQcm92aWRlcnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgdGhlIHNldCBvZiBpbmplY3RhYmxlIG9iamVjdHMgdGhhdCBhcmUgdmlzaWJsZSB0byBpdHMgdmlldyBET00gY2hpbGRyZW4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAjIyBTaW1wbGUgRXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSGVyZSBpcyBhbiBleGFtcGxlIG9mIGEgY2xhc3MgdGhhdCBjYW4gYmUgaW5qZWN0ZWQ6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKiBjbGFzcyBHcmVldGVyIHtcclxuICAgICAgICAgKiAgICBncmVldChuYW1lOnN0cmluZykge1xyXG4gICAgICAgICAqICAgICAgcmV0dXJuICdIZWxsbyAnICsgbmFtZSArICchJztcclxuICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICogfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICogICBzZWxlY3RvcjogJ25lZWRzLWdyZWV0ZXInXHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiBjbGFzcyBOZWVkc0dyZWV0ZXIge1xyXG4gICAgICAgICAqICAgZ3JlZXRlcjpHcmVldGVyO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihncmVldGVyOkdyZWV0ZXIpIHtcclxuICAgICAgICAgKiAgICAgdGhpcy5ncmVldGVyID0gZ3JlZXRlcjtcclxuICAgICAgICAgKiAgIH1cclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAQ29tcG9uZW50KHtcclxuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gICAgICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xyXG4gICAgICAgICAqICAgICBHcmVldGVyXHJcbiAgICAgICAgICogICBdLFxyXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGA8bmVlZHMtZ3JlZXRlcj48L25lZWRzLWdyZWV0ZXI+YCxcclxuICAgICAgICAgKiAgIGRpcmVjdGl2ZXM6IFtOZWVkc0dyZWV0ZXJdXHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiBjbGFzcyBIZWxsb1dvcmxkIHtcclxuICAgICAgICAgKiB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fdmlld0JpbmRpbmdzKSAmJiB0aGlzLl92aWV3QmluZGluZ3MubGVuZ3RoID4gMCA/IHRoaXMuX3ZpZXdCaW5kaW5ncyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UHJvdmlkZXJzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudE1ldGFkYXRhLnByb3RvdHlwZSwgXCJ2aWV3QmluZGluZ3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3UHJvdmlkZXJzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvbXBvbmVudE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBDb21wb25lbnRNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gQ29tcG9uZW50TWV0YWRhdGE7XHJcbn0pKERpcmVjdGl2ZU1ldGFkYXRhKTtcclxuZXhwb3J0cy5Db21wb25lbnRNZXRhZGF0YSA9IENvbXBvbmVudE1ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZSByZXVzYWJsZSBwaXBlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBAUGlwZSh7XHJcbiAqICAgbmFtZTogJ2xvd2VyY2FzZSdcclxuICogfSlcclxuICogY2xhc3MgTG93ZXJjYXNlIHtcclxuICogICB0cmFuc2Zvcm0odiwgYXJncykgeyByZXR1cm4gdi50b0xvd2VyQ2FzZSgpOyB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgUGlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQaXBlTWV0YWRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQaXBlTWV0YWRhdGEoX2EpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHB1cmUgPSBfYS5wdXJlO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5fcHVyZSA9IHB1cmU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGlwZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJwdXJlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcHVyZSkgPyB0aGlzLl9wdXJlIDogdHJ1ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQaXBlTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIFBpcGVNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gUGlwZU1ldGFkYXRhO1xyXG59KShtZXRhZGF0YV8xLkluamVjdGFibGVNZXRhZGF0YSk7XHJcbmV4cG9ydHMuUGlwZU1ldGFkYXRhID0gUGlwZU1ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZXMgYSBkYXRhLWJvdW5kIGlucHV0IHByb3BlcnR5LlxyXG4gKlxyXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyBkYXRhLWJvdW5kIHByb3BlcnRpZXMgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAqXHJcbiAqIGBJbnB1dE1ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWVcclxuICogdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBXaGVuIG5vdCBwcm92aWRlZCxcclxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCB3aXRoIHR3byBpbnB1dCBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYmFuay1hY2NvdW50JyxcclxuICogICB0ZW1wbGF0ZTogYFxyXG4gKiAgICAgQmFuayBOYW1lOiB7e2JhbmtOYW1lfX1cclxuICogICAgIEFjY291bnQgSWQ6IHt7aWR9fVxyXG4gKiAgIGBcclxuICogfSlcclxuICogY2xhc3MgQmFua0FjY291bnQge1xyXG4gKiAgIEBJbnB1dCgpIGJhbmtOYW1lOiBzdHJpbmc7XHJcbiAqICAgQElucHV0KCdhY2NvdW50LWlkJykgaWQ6IHN0cmluZztcclxuICpcclxuICogICAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCBib3VuZCwgYW5kIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSBBbmd1bGFyXHJcbiAqICAgbm9ybWFsaXplZEJhbmtOYW1lOiBzdHJpbmc7XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8YmFuay1hY2NvdW50IGJhbmstbmFtZT1cIlJCQ1wiIGFjY291bnQtaWQ9XCI0NzQ3XCI+PC9iYW5rLWFjY291bnQ+XHJcbiAqICAgYCxcclxuICogICBkaXJlY3RpdmVzOiBbQmFua0FjY291bnRdXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7fVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgSW5wdXRNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnB1dE1ldGFkYXRhKFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5hbWUgdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbWxhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmluZGluZ1Byb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1Byb3BlcnR5TmFtZSA9IGJpbmRpbmdQcm9wZXJ0eU5hbWU7XHJcbiAgICB9XHJcbiAgICBJbnB1dE1ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXHJcbiAgICBdLCBJbnB1dE1ldGFkYXRhKTtcclxuICAgIHJldHVybiBJbnB1dE1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLklucHV0TWV0YWRhdGEgPSBJbnB1dE1ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZXMgYW4gZXZlbnQtYm91bmQgb3V0cHV0IHByb3BlcnR5LlxyXG4gKlxyXG4gKiBXaGVuIGFuIG91dHB1dCBwcm9wZXJ0eSBlbWl0cyBhbiBldmVudCwgYW4gZXZlbnQgaGFuZGxlciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50XHJcbiAqIHRoZSB0ZW1wbGF0ZSBpcyBpbnZva2VkLlxyXG4gKlxyXG4gKiBgT3V0cHV0TWV0YWRhdGFgIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZVxyXG4gKiB1c2VkIHdoZW4gaW5zdGFudGlhdGluZyBhIGNvbXBvbmVudCBpbiB0aGUgdGVtcGxhdGUuIFdoZW4gbm90IHByb3ZpZGVkLFxyXG4gKiB0aGUgbmFtZSBvZiB0aGUgZGVjb3JhdGVkIHByb3BlcnR5IGlzIHVzZWQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQERpcmVjdGl2ZSh7XHJcbiAqICAgc2VsZWN0b3I6ICdpbnRlcnZhbC1kaXInLFxyXG4gKiB9KVxyXG4gKiBjbGFzcyBJbnRlcnZhbERpciB7XHJcbiAqICAgQE91dHB1dCgpIGV2ZXJ5U2Vjb25kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gKiAgIEBPdXRwdXQoJ2V2ZXJ5Rml2ZVNlY29uZHMnKSBmaXZlNVNlY3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqXHJcbiAqICAgY29uc3RydWN0b3IoKSB7XHJcbiAqICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmV2ZXJ5U2Vjb25kLm5leHQoXCJldmVudFwiKSwgMTAwMCk7XHJcbiAqICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmZpdmU1U2Vjcy5uZXh0KFwiZXZlbnRcIiksIDUwMDApO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGBcclxuICogICAgIDxpbnRlcnZhbC1kaXIgKGV2ZXJ5LXNlY29uZCk9XCJldmVyeVNlY29uZCgpXCIgKGV2ZXJ5LWZpdmUtc2Vjb25kcyk9XCJldmVyeUZpdmVTZWNvbmRzKClcIj5cclxuICogICAgIDwvaW50ZXJ2YWwtZGlyPlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW0ludGVydmFsRGlyXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBBcHAge1xyXG4gKiAgIGV2ZXJ5U2Vjb25kKCkgeyBjb25zb2xlLmxvZygnc2Vjb25kJyk7IH1cclxuICogICBldmVyeUZpdmVTZWNvbmRzKCkgeyBjb25zb2xlLmxvZygnZml2ZSBzZWNvbmRzJyk7IH1cclxuICogfVxyXG4gKiBib290c3RyYXAoQXBwKTtcclxuICogYGBgXHJcbiAqL1xyXG52YXIgT3V0cHV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT3V0cHV0TWV0YWRhdGEoYmluZGluZ1Byb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHRoaXMuYmluZGluZ1Byb3BlcnR5TmFtZSA9IGJpbmRpbmdQcm9wZXJ0eU5hbWU7XHJcbiAgICB9XHJcbiAgICBPdXRwdXRNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgT3V0cHV0TWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIE91dHB1dE1ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLk91dHB1dE1ldGFkYXRhID0gT3V0cHV0TWV0YWRhdGE7XHJcbi8qKlxyXG4gKiBEZWNsYXJlcyBhIGhvc3QgcHJvcGVydHkgYmluZGluZy5cclxuICpcclxuICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IGNoZWNrcyBob3N0IHByb3BlcnR5IGJpbmRpbmdzIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLlxyXG4gKiBJZiBhIGJpbmRpbmcgY2hhbmdlcywgaXQgd2lsbCB1cGRhdGUgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGUgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBgSG9zdEJpbmRpbmdNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBwcm9wZXJ0eVxyXG4gKiBuYW1lIG9mIHRoZSBob3N0IGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVwZGF0ZWQuIFdoZW4gbm90IHByb3ZpZGVkLFxyXG4gKiB0aGUgY2xhc3MgcHJvcGVydHkgbmFtZSBpcyB1c2VkLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGRpcmVjdGl2ZSB0aGF0IHNldHMgdGhlIGB2YWxpZGAgYW5kIGBpbnZhbGlkYCBjbGFzc2VzXHJcbiAqIG9uIHRoZSBET00gZWxlbWVudCB0aGF0IGhhcyBuZy1tb2RlbCBkaXJlY3RpdmUgb24gaXQuXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbbmctbW9kZWxdJ30pXHJcbiAqIGNsYXNzIE5nTW9kZWxTdGF0dXMge1xyXG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb250cm9sOk5nTW9kZWwpIHt9XHJcbiAqICAgQEhvc3RCaW5kaW5nKCdbY2xhc3MudmFsaWRdJykgZ2V0IHZhbGlkIHsgcmV0dXJuIHRoaXMuY29udHJvbC52YWxpZDsgfVxyXG4gKiAgIEBIb3N0QmluZGluZygnW2NsYXNzLmludmFsaWRdJykgZ2V0IGludmFsaWQgeyByZXR1cm4gdGhpcy5jb250cm9sLmludmFsaWQ7IH1cclxuICogfVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgdGVtcGxhdGU6IGA8aW5wdXQgWyhuZy1tb2RlbCldPVwicHJvcFwiPmAsXHJcbiAqICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFUywgTmdNb2RlbFN0YXR1c11cclxuICogfSlcclxuICogY2xhc3MgQXBwIHtcclxuICogICBwcm9wO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHApO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBIb3N0QmluZGluZ01ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhvc3RCaW5kaW5nTWV0YWRhdGEoaG9zdFByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnR5TmFtZSA9IGhvc3RQcm9wZXJ0eU5hbWU7XHJcbiAgICB9XHJcbiAgICBIb3N0QmluZGluZ01ldGFkYXRhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXHJcbiAgICBdLCBIb3N0QmluZGluZ01ldGFkYXRhKTtcclxuICAgIHJldHVybiBIb3N0QmluZGluZ01ldGFkYXRhO1xyXG59KSgpO1xyXG5leHBvcnRzLkhvc3RCaW5kaW5nTWV0YWRhdGEgPSBIb3N0QmluZGluZ01ldGFkYXRhO1xyXG4vKipcclxuICogRGVjbGFyZXMgYSBob3N0IGxpc3RlbmVyLlxyXG4gKlxyXG4gKiBBbmd1bGFyIHdpbGwgaW52b2tlIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBlbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG4gKlxyXG4gKiBJZiB0aGUgZGVjb3JhdGVkIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAsIHRoZW4gYHByZXZlbnREZWZhdWx0YCBpcyBhcHBsaWVkIG9uIHRoZSBET01cclxuICogZXZlbnQuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZWNsYXJlcyBhIGRpcmVjdGl2ZSB0aGF0IGF0dGFjaGVzIGEgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIGJ1dHRvbiBhbmRcclxuICogY291bnRzIGNsaWNrcy5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2J1dHRvbltjb3VudGluZ10nfSlcclxuICogY2xhc3MgQ291bnRDbGlja3Mge1xyXG4gKiAgIG51bWJlck9mQ2xpY2tzID0gMDtcclxuICpcclxuICogICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxyXG4gKiAgIG9uQ2xpY2soYnRuKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcImJ1dHRvblwiLCBidG4sIFwibnVtYmVyIG9mIGNsaWNrczpcIiwgdGhpcy5udW1iZXJPZkNsaWNrcysrKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxyXG4gKiAgIHRlbXBsYXRlOiBgPGJ1dHRvbiBjb3VudGluZz5JbmNyZW1lbnQ8L2J1dHRvbj5gLFxyXG4gKiAgIGRpcmVjdGl2ZXM6IFtDb3VudENsaWNrc11cclxuICogfSlcclxuICogY2xhc3MgQXBwIHt9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHApO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBIb3N0TGlzdGVuZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIb3N0TGlzdGVuZXJNZXRhZGF0YShldmVudE5hbWUsIGFyZ3MpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgfVxyXG4gICAgSG9zdExpc3RlbmVyTWV0YWRhdGEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nLCBBcnJheV0pXHJcbiAgICBdLCBIb3N0TGlzdGVuZXJNZXRhZGF0YSk7XHJcbiAgICByZXR1cm4gSG9zdExpc3RlbmVyTWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuSG9zdExpc3RlbmVyTWV0YWRhdGEgPSBIb3N0TGlzdGVuZXJNZXRhZGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIHRlbXBsYXRlIGFuZCBzdHlsZSBlbmNhcHN1bGF0aW9uIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBDb21wb25lbnQncyB7QGxpbmsgVmlld30uXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgVmlld01ldGFkYXRhI2VuY2Fwc3VsYXRpb259LlxyXG4gKi9cclxuKGZ1bmN0aW9uIChWaWV3RW5jYXBzdWxhdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbXVsYXRlIGBOYXRpdmVgIHNjb3Bpbmcgb2Ygc3R5bGVzIGJ5IGFkZGluZyBhbiBhdHRyaWJ1dGUgY29udGFpbmluZyBzdXJyb2dhdGUgaWQgdG8gdGhlIEhvc3RcclxuICAgICAqIEVsZW1lbnQgYW5kIHByZS1wcm9jZXNzaW5nIHRoZSBzdHlsZSBydWxlcyBwcm92aWRlZCB2aWFcclxuICAgICAqIHtAbGluayBWaWV3TWV0YWRhdGEjc3R5bGVzfSBvciB7QGxpbmsgVmlld01ldGFkYXRhI3N0eWxlc1VybHN9LCBhbmQgYWRkaW5nIHRoZSBuZXcgSG9zdCBFbGVtZW50XHJcbiAgICAgKiBhdHRyaWJ1dGUgdG8gYWxsIHNlbGVjdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJFbXVsYXRlZFwiXSA9IDBdID0gXCJFbXVsYXRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhlIG5hdGl2ZSBlbmNhcHN1bGF0aW9uIG1lY2hhbmlzbSBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHRoZSBET00gdGhpcyBtZWFucyB1c2luZyBbU2hhZG93IERPTV0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvKSBhbmRcclxuICAgICAqIGNyZWF0aW5nIGEgU2hhZG93Um9vdCBmb3IgQ29tcG9uZW50J3MgSG9zdCBFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5hdGl2ZVwiXSA9IDFdID0gXCJOYXRpdmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogRG9uJ3QgcHJvdmlkZSBhbnkgdGVtcGxhdGUgb3Igc3R5bGUgZW5jYXBzdWxhdGlvbi5cclxuICAgICAqL1xyXG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcclxufSkoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiB8fCAoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiA9IHt9KSk7XHJcbnZhciBWaWV3RW5jYXBzdWxhdGlvbiA9IGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb247XHJcbmV4cG9ydHMuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFUyA9IFtWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlLCBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXTtcclxuLyoqXHJcbiAqIE1ldGFkYXRhIHByb3BlcnRpZXMgYXZhaWxhYmxlIGZvciBjb25maWd1cmluZyBWaWV3cy5cclxuICpcclxuICogRWFjaCBBbmd1bGFyIGNvbXBvbmVudCByZXF1aXJlcyBhIHNpbmdsZSBgQENvbXBvbmVudGAgYW5kIGF0IGxlYXN0IG9uZSBgQFZpZXdgIGFubm90YXRpb24uIFRoZVxyXG4gKiBgQFZpZXdgIGFubm90YXRpb24gc3BlY2lmaWVzIHRoZSBIVE1MIHRlbXBsYXRlIHRvIHVzZSwgYW5kIGxpc3RzIHRoZSBkaXJlY3RpdmVzIHRoYXQgYXJlIGFjdGl2ZVxyXG4gKiB3aXRoaW4gdGhlIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgdGhlIHRlbXBsYXRlIGlzIGxvYWRlZCBpbnRvIHRoZSBjb21wb25lbnQncyBzaGFkb3cgcm9vdCwgYW5kXHJcbiAqIHRoZSBleHByZXNzaW9ucyBhbmQgc3RhdGVtZW50cyBpbiB0aGUgdGVtcGxhdGUgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQENvbXBvbmVudGAgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBDb21wb25lbnRNZXRhZGF0YX0uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxyXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJyxcclxuICogICBkaXJlY3RpdmVzOiBbR3JlZXRVc2VyLCBCb2xkXVxyXG4gKiB9KVxyXG4gKiBjbGFzcyBHcmVldCB7XHJcbiAqICAgbmFtZTogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG52YXIgVmlld01ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdNZXRhZGF0YShfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCBkaXJlY3RpdmVzID0gX2IuZGlyZWN0aXZlcywgcGlwZXMgPSBfYi5waXBlcywgZW5jYXBzdWxhdGlvbiA9IF9iLmVuY2Fwc3VsYXRpb24sIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgICAgICB0aGlzLnBpcGVzID0gcGlwZXM7XHJcbiAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcclxuICAgIH1cclxuICAgIFZpZXdNZXRhZGF0YSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgVmlld01ldGFkYXRhKTtcclxuICAgIHJldHVybiBWaWV3TWV0YWRhdGE7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVmlld01ldGFkYXRhID0gVmlld01ldGFkYXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3LmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogQG1vZHVsZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBzZXQgb2YgY29tbW9uIFBpcGVzLlxyXG4gKi9cclxudmFyIGFzeW5jX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvYXN5bmNfcGlwZScpO1xyXG5leHBvcnRzLkFzeW5jUGlwZSA9IGFzeW5jX3BpcGVfMS5Bc3luY1BpcGU7XHJcbnZhciBkYXRlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvZGF0ZV9waXBlJyk7XHJcbmV4cG9ydHMuRGF0ZVBpcGUgPSBkYXRlX3BpcGVfMS5EYXRlUGlwZTtcclxudmFyIGRlZmF1bHRfcGlwZXNfMSA9IHJlcXVpcmUoJy4vcGlwZXMvZGVmYXVsdF9waXBlcycpO1xyXG5leHBvcnRzLkRFRkFVTFRfUElQRVMgPSBkZWZhdWx0X3BpcGVzXzEuREVGQVVMVF9QSVBFUztcclxuZXhwb3J0cy5ERUZBVUxUX1BJUEVTX1RPS0VOID0gZGVmYXVsdF9waXBlc18xLkRFRkFVTFRfUElQRVNfVE9LRU47XHJcbnZhciBqc29uX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvanNvbl9waXBlJyk7XHJcbmV4cG9ydHMuSnNvblBpcGUgPSBqc29uX3BpcGVfMS5Kc29uUGlwZTtcclxudmFyIHNsaWNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvc2xpY2VfcGlwZScpO1xyXG5leHBvcnRzLlNsaWNlUGlwZSA9IHNsaWNlX3BpcGVfMS5TbGljZVBpcGU7XHJcbnZhciBsb3dlcmNhc2VfcGlwZV8xID0gcmVxdWlyZSgnLi9waXBlcy9sb3dlcmNhc2VfcGlwZScpO1xyXG5leHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBsb3dlcmNhc2VfcGlwZV8xLkxvd2VyQ2FzZVBpcGU7XHJcbnZhciBudW1iZXJfcGlwZV8xID0gcmVxdWlyZSgnLi9waXBlcy9udW1iZXJfcGlwZScpO1xyXG5leHBvcnRzLk51bWJlclBpcGUgPSBudW1iZXJfcGlwZV8xLk51bWJlclBpcGU7XHJcbmV4cG9ydHMuRGVjaW1hbFBpcGUgPSBudW1iZXJfcGlwZV8xLkRlY2ltYWxQaXBlO1xyXG5leHBvcnRzLlBlcmNlbnRQaXBlID0gbnVtYmVyX3BpcGVfMS5QZXJjZW50UGlwZTtcclxuZXhwb3J0cy5DdXJyZW5jeVBpcGUgPSBudW1iZXJfcGlwZV8xLkN1cnJlbmN5UGlwZTtcclxudmFyIHVwcGVyY2FzZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL3VwcGVyY2FzZV9waXBlJyk7XHJcbmV4cG9ydHMuVXBwZXJDYXNlUGlwZSA9IHVwcGVyY2FzZV9waXBlXzEuVXBwZXJDYXNlUGlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24nKTtcclxudmFyIGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbicpO1xyXG52YXIgT2JzZXJ2YWJsZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVTdHJhdGVneSgpIHtcclxuICAgIH1cclxuICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZShhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5kaXNwb3NlKHN1YnNjcmlwdGlvbik7IH07XHJcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5kaXNwb3NlKHN1YnNjcmlwdGlvbik7IH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVN0cmF0ZWd5O1xyXG59KSgpO1xyXG52YXIgUHJvbWlzZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb21pc2VTdHJhdGVneSgpIHtcclxuICAgIH1cclxuICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhc3luYy50aGVuKHVwZGF0ZUxhdGVzdFZhbHVlKTtcclxuICAgIH07XHJcbiAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XHJcbiAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcclxuICAgIHJldHVybiBQcm9taXNlU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbnZhciBfcHJvbWlzZVN0cmF0ZWd5ID0gbmV3IFByb21pc2VTdHJhdGVneSgpO1xyXG52YXIgX29ic2VydmFibGVTdHJhdGVneSA9IG5ldyBPYnNlcnZhYmxlU3RyYXRlZ3koKTtcclxuLyoqXHJcbiAqIFRoZSBgYXN5bmNgIHBpcGUgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIG9yIFByb21pc2UgYW5kIHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBpdCBoYXNcclxuICogZW1pdHRlZC5cclxuICogV2hlbiBhIG5ldyB2YWx1ZSBpcyBlbWl0dGVkLCB0aGUgYGFzeW5jYCBwaXBlIG1hcmtzIHRoZSBjb21wb25lbnQgdG8gYmUgY2hlY2tlZCBmb3IgY2hhbmdlcy5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqIFRoZSBleGFtcGxlIGJlbG93IGJpbmRzIHRoZSBgdGltZWAgT2JzZXJ2YWJsZSB0byB0aGUgdmlldy4gRXZlcnkgNTAwbXMsIHRoZSBgdGltZWAgT2JzZXJ2YWJsZVxyXG4gKiB1cGRhdGVzIHRoZSB2aWV3IHdpdGggdGhlIGN1cnJlbnQgdGltZS5cclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAnYW5ndWxhcjIvY29yZSc7XHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiBcInRhc2stY21wXCIsXHJcbiAqICAgdGVtcGxhdGU6IFwiVGltZToge3sgdGltZSB8IGFzeW5jIH19XCJcclxuICogfSlcclxuICogY2xhc3MgVGFzayB7XHJcbiAqICAgdGltZSA9IG5ldyBPYnNlcnZhYmxlPG51bWJlcj4ob2JzZXJ2ZXIgPT4ge1xyXG4gKiAgICAgc2V0SW50ZXJ2YWwoXyA9PlxyXG4gKiAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBEYXRlKCkuZ2V0VGltZSgpKSwgNTAwKTtcclxuICogICB9KTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBBc3luY1BpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXN5bmNQaXBlKF9yZWYpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmVmID0gX3JlZjtcclxuICAgIH1cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3N1YnNjcmlwdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fb2JqKSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5fb2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9sYXRlc3RWYWx1ZSA9PT0gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZV9kZXRlY3Rpb25fMS5XcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX29iaiA9IG9iajtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHRoaXMuX3NlbGVjdFN0cmF0ZWd5KG9iaik7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID1cclxuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kuY3JlYXRlU3Vic2NyaXB0aW9uKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlTGF0ZXN0VmFsdWUob2JqLCB2YWx1ZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3NlbGVjdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcm9taXNlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlU3RyYXRlZ3k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuaXNPYnNlcnZhYmxlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlU3RyYXRlZ3k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xLkludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24oQXN5bmNQaXBlLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5LmRpc3Bvc2UodGhpcy5fc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3VwZGF0ZUxhdGVzdFZhbHVlID0gZnVuY3Rpb24gKGFzeW5jLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChhc3luYyA9PT0gdGhpcy5fb2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZi5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXN5bmNQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ2FzeW5jJywgcHVyZTogZmFsc2UgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclJlZl0pXHJcbiAgICBdLCBBc3luY1BpcGUpO1xyXG4gICAgcmV0dXJuIEFzeW5jUGlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5Bc3luY1BpcGUgPSBBc3luY1BpcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jX3BpcGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgaW50bF8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2ludGwnKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL21ldGFkYXRhJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XHJcbi8vIFRPRE86IG1vdmUgdG8gYSBnbG9iYWwgY29uZmlndXJhYmxlIGxvY2F0aW9uIGFsb25nIHdpdGggb3RoZXIgaTE4biBjb21wb25lbnRzLlxyXG52YXIgZGVmYXVsdExvY2FsZSA9ICdlbi1VUyc7XHJcbi8qKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJLlxyXG4gKiBUaGVyZWZvcmUgaXQgaXMgb25seSByZWxpYWJsZSBpbiBDaHJvbWUgYW5kIE9wZXJhIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBGb3JtYXRzIGEgZGF0ZSB2YWx1ZSB0byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgcmVxdWVzdGVkIGZvcm1hdC5cclxuICpcclxuICogIyBVc2FnZVxyXG4gKlxyXG4gKiAgICAgZXhwcmVzc2lvbiB8IGRhdGVbOmZvcm1hdF1cclxuICpcclxuICogd2hlcmUgYGV4cHJlc3Npb25gIGlzIGEgZGF0ZSBvYmplY3Qgb3IgYSBudW1iZXIgKG1pbGxpc2Vjb25kcyBzaW5jZSBVVEMgZXBvY2gpIGFuZFxyXG4gKiBgZm9ybWF0YCBpbmRpY2F0ZXMgd2hpY2ggZGF0ZS90aW1lIGNvbXBvbmVudHMgdG8gaW5jbHVkZTpcclxuICpcclxuICogIHwgQ29tcG9uZW50IHwgU3ltYm9sIHwgU2hvcnQgRm9ybSAgIHwgTG9uZyBGb3JtICAgICAgICAgfCBOdW1lcmljICAgfCAyLWRpZ2l0ICAgfFxyXG4gKiAgfC0tLS0tLS0tLS0tfDotLS0tLS06fC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS18LS0tLS0tLS0tLS18XHJcbiAqICB8IGVyYSAgICAgICB8ICAgRyAgICB8IEcgKEFEKSAgICAgICB8IEdHR0cgKEFubm8gRG9taW5pKXwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcclxuICogIHwgeWVhciAgICAgIHwgICB5ICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCB5ICgyMDE1KSAgfCB5eSAoMTUpICAgfFxyXG4gKiAgfCBtb250aCAgICAgfCAgIE0gICAgfCBNTU0gKFNlcCkgICAgfCBNTU1NIChTZXB0ZW1iZXIpICB8IE0gKDkpICAgICB8IE1NICgwOSkgICB8XHJcbiAqICB8IGRheSAgICAgICB8ICAgZCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgZCAoMykgICAgIHwgZGQgKDAzKSAgIHxcclxuICogIHwgd2Vla2RheSAgIHwgICBFICAgIHwgRUVFIChTdW4pICAgIHwgRUVFRSAoU3VuZGF5KSAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxyXG4gKiAgfCBob3VyICAgICAgfCAgIGogICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGogKDEzKSAgICB8IGpqICgxMykgICB8XHJcbiAqICB8IGhvdXIxMiAgICB8ICAgaCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgaCAoMSBQTSkgIHwgaGggKDAxIFBNKXxcclxuICogIHwgaG91cjI0ICAgIHwgICBIICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBIICgxMykgICAgfCBISCAoMTMpICAgfFxyXG4gKiAgfCBtaW51dGUgICAgfCAgIG0gICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IG0gKDUpICAgICB8IG1tICgwNSkgICB8XHJcbiAqICB8IHNlY29uZCAgICB8ICAgcyAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgcyAoOSkgICAgIHwgc3MgKDA5KSAgIHxcclxuICogIHwgdGltZXpvbmUgIHwgICB6ICAgIHwgLSAgICAgICAgICAgIHwgeiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKXwgLSAgfCAtICAgICAgICAgfFxyXG4gKiAgfCB0aW1lem9uZSAgfCAgIFogICAgfCBaIChHTVQtODowMCkgfCAtICAgICAgICAgICAgICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XHJcbiAqXHJcbiAqIEluIGphdmFzY3JpcHQsIG9ubHkgdGhlIGNvbXBvbmVudHMgc3BlY2lmaWVkIHdpbGwgYmUgcmVzcGVjdGVkIChub3QgdGhlIG9yZGVyaW5nLFxyXG4gKiBwdW5jdHVhdGlvbnMsIC4uLikgYW5kIGRldGFpbHMgb2YgdGhlIGZvcm1hdHRpbmcgd2lsbCBiZSBkZXBlbmRlbnQgb24gdGhlIGxvY2FsZS5cclxuICogT24gdGhlIG90aGVyIGhhbmQgaW4gRGFydCB2ZXJzaW9uLCB5b3UgY2FuIGFsc28gaW5jbHVkZSBxdW90ZWQgdGV4dCBhcyB3ZWxsIGFzIHNvbWUgZXh0cmFcclxuICogZGF0ZS90aW1lIGNvbXBvbmVudHMgc3VjaCBhcyBxdWFydGVyLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWU6XHJcbiAqIGh0dHBzOi8vYXBpLmRhcnRsYW5nLm9yZy9hcGlkb2NzL2NoYW5uZWxzL3N0YWJsZS9kYXJ0ZG9jLXZpZXdlci9pbnRsL2ludGwuRGF0ZUZvcm1hdC5cclxuICpcclxuICogYGZvcm1hdGAgY2FuIGFsc28gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgcHJlZGVmaW5lZCBmb3JtYXRzOlxyXG4gKlxyXG4gKiAgLSBgJ21lZGl1bSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTWRqbXMnYCAoZS5nLiBTZXAgMywgMjAxMCwgMTI6MDU6MDggUE0gZm9yIGVuLVVTKVxyXG4gKiAgLSBgJ3Nob3J0J2A6IGVxdWl2YWxlbnQgdG8gYCd5TWRqbSdgIChlLmcuIDkvMy8yMDEwLCAxMjowNSBQTSBmb3IgZW4tVVMpXHJcbiAqICAtIGAnZnVsbERhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1NRUVFRWQnYCAoZS5nLiBGcmlkYXksIFNlcHRlbWJlciAzLCAyMDEwIGZvciBlbi1VUylcclxuICogIC0gYCdsb25nRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTU1kJ2AgKGUuZy4gU2VwdGVtYmVyIDMsIDIwMTApXHJcbiAqICAtIGAnbWVkaXVtRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTWQnYCAoZS5nLiBTZXAgMywgMjAxMCBmb3IgZW4tVVMpXHJcbiAqICAtIGAnc2hvcnREYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TWQnYCAoZS5nLiA5LzMvMjAxMCBmb3IgZW4tVVMpXHJcbiAqICAtIGAnbWVkaXVtVGltZSdgOiBlcXVpdmFsZW50IHRvIGAnam1zJ2AgKGUuZy4gMTI6MDU6MDggUE0gZm9yIGVuLVVTKVxyXG4gKiAgLSBgJ3Nob3J0VGltZSdgOiBlcXVpdmFsZW50IHRvIGAnam0nYCAoZS5nLiAxMjowNSBQTSBmb3IgZW4tVVMpXHJcbiAqXHJcbiAqIFRpbWV6b25lIG9mIHRoZSBmb3JtYXR0ZWQgdGV4dCB3aWxsIGJlIHRoZSBsb2NhbCBzeXN0ZW0gdGltZXpvbmUgb2YgdGhlIGVuZC11c2VycyBtYWNoaW5lLlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVzXHJcbiAqXHJcbiAqIEFzc3VtaW5nIGBkYXRlT2JqYCBpcyAoeWVhcjogMjAxNSwgbW9udGg6IDYsIGRheTogMTUsIGhvdXI6IDIxLCBtaW51dGU6IDQzLCBzZWNvbmQ6IDExKVxyXG4gKiBpbiB0aGUgX2xvY2FsXyB0aW1lIGFuZCBsb2NhbGUgaXMgJ2VuLVVTJzpcclxuICpcclxuICogICAgIHt7IGRhdGVPYmogfCBkYXRlIH19ICAgICAgICAgICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUnXHJcbiAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbWVkaXVtJyB9fSAgICAgIC8vIG91dHB1dCBpcyAnSnVuIDE1LCAyMDE1LCA5OjQzOjExIFBNJ1xyXG4gKiAgICAge3sgZGF0ZU9iaiB8IGRhdGU6J3Nob3J0VGltZScgfX0gICAvLyBvdXRwdXQgaXMgJzk6NDMgUE0nXHJcbiAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbW1zcycgfX0gICAgICAgIC8vIG91dHB1dCBpcyAnNDM6MTEnXHJcbiAqL1xyXG52YXIgRGF0ZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZVBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICBEYXRlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xLkludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24oRGF0ZVBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBsYW5nXzEuaXNQcmVzZW50KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiAnbWVkaXVtRGF0ZSc7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBsYW5nXzEuRGF0ZVdyYXBwZXIuZnJvbU1pbGxpcyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhEYXRlUGlwZS5fQUxJQVNFUywgcGF0dGVybikpIHtcclxuICAgICAgICAgICAgcGF0dGVybiA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChEYXRlUGlwZS5fQUxJQVNFUywgcGF0dGVybik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnRsXzEuRGF0ZUZvcm1hdHRlci5mb3JtYXQodmFsdWUsIGRlZmF1bHRMb2NhbGUsIHBhdHRlcm4pO1xyXG4gICAgfTtcclxuICAgIERhdGVQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGxhbmdfMS5pc0RhdGUob2JqKSB8fCBsYW5nXzEuaXNOdW1iZXIob2JqKTsgfTtcclxuICAgIERhdGVQaXBlLl9BTElBU0VTID0ge1xyXG4gICAgICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxyXG4gICAgICAgICdzaG9ydCc6ICd5TWRqbScsXHJcbiAgICAgICAgJ2Z1bGxEYXRlJzogJ3lNTU1NRUVFRWQnLFxyXG4gICAgICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxyXG4gICAgICAgICdtZWRpdW1EYXRlJzogJ3lNTU1kJyxcclxuICAgICAgICAnc2hvcnREYXRlJzogJ3lNZCcsXHJcbiAgICAgICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcclxuICAgICAgICAnc2hvcnRUaW1lJzogJ2ptJ1xyXG4gICAgfTtcclxuICAgIERhdGVQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ2RhdGUnIH0pLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgRGF0ZVBpcGUpO1xyXG4gICAgcmV0dXJuIERhdGVQaXBlO1xyXG59KSgpO1xyXG5leHBvcnRzLkRhdGVQaXBlID0gRGF0ZVBpcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGVfcGlwZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGFzeW5jX3BpcGVfMSA9IHJlcXVpcmUoJy4vYXN5bmNfcGlwZScpO1xyXG52YXIgdXBwZXJjYXNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vdXBwZXJjYXNlX3BpcGUnKTtcclxudmFyIGxvd2VyY2FzZV9waXBlXzEgPSByZXF1aXJlKCcuL2xvd2VyY2FzZV9waXBlJyk7XHJcbnZhciBqc29uX3BpcGVfMSA9IHJlcXVpcmUoJy4vanNvbl9waXBlJyk7XHJcbnZhciBzbGljZV9waXBlXzEgPSByZXF1aXJlKCcuL3NsaWNlX3BpcGUnKTtcclxudmFyIGRhdGVfcGlwZV8xID0gcmVxdWlyZSgnLi9kYXRlX3BpcGUnKTtcclxudmFyIG51bWJlcl9waXBlXzEgPSByZXF1aXJlKCcuL251bWJlcl9waXBlJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBERUZBVUxUX1BJUEVTX0xJU1QgPSBsYW5nXzEuQ09OU1RfRVhQUihbXHJcbiAgICBhc3luY19waXBlXzEuQXN5bmNQaXBlLFxyXG4gICAgdXBwZXJjYXNlX3BpcGVfMS5VcHBlckNhc2VQaXBlLFxyXG4gICAgbG93ZXJjYXNlX3BpcGVfMS5Mb3dlckNhc2VQaXBlLFxyXG4gICAganNvbl9waXBlXzEuSnNvblBpcGUsXHJcbiAgICBzbGljZV9waXBlXzEuU2xpY2VQaXBlLFxyXG4gICAgbnVtYmVyX3BpcGVfMS5EZWNpbWFsUGlwZSxcclxuICAgIG51bWJlcl9waXBlXzEuUGVyY2VudFBpcGUsXHJcbiAgICBudW1iZXJfcGlwZV8xLkN1cnJlbmN5UGlwZSxcclxuICAgIGRhdGVfcGlwZV8xLkRhdGVQaXBlXHJcbl0pO1xyXG5leHBvcnRzLkRFRkFVTFRfUElQRVNfVE9LRU4gPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5PcGFxdWVUb2tlbihcIkRlZmF1bHQgUGlwZXNcIikpO1xyXG5leHBvcnRzLkRFRkFVTFRfUElQRVMgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5Qcm92aWRlcihleHBvcnRzLkRFRkFVTFRfUElQRVNfVE9LRU4sIHsgdXNlVmFsdWU6IERFRkFVTFRfUElQRVNfTElTVCB9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRfcGlwZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24odHlwZSwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkludmFsaWQgYXJndW1lbnQgJ1wiICsgdmFsdWUgKyBcIicgZm9yIHBpcGUgJ1wiICsgdHlwZSArIFwiJ1wiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBJbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uO1xyXG59KShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbik7XHJcbmV4cG9ydHMuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbiA9IEludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudHMganNvbiB0cmFuc2Zvcm1zIHRvIGFueSBvYmplY3QuXHJcbiAqXHJcbiAqICMgRXhhbXBsZVxyXG4gKlxyXG4gKiBJbiB0aGlzIGV4YW1wbGUgd2UgdHJhbnNmb3JtIHRoZSB1c2VyIG9iamVjdCB0byBqc29uLlxyXG4gKlxyXG4gKiAgYGBgXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiBcInVzZXItY21wXCIsXHJcbiAqICAgdGVtcGxhdGU6IFwiVXNlcjoge3sgdXNlciB8IGpzb24gfX1cIlxyXG4gKiB9KVxyXG4gKiBjbGFzcyBVc2VybmFtZSB7XHJcbiAqICB1c2VyOk9iamVjdFxyXG4gKiAgY29uc3RydWN0b3IoKSB7XHJcbiAqICAgIHRoaXMudXNlciA9IHsgbmFtZTogXCJQYXRyaWNrSlNcIiB9O1xyXG4gKiAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEpzb25QaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEpzb25QaXBlKCkge1xyXG4gICAgfVxyXG4gICAgSnNvblBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gbGFuZ18xLkpzb24uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBKc29uUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdqc29uJyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEpzb25QaXBlKTtcclxuICAgIHJldHVybiBKc29uUGlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5Kc29uUGlwZSA9IEpzb25QaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uX3BpcGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbicpO1xyXG4vKipcclxuICogSW1wbGVtZW50cyBsb3dlcmNhc2UgdHJhbnNmb3JtcyB0byB0ZXh0LlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVcclxuICpcclxuICogSW4gdGhpcyBleGFtcGxlIHdlIHRyYW5zZm9ybSB0aGUgdXNlciB0ZXh0IGxvd2VyY2FzZS5cclxuICpcclxuICogIGBgYFxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogXCJ1c2VybmFtZS1jbXBcIixcclxuICogICB0ZW1wbGF0ZTogXCJVc2VybmFtZToge3sgdXNlciB8IGxvd2VyY2FzZSB9fVwiXHJcbiAqIH0pXHJcbiAqIGNsYXNzIFVzZXJuYW1lIHtcclxuICogICB1c2VyOnN0cmluZztcclxuICogfVxyXG4gKlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBMb3dlckNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvd2VyQ2FzZVBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICBMb3dlckNhc2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIGlmICghbGFuZ18xLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xLkludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb24oTG93ZXJDYXNlUGlwZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIudG9Mb3dlckNhc2UodmFsdWUpO1xyXG4gICAgfTtcclxuICAgIExvd2VyQ2FzZVBpcGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSxcclxuICAgICAgICBtZXRhZGF0YV8xLlBpcGUoeyBuYW1lOiAnbG93ZXJjYXNlJyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIExvd2VyQ2FzZVBpcGUpO1xyXG4gICAgcmV0dXJuIExvd2VyQ2FzZVBpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG93ZXJDYXNlUGlwZSA9IExvd2VyQ2FzZVBpcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvd2VyY2FzZV9waXBlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBpbnRsXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvaW50bCcpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcclxudmFyIGRlZmF1bHRMb2NhbGUgPSAnZW4tVVMnO1xyXG52YXIgX3JlID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCdeKFxcXFxkKyk/XFxcXC4oKFxcXFxkKykoXFxcXC0oXFxcXGQrKSk/KT8kJyk7XHJcbnZhciBOdW1iZXJQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE51bWJlclBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICBOdW1iZXJQaXBlLl9mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUsIHN0eWxlLCBkaWdpdHMsIGN1cnJlbmN5LCBjdXJyZW5jeUFzU3ltYm9sKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDApIHsgY3VycmVuY3kgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGN1cnJlbmN5QXNTeW1ib2wgPT09IHZvaWQgMCkgeyBjdXJyZW5jeUFzU3ltYm9sID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKE51bWJlclBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbkludCA9IDEsIG1pbkZyYWN0aW9uID0gMCwgbWF4RnJhY3Rpb24gPSAzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpZ2l0cykpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChfcmUsIGRpZ2l0cyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJ0cykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihkaWdpdHMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvIGZvciBudW1iZXIgcGlwZXNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFydHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5JbnQgPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFydHNbM10pKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5GcmFjdGlvbiA9IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4KHBhcnRzWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJ0c1s1XSkpIHtcclxuICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbNV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnRsXzEuTnVtYmVyRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSwgZGVmYXVsdExvY2FsZSwgc3R5bGUsIHtcclxuICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IG1pbkludCxcclxuICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcclxuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhGcmFjdGlvbixcclxuICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxyXG4gICAgICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyUGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgTnVtYmVyUGlwZSk7XHJcbiAgICByZXR1cm4gTnVtYmVyUGlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5OdW1iZXJQaXBlID0gTnVtYmVyUGlwZTtcclxuLyoqXHJcbiAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkuXHJcbiAqIFRoZXJlZm9yZSBpdCBpcyBvbmx5IHJlbGlhYmxlIGluIENocm9tZSBhbmQgT3BlcmEgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEZvcm1hdHMgYSBudW1iZXIgYXMgbG9jYWwgdGV4dC4gaS5lLiBncm91cCBzaXppbmcgYW5kIHNlcGFyYXRvciBhbmQgb3RoZXIgbG9jYWxlLXNwZWNpZmljXHJcbiAqIGNvbmZpZ3VyYXRpb25zIGFyZSBiYXNlZCBvbiB0aGUgYWN0aXZlIGxvY2FsZS5cclxuICpcclxuICogIyBVc2FnZVxyXG4gKlxyXG4gKiAgICAgZXhwcmVzc2lvbiB8IG51bWJlcls6ZGlnaXRJbmZvXVxyXG4gKlxyXG4gKiB3aGVyZSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXIgYW5kIGBkaWdpdEluZm9gIGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdDpcclxuICpcclxuICogICAgIHttaW5JbnRlZ2VyRGlnaXRzfS57bWluRnJhY3Rpb25EaWdpdHN9LXttYXhGcmFjdGlvbkRpZ2l0c31cclxuICpcclxuICogLSBtaW5JbnRlZ2VyRGlnaXRzIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBpbnRlZ2VyIGRpZ2l0cyB0byB1c2UuIERlZmF1bHRzIHRvIDEuXHJcbiAqIC0gbWluRnJhY3Rpb25EaWdpdHMgaXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmcmFjdGlvbi4gRGVmYXVsdHMgdG8gMC5cclxuICogLSBtYXhGcmFjdGlvbkRpZ2l0cyBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIGZyYWN0aW9uLiBEZWZhdWx0cyB0byAzLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgYWNjZXB0YWJsZSByYW5nZSBmb3IgZWFjaCBvZiB0aGVzZSBudW1iZXJzIGFuZCBvdGhlclxyXG4gKiBkZXRhaWxzIHNlZSB5b3VyIG5hdGl2ZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBsaWJyYXJ5LlxyXG4gKlxyXG4gKiAjIEV4YW1wbGVzXHJcbiAqXHJcbiAqICAgICB7eyAxMjMgfCBudW1iZXIgfX0gICAgICAgICAgICAgIC8vIG91dHB1dCBpcyAxMjNcclxuICogICAgIHt7IDEyMy4xIHwgbnVtYmVyOiAnLjItMycgfX0gICAgLy8gb3V0cHV0IGlzIDEyMy4xMFxyXG4gKiAgICAge3sgMSB8IG51bWJlcjogJzIuMicgfX0gICAgICAgICAvLyBvdXRwdXQgaXMgMDEuMDBcclxuICovXHJcbnZhciBEZWNpbWFsUGlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGVjaW1hbFBpcGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZWNpbWFsUGlwZSgpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIERlY2ltYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGFyZ3MpIHtcclxuICAgICAgICB2YXIgZGlnaXRzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KGFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBOdW1iZXJQaXBlLl9mb3JtYXQodmFsdWUsIGludGxfMS5OdW1iZXJGb3JtYXRTdHlsZS5EZWNpbWFsLCBkaWdpdHMpO1xyXG4gICAgfTtcclxuICAgIERlY2ltYWxQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ251bWJlcicgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEZWNpbWFsUGlwZSk7XHJcbiAgICByZXR1cm4gRGVjaW1hbFBpcGU7XHJcbn0pKE51bWJlclBpcGUpO1xyXG5leHBvcnRzLkRlY2ltYWxQaXBlID0gRGVjaW1hbFBpcGU7XHJcbi8qKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJLlxyXG4gKiBUaGVyZWZvcmUgaXQgaXMgb25seSByZWxpYWJsZSBpbiBDaHJvbWUgYW5kIE9wZXJhIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIGxvY2FsIHBlcmNlbnQuXHJcbiAqXHJcbiAqICMgVXNhZ2VcclxuICpcclxuICogICAgIGV4cHJlc3Npb24gfCBwZXJjZW50WzpkaWdpdEluZm9dXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGBkaWdpdEluZm9gIHNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9XHJcbiAqL1xyXG52YXIgUGVyY2VudFBpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBlcmNlbnRQaXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGVyY2VudFBpcGUoKSB7XHJcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBQZXJjZW50UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGRpZ2l0cyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdChhcmdzKTtcclxuICAgICAgICByZXR1cm4gTnVtYmVyUGlwZS5fZm9ybWF0KHZhbHVlLCBpbnRsXzEuTnVtYmVyRm9ybWF0U3R5bGUuUGVyY2VudCwgZGlnaXRzKTtcclxuICAgIH07XHJcbiAgICBQZXJjZW50UGlwZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLFxyXG4gICAgICAgIG1ldGFkYXRhXzEuUGlwZSh7IG5hbWU6ICdwZXJjZW50JyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFBlcmNlbnRQaXBlKTtcclxuICAgIHJldHVybiBQZXJjZW50UGlwZTtcclxufSkoTnVtYmVyUGlwZSk7XHJcbmV4cG9ydHMuUGVyY2VudFBpcGUgPSBQZXJjZW50UGlwZTtcclxuLyoqXHJcbiAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkuXHJcbiAqIFRoZXJlZm9yZSBpdCBpcyBvbmx5IHJlbGlhYmxlIGluIENocm9tZSBhbmQgT3BlcmEgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEZvcm1hdHMgYSBudW1iZXIgYXMgbG9jYWwgY3VycmVuY3kuXHJcbiAqXHJcbiAqICMgVXNhZ2VcclxuICpcclxuICogICAgIGV4cHJlc3Npb24gfCBjdXJyZW5jeVs6Y3VycmVuY3lDb2RlWzpzeW1ib2xEaXNwbGF5WzpkaWdpdEluZm9dXV1cclxuICpcclxuICogd2hlcmUgYGN1cnJlbmN5Q29kZWAgaXMgdGhlIElTTyA0MjE3IGN1cnJlbmN5IGNvZGUsIHN1Y2ggYXMgXCJVU0RcIiBmb3IgdGhlIFVTIGRvbGxhciBhbmRcclxuICogXCJFVVJcIiBmb3IgdGhlIGV1cm8uIGBzeW1ib2xEaXNwbGF5YCBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHVzZSB0aGUgY3VycmVuY3lcclxuICogc3ltYm9sIChlLmcuICQpIG9yIHRoZSBjdXJyZW5jeSBjb2RlIChlLmcuIFVTRCkgaW4gdGhlIG91dHB1dC4gVGhlIGRlZmF1bHQgZm9yIHRoaXMgdmFsdWVcclxuICogaXMgYGZhbHNlYC5cclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgYGRpZ2l0SW5mb2Agc2VlIHtAbGluayBEZWNpbWFsUGlwZX1cclxuICovXHJcbnZhciBDdXJyZW5jeVBpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEN1cnJlbmN5UGlwZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEN1cnJlbmN5UGlwZSgpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIEN1cnJlbmN5UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbmN5Q29kZSA9IGxhbmdfMS5pc1ByZXNlbnQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwID8gYXJnc1swXSA6ICdVU0QnO1xyXG4gICAgICAgIHZhciBzeW1ib2xEaXNwbGF5ID0gbGFuZ18xLmlzUHJlc2VudChhcmdzKSAmJiBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzWzFdIDogZmFsc2U7XHJcbiAgICAgICAgdmFyIGRpZ2l0cyA9IGxhbmdfMS5pc1ByZXNlbnQoYXJncykgJiYgYXJncy5sZW5ndGggPiAyID8gYXJnc1syXSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlclBpcGUuX2Zvcm1hdCh2YWx1ZSwgaW50bF8xLk51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5LCBkaWdpdHMsIGN1cnJlbmN5Q29kZSwgc3ltYm9sRGlzcGxheSk7XHJcbiAgICB9O1xyXG4gICAgQ3VycmVuY3lQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ2N1cnJlbmN5JyB9KSxcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEN1cnJlbmN5UGlwZSk7XHJcbiAgICByZXR1cm4gQ3VycmVuY3lQaXBlO1xyXG59KShOdW1iZXJQaXBlKTtcclxuZXhwb3J0cy5DdXJyZW5jeVBpcGUgPSBDdXJyZW5jeVBpcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlcl9waXBlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgcHJvdmlkZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpL3Byb3ZpZGVyJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIFBpcGVQcm92aWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGlwZVByb3ZpZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGlwZVByb3ZpZGVyKG5hbWUsIHB1cmUsIGtleSwgcmVzb2x2ZWRGYWN0b3JpZXMsIG11bHRpQmluZGluZykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGtleSwgcmVzb2x2ZWRGYWN0b3JpZXMsIG11bHRpQmluZGluZyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnB1cmUgPSBwdXJlO1xyXG4gICAgfVxyXG4gICAgUGlwZVByb3ZpZGVyLmNyZWF0ZUZyb21UeXBlID0gZnVuY3Rpb24gKHR5cGUsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IGRpXzEuUHJvdmlkZXIodHlwZSwgeyB1c2VDbGFzczogdHlwZSB9KTtcclxuICAgICAgICB2YXIgcmIgPSBwcm92aWRlcl8xLnJlc29sdmVQcm92aWRlcihwcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaXBlUHJvdmlkZXIobWV0YWRhdGEubmFtZSwgbWV0YWRhdGEucHVyZSwgcmIua2V5LCByYi5yZXNvbHZlZEZhY3RvcmllcywgcmIubXVsdGlQcm92aWRlcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBpcGVQcm92aWRlcjtcclxufSkocHJvdmlkZXJfMS5SZXNvbHZlZFByb3ZpZGVyXyk7XHJcbmV4cG9ydHMuUGlwZVByb3ZpZGVyID0gUGlwZVByb3ZpZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlX3Byb3ZpZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgY2QgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL3BpcGVzJyk7XHJcbnZhciBQcm90b1BpcGVzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3RvUGlwZXMoXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBNYXAgb2Yge0BsaW5rIFBpcGVNZXRhZGF0YX0gbmFtZXMgdG8ge0BsaW5rIFBpcGVNZXRhZGF0YX0gaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICBQcm90b1BpcGVzLmZyb21Qcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XHJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHt9O1xyXG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7IHJldHVybiBjb25maWdbYi5uYW1lXSA9IGI7IH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdG9QaXBlcyhjb25maWcpO1xyXG4gICAgfTtcclxuICAgIFByb3RvUGlwZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy5jb25maWdbbmFtZV07XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHByb3ZpZGVyKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGZpbmQgcGlwZSAnXCIgKyBuYW1lICsgXCInLlwiKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb3RvUGlwZXM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJvdG9QaXBlcyA9IFByb3RvUGlwZXM7XHJcbnZhciBQaXBlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaXBlcyhwcm90bywgaW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLnByb3RvID0gcHJvdG87XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9jb25maWcgPSB7fTtcclxuICAgIH1cclxuICAgIFBpcGVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBjYWNoZWQgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQodGhpcy5fY29uZmlnLCBuYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjYWNoZWQpKVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5wcm90by5nZXQobmFtZSk7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChwKTtcclxuICAgICAgICB2YXIgcmVzID0gbmV3IGNkLlNlbGVjdGVkUGlwZSh0cmFuc2Zvcm0sIHAucHVyZSk7XHJcbiAgICAgICAgaWYgKHAucHVyZSkge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQodGhpcy5fY29uZmlnLCBuYW1lLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQaXBlcztcclxufSkoKTtcclxuZXhwb3J0cy5QaXBlcyA9IFBpcGVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XHJcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi4vbWV0YWRhdGEnKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBvciBTdHJpbmcgY29udGFpbmluZyBvbmx5IGEgc3Vic2V0IChzbGljZSkgb2YgdGhlXHJcbiAqIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIHN1YnNldCB0byByZXR1cm4gaXMgc3BlY2lmaWVkIGJ5IHRoZSBgc3RhcnRgIHBhcmFtZXRlci5cclxuICpcclxuICogVGhlIGVuZGluZyBpbmRleCBvZiB0aGUgc3Vic2V0IHRvIHJldHVybiBpcyBzcGVjaWZpZWQgYnkgdGhlIG9wdGlvbmFsIGBlbmRgIHBhcmFtZXRlci5cclxuICpcclxuICogIyBVc2FnZVxyXG4gKlxyXG4gKiAgICAgZXhwcmVzc2lvbiB8IHNsaWNlOnN0YXJ0WzplbmRdXHJcbiAqXHJcbiAqIEFsbCBiZWhhdmlvciBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhlIEphdmFTY3JpcHQgQVBJXHJcbiAqIEFycmF5LnByb3RvdHlwZS5zbGljZSgpIGFuZCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKClcclxuICpcclxuICogV2hlcmUgdGhlIGlucHV0IGV4cHJlc3Npb24gaXMgYSBbTGlzdF0gb3IgW1N0cmluZ10sIGFuZCBgc3RhcnRgIGlzOlxyXG4gKlxyXG4gKiAtICoqYSBwb3NpdGl2ZSBpbnRlZ2VyKio6IHJldHVybiB0aGUgaXRlbSBhdCBfc3RhcnRfIGluZGV4IGFuZCBhbGwgaXRlbXMgYWZ0ZXJcclxuICogaW4gdGhlIGxpc3Qgb3Igc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAqIC0gKiphIG5lZ2F0aXZlIGludGVnZXIqKjogcmV0dXJuIHRoZSBpdGVtIGF0IF9zdGFydF8gaW5kZXggZnJvbSB0aGUgZW5kIGFuZCBhbGwgaXRlbXMgYWZ0ZXJcclxuICogaW4gdGhlIGxpc3Qgb3Igc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAqIC0gKipgfHN0YXJ0fGAgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBhbiBlbXB0eSBsaXN0IG9yIHN0cmluZy5cclxuICogLSAqKmB8c3RhcnR8YCBuZWdhdGl2ZSBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGV4cHJlc3Npb24qKjogcmV0dXJuIGVudGlyZSBsaXN0IG9yXHJcbiAqIHN0cmluZyBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBhbmQgd2hlcmUgYGVuZGAgaXM6XHJcbiAqXHJcbiAqIC0gKipvbWl0dGVkKio6IHJldHVybiBhbGwgaXRlbXMgdW50aWwgdGhlIGVuZCBvZiB0aGUgaW5wdXRcclxuICogLSAqKmEgcG9zaXRpdmUgaW50ZWdlcioqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBfZW5kXyBpbmRleCBvZiB0aGUgbGlzdCBvciBzdHJpbmdcclxuICogZXhwcmVzc2lvbi5cclxuICogLSAqKmEgbmVnYXRpdmUgaW50ZWdlcioqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBfZW5kXyBpbmRleCBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3RcclxuICogb3Igc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgW0xpc3RdLCB0aGUgcmV0dXJuZWQgbGlzdCBpcyBhbHdheXMgYSBjb3B5IGV2ZW4gd2hlbiBhbGxcclxuICogdGhlIGVsZW1lbnRzIGFyZSBiZWluZyByZXR1cm5lZC5cclxuICpcclxuICogIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiAjIyBMaXN0IEV4YW1wbGVcclxuICpcclxuICogQXNzdW1pbmcgYHZhciBjb2xsZWN0aW9uID0gWydhJywgJ2InLCAnYycsICdkJ11gLCB0aGlzIGBuZy1mb3JgIGRpcmVjdGl2ZTpcclxuICpcclxuICogICAgIDxsaSAqbmctZm9yPVwidmFyIGkgaW4gY29sbGVjdGlvbiB8IHNsaWNlOjE6M1wiPnt7aX19PC9saT5cclxuICpcclxuICogcHJvZHVjZXMgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogICAgIDxsaT5iPC9saT5cclxuICogICAgIDxsaT5jPC9saT5cclxuICpcclxuICogIyMgU3RyaW5nIEV4YW1wbGVzXHJcbiAqXHJcbiAqICAgICB7eyAnYWJjZGVmZ2hpaicgfCBzbGljZTowOjQgfX0gICAgICAgLy8gb3V0cHV0IGlzICdhYmNkJ1xyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6NDowIH19ICAgICAgIC8vIG91dHB1dCBpcyAnJ1xyXG4gKiAgICAge3sgJ2FiY2RlZmdoaWonIHwgc2xpY2U6LTQgfX0gICAgICAvLyBvdXRwdXQgaXMgJ2doaWonXHJcbiAqICAgICB7eyAnYWJjZGVmZ2hpaicgfCBzbGljZTotNCwtMiB9fSAgICAgIC8vIG91dHB1dCBpcyAnZ2gnXHJcbiAqICAgICB7eyAnYWJjZGVmZ2hpaicgfCBzbGljZTogLTEwMCB9fSAgICAvLyBvdXRwdXQgaXMgJ2FiY2RlZmdoaWonXHJcbiAqICAgICB7eyAnYWJjZGVmZ2hpaicgfCBzbGljZTogMTAwIH19ICAgIC8vIG91dHB1dCBpcyAnJ1xyXG4gKi9cclxudmFyIFNsaWNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTbGljZVBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICBTbGljZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IG51bGw7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoYXJncykgfHwgYXJncy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1NsaWNlIHBpcGUgcmVxdWlyZXMgb25lIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0cyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFNsaWNlUGlwZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gYXJnc1swXTtcclxuICAgICAgICB2YXIgZW5kID0gYXJncy5sZW5ndGggPiAxID8gYXJnc1sxXSA6IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNsaWNlKHZhbHVlLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5zbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgU2xpY2VQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGxhbmdfMS5pc1N0cmluZyhvYmopIHx8IGxhbmdfMS5pc0FycmF5KG9iaik7IH07XHJcbiAgICBTbGljZVBpcGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBtZXRhZGF0YV8xLlBpcGUoeyBuYW1lOiAnc2xpY2UnIH0pLFxyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgU2xpY2VQaXBlKTtcclxuICAgIHJldHVybiBTbGljZVBpcGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2xpY2VQaXBlID0gU2xpY2VQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV9waXBlLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIG1ldGFkYXRhXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9tZXRhZGF0YScpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdXBwZXJjYXNlIHRyYW5zZm9ybXMgdG8gdGV4dC5cclxuICpcclxuICogIyBFeGFtcGxlXHJcbiAqXHJcbiAqIEluIHRoaXMgZXhhbXBsZSB3ZSB0cmFuc2Zvcm0gdGhlIHVzZXIgdGV4dCB1cHBlcmNhc2UuXHJcbiAqXHJcbiAqICBgYGBcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6IFwidXNlcm5hbWUtY21wXCIsXHJcbiAqICAgdGVtcGxhdGU6IFwiVXNlcm5hbWU6IHt7IHVzZXIgfCB1cHBlcmNhc2UgfX1cIlxyXG4gKiB9KVxyXG4gKiBjbGFzcyBVc2VybmFtZSB7XHJcbiAqICAgdXNlcjpzdHJpbmc7XHJcbiAqIH1cclxuICpcclxuICogYGBgXHJcbiAqL1xyXG52YXIgVXBwZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcHBlckNhc2VQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgVXBwZXJDYXNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFVwcGVyQ2FzZVBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnRvVXBwZXJDYXNlKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBVcHBlckNhc2VQaXBlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksXHJcbiAgICAgICAgbWV0YWRhdGFfMS5QaXBlKHsgbmFtZTogJ3VwcGVyY2FzZScgfSksXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBVcHBlckNhc2VQaXBlKTtcclxuICAgIHJldHVybiBVcHBlckNhc2VQaXBlO1xyXG59KSgpO1xyXG5leHBvcnRzLlVwcGVyQ2FzZVBpcGUgPSBVcHBlckNhc2VQaXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cHBlcmNhc2VfcGlwZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxuZXhwb3J0cy5FWENFUFRJT05fUFJPVklERVIgPSBkaV8xLnByb3ZpZGUoZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXIsIHsgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGV4Y2VwdGlvbnNfMS5FeGNlcHRpb25IYW5kbGVyKGRvbV9hZGFwdGVyXzEuRE9NLCBmYWxzZSk7IH0sIGRlcHM6IFtdIH0pO1xyXG5leHBvcnRzLkVYQ0VQVElPTl9CSU5ESU5HID0gZXhwb3J0cy5FWENFUFRJT05fUFJPVklERVI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtX2JpbmRpbmdzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgaW1wbCA9IHJlcXVpcmUoXCIuL3d0Zl9pbXBsXCIpO1xyXG4vLyBDaGFuZ2UgZXhwb3J0cyB0byBjb25zdCBvbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3RzMmRhcnQvaXNzdWVzLzE1MFxyXG4vKipcclxuICogVHJ1ZSBpZiBXVEYgaXMgZW5hYmxlZC5cclxuICovXHJcbmV4cG9ydHMud3RmRW5hYmxlZCA9IGltcGwuZGV0ZWN0V1RGKCk7XHJcbmZ1bmN0aW9uIG5vb3BTY29wZShhcmcwLCBhcmcxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRyYWNlIHNjb3BlLlxyXG4gKlxyXG4gKiBTY29wZXMgbXVzdCBiZSBzdHJpY3RseSBuZXN0ZWQgYW5kIGFyZSBhbmFsb2dvdXMgdG8gc3RhY2sgZnJhbWVzLCBidXRcclxuICogZG8gbm90IGhhdmUgdG8gZm9sbG93IHRoZSBzdGFjayBmcmFtZXMuIEluc3RlYWQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGV5IGZvbGxvdyBsb2dpY2FsXHJcbiAqIG5lc3RpbmcuIFlvdSBtYXkgd2FudCB0byB1c2VcclxuICogW0V2ZW50XHJcbiAqIFNpZ25hdHVyZXNdKGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL3RyYWNpbmctZnJhbWV3b3JrL2luc3RydW1lbnRpbmctY29kZS5odG1sI2N1c3RvbS1ldmVudHMpXHJcbiAqIGFzIHRoZXkgYXJlIGRlZmluZWQgaW4gV1RGLlxyXG4gKlxyXG4gKiBVc2VkIHRvIG1hcmsgc2NvcGUgZW50cnkuIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCB0byBsZWF2ZSB0aGUgc2NvcGUuXHJcbiAqXHJcbiAqICAgICB2YXIgbXlTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdNeUNsYXNzI215TWV0aG9kKGFzY2lpIHNvbWVWYWwpJyk7XHJcbiAqXHJcbiAqICAgICBzb21lTWV0aG9kKCkge1xyXG4gKiAgICAgICAgdmFyIHMgPSBteVNjb3BlKCdGb28nKTsgLy8gJ0ZvbycgZ2V0cyBzdG9yZWQgaW4gdHJhY2luZyBVSVxyXG4gKiAgICAgICAgLy8gRE8gU09NRSBXT1JLIEhFUkVcclxuICogICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCAxMjMpOyAvLyBSZXR1cm4gdmFsdWUgMTIzXHJcbiAqICAgICB9XHJcbiAqXHJcbiAqIE5vdGUsIGFkZGluZyB0cnktZmluYWxseSBibG9jayBhcm91bmQgdGhlIHdvcmsgdG8gZW5zdXJlIHRoYXQgYHd0ZkxlYXZlYCBnZXRzIGNhbGxlZCBjYW5cclxuICogbmVnYXRpdmVseSBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgYXBwbGljYXRpb24uIEZvciB0aGlzIHJlYXNvbiB3ZSByZWNvbW1lbmQgdGhhdFxyXG4gKiB5b3UgZG9uJ3QgYWRkIHRoZW0gdG8gZW5zdXJlIHRoYXQgYHd0ZkxlYXZlYCBnZXRzIGNhbGxlZC4gSW4gcHJvZHVjdGlvbiBgd3RmTGVhdmVgIGlzIGEgbm9vcCBhbmRcclxuICogc28gdHJ5LWZpbmFsbHkgYmxvY2sgaGFzIG5vIHZhbHVlLiBXaGVuIGRlYnVnZ2luZyBwZXJmIGlzc3Vlcywgc2tpcHBpbmcgYHd0ZkxlYXZlYCwgZG8gdG9cclxuICogZXhjZXB0aW9uLCB3aWxsIHByb2R1Y2UgaW5jb3JyZWN0IHRyYWNlLCBidXQgcHJlc2VuY2Ugb2YgZXhjZXB0aW9uIHNpZ25pZmllcyBsb2dpYyBlcnJvciB3aGljaFxyXG4gKiBuZWVkcyB0byBiZSBmaXhlZCBiZWZvcmUgdGhlIGFwcCBzaG91bGQgYmUgcHJvZmlsZWQuIEFkZCB0cnktZmluYWxseSBvbmx5IHdoZW4geW91IGV4cGVjdCB0aGF0XHJcbiAqIGFuIGV4Y2VwdGlvbiBpcyBleHBlY3RlZCBkdXJpbmcgbm9ybWFsIGV4ZWN1dGlvbiB3aGlsZSBwcm9maWxpbmcuXHJcbiAqXHJcbiAqL1xyXG5leHBvcnRzLnd0ZkNyZWF0ZVNjb3BlID0gZXhwb3J0cy53dGZFbmFibGVkID8gaW1wbC5jcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIG1hcmsgZW5kIG9mIFNjb3BlLlxyXG4gKlxyXG4gKiAtIGBzY29wZWAgdG8gZW5kLlxyXG4gKiAtIGByZXR1cm5WYWx1ZWAgKG9wdGlvbmFsKSB0byBiZSBwYXNzZWQgdG8gdGhlIFdURi5cclxuICpcclxuICogUmV0dXJucyB0aGUgYHJldHVyblZhbHVlIGZvciBlYXN5IGNoYWluaW5nLlxyXG4gKi9cclxuZXhwb3J0cy53dGZMZWF2ZSA9IGV4cG9ydHMud3RmRW5hYmxlZCA/IGltcGwubGVhdmUgOiBmdW5jdGlvbiAocywgcikgeyByZXR1cm4gcjsgfTtcclxuLyoqXHJcbiAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXHJcbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbiB0aGUgY2FsbCB0byBbZW5kQXN5bmNdLiBBc3luYyByYW5nZXMgb25seSB3b3JrIGlmIFdURiBoYXMgYmVlblxyXG4gKiBlbmFibGVkLlxyXG4gKlxyXG4gKiAgICAgc29tZU1ldGhvZCgpIHtcclxuICogICAgICAgIHZhciBzID0gd3RmU3RhcnRUaW1lUmFuZ2UoJ0hUVFA6R0VUJywgJ3NvbWUudXJsJyk7XHJcbiAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XHJcbiAqICAgICAgICAgIHd0ZkVuZFRpbWVSYW5nZShzKTtcclxuICogICAgICAgIH0pO1xyXG4gKiAgICAgfVxyXG4gKi9cclxuZXhwb3J0cy53dGZTdGFydFRpbWVSYW5nZSA9IGV4cG9ydHMud3RmRW5hYmxlZCA/IGltcGwuc3RhcnRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocmFuZ2VUeXBlLCBhY3Rpb24pIHsgcmV0dXJuIG51bGw7IH07XHJcbi8qKlxyXG4gKiBFbmRzIGEgYXN5bmMgdGltZSByYW5nZSBvcGVyYXRpb24uXHJcbiAqIFtyYW5nZV0gaXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFt3dGZTdGFydFRpbWVSYW5nZV0gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cclxuICogZW5hYmxlZC5cclxuICovXHJcbmV4cG9ydHMud3RmRW5kVGltZVJhbmdlID0gZXhwb3J0cy53dGZFbmFibGVkID8gaW1wbC5lbmRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2ZpbGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9mYWNhZGUvbGFuZycpO1xyXG52YXIgdHJhY2U7XHJcbnZhciBldmVudHM7XHJcbmZ1bmN0aW9uIGRldGVjdFdURigpIHtcclxuICAgIHZhciB3dGYgPSBsYW5nXzEuZ2xvYmFsWyd3dGYnXTtcclxuICAgIGlmICh3dGYpIHtcclxuICAgICAgICB0cmFjZSA9IHd0ZlsndHJhY2UnXTtcclxuICAgICAgICBpZiAodHJhY2UpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gdHJhY2VbJ2V2ZW50cyddO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5kZXRlY3RXVEYgPSBkZXRlY3RXVEY7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpIHtcclxuICAgIGlmIChmbGFncyA9PT0gdm9pZCAwKSB7IGZsYWdzID0gbnVsbDsgfVxyXG4gICAgcmV0dXJuIGV2ZW50cy5jcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZVNjb3BlID0gY3JlYXRlU2NvcGU7XHJcbmZ1bmN0aW9uIGxlYXZlKHNjb3BlLCByZXR1cm5WYWx1ZSkge1xyXG4gICAgdHJhY2UubGVhdmVTY29wZShzY29wZSwgcmV0dXJuVmFsdWUpO1xyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG59XHJcbmV4cG9ydHMubGVhdmUgPSBsZWF2ZTtcclxuZnVuY3Rpb24gc3RhcnRUaW1lUmFuZ2UocmFuZ2VUeXBlLCBhY3Rpb24pIHtcclxuICAgIHJldHVybiB0cmFjZS5iZWdpblRpbWVSYW5nZShyYW5nZVR5cGUsIGFjdGlvbik7XHJcbn1cclxuZXhwb3J0cy5zdGFydFRpbWVSYW5nZSA9IHN0YXJ0VGltZVJhbmdlO1xyXG5mdW5jdGlvbiBlbmRUaW1lUmFuZ2UocmFuZ2UpIHtcclxuICAgIHRyYWNlLmVuZFRpbWVSYW5nZShyYW5nZSk7XHJcbn1cclxuZXhwb3J0cy5lbmRUaW1lUmFuZ2UgPSBlbmRUaW1lUmFuZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXd0Zl9pbXBsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvKipcclxuICogVGhpcyBpcyBoZXJlIGJlY2F1c2UgREFSVCByZXF1aXJlcyBpdC4gSXQgaXMgbm9vcCBpbiBKUy5cclxuICovXHJcbmZ1bmN0aW9uIHd0ZkluaXQoKSB7IH1cclxuZXhwb3J0cy53dGZJbml0ID0gd3RmSW5pdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3RmX2luaXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciByZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdG9yJyk7XHJcbnZhciByZWZsZWN0b3JfMiA9IHJlcXVpcmUoJy4vcmVmbGVjdG9yJyk7XHJcbmV4cG9ydHMuUmVmbGVjdG9yID0gcmVmbGVjdG9yXzIuUmVmbGVjdG9yO1xyXG5leHBvcnRzLlJlZmxlY3Rpb25JbmZvID0gcmVmbGVjdG9yXzIuUmVmbGVjdGlvbkluZm87XHJcbnZhciByZWZsZWN0aW9uX2NhcGFiaWxpdGllc18xID0gcmVxdWlyZSgnLi9yZWZsZWN0aW9uX2NhcGFiaWxpdGllcycpO1xyXG5leHBvcnRzLnJlZmxlY3RvciA9IG5ldyByZWZsZWN0b3JfMS5SZWZsZWN0b3IobmV3IHJlZmxlY3Rpb25fY2FwYWJpbGl0aWVzXzEuUmVmbGVjdGlvbkNhcGFiaWxpdGllcygpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVmbGVjdGlvbkNhcGFiaWxpdGllcyhyZWZsZWN0KSB7XHJcbiAgICAgICAgdGhpcy5fcmVmbGVjdCA9IGxhbmdfMS5pc1ByZXNlbnQocmVmbGVjdCkgPyByZWZsZWN0IDogbGFuZ18xLmdsb2JhbC5SZWZsZWN0O1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBzd2l0Y2ggKHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgdCgpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExKSB7IHJldHVybiBuZXcgdChhMSk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyKSB7IHJldHVybiBuZXcgdChhMSwgYTIpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHsgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHsgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7IH07XHJcbiAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHsgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpOyB9O1xyXG4gICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIDE5OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4LCBhMTkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCwgYTE5KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgMjA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgsIGExOSwgYTIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgsIGExOSwgYTIwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgZmFjdG9yeSBmb3IgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeSh0KSArIFwiJyBiZWNhdXNlIGl0cyBjb25zdHJ1Y3RvciBoYXMgbW9yZSB0aGFuIDIwIGFyZ3VtZW50c1wiKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5femlwVHlwZXNBbmRBbm5vdGFpb25zID0gZnVuY3Rpb24gKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShwYXJhbUFubm90YXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHBhcmFtVHlwZXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVFMgb3V0cHV0cyBPYmplY3QgZm9yIHBhcmFtZXRlcnMgd2l0aG91dCB0eXBlcywgd2hpbGUgVHJhY2V1ciBvbWl0c1xyXG4gICAgICAgICAgICAvLyB0aGUgYW5ub3RhdGlvbnMuIEZvciBub3cgd2UgcHJlc2VydmUgdGhlIFRyYWNldXIgYmVoYXZpb3IgdG8gYWlkXHJcbiAgICAgICAgICAgIC8vIG1pZ3JhdGlvbiwgYnV0IHRoaXMgY2FuIGJlIHJldmlzaXRlZC5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbVR5cGVzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlc1tpXSAhPSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtwYXJhbVR5cGVzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnMpICYmIGxhbmdfMS5pc1ByZXNlbnQocGFyYW1Bbm5vdGF0aW9uc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5jb25jYXQocGFyYW1Bbm5vdGF0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZU9yRnVuYy5wYXJhbWV0ZXJzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZU9yRnVuYy5wYXJhbWV0ZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIHR5cGVPckZ1bmMpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1UeXBlcyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgdHlwZU9yRnVuYyk7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmFtVHlwZXMpIHx8IGxhbmdfMS5pc1ByZXNlbnQocGFyYW1Bbm5vdGF0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YWlvbnMocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodHlwZU9yRnVuYy5sZW5ndGgpO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZU9yRnVuYy5hbm5vdGF0aW9ucykpIHtcclxuICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdHlwZU9yRnVuYy5hbm5vdGF0aW9ucztcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGFubm90YXRpb25zKSAmJiBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QpICYmIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCB0eXBlT3JGdW5jKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYW5ub3RhdGlvbnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZU9yRnVuYy5wcm9wTWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0eXBlT3JGdW5jLnByb3BNZXRhZGF0YTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKHByb3BNZXRhZGF0YSkgJiYgcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0gcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdwcm9wTWV0YWRhdGEnLCB0eXBlT3JGdW5jKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvcE1ldGFkYXRhKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbnRlcmZhY2VzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJKYXZhU2NyaXB0IGRvZXMgbm90IHN1cHBvcnQgaW50ZXJmYWNlc1wiKTtcclxuICAgIH07XHJcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ3JldHVybiBvLicgKyBuYW1lICsgJzsnKTsgfTtcclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICd2JywgJ3JldHVybiBvLicgKyBuYW1lICsgJyA9IHY7Jyk7XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gXCJpZiAoIW8uXCIgKyBuYW1lICsgXCIpIHRocm93IG5ldyBFcnJvcignXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyB1bmRlZmluZWQnKTtcXG4gICAgICAgIHJldHVybiBvLlwiICsgbmFtZSArIFwiLmFwcGx5KG8sIGFyZ3MpO1wiO1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAnYXJncycsIGZ1bmN0aW9uQm9keSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlcmUgaXMgbm90IGEgY29uY2VwdCBvZiBpbXBvcnQgdXJpIGluIEpzLCBidXQgdGhpcyBpcyB1c2VmdWwgaW4gZGV2ZWxvcGluZyBEYXJ0IGFwcGxpY2F0aW9ucy5cclxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiAnLi8nOyB9O1xyXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3Rpb25fY2FwYWJpbGl0aWVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgUmVmbGVjdGlvbkluZm8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVmbGVjdGlvbkluZm8oYW5ub3RhdGlvbnMsIHBhcmFtZXRlcnMsIGZhY3RvcnksIGludGVyZmFjZXMsIHByb3BNZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VzID0gaW50ZXJmYWNlcztcclxuICAgICAgICB0aGlzLnByb3BNZXRhZGF0YSA9IHByb3BNZXRhZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWZsZWN0aW9uSW5mbztcclxufSkoKTtcclxuZXhwb3J0cy5SZWZsZWN0aW9uSW5mbyA9IFJlZmxlY3Rpb25JbmZvO1xyXG52YXIgUmVmbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlZmxlY3RvcihyZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2luamVjdGFibGVJbmZvID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fZ2V0dGVycyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3NldHRlcnMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9tZXRob2RzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLl91c2VkS2V5cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gcmVmbGVjdGlvbkNhcGFiaWxpdGllcztcclxuICAgIH1cclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5pc1JlZmxlY3Rpb25FbmFibGVkKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIENhdXNlcyBgdGhpc2AgcmVmbGVjdG9yIHRvIHRyYWNrIGtleXMgdXNlZCB0byBhY2Nlc3NcclxuICAgICAqIHtAbGluayBSZWZsZWN0aW9uSW5mb30gb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS50cmFja1VzYWdlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl91c2VkS2V5cyA9IG5ldyBjb2xsZWN0aW9uXzEuU2V0KCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIExpc3RzIHR5cGVzIGZvciB3aGljaCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBub3QgcmVxdWVzdGVkIHNpbmNlXHJcbiAgICAgKiB7QGxpbmsgI3RyYWNrVXNhZ2V9IHdhcyBjYWxsZWQuIFRoaXMgbGlzdCBjb3VsZCBsYXRlciBiZSBhdWRpdGVkIGFzXHJcbiAgICAgKiBwb3RlbnRpYWwgZGVhZCBjb2RlLlxyXG4gICAgICovXHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmxpc3RVbnVzZWRLZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VzZWRLZXlzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdVc2FnZSB0cmFja2luZyBpcyBkaXNhYmxlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsVHlwZXMgPSBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci5rZXlzKHRoaXMuX2luamVjdGFibGVJbmZvKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpbHRlcihhbGxUeXBlcywgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhfdGhpcy5fdXNlZEtleXMsIGtleSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBmdW5jSW5mbykge1xyXG4gICAgICAgIHRoaXMuX2luamVjdGFibGVJbmZvLnNldChmdW5jLCBmdW5jSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZWdpc3RlclR5cGUgPSBmdW5jdGlvbiAodHlwZSwgdHlwZUluZm8pIHtcclxuICAgICAgICB0aGlzLl9pbmplY3RhYmxlSW5mby5zZXQodHlwZSwgdHlwZUluZm8pO1xyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJHZXR0ZXJzID0gZnVuY3Rpb24gKGdldHRlcnMpIHsgX21lcmdlTWFwcyh0aGlzLl9nZXR0ZXJzLCBnZXR0ZXJzKTsgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJTZXR0ZXJzID0gZnVuY3Rpb24gKHNldHRlcnMpIHsgX21lcmdlTWFwcyh0aGlzLl9zZXR0ZXJzLCBzZXR0ZXJzKTsgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZHMpIHsgX21lcmdlTWFwcyh0aGlzLl9tZXRob2RzLCBtZXRob2RzKTsgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zUmVmbGVjdGlvbkluZm8odHlwZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGUpLmZhY3Rvcnk7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlcykgPyByZXMgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5mYWN0b3J5KHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYykpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGVPckZ1bmMpLnBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlcykgPyByZXMgOiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luamVjdGFibGVJbmZvLmhhcyh0eXBlT3JGdW5jKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fZ2V0UmVmbGVjdGlvbkluZm8odHlwZU9yRnVuYykuYW5ub3RhdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlcykgPyByZXMgOiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuYW5ub3RhdGlvbnModHlwZU9yRnVuYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlT3JGdW5jKS5wcm9wTWV0YWRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlcykgPyByZXMgOiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvcE1ldGFkYXRhKHR5cGVPckZ1bmMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXMgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGUpLmludGVyZmFjZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlcykgPyByZXMgOiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW50ZXJmYWNlcyh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9nZXR0ZXJzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0dGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmdldHRlcihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZXR0ZXJzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnNldHRlcihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXRob2RzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWV0aG9kcy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLm1ldGhvZChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5fZ2V0UmVmbGVjdGlvbkluZm8gPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3VzZWRLZXlzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VkS2V5cy5hZGQodHlwZU9yRnVuYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3RhYmxlSW5mby5nZXQodHlwZU9yRnVuYyk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5fY29udGFpbnNSZWZsZWN0aW9uSW5mbyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7IHJldHVybiB0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYyk7IH07XHJcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW1wb3J0VXJpKHR5cGUpOyB9O1xyXG4gICAgcmV0dXJuIFJlZmxlY3RvcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZWZsZWN0b3IgPSBSZWZsZWN0b3I7XHJcbmZ1bmN0aW9uIF9tZXJnZU1hcHModGFyZ2V0LCBjb25maWcpIHtcclxuICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goY29uZmlnLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gdGFyZ2V0LnNldChrLCB2KTsgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBQdWJsaWMgQVBJIGZvciByZW5kZXJcclxudmFyIHJlbmRlcl8xID0gcmVxdWlyZSgnLi9yZW5kZXIvcmVuZGVyJyk7XHJcbmV4cG9ydHMuUmVuZGVyZXIgPSByZW5kZXJfMS5SZW5kZXJlcjtcclxuZXhwb3J0cy5SZW5kZXJWaWV3UmVmID0gcmVuZGVyXzEuUmVuZGVyVmlld1JlZjtcclxuZXhwb3J0cy5SZW5kZXJQcm90b1ZpZXdSZWYgPSByZW5kZXJfMS5SZW5kZXJQcm90b1ZpZXdSZWY7XHJcbmV4cG9ydHMuUmVuZGVyRnJhZ21lbnRSZWYgPSByZW5kZXJfMS5SZW5kZXJGcmFnbWVudFJlZjtcclxuZXhwb3J0cy5SZW5kZXJWaWV3V2l0aEZyYWdtZW50cyA9IHJlbmRlcl8xLlJlbmRlclZpZXdXaXRoRnJhZ21lbnRzO1xyXG5leHBvcnRzLkRPQ1VNRU5UID0gcmVuZGVyXzEuRE9DVU1FTlQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBQcm90b1ZpZXcgaW4gdGhlIFJlbmRlcmluZyBDb250ZXh0LlxyXG4gKlxyXG4gKiBXaGVuIHlvdSBpbXBsZW1lbnQgYSBjdXN0b20ge0BsaW5rIFJlbmRlcmVyfSwgYFJlbmRlclByb3RvVmlld1JlZmAgc3BlY2lmaWVzIHdoYXQgUmVuZGVyIFZpZXdcclxuICogeW91ciByZW5kZXJlciBzaG91bGQgY3JlYXRlLlxyXG4gKlxyXG4gKiBgUmVuZGVyUHJvdG9WaWV3UmVmYCBpcyBhIGNvdW50ZXJwYXJ0IHRvIHtAbGluayBQcm90b1ZpZXdSZWZ9IGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb25cclxuICogQ29udGV4dC4gQnV0IHVubGlrZSBgUHJvdG9WaWV3UmVmYCwgYFJlbmRlclByb3RvVmlld1JlZmAgY29udGFpbnMgYWxsIHN0YXRpYyBuZXN0ZWQgUHJvdG8gVmlld3NcclxuICogdGhhdCBhcmUgcmVjdXJzaXZlbHkgbWVyZ2VkIGludG8gYSBzaW5nbGUgUmVuZGVyIFByb3RvIFZpZXcuXHJcblxyXG4gKlxyXG4gKiA8IS0tIFRPRE86IHRoaXMgaXMgY3JlYXRlZCBieSBSZW5kZXJlciNjcmVhdGVQcm90b1ZpZXcgaW4gdGhlIG5ldyBjb21waWxlciAtLT5cclxuICovXHJcbnZhciBSZW5kZXJQcm90b1ZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyUHJvdG9WaWV3UmVmKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbmRlclByb3RvVmlld1JlZjtcclxufSkoKTtcclxuZXhwb3J0cy5SZW5kZXJQcm90b1ZpZXdSZWYgPSBSZW5kZXJQcm90b1ZpZXdSZWY7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbGlzdCBvZiBzaWJsaW5nIE5vZGVzIHRoYXQgY2FuIGJlIG1vdmVkIGJ5IHRoZSB7QGxpbmsgUmVuZGVyZXJ9IGluZGVwZW5kZW50bHkgb2ZcclxuICogb3RoZXIgUmVuZGVyIEZyYWdtZW50cy5cclxuICpcclxuICogQW55IHtAbGluayBSZW5kZXJWaWV3fSBoYXMgb25lIFJlbmRlciBGcmFnbWVudC5cclxuICpcclxuICogQWRkaXRpb25hbGx5IGFueSBWaWV3IHdpdGggYW4gRW1iZWRkZWQgVmlldyB0aGF0IGNvbnRhaW5zIGEge0BsaW5rIE5nQ29udGVudCBWaWV3IFByb2plY3Rpb259XHJcbiAqIHJlc3VsdHMgaW4gYWRkaXRpb25hbCBSZW5kZXIgRnJhZ21lbnQuXHJcbiAqL1xyXG4vKlxyXG4gIDxkaXY+Zm9vPC9kaXY+XHJcbiAge3tiYXJ9fVxyXG5cclxuXHJcbiAgPGRpdj5mb288L2Rpdj4gLT4gdmlldyAxIC8gZnJhZ21lbnQgMVxyXG4gIDx1bD5cclxuICAgIDx0ZW1wbGF0ZSBuZy1mb3I+XHJcbiAgICAgIDxsaT57e2ZnfX08L2xpPiAtPiB2aWV3IDIgLyBmcmFnbWVudCAxXHJcbiAgICA8L3RlbXBsYXRlPlxyXG4gIDwvdWw+XHJcbiAge3tiYXJ9fVxyXG5cclxuXHJcbiAgPGRpdj5mb288L2Rpdj4gLT4gdmlldyAxIC8gZnJhZ21lbnQgMVxyXG4gIDx1bD5cclxuICAgIDx0ZW1wbGF0ZSBuZy1pZj5cclxuICAgICAgPGxpPjxuZy1jb250ZW50PjwvPjwvbGk+IC0+IHZpZXcgMSAvIGZyYWdtZW50IDJcclxuICAgIDwvdGVtcGxhdGU+XHJcbiAgICA8dGVtcGxhdGUgbmctZm9yPlxyXG4gICAgICA8bGk+PG5nLWNvbnRlbnQ+PC8+PC9saT4gLT5cclxuICAgICAgPGxpPjwvbGk+ICAgICAgICAgICAgICAgIC0+IHZpZXcgMSAvIGZyYWdtZW50IDIgKyB2aWV3IDIgLyBmcmFnbWVudCAxLi5uLTFcclxuICAgIDwvdGVtcGxhdGU+XHJcbiAgPC91bD5cclxuICB7e2Jhcn19XHJcbiAqL1xyXG4vLyBUT0RPKGkpOiByZWZhY3RvciBpbnRvIGFuIGludGVyZmFjZVxyXG52YXIgUmVuZGVyRnJhZ21lbnRSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyRnJhZ21lbnRSZWYoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVuZGVyRnJhZ21lbnRSZWY7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVuZGVyRnJhZ21lbnRSZWYgPSBSZW5kZXJGcmFnbWVudFJlZjtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBWaWV3IGluIHRoZSBSZW5kZXJpbmcgQ29udGV4dC5cclxuICpcclxuICogYFJlbmRlclZpZXdSZWZgIHNwZWNpZmllcyB0byB0aGUge0BsaW5rIFJlbmRlcmVyfSB3aGF0IFZpZXcgdG8gdXBkYXRlIG9yIGRlc3Ryb3kuXHJcbiAqXHJcbiAqIFVubGlrZSBhIHtAbGluayBWaWV3UmVmfSBhdmFpbGFibGUgaW4gdGhlIEFwcGxpY2F0aW9uIENvbnRleHQsIFJlbmRlciBWaWV3IGNvbnRhaW5zIGFsbCB0aGVcclxuICogc3RhdGljIENvbXBvbmVudCBWaWV3cyB0aGF0IGhhdmUgYmVlbiByZWN1cnNpdmVseSBtZXJnZWQgaW50byBhIHNpbmdsZSBSZW5kZXIgVmlldy5cclxuICpcclxuICogRWFjaCBgUmVuZGVyVmlld1JlZmAgY29udGFpbnMgb25lIG9yIG1vcmUge0BsaW5rIFJlbmRlckZyYWdtZW50UmVmIFJlbmRlciBGcmFnbWVudHN9LCB0aGVzZVxyXG4gKiBGcmFnbWVudHMgYXJlIGNyZWF0ZWQsIGh5ZHJhdGVkLCBkZWh5ZHJhdGVkIGFuZCBkZXN0cm95ZWQgYXMgYSBzaW5nbGUgdW5pdCB0b2dldGhlciB3aXRoIHRoZVxyXG4gKiBWaWV3LlxyXG4gKi9cclxuLy8gVE9ETyhpKTogcmVmYWN0b3IgaW50byBhbiBpbnRlcmZhY2VcclxudmFyIFJlbmRlclZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyVmlld1JlZigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBSZW5kZXJWaWV3UmVmO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlbmRlclZpZXdSZWYgPSBSZW5kZXJWaWV3UmVmO1xyXG4vKipcclxuICogQ29udGFpbmVyIGNsYXNzIHByb2R1Y2VkIGJ5IGEge0BsaW5rIFJlbmRlcmVyfSB3aGVuIGNyZWF0aW5nIGEgUmVuZGVyIFZpZXcuXHJcbiAqXHJcbiAqIEFuIGluc3RhbmNlIG9mIGBSZW5kZXJWaWV3V2l0aEZyYWdtZW50c2AgY29udGFpbnMgYSB7QGxpbmsgUmVuZGVyVmlld1JlZn0gYW5kIGFuIGFycmF5IG9mXHJcbiAqIHtAbGluayBSZW5kZXJGcmFnbWVudFJlZn1zIGJlbG9uZ2luZyB0byB0aGlzIFJlbmRlciBWaWV3LlxyXG4gKi9cclxuLy8gVE9ETyhpKTogcmVmYWN0b3IgdGhpcyBieSBSZW5kZXJWaWV3V2l0aEZyYWdtZW50cyBhbmQgYWRkaW5nIGZyYWdtZW50cyBkaXJlY3RseSB0byBSZW5kZXJWaWV3UmVmXHJcbnZhciBSZW5kZXJWaWV3V2l0aEZyYWdtZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZW5kZXJWaWV3V2l0aEZyYWdtZW50cyhcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHtAbGluayBSZW5kZXJWaWV3UmVmfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2aWV3UmVmLCBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcnJheSBvZiB7QGxpbmsgUmVuZGVyRnJhZ21lbnRSZWZ9cyBvcmRlcmVkIGluIHRoZSBkZXB0aC1maXJzdCBvcmRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmcmFnbWVudFJlZnMpIHtcclxuICAgICAgICB0aGlzLnZpZXdSZWYgPSB2aWV3UmVmO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRSZWZzID0gZnJhZ21lbnRSZWZzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbmRlclZpZXdXaXRoRnJhZ21lbnRzO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlbmRlclZpZXdXaXRoRnJhZ21lbnRzID0gUmVuZGVyVmlld1dpdGhGcmFnbWVudHM7XHJcbi8qKlxyXG4gKiBJbmplY3RhYmxlIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBhIGxvdy1sZXZlbCBpbnRlcmZhY2UgZm9yIG1vZGlmeWluZyB0aGUgVUkuXHJcbiAqXHJcbiAqIFVzZSB0aGlzIHNlcnZpY2UgdG8gYnlwYXNzIEFuZ3VsYXIncyB0ZW1wbGF0aW5nIGFuZCBtYWtlIGN1c3RvbSBVSSBjaGFuZ2VzIHRoYXQgY2FuJ3QgYmVcclxuICogZXhwcmVzc2VkIGRlY2xhcmF0aXZlbHkuIEZvciBleGFtcGxlIGlmIHlvdSBuZWVkIHRvIHNldCBhIHByb3BlcnR5IG9yIGFuIGF0dHJpYnV0ZSB3aG9zZSBuYW1lIGlzXHJcbiAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rICNzZXRFbGVtZW50UHJvcGVydHl9IG9yIHtAbGluayAjc2V0RWxlbWVudEF0dHJpYnV0ZX1cclxuICogcmVzcGVjdGl2ZWx5LlxyXG4gKlxyXG4gKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSByZW5kZXJlciwgeW91IG11c3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCBSZW5kZXJlciBpbXBsZW1lbnRhdGlvbiBpcyB7QGxpbmsgRG9tUmVuZGVyZXJ9LiBBbHNvIHNlZSB7QGxpbmsgV2ViV29ya2VyUmVuZGVyZXJ9LlxyXG4gKi9cclxudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBhbmltYXRpb25fYnVpbGRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2FuaW1hdGUvYW5pbWF0aW9uX2J1aWxkZXInKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9ldmVudHMvZXZlbnRfbWFuYWdlcicpO1xyXG52YXIgc2hhcmVkX3N0eWxlc19ob3N0XzEgPSByZXF1aXJlKCcuL3NoYXJlZF9zdHlsZXNfaG9zdCcpO1xyXG52YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi4vLi4vcHJvZmlsZS9wcm9maWxlJyk7XHJcbnZhciBhcGlfMSA9IHJlcXVpcmUoJy4uL2FwaScpO1xyXG52YXIgZG9tX3Rva2Vuc18xID0gcmVxdWlyZSgnLi9kb21fdG9rZW5zJyk7XHJcbnZhciB2aWV3X2ZhY3RvcnlfMSA9IHJlcXVpcmUoJy4uL3ZpZXdfZmFjdG9yeScpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZSgnLi4vdmlldycpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBEb21SZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRG9tUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEb21SZW5kZXJlcigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVQcm90b1ZpZXcgPSBmdW5jdGlvbiAoY21kcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgdmlld18xLkRlZmF1bHRQcm90b1ZpZXdSZWYoY21kcyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmdldE5hdGl2ZUVsZW1lbnRTeW5jID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVJbnRlcm5hbERvbVZpZXcobG9jYXRpb24ucmVuZGVyVmlldykuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmdldFJvb3ROb2RlcyA9IGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gcmVzb2x2ZUludGVybmFsRG9tRnJhZ21lbnQoZnJhZ21lbnQpOyB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaEZyYWdtZW50QWZ0ZXJGcmFnbWVudCA9IGZ1bmN0aW9uIChwcmV2aW91c0ZyYWdtZW50UmVmLCBmcmFnbWVudFJlZikge1xyXG4gICAgICAgIHZhciBwcmV2aW91c0ZyYWdtZW50Tm9kZXMgPSByZXNvbHZlSW50ZXJuYWxEb21GcmFnbWVudChwcmV2aW91c0ZyYWdtZW50UmVmKTtcclxuICAgICAgICBpZiAocHJldmlvdXNGcmFnbWVudE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBwcmV2aW91c0ZyYWdtZW50Tm9kZXNbcHJldmlvdXNGcmFnbWVudE5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSByZXNvbHZlSW50ZXJuYWxEb21GcmFnbWVudChmcmFnbWVudFJlZik7XHJcbiAgICAgICAgICAgIG1vdmVOb2Rlc0FmdGVyU2libGluZyhzaWJsaW5nLCBub2Rlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZU5vZGVzRW50ZXIobm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIG5vZGVzIGJlaW5nIGFkZGVkIHRvIHRoZSBET00gYW5kIGFuaW1hdGVzIHRoZW0gaWYgbmVjZXNzYXJ5XHJcbiAgICAgKiBAcGFyYW0gbm9kZXNcclxuICAgICAqL1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGVOb2Rlc0VudGVyID0gZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlTm9kZUVudGVyKG5vZGVzW2ldKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoRnJhZ21lbnRBZnRlckVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudFJlZiwgZnJhZ21lbnRSZWYpIHtcclxuICAgICAgICB2YXIgcGFyZW50VmlldyA9IHJlc29sdmVJbnRlcm5hbERvbVZpZXcoZWxlbWVudFJlZi5yZW5kZXJWaWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHBhcmVudFZpZXcuYm91bmRFbGVtZW50c1tlbGVtZW50UmVmLmJvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgbm9kZXMgPSByZXNvbHZlSW50ZXJuYWxEb21GcmFnbWVudChmcmFnbWVudFJlZik7XHJcbiAgICAgICAgbW92ZU5vZGVzQWZ0ZXJTaWJsaW5nKGVsZW1lbnQsIG5vZGVzKTtcclxuICAgICAgICB0aGlzLmFuaW1hdGVOb2Rlc0VudGVyKG5vZGVzKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuaHlkcmF0ZVZpZXcgPSBmdW5jdGlvbiAodmlld1JlZikgeyByZXNvbHZlSW50ZXJuYWxEb21WaWV3KHZpZXdSZWYpLmh5ZHJhdGUoKTsgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5kZWh5ZHJhdGVWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHsgcmVzb2x2ZUludGVybmFsRG9tVmlldyh2aWV3UmVmKS5kZWh5ZHJhdGUoKTsgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZUFuY2hvciA9IGZ1bmN0aW9uIChhdHRyTmFtZUFuZFZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcsIGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZG9tX2FkYXB0ZXJfMS5ET00uY3JlYXRlVGV4dE5vZGUobGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgPyB2YWx1ZSA6ICcnKTsgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7IGRvbV9hZGFwdGVyXzEuRE9NLmFwcGVuZENoaWxkKHBhcmVudCwgY2hpbGQpOyB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGxvY2F0aW9uLnJlbmRlclZpZXcpO1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldFByb3BlcnR5KHZpZXcuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF0sIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobG9jYXRpb24sIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGxvY2F0aW9uLnJlbmRlclZpZXcpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdmlldy5ib3VuZEVsZW1lbnRzW2xvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICB2YXIgZGFzaENhc2VkQXR0cmlidXRlTmFtZSA9IHV0aWxfMS5jYW1lbENhc2VUb0Rhc2hDYXNlKGF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF0dHJpYnV0ZVZhbHVlKSkge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgZGFzaENhc2VkQXR0cmlidXRlTmFtZSwgbGFuZ18xLnN0cmluZ2lmeShhdHRyaWJ1dGVWYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGRhc2hDYXNlZEF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudENsYXNzID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBjbGFzc05hbWUsIGlzQWRkKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGxvY2F0aW9uLnJlbmRlclZpZXcpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdmlldy5ib3VuZEVsZW1lbnRzW2xvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICBpZiAoaXNBZGQpIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAobG9jYXRpb24sIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyhsb2NhdGlvbi5yZW5kZXJWaWV3KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuYm91bmRFbGVtZW50c1tsb2NhdGlvbi5ib3VuZEVsZW1lbnRJbmRleF07XHJcbiAgICAgICAgdmFyIGRhc2hDYXNlZFN0eWxlTmFtZSA9IHV0aWxfMS5jYW1lbENhc2VUb0Rhc2hDYXNlKHN0eWxlTmFtZSk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3R5bGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uc2V0U3R5bGUoZWxlbWVudCwgZGFzaENhc2VkU3R5bGVOYW1lLCBsYW5nXzEuc3RyaW5naWZ5KHN0eWxlVmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZVN0eWxlKGVsZW1lbnQsIGRhc2hDYXNlZFN0eWxlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5pbnZva2VFbGVtZW50TWV0aG9kID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSByZXNvbHZlSW50ZXJuYWxEb21WaWV3KGxvY2F0aW9uLnJlbmRlclZpZXcpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdmlldy5ib3VuZEVsZW1lbnRzW2xvY2F0aW9uLmJvdW5kRWxlbWVudEluZGV4XTtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5pbnZva2UoZWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodmlld1JlZiwgdGV4dE5vZGVJbmRleCwgdGV4dCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gcmVzb2x2ZUludGVybmFsRG9tVmlldyh2aWV3UmVmKTtcclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5zZXRUZXh0KHZpZXcuYm91bmRUZXh0Tm9kZXNbdGV4dE5vZGVJbmRleF0sIHRleHQpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAodmlld1JlZiwgZGlzcGF0Y2hlcikge1xyXG4gICAgICAgIHJlc29sdmVJbnRlcm5hbERvbVZpZXcodmlld1JlZikuc2V0RXZlbnREaXNwYXRjaGVyKGRpc3BhdGNoZXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEb21SZW5kZXJlcjtcclxufSkoYXBpXzEuUmVuZGVyZXIpO1xyXG5leHBvcnRzLkRvbVJlbmRlcmVyID0gRG9tUmVuZGVyZXI7XHJcbnZhciBEb21SZW5kZXJlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERvbVJlbmRlcmVyXywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERvbVJlbmRlcmVyXyhfZXZlbnRNYW5hZ2VyLCBfZG9tU2hhcmVkU3R5bGVzSG9zdCwgX2FuaW1hdGUsIGRvY3VtZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gX2V2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9kb21TaGFyZWRTdHlsZXNIb3N0ID0gX2RvbVNoYXJlZFN0eWxlc0hvc3Q7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IF9hbmltYXRlO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudENtZHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlU2hhZG93U3R5bGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9jcmVhdGVSb290SG9zdFZpZXdTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnRG9tUmVuZGVyZXIjY3JlYXRlUm9vdEhvc3RWaWV3KCknKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlVmlld1Njb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdEb21SZW5kZXJlciNjcmVhdGVWaWV3KCknKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fZGV0YWNoRnJhZ21lbnRTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnRG9tUmVuZGVyZXIjZGV0YWNoRnJhZ21lbnQoKScpO1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLnJlZ2lzdGVyQ29tcG9uZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGVJZCwgY29tbWFuZHMsIHN0eWxlcywgbmF0aXZlU2hhZG93KSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50Q21kcy5zZXQodGVtcGxhdGVJZCwgY29tbWFuZHMpO1xyXG4gICAgICAgIGlmIChuYXRpdmVTaGFkb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmF0aXZlU2hhZG93U3R5bGVzLnNldCh0ZW1wbGF0ZUlkLCBzdHlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZG9tU2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXMoc3R5bGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGVJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRDbWRzLmdldCh0ZW1wbGF0ZUlkKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLmNyZWF0ZVJvb3RIb3N0VmlldyA9IGZ1bmN0aW9uIChob3N0UHJvdG9WaWV3UmVmLCBmcmFnbWVudENvdW50LCBob3N0RWxlbWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9jcmVhdGVSb290SG9zdFZpZXdTY29wZSgpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9tX2FkYXB0ZXJfMS5ET00ucXVlcnlTZWxlY3Rvcih0aGlzLl9kb2N1bWVudCwgaG9zdEVsZW1lbnRTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVGhlIHNlbGVjdG9yIFxcXCJcIiArIGhvc3RFbGVtZW50U2VsZWN0b3IgKyBcIlxcXCIgZGlkIG5vdCBtYXRjaCBhbnkgZWxlbWVudHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9maWxlXzEud3RmTGVhdmUocywgdGhpcy5fY3JlYXRlVmlldyhob3N0UHJvdG9WaWV3UmVmLCBlbGVtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKHByb3RvVmlld1JlZiwgZnJhZ21lbnRDb3VudCkge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlVmlld1Njb3BlKCk7XHJcbiAgICAgICAgcmV0dXJuIHByb2ZpbGVfMS53dGZMZWF2ZShzLCB0aGlzLl9jcmVhdGVWaWV3KHByb3RvVmlld1JlZiwgbnVsbCkpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuX2NyZWF0ZVZpZXcgPSBmdW5jdGlvbiAocHJvdG9WaWV3UmVmLCBpbnBsYWNlRWxlbWVudCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdmlld19mYWN0b3J5XzEuY3JlYXRlUmVuZGVyVmlldyhwcm90b1ZpZXdSZWYuY21kcywgaW5wbGFjZUVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIHZhciBzZFJvb3RzID0gdmlldy5uYXRpdmVTaGFkb3dSb290cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNkUm9vdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fZG9tU2hhcmVkU3R5bGVzSG9zdC5hZGRIb3N0KHNkUm9vdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGFwaV8xLlJlbmRlclZpZXdXaXRoRnJhZ21lbnRzKHZpZXcsIHZpZXcuZnJhZ21lbnRzKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHZpZXdSZWY7XHJcbiAgICAgICAgdmFyIHNkUm9vdHMgPSB2aWV3Lm5hdGl2ZVNoYWRvd1Jvb3RzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2RSb290cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9kb21TaGFyZWRTdHlsZXNIb3N0LnJlbW92ZUhvc3Qoc2RSb290c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuYW5pbWF0ZU5vZGVFbnRlciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKGRvbV9hZGFwdGVyXzEuRE9NLmlzRWxlbWVudE5vZGUobm9kZSkgJiYgZG9tX2FkYXB0ZXJfMS5ET00uaGFzQ2xhc3Mobm9kZSwgJ25nLWFuaW1hdGUnKSkge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hZGRDbGFzcyhub2RlLCAnbmctZW50ZXInKTtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZS5jc3MoKVxyXG4gICAgICAgICAgICAgICAgLmFkZEFuaW1hdGlvbkNsYXNzKCduZy1lbnRlci1hY3RpdmUnKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KG5vZGUpXHJcbiAgICAgICAgICAgICAgICAub25Db21wbGV0ZShmdW5jdGlvbiAoKSB7IGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZUNsYXNzKG5vZGUsICduZy1lbnRlcicpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5hbmltYXRlTm9kZUxlYXZlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNFbGVtZW50Tm9kZShub2RlKSAmJiBkb21fYWRhcHRlcl8xLkRPTS5oYXNDbGFzcyhub2RlLCAnbmctYW5pbWF0ZScpKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmFkZENsYXNzKG5vZGUsICduZy1sZWF2ZScpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlLmNzcygpXHJcbiAgICAgICAgICAgICAgICAuYWRkQW5pbWF0aW9uQ2xhc3MoJ25nLWxlYXZlLWFjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQobm9kZSlcclxuICAgICAgICAgICAgICAgIC5vbkNvbXBsZXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZUNsYXNzKG5vZGUsICduZy1sZWF2ZScpO1xyXG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnJlbW92ZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5kZXRhY2hGcmFnbWVudCA9IGZ1bmN0aW9uIChmcmFnbWVudFJlZikge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5fZGV0YWNoRnJhZ21lbnRTY29wZSgpO1xyXG4gICAgICAgIHZhciBmcmFnbWVudE5vZGVzID0gcmVzb2x2ZUludGVybmFsRG9tRnJhZ21lbnQoZnJhZ21lbnRSZWYpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVOb2RlTGVhdmUoZnJhZ21lbnROb2Rlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMpIHtcclxuICAgICAgICB2YXIgZWwgPSBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVFbGVtZW50KG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoZWwsIGF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5tZXJnZUVsZW1lbnQgPSBmdW5jdGlvbiAoZXhpc3RpbmcsIGF0dHJOYW1lQW5kVmFsdWVzKSB7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uY2xlYXJOb2RlcyhleGlzdGluZyk7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlcyhleGlzdGluZywgYXR0ck5hbWVBbmRWYWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXy5wcm90b3R5cGUuX3NldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSwgYXR0ck5hbWVBbmRWYWx1ZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBhdHRySWR4ID0gMDsgYXR0cklkeCA8IGF0dHJOYW1lQW5kVmFsdWVzLmxlbmd0aDsgYXR0cklkeCArPSAyKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLnNldEF0dHJpYnV0ZShub2RlLCBhdHRyTmFtZUFuZFZhbHVlc1thdHRySWR4XSwgYXR0ck5hbWVBbmRWYWx1ZXNbYXR0cklkeCArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5jcmVhdGVSb290Q29udGVudEluc2VydGlvblBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVDb21tZW50KCdyb290LWNvbnRlbnQtaW5zZXJ0aW9uLXBvaW50Jyk7XHJcbiAgICB9O1xyXG4gICAgRG9tUmVuZGVyZXJfLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gZnVuY3Rpb24gKGhvc3QsIHRlbXBsYXRlSWQpIHtcclxuICAgICAgICB2YXIgc3IgPSBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVTaGFkb3dSb290KGhvc3QpO1xyXG4gICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLl9uYXRpdmVTaGFkb3dTdHlsZXMuZ2V0KHRlbXBsYXRlSWQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmFwcGVuZENoaWxkKHNyLCBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVTdHlsZUVsZW1lbnQoc3R5bGVzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzcjtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcclxuICAgIH07XHJcbiAgICBEb21SZW5kZXJlcl8ucHJvdG90eXBlLmdsb2JhbE9uID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChjYWxsYmFjaykpO1xyXG4gICAgfTtcclxuICAgIERvbVJlbmRlcmVyXyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oMywgZGlfMS5JbmplY3QoZG9tX3Rva2Vuc18xLkRPQ1VNRU5UKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2V2ZW50X21hbmFnZXJfMS5FdmVudE1hbmFnZXIsIHNoYXJlZF9zdHlsZXNfaG9zdF8xLkRvbVNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbl9idWlsZGVyXzEuQW5pbWF0aW9uQnVpbGRlciwgT2JqZWN0XSlcclxuICAgIF0sIERvbVJlbmRlcmVyXyk7XHJcbiAgICByZXR1cm4gRG9tUmVuZGVyZXJfO1xyXG59KShEb21SZW5kZXJlcik7XHJcbmV4cG9ydHMuRG9tUmVuZGVyZXJfID0gRG9tUmVuZGVyZXJfO1xyXG5mdW5jdGlvbiByZXNvbHZlSW50ZXJuYWxEb21WaWV3KHZpZXdSZWYpIHtcclxuICAgIHJldHVybiB2aWV3UmVmO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbnRlcm5hbERvbUZyYWdtZW50KGZyYWdtZW50UmVmKSB7XHJcbiAgICByZXR1cm4gZnJhZ21lbnRSZWYubm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gbW92ZU5vZGVzQWZ0ZXJTaWJsaW5nKHNpYmxpbmcsIG5vZGVzKSB7XHJcbiAgICBpZiAobm9kZXMubGVuZ3RoID4gMCAmJiBsYW5nXzEuaXNQcmVzZW50KGRvbV9hZGFwdGVyXzEuRE9NLnBhcmVudEVsZW1lbnQoc2libGluZykpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5pbnNlcnRCZWZvcmUoc2libGluZywgbm9kZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5pbnNlcnRCZWZvcmUobm9kZXNbMF0sIHNpYmxpbmcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdmVDaGlsZE5vZGVzKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICB2YXIgY3VyckNoaWxkID0gZG9tX2FkYXB0ZXJfMS5ET00uZmlyc3RDaGlsZChzb3VyY2UpO1xyXG4gICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQoY3VyckNoaWxkKSkge1xyXG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBkb21fYWRhcHRlcl8xLkRPTS5uZXh0U2libGluZyhjdXJyQ2hpbGQpO1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmFwcGVuZENoaWxkKHRhcmdldCwgY3VyckNoaWxkKTtcclxuICAgICAgICBjdXJyQ2hpbGQgPSBuZXh0Q2hpbGQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChldmVudEhhbmRsZXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgYWxsb3dEZWZhdWx0QmVoYXZpb3IgPSBldmVudEhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgIGlmICghYWxsb3dEZWZhdWx0QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHByZXZlbnREZWZhdWx0IGludG8gZXZlbnQgcGx1Z2lucy4uLlxyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5wcmV2ZW50RGVmYXVsdChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21fcmVuZGVyZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBBIERJIFRva2VuIHJlcHJlc2VudGluZyB0aGUgbWFpbiByZW5kZXJpbmcgY29udGV4dC4gSW4gYSBicm93c2VyIHRoaXMgaXMgdGhlIERPTSBEb2N1bWVudC5cclxuICpcclxuICogTm90ZTogRG9jdW1lbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb24gQ29udGV4dCB3aGVuIEFwcGxpY2F0aW9uIGFuZCBSZW5kZXJpbmdcclxuICogQ29udGV4dHMgYXJlIG5vdCB0aGUgc2FtZSAoZS5nLiB3aGVuIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uIGludG8gYSBXZWIgV29ya2VyKS5cclxuICovXHJcbmV4cG9ydHMuRE9DVU1FTlQgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5PcGFxdWVUb2tlbignRG9jdW1lbnRUb2tlbicpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tX3Rva2Vucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59O1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgbmdfem9uZV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvem9uZS9uZ196b25lJyk7XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxuZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgZGlfMS5PcGFxdWVUb2tlbihcIkV2ZW50TWFuYWdlclBsdWdpbnNcIikpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihwbHVnaW5zLCBfem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xyXG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5tYW5hZ2VyID0gX3RoaXM7IH0pO1xyXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmV2ZXJzZWQocGx1Z2lucyk7XHJcbiAgICB9XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuX2ZpbmRQbHVnaW5Gb3IoZXZlbnROYW1lKTtcclxuICAgICAgICBwbHVnaW4uYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl96b25lOyB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fZmluZFBsdWdpbkZvciA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICB2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW2ldO1xyXG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzKGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gZXZlbnQgbWFuYWdlciBwbHVnaW4gZm91bmQgZm9yIGV2ZW50IFwiICsgZXZlbnROYW1lKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSxcclxuICAgICAgICBfX3BhcmFtKDAsIGRpXzEuSW5qZWN0KGV4cG9ydHMuRVZFTlRfTUFOQUdFUl9QTFVHSU5TKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0FycmF5LCBuZ196b25lXzEuTmdab25lXSlcclxuICAgIF0sIEV2ZW50TWFuYWdlcik7XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLkV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlcjtcclxudmFyIEV2ZW50TWFuYWdlclBsdWdpbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXJQbHVnaW4oKSB7XHJcbiAgICB9XHJcbiAgICAvLyBUaGF0IGlzIGVxdWl2YWxlbnQgdG8gaGF2aW5nIHN1cHBvcnRpbmcgJGV2ZW50LnRhcmdldFxyXG4gICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRocm93IFwibm90IGltcGxlbWVudGVkXCI7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRocm93IFwibm90IGltcGxlbWVudGVkXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50TWFuYWdlclBsdWdpbjtcclxufSkoKTtcclxuZXhwb3J0cy5FdmVudE1hbmFnZXJQbHVnaW4gPSBFdmVudE1hbmFnZXJQbHVnaW47XHJcbnZhciBEb21FdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERvbUV2ZW50c1BsdWdpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERvbUV2ZW50c1BsdWdpbigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgcGx1Z2luIHNob3VsZCBjb21lIGxhc3QgaW4gdGhlIGxpc3Qgb2YgcGx1Z2lucywgYmVjYXVzZSBpdCBhY2NlcHRzIGFsbFxyXG4gICAgLy8gZXZlbnRzLlxyXG4gICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICBEb21FdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xyXG4gICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pOyB9O1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyBkb21fYWRhcHRlcl8xLkRPTS5vbihlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcclxuICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHpvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZXIoZXZlbnQpOyB9KTsgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBkb21fYWRhcHRlcl8xLkRPTS5vbkFuZENhbmNlbChlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRG9tRXZlbnRzUGx1Z2luID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBEb21FdmVudHNQbHVnaW4pO1xyXG4gICAgcmV0dXJuIERvbUV2ZW50c1BsdWdpbjtcclxufSkoRXZlbnRNYW5hZ2VyUGx1Z2luKTtcclxuZXhwb3J0cy5Eb21FdmVudHNQbHVnaW4gPSBEb21FdmVudHNQbHVnaW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50X21hbmFnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBldmVudF9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL2V2ZW50X21hbmFnZXInKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBfZXZlbnROYW1lcyA9IHtcclxuICAgIC8vIHBhblxyXG4gICAgJ3Bhbic6IHRydWUsXHJcbiAgICAncGFuc3RhcnQnOiB0cnVlLFxyXG4gICAgJ3Bhbm1vdmUnOiB0cnVlLFxyXG4gICAgJ3BhbmVuZCc6IHRydWUsXHJcbiAgICAncGFuY2FuY2VsJzogdHJ1ZSxcclxuICAgICdwYW5sZWZ0JzogdHJ1ZSxcclxuICAgICdwYW5yaWdodCc6IHRydWUsXHJcbiAgICAncGFudXAnOiB0cnVlLFxyXG4gICAgJ3BhbmRvd24nOiB0cnVlLFxyXG4gICAgLy8gcGluY2hcclxuICAgICdwaW5jaCc6IHRydWUsXHJcbiAgICAncGluY2hzdGFydCc6IHRydWUsXHJcbiAgICAncGluY2htb3ZlJzogdHJ1ZSxcclxuICAgICdwaW5jaGVuZCc6IHRydWUsXHJcbiAgICAncGluY2hjYW5jZWwnOiB0cnVlLFxyXG4gICAgJ3BpbmNoaW4nOiB0cnVlLFxyXG4gICAgJ3BpbmNob3V0JzogdHJ1ZSxcclxuICAgIC8vIHByZXNzXHJcbiAgICAncHJlc3MnOiB0cnVlLFxyXG4gICAgJ3ByZXNzdXAnOiB0cnVlLFxyXG4gICAgLy8gcm90YXRlXHJcbiAgICAncm90YXRlJzogdHJ1ZSxcclxuICAgICdyb3RhdGVzdGFydCc6IHRydWUsXHJcbiAgICAncm90YXRlbW92ZSc6IHRydWUsXHJcbiAgICAncm90YXRlZW5kJzogdHJ1ZSxcclxuICAgICdyb3RhdGVjYW5jZWwnOiB0cnVlLFxyXG4gICAgLy8gc3dpcGVcclxuICAgICdzd2lwZSc6IHRydWUsXHJcbiAgICAnc3dpcGVsZWZ0JzogdHJ1ZSxcclxuICAgICdzd2lwZXJpZ2h0JzogdHJ1ZSxcclxuICAgICdzd2lwZXVwJzogdHJ1ZSxcclxuICAgICdzd2lwZWRvd24nOiB0cnVlLFxyXG4gICAgLy8gdGFwXHJcbiAgICAndGFwJzogdHJ1ZSxcclxufTtcclxudmFyIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uKCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhfZXZlbnROYW1lcywgZXZlbnROYW1lKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb247XHJcbn0pKGV2ZW50X21hbmFnZXJfMS5FdmVudE1hbmFnZXJQbHVnaW4pO1xyXG5leHBvcnRzLkhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uID0gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbW1lcl9jb21tb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBoYW1tZXJfY29tbW9uXzEgPSByZXF1aXJlKCcuL2hhbW1lcl9jb21tb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgZGlfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJyk7XHJcbnZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSGFtbWVyR2VzdHVyZXNQbHVnaW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbigpIHtcclxuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoIV9zdXBlci5wcm90b3R5cGUuc3VwcG9ydHMuY2FsbCh0aGlzLCBldmVudE5hbWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNQcmVzZW50KHdpbmRvd1snSGFtbWVyJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkhhbW1lci5qcyBpcyBub3QgbG9hZGVkLCBjYW4gbm90IGJpbmQgXCIgKyBldmVudE5hbWUgKyBcIiBldmVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xyXG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGluZyB0aGUgbWFuYWdlciBiaW5kIGV2ZW50cywgbXVzdCBiZSBkb25lIG91dHNpZGUgb2YgYW5ndWxhclxyXG4gICAgICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBtYy5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBtYy5nZXQoJ3JvdGF0ZScpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbWMub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnRPYmopIHsgem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBoYW5kbGVyKGV2ZW50T2JqKTsgfSk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGlfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBIYW1tZXJHZXN0dXJlc1BsdWdpbik7XHJcbiAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW47XHJcbn0pKGhhbW1lcl9jb21tb25fMS5IYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbik7XHJcbmV4cG9ydHMuSGFtbWVyR2VzdHVyZXNQbHVnaW4gPSBIYW1tZXJHZXN0dXJlc1BsdWdpbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFtbWVyX2dlc3R1cmVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBldmVudF9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL2V2ZW50X21hbmFnZXInKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgbW9kaWZpZXJLZXlzID0gWydhbHQnLCAnY29udHJvbCcsICdtZXRhJywgJ3NoaWZ0J107XHJcbnZhciBtb2RpZmllcktleUdldHRlcnMgPSB7XHJcbiAgICAnYWx0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5hbHRLZXk7IH0sXHJcbiAgICAnY29udHJvbCc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuY3RybEtleTsgfSxcclxuICAgICdtZXRhJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5tZXRhS2V5OyB9LFxyXG4gICAgJ3NoaWZ0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5zaGlmdEtleTsgfVxyXG59O1xyXG52YXIgS2V5RXZlbnRzUGx1Z2luID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhLZXlFdmVudHNQbHVnaW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBLZXlFdmVudHNQbHVnaW4oKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcbiAgICBLZXlFdmVudHNQbHVnaW4ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpKTtcclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZEV2ZW50ID0gS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyID0gS2V5RXZlbnRzUGx1Z2luLmV2ZW50Q2FsbGJhY2soZWxlbWVudCwgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KHBhcnNlZEV2ZW50LCAnZnVsbEtleScpLCBoYW5kbGVyLCB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00ub24oZWxlbWVudCwgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KHBhcnNlZEV2ZW50LCAnZG9tRXZlbnROYW1lJyksIG91dHNpZGVIYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKTtcclxuICAgICAgICB2YXIgZG9tRXZlbnROYW1lID0gcGFydHMuc2hpZnQoKTtcclxuICAgICAgICBpZiAoKHBhcnRzLmxlbmd0aCA9PT0gMCkgfHxcclxuICAgICAgICAgICAgIShsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoZG9tRXZlbnROYW1lLCAna2V5ZG93bicpIHx8XHJcbiAgICAgICAgICAgICAgICBsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoZG9tRXZlbnROYW1lLCAna2V5dXAnKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXkgPSBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleShwYXJ0cy5wb3AoKSk7XHJcbiAgICAgICAgdmFyIGZ1bGxLZXkgPSAnJztcclxuICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnMocGFydHMsIG1vZGlmaWVyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUocGFydHMsIG1vZGlmaWVyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBmdWxsS2V5ICs9IG1vZGlmaWVyTmFtZSArICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bGxLZXkgKz0ga2V5O1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmcgdG8gbGV0IGFub3RoZXIgcGx1Z2luIHByb2Nlc3MgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHJlc3VsdCwgJ2RvbUV2ZW50TmFtZScsIGRvbUV2ZW50TmFtZSk7XHJcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHJlc3VsdCwgJ2Z1bGxLZXknLCBmdWxsS2V5KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZnVsbEtleSA9ICcnO1xyXG4gICAgICAgIHZhciBrZXkgPSBkb21fYWRhcHRlcl8xLkRPTS5nZXRFdmVudEtleShldmVudCk7XHJcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhrZXksICcgJykpIHtcclxuICAgICAgICAgICAga2V5ID0gJ3NwYWNlJzsgLy8gZm9yIHJlYWRhYmlsaXR5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhrZXksICcuJykpIHtcclxuICAgICAgICAgICAga2V5ID0gJ2RvdCc7IC8vIGJlY2F1c2UgJy4nIGlzIHVzZWQgYXMgYSBzZXBhcmF0b3IgaW4gZXZlbnQgbmFtZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kaWZpZXJLZXlzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJOYW1lICE9IGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyR2V0dGVyID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KG1vZGlmaWVyS2V5R2V0dGVycywgbW9kaWZpZXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllckdldHRlcihldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxsS2V5ICs9IG1vZGlmaWVyTmFtZSArICcuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bGxLZXkgKz0ga2V5O1xyXG4gICAgICAgIHJldHVybiBmdWxsS2V5O1xyXG4gICAgfTtcclxuICAgIEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZ1bGxLZXksIGhhbmRsZXIsIHpvbmUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoS2V5RXZlbnRzUGx1Z2luLmdldEV2ZW50RnVsbEtleShldmVudCksIGZ1bGxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEtleUV2ZW50c1BsdWdpbi5fbm9ybWFsaXplS2V5ID0gZnVuY3Rpb24gKGtleU5hbWUpIHtcclxuICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBTdHJpbmdNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcclxuICAgICAgICBzd2l0Y2ggKGtleU5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSAnZXNjJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlOYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLZXlFdmVudHNQbHVnaW4gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIEtleUV2ZW50c1BsdWdpbik7XHJcbiAgICByZXR1cm4gS2V5RXZlbnRzUGx1Z2luO1xyXG59KShldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyUGx1Z2luKTtcclxuZXhwb3J0cy5LZXlFdmVudHNQbHVnaW4gPSBLZXlFdmVudHNQbHVnaW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleV9ldmVudHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGRpXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kaScpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGRvbV90b2tlbnNfMSA9IHJlcXVpcmUoJy4vZG9tX3Rva2VucycpO1xyXG52YXIgU2hhcmVkU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaGFyZWRTdHlsZXNIb3N0KCkge1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9zdHlsZXMgPSBbXTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fc3R5bGVzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhfdGhpcy5fc3R5bGVzU2V0LCBzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZXNTZXQuYWRkKHN0eWxlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZXMucHVzaChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uU3R5bGVzQWRkZWQoYWRkaXRpb25zKTtcclxuICAgIH07XHJcbiAgICBTaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gZnVuY3Rpb24gKGFkZGl0aW9ucykgeyB9O1xyXG4gICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3R5bGVzOyB9O1xyXG4gICAgU2hhcmVkU3R5bGVzSG9zdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgU2hhcmVkU3R5bGVzSG9zdCk7XHJcbiAgICByZXR1cm4gU2hhcmVkU3R5bGVzSG9zdDtcclxufSkoKTtcclxuZXhwb3J0cy5TaGFyZWRTdHlsZXNIb3N0ID0gU2hhcmVkU3R5bGVzSG9zdDtcclxudmFyIERvbVNoYXJlZFN0eWxlc0hvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERvbVNoYXJlZFN0eWxlc0hvc3QsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEb21TaGFyZWRTdHlsZXNIb3N0KGRvYykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2hvc3ROb2RlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuYWRkKGRvYy5oZWFkKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIERvbVNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLl9hZGRTdHlsZXNUb0hvc3QgPSBmdW5jdGlvbiAoc3R5bGVzLCBob3N0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xyXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLkRPTS5hcHBlbmRDaGlsZChob3N0LCBkb21fYWRhcHRlcl8xLkRPTS5jcmVhdGVTdHlsZUVsZW1lbnQoc3R5bGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuX2FkZFN0eWxlc1RvSG9zdCh0aGlzLl9zdHlsZXMsIGhvc3ROb2RlKTtcclxuICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuYWRkKGhvc3ROb2RlKTtcclxuICAgIH07XHJcbiAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5yZW1vdmVIb3N0ID0gZnVuY3Rpb24gKGhvc3ROb2RlKSB7IGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmRlbGV0ZSh0aGlzLl9ob3N0Tm9kZXMsIGhvc3ROb2RlKTsgfTtcclxuICAgIERvbVNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLm9uU3R5bGVzQWRkZWQgPSBmdW5jdGlvbiAoYWRkaXRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdE5vZGUpIHsgX3RoaXMuX2FkZFN0eWxlc1RvSG9zdChhZGRpdGlvbnMsIGhvc3ROb2RlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRpXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgZGlfMS5JbmplY3QoZG9tX3Rva2Vuc18xLkRPQ1VNRU5UKSksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBEb21TaGFyZWRTdHlsZXNIb3N0KTtcclxuICAgIHJldHVybiBEb21TaGFyZWRTdHlsZXNIb3N0O1xyXG59KShTaGFyZWRTdHlsZXNIb3N0KTtcclxuZXhwb3J0cy5Eb21TaGFyZWRTdHlsZXNIb3N0ID0gRG9tU2hhcmVkU3R5bGVzSG9zdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkX3N0eWxlc19ob3N0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcclxudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLShbYS16XSkvZztcclxuZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIENBTUVMX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gJy0nICsgbVsxXS50b0xvd2VyQ2FzZSgpOyB9KTtcclxufVxyXG5leHBvcnRzLmNhbWVsQ2FzZVRvRGFzaENhc2UgPSBjYW1lbENhc2VUb0Rhc2hDYXNlO1xyXG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5kYXNoQ2FzZVRvQ2FtZWxDYXNlID0gZGFzaENhc2VUb0NhbWVsQ2FzZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFkdmFuY2VkIHN1cHBvcnQgZm9yIGV4dGVuZGluZyBkb20gc3RyYXRlZ3kuXHJcbiAqL1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuX19leHBvcnQocmVxdWlyZSgnLi9kb20vc2hhcmVkX3N0eWxlc19ob3N0JykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RvbS9kb21fcmVuZGVyZXInKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZG9tL2RvbV90b2tlbnMnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYXBpJykpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBhcGlfMSA9IHJlcXVpcmUoJy4vYXBpJyk7XHJcbnZhciBEZWZhdWx0UHJvdG9WaWV3UmVmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWZhdWx0UHJvdG9WaWV3UmVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdFByb3RvVmlld1JlZihjbWRzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jbWRzID0gY21kcztcclxuICAgIH1cclxuICAgIHJldHVybiBEZWZhdWx0UHJvdG9WaWV3UmVmO1xyXG59KShhcGlfMS5SZW5kZXJQcm90b1ZpZXdSZWYpO1xyXG5leHBvcnRzLkRlZmF1bHRQcm90b1ZpZXdSZWYgPSBEZWZhdWx0UHJvdG9WaWV3UmVmO1xyXG52YXIgRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWZhdWx0UmVuZGVyRnJhZ21lbnRSZWYsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyRnJhZ21lbnRSZWYobm9kZXMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmO1xyXG59KShhcGlfMS5SZW5kZXJGcmFnbWVudFJlZik7XHJcbmV4cG9ydHMuRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmID0gRGVmYXVsdFJlbmRlckZyYWdtZW50UmVmO1xyXG52YXIgRGVmYXVsdFJlbmRlclZpZXcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERlZmF1bHRSZW5kZXJWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdFJlbmRlclZpZXcoZnJhZ21lbnRzLCBib3VuZFRleHROb2RlcywgYm91bmRFbGVtZW50cywgbmF0aXZlU2hhZG93Um9vdHMsIGdsb2JhbEV2ZW50QWRkZXJzLCByb290Q29udGVudEluc2VydGlvblBvaW50cykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xyXG4gICAgICAgIHRoaXMuYm91bmRUZXh0Tm9kZXMgPSBib3VuZFRleHROb2RlcztcclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudHMgPSBib3VuZEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMubmF0aXZlU2hhZG93Um9vdHMgPSBuYXRpdmVTaGFkb3dSb290cztcclxuICAgICAgICB0aGlzLmdsb2JhbEV2ZW50QWRkZXJzID0gZ2xvYmFsRXZlbnRBZGRlcnM7XHJcbiAgICAgICAgdGhpcy5yb290Q29udGVudEluc2VydGlvblBvaW50cyA9IHJvb3RDb250ZW50SW5zZXJ0aW9uUG9pbnRzO1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudFJlbW92ZXJzID0gbnVsbDtcclxuICAgIH1cclxuICAgIERlZmF1bHRSZW5kZXJWaWV3LnByb3RvdHlwZS5oeWRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmh5ZHJhdGVkKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1RoZSB2aWV3IGlzIGFscmVhZHkgaHlkcmF0ZWQuJyk7XHJcbiAgICAgICAgdGhpcy5oeWRyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudFJlbW92ZXJzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSh0aGlzLmdsb2JhbEV2ZW50QWRkZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdsb2JhbEV2ZW50QWRkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRSZW1vdmVyc1tpXSA9IHRoaXMuZ2xvYmFsRXZlbnRBZGRlcnNbaV0oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdFJlbmRlclZpZXcucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaHlkcmF0ZWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVGhlIHZpZXcgaXMgYWxyZWFkeSBkZWh5ZHJhdGVkLicpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxFdmVudFJlbW92ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRSZW1vdmVyc1tpXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdsb2JhbEV2ZW50UmVtb3ZlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaHlkcmF0ZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0UmVuZGVyVmlldy5wcm90b3R5cGUuc2V0RXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBkaXNwYXRjaGVyOyB9O1xyXG4gICAgRGVmYXVsdFJlbmRlclZpZXcucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiAoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpIHtcclxuICAgICAgICB2YXIgYWxsb3dEZWZhdWx0QmVoYXZpb3IgPSB0cnVlO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuZXZlbnREaXNwYXRjaGVyKSkge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICAgICAgbG9jYWxzLnNldCgnJGV2ZW50JywgZXZlbnQpO1xyXG4gICAgICAgICAgICBhbGxvd0RlZmF1bHRCZWhhdmlvciA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaFJlbmRlckV2ZW50KGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGxvY2Fscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxvd0RlZmF1bHRCZWhhdmlvcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdFJlbmRlclZpZXc7XHJcbn0pKGFwaV8xLlJlbmRlclZpZXdSZWYpO1xyXG5leHBvcnRzLkRlZmF1bHRSZW5kZXJWaWV3ID0gRGVmYXVsdFJlbmRlclZpZXc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZSgnLi92aWV3Jyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclZpZXcoZnJhZ21lbnRDbWRzLCBpbnBsYWNlRWxlbWVudCwgbm9kZUZhY3RvcnkpIHtcclxuICAgIHZhciB2aWV3O1xyXG4gICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3LmRpc3BhdGNoUmVuZGVyRXZlbnQoYm91bmRFbGVtZW50SW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpO1xyXG4gICAgfTtcclxuICAgIHZhciBjb250ZXh0ID0gbmV3IEJ1aWxkQ29udGV4dChldmVudERpc3BhdGNoZXIsIG5vZGVGYWN0b3J5LCBpbnBsYWNlRWxlbWVudCk7XHJcbiAgICBjb250ZXh0LmJ1aWxkKGZyYWdtZW50Q21kcyk7XHJcbiAgICB2YXIgZnJhZ21lbnRzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHQuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZnJhZ21lbnRzLnB1c2gobmV3IHZpZXdfMS5EZWZhdWx0UmVuZGVyRnJhZ21lbnRSZWYoY29udGV4dC5mcmFnbWVudHNbaV0pKTtcclxuICAgIH1cclxuICAgIHZpZXcgPSBuZXcgdmlld18xLkRlZmF1bHRSZW5kZXJWaWV3KGZyYWdtZW50cywgY29udGV4dC5ib3VuZFRleHROb2RlcywgY29udGV4dC5ib3VuZEVsZW1lbnRzLCBjb250ZXh0Lm5hdGl2ZVNoYWRvd1Jvb3RzLCBjb250ZXh0Lmdsb2JhbEV2ZW50QWRkZXJzLCBjb250ZXh0LnJvb3RDb250ZW50SW5zZXJ0aW9uUG9pbnRzKTtcclxuICAgIHJldHVybiB2aWV3O1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlUmVuZGVyVmlldyA9IGNyZWF0ZVJlbmRlclZpZXc7XHJcbnZhciBCdWlsZENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnVpbGRDb250ZXh0KF9ldmVudERpc3BhdGNoZXIsIGZhY3RvcnksIF9pbnBsYWNlRWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50RGlzcGF0Y2hlciA9IF9ldmVudERpc3BhdGNoZXI7XHJcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcclxuICAgICAgICB0aGlzLl9pbnBsYWNlRWxlbWVudCA9IF9pbnBsYWNlRWxlbWVudDtcclxuICAgICAgICB0aGlzLl9idWlsZGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRBZGRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmJvdW5kVGV4dE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5uYXRpdmVTaGFkb3dSb290cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5yb290Q29udGVudEluc2VydGlvblBvaW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaXNIb3N0ID0gbGFuZ18xLmlzUHJlc2VudCgoX2lucGxhY2VFbGVtZW50KSk7XHJcbiAgICB9XHJcbiAgICBCdWlsZENvbnRleHQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGZyYWdtZW50Q21kcykge1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZUZyYWdtZW50QnVpbGRlcihudWxsLCBmcmFnbWVudENtZHMpO1xyXG4gICAgICAgIHRoaXMuX2J1aWxkKHRoaXMuX2J1aWxkZXJzWzBdKTtcclxuICAgIH07XHJcbiAgICBCdWlsZENvbnRleHQucHJvdG90eXBlLl9idWlsZCA9IGZ1bmN0aW9uIChidWlsZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYnVpbGRlcnMgPSBbXTtcclxuICAgICAgICBidWlsZGVyLmJ1aWxkKHRoaXMpO1xyXG4gICAgICAgIHZhciBlbnF1ZXVlZEJ1aWxkZXJzID0gdGhpcy5fYnVpbGRlcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnF1ZXVlZEJ1aWxkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkKGVucXVldWVkQnVpbGRlcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdWlsZENvbnRleHQucHJvdG90eXBlLmVucXVldWVDb21wb25lbnRCdWlsZGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Q291bnQrKztcclxuICAgICAgICB0aGlzLl9idWlsZGVycy5wdXNoKG5ldyBSZW5kZXJWaWV3QnVpbGRlcihjb21wb25lbnQsIG51bGwsIHRoaXMuZmFjdG9yeS5yZXNvbHZlQ29tcG9uZW50VGVtcGxhdGUoY29tcG9uZW50LmNtZC50ZW1wbGF0ZUlkKSkpO1xyXG4gICAgfTtcclxuICAgIEJ1aWxkQ29udGV4dC5wcm90b3R5cGUuZW5xdWV1ZUZyYWdtZW50QnVpbGRlciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNvbW1hbmRzKSB7XHJcbiAgICAgICAgdmFyIHJvb3ROb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLnB1c2gocm9vdE5vZGVzKTtcclxuICAgICAgICB0aGlzLl9idWlsZGVycy5wdXNoKG5ldyBSZW5kZXJWaWV3QnVpbGRlcihwYXJlbnRDb21wb25lbnQsIHJvb3ROb2RlcywgY29tbWFuZHMpKTtcclxuICAgIH07XHJcbiAgICBCdWlsZENvbnRleHQucHJvdG90eXBlLmNvbnN1bWVJbnBsYWNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faW5wbGFjZUVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5faW5wbGFjZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQnVpbGRDb250ZXh0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGJvdW5kRWxlbWVudEluZGV4LCB0YXJnZXQsIGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBjcmVhdGVFdmVudEhhbmRsZXIoYm91bmRFbGVtZW50SW5kZXgsIHRhcmdldCArIFwiOlwiICsgZXZlbnROYW1lLCB0aGlzLl9ldmVudERpc3BhdGNoZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbEV2ZW50QWRkZXJzLnB1c2goY3JlYXRlR2xvYmFsRXZlbnRBZGRlcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgdGhpcy5mYWN0b3J5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGNyZWF0ZUV2ZW50SGFuZGxlcihib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCB0aGlzLl9ldmVudERpc3BhdGNoZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmZhY3Rvcnkub24odGhpcy5ib3VuZEVsZW1lbnRzW2JvdW5kRWxlbWVudEluZGV4XSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ1aWxkQ29udGV4dDtcclxufSkoKTtcclxuZnVuY3Rpb24gY3JlYXRlRXZlbnRIYW5kbGVyKGJvdW5kRWxlbWVudEluZGV4LCBldmVudE5hbWUsIGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgkZXZlbnQpIHsgcmV0dXJuIGV2ZW50RGlzcGF0Y2hlcihib3VuZEVsZW1lbnRJbmRleCwgZXZlbnROYW1lLCAkZXZlbnQpOyB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbEV2ZW50QWRkZXIodGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgbm9kZUZhY3RvcnkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBub2RlRmFjdG9yeS5nbG9iYWxPbih0YXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTsgfTtcclxufVxyXG52YXIgUmVuZGVyVmlld0J1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyVmlld0J1aWxkZXIocGFyZW50Q29tcG9uZW50LCBmcmFnbWVudFJvb3ROb2RlcywgY29tbWFuZHMpIHtcclxuICAgICAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudENvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZyYWdtZW50Um9vdE5vZGVzID0gZnJhZ21lbnRSb290Tm9kZXM7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IGNvbW1hbmRzO1xyXG4gICAgICAgIHZhciByb290Tm9kZXNQYXJlbnQgPSBsYW5nXzEuaXNQcmVzZW50KGZyYWdtZW50Um9vdE5vZGVzKSA/IG51bGwgOiBwYXJlbnRDb21wb25lbnQuc2hhZG93Um9vdDtcclxuICAgICAgICB0aGlzLnBhcmVudFN0YWNrID0gW3Jvb3ROb2Rlc1BhcmVudF07XHJcbiAgICB9XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzW2ldLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcmVudFN0YWNrW3RoaXMucGFyZW50U3RhY2subGVuZ3RoIC0gMV07IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChjbWQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IGNvbnRleHQuZmFjdG9yeS5jcmVhdGVUZXh0KGNtZC52YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fYWRkQ2hpbGQodGV4dCwgY21kLm5nQ29udGVudEluZGV4LCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoY21kLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5ib3VuZFRleHROb2Rlcy5wdXNoKHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5wYXJlbnRDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENvbXBvbmVudC5pc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRpb25Qb2ludCA9IGNvbnRleHQuZmFjdG9yeS5jcmVhdGVSb290Q29udGVudEluc2VydGlvblBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZhY3RvcnkuYXBwZW5kQ2hpbGQodGhpcy5wYXJlbnQuc2hhZG93Um9vdCwgaW5zZXJ0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5mYWN0b3J5LmFwcGVuZENoaWxkKHRoaXMucGFyZW50LCBpbnNlcnRpb25Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJvb3RDb250ZW50SW5zZXJ0aW9uUG9pbnRzLnB1c2goaW5zZXJ0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZE5vZGVzID0gdGhpcy5wYXJlbnRDb21wb25lbnQucHJvamVjdChjbWQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9qZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcHJvamVjdGVkTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQobm9kZSwgY21kLm5nQ29udGVudEluZGV4LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRCZWdpbkVsZW1lbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRTdGFjay5wdXNoKHRoaXMuX2JlZ2luRWxlbWVudChjbWQsIGNvbnRleHQpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbmRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9lbmRFbGVtZW50KCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QmVnaW5Db21wb25lbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fYmVnaW5FbGVtZW50KGNtZCwgY29udGV4dCk7XHJcbiAgICAgICAgdmFyIHJvb3QgPSBlbDtcclxuICAgICAgICBpZiAoY21kLm5hdGl2ZVNoYWRvdykge1xyXG4gICAgICAgICAgICByb290ID0gY29udGV4dC5mYWN0b3J5LmNyZWF0ZVNoYWRvd1Jvb3QoZWwsIGNtZC50ZW1wbGF0ZUlkKTtcclxuICAgICAgICAgICAgY29udGV4dC5uYXRpdmVTaGFkb3dSb290cy5wdXNoKHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNSb290ID0gY29udGV4dC5jb21wb25lbnRDb3VudCA9PT0gMCAmJiBjb250ZXh0LmlzSG9zdDtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChlbCwgcm9vdCwgY21kLCBpc1Jvb3QpO1xyXG4gICAgICAgIGNvbnRleHQuZW5xdWV1ZUNvbXBvbmVudEJ1aWxkZXIoY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLnBhcmVudFN0YWNrLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX2VuZEVsZW1lbnQoKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZW5kZXJWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNtZCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBlbCA9IGNvbnRleHQuZmFjdG9yeS5jcmVhdGVUZW1wbGF0ZUFuY2hvcihjbWQuYXR0ck5hbWVBbmRWYWx1ZXMpO1xyXG4gICAgICAgIHRoaXMuX2FkZENoaWxkKGVsLCBjbWQubmdDb250ZW50SW5kZXgsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnRleHQuYm91bmRFbGVtZW50cy5wdXNoKGVsKTtcclxuICAgICAgICBpZiAoY21kLmlzTWVyZ2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZW5xdWV1ZUZyYWdtZW50QnVpbGRlcih0aGlzLnBhcmVudENvbXBvbmVudCwgY21kLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyVmlld0J1aWxkZXIucHJvdG90eXBlLl9iZWdpbkVsZW1lbnQgPSBmdW5jdGlvbiAoY21kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGVsID0gY29udGV4dC5jb25zdW1lSW5wbGFjZUVsZW1lbnQoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbCkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5mYWN0b3J5Lm1lcmdlRWxlbWVudChlbCwgY21kLmF0dHJOYW1lQW5kVmFsdWVzKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFJvb3ROb2Rlcy5wdXNoKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gY29udGV4dC5mYWN0b3J5LmNyZWF0ZUVsZW1lbnQoY21kLm5hbWUsIGNtZC5hdHRyTmFtZUFuZFZhbHVlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGVsLCBjbWQubmdDb250ZW50SW5kZXgsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY21kLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kRWxlbWVudEluZGV4ID0gY29udGV4dC5ib3VuZEVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29udGV4dC5ib3VuZEVsZW1lbnRzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtZC5ldmVudFRhcmdldEFuZE5hbWVzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gY21kLmV2ZW50VGFyZ2V0QW5kTmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gY21kLmV2ZW50VGFyZ2V0QW5kTmFtZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKGJvdW5kRWxlbWVudEluZGV4LCB0YXJnZXQsIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZS5fZW5kRWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wYXJlbnRTdGFjay5wb3AoKTsgfTtcclxuICAgIFJlbmRlclZpZXdCdWlsZGVyLnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSwgbmdDb250ZW50SW5kZXgsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50KSkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ29udGVudE5vZGUobmdDb250ZW50SW5kZXgsIG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5mYWN0b3J5LmFwcGVuZENoaWxkKHBhcmVudCwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRSb290Tm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlbmRlclZpZXdCdWlsZGVyO1xyXG59KSgpO1xyXG52YXIgQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChob3N0RWxlbWVudCwgc2hhZG93Um9vdCwgY21kLCBpc1Jvb3QpIHtcclxuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dSb290ID0gc2hhZG93Um9vdDtcclxuICAgICAgICB0aGlzLmNtZCA9IGNtZDtcclxuICAgICAgICB0aGlzLmlzUm9vdCA9IGlzUm9vdDtcclxuICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXggPSBbXTtcclxuICAgIH1cclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ29udGVudE5vZGUgPSBmdW5jdGlvbiAobmdDb250ZW50SW5kZXgsIG5vZGUsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobmdDb250ZW50SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNtZC5uYXRpdmVTaGFkb3cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmFjdG9yeS5hcHBlbmRDaGlsZCh0aGlzLmhvc3RFbGVtZW50LCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleC5sZW5ndGggPD0gbmdDb250ZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXhbbmdDb250ZW50SW5kZXhdLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChuZ0NvbnRlbnRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBuZ0NvbnRlbnRJbmRleCA8IHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleC5sZW5ndGggP1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXhbbmdDb250ZW50SW5kZXhdIDpcclxuICAgICAgICAgICAgW107XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudDtcclxufSkoKTtcclxuZnVuY3Rpb24gYWRkQWxsKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19mYWN0b3J5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBQdWJsaWMgQVBJIGZvciBTZXJ2aWNlc1xyXG52YXIgYXBwX3Jvb3RfdXJsXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlci9hcHBfcm9vdF91cmwnKTtcclxuZXhwb3J0cy5BcHBSb290VXJsID0gYXBwX3Jvb3RfdXJsXzEuQXBwUm9vdFVybDtcclxudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvY29tcGlsZXIvdXJsX3Jlc29sdmVyJyk7XHJcbmV4cG9ydHMuVXJsUmVzb2x2ZXIgPSB1cmxfcmVzb2x2ZXJfMS5VcmxSZXNvbHZlcjtcclxudmFyIHRpdGxlXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9zZXJ2aWNlcy90aXRsZScpO1xyXG5leHBvcnRzLlRpdGxlID0gdGl0bGVfMS5UaXRsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZG9tL2RvbV9hZGFwdGVyJyk7XHJcbi8qKlxyXG4gKiBBIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgYW5kIHNldCB0aGUgdGl0bGUgb2YgYSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIFNpbmNlIGFuIEFuZ3VsYXIgMiBhcHBsaWNhdGlvbiBjYW4ndCBiZSBib290c3RyYXBwZWQgb24gdGhlIGVudGlyZSBIVE1MIGRvY3VtZW50IChgPGh0bWw+YCB0YWcpXHJcbiAqIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBiaW5kIHRvIHRoZSBgdGV4dGAgcHJvcGVydHkgb2YgdGhlIGBIVE1MVGl0bGVFbGVtZW50YCBlbGVtZW50c1xyXG4gKiAocmVwcmVzZW50aW5nIHRoZSBgPHRpdGxlPmAgdGFnKS4gSW5zdGVhZCwgdGhpcyBzZXJ2aWNlIGNhbiBiZSB1c2VkIHRvIHNldCBhbmQgZ2V0IHRoZSBjdXJyZW50XHJcbiAqIHRpdGxlIHZhbHVlLlxyXG4gKi9cclxudmFyIFRpdGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRpdGxlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBUaXRsZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21fYWRhcHRlcl8xLkRPTS5nZXRUaXRsZSgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gbmV3VGl0bGVcclxuICAgICAqL1xyXG4gICAgVGl0bGUucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5ld1RpdGxlKSB7IGRvbV9hZGFwdGVyXzEuRE9NLnNldFRpdGxlKG5ld1RpdGxlKTsgfTtcclxuICAgIHJldHVybiBUaXRsZTtcclxufSkoKTtcclxuZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aXRsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIHRlc3RhYmlsaXR5XzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIFB1YmxpY1Rlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFB1YmxpY1Rlc3RhYmlsaXR5KHRlc3RhYmlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHkgPSB0ZXN0YWJpbGl0eTtcclxuICAgIH1cclxuICAgIFB1YmxpY1Rlc3RhYmlsaXR5LnByb3RvdHlwZS5pc1N0YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Rlc3RhYmlsaXR5LmlzU3RhYmxlKCk7IH07XHJcbiAgICBQdWJsaWNUZXN0YWJpbGl0eS5wcm90b3R5cGUud2hlblN0YWJsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl90ZXN0YWJpbGl0eS53aGVuU3RhYmxlKGNhbGxiYWNrKTsgfTtcclxuICAgIFB1YmxpY1Rlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kQmluZGluZ3MgPSBmdW5jdGlvbiAodXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFByb3ZpZGVycyh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpO1xyXG4gICAgfTtcclxuICAgIFB1YmxpY1Rlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kUHJvdmlkZXJzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0YWJpbGl0eS5maW5kQmluZGluZ3ModXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHVibGljVGVzdGFiaWxpdHk7XHJcbn0pKCk7XHJcbnZhciBCcm93c2VyR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlckdldFRlc3RhYmlsaXR5KCkge1xyXG4gICAgfVxyXG4gICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LmluaXQgPSBmdW5jdGlvbiAoKSB7IHRlc3RhYmlsaXR5XzEuc2V0VGVzdGFiaWxpdHlHZXR0ZXIobmV3IEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpKTsgfTtcclxuICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHtcclxuICAgICAgICBsYW5nXzEuZ2xvYmFsLmdldEFuZ3VsYXJUZXN0YWJpbGl0eSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cclxuICAgICAgICAgICAgdmFyIHRlc3RhYmlsaXR5ID0gcmVnaXN0cnkuZmluZFRlc3RhYmlsaXR5SW5UcmVlKGVsZW0sIGZpbmRJbkFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0YWJpbGl0eSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRlc3RhYmlsaXR5IGZvciBlbGVtZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVibGljVGVzdGFiaWxpdHkodGVzdGFiaWxpdHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGFuZ18xLmdsb2JhbC5nZXRBbGxBbmd1bGFyVGVzdGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRlc3RhYmlsaXRpZXMgPSByZWdpc3RyeS5nZXRBbGxUZXN0YWJpbGl0aWVzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXN0YWJpbGl0aWVzLm1hcChmdW5jdGlvbiAodGVzdGFiaWxpdHkpIHsgcmV0dXJuIG5ldyBQdWJsaWNUZXN0YWJpbGl0eSh0ZXN0YWJpbGl0eSk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJyb3dzZXJHZXRUZXN0YWJpbGl0eTtcclxufSkoKTtcclxuZXhwb3J0cy5Ccm93c2VyR2V0VGVzdGFiaWxpdHkgPSBCcm93c2VyR2V0VGVzdGFiaWxpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfdGVzdGFiaWxpdHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBkaV8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZGknKTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJy4uL3pvbmUvbmdfem9uZScpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG4vKipcclxuICogVGhlIFRlc3RhYmlsaXR5IHNlcnZpY2UgcHJvdmlkZXMgdGVzdGluZyBob29rcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBmcm9tXHJcbiAqIHRoZSBicm93c2VyIGFuZCBieSBzZXJ2aWNlcyBzdWNoIGFzIFByb3RyYWN0b3IuIEVhY2ggYm9vdHN0cmFwcGVkIEFuZ3VsYXJcclxuICogYXBwbGljYXRpb24gb24gdGhlIHBhZ2Ugd2lsbCBoYXZlIGFuIGluc3RhbmNlIG9mIFRlc3RhYmlsaXR5LlxyXG4gKi9cclxudmFyIFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5KF9uZ1pvbmUpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2lzQW5ndWxhckV2ZW50UGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3dhdGNoQW5ndWxhckV2ZW50cyhfbmdab25lKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fd2F0Y2hBbmd1bGFyRXZlbnRzID0gZnVuY3Rpb24gKF9uZ1pvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9uZ1pvbmUub3ZlcnJpZGVPblR1cm5TdGFydChmdW5jdGlvbiAoKSB7IF90aGlzLl9pc0FuZ3VsYXJFdmVudFBlbmRpbmcgPSB0cnVlOyB9KTtcclxuICAgICAgICBfbmdab25lLm92ZXJyaWRlT25FdmVudERvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faXNBbmd1bGFyRXZlbnRQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmluY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgKz0gMTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5kZWNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdwZW5kaW5nIGFzeW5jIHJlcXVlc3RzIGJlbG93IHplcm8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7XHJcbiAgICB9O1xyXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmlzU3RhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50ID09IDAgJiYgIXRoaXMuX2lzQW5ndWxhckV2ZW50UGVuZGluZzsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fcnVuQ2FsbGJhY2tzSWZSZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1N0YWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm90IHJlYWR5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgY2FsbCBiYWNrcyBpbiBhIG5ldyBmcmFtZSBzbyB0aGF0IGl0IGlzIGFsd2F5cyBhc3luYy5cclxuICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICB3aGlsZSAoX3RoaXMuX2NhbGxiYWNrcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIChfdGhpcy5fY2FsbGJhY2tzLnBvcCgpKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLndoZW5TdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5nZXRQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50OyB9O1xyXG4gICAgLy8gVGhpcyBvbmx5IGFjY291bnRzIGZvciBuZ1pvbmUsIGFuZCBub3QgcGVuZGluZyBjb3VudHMuIFVzZSBgd2hlblN0YWJsZWAgdG9cclxuICAgIC8vIGNoZWNrIGZvciBzdGFiaWxpdHkuXHJcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuaXNBbmd1bGFyRXZlbnRQZW5kaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXNBbmd1bGFyRXZlbnRQZW5kaW5nOyB9O1xyXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRCaW5kaW5ncyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcclxuICAgICAgICAvLyBUT0RPKGp1bGllbXIpOiBpbXBsZW1lbnQuXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kUHJvdmlkZXJzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xyXG4gICAgICAgIC8vIFRPRE8oanVsaWVtcik6IGltcGxlbWVudC5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgVGVzdGFiaWxpdHkgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbbmdfem9uZV8xLk5nWm9uZV0pXHJcbiAgICBdLCBUZXN0YWJpbGl0eSk7XHJcbiAgICByZXR1cm4gVGVzdGFiaWxpdHk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVzdGFiaWxpdHkgPSBUZXN0YWJpbGl0eTtcclxudmFyIFRlc3RhYmlsaXR5UmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVzdGFiaWxpdHlSZWdpc3RyeSgpIHtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0ZXN0YWJpbGl0eUdldHRlci5hZGRUb1dpbmRvdyh0aGlzKTtcclxuICAgIH1cclxuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyQXBwbGljYXRpb24gPSBmdW5jdGlvbiAodG9rZW4sIHRlc3RhYmlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnNldCh0b2tlbiwgdGVzdGFiaWxpdHkpO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbFRlc3RhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci52YWx1ZXModGhpcy5fYXBwbGljYXRpb25zKTsgfTtcclxuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcclxuICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChlbGVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9hcHBsaWNhdGlvbnMuaGFzKGVsZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbnMuZ2V0KGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghZmluZEluQW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5ET00uaXNTaGFkb3dSb290KGVsZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShkb21fYWRhcHRlcl8xLkRPTS5nZXRIb3N0KGVsZW0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlc3RhYmlsaXR5SW5UcmVlKGRvbV9hZGFwdGVyXzEuRE9NLnBhcmVudEVsZW1lbnQoZWxlbSkpO1xyXG4gICAgfTtcclxuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkaV8xLkluamVjdGFibGUoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcclxuICAgIF0sIFRlc3RhYmlsaXR5UmVnaXN0cnkpO1xyXG4gICAgcmV0dXJuIFRlc3RhYmlsaXR5UmVnaXN0cnk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGVzdGFiaWxpdHlSZWdpc3RyeSA9IFRlc3RhYmlsaXR5UmVnaXN0cnk7XHJcbnZhciBOb29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9vcEdldFRlc3RhYmlsaXR5KCkge1xyXG4gICAgfVxyXG4gICAgTm9vcEdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5hZGRUb1dpbmRvdyA9IGZ1bmN0aW9uIChyZWdpc3RyeSkgeyB9O1xyXG4gICAgTm9vcEdldFRlc3RhYmlsaXR5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBOb29wR2V0VGVzdGFiaWxpdHkpO1xyXG4gICAgcmV0dXJuIE5vb3BHZXRUZXN0YWJpbGl0eTtcclxufSkoKTtcclxuZnVuY3Rpb24gc2V0VGVzdGFiaWxpdHlHZXR0ZXIoZ2V0dGVyKSB7XHJcbiAgICB0ZXN0YWJpbGl0eUdldHRlciA9IGdldHRlcjtcclxufVxyXG5leHBvcnRzLnNldFRlc3RhYmlsaXR5R2V0dGVyID0gc2V0VGVzdGFiaWxpdHlHZXR0ZXI7XHJcbnZhciB0ZXN0YWJpbGl0eUdldHRlciA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBOb29wR2V0VGVzdGFiaWxpdHkoKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RhYmlsaXR5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JzsvLyBQdWJsaWMgQVBJIGZvciB1dGlsXHJcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCcuL3V0aWwvZGVjb3JhdG9ycycpO1xyXG5leHBvcnRzLkNsYXNzID0gZGVjb3JhdG9yc18xLkNsYXNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZnVuY3Rpb24gZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikge1xyXG4gICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGFubm90YXRpb24pICYmIGFubm90YXRpb24uaGFzT3duUHJvcGVydHkoJ2Fubm90YXRpb24nKSkge1xyXG4gICAgICAgIC8vIGl0IGlzIGEgZGVjb3JhdG9yLCBleHRyYWN0IGFubm90YXRpb25cclxuICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFubm90YXRpb247XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlQYXJhbXMoZm5PckFycmF5LCBrZXkpIHtcclxuICAgIGlmIChmbk9yQXJyYXkgPT09IE9iamVjdCB8fCBmbk9yQXJyYXkgPT09IFN0cmluZyB8fCBmbk9yQXJyYXkgPT09IEZ1bmN0aW9uIHx8XHJcbiAgICAgICAgZm5PckFycmF5ID09PSBOdW1iZXIgfHwgZm5PckFycmF5ID09PSBBcnJheSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgdXNlIG5hdGl2ZSBcIiArIGxhbmdfMS5zdHJpbmdpZnkoZm5PckFycmF5KSArIFwiIGFzIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGZuT3JBcnJheSkpIHtcclxuICAgICAgICByZXR1cm4gZm5PckFycmF5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZm5PckFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBmbk9yQXJyYXk7XHJcbiAgICAgICAgdmFyIGZuID0gZm5PckFycmF5W2ZuT3JBcnJheS5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAoIWxhbmdfMS5pc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHBvc2l0aW9uIG9mIENsYXNzIG1ldGhvZCBhcnJheSBtdXN0IGJlIEZ1bmN0aW9uIGluIGtleSBcIiArIGtleSArIFwiIHdhcyAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGZuKSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFubm9MZW5ndGggPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChhbm5vTGVuZ3RoICE9IGZuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYW5ub3RhdGlvbnMgKFwiICsgYW5ub0xlbmd0aCArIFwiKSBkb2VzIG5vdCBtYXRjaCBudW1iZXIgb2YgYXJndW1lbnRzIChcIiArIGZuLmxlbmd0aCArIFwiKSBpbiB0aGUgZnVuY3Rpb246IFwiICsgbGFuZ18xLnN0cmluZ2lmeShmbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyYW1zQW5ub3RhdGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBwYXJhbXNBbm5vdGF0aW9ucy5wdXNoKHBhcmFtQW5ub3RhdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xyXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFubm90YXRpb24ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbltqXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGFubm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbXNBbm5vdGF0aW9ucywgZm4pO1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgRnVuY3Rpb24gb3IgQXJyYXkgaXMgc3VwcG9ydGVkIGluIENsYXNzIGRlZmluaXRpb24gZm9yIGtleSAnXCIgKyBrZXkgKyBcIicgaXMgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShmbk9yQXJyYXkpICsgXCInXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHdheSBmb3IgZXhwcmVzc2luZyBFUzYgY2xhc3NlcyB3aXRoIHBhcmFtZXRlciBhbm5vdGF0aW9ucyBpbiBFUzUuXHJcbiAqXHJcbiAqICMjIEJhc2ljIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBHcmVldGVyID0gbmcuQ2xhc3Moe1xyXG4gKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gKiAgIH0sXHJcbiAqXHJcbiAqICAgZ3JlZXQ6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xyXG4gKiAgIH1cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcclxuICpcclxuICogYGBgXHJcbiAqIGNsYXNzIEdyZWV0ZXIge1xyXG4gKiAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICogICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIGdyZWV0KCkge1xyXG4gKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogb3IgZXF1aXZhbGVudCB0byBFUzU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgR3JlZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAqICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICogfVxyXG4gKlxyXG4gKiBHcmVldGVyLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uICgpIHtcclxuICogICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnNcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBNeVNlcnZpY2UgPSBuZy5DbGFzcyh7XHJcbiAqICAgY29uc3RydWN0b3I6IFtTdHJpbmcsIFtuZXcgUXVlcnkoKSwgUXVlcnlMaXN0XSwgZnVuY3Rpb24obmFtZSwgcXVlcnlMaXN0KSB7XHJcbiAqICAgICAuLi5cclxuICogICB9XVxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGlzIGVxdWl2YWxlbnQgdG8gRVM2OlxyXG4gKlxyXG4gKiBgYGBcclxuICogY2xhc3MgTXlTZXJ2aWNlIHtcclxuICogICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIEBRdWVyeSgpIHF1ZXJ5TGlzdDogUXVlcnlMaXN0KSB7XHJcbiAqICAgICAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgd2l0aCBpbmhlcml0YW5jZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIFNoYXBlID0gbmcuQ2xhc3Moe1xyXG4gKiAgIGNvbnN0cnVjdG9yOiAoY29sb3IpIHtcclxuICogICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiB2YXIgU3F1YXJlID0gbmcuQ2xhc3Moe1xyXG4gKiAgIGV4dGVuZHM6IFNoYXBlLFxyXG4gKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihjb2xvciwgc2l6ZSkge1xyXG4gKiAgICAgU2hhcGUuY2FsbCh0aGlzLCBjb2xvcik7XHJcbiAqICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gKiAgIH1cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gQ2xhc3MoY2xzRGVmKSB7XHJcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcHBseVBhcmFtcyhjbHNEZWYuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykgPyBjbHNEZWYuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsICdjb25zdHJ1Y3RvcicpO1xyXG4gICAgdmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gICAgaWYgKGNsc0RlZi5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGNsc0RlZi5leHRlbmRzKSkge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBwcm90byA9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGNsc0RlZi5leHRlbmRzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzcyBkZWZpbml0aW9uICdleHRlbmRzJyBwcm9wZXJ0eSBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2FzOiBcIiArIGxhbmdfMS5zdHJpbmdpZnkoY2xzRGVmLmV4dGVuZHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gY2xzRGVmKSB7XHJcbiAgICAgICAgaWYgKGtleSAhPSAnZXh0ZW5kcycgJiYga2V5ICE9ICdwcm90b3R5cGUnICYmIGNsc0RlZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHByb3RvW2tleV0gPSBhcHBseVBhcmFtcyhjbHNEZWZba2V5XSwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcyAmJiB0aGlzLmFubm90YXRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcclxufVxyXG5leHBvcnRzLkNsYXNzID0gQ2xhc3M7XHJcbnZhciBSZWZsZWN0ID0gbGFuZ18xLmdsb2JhbC5SZWZsZWN0O1xyXG5pZiAoIShSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XHJcbiAgICB0aHJvdyAncmVmbGVjdC1tZXRhZGF0YSBzaGltIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgY2xhc3MgZGVjb3JhdG9ycyc7XHJcbn1cclxuZnVuY3Rpb24gbWFrZURlY29yYXRvcihhbm5vdGF0aW9uQ2xzLCBjaGFpbkZuKSB7XHJcbiAgICBpZiAoY2hhaW5GbiA9PT0gdm9pZCAwKSB7IGNoYWluRm4gPSBudWxsOyB9XHJcbiAgICBmdW5jdGlvbiBEZWNvcmF0b3JGYWN0b3J5KG9iak9yVHlwZSkge1xyXG4gICAgICAgIHZhciBhbm5vdGF0aW9uSW5zdGFuY2UgPSBuZXcgYW5ub3RhdGlvbkNscyhvYmpPclR5cGUpO1xyXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYW5ub3RhdGlvbkNscykge1xyXG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbkluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNoYWluQW5ub3RhdGlvbiA9IGxhbmdfMS5pc0Z1bmN0aW9uKHRoaXMpICYmIHRoaXMuYW5ub3RhdGlvbnMgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuYW5ub3RhdGlvbnMgOiBbXTtcclxuICAgICAgICAgICAgY2hhaW5Bbm5vdGF0aW9uLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcclxuICAgICAgICAgICAgdmFyIFR5cGVEZWNvcmF0b3IgPSBmdW5jdGlvbiBUeXBlRGVjb3JhdG9yKGNscykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCBjbHMpO1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgYW5ub3RhdGlvbnMsIGNscyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUeXBlRGVjb3JhdG9yLmFubm90YXRpb25zID0gY2hhaW5Bbm5vdGF0aW9uO1xyXG4gICAgICAgICAgICBUeXBlRGVjb3JhdG9yLkNsYXNzID0gQ2xhc3M7XHJcbiAgICAgICAgICAgIGlmIChjaGFpbkZuKVxyXG4gICAgICAgICAgICAgICAgY2hhaW5GbihUeXBlRGVjb3JhdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIFR5cGVEZWNvcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFubm90YXRpb25DbHMucHJvdG90eXBlKTtcclxuICAgIHJldHVybiBEZWNvcmF0b3JGYWN0b3J5O1xyXG59XHJcbmV4cG9ydHMubWFrZURlY29yYXRvciA9IG1ha2VEZWNvcmF0b3I7XHJcbmZ1bmN0aW9uIG1ha2VQYXJhbURlY29yYXRvcihhbm5vdGF0aW9uQ2xzKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJhbURlY29yYXRvckZhY3RvcnkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShhbm5vdGF0aW9uQ2xzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgYW5ub3RhdGlvbkNscy5hcHBseShhbm5vdGF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xyXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYW5ub3RhdGlvbkNscykge1xyXG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbkluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgUGFyYW1EZWNvcmF0b3IuYW5ub3RhdGlvbiA9IGFubm90YXRpb25JbnN0YW5jZTtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBQYXJhbURlY29yYXRvcihjbHMsIHVudXNlZEtleSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgY2xzKTtcclxuICAgICAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwgW107XHJcbiAgICAgICAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIGdhcHMgaWYgc29tZSBpbiBiZXR3ZWVuIHBhcmFtZXRlcnMgZG8gbm90IGhhdmUgYW5ub3RhdGlvbnMuXHJcbiAgICAgICAgICAgIC8vIHdlIHBhZCB3aXRoIG51bGxzLlxyXG4gICAgICAgICAgICB3aGlsZSAocGFyYW1ldGVycy5sZW5ndGggPD0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW2luZGV4XSA9IHBhcmFtZXRlcnNbaW5kZXhdIHx8IFtdO1xyXG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnNGb3JQYXJhbSA9IHBhcmFtZXRlcnNbaW5kZXhdO1xyXG4gICAgICAgICAgICBhbm5vdGF0aW9uc0ZvclBhcmFtLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcclxuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgncGFyYW1ldGVycycsIHBhcmFtZXRlcnMsIGNscyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjbHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW5ub3RhdGlvbkNscy5wcm90b3R5cGUpO1xyXG4gICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yRmFjdG9yeTtcclxufVxyXG5leHBvcnRzLm1ha2VQYXJhbURlY29yYXRvciA9IG1ha2VQYXJhbURlY29yYXRvcjtcclxuZnVuY3Rpb24gbWFrZVByb3BEZWNvcmF0b3IoZGVjb3JhdG9yQ2xzKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yRmFjdG9yeSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWNvcmF0b3JJbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUoZGVjb3JhdG9yQ2xzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgZGVjb3JhdG9yQ2xzLmFwcGx5KGRlY29yYXRvckluc3RhbmNlLCBhcmdzKTtcclxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGRlY29yYXRvckNscykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9ySW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gUHJvcERlY29yYXRvcih0YXJnZXQsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgICAgIG1ldGEgPSBtZXRhIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgbWV0YVtuYW1lXSA9IG1ldGFbbmFtZV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdLnVuc2hpZnQoZGVjb3JhdG9ySW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgbWV0YSwgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGRlY29yYXRvckNscy5wcm90b3R5cGUpO1xyXG4gICAgcmV0dXJuIFByb3BEZWNvcmF0b3JGYWN0b3J5O1xyXG59XHJcbmV4cG9ydHMubWFrZVByb3BEZWNvcmF0b3IgPSBtYWtlUHJvcERlY29yYXRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb3JhdG9ycy5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gUHVibGljIEFQSSBmb3IgWm9uZVxyXG52YXIgbmdfem9uZV8xID0gcmVxdWlyZSgnLi96b25lL25nX3pvbmUnKTtcclxuZXhwb3J0cy5OZ1pvbmUgPSBuZ196b25lXzEuTmdab25lO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD16b25lLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBwcm9maWxlXzEgPSByZXF1aXJlKCcuLi9wcm9maWxlL3Byb2ZpbGUnKTtcclxuLyoqXHJcbiAqIEFuIGluamVjdGFibGUgc2VydmljZSBmb3IgZXhlY3V0aW5nIHdvcmsgaW5zaWRlIG9yIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIHVzZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2Ugd2hlbiBzdGFydGluZyBhIHdvcmsgY29uc2lzdGluZyBvZlxyXG4gKiBvbmUgb3IgbW9yZSBhc3luY2hyb25vdXMgdGFza3MgdGhhdCBkb24ndCByZXF1aXJlIFVJIHVwZGF0ZXMgb3IgZXJyb3IgaGFuZGxpbmcgdG8gYmUgaGFuZGxlZCBieVxyXG4gKiBBbmd1bGFyLiBTdWNoIHRhc2tzIGNhbiBiZSBraWNrZWQgb2ZmIHZpYSB7QGxpbmsgI3J1bk91dHNpZGVBbmd1bGFyfSBhbmQgaWYgbmVlZGVkLCB0aGVzZSB0YXNrc1xyXG4gKiBjYW4gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIHZpYSB7QGxpbmsgI3J1bn0uXHJcbiAqXHJcbiAqIDwhLS0gVE9ETzogYWRkL2ZpeCBsaW5rcyB0bzpcclxuICogICAtIGRvY3MgZXhwbGFpbmluZyB6b25lcyBhbmQgdGhlIHVzZSBvZiB6b25lcyBpbiBBbmd1bGFyIGFuZCBjaGFuZ2UtZGV0ZWN0aW9uXHJcbiAqICAgLSBsaW5rIHRvIHJ1bk91dHNpZGVBbmd1bGFyL3J1biAodGhyb3VnaG91dCB0aGlzIGZpbGUhKVxyXG4gKiAgIC0tPlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvbFk5bThITHk3ejA2dkRvVWFTTjI/cD1wcmV2aWV3KSlcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50LCBWaWV3LCBOZ0lmLCBOZ1pvbmV9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICAgc2VsZWN0b3I6ICduZy16b25lLWRlbW8nLlxyXG4gKiAgIHRlbXBsYXRlOiBgXHJcbiAqICAgICA8aDI+RGVtbzogTmdab25lPC9oMj5cclxuICpcclxuICogICAgIDxwPlByb2dyZXNzOiB7e3Byb2dyZXNzfX0lPC9wPlxyXG4gKiAgICAgPHAgKm5nLWlmPVwicHJvZ3Jlc3MgPj0gMTAwXCI+RG9uZSBwcm9jZXNzaW5nIHt7bGFiZWx9fSBvZiBBbmd1bGFyIHpvbmUhPC9wPlxyXG4gKlxyXG4gKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc1dpdGhpbkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIHdpdGhpbiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cclxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyBvdXRzaWRlIG9mIEFuZ3VsYXIgem9uZTwvYnV0dG9uPlxyXG4gKiAgIGAsXHJcbiAqICAgZGlyZWN0aXZlczogW05nSWZdXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBOZ1pvbmVEZW1vIHtcclxuICogICBwcm9ncmVzczogbnVtYmVyID0gMDtcclxuICogICBsYWJlbDogc3RyaW5nO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7fVxyXG4gKlxyXG4gKiAgIC8vIExvb3AgaW5zaWRlIHRoZSBBbmd1bGFyIHpvbmVcclxuICogICAvLyBzbyB0aGUgVUkgRE9FUyByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxyXG4gKiAgIHByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpIHtcclxuICogICAgIHRoaXMubGFiZWwgPSAnaW5zaWRlJztcclxuICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG4gKiAgICAgdGhpcy5faW5jcmVhc2VQcm9ncmVzcygoKSA9PiBjb25zb2xlLmxvZygnSW5zaWRlIERvbmUhJykpO1xyXG4gKiAgIH1cclxuICpcclxuICogICAvLyBMb29wIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZVxyXG4gKiAgIC8vIHNvIHRoZSBVSSBET0VTIE5PVCByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxyXG4gKiAgIHByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpIHtcclxuICogICAgIHRoaXMubGFiZWwgPSAnb3V0c2lkZSc7XHJcbiAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICogICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAqICAgICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4ge1xyXG4gKiAgICAgICAvLyByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgYW5kIGRpc3BsYXkgZG9uZVxyXG4gKiAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHtjb25zb2xlLmxvZygnT3V0c2lkZSBEb25lIScpIH0pO1xyXG4gKiAgICAgfX0pKTtcclxuICogICB9XHJcbiAqXHJcbiAqXHJcbiAqICAgX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XHJcbiAqICAgICB0aGlzLnByb2dyZXNzICs9IDE7XHJcbiAqICAgICBjb25zb2xlLmxvZyhgQ3VycmVudCBwcm9ncmVzczogJHt0aGlzLnByb2dyZXNzfSVgKTtcclxuICpcclxuICogICAgIGlmICh0aGlzLnByb2dyZXNzIDwgMTAwKSB7XHJcbiAqICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrKSksIDEwKVxyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgZG9uZUNhbGxiYWNrKCk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIE5nWm9uZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZW5hYmxlTG9uZ1N0YWNrVHJhY2Ugd2hldGhlciB0byBlbmFibGUgbG9uZyBzdGFjayB0cmFjZS4gVGhleSBzaG91bGQgb25seSBiZVxyXG4gICAgICogICAgICAgICAgICAgICBlbmFibGVkIGluIGRldmVsb3BtZW50IG1vZGUgYXMgdGhleSBzaWduaWZpY2FudGx5IGltcGFjdCBwZXJmLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBOZ1pvbmUoX2EpIHtcclxuICAgICAgICB2YXIgZW5hYmxlTG9uZ1N0YWNrVHJhY2UgPSBfYS5lbmFibGVMb25nU3RhY2tUcmFjZTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fcnVuU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoXCJOZ1pvbmUjcnVuKClcIik7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX21pY3JvdGFza1Njb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKFwiTmdab25lI21pY3JvdGFzaygpXCIpO1xyXG4gICAgICAgIC8vIE51bWJlciBvZiBtaWNyb3Rhc2tzIHBlbmRpbmcgZnJvbSBfaW5uZXJab25lICgmIGRlc2NlbmRhbnRzKVxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9wZW5kaW5nTWljcm90YXNrcyA9IDA7XHJcbiAgICAgICAgLy8gV2hldGhlciBzb21lIGNvZGUgaGFzIGJlZW4gZXhlY3V0ZWQgaW4gdGhlIF9pbm5lclpvbmUgKCYgZGVzY2VuZGFudHMpIGluIHRoZSBjdXJyZW50IHR1cm5cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5faGFzRXhlY3V0ZWRDb2RlSW5Jbm5lclpvbmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBydW4oKSBjYWxsIGRlcHRoIGluIF9tb3VudFpvbmUuIDAgYXQgdGhlIGVuZCBvZiBhIG1hY3JvdGFza1xyXG4gICAgICAgIC8vIHpvbmUucnVuKCgpID0+IHsgICAgICAgICAvLyB0b3AtbGV2ZWwgY2FsbFxyXG4gICAgICAgIC8vICAgem9uZS5ydW4oKCkgPT4ge30pOyAgICAvLyBuZXN0ZWQgY2FsbCAtPiBpbi10dXJuXHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX25lc3RlZFJ1biA9IDA7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX2luVm1UdXJuRG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9wZW5kaW5nVGltZW91dHMgPSBbXTtcclxuICAgICAgICBpZiAobGFuZ18xLmdsb2JhbC56b25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdW50Wm9uZSA9IGxhbmdfMS5nbG9iYWwuem9uZTtcclxuICAgICAgICAgICAgdGhpcy5faW5uZXJab25lID0gdGhpcy5fY3JlYXRlSW5uZXJab25lKHRoaXMuX21vdW50Wm9uZSwgZW5hYmxlTG9uZ1N0YWNrVHJhY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VudFpvbmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9uZSBob29rIHRoYXQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIGEgYnJvd3NlciB0YXNrIHRoYXQgaXMgaGFuZGxlZCBieSBBbmd1bGFyXHJcbiAgICAgKiBleGVjdXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaG9vayBpcyBjYWxsZWQgb25jZSBwZXIgYnJvd3NlciB0YXNrIHRoYXQgaXMgaGFuZGxlZCBieSBBbmd1bGFyLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGhvb2sgb3ZlcnJpZGVzIGFueSBwcmV2aW91c2x5IHNldCBob29rLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLm92ZXJyaWRlT25UdXJuU3RhcnQgPSBmdW5jdGlvbiAob25UdXJuU3RhcnRIb29rKSB7XHJcbiAgICAgICAgdGhpcy5fb25UdXJuU3RhcnQgPSBsYW5nXzEubm9ybWFsaXplQmxhbmsob25UdXJuU3RhcnRIb29rKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHpvbmUgaG9vayB0aGF0IGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBBbmd1bGFyIHpvbmUgaXMgZG9uZSBwcm9jZXNzaW5nIHRoZSBjdXJyZW50XHJcbiAgICAgKiB0YXNrIGFuZCBhbnkgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB0aGF0IHRhc2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB3aGVyZSB3ZSB0eXBpY2FsbHkgZG8gY2hhbmdlLWRldGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaG9vayBpcyBjYWxsZWQgb25jZSBwZXIgYnJvd3NlciB0YXNrIHRoYXQgaXMgaGFuZGxlZCBieSBBbmd1bGFyLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGhvb2sgb3ZlcnJpZGVzIGFueSBwcmV2aW91c2x5IHNldCBob29rLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLm92ZXJyaWRlT25UdXJuRG9uZSA9IGZ1bmN0aW9uIChvblR1cm5Eb25lSG9vaykge1xyXG4gICAgICAgIHRoaXMuX29uVHVybkRvbmUgPSBsYW5nXzEubm9ybWFsaXplQmxhbmsob25UdXJuRG9uZUhvb2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9uZSBob29rIHRoYXQgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBgb25UdXJuRG9uZWAgY2FsbGJhY2sgaXMgY2FsbGVkIGFuZCBhbnlcclxuICAgICAqIG1pY3Jvc3Rhc2tzIHNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGF0IGNhbGxiYWNrIGFyZSBkcmFpbmVkLlxyXG4gICAgICpcclxuICAgICAqIGBvbkV2ZW50RG9uZUZuYCBpcyBleGVjdXRlZCBvdXRzaWRlIEFuZ3VsYXIgem9uZSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSB3aWxsIG5vIGxvbmdlciBhdHRlbXB0IHRvXHJcbiAgICAgKiBzeW5jIHRoZSBVSSB3aXRoIGFueSBtb2RlbCBjaGFuZ2VzIHRoYXQgb2NjdXIgd2l0aGluIHRoaXMgY2FsbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBob29rIGlzIHVzZWZ1bCBmb3IgdmFsaWRhdGluZyBhcHBsaWNhdGlvbiBzdGF0ZSAoZS5nLiBpbiBhIHRlc3QpLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGhvb2sgb3ZlcnJpZGVzIGFueSBwcmV2aW91c2x5IHNldCBob29rLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLm92ZXJyaWRlT25FdmVudERvbmUgPSBmdW5jdGlvbiAob25FdmVudERvbmVGbiwgb3B0X3dhaXRGb3JBc3luYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9wdF93YWl0Rm9yQXN5bmMgPT09IHZvaWQgMCkgeyBvcHRfd2FpdEZvckFzeW5jID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgbm9ybWFsaXplZE9uRXZlbnREb25lID0gbGFuZ18xLm5vcm1hbGl6ZUJsYW5rKG9uRXZlbnREb25lRm4pO1xyXG4gICAgICAgIGlmIChvcHRfd2FpdEZvckFzeW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRXZlbnREb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcGVuZGluZ1RpbWVvdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRPbkV2ZW50RG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb25FdmVudERvbmUgPSBub3JtYWxpemVkT25FdmVudERvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9uZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBBbmd1bGFyIHpvbmUuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGUgaG9vayBvdmVycmlkZXMgYW55IHByZXZpb3VzbHkgc2V0IGhvb2suXHJcbiAgICAgKi9cclxuICAgIE5nWm9uZS5wcm90b3R5cGUub3ZlcnJpZGVPbkVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9vbkVycm9ySGFuZGxlciA9IGxhbmdfMS5ub3JtYWxpemVCbGFuayhlcnJvckhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSBhbmQgcmV0dXJucyB2YWx1ZSByZXR1cm5lZCBieVxyXG4gICAgICogdGhlIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBgcnVuYCBhbGxvd3MgeW91IHRvIHJlZW50ZXIgQW5ndWxhciB6b25lIGZyb20gYSB0YXNrIHRoYXQgd2FzIGV4ZWN1dGVkXHJcbiAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUgKHR5cGljYWxseSBzdGFydGVkIHZpYSB7QGxpbmsgI3J1bk91dHNpZGVBbmd1bGFyfSkuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGZ1dHVyZSB0YXNrcyBvciBtaWNyb3Rhc2tzIHNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udGludWUgZXhlY3V0aW5nIGZyb21cclxuICAgICAqIHdpdGhpbiB0aGUgQW5ndWxhciB6b25lLlxyXG4gICAgICovXHJcbiAgICBOZ1pvbmUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fcnVuU2NvcGUoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbm5lclpvbmUucnVuKGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XHJcbiAgICAgKiB0aGUgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIGBydW5PdXRzaWRlQW5ndWxhcmAgYWxsb3dzIHlvdSB0byBlc2NhcGUgQW5ndWxhcidzIHpvbmUgYW5kIGRvIHdvcmsgdGhhdFxyXG4gICAgICogZG9lc24ndCB0cmlnZ2VyIEFuZ3VsYXIgY2hhbmdlLWRldGVjdGlvbiBvciBpcyBzdWJqZWN0IHRvIEFuZ3VsYXIncyBlcnJvciBoYW5kbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxyXG4gICAgICogb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lLlxyXG4gICAgICpcclxuICAgICAqIFVzZSB7QGxpbmsgI3J1bn0gdG8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkbyB3b3JrIHRoYXQgdXBkYXRlcyB0aGUgYXBwbGljYXRpb24gbW9kZWwuXHJcbiAgICAgKi9cclxuICAgIE5nWm9uZS5wcm90b3R5cGUucnVuT3V0c2lkZUFuZ3VsYXIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW91bnRab25lLnJ1bihmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nWm9uZS5wcm90b3R5cGUuX2NyZWF0ZUlubmVyWm9uZSA9IGZ1bmN0aW9uICh6b25lLCBlbmFibGVMb25nU3RhY2tUcmFjZSkge1xyXG4gICAgICAgIHZhciBtaWNyb3Rhc2tTY29wZSA9IHRoaXMuX21pY3JvdGFza1Njb3BlO1xyXG4gICAgICAgIHZhciBuZ1pvbmUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsaW5nO1xyXG4gICAgICAgIGlmIChlbmFibGVMb25nU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBlcnJvckhhbmRsaW5nID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIubWVyZ2UoWm9uZS5sb25nU3RhY2tUcmFjZVpvbmUsIHsgb25FcnJvcjogZnVuY3Rpb24gKGUpIHsgbmdab25lLl9vbkVycm9yKHRoaXMsIGUpOyB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGluZyA9IHsgb25FcnJvcjogZnVuY3Rpb24gKGUpIHsgbmdab25lLl9vbkVycm9yKHRoaXMsIGUpOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB6b25lLmZvcmsoZXJyb3JIYW5kbGluZylcclxuICAgICAgICAgICAgLmZvcmsoe1xyXG4gICAgICAgICAgICAnJHJ1bic6IGZ1bmN0aW9uIChwYXJlbnRSdW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmdab25lLl9uZXN0ZWRSdW4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZ1pvbmUuX2hhc0V4ZWN1dGVkQ29kZUluSW5uZXJab25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ1pvbmUuX2hhc0V4ZWN1dGVkQ29kZUluSW5uZXJab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZ1pvbmUuX29uVHVyblN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVuLmNhbGwobmdab25lLl9pbm5lclpvbmUsIG5nWm9uZS5fb25UdXJuU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRSdW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZS5fbmVzdGVkUnVuLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIHBlbmRpbmcgbWljcm90YXNrcywgd2UgYXJlIGF0IHRoZSBlbmQgb2YgYSBWTSB0dXJuIChvciBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvblR1cm5TdGFydClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX25lc3RlZFJ1biB3aWxsIGJlIDAgYXQgdGhlIGVuZCBvZiBhIG1hY3JvdGFza3MgKGl0IGNvdWxkIGJlID4gMCB3aGVuIHRoZXJlIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgY2FsbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcnVuKCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmdab25lLl9wZW5kaW5nTWljcm90YXNrcyA9PSAwICYmIG5nWm9uZS5fbmVzdGVkUnVuID09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9pblZtVHVybkRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZ1pvbmUuX29uVHVybkRvbmUgJiYgbmdab25lLl9oYXNFeGVjdXRlZENvZGVJbklubmVyWm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luVm1UdXJuRG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5jYWxsKG5nWm9uZS5faW5uZXJab25lLCBuZ1pvbmUuX29uVHVybkRvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5WbVR1cm5Eb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nWm9uZS5faGFzRXhlY3V0ZWRDb2RlSW5Jbm5lclpvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmdab25lLl9wZW5kaW5nTWljcm90YXNrcyA9PT0gMCAmJiBsYW5nXzEuaXNQcmVzZW50KG5nWm9uZS5fb25FdmVudERvbmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKG5nWm9uZS5fb25FdmVudERvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyRzY2hlZHVsZU1pY3JvdGFzayc6IGZ1bmN0aW9uIChwYXJlbnRTY2hlZHVsZU1pY3JvdGFzaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5nWm9uZS5fcGVuZGluZ01pY3JvdGFza3MrKztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWljcm90YXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG1pY3JvdGFza1Njb3BlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdab25lLl9wZW5kaW5nTWljcm90YXNrcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZV8xLnd0ZkxlYXZlKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTY2hlZHVsZU1pY3JvdGFzay5jYWxsKHRoaXMsIG1pY3JvdGFzayk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnJHNldFRpbWVvdXQnOiBmdW5jdGlvbiAocGFyZW50U2V0VGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUobmdab25lLl9wZW5kaW5nVGltZW91dHMsIGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gcGFyZW50U2V0VGltZW91dChjYiwgZGVsYXksIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5nWm9uZS5fcGVuZGluZ1RpbWVvdXRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICckY2xlYXJUaW1lb3V0JzogZnVuY3Rpb24gKHBhcmVudENsZWFyVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENsZWFyVGltZW91dChpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZShuZ1pvbmUuX3BlbmRpbmdUaW1lb3V0cywgaWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2lubmVyWm9uZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIE5nWm9uZS5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoem9uZSwgZSkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX29uRXJyb3JIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2UgPSBbbGFuZ18xLm5vcm1hbGl6ZUJsYW5rKGUuc3RhY2spXTtcclxuICAgICAgICAgICAgd2hpbGUgKHpvbmUgJiYgem9uZS5jb25zdHJ1Y3RlZEF0RXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZS5wdXNoKHpvbmUuY29uc3RydWN0ZWRBdEV4Y2VwdGlvbi5nZXQoKSk7XHJcbiAgICAgICAgICAgICAgICB6b25lID0gem9uZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb25FcnJvckhhbmRsZXIoZSwgdHJhY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJyMjIF9vbkVycm9yICMjJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTmdab25lO1xyXG59KSgpO1xyXG5leHBvcnRzLk5nWm9uZSA9IE5nWm9uZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfem9uZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBBc3luY1JvdXRlSGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBc3luY1JvdXRlSGFuZGxlcihfbG9hZGVyLCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gX2xvYWRlcjtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9yZXNvbHZlZENvbXBvbmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBBc3luY1JvdXRlSGFuZGxlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZXNvbHZlZENvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQ29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRDb21wb25lbnQgPSB0aGlzLl9sb2FkZXIoKS50aGVuKGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50VHlwZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXN5bmNSb3V0ZUhhbmRsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXN5bmNSb3V0ZUhhbmRsZXIgPSBBc3luY1JvdXRlSGFuZGxlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNfcm91dGVfaGFuZGxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZChvKSkgfHwgbzsgfSwgdGFyZ2V0KTtcclxuICAgICAgICBjYXNlIDM6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXkpKSwgdm9pZCAwOyB9LCB2b2lkIDApO1xyXG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSwgbykpIHx8IG87IH0sIGRlc2MpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9kb20vZG9tX2FkYXB0ZXInKTtcclxudmFyIGFuZ3VsYXIyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vbG9jYXRpb25fc3RyYXRlZ3knKTtcclxuLyoqXHJcbiAqIGBIYXNoTG9jYXRpb25TdHJhdGVneWAgaXMgYSB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gdXNlZCB0byBjb25maWd1cmUgdGhlXHJcbiAqIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB0byByZXByZXNlbnQgaXRzIHN0YXRlIGluIHRoZVxyXG4gKiBbaGFzaCBmcmFnbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheClcclxuICogb2YgdGhlIGJyb3dzZXIncyBVUkwuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgaWYgeW91IGNhbGwgYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxyXG4gKiBgZXhhbXBsZS5jb20jL2Zvb2AuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50LCBWaWV3fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7XHJcbiAqICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAqICAgUk9VVEVSX1BST1ZJREVSUyxcclxuICogICBSb3V0ZUNvbmZpZyxcclxuICogICBMb2NhdGlvblxyXG4gKiB9IGZyb20gJ2FuZ3VsYXIyL3JvdXRlcic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe2RpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFU119KVxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgey4uLn0sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7XHJcbiAqICAgY29uc3RydWN0b3IobG9jYXRpb246IExvY2F0aW9uKSB7XHJcbiAqICAgICBsb2NhdGlvbi5nbygnL2ZvbycpO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBib290c3RyYXAoQXBwQ21wLCBbUk9VVEVSX1BST1ZJREVSU10pO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBIYXNoTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIYXNoTG9jYXRpb25TdHJhdGVneSgpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldExvY2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldEhpc3RvcnkoKTtcclxuICAgIH1cclxuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5ET00uZ2V0R2xvYmFsRXZlbnRUYXJnZXQoJ3dpbmRvdycpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZm4sIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfTtcclxuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHRoZSBoYXNoIHZhbHVlIGlzIGFsd2F5cyBwcmVmaXhlZCB3aXRoIGEgYCNgXHJcbiAgICAgICAgLy8gYW5kIGlmIGl0IGlzIGVtcHR5IHRoZW4gaXQgd2lsbCBzdGF5IGVtcHR5XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9sb2NhdGlvbi5oYXNoO1xyXG4gICAgICAgIC8vIERhcnQgd2lsbCBjb21wbGFpbiBpZiBhIGNhbGwgdG8gc3Vic3RyaW5nIGlzXHJcbiAgICAgICAgLy8gZXhlY3V0ZWQgd2l0aCBhIHBvc2l0aW9uIHZhbHVlIHRoYXQgZXh0ZW5kcyB0aGVcclxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nLlxyXG4gICAgICAgIHJldHVybiAocGF0aC5sZW5ndGggPiAwID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoKSArXHJcbiAgICAgICAgICAgIGxvY2F0aW9uX3N0cmF0ZWd5XzEubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fbG9jYXRpb24uc2VhcmNoKTtcclxuICAgIH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICB2YXIgdXJsID0gcGF0aCArIGxvY2F0aW9uX3N0cmF0ZWd5XzEubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGlmICh1cmwubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdXJsID0gdGhpcy5fbG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cmwgPSAnIycgKyB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcclxuICAgIH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5mb3J3YXJkKCk7IH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5iYWNrKCk7IH07XHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGFuZ3VsYXIyXzEuSW5qZWN0YWJsZSgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxyXG4gICAgXSwgSGFzaExvY2F0aW9uU3RyYXRlZ3kpO1xyXG4gICAgcmV0dXJuIEhhc2hMb2NhdGlvblN0cmF0ZWd5O1xyXG59KShsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3kpO1xyXG5leHBvcnRzLkhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hfbG9jYXRpb25fc3RyYXRlZ3kuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbi8qKlxyXG4gKiBgUm91dGVQYXJhbXNgIGlzIGFuIGltbXV0YWJsZSBtYXAgb2YgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIHJvdXRlXHJcbiAqIGJhc2VkIG9uIHRoZSB1cmwgbWF0Y2hlciBhbmQgb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhhdCByb3V0ZS5cclxuICpcclxuICogWW91IGNhbiBpbmplY3QgYFJvdXRlUGFyYW1zYCBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiBhIGNvbXBvbmVudCB0byB1c2UgaXQuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Ym9vdHN0cmFwLCBDb21wb25lbnR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtSb3V0ZXIsIFJPVVRFUl9ESVJFQ1RJVkVTLCBST1VURVJfUFJPVklERVJTLCBSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7ZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTXX0pXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICB7cGF0aDogJy91c2VyLzppZCcsIGNvbXBvbmVudDogVXNlckNtcCwgYXM6ICdVc2VyQ21wJ30sXHJcbiAqIF0pXHJcbiAqIGNsYXNzIEFwcENtcCB7fVxyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHsgdGVtcGxhdGU6ICd1c2VyOiB7e2lkfX0nIH0pXHJcbiAqIGNsYXNzIFVzZXJDbXAge1xyXG4gKiAgIHN0cmluZzogaWQ7XHJcbiAqICAgY29uc3RydWN0b3IocGFyYW1zOiBSb3V0ZVBhcmFtcykge1xyXG4gKiAgICAgdGhpcy5pZCA9IHBhcmFtcy5nZXQoJ2lkJyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFJPVVRFUl9QUk9WSURFUlMpO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBSb3V0ZVBhcmFtcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZVBhcmFtcyhwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIFJvdXRlUGFyYW1zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGxhbmdfMS5ub3JtYWxpemVCbGFuayhjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQodGhpcy5wYXJhbXMsIHBhcmFtKSk7IH07XHJcbiAgICByZXR1cm4gUm91dGVQYXJhbXM7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUm91dGVQYXJhbXMgPSBSb3V0ZVBhcmFtcztcclxuLyoqXHJcbiAqIGBJbnN0cnVjdGlvbmAgaXMgYSB0cmVlIG9mIHtAbGluayBDb21wb25lbnRJbnN0cnVjdGlvbn1zIHdpdGggYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWRcclxuICogdG8gdHJhbnNpdGlvbiBlYWNoIGNvbXBvbmVudCBpbiB0aGUgYXBwIHRvIGEgZ2l2ZW4gcm91dGUsIGluY2x1ZGluZyBhbGwgYXV4aWxpYXJ5IHJvdXRlcy5cclxuICpcclxuICogYEluc3RydWN0aW9uYHMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcge0BsaW5rIFJvdXRlciNnZW5lcmF0ZX0sIGFuZCBjYW4gYmUgdXNlZCB0b1xyXG4gKiBwZXJmb3JtIHJvdXRlIGNoYW5nZXMgd2l0aCB7QGxpbmsgUm91dGVyI25hdmlnYXRlQnlJbnN0cnVjdGlvbn0uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Ym9vdHN0cmFwLCBDb21wb25lbnR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtSb3V0ZXIsIFJPVVRFUl9ESVJFQ1RJVkVTLCBST1VURVJfUFJPVklERVJTLCBSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7ZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTXX0pXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICB7Li4ufSxcclxuICogXSlcclxuICogY2xhc3MgQXBwQ21wIHtcclxuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xyXG4gKiAgICAgdmFyIGluc3RydWN0aW9uID0gcm91dGVyLmdlbmVyYXRlKFsnL015Um91dGUnXSk7XHJcbiAqICAgICByb3V0ZXIubmF2aWdhdGVCeUluc3RydWN0aW9uKGluc3RydWN0aW9uKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogYm9vdHN0cmFwKEFwcENtcCwgUk9VVEVSX1BST1ZJREVSUyk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEluc3RydWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluc3RydWN0aW9uKGNvbXBvbmVudCwgY2hpbGQsIGF1eEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMuYXV4SW5zdHJ1Y3Rpb24gPSBhdXhJbnN0cnVjdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBpbnN0cnVjdGlvbiB0aGF0IHNoYXJlcyB0aGUgc3RhdGUgb2YgdGhlIGV4aXN0aW5nIGluc3RydWN0aW9uLCBidXQgd2l0aFxyXG4gICAgICogdGhlIGdpdmVuIGNoaWxkIHtAbGluayBJbnN0cnVjdGlvbn0gcmVwbGFjaW5nIHRoZSBleGlzdGluZyBjaGlsZC5cclxuICAgICAqL1xyXG4gICAgSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5zdHJ1Y3Rpb24odGhpcy5jb21wb25lbnQsIGNoaWxkLCB0aGlzLmF1eEluc3RydWN0aW9uKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5zdHJ1Y3Rpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuSW5zdHJ1Y3Rpb24gPSBJbnN0cnVjdGlvbjtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBwYXJ0aWFsbHkgY29tcGxldGVkIGluc3RydWN0aW9uIGR1cmluZyByZWNvZ25pdGlvbiB0aGF0IG9ubHkgaGFzIHRoZVxyXG4gKiBwcmltYXJ5IChub24tYXV4KSByb3V0ZSBpbnN0cnVjdGlvbnMgbWF0Y2hlZC5cclxuICpcclxuICogYFByaW1hcnlJbnN0cnVjdGlvbmAgaXMgYW4gaW50ZXJuYWwgY2xhc3MgdXNlZCBieSBgUm91dGVSZWNvZ25pemVyYCB3aGlsZSBpdCdzXHJcbiAqIGZpZ3VyaW5nIG91dCB3aGVyZSB0byBuYXZpZ2F0ZS5cclxuICovXHJcbnZhciBQcmltYXJ5SW5zdHJ1Y3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJpbWFyeUluc3RydWN0aW9uKGNvbXBvbmVudCwgY2hpbGQsIGF1eFVybHMpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgdGhpcy5hdXhVcmxzID0gYXV4VXJscztcclxuICAgIH1cclxuICAgIHJldHVybiBQcmltYXJ5SW5zdHJ1Y3Rpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuUHJpbWFyeUluc3RydWN0aW9uID0gUHJpbWFyeUluc3RydWN0aW9uO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xyXG4gICAgcmV0dXJuIHN0cmluZ2lmeUluc3RydWN0aW9uUGF0aChpbnN0cnVjdGlvbikgKyBzdHJpbmdpZnlJbnN0cnVjdGlvblF1ZXJ5KGluc3RydWN0aW9uKTtcclxufVxyXG5leHBvcnRzLnN0cmluZ2lmeUluc3RydWN0aW9uID0gc3RyaW5naWZ5SW5zdHJ1Y3Rpb247XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUluc3RydWN0aW9uUGF0aChpbnN0cnVjdGlvbikge1xyXG4gICAgcmV0dXJuIGluc3RydWN0aW9uLmNvbXBvbmVudC51cmxQYXRoICsgc3RyaW5naWZ5QXV4KGluc3RydWN0aW9uKSArXHJcbiAgICAgICAgc3RyaW5naWZ5UHJpbWFyeShpbnN0cnVjdGlvbi5jaGlsZCk7XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdpZnlJbnN0cnVjdGlvblBhdGggPSBzdHJpbmdpZnlJbnN0cnVjdGlvblBhdGg7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUluc3RydWN0aW9uUXVlcnkoaW5zdHJ1Y3Rpb24pIHtcclxuICAgIHJldHVybiBpbnN0cnVjdGlvbi5jb21wb25lbnQudXJsUGFyYW1zLmxlbmd0aCA+IDAgP1xyXG4gICAgICAgICgnPycgKyBpbnN0cnVjdGlvbi5jb21wb25lbnQudXJsUGFyYW1zLmpvaW4oJyYnKSkgOlxyXG4gICAgICAgICcnO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5naWZ5SW5zdHJ1Y3Rpb25RdWVyeSA9IHN0cmluZ2lmeUluc3RydWN0aW9uUXVlcnk7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVByaW1hcnkoaW5zdHJ1Y3Rpb24pIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnN0cnVjdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyYW1zID0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnVybFBhcmFtcy5sZW5ndGggPiAwID9cclxuICAgICAgICAoJzsnICsgaW5zdHJ1Y3Rpb24uY29tcG9uZW50LnVybFBhcmFtcy5qb2luKCc7JykpIDpcclxuICAgICAgICAnJztcclxuICAgIHJldHVybiAnLycgKyBpbnN0cnVjdGlvbi5jb21wb25lbnQudXJsUGF0aCArIHBhcmFtcyArIHN0cmluZ2lmeUF1eChpbnN0cnVjdGlvbikgK1xyXG4gICAgICAgIHN0cmluZ2lmeVByaW1hcnkoaW5zdHJ1Y3Rpb24uY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUF1eChpbnN0cnVjdGlvbikge1xyXG4gICAgdmFyIHJvdXRlcyA9IFtdO1xyXG4gICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChpbnN0cnVjdGlvbi5hdXhJbnN0cnVjdGlvbiwgZnVuY3Rpb24gKGF1eEluc3RydWN0aW9uLCBfKSB7XHJcbiAgICAgICAgcm91dGVzLnB1c2goc3RyaW5naWZ5UHJpbWFyeShhdXhJbnN0cnVjdGlvbikpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAocm91dGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gJygnICsgcm91dGVzLmpvaW4oJy8vJykgKyAnKSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuLyoqXHJcbiAqIEEgYENvbXBvbmVudEluc3RydWN0aW9uYCByZXByZXNlbnRzIHRoZSByb3V0ZSBzdGF0ZSBmb3IgYSBzaW5nbGUgY29tcG9uZW50LiBBbiBgSW5zdHJ1Y3Rpb25gIGlzXHJcbiAqIGNvbXBvc2VkIG9mIGEgdHJlZSBvZiB0aGVzZSBgQ29tcG9uZW50SW5zdHJ1Y3Rpb25gcy5cclxuICpcclxuICogYENvbXBvbmVudEluc3RydWN0aW9uc2AgaXMgYSBwdWJsaWMgQVBJLiBJbnN0YW5jZXMgb2YgYENvbXBvbmVudEluc3RydWN0aW9uYCBhcmUgcGFzc2VkXHJcbiAqIHRvIHJvdXRlIGxpZmVjeWNsZSBob29rcywgbGlrZSB7QGxpbmsgQ2FuQWN0aXZhdGV9LlxyXG4gKlxyXG4gKiBgQ29tcG9uZW50SW5zdHJ1Y3Rpb25gcyBhcmUgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhc2hfY29uc2luZ10oaGFzaCBjb25zZWQpLiBZb3Ugc2hvdWxkXHJcbiAqIG5ldmVyIGNvbnN0cnVjdCBvbmUgeW91cnNlbGYgd2l0aCBcIm5ldy5cIiBJbnN0ZWFkLCByZWx5IG9uIHtAbGluayBSb3V0ZXIvUGF0aFJlY29nbml6ZXJ9IHRvXHJcbiAqIGNvbnN0cnVjdCBgQ29tcG9uZW50SW5zdHJ1Y3Rpb25gcy5cclxuICpcclxuICogWW91IHNob3VsZCBub3QgbW9kaWZ5IHRoaXMgb2JqZWN0LiBJdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbW11dGFibGUuXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50SW5zdHJ1Y3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50SW5zdHJ1Y3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZXVzZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudEluc3RydWN0aW9uLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgdHlwZSBvZiB0aGUgcmVwcmVzZW50ZWQgcm91dGUsIG9yIGBudWxsYCBpZiB0aGlzIGluc3RydWN0aW9uXHJcbiAgICAgICAgICogaGFzbid0IGJlZW4gcmVzb2x2ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRJbnN0cnVjdGlvbi5wcm90b3R5cGUsIFwic3BlY2lmaWNpdHlcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSByb3V0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBgSW5zdHJ1Y3Rpb25gLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICA7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50SW5zdHJ1Y3Rpb24ucHJvdG90eXBlLCBcInRlcm1pbmFsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29tcG9uZW50IHR5cGUgb2YgdGhpcyBpbnN0cnVjdGlvbiBoYXMgbm8gY2hpbGQge0BsaW5rIFJvdXRlQ29uZmlnfSxcclxuICAgICAgICAgKiBvciBgZmFsc2VgIGlmIGl0IGRvZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIDtcclxuICAgIHJldHVybiBDb21wb25lbnRJbnN0cnVjdGlvbjtcclxufSkoKTtcclxuZXhwb3J0cy5Db21wb25lbnRJbnN0cnVjdGlvbiA9IENvbXBvbmVudEluc3RydWN0aW9uO1xyXG52YXIgQ29tcG9uZW50SW5zdHJ1Y3Rpb25fID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRJbnN0cnVjdGlvbl8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnRJbnN0cnVjdGlvbl8odXJsUGF0aCwgdXJsUGFyYW1zLCBfcmVjb2duaXplciwgcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IG51bGw7IH1cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yZWNvZ25pemVyID0gX3JlY29nbml6ZXI7XHJcbiAgICAgICAgdGhpcy51cmxQYXRoID0gdXJsUGF0aDtcclxuICAgICAgICB0aGlzLnVybFBhcmFtcyA9IHVybFBhcmFtcztcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRJbnN0cnVjdGlvbl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVjb2duaXplci5oYW5kbGVyLmNvbXBvbmVudFR5cGU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ29tcG9uZW50SW5zdHJ1Y3Rpb25fLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlY29nbml6ZXIuaGFuZGxlci5yZXNvbHZlQ29tcG9uZW50VHlwZSgpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudEluc3RydWN0aW9uXy5wcm90b3R5cGUsIFwic3BlY2lmaWNpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVjb2duaXplci5zcGVjaWZpY2l0eTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50SW5zdHJ1Y3Rpb25fLnByb3RvdHlwZSwgXCJ0ZXJtaW5hbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWNvZ25pemVyLnRlcm1pbmFsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvbXBvbmVudEluc3RydWN0aW9uXy5wcm90b3R5cGUucm91dGVEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVjb2duaXplci5oYW5kbGVyLmRhdGE7IH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50SW5zdHJ1Y3Rpb25fO1xyXG59KShDb21wb25lbnRJbnN0cnVjdGlvbik7XHJcbmV4cG9ydHMuQ29tcG9uZW50SW5zdHJ1Y3Rpb25fID0gQ29tcG9uZW50SW5zdHJ1Y3Rpb25fO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0cnVjdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIFRoaXMgaW5kaXJlY3Rpb24gaXMgbmVlZGVkIHRvIGZyZWUgdXAgQ29tcG9uZW50LCBldGMgc3ltYm9scyBpbiB0aGUgcHVibGljIEFQSVxyXG4gKiB0byBiZSB1c2VkIGJ5IHRoZSBkZWNvcmF0b3IgdmVyc2lvbnMgb2YgdGhlc2UgYW5ub3RhdGlvbnMuXHJcbiAqL1xyXG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvdXRpbC9kZWNvcmF0b3JzJyk7XHJcbnZhciBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8xID0gcmVxdWlyZSgnLi9saWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbCcpO1xyXG52YXIgbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMiA9IHJlcXVpcmUoJy4vbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGwnKTtcclxuZXhwb3J0cy5jYW5SZXVzZSA9IGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzIuY2FuUmV1c2U7XHJcbmV4cG9ydHMuY2FuRGVhY3RpdmF0ZSA9IGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzIuY2FuRGVhY3RpdmF0ZTtcclxuZXhwb3J0cy5vbkFjdGl2YXRlID0gbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMi5vbkFjdGl2YXRlO1xyXG5leHBvcnRzLm9uUmV1c2UgPSBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8yLm9uUmV1c2U7XHJcbmV4cG9ydHMub25EZWFjdGl2YXRlID0gbGlmZWN5Y2xlX2Fubm90YXRpb25zX2ltcGxfMi5vbkRlYWN0aXZhdGU7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIHJvdXRlIGxpZmVjeWNsZSBob29rIGBDYW5BY3RpdmF0ZWAsIHdoaWNoIGlzIGNhbGxlZCBieSB0aGUgcm91dGVyIHRvIGRldGVybWluZVxyXG4gKiBpZiBhIGNvbXBvbmVudCBjYW4gYmUgaW5zdGFudGlhdGVkIGFzIHBhcnQgb2YgYSBuYXZpZ2F0aW9uLlxyXG4gKlxyXG4gKiBUaGUgYENhbkFjdGl2YXRlYCBob29rIGlzIGNhbGxlZCB3aXRoIHR3byB7QGxpbmsgQ29tcG9uZW50SW5zdHJ1Y3Rpb259cyBhcyBwYXJhbWV0ZXJzLCB0aGUgZmlyc3RcclxuICogcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBjdXJyZW50IHJvdXRlIGJlaW5nIG5hdmlnYXRlZCB0bywgYW5kIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgcm91dGUgb3JcclxuICogYG51bGxgLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdW5saWtlIG90aGVyIGxpZmVjeWNsZSBob29rcywgdGhpcyBvbmUgdXNlcyBhbiBhbm5vdGF0aW9uIHJhdGhlciB0aGFuIGFuIGludGVyZmFjZS5cclxuICogVGhpcyBpcyBiZWNhdXNlIHRoZSBgQ2FuQWN0aXZhdGVgIGZ1bmN0aW9uIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQuXHJcbiAqXHJcbiAqIElmIGBDYW5BY3RpdmF0ZWAgcmV0dXJucyBvciByZXNvbHZlcyB0byBgZmFsc2VgLCB0aGUgbmF2aWdhdGlvbiBpcyBjYW5jZWxsZWQuXHJcbiAqIElmIGBDYW5BY3RpdmF0ZWAgdGhyb3dzIG9yIHJlamVjdHMsIHRoZSBuYXZpZ2F0aW9uIGlzIGFsc28gY2FuY2VsbGVkLlxyXG4gKiBJZiBgQ2FuQWN0aXZhdGVgIHJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYHRydWVgLCBuYXZpZ2F0aW9uIGNvbnRpbnVlcywgdGhlIGNvbXBvbmVudCBpc1xyXG4gKiBpbnN0YW50aWF0ZWQsIGFuZCB0aGUge0BsaW5rIE9uQWN0aXZhdGV9IGhvb2sgb2YgdGhhdCBjb21wb25lbnQgaXMgY2FsbGVkIGlmIGltcGxlbWVudGVkLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge0NhbkFjdGl2YXRlfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2NvbnRyb2wtcGFuZWwtY21wJyxcclxuICogICB0ZW1wbGF0ZTogJzxkaXY+Q29udHJvbCBQYW5lbDogLi4uPC9kaXY+J1xyXG4gKiB9KVxyXG4gKiBAQ2FuQWN0aXZhdGUoKCkgPT4gY2hlY2tJZlVzZXJJc0xvZ2dlZEluKCkpXHJcbiAqIGNsYXNzIENvbnRyb2xQYW5lbENtcCB7XHJcbiAqICAgLy8gLi4uXHJcbiAqIH1cclxuICogIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5DYW5BY3RpdmF0ZSA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKGxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsXzEuQ2FuQWN0aXZhdGUpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlY3ljbGVfYW5ub3RhdGlvbnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgUm91dGVMaWZlY3ljbGVIb29rID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlTGlmZWN5Y2xlSG9vayhuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIH1cclxuICAgIFJvdXRlTGlmZWN5Y2xlSG9vayA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxyXG4gICAgXSwgUm91dGVMaWZlY3ljbGVIb29rKTtcclxuICAgIHJldHVybiBSb3V0ZUxpZmVjeWNsZUhvb2s7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUm91dGVMaWZlY3ljbGVIb29rID0gUm91dGVMaWZlY3ljbGVIb29rO1xyXG52YXIgQ2FuQWN0aXZhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FuQWN0aXZhdGUoZm4pIHtcclxuICAgICAgICB0aGlzLmZuID0gZm47XHJcbiAgICB9XHJcbiAgICBDYW5BY3RpdmF0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtGdW5jdGlvbl0pXHJcbiAgICBdLCBDYW5BY3RpdmF0ZSk7XHJcbiAgICByZXR1cm4gQ2FuQWN0aXZhdGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2FuQWN0aXZhdGUgPSBDYW5BY3RpdmF0ZTtcclxuZXhwb3J0cy5jYW5SZXVzZSA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBSb3V0ZUxpZmVjeWNsZUhvb2soXCJjYW5SZXVzZVwiKSk7XHJcbmV4cG9ydHMuY2FuRGVhY3RpdmF0ZSA9IGxhbmdfMS5DT05TVF9FWFBSKG5ldyBSb3V0ZUxpZmVjeWNsZUhvb2soXCJjYW5EZWFjdGl2YXRlXCIpKTtcclxuZXhwb3J0cy5vbkFjdGl2YXRlID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IFJvdXRlTGlmZWN5Y2xlSG9vayhcIm9uQWN0aXZhdGVcIikpO1xyXG5leHBvcnRzLm9uUmV1c2UgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgUm91dGVMaWZlY3ljbGVIb29rKFwib25SZXVzZVwiKSk7XHJcbmV4cG9ydHMub25EZWFjdGl2YXRlID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IFJvdXRlTGlmZWN5Y2xlSG9vayhcIm9uRGVhY3RpdmF0ZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZmVjeWNsZV9hbm5vdGF0aW9uc19pbXBsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBsb2NhdGlvbl9zdHJhdGVneV8xID0gcmVxdWlyZSgnLi9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIGxhbmdfMiA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgYW5ndWxhcjJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbi8qKlxyXG4gKiBUaGUgYEFQUF9CQVNFX0hSRUZgIHRva2VuIHJlcHJlc2VudHMgdGhlIGJhc2UgaHJlZiB0byBiZSB1c2VkIHdpdGggdGhlXHJcbiAqIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0uXHJcbiAqXHJcbiAqIElmIHlvdSdyZSB1c2luZyB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LCB5b3UgbXVzdCBwcm92aWRlIGEgcHJvdmlkZXIgdG8gYSBzdHJpbmdcclxuICogcmVwcmVzZW50aW5nIHRoZSBVUkwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nXHJcbiAqIFVSTHMuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdhbmd1bGFyMi9hbmd1bGFyMic7XHJcbiAqIGltcG9ydCB7Uk9VVEVSX0RJUkVDVElWRVMsIFJPVVRFUl9QUk9WSURFUlMsIFJvdXRlQ29uZmlnfSBmcm9tICdhbmd1bGFyMi9yb3V0ZXInO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogIHsuLi59LFxyXG4gKiBdKVxyXG4gKiBjbGFzcyBBcHBDbXAge1xyXG4gKiAgIC8vIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtcclxuICogICBST1VURVJfUFJPVklERVJTLFxyXG4gKiAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LFxyXG4gKiAgIHByb3ZpZGUoQVBQX0JBU0VfSFJFRiwge3VzZVZhbHVlOiAnL215L2FwcCd9KVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLkFQUF9CQVNFX0hSRUYgPSBsYW5nXzEuQ09OU1RfRVhQUihuZXcgYW5ndWxhcjJfMS5PcGFxdWVUb2tlbignYXBwQmFzZUhyZWYnKSk7XHJcbi8qKlxyXG4gKiBgTG9jYXRpb25gIGlzIGEgc2VydmljZSB0aGF0IGFwcGxpY2F0aW9ucyBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggYSBicm93c2VyJ3MgVVJMLlxyXG4gKiBEZXBlbmRpbmcgb24gd2hpY2gge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGlzIHVzZWQsIGBMb2NhdGlvbmAgd2lsbCBlaXRoZXIgcGVyc2lzdFxyXG4gKiB0byB0aGUgVVJMJ3MgcGF0aCBvciB0aGUgVVJMJ3MgaGFzaCBzZWdtZW50LlxyXG4gKlxyXG4gKiBOb3RlOiBpdCdzIGJldHRlciB0byB1c2Uge0BsaW5rIFJvdXRlciNuYXZpZ2F0ZX0gc2VydmljZSB0byB0cmlnZ2VyIHJvdXRlIGNoYW5nZXMuIFVzZVxyXG4gKiBgTG9jYXRpb25gIG9ubHkgaWYgeW91IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aCBvciBjcmVhdGUgbm9ybWFsaXplZCBVUkxzIG91dHNpZGUgb2ZcclxuICogcm91dGluZy5cclxuICpcclxuICogYExvY2F0aW9uYCBpcyByZXNwb25zaWJsZSBmb3Igbm9ybWFsaXppbmcgdGhlIFVSTCBhZ2FpbnN0IHRoZSBhcHBsaWNhdGlvbidzIGJhc2UgaHJlZi5cclxuICogQSBub3JtYWxpemVkIFVSTCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSBVUkwgaG9zdCwgaW5jbHVkZXMgdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmLCBhbmQgaGFzIG5vXHJcbiAqIHRyYWlsaW5nIHNsYXNoOlxyXG4gKiAtIGAvbXkvYXBwL3VzZXIvMTIzYCBpcyBub3JtYWxpemVkXHJcbiAqIC0gYG15L2FwcC91c2VyLzEyM2AgKippcyBub3QqKiBub3JtYWxpemVkXHJcbiAqIC0gYC9teS9hcHAvdXNlci8xMjMvYCAqKmlzIG5vdCoqIG5vcm1hbGl6ZWRcclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ2FuZ3VsYXIyL2FuZ3VsYXIyJztcclxuICogaW1wb3J0IHtcclxuICogICBST1VURVJfRElSRUNUSVZFUyxcclxuICogICBST1VURVJfUFJPVklERVJTLFxyXG4gKiAgIFJvdXRlQ29uZmlnLFxyXG4gKiAgIExvY2F0aW9uXHJcbiAqIH0gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7ZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTXX0pXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICB7Li4ufSxcclxuICogXSlcclxuICogY2xhc3MgQXBwQ21wIHtcclxuICogICBjb25zdHJ1Y3Rvcihsb2NhdGlvbjogTG9jYXRpb24pIHtcclxuICogICAgIGxvY2F0aW9uLmdvKCcvZm9vJyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtST1VURVJfUFJPVklERVJTXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIExvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvY2F0aW9uKHBsYXRmb3JtU3RyYXRlZ3ksIGhyZWYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm1TdHJhdGVneSA9IHBsYXRmb3JtU3RyYXRlZ3k7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB2YXIgYnJvd3NlckJhc2VIcmVmID0gbGFuZ18xLmlzUHJlc2VudChocmVmKSA/IGhyZWYgOiB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kuZ2V0QmFzZUhyZWYoKTtcclxuICAgICAgICBpZiAobGFuZ18yLmlzQmxhbmsoYnJvd3NlckJhc2VIcmVmKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBiYXNlIGhyZWYgc2V0LiBFaXRoZXIgcHJvdmlkZSBhIHByb3ZpZGVyIGZvciB0aGUgQVBQX0JBU0VfSFJFRiB0b2tlbiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBzdHJpcFRyYWlsaW5nU2xhc2goc3RyaXBJbmRleEh0bWwoYnJvd3NlckJhc2VIcmVmKSk7XHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybVN0cmF0ZWd5Lm9uUG9wU3RhdGUoZnVuY3Rpb24gKF8pIHsgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dChfdGhpcy5fc3ViamVjdCwgeyAndXJsJzogX3RoaXMucGF0aCgpLCAncG9wJzogdHJ1ZSB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGguXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub3JtYWxpemUodGhpcy5wbGF0Zm9ybVN0cmF0ZWd5LnBhdGgoKSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgcGF0aC5cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICByZXR1cm4gc3RyaXBUcmFpbGluZ1NsYXNoKF9zdHJpcEJhc2VIcmVmKHRoaXMuX2Jhc2VIcmVmLCBzdHJpcEluZGV4SHRtbCh1cmwpKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGguXHJcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gVVJMIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIGxlYWRpbmcgc2xhc2ggKGAnLydgKSwgdGhpcyBtZXRob2QgYWRkcyBvbmVcclxuICAgICAqIGJlZm9yZSBub3JtYWxpemluZy5cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLm5vcm1hbGl6ZUFic29sdXRlbHkgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIHVybCA9ICcvJyArIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmlwVHJhaWxpbmdTbGFzaChfYWRkQmFzZUhyZWYodGhpcy5fYmFzZUhyZWYsIHVybCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHB1c2hlcyBhXHJcbiAgICAgKiBuZXcgaXRlbSBvbnRvIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cclxuICAgICAgICB2YXIgYWJzb2x1dGVQYXRoID0gdGhpcy5ub3JtYWxpemVBYnNvbHV0ZWx5KHBhdGgpO1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm1TdHJhdGVneS5wdXNoU3RhdGUobnVsbCwgJycsIGFic29sdXRlUGF0aCwgcXVlcnkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTmF2aWdhdGVzIGZvcndhcmQgaW4gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucGxhdGZvcm1TdHJhdGVneS5mb3J3YXJkKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyBiYWNrIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kuYmFjaygpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIHBsYXRmb3JtJ3MgYHBvcFN0YXRlYCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob25OZXh0LCBvblRocm93LCBvblJldHVybikge1xyXG4gICAgICAgIGlmIChvblRocm93ID09PSB2b2lkIDApIHsgb25UaHJvdyA9IG51bGw7IH1cclxuICAgICAgICBpZiAob25SZXR1cm4gPT09IHZvaWQgMCkgeyBvblJldHVybiA9IG51bGw7IH1cclxuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZSh0aGlzLl9zdWJqZWN0LCBvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKTtcclxuICAgIH07XHJcbiAgICBMb2NhdGlvbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGFuZ3VsYXIyXzEuSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgYW5ndWxhcjJfMS5PcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDEsIGFuZ3VsYXIyXzEuSW5qZWN0KGV4cG9ydHMuQVBQX0JBU0VfSFJFRikpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3ksIFN0cmluZ10pXHJcbiAgICBdLCBMb2NhdGlvbik7XHJcbiAgICByZXR1cm4gTG9jYXRpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbjtcclxuZnVuY3Rpb24gX3N0cmlwQmFzZUhyZWYoYmFzZUhyZWYsIHVybCkge1xyXG4gICAgaWYgKGJhc2VIcmVmLmxlbmd0aCA+IDAgJiYgdXJsLnN0YXJ0c1dpdGgoYmFzZUhyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoYmFzZUhyZWYubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuZnVuY3Rpb24gX2FkZEJhc2VIcmVmKGJhc2VIcmVmLCB1cmwpIHtcclxuICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoYmFzZUhyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VIcmVmICsgdXJsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5mdW5jdGlvbiBzdHJpcEluZGV4SHRtbCh1cmwpIHtcclxuICAgIGlmICgvXFwvaW5kZXguaHRtbCQvZy50ZXN0KHVybCkpIHtcclxuICAgICAgICAvLyAnL2luZGV4Lmh0bWwnLmxlbmd0aCA9PSAxMVxyXG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaCh1cmwpIHtcclxuICAgIGlmICgvXFwvJC9nLnRlc3QodXJsKSkge1xyXG4gICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7LyoqXHJcbiAqIGBMb2NhdGlvblN0cmF0ZWd5YCBpcyByZXNwb25zaWJsZSBmb3IgcmVwcmVzZW50aW5nIGFuZCByZWFkaW5nIHJvdXRlIHN0YXRlXHJcbiAqIGZyb20gdGhlIHRoZSBicm93c2VyJ3MgVVJMLiBBbmd1bGFyIHByb3ZpZGVzIHR3byBzdHJhdGVnaWVzOlxyXG4gKiB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IChkZWZhdWx0KSBhbmQge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fS5cclxuICpcclxuICogVGhpcyBpcyB1c2VkIHVuZGVyIHRoZSBob29kIG9mIHRoZSB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UuXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBzaG91bGQgdXNlIHRoZSB7QGxpbmsgUm91dGVyfSBvciB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2VzIHRvXHJcbiAqIGludGVyYWN0IHdpdGggYXBwbGljYXRpb24gcm91dGUgc3RhdGUuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwge0BsaW5rIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBwcm9kdWNlcyBVUkxzIGxpa2VcclxuICogYGh0dHA6Ly9leGFtcGxlLmNvbSMvZm9vYCwgYW5kIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0gcHJvZHVjZXNcclxuICogYGh0dHA6Ly9leGFtcGxlLmNvbS9mb29gIGFzIGFuIGVxdWl2YWxlbnQgVVJMLlxyXG4gKlxyXG4gKiBTZWUgdGhlc2UgdHdvIGNsYXNzZXMgZm9yIG1vcmUuXHJcbiAqL1xyXG52YXIgTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2NhdGlvblN0cmF0ZWd5KCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExvY2F0aW9uU3RyYXRlZ3k7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9jYXRpb25TdHJhdGVneSA9IExvY2F0aW9uU3RyYXRlZ3k7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHBhcmFtcykge1xyXG4gICAgcmV0dXJuIChwYXJhbXMubGVuZ3RoID4gMCAmJiBwYXJhbXMuc3Vic3RyaW5nKDAsIDEpICE9ICc/JykgPyAoJz8nICsgcGFyYW1zKSA6IHBhcmFtcztcclxufVxyXG5leHBvcnRzLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zID0gbm9ybWFsaXplUXVlcnlQYXJhbXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uX3N0cmF0ZWd5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2RvbS9kb21fYWRhcHRlcicpO1xyXG52YXIgYW5ndWxhcjJfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL2FuZ3VsYXIyJyk7XHJcbnZhciBsb2NhdGlvbl9zdHJhdGVneV8xID0gcmVxdWlyZSgnLi9sb2NhdGlvbl9zdHJhdGVneScpO1xyXG4vKipcclxuICogYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcclxuICoge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlIHRvIHJlcHJlc2VudCBpdHMgc3RhdGUgaW4gdGhlXHJcbiAqIFtwYXRoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbmlmb3JtX1Jlc291cmNlX0xvY2F0b3IjU3ludGF4KSBvZiB0aGVcclxuICogYnJvd3NlcidzIFVSTC5cclxuICpcclxuICogYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyB0aGUgZGVmYXVsdCBiaW5kaW5nIGZvciB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX1cclxuICogcHJvdmlkZWQgaW4ge0BsaW5rIFJPVVRFUl9QUk9WSURFUlN9LlxyXG4gKlxyXG4gKiBJZiB5b3UncmUgdXNpbmcgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCwgeW91IG11c3QgcHJvdmlkZSBhIHByb3ZpZGVyIGZvclxyXG4gKiB7QGxpbmsgQVBQX0JBU0VfSFJFRn0gdG8gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBVUkwgcHJlZml4IHRoYXQgc2hvdWxkXHJcbiAqIGJlIHByZXNlcnZlZCB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nIFVSTHMuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgaWYgeW91IHByb3ZpZGUgYW4gYEFQUF9CQVNFX0hSRUZgIG9mIGAnL215L2FwcCdgIGFuZCBjYWxsXHJcbiAqIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcclxuICogYGV4YW1wbGUuY29tL215L2FwcC9mb29gLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgcHJvdmlkZX0gZnJvbSAnYW5ndWxhcjIvYW5ndWxhcjInO1xyXG4gKiBpbXBvcnQge1xyXG4gKiAgIEFQUF9CQVNFX0hSRUZcclxuICogICBST1VURVJfRElSRUNUSVZFUyxcclxuICogICBST1VURVJfUFJPVklERVJTLFxyXG4gKiAgIFJvdXRlQ29uZmlnLFxyXG4gKiAgIExvY2F0aW9uXHJcbiAqIH0gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQENvbXBvbmVudCh7ZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTXX0pXHJcbiAqIEBSb3V0ZUNvbmZpZyhbXHJcbiAqICB7Li4ufSxcclxuICogXSlcclxuICogY2xhc3MgQXBwQ21wIHtcclxuICogICBjb25zdHJ1Y3Rvcihsb2NhdGlvbjogTG9jYXRpb24pIHtcclxuICogICAgIGxvY2F0aW9uLmdvKCcvZm9vJyk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGJvb3RzdHJhcChBcHBDbXAsIFtcclxuICogICBST1VURVJfUFJPVklERVJTLCAvLyBpbmNsdWRlcyBiaW5kaW5nIHRvIFBhdGhMb2NhdGlvblN0cmF0ZWd5XHJcbiAqICAgcHJvdmlkZShBUFBfQkFTRV9IUkVGLCB7dXNlVmFsdWU6ICcvbXkvYXBwJ30pXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICovXHJcbnZhciBQYXRoTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGF0aExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYXRoTG9jYXRpb25TdHJhdGVneSgpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldExvY2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldEhpc3RvcnkoKTtcclxuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IGRvbV9hZGFwdGVyXzEuRE9NLmdldEJhc2VIcmVmKCk7XHJcbiAgICB9XHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGRvbV9hZGFwdGVyXzEuRE9NLmdldEdsb2JhbEV2ZW50VGFyZ2V0KCd3aW5kb3cnKS5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZuLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYmFzZUhyZWY7IH07XHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb25fc3RyYXRlZ3lfMS5ub3JtYWxpemVRdWVyeVBhcmFtcyh0aGlzLl9sb2NhdGlvbi5zZWFyY2gpOyB9O1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsICh1cmwgKyBsb2NhdGlvbl9zdHJhdGVneV8xLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSkpO1xyXG4gICAgfTtcclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oaXN0b3J5LmZvcndhcmQoKTsgfTtcclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oaXN0b3J5LmJhY2soKTsgfTtcclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgYW5ndWxhcjJfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBQYXRoTG9jYXRpb25TdHJhdGVneSk7XHJcbiAgICByZXR1cm4gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XHJcbn0pKGxvY2F0aW9uX3N0cmF0ZWd5XzEuTG9jYXRpb25TdHJhdGVneSk7XHJcbmV4cG9ydHMuUGF0aExvY2F0aW9uU3RyYXRlZ3kgPSBQYXRoTG9jYXRpb25TdHJhdGVneTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aF9sb2NhdGlvbl9zdHJhdGVneS5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIHVybF9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vdXJsX3BhcnNlcicpO1xyXG52YXIgaW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoJy4vaW5zdHJ1Y3Rpb24nKTtcclxudmFyIFRvdWNoTWFwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvdWNoTWFwKG1hcCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcclxuICAgICAgICB0aGlzLmtleXMgPSB7fTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXApKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gobWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubWFwW2tleV0gPSBsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMua2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVG91Y2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5kZWxldGUodGhpcy5rZXlzLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xyXG4gICAgfTtcclxuICAgIFRvdWNoTWFwLnByb3RvdHlwZS5nZXRVbnVzZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW51c2VkID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGtleXMgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5rZXlzKHRoaXMua2V5cyk7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHVudXNlZFtrZXldID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KF90aGlzLm1hcCwga2V5KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVudXNlZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVG91Y2hNYXA7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZyhvYmopIHtcclxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxudmFyIENvbnRpbnVhdGlvblNlZ21lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29udGludWF0aW9uU2VnbWVudCgpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIH1cclxuICAgIENvbnRpbnVhdGlvblNlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gJyc7IH07XHJcbiAgICBDb250aW51YXRpb25TZWdtZW50LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgcmV0dXJuIENvbnRpbnVhdGlvblNlZ21lbnQ7XHJcbn0pKCk7XHJcbnZhciBTdGF0aWNTZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXRpY1NlZ21lbnQocGF0aCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICB9XHJcbiAgICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoID09IHRoaXMucGF0aDsgfTtcclxuICAgIFN0YXRpY1NlZ21lbnQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gdGhpcy5wYXRoOyB9O1xyXG4gICAgcmV0dXJuIFN0YXRpY1NlZ21lbnQ7XHJcbn0pKCk7XHJcbnZhciBEeW5hbWljU2VnbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEeW5hbWljU2VnbWVudChuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIH1cclxuICAgIER5bmFtaWNTZWdtZW50LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoLmxlbmd0aCA+IDA7IH07XHJcbiAgICBEeW5hbWljU2VnbWVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhwYXJhbXMubWFwLCB0aGlzLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlJvdXRlIGdlbmVyYXRvciBmb3IgJ1wiICsgdGhpcy5uYW1lICsgXCInIHdhcyBub3QgaW5jbHVkZWQgaW4gcGFyYW1ldGVycyBwYXNzZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU3RyaW5nKHBhcmFtcy5nZXQodGhpcy5uYW1lKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIER5bmFtaWNTZWdtZW50O1xyXG59KSgpO1xyXG52YXIgU3RhclNlZ21lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RhclNlZ21lbnQobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgICBTdGFyU2VnbWVudC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIFN0YXJTZWdtZW50LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZyhwYXJhbXMuZ2V0KHRoaXMubmFtZSkpOyB9O1xyXG4gICAgcmV0dXJuIFN0YXJTZWdtZW50O1xyXG59KSgpO1xyXG52YXIgcGFyYW1NYXRjaGVyID0gL146KFteXFwvXSspJC9nO1xyXG52YXIgd2lsZGNhcmRNYXRjaGVyID0gL15cXCooW15cXC9dKykkL2c7XHJcbmZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyhyb3V0ZSkge1xyXG4gICAgLy8gbm9ybWFsaXplIHJvdXRlIGFzIG5vdCBzdGFydGluZyB3aXRoIGEgXCIvXCIuIFJlY29nbml0aW9uIHdpbGxcclxuICAgIC8vIGFsc28gbm9ybWFsaXplLlxyXG4gICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGgocm91dGUsIFwiL1wiKSkge1xyXG4gICAgICAgIHJvdXRlID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3Vic3RyaW5nKHJvdXRlLCAxKTtcclxuICAgIH1cclxuICAgIHZhciBzZWdtZW50cyA9IHNwbGl0QnlTbGFzaChyb3V0ZSk7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgdmFyIHNwZWNpZmljaXR5ID0gMDtcclxuICAgIC8vIFRoZSBcInNwZWNpZmljaXR5XCIgb2YgYSBwYXRoIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvdXRlIGlzIHVzZWQgd2hlbiBtdWx0aXBsZSByb3V0ZXMgbWF0Y2hcclxuICAgIC8vIGEgVVJMLlxyXG4gICAgLy8gU3RhdGljIHNlZ21lbnRzIChsaWtlIFwiL2Zvb1wiKSBhcmUgdGhlIG1vc3Qgc3BlY2lmaWMsIGZvbGxvd2VkIGJ5IGR5bmFtaWMgc2VnbWVudHMgKGxpa2VcclxuICAgIC8vIFwiLzppZFwiKS4gU3RhciBzZWdtZW50c1xyXG4gICAgLy8gYWRkIG5vIHNwZWNpZmljaXR5LiBTZWdtZW50cyBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhdGggYXJlIG1vcmUgc3BlY2lmaWMgdGhhbiBwcm9jZWVkaW5nIG9uZXMuXHJcbiAgICAvLyBUaGUgY29kZSBiZWxvdyB1c2VzIHBsYWNlIHZhbHVlcyB0byBjb21iaW5lIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VnbWVudHMgaW50byBhIHNpbmdsZVxyXG4gICAgLy8gaW50ZWdlciB0aGF0IHdlIGNhblxyXG4gICAgLy8gc29ydCBsYXRlci4gRWFjaCBzdGF0aWMgc2VnbWVudCBpcyB3b3J0aCBodW5kcmVkcyBvZiBwb2ludHMgb2Ygc3BlY2lmaWNpdHkgKDEwMDAwLCA5OTAwLCAuLi4sXHJcbiAgICAvLyAyMDApLCBhbmQgZWFjaFxyXG4gICAgLy8gZHluYW1pYyBzZWdtZW50IGlzIHdvcnRoIHNpbmdsZSBwb2ludHMgb2Ygc3BlY2lmaWNpdHkgKDEwMCwgOTksIC4uLiAyKS5cclxuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiA5OCkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIidcIiArIHJvdXRlICsgXCInIGhhcyBtb3JlIHRoYW4gdGhlIG1heGltdW0gc3VwcG9ydGVkIG51bWJlciBvZiBzZWdtZW50cy5cIik7XHJcbiAgICB9XHJcbiAgICB2YXIgbGltaXQgPSBzZWdtZW50cy5sZW5ndGggLSAxO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGltaXQ7IGkrKykge1xyXG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sIG1hdGNoO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChwYXJhbU1hdGNoZXIsIHNlZ21lbnQpKSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IER5bmFtaWNTZWdtZW50KG1hdGNoWzFdKSk7XHJcbiAgICAgICAgICAgIHNwZWNpZmljaXR5ICs9ICgxMDAgLSBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2god2lsZGNhcmRNYXRjaGVyLCBzZWdtZW50KSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGFyU2VnbWVudChtYXRjaFsxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWdtZW50ID09ICcuLi4nKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgbGltaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gKG1hdHNrbyk6IHNldHVwIGEgcHJvcGVyIGVycm9yIGhlcmUgYFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5leHBlY3RlZCBcXFwiLi4uXFxcIiBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcGF0aCBmb3IgXFxcIlwiICsgcm91dGUgKyBcIlxcXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQ29udGludWF0aW9uU2VnbWVudCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgU3RhdGljU2VnbWVudChzZWdtZW50KSk7XHJcbiAgICAgICAgICAgIHNwZWNpZmljaXR5ICs9IDEwMCAqICgxMDAgLSBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY3JlYXRlKCk7XHJcbiAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQocmVzdWx0LCAnc2VnbWVudHMnLCByZXN1bHRzKTtcclxuICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldChyZXN1bHQsICdzcGVjaWZpY2l0eScsIHNwZWNpZmljaXR5KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcm91dGUgY29uZmlnIHBhdGggbGlrZSBgL2Zvby86aWRgIGNvbGxpZGVzIHdpdGhcclxuLy8gYC9mb28vOm5hbWVgXHJcbmZ1bmN0aW9uIHBhdGhEc2xIYXNoKHNlZ21lbnRzKSB7XHJcbiAgICByZXR1cm4gc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBTdGFyU2VnbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWdtZW50IGluc3RhbmNlb2YgQ29udGludWF0aW9uU2VnbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4uLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBEeW5hbWljU2VnbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzonO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWdtZW50IGluc3RhbmNlb2YgU3RhdGljU2VnbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICAgICAgLmpvaW4oJy8nKTtcclxufVxyXG5mdW5jdGlvbiBzcGxpdEJ5U2xhc2godXJsKSB7XHJcbiAgICByZXR1cm4gdXJsLnNwbGl0KCcvJyk7XHJcbn1cclxudmFyIFJFU0VSVkVEX0NIQVJTID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCcvL3xcXFxcKHxcXFxcKXw7fFxcXFw/fD0nKTtcclxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XHJcbiAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnMocGF0aCwgJyMnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiBzaG91bGQgbm90IGluY2x1ZGUgXFxcIiNcXFwiLiBVc2UgXFxcIkhhc2hMb2NhdGlvblN0cmF0ZWd5XFxcIiBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuICAgIHZhciBpbGxlZ2FsQ2hhcmFjdGVyID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChSRVNFUlZFRF9DSEFSUywgcGF0aCk7XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbGxlZ2FsQ2hhcmFjdGVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiBjb250YWlucyBcXFwiXCIgKyBpbGxlZ2FsQ2hhcmFjdGVyWzBdICsgXCJcXFwiIHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluIGEgcm91dGUgY29uZmlnLlwiKTtcclxuICAgIH1cclxufVxyXG52YXIgUGF0aE1hdGNoID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhdGhNYXRjaChpbnN0cnVjdGlvbiwgcmVtYWluaW5nLCByZW1haW5pbmdBdXgpIHtcclxuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgdGhpcy5yZW1haW5pbmcgPSByZW1haW5pbmc7XHJcbiAgICAgICAgdGhpcy5yZW1haW5pbmdBdXggPSByZW1haW5pbmdBdXg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGF0aE1hdGNoO1xyXG59KSgpO1xyXG5leHBvcnRzLlBhdGhNYXRjaCA9IFBhdGhNYXRjaDtcclxuLy8gcmVwcmVzZW50cyBzb21ldGhpbmcgbGlrZSAnL2Zvby86YmFyJ1xyXG52YXIgUGF0aFJlY29nbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVE9ETzogY2FjaGUgY29tcG9uZW50IGluc3RydWN0aW9uIGluc3RhbmNlcyBieSBwYXJhbXMgYW5kIGJ5IFBhcnNlZFVybCBpbnN0YW5jZVxyXG4gICAgZnVuY3Rpb24gUGF0aFJlY29nbml6ZXIocGF0aCwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLnRlcm1pbmFsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcclxuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoU3RyaW5nKHBhdGgpO1xyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRzID0gcGFyc2VkWydzZWdtZW50cyddO1xyXG4gICAgICAgIHRoaXMuc3BlY2lmaWNpdHkgPSBwYXJzZWRbJ3NwZWNpZmljaXR5J107XHJcbiAgICAgICAgdGhpcy5oYXNoID0gcGF0aERzbEhhc2godGhpcy5fc2VnbWVudHMpO1xyXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW3RoaXMuX3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHRoaXMudGVybWluYWwgPSAhKGxhc3RTZWdtZW50IGluc3RhbmNlb2YgQ29udGludWF0aW9uU2VnbWVudCk7XHJcbiAgICB9XHJcbiAgICBQYXRoUmVjb2duaXplci5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gKGJlZ2lubmluZ1NlZ21lbnQpIHtcclxuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBiZWdpbm5pbmdTZWdtZW50O1xyXG4gICAgICAgIHZhciBjdXJyZW50U2VnbWVudDtcclxuICAgICAgICB2YXIgcG9zaXRpb25hbFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHZhciBjYXB0dXJlZCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSBuZXh0U2VnbWVudDtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBDb250aW51YXRpb25TZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjdXJyZW50U2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNhcHR1cmVkLnB1c2goY3VycmVudFNlZ21lbnQucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RhciBzZWdtZW50IGNvbnN1bWVzIGFsbCBvZiB0aGUgcmVtYWluaW5nIFVSTCwgaW5jbHVkaW5nIG1hdHJpeCBwYXJhbXNcclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgU3RhclNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmFsUGFyYW1zW3NlZ21lbnQubmFtZV0gPSBjdXJyZW50U2VnbWVudC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRHluYW1pY1NlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmFsUGFyYW1zW3NlZ21lbnQubmFtZV0gPSBjdXJyZW50U2VnbWVudC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlZ21lbnQubWF0Y2goY3VycmVudFNlZ21lbnQucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gY3VycmVudFNlZ21lbnQuY2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXNlZ21lbnQubWF0Y2goJycpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50ZXJtaW5hbCAmJiBsYW5nXzEuaXNQcmVzZW50KG5leHRTZWdtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybFBhdGggPSBjYXB0dXJlZC5qb2luKCcvJyk7XHJcbiAgICAgICAgdmFyIGF1eGlsaWFyeTtcclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgdmFyIHVybFBhcmFtcztcclxuICAgICAgICB2YXIgYWxsUGFyYW1zO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGN1cnJlbnRTZWdtZW50KSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSByb290IGNvbXBvbmVudCwgcmVhZCBxdWVyeSBwYXJhbXMuIE90aGVyd2lzZSwgcmVhZCBtYXRyaXggcGFyYW1zLlxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zU2VnbWVudCA9IGJlZ2lubmluZ1NlZ21lbnQgaW5zdGFuY2VvZiB1cmxfcGFyc2VyXzEuUm9vdFVybCA/IGJlZ2lubmluZ1NlZ21lbnQgOiBjdXJyZW50U2VnbWVudDtcclxuICAgICAgICAgICAgYWxsUGFyYW1zID0gbGFuZ18xLmlzUHJlc2VudChwYXJhbXNTZWdtZW50LnBhcmFtcykgP1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIubWVyZ2UocGFyYW1zU2VnbWVudC5wYXJhbXMsIHBvc2l0aW9uYWxQYXJhbXMpIDpcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxQYXJhbXM7XHJcbiAgICAgICAgICAgIHVybFBhcmFtcyA9IHVybF9wYXJzZXJfMS5zZXJpYWxpemVQYXJhbXMocGFyYW1zU2VnbWVudC5wYXJhbXMpO1xyXG4gICAgICAgICAgICBhdXhpbGlhcnkgPSBjdXJyZW50U2VnbWVudC5hdXhpbGlhcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhbGxQYXJhbXMgPSBwb3NpdGlvbmFsUGFyYW1zO1xyXG4gICAgICAgICAgICBhdXhpbGlhcnkgPSBbXTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RydWN0aW9uID0gdGhpcy5fZ2V0SW5zdHJ1Y3Rpb24odXJsUGF0aCwgdXJsUGFyYW1zLCB0aGlzLCBhbGxQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGF0aE1hdGNoKGluc3RydWN0aW9uLCBuZXh0U2VnbWVudCwgYXV4aWxpYXJ5KTtcclxuICAgIH07XHJcbiAgICBQYXRoUmVjb2duaXplci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtVG9rZW5zID0gbmV3IFRvdWNoTWFwKHBhcmFtcyk7XHJcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmICghKHNlZ21lbnQgaW5zdGFuY2VvZiBDb250aW51YXRpb25TZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKHNlZ21lbnQuZ2VuZXJhdGUocGFyYW1Ub2tlbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsUGF0aCA9IHBhdGguam9pbignLycpO1xyXG4gICAgICAgIHZhciBub25Qb3NpdGlvbmFsUGFyYW1zID0gcGFyYW1Ub2tlbnMuZ2V0VW51c2VkKCk7XHJcbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IHVybF9wYXJzZXJfMS5zZXJpYWxpemVQYXJhbXMobm9uUG9zaXRpb25hbFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEluc3RydWN0aW9uKHVybFBhdGgsIHVybFBhcmFtcywgdGhpcywgcGFyYW1zKTtcclxuICAgIH07XHJcbiAgICBQYXRoUmVjb2duaXplci5wcm90b3R5cGUuX2dldEluc3RydWN0aW9uID0gZnVuY3Rpb24gKHVybFBhdGgsIHVybFBhcmFtcywgX3JlY29nbml6ZXIsIHBhcmFtcykge1xyXG4gICAgICAgIHZhciBoYXNoS2V5ID0gdXJsUGF0aCArICc/JyArIHVybFBhcmFtcy5qb2luKCc/Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhcyhoYXNoS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0KGhhc2hLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBuZXcgaW5zdHJ1Y3Rpb25fMS5Db21wb25lbnRJbnN0cnVjdGlvbl8odXJsUGF0aCwgdXJsUGFyYW1zLCBfcmVjb2duaXplciwgcGFyYW1zKTtcclxuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoaGFzaEtleSwgaW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGF0aFJlY29nbml6ZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUGF0aFJlY29nbml6ZXIgPSBQYXRoUmVjb2duaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aF9yZWNvZ25pemVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgcm91dGVfY29uZmlnX2ltcGxfMSA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX2ltcGwnKTtcclxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL3V0aWwvZGVjb3JhdG9ycycpO1xyXG52YXIgcm91dGVfY29uZmlnX2ltcGxfMiA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX2ltcGwnKTtcclxuZXhwb3J0cy5Sb3V0ZSA9IHJvdXRlX2NvbmZpZ19pbXBsXzIuUm91dGU7XHJcbmV4cG9ydHMuUmVkaXJlY3QgPSByb3V0ZV9jb25maWdfaW1wbF8yLlJlZGlyZWN0O1xyXG5leHBvcnRzLkF1eFJvdXRlID0gcm91dGVfY29uZmlnX2ltcGxfMi5BdXhSb3V0ZTtcclxuZXhwb3J0cy5Bc3luY1JvdXRlID0gcm91dGVfY29uZmlnX2ltcGxfMi5Bc3luY1JvdXRlO1xyXG5leHBvcnRzLlJvdXRlQ29uZmlnID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3Iocm91dGVfY29uZmlnX2ltcGxfMS5Sb3V0ZUNvbmZpZyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX2NvbmZpZ19kZWNvcmF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG4vKipcclxuICogVGhlIGBSb3V0ZUNvbmZpZ2AgZGVjb3JhdG9yIGRlZmluZXMgcm91dGVzIGZvciBhIGdpdmVuIGNvbXBvbmVudC5cclxuICpcclxuICogSXQgdGFrZXMgYW4gYXJyYXkgb2Yge0BsaW5rIFJvdXRlRGVmaW5pdGlvbn1zLlxyXG4gKi9cclxudmFyIFJvdXRlQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlQ29uZmlnKGNvbmZpZ3MpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZ3MgPSBjb25maWdzO1xyXG4gICAgfVxyXG4gICAgUm91dGVDb25maWcgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXldKVxyXG4gICAgXSwgUm91dGVDb25maWcpO1xyXG4gICAgcmV0dXJuIFJvdXRlQ29uZmlnO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlQ29uZmlnID0gUm91dGVDb25maWc7XHJcbi8qKlxyXG4gKiBgUm91dGVgIGlzIGEgdHlwZSBvZiB7QGxpbmsgUm91dGVEZWZpbml0aW9ufSB1c2VkIHRvIHJvdXRlIGEgcGF0aCB0byBhIGNvbXBvbmVudC5cclxuICpcclxuICogSXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogLSBgcGF0aGAgaXMgYSBzdHJpbmcgdGhhdCB1c2VzIHRoZSByb3V0ZSBtYXRjaGVyIERTTC5cclxuICogLSBgY29tcG9uZW50YCBhIGNvbXBvbmVudCB0eXBlLlxyXG4gKiAtIGBhc2AgaXMgYW4gb3B0aW9uYWwgYENhbWVsQ2FzZWAgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgcm91dGUuXHJcbiAqIC0gYGRhdGFgIGlzIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIGFueSB0eXBlIHJlcHJlc2VudGluZyBhcmJpdHJhcnkgcm91dGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlblxyXG4gKiByb3V0ZS4gSXQgaXMgaW5qZWN0YWJsZSB2aWEgdGhlIHtAbGluayBST1VURV9EQVRBfSB0b2tlbi5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogICB7cGF0aDogJy9ob21lJywgY29tcG9uZW50OiBIb21lQ21wLCBhczogJ0hvbWVDbXAnIH1cclxuICogXSlcclxuICogY2xhc3MgTXlBcHAge31cclxuICogYGBgXHJcbiAqL1xyXG52YXIgUm91dGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUm91dGUoX2EpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IF9hLnBhdGgsIGNvbXBvbmVudCA9IF9hLmNvbXBvbmVudCwgYXMgPSBfYS5hcywgZGF0YSA9IF9hLmRhdGE7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmFzID0gYXM7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVkaXJlY3RUbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuICAgIFJvdXRlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBSb3V0ZSk7XHJcbiAgICByZXR1cm4gUm91dGU7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUm91dGUgPSBSb3V0ZTtcclxuLyoqXHJcbiAqIGBBdXhSb3V0ZWAgaXMgYSB0eXBlIG9mIHtAbGluayBSb3V0ZURlZmluaXRpb259IHVzZWQgdG8gZGVmaW5lIGFuIGF1eGlsaWFyeSByb3V0ZS5cclxuICpcclxuICogSXQgdGFrZXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiAtIGBwYXRoYCBpcyBhIHN0cmluZyB0aGF0IHVzZXMgdGhlIHJvdXRlIG1hdGNoZXIgRFNMLlxyXG4gKiAtIGBjb21wb25lbnRgIGEgY29tcG9uZW50IHR5cGUuXHJcbiAqIC0gYGFzYCBpcyBhbiBvcHRpb25hbCBgQ2FtZWxDYXNlYCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSByb3V0ZS5cclxuICogLSBgZGF0YWAgaXMgYW4gb3B0aW9uYWwgcHJvcGVydHkgb2YgYW55IHR5cGUgcmVwcmVzZW50aW5nIGFyYml0cmFyeSByb3V0ZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuXHJcbiAqIHJvdXRlLiBJdCBpcyBpbmplY3RhYmxlIHZpYSB0aGUge0BsaW5rIFJPVVRFX0RBVEF9IHRva2VuLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge1JvdXRlQ29uZmlnLCBBdXhSb3V0ZX0gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogICBuZXcgQXV4Um91dGUoe3BhdGg6ICcvaG9tZScsIGNvbXBvbmVudDogSG9tZUNtcH0pXHJcbiAqIF0pXHJcbiAqIGNsYXNzIE15QXBwIHt9XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIEF1eFJvdXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1eFJvdXRlKF9hKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBfYS5wYXRoLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGFzID0gX2EuYXM7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICAvLyBhZGRlZCBuZXh0IHR3byBwcm9wZXJ0aWVzIHRvIHdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDEwN1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VG8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5hcyA9IGFzO1xyXG4gICAgfVxyXG4gICAgQXV4Um91dGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBsYW5nXzEuQ09OU1QoKSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcclxuICAgIF0sIEF1eFJvdXRlKTtcclxuICAgIHJldHVybiBBdXhSb3V0ZTtcclxufSkoKTtcclxuZXhwb3J0cy5BdXhSb3V0ZSA9IEF1eFJvdXRlO1xyXG4vKipcclxuICogYEFzeW5jUm91dGVgIGlzIGEgdHlwZSBvZiB7QGxpbmsgUm91dGVEZWZpbml0aW9ufSB1c2VkIHRvIHJvdXRlIGEgcGF0aCB0byBhbiBhc3luY2hyb25vdXNseVxyXG4gKiBsb2FkZWQgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBJdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiAtIGBwYXRoYCBpcyBhIHN0cmluZyB0aGF0IHVzZXMgdGhlIHJvdXRlIG1hdGNoZXIgRFNMLlxyXG4gKiAtIGBsb2FkZXJgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29tcG9uZW50LlxyXG4gKiAtIGBhc2AgaXMgYW4gb3B0aW9uYWwgYENhbWVsQ2FzZWAgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgcm91dGUuXHJcbiAqIC0gYGRhdGFgIGlzIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIGFueSB0eXBlIHJlcHJlc2VudGluZyBhcmJpdHJhcnkgcm91dGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlblxyXG4gKiByb3V0ZS4gSXQgaXMgaW5qZWN0YWJsZSB2aWEgdGhlIHtAbGluayBST1VURV9EQVRBfSB0b2tlbi5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogICB7cGF0aDogJy9ob21lJywgbG9hZGVyOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoTXlMb2FkZWRDbXApLCBhczogJ015TG9hZGVkQ21wJ31cclxuICogXSlcclxuICogY2xhc3MgTXlBcHAge31cclxuICogYGBgXHJcbiAqL1xyXG52YXIgQXN5bmNSb3V0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBc3luY1JvdXRlKF9hKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBfYS5wYXRoLCBsb2FkZXIgPSBfYS5sb2FkZXIsIGFzID0gX2EuYXMsIGRhdGEgPSBfYS5kYXRhO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5hcyA9IGFzO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgICBBc3luY1JvdXRlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgbGFuZ18xLkNPTlNUKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXHJcbiAgICBdLCBBc3luY1JvdXRlKTtcclxuICAgIHJldHVybiBBc3luY1JvdXRlO1xyXG59KSgpO1xyXG5leHBvcnRzLkFzeW5jUm91dGUgPSBBc3luY1JvdXRlO1xyXG4vKipcclxuICogYFJlZGlyZWN0YCBpcyBhIHR5cGUgb2Yge0BsaW5rIFJvdXRlRGVmaW5pdGlvbn0gdXNlZCB0byByb3V0ZSBhIHBhdGggdG8gYW4gYXN5bmNocm9ub3VzbHkgbG9hZGVkXHJcbiAqIGNvbXBvbmVudC5cclxuICpcclxuICogSXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogLSBgcGF0aGAgaXMgYSBzdHJpbmcgdGhhdCB1c2VzIHRoZSByb3V0ZSBtYXRjaGVyIERTTC5cclxuICogLSBgcmVkaXJlY3RUb2AgaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuZXcgVVJMIHRvIGJlIG1hdGNoZWQgYWdhaW5zdC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogaW1wb3J0IHtSb3V0ZUNvbmZpZ30gZnJvbSAnYW5ndWxhcjIvcm91dGVyJztcclxuICpcclxuICogQFJvdXRlQ29uZmlnKFtcclxuICogICB7cGF0aDogJy8nLCByZWRpcmVjdFRvOiAnL2hvbWUnfSxcclxuICogICB7cGF0aDogJy9ob21lJywgY29tcG9uZW50OiBIb21lQ21wfVxyXG4gKiBdKVxyXG4gKiBjbGFzcyBNeUFwcCB7fVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBSZWRpcmVjdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWRpcmVjdChfYSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gX2EucGF0aCwgcmVkaXJlY3RUbyA9IF9hLnJlZGlyZWN0VG87XHJcbiAgICAgICAgdGhpcy5hcyA9IG51bGw7XHJcbiAgICAgICAgLy8gYWRkZWQgbmV4dCBwcm9wZXJ0eSB0byB3b3JrIGFyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQxMDdcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMucmVkaXJlY3RUbyA9IHJlZGlyZWN0VG87XHJcbiAgICB9XHJcbiAgICBSZWRpcmVjdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGxhbmdfMS5DT05TVCgpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxyXG4gICAgXSwgUmVkaXJlY3QpO1xyXG4gICAgcmV0dXJuIFJlZGlyZWN0O1xyXG59KSgpO1xyXG5leHBvcnRzLlJlZGlyZWN0ID0gUmVkaXJlY3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX2NvbmZpZ19pbXBsLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgcm91dGVfY29uZmlnX2RlY29yYXRvcl8xID0gcmVxdWlyZSgnLi9yb3V0ZV9jb25maWdfZGVjb3JhdG9yJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuLyoqXHJcbiAqIEdpdmVuIGEgSlMgT2JqZWN0IHRoYXQgcmVwcmVzZW50cy4uLiByZXR1cm5zIGEgY29ycmVzcG9uZGluZyBSb3V0ZSwgQXN5bmNSb3V0ZSwgb3IgUmVkaXJlY3RcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlQ29uZmlnKGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Sb3V0ZSB8fCBjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuUmVkaXJlY3QgfHwgY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLkFzeW5jUm91dGUgfHxcclxuICAgICAgICBjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuQXV4Um91dGUpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgaWYgKCgrISFjb25maWcuY29tcG9uZW50KSArICgrISFjb25maWcucmVkaXJlY3RUbykgKyAoKyEhY29uZmlnLmxvYWRlcikgIT0gMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlJvdXRlIGNvbmZpZyBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBcXFwiY29tcG9uZW50XFxcIiwgXFxcImxvYWRlclxcXCIsIG9yIFxcXCJyZWRpcmVjdFRvXFxcIiBwcm9wZXJ0eS5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAoY29uZmlnLmxvYWRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLkFzeW5jUm91dGUoeyBwYXRoOiBjb25maWcucGF0aCwgbG9hZGVyOiBjb25maWcubG9hZGVyLCBhczogY29uZmlnLmFzIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5jb21wb25lbnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb21wb25lbnQgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudERlZmluaXRpb25PYmplY3QgPSBjb25maWcuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbk9iamVjdC50eXBlID09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcm91dGVfY29uZmlnX2RlY29yYXRvcl8xLlJvdXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjb25maWcucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudERlZmluaXRpb25PYmplY3QuY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgYXM6IGNvbmZpZy5hc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50RGVmaW5pdGlvbk9iamVjdC50eXBlID09ICdsb2FkZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Bc3luY1JvdXRlKHsgcGF0aDogY29uZmlnLnBhdGgsIGxvYWRlcjogY29tcG9uZW50RGVmaW5pdGlvbk9iamVjdC5sb2FkZXIsIGFzOiBjb25maWcuYXMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJJbnZhbGlkIGNvbXBvbmVudCB0eXBlIFxcXCJcIiArIGNvbXBvbmVudERlZmluaXRpb25PYmplY3QudHlwZSArIFwiXFxcIi4gVmFsaWQgdHlwZXMgYXJlIFxcXCJjb25zdHJ1Y3RvclxcXCIgYW5kIFxcXCJsb2FkZXJcXFwiLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IHJvdXRlX2NvbmZpZ19kZWNvcmF0b3JfMS5Sb3V0ZShjb25maWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5yZWRpcmVjdFRvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByb3V0ZV9jb25maWdfZGVjb3JhdG9yXzEuUmVkaXJlY3QoeyBwYXRoOiBjb25maWcucGF0aCwgcmVkaXJlY3RUbzogY29uZmlnLnJlZGlyZWN0VG8gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG59XHJcbmV4cG9ydHMubm9ybWFsaXplUm91dGVDb25maWcgPSBub3JtYWxpemVSb3V0ZUNvbmZpZztcclxuZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50RXhpc3RzKGNvbXBvbmVudCwgcGF0aCkge1xyXG4gICAgaWYgKCFsYW5nXzEuaXNUeXBlKGNvbXBvbmVudCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb21wb25lbnQgZm9yIHJvdXRlIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgaXMgbm90IGRlZmluZWQsIG9yIGlzIG5vdCBhIGNsYXNzLlwiKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFzc2VydENvbXBvbmVudEV4aXN0cyA9IGFzc2VydENvbXBvbmVudEV4aXN0cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVfY29uZmlnX25vbWFsaXplci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGFuZ3VsYXIyXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9hbmd1bGFyMicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxuZXhwb3J0cy5ST1VURV9EQVRBID0gbGFuZ18xLkNPTlNUX0VYUFIobmV3IGFuZ3VsYXIyXzEuT3BhcXVlVG9rZW4oJ3JvdXRlRGF0YScpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVfZGF0YS5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVfZGVmaW5pdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8xID0gcmVxdWlyZSgnLi9saWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbCcpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbmZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2soZSwgdHlwZSkge1xyXG4gICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIGxhbmdfMS5UeXBlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gZS5uYW1lIGluIHR5cGUucHJvdG90eXBlO1xyXG59XHJcbmV4cG9ydHMuaGFzTGlmZWN5Y2xlSG9vayA9IGhhc0xpZmVjeWNsZUhvb2s7XHJcbmZ1bmN0aW9uIGdldENhbkFjdGl2YXRlSG9vayh0eXBlKSB7XHJcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XHJcbiAgICAgICAgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBsaWZlY3ljbGVfYW5ub3RhdGlvbnNfaW1wbF8xLkNhbkFjdGl2YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uLmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q2FuQWN0aXZhdGVIb29rID0gZ2V0Q2FuQWN0aXZhdGVIb29rO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZV9saWZlY3ljbGVfcmVmbGVjdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgcGF0aF9yZWNvZ25pemVyXzEgPSByZXF1aXJlKCcuL3BhdGhfcmVjb2duaXplcicpO1xyXG52YXIgcm91dGVfY29uZmlnX2ltcGxfMSA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX2ltcGwnKTtcclxudmFyIGFzeW5jX3JvdXRlX2hhbmRsZXJfMSA9IHJlcXVpcmUoJy4vYXN5bmNfcm91dGVfaGFuZGxlcicpO1xyXG52YXIgc3luY19yb3V0ZV9oYW5kbGVyXzEgPSByZXF1aXJlKCcuL3N5bmNfcm91dGVfaGFuZGxlcicpO1xyXG52YXIgdXJsX3BhcnNlcl8xID0gcmVxdWlyZSgnLi91cmxfcGFyc2VyJyk7XHJcbi8qKlxyXG4gKiBgUm91dGVSZWNvZ25pemVyYCBpcyByZXNwb25zaWJsZSBmb3IgcmVjb2duaXppbmcgcm91dGVzIGZvciBhIHNpbmdsZSBjb21wb25lbnQuXHJcbiAqIEl0IGlzIGNvbnN1bWVkIGJ5IGBSb3V0ZVJlZ2lzdHJ5YCwgd2hpY2gga25vd3MgaG93IHRvIHJlY29nbml6ZSBhbiBlbnRpcmUgaGllcmFyY2h5IG9mXHJcbiAqIGNvbXBvbmVudHMuXHJcbiAqL1xyXG52YXIgUm91dGVSZWNvZ25pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcclxuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgICAgICB0aGlzLmF1eFJvdXRlcyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpcyBpbnRvIGEgdHJpZVxyXG4gICAgICAgIHRoaXMubWF0Y2hlcnMgPSBbXTtcclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzIGludG8gYSB0cmllXHJcbiAgICAgICAgdGhpcy5yZWRpcmVjdHMgPSBbXTtcclxuICAgIH1cclxuICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBoYW5kbGVyO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbmZpZy5hcykgJiYgY29uZmlnLmFzWzBdLnRvVXBwZXJDYXNlKCkgIT0gY29uZmlnLmFzWzBdKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWdnZXN0ZWRBbGlhcyA9IGNvbmZpZy5hc1swXS50b1VwcGVyQ2FzZSgpICsgY29uZmlnLmFzLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiUm91dGUgJ1wiICsgY29uZmlnLnBhdGggKyBcIicgd2l0aCBhbGlhcyAnXCIgKyBjb25maWcuYXMgKyBcIicgZG9lcyBub3QgYmVnaW4gd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyLiBSb3V0ZSBhbGlhc2VzIHNob3VsZCBiZSBDYW1lbENhc2UgbGlrZSAnXCIgKyBzdWdnZXN0ZWRBbGlhcyArIFwiJy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLkF1eFJvdXRlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIgPSBuZXcgc3luY19yb3V0ZV9oYW5kbGVyXzEuU3luY1JvdXRlSGFuZGxlcihjb25maWcuY29tcG9uZW50LCBjb25maWcuZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aChjb25maWcucGF0aCwgJy8nKSA/IGNvbmZpZy5wYXRoLnN1YnN0cmluZygxKSA6IGNvbmZpZy5wYXRoO1xyXG4gICAgICAgICAgICB2YXIgcmVjb2duaXplciA9IG5ldyBwYXRoX3JlY29nbml6ZXJfMS5QYXRoUmVjb2duaXplcihjb25maWcucGF0aCwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuYXV4Um91dGVzLnNldChwYXRoLCByZWNvZ25pemVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXIudGVybWluYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLlJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RzLnB1c2gobmV3IFJlZGlyZWN0b3IoY29uZmlnLnBhdGgsIGNvbmZpZy5yZWRpcmVjdFRvKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2Ygcm91dGVfY29uZmlnX2ltcGxfMS5Sb3V0ZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyID0gbmV3IHN5bmNfcm91dGVfaGFuZGxlcl8xLlN5bmNSb3V0ZUhhbmRsZXIoY29uZmlnLmNvbXBvbmVudCwgY29uZmlnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLkFzeW5jUm91dGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IG5ldyBhc3luY19yb3V0ZV9oYW5kbGVyXzEuQXN5bmNSb3V0ZUhhbmRsZXIoY29uZmlnLmxvYWRlciwgY29uZmlnLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjb2duaXplciA9IG5ldyBwYXRoX3JlY29nbml6ZXJfMS5QYXRoUmVjb2duaXplcihjb25maWcucGF0aCwgaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5tYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyLmhhc2ggPT0gbWF0Y2hlci5oYXNoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb25maWd1cmF0aW9uICdcIiArIGNvbmZpZy5wYXRoICsgXCInIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIHJvdXRlICdcIiArIG1hdGNoZXIucGF0aCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubWF0Y2hlcnMucHVzaChyZWNvZ25pemVyKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb25maWcuYXMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZXMuc2V0KGNvbmZpZy5hcywgcmVjb2duaXplcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWNvZ25pemVyLnRlcm1pbmFsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBVUkwsIHJldHVybnMgYSBsaXN0IG9mIGBSb3V0ZU1hdGNoYGVzLCB3aGljaCBhcmUgcGFydGlhbCByZWNvZ25pdGlvbnMgZm9yIHNvbWUgcm91dGUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uICh1cmxQYXJzZSkge1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcclxuICAgICAgICB1cmxQYXJzZSA9IHRoaXMuX3JlZGlyZWN0KHVybFBhcnNlKTtcclxuICAgICAgICB0aGlzLm1hdGNoZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhdGhSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoTWF0Y2ggPSBwYXRoUmVjb2duaXplci5yZWNvZ25pemUodXJsUGFyc2UpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXRoTWF0Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChwYXRoTWF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9yZWRpcmVjdCA9IGZ1bmN0aW9uICh1cmxQYXJzZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWRpcmVjdHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIHJlZGlyZWN0b3IgPSB0aGlzLnJlZGlyZWN0c1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlZGlyZWN0ZWRVcmwgPSByZWRpcmVjdG9yLnJlZGlyZWN0KHVybFBhcnNlKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVkaXJlY3RlZFVybCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWRpcmVjdGVkVXJsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmxQYXJzZTtcclxuICAgIH07XHJcbiAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZUF1eGlsaWFyeSA9IGZ1bmN0aW9uICh1cmxQYXJzZSkge1xyXG4gICAgICAgIHZhciBwYXRoUmVjb2duaXplciA9IHRoaXMuYXV4Um91dGVzLmdldCh1cmxQYXJzZS5wYXRoKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGF0aFJlY29nbml6ZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFJlY29nbml6ZXIucmVjb2duaXplKHVybFBhcnNlKTtcclxuICAgIH07XHJcbiAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmhhc1JvdXRlID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMubmFtZXMuaGFzKG5hbWUpOyB9O1xyXG4gICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgcGF0aFJlY29nbml6ZXIgPSB0aGlzLm5hbWVzLmdldChuYW1lKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGF0aFJlY29nbml6ZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFJlY29nbml6ZXIuZ2VuZXJhdGUocGFyYW1zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm91dGVSZWNvZ25pemVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlUmVjb2duaXplciA9IFJvdXRlUmVjb2duaXplcjtcclxudmFyIFJlZGlyZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVkaXJlY3RvcihwYXRoLCByZWRpcmVjdFRvKSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMudG9TZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKHBhdGgsICcvJykpIHtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5zdGFydHNXaXRoKHJlZGlyZWN0VG8sICcvJykpIHtcclxuICAgICAgICAgICAgcmVkaXJlY3RUbyA9IHJlZGlyZWN0VG8uc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvU2VnbWVudHMgPSByZWRpcmVjdFRvLnNwbGl0KCcvJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYG51bGxgIG9yIGEgYFBhcnNlZFVybGAgcmVwcmVzZW50aW5nIHRoZSBuZXcgcGF0aCB0byBtYXRjaFxyXG4gICAgICovXHJcbiAgICBSZWRpcmVjdG9yLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uICh1cmxQYXJzZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodXJsUGFyc2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHRoaXMuc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50ICE9IHVybFBhcnNlLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybFBhcnNlID0gdXJsUGFyc2UuY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRvU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLnRvU2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIHVybFBhcnNlID0gbmV3IHVybF9wYXJzZXJfMS5Vcmwoc2VnbWVudCwgdXJsUGFyc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsUGFyc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlZGlyZWN0b3I7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmVkaXJlY3RvciA9IFJlZGlyZWN0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX3JlY29nbml6ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO3ZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQobykpIHx8IG87IH0sIHRhcmdldCk7XHJcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5KSksIHZvaWQgMDsgfSwgdm9pZCAwKTtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBkZWNvcmF0b3JzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKG8sIGQpIHsgcmV0dXJuIChkICYmIGQodGFyZ2V0LCBrZXksIG8pKSB8fCBvOyB9LCBkZXNjKTtcclxuICAgIH1cclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciByb3V0ZV9yZWNvZ25pemVyXzEgPSByZXF1aXJlKCcuL3JvdXRlX3JlY29nbml6ZXInKTtcclxudmFyIGluc3RydWN0aW9uXzEgPSByZXF1aXJlKCcuL2luc3RydWN0aW9uJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciByb3V0ZV9jb25maWdfaW1wbF8xID0gcmVxdWlyZSgnLi9yb3V0ZV9jb25maWdfaW1wbCcpO1xyXG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XHJcbnZhciBhbmd1bGFyMl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvYW5ndWxhcjInKTtcclxudmFyIHJvdXRlX2NvbmZpZ19ub21hbGl6ZXJfMSA9IHJlcXVpcmUoJy4vcm91dGVfY29uZmlnX25vbWFsaXplcicpO1xyXG52YXIgdXJsX3BhcnNlcl8xID0gcmVxdWlyZSgnLi91cmxfcGFyc2VyJyk7XHJcbnZhciBfcmVzb2x2ZVRvTnVsbCA9IGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZShudWxsKTtcclxuLyoqXHJcbiAqIFRoZSBSb3V0ZVJlZ2lzdHJ5IGhvbGRzIHJvdXRlIGNvbmZpZ3VyYXRpb25zIGZvciBlYWNoIGNvbXBvbmVudCBpbiBhbiBBbmd1bGFyIGFwcC5cclxuICogSXQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIEluc3RydWN0aW9ucyBmcm9tIFVSTHMsIGFuZCBnZW5lcmF0aW5nIFVSTHMgYmFzZWQgb24gcm91dGUgYW5kXHJcbiAqIHBhcmFtZXRlcnMuXHJcbiAqL1xyXG52YXIgUm91dGVSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZVJlZ2lzdHJ5KCkge1xyXG4gICAgICAgIHRoaXMuX3J1bGVzID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBjb21wb25lbnQgYW5kIGEgY29uZmlndXJhdGlvbiBvYmplY3QsIGFkZCB0aGUgcm91dGUgdG8gdGhpcyByZWdpc3RyeVxyXG4gICAgICovXHJcbiAgICBSb3V0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBjb25maWcpIHtcclxuICAgICAgICBjb25maWcgPSByb3V0ZV9jb25maWdfbm9tYWxpemVyXzEubm9ybWFsaXplUm91dGVDb25maWcoY29uZmlnKTtcclxuICAgICAgICAvLyB0aGlzIGlzIGhlcmUgYmVjYXVzZSBEYXJ0IHR5cGUgZ3VhcmQgcmVhc29uc1xyXG4gICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLlJvdXRlKSB7XHJcbiAgICAgICAgICAgIHJvdXRlX2NvbmZpZ19ub21hbGl6ZXJfMS5hc3NlcnRDb21wb25lbnRFeGlzdHMoY29uZmlnLmNvbXBvbmVudCwgY29uZmlnLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLkF1eFJvdXRlKSB7XHJcbiAgICAgICAgICAgIHJvdXRlX2NvbmZpZ19ub21hbGl6ZXJfMS5hc3NlcnRDb21wb25lbnRFeGlzdHMoY29uZmlnLmNvbXBvbmVudCwgY29uZmlnLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuX3J1bGVzLmdldChwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICByZWNvZ25pemVyID0gbmV3IHJvdXRlX3JlY29nbml6ZXJfMS5Sb3V0ZVJlY29nbml6ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fcnVsZXMuc2V0KHBhcmVudENvbXBvbmVudCwgcmVjb2duaXplcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IHJlY29nbml6ZXIuY29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIHJvdXRlX2NvbmZpZ19pbXBsXzEuUm91dGUpIHtcclxuICAgICAgICAgICAgaWYgKHRlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRUZXJtaW5hbENvbXBvbmVudChjb25maWcuY29tcG9uZW50LCBjb25maWcucGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ0Zyb21Db21wb25lbnQoY29uZmlnLmNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgYW5ub3RhdGlvbnMgb2YgYSBjb21wb25lbnQgYW5kIGNvbmZpZ3VyZXMgdGhlIHJlZ2lzdHJ5IGJhc2VkIG9uIHRoZW1cclxuICAgICAqL1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuY29uZmlnRnJvbUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghbGFuZ18xLmlzVHlwZShjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG9uJ3QgcmVhZCB0aGUgYW5ub3RhdGlvbnMgZnJvbSBhIHR5cGUgbW9yZSB0aGFuIG9uY2Ug4oCTXHJcbiAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wIGlmIGEgY29tcG9uZW50IHJvdXRlcyByZWN1cnNpdmVseS5cclxuICAgICAgICBpZiAodGhpcy5fcnVsZXMuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYW5ub3RhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIHJvdXRlX2NvbmZpZ19pbXBsXzEuUm91dGVDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVDZmdzID0gYW5ub3RhdGlvbi5jb25maWdzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlQ2Zncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHsgcmV0dXJuIF90aGlzLmNvbmZpZyhjb21wb25lbnQsIGNvbmZpZyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBVUkwgYW5kIGEgcGFyZW50IGNvbXBvbmVudCwgcmV0dXJuIHRoZSBtb3N0IHNwZWNpZmljIGluc3RydWN0aW9uIGZvciBuYXZpZ2F0aW5nXHJcbiAgICAgKiB0aGUgYXBwbGljYXRpb24gaW50byB0aGUgc3RhdGUgc3BlY2lmaWVkIGJ5IHRoZSB1cmxcclxuICAgICAqL1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gKHVybCwgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZFVybCA9IHVybF9wYXJzZXJfMS5wYXJzZXIucGFyc2UodXJsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKHBhcnNlZFVybCwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fcmVjb2duaXplID0gZnVuY3Rpb24gKHBhcnNlZFVybCwgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplUHJpbWFyeVJvdXRlKHBhcnNlZFVybCwgcGFyZW50Q29tcG9uZW50KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21wbGV0ZUF1eGlsaWFyeVJvdXRlTWF0Y2hlcyhpbnN0cnVjdGlvbiwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fcmVjb2duaXplUHJpbWFyeVJvdXRlID0gZnVuY3Rpb24gKHBhcnNlZFVybCwgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50UmVjb2duaXplciA9IHRoaXMuX3J1bGVzLmdldChwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb21wb25lbnRSZWNvZ25pemVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Jlc29sdmVUb051bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1hdGNoZXMgc29tZSBiZWdpbm5pbmcgcGFydCBvZiB0aGUgZ2l2ZW4gVVJMXHJcbiAgICAgICAgdmFyIHBvc3NpYmxlTWF0Y2hlcyA9IGNvbXBvbmVudFJlY29nbml6ZXIucmVjb2duaXplKHBhcnNlZFVybCk7XHJcbiAgICAgICAgdmFyIG1hdGNoUHJvbWlzZXMgPSBwb3NzaWJsZU1hdGNoZXMubWFwKGZ1bmN0aW9uIChjYW5kaWRhdGUpIHsgcmV0dXJuIF90aGlzLl9jb21wbGV0ZVByaW1hcnlSb3V0ZU1hdGNoKGNhbmRpZGF0ZSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChtYXRjaFByb21pc2VzKS50aGVuKG1vc3RTcGVjaWZpYyk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuX2NvbXBsZXRlUHJpbWFyeVJvdXRlTWF0Y2ggPSBmdW5jdGlvbiAocGFydGlhbE1hdGNoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBwYXJ0aWFsTWF0Y2guaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uLnJlc29sdmVDb21wb25lbnRUeXBlKCkudGhlbihmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5jb25maWdGcm9tQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24udGVybWluYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5zdHJ1Y3Rpb25fMS5QcmltYXJ5SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIG51bGwsIHBhcnRpYWxNYXRjaC5yZW1haW5pbmdBdXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVjb2duaXplUHJpbWFyeVJvdXRlKHBhcnRpYWxNYXRjaC5yZW1haW5pbmcsIGNvbXBvbmVudFR5cGUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2hpbGRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNoaWxkSW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluc3RydWN0aW9uXzEuUHJpbWFyeUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBjaGlsZEluc3RydWN0aW9uLCBwYXJ0aWFsTWF0Y2gucmVtYWluaW5nQXV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVSZWdpc3RyeS5wcm90b3R5cGUuX2NvbXBsZXRlQXV4aWxpYXJ5Um91dGVNYXRjaGVzID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9OdWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcG9uZW50UmVjb2duaXplciA9IHRoaXMuX3J1bGVzLmdldChwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIHZhciBhdXhJbnN0cnVjdGlvbnMgPSB7fTtcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBpbnN0cnVjdGlvbi5hdXhVcmxzLm1hcChmdW5jdGlvbiAoYXV4U2VnbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBjb21wb25lbnRSZWNvZ25pemVyLnJlY29nbml6ZUF1eGlsaWFyeShhdXhTZWdtZW50KTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1hdGNoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9OdWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGxldGVQcmltYXJ5Um91dGVNYXRjaChtYXRjaCkudGhlbihmdW5jdGlvbiAoYXV4SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF1eEluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGxldGVBdXhpbGlhcnlSb3V0ZU1hdGNoZXMoYXV4SW5zdHJ1Y3Rpb24sIHBhcmVudENvbXBvbmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbmlzaGVkQXV4Um91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV4SW5zdHJ1Y3Rpb25zW2F1eFNlZ21lbnQucGF0aF0gPSBmaW5pc2hlZEF1eFJvdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGluc3RydWN0aW9uLmNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVjdGlvbl8xLkluc3RydWN0aW9uKGluc3RydWN0aW9uLmNvbXBvbmVudCwgbnVsbCwgYXV4SW5zdHJ1Y3Rpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBsZXRlQXV4aWxpYXJ5Um91dGVNYXRjaGVzKGluc3RydWN0aW9uLmNoaWxkLCBpbnN0cnVjdGlvbi5jb21wb25lbnQuY29tcG9uZW50VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb21wbGV0ZUNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluc3RydWN0aW9uXzEuSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24uY29tcG9uZW50LCBjb21wbGV0ZUNoaWxkLCBhdXhJbnN0cnVjdGlvbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgbm9ybWFsaXplZCBsaXN0IHdpdGggY29tcG9uZW50IG5hbWVzIGFuZCBwYXJhbXMgbGlrZTogYFsndXNlcicsIHtpZDogMyB9XWBcclxuICAgICAqIGdlbmVyYXRlcyBhIHVybCB3aXRoIGEgbGVhZGluZyBzbGFzaCByZWxhdGl2ZSB0byB0aGUgcHJvdmlkZWQgYHBhcmVudENvbXBvbmVudGAuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlUmVnaXN0cnkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKGxpbmtQYXJhbXMsIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRDdXJzb3IgPSBwYXJlbnRDb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGxhc3RJbnN0cnVjdGlvbklzVGVybWluYWwgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtQYXJhbXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBsaW5rUGFyYW1zW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcG9uZW50Q3Vyc29yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ291bGQgbm90IGZpbmQgcm91dGUgbmFtZWQgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIi5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFsYW5nXzEuaXNTdHJpbmcoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgc2VnbWVudCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiIGluIGxpbmsgRFNMLiBFeHBlY3RlZCBhIHN0cmluZy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PSAnJyB8fCBzZWdtZW50ID09ICcuJyB8fCBzZWdtZW50ID09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlxcXCJcIiArIHNlZ21lbnQgKyBcIi9cXFwiIGlzIG9ubHkgYWxsb3dlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluayBEU0wuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGlua1BhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2VnbWVudCA9IGxpbmtQYXJhbXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1N0cmluZ01hcChuZXh0U2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXh0U2VnbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlY29nbml6ZXIgPSB0aGlzLl9ydWxlcy5nZXQoY29tcG9uZW50Q3Vyc29yKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBvbmVudFJlY29nbml6ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb21wb25lbnQgXFxcIlwiICsgbGFuZ18xLmdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGNvbXBvbmVudEN1cnNvcikgKyBcIlxcXCIgaGFzIG5vIHJvdXRlIGNvbmZpZy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gY29tcG9uZW50UmVjb2duaXplci5nZW5lcmF0ZShzZWdtZW50LCBwYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb21wb25lbnQgXFxcIlwiICsgbGFuZ18xLmdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGNvbXBvbmVudEN1cnNvcikgKyBcIlxcXCIgaGFzIG5vIHJvdXRlIG5hbWVkIFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBjb21wb25lbnRDdXJzb3IgPSByZXNwb25zZS5jb21wb25lbnRUeXBlO1xyXG4gICAgICAgICAgICBsYXN0SW5zdHJ1Y3Rpb25Jc1Rlcm1pbmFsID0gcmVzcG9uc2UudGVybWluYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFsYXN0SW5zdHJ1Y3Rpb25Jc1Rlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gdGhpcy5fZ2VuZXJhdGVSZWRpcmVjdHMoY29tcG9uZW50Q3Vyc29yKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChsYXN0SW5zdHJ1Y3Rpb24uY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluc3RydWN0aW9uID0gbGFzdEluc3RydWN0aW9uLmNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdEluc3RydWN0aW9uSXNUZXJtaW5hbCA9IGxhc3RJbnN0cnVjdGlvbi5jb21wb25lbnQudGVybWluYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcG9uZW50Q3Vyc29yKSAmJiAhbGFzdEluc3RydWN0aW9uSXNUZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTGluayBcXFwiXCIgKyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIudG9KU09OKGxpbmtQYXJhbXMpICsgXCJcXFwiIGRvZXMgbm90IHJlc29sdmUgdG8gYSB0ZXJtaW5hbCBvciBhc3luYyBpbnN0cnVjdGlvbi5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgaW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbihzZWdtZW50cy5wb3AoKSwgaW5zdHJ1Y3Rpb24sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xyXG4gICAgfTtcclxuICAgIC8vIGlmIHRoZSBjaGlsZCBpbmNsdWRlcyBhIHJlZGlyZWN0IGxpa2UgOiBcIi9cIiAtPiBcIi9zb21ldGhpbmdcIixcclxuICAgIC8vIHdlIHdhbnQgdG8gaG9ub3IgdGhhdCByZWRpcmVjdGlvbiB3aGVuIGNyZWF0aW5nIHRoZSBsaW5rXHJcbiAgICBSb3V0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVSZWRpcmVjdHMgPSBmdW5jdGlvbiAoY29tcG9uZW50Q3Vyc29yKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBvbmVudEN1cnNvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wb25lbnRSZWNvZ25pemVyID0gdGhpcy5fcnVsZXMuZ2V0KGNvbXBvbmVudEN1cnNvcik7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBvbmVudFJlY29nbml6ZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudFJlY29nbml6ZXIucmVkaXJlY3RzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciByZWRpcmVjdCA9IGNvbXBvbmVudFJlY29nbml6ZXIucmVkaXJlY3RzW2ldO1xyXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGhhbmRsZSByZWRpcmVjdGluZyBmcm9tIGFuIGVtcHR5IHNlZ21lbnRcclxuICAgICAgICAgICAgaWYgKHJlZGlyZWN0LnNlZ21lbnRzLmxlbmd0aCA9PSAxICYmIHJlZGlyZWN0LnNlZ21lbnRzWzBdID09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9TZWdtZW50cyA9IHVybF9wYXJzZXJfMS5wYXRoU2VnbWVudHNUb1VybChyZWRpcmVjdC50b1NlZ21lbnRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50UmVjb2duaXplci5yZWNvZ25pemUodG9TZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUluc3RydWN0aW9uID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLm1heGltdW0obWF0Y2hlcywgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBtYXRjaC5pbnN0cnVjdGlvbi5zcGVjaWZpY2l0eTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcmltYXJ5SW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fZ2VuZXJhdGVSZWRpcmVjdHMocHJpbWFyeUluc3RydWN0aW9uLmluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5zdHJ1Y3Rpb25fMS5JbnN0cnVjdGlvbihwcmltYXJ5SW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24sIGNoaWxkLCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSb3V0ZVJlZ2lzdHJ5ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgYW5ndWxhcjJfMS5JbmplY3RhYmxlKCksIFxyXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXHJcbiAgICBdLCBSb3V0ZVJlZ2lzdHJ5KTtcclxuICAgIHJldHVybiBSb3V0ZVJlZ2lzdHJ5O1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlUmVnaXN0cnkgPSBSb3V0ZVJlZ2lzdHJ5O1xyXG4vKlxyXG4gKiBHaXZlbiBhIGxpc3Qgb2YgaW5zdHJ1Y3Rpb25zLCByZXR1cm5zIHRoZSBtb3N0IHNwZWNpZmljIGluc3RydWN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBtb3N0U3BlY2lmaWMoaW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLm1heGltdW0oaW5zdHJ1Y3Rpb25zLCBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHsgcmV0dXJuIGluc3RydWN0aW9uLmNvbXBvbmVudC5zcGVjaWZpY2l0eTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0VGVybWluYWxDb21wb25lbnQoY29tcG9uZW50LCBwYXRoKSB7XHJcbiAgICBpZiAoIWxhbmdfMS5pc1R5cGUoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBhbm5vdGF0aW9ucyA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuYW5ub3RhdGlvbnMoY29tcG9uZW50KTtcclxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFubm90YXRpb25zKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiByb3V0ZV9jb25maWdfaW1wbF8xLlJvdXRlQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDaGlsZCByb3V0ZXMgYXJlIG5vdCBhbGxvd2VkIGZvciBcXFwiXCIgKyBwYXRoICsgXCJcXFwiLiBVc2UgXFxcIi4uLlxcXCIgb24gdGhlIHBhcmVudCdzIHJvdXRlIHBhdGguXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlX3JlZ2lzdHJ5LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9hc3luYycpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2NvbGxlY3Rpb24nKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9sYW5nJyk7XHJcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvZXhjZXB0aW9ucycpO1xyXG52YXIgaW5zdHJ1Y3Rpb25fMSA9IHJlcXVpcmUoJy4vaW5zdHJ1Y3Rpb24nKTtcclxudmFyIHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vcm91dGVfbGlmZWN5Y2xlX3JlZmxlY3RvcicpO1xyXG52YXIgX3Jlc29sdmVUb1RydWUgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodHJ1ZSk7XHJcbnZhciBfcmVzb2x2ZVRvRmFsc2UgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUoZmFsc2UpO1xyXG4vKipcclxuICogVGhlIGBSb3V0ZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIFVSTHMgdG8gY29tcG9uZW50cy5cclxuICpcclxuICogWW91IGNhbiBzZWUgdGhlIHN0YXRlIG9mIHRoZSByb3V0ZXIgYnkgaW5zcGVjdGluZyB0aGUgcmVhZC1vbmx5IGZpZWxkIGByb3V0ZXIubmF2aWdhdGluZ2AuXHJcbiAqIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3Igc2hvd2luZyBhIHNwaW5uZXIsIGZvciBpbnN0YW5jZS5cclxuICpcclxuICogIyMgQ29uY2VwdHNcclxuICpcclxuICogUm91dGVycyBhbmQgY29tcG9uZW50IGluc3RhbmNlcyBoYXZlIGEgMToxIGNvcnJlc3BvbmRlbmNlLlxyXG4gKlxyXG4gKiBUaGUgcm91dGVyIGhvbGRzIHJlZmVyZW5jZSB0byBhIG51bWJlciBvZiB7QGxpbmsgUm91dGVyT3V0bGV0fS5cclxuICogQW4gb3V0bGV0IGlzIGEgcGxhY2Vob2xkZXIgdGhhdCB0aGUgcm91dGVyIGR5bmFtaWNhbGx5IGZpbGxzIGluIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBVUkwuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIHJvdXRlciBuYXZpZ2F0ZXMgZnJvbSBhIFVSTCwgaXQgbXVzdCBmaXJzdCByZWNvZ25pemUgaXQgYW5kIHNlcmlhbGl6ZSBpdCBpbnRvIGFuXHJcbiAqIGBJbnN0cnVjdGlvbmAuXHJcbiAqIFRoZSByb3V0ZXIgdXNlcyB0aGUgYFJvdXRlUmVnaXN0cnlgIHRvIGdldCBhbiBgSW5zdHJ1Y3Rpb25gLlxyXG4gKi9cclxudmFyIFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSb3V0ZXIocmVnaXN0cnksIHBhcmVudCwgaG9zdENvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE5hdmlnYXRpb24gPSBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgICAgICB0aGlzLl9vdXRsZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2F1eFJvdXRlcnMgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIGNoaWxkIHJvdXRlci4gWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMgdW5sZXNzIHlvdSdyZSB3cml0aW5nIGEgcmV1c2FibGVcclxuICAgICAqIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5jaGlsZFJvdXRlciA9IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkUm91dGVyID0gbmV3IENoaWxkUm91dGVyKHRoaXMsIGhvc3RDb21wb25lbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIGNoaWxkIHJvdXRlci4gWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMgdW5sZXNzIHlvdSdyZSB3cml0aW5nIGEgcmV1c2FibGVcclxuICAgICAqIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5hdXhSb3V0ZXIgPSBmdW5jdGlvbiAoaG9zdENvbXBvbmVudCkgeyByZXR1cm4gbmV3IENoaWxkUm91dGVyKHRoaXMsIGhvc3RDb21wb25lbnQpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhbiBvdXRsZXQgdG8gbm90aWZpZWQgb2YgcHJpbWFyeSByb3V0ZSBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzIHVubGVzcyB5b3UncmUgd3JpdGluZyBhIHJldXNhYmxlIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5yZWdpc3RlclByaW1hcnlPdXRsZXQgPSBmdW5jdGlvbiAob3V0bGV0KSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3V0bGV0Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcInJlZ2lzdGVyQXV4T3V0bGV0IGV4cGVjdHMgdG8gYmUgY2FsbGVkIHdpdGggYW4gdW5uYW1lZCBvdXRsZXQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vdXRsZXQgPSBvdXRsZXQ7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY3VycmVudEluc3RydWN0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21taXQodGhpcy5fY3VycmVudEluc3RydWN0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfcmVzb2x2ZVRvVHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGFuIG91dGxldCB0byBub3RpZmllZCBvZiBhdXhpbGlhcnkgcm91dGUgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcyB1bmxlc3MgeW91J3JlIHdyaXRpbmcgYSByZXVzYWJsZSBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVnaXN0ZXJBdXhPdXRsZXQgPSBmdW5jdGlvbiAob3V0bGV0KSB7XHJcbiAgICAgICAgdmFyIG91dGxldE5hbWUgPSBvdXRsZXQubmFtZTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsob3V0bGV0TmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwicmVnaXN0ZXJBdXhPdXRsZXQgZXhwZWN0cyB0byBiZSBjYWxsZWQgd2l0aCBhbiBvdXRsZXQgd2l0aCBhIG5hbWUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPLi4uXHJcbiAgICAgICAgLy8gd2hhdCBpcyB0aGUgaG9zdCBvZiBhbiBhdXggcm91dGU/Pz9cclxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5hdXhSb3V0ZXIodGhpcy5ob3N0Q29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9hdXhSb3V0ZXJzLnNldChvdXRsZXROYW1lLCByb3V0ZXIpO1xyXG4gICAgICAgIHJvdXRlci5fb3V0bGV0ID0gb3V0bGV0O1xyXG4gICAgICAgIHZhciBhdXhJbnN0cnVjdGlvbjtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pICYmXHJcbiAgICAgICAgICAgIGxhbmdfMS5pc1ByZXNlbnQoYXV4SW5zdHJ1Y3Rpb24gPSB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24uYXV4SW5zdHJ1Y3Rpb25bb3V0bGV0TmFtZV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuY29tbWl0KGF1eEluc3RydWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gaW5zdHJ1Y3Rpb24sIHJldHVybnMgYHRydWVgIGlmIHRoZSBpbnN0cnVjdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlLFxyXG4gICAgICogb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuaXNSb3V0ZUFjdGl2ZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KHJvdXRlci5wYXJlbnQpICYmIGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24uY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIHJvdXRlciA9IHJvdXRlci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikgJiZcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmNvbXBvbmVudCA9PSBpbnN0cnVjdGlvbi5jb21wb25lbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEeW5hbWljYWxseSB1cGRhdGUgdGhlIHJvdXRpbmcgY29uZmlndXJhdGlvbiBhbmQgdHJpZ2dlciBhIG5hdmlnYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogIyBVc2FnZVxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogcm91dGVyLmNvbmZpZyhbXHJcbiAgICAgKiAgIHsgJ3BhdGgnOiAnLycsICdjb21wb25lbnQnOiBJbmRleENvbXAgfSxcclxuICAgICAqICAgeyAncGF0aCc6ICcvdXNlci86aWQnLCAnY29tcG9uZW50JzogVXNlckNvbXAgfSxcclxuICAgICAqIF0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gKGRlZmluaXRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBkZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZURlZmluaXRpb24pIHsgX3RoaXMucmVnaXN0cnkuY29uZmlnKF90aGlzLmhvc3RDb21wb25lbnQsIHJvdXRlRGVmaW5pdGlvbik7IH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmF2aWdhdGUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBSb3V0ZSBMaW5rIERTTC4gSXQncyBwcmVmZXJyZWQgdG8gbmF2aWdhdGUgd2l0aCB0aGlzIG1ldGhvZFxyXG4gICAgICogb3ZlciBgbmF2aWdhdGVCeVVybGAuXHJcbiAgICAgKlxyXG4gICAgICogIyBVc2FnZVxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgUm91dGUgTGluayBEU0w6XHJcbiAgICAgKiBgYGBcclxuICAgICAqIFsnLi9NeUNtcCcsIHtwYXJhbTogM31dXHJcbiAgICAgKiBgYGBcclxuICAgICAqIFNlZSB0aGUge0BsaW5rIFJvdXRlckxpbmt9IGRpcmVjdGl2ZSBmb3IgbW9yZS5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChsaW5rUGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIGluc3RydWN0aW9uID0gdGhpcy5nZW5lcmF0ZShsaW5rUGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZUJ5SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlIHRvIGEgVVJMLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gbmF2aWdhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAqIEl0J3MgcHJlZmVycmVkIHRvIG5hdmlnYXRlIHdpdGggYG5hdmlnYXRlYCBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLCBzaW5jZSBVUkxzIGFyZSBtb3JlIGJyaXR0bGUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGdpdmVuIFVSTCBiZWdpbnMgd2l0aCBhIGAvYCwgcm91dGVyIHdpbGwgbmF2aWdhdGUgYWJzb2x1dGVseS5cclxuICAgICAqIElmIHRoZSBnaXZlbiBVUkwgZG9lcyBub3QgYmVnaW4gd2l0aCBgL2AsIHRoZSByb3V0ZXIgd2lsbCBuYXZpZ2F0ZSByZWxhdGl2ZSB0byB0aGlzIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZUJ5VXJsID0gZnVuY3Rpb24gKHVybCwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9za2lwTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBfc2tpcExvY2F0aW9uQ2hhbmdlID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudE5hdmlnYXRpb24gPSB0aGlzLl9jdXJyZW50TmF2aWdhdGlvbi50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmxhc3ROYXZpZ2F0aW9uQXR0ZW1wdCA9IHVybDtcclxuICAgICAgICAgICAgX3RoaXMuX3N0YXJ0TmF2aWdhdGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2FmdGVyUHJvbWlzZUZpbmlzaE5hdmlnYXRpbmcoX3RoaXMucmVjb2duaXplKHVybCkudGhlbihmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX25hdmlnYXRlKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTmF2aWdhdGUgdmlhIHRoZSBwcm92aWRlZCBpbnN0cnVjdGlvbi4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIG5hdmlnYXRpb24gaXNcclxuICAgICAqIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlQnlJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9za2lwTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBfc2tpcExvY2F0aW9uQ2hhbmdlID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvRmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TmF2aWdhdGlvbiA9IHRoaXMuX2N1cnJlbnROYXZpZ2F0aW9uLnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgX3RoaXMuX3N0YXJ0TmF2aWdhdGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2FmdGVyUHJvbWlzZUZpbmlzaE5hdmlnYXRpbmcoX3RoaXMuX25hdmlnYXRlKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fbmF2aWdhdGUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIF9za2lwTG9jYXRpb25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0bGVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLl9jYW5SZXVzZShpbnN0cnVjdGlvbik7IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5fY2FuQWN0aXZhdGUoaW5zdHJ1Y3Rpb24pOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jYW5EZWFjdGl2YXRlKGluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb21taXQoaW5zdHJ1Y3Rpb24sIF9za2lwTG9jYXRpb25DaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0TmF2aWdhdGlvbkZpbmlzaChpbnN0cnVjdGlvbl8xLnN0cmluZ2lmeUluc3RydWN0aW9uKGluc3RydWN0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPKGJ0Zm9yZCk6IGl0J2QgYmUgbmljZSB0byByZW1vdmUgdGhpcyBtZXRob2QgYXMgcGFydCBvZiBjbGVhbmluZyB1cCB0aGUgdHJhdmVyc2FsIGxvZ2ljXHJcbiAgICAvLyBTaW5jZSByZWZhY3RvcmluZyBgUm91dGVyLmdlbmVyYXRlYCB0byByZXR1cm4gYW4gaW5zdHJ1Y3Rpb24gcmF0aGVyIHRoYW4gYSBzdHJpbmcsIGl0J3Mgbm90XHJcbiAgICAvLyBndWFyYW50ZWVkIHRoYXQgdGhlIGBjb21wb25lbnRUeXBlYHMgZm9yIHRoZSB0ZXJtaW5hbCBhc3luYyByb3V0ZXMgaGF2ZSBiZWVuIGxvYWRlZCBieSB0aGUgdGltZVxyXG4gICAgLy8gd2UgYmVnaW4gbmF2aWdhdGlvbi4gVGhlIG1ldGhvZCBiZWxvdyBzaW1wbHkgdHJhdmVyc2VzIGluc3RydWN0aW9ucyBhbmQgcmVzb2x2ZXMgYW55IGNvbXBvbmVudHNcclxuICAgIC8vIGZvciB3aGljaCBgY29tcG9uZW50VHlwZWAgaXMgbm90IHByZXNlbnRcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuX3NldHRsZUluc3RydWN0aW9uID0gZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW5zZXR0bGVkSW5zdHJ1Y3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGluc3RydWN0aW9uLmNvbXBvbmVudC5jb21wb25lbnRUeXBlKSkge1xyXG4gICAgICAgICAgICB1bnNldHRsZWRJbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbi5jb21wb25lbnQucmVzb2x2ZUNvbXBvbmVudFR5cGUoKS50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IF90aGlzLnJlZ2lzdHJ5LmNvbmZpZ0Zyb21Db21wb25lbnQodHlwZSk7IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24uY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIHVuc2V0dGxlZEluc3RydWN0aW9ucy5wdXNoKHRoaXMuX3NldHRsZUluc3RydWN0aW9uKGluc3RydWN0aW9uLmNoaWxkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goaW5zdHJ1Y3Rpb24uYXV4SW5zdHJ1Y3Rpb24sIGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgXykge1xyXG4gICAgICAgICAgICB1bnNldHRsZWRJbnN0cnVjdGlvbnMucHVzaChfdGhpcy5fc2V0dGxlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwodW5zZXR0bGVkSW5zdHJ1Y3Rpb25zKTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLl9lbWl0TmF2aWdhdGlvbkZpbmlzaCA9IGZ1bmN0aW9uICh1cmwpIHsgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsTmV4dCh0aGlzLl9zdWJqZWN0LCB1cmwpOyB9O1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWZ0ZXJQcm9taXNlRmluaXNoTmF2aWdhdGluZyA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5jYXRjaEVycm9yKHByb21pc2UudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMuX2ZpbmlzaE5hdmlnYXRpbmcoKTsgfSksIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2ZpbmlzaE5hdmlnYXRpbmcoKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBSZWN1cnNpdmVseSBzZXQgcmV1c2UgZmxhZ3NcclxuICAgICAqL1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fY2FuUmV1c2UgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9vdXRsZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZVRvRmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRsZXQuY2FuUmV1c2UoaW5zdHJ1Y3Rpb24uY29tcG9uZW50KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbXBvbmVudC5yZXVzZSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiBsYW5nXzEuaXNQcmVzZW50KF90aGlzLl9jaGlsZFJvdXRlcikgJiYgbGFuZ18xLmlzUHJlc2VudChpbnN0cnVjdGlvbi5jaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2hpbGRSb3V0ZXIuX2NhblJldXNlKGluc3RydWN0aW9uLmNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NhbkFjdGl2YXRlID0gZnVuY3Rpb24gKG5leHRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjYW5BY3RpdmF0ZU9uZShuZXh0SW5zdHJ1Y3Rpb24sIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5fY2FuRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX291dGxldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dDtcclxuICAgICAgICB2YXIgY2hpbGRJbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIHJldXNlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RydWN0aW9uID0gbnVsbDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLmNoaWxkO1xyXG4gICAgICAgICAgICBjb21wb25lbnRJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgcmV1c2UgPSBpbnN0cnVjdGlvbi5jb21wb25lbnQucmV1c2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXVzZSkge1xyXG4gICAgICAgICAgICBuZXh0ID0gX3Jlc29sdmVUb1RydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5fb3V0bGV0LmNhbkRlYWN0aXZhdGUoY29tcG9uZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBhdXggcm91dGUgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgcmV0dXJuIG5leHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChfdGhpcy5fY2hpbGRSb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkUm91dGVyLl9jYW5EZWFjdGl2YXRlKGNoaWxkSW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGlzIHJvdXRlciBhbmQgYWxsIGRlc2NlbmRhbnQgcm91dGVycyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGluc3RydWN0aW9uXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoX3NraXBMb2NhdGlvbkNoYW5nZSA9PT0gdm9pZCAwKSB7IF9za2lwTG9jYXRpb25DaGFuZ2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xyXG4gICAgICAgIHZhciBuZXh0ID0gX3Jlc29sdmVUb1RydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fb3V0bGV0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRJbnN0cnVjdGlvbi5yZXVzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuX291dGxldC5yZXVzZShjb21wb25lbnRJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLl9vdXRsZXQuYWN0aXZhdGUoY29tcG9uZW50SW5zdHJ1Y3Rpb24pOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbnN0cnVjdGlvbi5jaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0LnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChfdGhpcy5fY2hpbGRSb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2hpbGRSb3V0ZXIuY29tbWl0KGluc3RydWN0aW9uLmNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9hdXhSb3V0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlciwgbmFtZSkgeyBwcm9taXNlcy5wdXNoKHJvdXRlci5jb21taXQoaW5zdHJ1Y3Rpb24uYXV4SW5zdHJ1Y3Rpb25bbmFtZV0pKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5leHQudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwocHJvbWlzZXMpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLl9zdGFydE5hdmlnYXRpbmcgPSBmdW5jdGlvbiAoKSB7IHRoaXMubmF2aWdhdGluZyA9IHRydWU7IH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLl9maW5pc2hOYXZpZ2F0aW5nID0gZnVuY3Rpb24gKCkgeyB0aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIFVSTCB1cGRhdGVzIGZyb20gdGhlIHJvdXRlclxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvbk5leHQpIHtcclxuICAgICAgICByZXR1cm4gYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUodGhpcy5fc3ViamVjdCwgb25OZXh0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgcm91dGVyJ3Mgb3V0bGV0IGFuZCBhbGwgZGVzY2VuZGFudCBvdXRsZXRzXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNoaWxkSW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRJbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5zdHJ1Y3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5jaGlsZDtcclxuICAgICAgICAgICAgY29tcG9uZW50SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5jb21wb25lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0ID0gX3Jlc29sdmVUb1RydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2hpbGRSb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLl9jaGlsZFJvdXRlci5kZWFjdGl2YXRlKGNoaWxkSW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9vdXRsZXQpKSB7XHJcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLl9vdXRsZXQuZGVhY3RpdmF0ZShjb21wb25lbnRJbnN0cnVjdGlvbik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgYXV4IHJvdXRlc1xyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBVUkwsIHJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQgZ3JhcGhcclxuICAgICAqL1xyXG4gICAgUm91dGVyLnByb3RvdHlwZS5yZWNvZ25pemUgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucmVjb2duaXplKHVybCwgdGhpcy5ob3N0Q29tcG9uZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyB0byBlaXRoZXIgdGhlIGxhc3QgVVJMIHN1Y2Nlc3NmdWxseSBuYXZpZ2F0ZWQgdG8sIG9yIHRoZSBsYXN0IFVSTCByZXF1ZXN0ZWQgaWYgdGhlXHJcbiAgICAgKiByb3V0ZXIgaGFzIHlldCB0byBzdWNjZXNzZnVsbHkgbmF2aWdhdGUuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlci5wcm90b3R5cGUucmVuYXZpZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5sYXN0TmF2aWdhdGlvbkF0dGVtcHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TmF2aWdhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGVCeVVybCh0aGlzLmxhc3ROYXZpZ2F0aW9uQXR0ZW1wdCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIFVSTCBmcm9tIGEgY29tcG9uZW50IG5hbWUgYW5kIG9wdGlvbmFsIG1hcCBvZiBwYXJhbWV0ZXJzLiBUaGUgVVJMIGlzIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAgICogYXBwJ3MgYmFzZSBocmVmLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKGxpbmtQYXJhbXMpIHtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZExpbmtQYXJhbXMgPSBzcGxpdEFuZEZsYXR0ZW5MaW5rUGFyYW1zKGxpbmtQYXJhbXMpO1xyXG4gICAgICAgIHZhciBmaXJzdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdChub3JtYWxpemVkTGlua1BhcmFtcyk7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc2xpY2Uobm9ybWFsaXplZExpbmtQYXJhbXMsIDEpO1xyXG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xyXG4gICAgICAgIC8vIFRoZSBmaXJzdCBzZWdtZW50IHNob3VsZCBiZSBlaXRoZXIgJy4nIChnZW5lcmF0ZSBmcm9tIHBhcmVudCkgb3IgJycgKGdlbmVyYXRlIGZyb20gcm9vdCkuXHJcbiAgICAgICAgLy8gV2hlbiB3ZSBub3JtYWxpemUgYWJvdmUsIHdlIHN0cmlwIGFsbCB0aGUgc2xhc2hlcywgJy4vJyBiZWNvbWVzICcuJyBhbmQgJy8nIGJlY29tZXMgJycuXHJcbiAgICAgICAgaWYgKGZpcnN0ID09ICcnKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KHJvdXRlci5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZXIgPSByb3V0ZXIucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09ICcuLicpIHtcclxuICAgICAgICAgICAgcm91dGVyID0gcm91dGVyLnBhcmVudDtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdChyZXN0KSA9PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICByZXN0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNsaWNlKHJlc3QsIDEpO1xyXG4gICAgICAgICAgICAgICAgcm91dGVyID0gcm91dGVyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTGluayBcXFwiXCIgKyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIudG9KU09OKGxpbmtQYXJhbXMpICsgXCJcXFwiIGhhcyB0b28gbWFueSBcXFwiLi4vXFxcIiBzZWdtZW50cy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZmlyc3QgIT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkxpbmsgXFxcIlwiICsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnRvSlNPTihsaW5rUGFyYW1zKSArIFwiXFxcIiBtdXN0IHN0YXJ0IHdpdGggXFxcIi9cXFwiLCBcXFwiLi9cXFwiLCBvciBcXFwiLi4vXFxcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3RbcmVzdC5sZW5ndGggLSAxXSA9PSAnJykge1xyXG4gICAgICAgICAgICByZXN0LnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdC5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBcIkxpbmsgXFxcIlwiICsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnRvSlNPTihsaW5rUGFyYW1zKSArIFwiXFxcIiBtdXN0IGluY2x1ZGUgYSByb3V0ZSBuYW1lLlwiO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24obXNnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogc3RydWN0dXJhbCBjbG9uaW5nIGFuZCB3aGF0bm90XHJcbiAgICAgICAgdmFyIHVybCA9IFtdO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSByb3V0ZXIucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgdXJsLnVuc2hpZnQocGFyZW50Ll9jdXJyZW50SW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dEluc3RydWN0aW9uID0gdGhpcy5yZWdpc3RyeS5nZW5lcmF0ZShyZXN0LCByb3V0ZXIuaG9zdENvbXBvbmVudCk7XHJcbiAgICAgICAgd2hpbGUgKHVybC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5leHRJbnN0cnVjdGlvbiA9IHVybC5wb3AoKS5yZXBsYWNlQ2hpbGQobmV4dEluc3RydWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHRJbnN0cnVjdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm91dGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlciA9IFJvdXRlcjtcclxudmFyIFJvb3RSb3V0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJvb3RSb3V0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSb290Um91dGVyKHJlZ2lzdHJ5LCBsb2NhdGlvbiwgcHJpbWFyeUNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcmVnaXN0cnksIG51bGwsIHByaW1hcnlDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24uc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5hdmlnYXRlQnlVcmwoY2hhbmdlWyd1cmwnXSwgbGFuZ18xLmlzUHJlc2VudChjaGFuZ2VbJ3BvcCddKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5jb25maWdGcm9tQ29tcG9uZW50KHByaW1hcnlDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMubmF2aWdhdGVCeVVybChsb2NhdGlvbi5wYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgUm9vdFJvdXRlci5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoX3NraXBMb2NhdGlvbkNoYW5nZSA9PT0gdm9pZCAwKSB7IF9za2lwTG9jYXRpb25DaGFuZ2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBlbWl0UGF0aCA9IGluc3RydWN0aW9uXzEuc3RyaW5naWZ5SW5zdHJ1Y3Rpb25QYXRoKGluc3RydWN0aW9uKTtcclxuICAgICAgICB2YXIgZW1pdFF1ZXJ5ID0gaW5zdHJ1Y3Rpb25fMS5zdHJpbmdpZnlJbnN0cnVjdGlvblF1ZXJ5KGluc3RydWN0aW9uKTtcclxuICAgICAgICBpZiAoZW1pdFBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBlbWl0UGF0aCA9ICcvJyArIGVtaXRQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvbWlzZSA9IF9zdXBlci5wcm90b3R5cGUuY29tbWl0LmNhbGwodGhpcywgaW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgIGlmICghX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChfKSB7IF90aGlzLl9sb2NhdGlvbi5nbyhlbWl0UGF0aCwgZW1pdFF1ZXJ5KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSb290Um91dGVyO1xyXG59KShSb3V0ZXIpO1xyXG5leHBvcnRzLlJvb3RSb3V0ZXIgPSBSb290Um91dGVyO1xyXG52YXIgQ2hpbGRSb3V0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENoaWxkUm91dGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2hpbGRSb3V0ZXIocGFyZW50LCBob3N0Q29tcG9uZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LnJlZ2lzdHJ5LCBwYXJlbnQsIGhvc3RDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG4gICAgQ2hpbGRSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlQnlVcmwgPSBmdW5jdGlvbiAodXJsLCBfc2tpcExvY2F0aW9uQ2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKF9za2lwTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBfc2tpcExvY2F0aW9uQ2hhbmdlID0gZmFsc2U7IH1cclxuICAgICAgICAvLyBEZWxlZ2F0ZSBuYXZpZ2F0aW9uIHRvIHRoZSByb290IHJvdXRlclxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5uYXZpZ2F0ZUJ5VXJsKHVybCwgX3NraXBMb2NhdGlvbkNoYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgQ2hpbGRSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlQnlJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgX3NraXBMb2NhdGlvbkNoYW5nZSkge1xyXG4gICAgICAgIGlmIChfc2tpcExvY2F0aW9uQ2hhbmdlID09PSB2b2lkIDApIHsgX3NraXBMb2NhdGlvbkNoYW5nZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgLy8gRGVsZWdhdGUgbmF2aWdhdGlvbiB0byB0aGUgcm9vdCByb3V0ZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubmF2aWdhdGVCeUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBfc2tpcExvY2F0aW9uQ2hhbmdlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2hpbGRSb3V0ZXI7XHJcbn0pKFJvdXRlcik7XHJcbi8qXHJcbiAqIEdpdmVuOiBbJy9hL2InLCB7YzogMn1dXHJcbiAqIFJldHVybnM6IFsnJywgJ2EnLCAnYicsIHtjOiAyfV1cclxuICovXHJcbnZhciBTTEFTSCA9IG5ldyBSZWdFeHAoJy8nKTtcclxuZnVuY3Rpb24gc3BsaXRBbmRGbGF0dGVuTGlua1BhcmFtcyhsaW5rUGFyYW1zKSB7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlZHVjZShsaW5rUGFyYW1zLCBmdW5jdGlvbiAoYWNjdW11bGF0aW9uLCBpdGVtKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1N0cmluZyhpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0aW9uLmNvbmNhdChsYW5nXzEuU3RyaW5nV3JhcHBlci5zcGxpdChpdGVtLCBTTEFTSCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY2N1bXVsYXRpb24ucHVzaChpdGVtKTtcclxuICAgICAgICByZXR1cm4gYWNjdW11bGF0aW9uO1xyXG4gICAgfSwgW10pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbkFjdGl2YXRlT25lKG5leHRJbnN0cnVjdGlvbiwgcHJldkluc3RydWN0aW9uKSB7XHJcbiAgICB2YXIgbmV4dCA9IF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobmV4dEluc3RydWN0aW9uLmNoaWxkKSkge1xyXG4gICAgICAgIG5leHQgPSBjYW5BY3RpdmF0ZU9uZShuZXh0SW5zdHJ1Y3Rpb24uY2hpbGQsIGxhbmdfMS5pc1ByZXNlbnQocHJldkluc3RydWN0aW9uKSA/IHByZXZJbnN0cnVjdGlvbi5jaGlsZCA6IG51bGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0SW5zdHJ1Y3Rpb24uY29tcG9uZW50LnJldXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaG9vayA9IHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5nZXRDYW5BY3RpdmF0ZUhvb2sobmV4dEluc3RydWN0aW9uLmNvbXBvbmVudC5jb21wb25lbnRUeXBlKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob29rKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaG9vayhuZXh0SW5zdHJ1Y3Rpb24uY29tcG9uZW50LCBsYW5nXzEuaXNQcmVzZW50KHByZXZJbnN0cnVjdGlvbikgPyBwcmV2SW5zdHJ1Y3Rpb24uY29tcG9uZW50IDogbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4uL2NvcmUvbWV0YWRhdGEnKTtcclxudmFyIHJvdXRlcl8xID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcclxudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKCcuL2xvY2F0aW9uJyk7XHJcbnZhciBpbnN0cnVjdGlvbl8xID0gcmVxdWlyZSgnLi9pbnN0cnVjdGlvbicpO1xyXG4vKipcclxuICogVGhlIFJvdXRlckxpbmsgZGlyZWN0aXZlIGxldHMgeW91IGxpbmsgdG8gc3BlY2lmaWMgcGFydHMgb2YgeW91ciBhcHAuXHJcbiAqXHJcbiAqIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgcm91dGUgY29uZmlndXJhdGlvbjpcclxuXHJcbiAqIGBgYFxyXG4gKiBAUm91dGVDb25maWcoW1xyXG4gKiAgIHsgcGF0aDogJy91c2VyJywgY29tcG9uZW50OiBVc2VyQ21wLCBhczogJ1VzZXInIH1cclxuICogXSk7XHJcbiAqIGNsYXNzIE15Q29tcCB7fVxyXG4gKiBgYGBcclxuICpcclxuICogV2hlbiBsaW5raW5nIHRvIHRoaXMgYFVzZXJgIHJvdXRlLCB5b3UgY2FuIHdyaXRlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogPGEgW3JvdXRlci1saW5rXT1cIlsnLi9Vc2VyJ11cIj5saW5rIHRvIHVzZXIgY29tcG9uZW50PC9hPlxyXG4gKiBgYGBcclxuICpcclxuICogUm91dGVyTGluayBleHBlY3RzIHRoZSB2YWx1ZSB0byBiZSBhbiBhcnJheSBvZiByb3V0ZSBuYW1lcywgZm9sbG93ZWQgYnkgdGhlIHBhcmFtc1xyXG4gKiBmb3IgdGhhdCBsZXZlbCBvZiByb3V0aW5nLiBGb3IgaW5zdGFuY2UgYFsnL1RlYW0nLCB7dGVhbUlkOiAxfSwgJ1VzZXInLCB7dXNlcklkOiAyfV1gXHJcbiAqIG1lYW5zIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBhIGxpbmsgZm9yIHRoZSBgVGVhbWAgcm91dGUgd2l0aCBwYXJhbXMgYHt0ZWFtSWQ6IDF9YCxcclxuICogYW5kIHdpdGggYSBjaGlsZCByb3V0ZSBgVXNlcmAgd2l0aCBwYXJhbXMgYHt1c2VySWQ6IDJ9YC5cclxuICpcclxuICogVGhlIGZpcnN0IHJvdXRlIG5hbWUgc2hvdWxkIGJlIHByZXBlbmRlZCB3aXRoIGAvYCwgYC4vYCwgb3IgYC4uL2AuXHJcbiAqIElmIHRoZSByb3V0ZSBiZWdpbnMgd2l0aCBgL2AsIHRoZSByb3V0ZXIgd2lsbCBsb29rIHVwIHRoZSByb3V0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBhcHAuXHJcbiAqIElmIHRoZSByb3V0ZSBiZWdpbnMgd2l0aCBgLi9gLCB0aGUgcm91dGVyIHdpbGwgaW5zdGVhZCBsb29rIGluIHRoZSBjdXJyZW50IGNvbXBvbmVudCdzXHJcbiAqIGNoaWxkcmVuIGZvciB0aGUgcm91dGUuIEFuZCBpZiB0aGUgcm91dGUgYmVnaW5zIHdpdGggYC4uL2AsIHRoZSByb3V0ZXIgd2lsbCBsb29rIGF0IHRoZVxyXG4gKiBjdXJyZW50IGNvbXBvbmVudCdzIHBhcmVudC5cclxuICovXHJcbnZhciBSb3V0ZXJMaW5rID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmsoX3JvdXRlciwgX2xvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IF9sb2NhdGlvbjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJpc1JvdXRlQWN0aXZlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlci5pc1JvdXRlQWN0aXZlKHRoaXMuX25hdmlnYXRpb25JbnN0cnVjdGlvbik7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJvdXRlUGFyYW1zXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlUGFyYW1zID0gY2hhbmdlcztcclxuICAgICAgICAgICAgdGhpcy5fbmF2aWdhdGlvbkluc3RydWN0aW9uID0gdGhpcy5fcm91dGVyLmdlbmVyYXRlKHRoaXMuX3JvdXRlUGFyYW1zKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogaXMgdGhpcyB0aGUgcmlnaHQgc3BvdCBmb3IgdGhpcz9cclxuICAgICAgICAgICAgdmFyIG5hdmlnYXRpb25IcmVmID0gJy8nICsgaW5zdHJ1Y3Rpb25fMS5zdHJpbmdpZnlJbnN0cnVjdGlvbih0aGlzLl9uYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2libGVIcmVmID0gdGhpcy5fbG9jYXRpb24ubm9ybWFsaXplQWJzb2x1dGVseShuYXZpZ2F0aW9uSHJlZik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBSb3V0ZXJMaW5rLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JvdXRlci5uYXZpZ2F0ZUJ5SW5zdHJ1Y3Rpb24odGhpcy5fbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUm91dGVyTGluayA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIG1ldGFkYXRhXzEuRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbcm91dGVyLWxpbmtdJyxcclxuICAgICAgICAgICAgaW5wdXRzOiBbJ3JvdXRlUGFyYW1zOiByb3V0ZXJMaW5rJ10sXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ29uQ2xpY2soKScsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuaHJlZl0nOiAndmlzaWJsZUhyZWYnLFxyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5yb3V0ZXItbGluay1hY3RpdmVdJzogJ2lzUm91dGVBY3RpdmUnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgXHJcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbcm91dGVyXzEuUm91dGVyLCBsb2NhdGlvbl8xLkxvY2F0aW9uXSlcclxuICAgIF0sIFJvdXRlckxpbmspO1xyXG4gICAgcmV0dXJuIFJvdXRlckxpbms7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUm91dGVyTGluayA9IFJvdXRlckxpbms7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlcl9saW5rLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jzt2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKG8pKSB8fCBvOyB9LCB0YXJnZXQpO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGRlY29yYXRvcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24obywgZCkgeyByZXR1cm4gKGQgJiYgZCh0YXJnZXQsIGtleSkpLCB2b2lkIDA7IH0sIHZvaWQgMCk7XHJcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZGVjb3JhdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbihvLCBkKSB7IHJldHVybiAoZCAmJiBkKHRhcmdldCwga2V5LCBvKSkgfHwgbzsgfSwgZGVzYyk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn07XHJcbnZhciBhc3luY18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2FzeW5jJyk7XHJcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvY29sbGVjdGlvbicpO1xyXG52YXIgbGFuZ18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2xhbmcnKTtcclxudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9leGNlcHRpb25zJyk7XHJcbnZhciBhbmd1bGFyMl8xID0gcmVxdWlyZSgnYW5ndWxhcjIvYW5ndWxhcjInKTtcclxudmFyIHJvdXRlck1vZCA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XHJcbnZhciBpbnN0cnVjdGlvbl8xID0gcmVxdWlyZSgnLi9pbnN0cnVjdGlvbicpO1xyXG52YXIgcm91dGVfZGF0YV8xID0gcmVxdWlyZSgnLi9yb3V0ZV9kYXRhJyk7XHJcbnZhciBob29rTW9kID0gcmVxdWlyZSgnLi9saWZlY3ljbGVfYW5ub3RhdGlvbnMnKTtcclxudmFyIHJvdXRlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vcm91dGVfbGlmZWN5Y2xlX3JlZmxlY3RvcicpO1xyXG52YXIgX3Jlc29sdmVUb1RydWUgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodHJ1ZSk7XHJcbi8qKlxyXG4gKiBBIHJvdXRlciBvdXRsZXQgaXMgYSBwbGFjZWhvbGRlciB0aGF0IEFuZ3VsYXIgZHluYW1pY2FsbHkgZmlsbHMgYmFzZWQgb24gdGhlIGFwcGxpY2F0aW9uJ3Mgcm91dGUuXHJcbiAqXHJcbiAqICMjIFVzZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxyXG4gKiBgYGBcclxuICovXHJcbnZhciBSb3V0ZXJPdXRsZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUm91dGVyT3V0bGV0KF9lbGVtZW50UmVmLCBfbG9hZGVyLCBfcGFyZW50Um91dGVyLCBuYW1lQXR0cikge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBfbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudFJvdXRlciA9IF9wYXJlbnRSb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobmFtZUF0dHIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWVBdHRyO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRSb3V0ZXIucmVnaXN0ZXJBdXhPdXRsZXQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRSb3V0ZXIucmVnaXN0ZXJQcmltYXJ5T3V0bGV0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBSb3V0ZXIgdG8gaW5zdGFudGlhdGUgYSBuZXcgY29tcG9uZW50IGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIG9mIGEgbmF2aWdhdGlvbi5cclxuICAgICAqIFRoaXMgbWV0aG9kIGluIHR1cm4gaXMgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgdGhlIGBvbkFjdGl2YXRlYCBob29rIG9mIGl0cyBjaGlsZC5cclxuICAgICAqL1xyXG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChuZXh0SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcmV2aW91c0luc3RydWN0aW9uID0gdGhpcy5fY3VycmVudEluc3RydWN0aW9uO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiA9IG5leHRJbnN0cnVjdGlvbjtcclxuICAgICAgICB2YXIgY29tcG9uZW50VHlwZSA9IG5leHRJbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlO1xyXG4gICAgICAgIHZhciBjaGlsZFJvdXRlciA9IHRoaXMuX3BhcmVudFJvdXRlci5jaGlsZFJvdXRlcihjb21wb25lbnRUeXBlKTtcclxuICAgICAgICB2YXIgcHJvdmlkZXJzID0gYW5ndWxhcjJfMS5JbmplY3Rvci5yZXNvbHZlKFtcclxuICAgICAgICAgICAgYW5ndWxhcjJfMS5wcm92aWRlKHJvdXRlX2RhdGFfMS5ST1VURV9EQVRBLCB7IHVzZVZhbHVlOiBuZXh0SW5zdHJ1Y3Rpb24ucm91dGVEYXRhKCkgfSksXHJcbiAgICAgICAgICAgIGFuZ3VsYXIyXzEucHJvdmlkZShpbnN0cnVjdGlvbl8xLlJvdXRlUGFyYW1zLCB7IHVzZVZhbHVlOiBuZXcgaW5zdHJ1Y3Rpb25fMS5Sb3V0ZVBhcmFtcyhuZXh0SW5zdHJ1Y3Rpb24ucGFyYW1zKSB9KSxcclxuICAgICAgICAgICAgYW5ndWxhcjJfMS5wcm92aWRlKHJvdXRlck1vZC5Sb3V0ZXIsIHsgdXNlVmFsdWU6IGNoaWxkUm91dGVyIH0pXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkTmV4dFRvTG9jYXRpb24oY29tcG9uZW50VHlwZSwgdGhpcy5fZWxlbWVudFJlZiwgcHJvdmlkZXJzKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9jb21wb25lbnRSZWYgPSBjb21wb25lbnRSZWY7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEuaGFzTGlmZWN5Y2xlSG9vayhob29rTW9kLm9uQWN0aXZhdGUsIGNvbXBvbmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5vbkFjdGl2YXRlKG5leHRJbnN0cnVjdGlvbiwgcHJldmlvdXNJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBieSB0aGUge0BsaW5rIFJvdXRlcn0gZHVyaW5nIHRoZSBjb21taXQgcGhhc2Ugb2YgYSBuYXZpZ2F0aW9uIHdoZW4gYW4gb3V0bGV0XHJcbiAgICAgKiByZXVzZXMgYSBjb21wb25lbnQgYmV0d2VlbiBkaWZmZXJlbnQgcm91dGVzLlxyXG4gICAgICogVGhpcyBtZXRob2QgaW4gdHVybiBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgYG9uUmV1c2VgIGhvb2sgb2YgaXRzIGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLnJldXNlID0gZnVuY3Rpb24gKG5leHRJbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBwcmV2aW91c0luc3RydWN0aW9uID0gdGhpcy5fY3VycmVudEluc3RydWN0aW9uO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbiA9IG5leHRJbnN0cnVjdGlvbjtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fY29tcG9uZW50UmVmKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgcmV1c2UgYW4gb3V0bGV0IHRoYXQgZG9lcyBub3QgY29udGFpbiBhIGNvbXBvbmVudC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUocm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9va01vZC5vblJldXNlLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSkgP1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2Uub25SZXVzZShuZXh0SW5zdHJ1Y3Rpb24sIHByZXZpb3VzSW5zdHJ1Y3Rpb24pIDpcclxuICAgICAgICAgICAgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgdGhlIHtAbGluayBSb3V0ZXJ9IHdoZW4gYW4gb3V0bGV0IHJldXNlcyBhIGNvbXBvbmVudCBhY3Jvc3MgbmF2aWdhdGlvbnMuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpbiB0dXJuIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBgb25SZXVzZWAgaG9vayBvZiBpdHMgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChuZXh0SW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuZXh0ID0gX3Jlc29sdmVUb1RydWU7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY29tcG9uZW50UmVmKSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikgJiZcclxuICAgICAgICAgICAgcm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9va01vZC5vbkRlYWN0aXZhdGUsIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlKSkge1xyXG4gICAgICAgICAgICBuZXh0ID0gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5vbkRlYWN0aXZhdGUobmV4dEluc3RydWN0aW9uLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHQudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChfdGhpcy5fY29tcG9uZW50UmVmKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBvbmVudFJlZi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29tcG9uZW50UmVmID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSB7QGxpbmsgUm91dGVyfSBkdXJpbmcgcmVjb2duaXRpb24gcGhhc2Ugb2YgYSBuYXZpZ2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoaXMgcmVzb2x2ZXMgdG8gYGZhbHNlYCwgdGhlIGdpdmVuIG5hdmlnYXRpb24gaXMgY2FuY2VsbGVkLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGRlbGVnYXRlcyB0byB0aGUgY2hpbGQgY29tcG9uZW50J3MgYGNhbkRlYWN0aXZhdGVgIGhvb2sgaWYgaXQgZXhpc3RzLFxyXG4gICAgICogYW5kIG90aGVyd2lzZSByZXNvbHZlcyB0byB0cnVlLlxyXG4gICAgICovXHJcbiAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmNhbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAobmV4dEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNvbHZlVG9UcnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9va01vZC5jYW5EZWFjdGl2YXRlLCB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZSh0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY2FuRGVhY3RpdmF0ZShuZXh0SW5zdHJ1Y3Rpb24sIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3Jlc29sdmVUb1RydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgdGhlIHtAbGluayBSb3V0ZXJ9IGR1cmluZyByZWNvZ25pdGlvbiBwaGFzZSBvZiBhIG5hdmlnYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIG5ldyBjaGlsZCBjb21wb25lbnQgaGFzIGEgZGlmZmVyZW50IFR5cGUgdGhhbiB0aGUgZXhpc3RpbmcgY2hpbGQgY29tcG9uZW50LFxyXG4gICAgICogdGhpcyB3aWxsIHJlc29sdmUgdG8gYGZhbHNlYC4gWW91IGNhbid0IHJldXNlIGFuIG9sZCBjb21wb25lbnQgd2hlbiB0aGUgbmV3IGNvbXBvbmVudFxyXG4gICAgICogaXMgb2YgYSBkaWZmZXJlbnQgVHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIGRlbGVnYXRlcyB0byB0aGUgY2hpbGQgY29tcG9uZW50J3MgYGNhblJldXNlYCBob29rIGlmIGl0IGV4aXN0cyxcclxuICAgICAqIG9yIHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIGhvb2sgaXMgbm90IHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuY2FuUmV1c2UgPSBmdW5jdGlvbiAobmV4dEluc3RydWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fY3VycmVudEluc3RydWN0aW9uKSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSAhPSBuZXh0SW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocm91dGVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9va01vZC5jYW5SZXVzZSwgdGhpcy5fY3VycmVudEluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5jYW5SZXVzZShuZXh0SW5zdHJ1Y3Rpb24sIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXh0SW5zdHJ1Y3Rpb24gPT0gdGhpcy5fY3VycmVudEluc3RydWN0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICAobGFuZ18xLmlzUHJlc2VudChuZXh0SW5zdHJ1Y3Rpb24ucGFyYW1zKSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbi5wYXJhbXMpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZXF1YWxzKG5leHRJbnN0cnVjdGlvbi5wYXJhbXMsIHRoaXMuX2N1cnJlbnRJbnN0cnVjdGlvbi5wYXJhbXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIFJvdXRlck91dGxldCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGFuZ3VsYXIyXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdyb3V0ZXItb3V0bGV0JyB9KSxcclxuICAgICAgICBfX3BhcmFtKDMsIGFuZ3VsYXIyXzEuQXR0cmlidXRlKCduYW1lJykpLCBcclxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFthbmd1bGFyMl8xLkVsZW1lbnRSZWYsIGFuZ3VsYXIyXzEuRHluYW1pY0NvbXBvbmVudExvYWRlciwgcm91dGVyTW9kLlJvdXRlciwgU3RyaW5nXSlcclxuICAgIF0sIFJvdXRlck91dGxldCk7XHJcbiAgICByZXR1cm4gUm91dGVyT3V0bGV0O1xyXG59KSgpO1xyXG5leHBvcnRzLlJvdXRlck91dGxldCA9IFJvdXRlck91dGxldDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyX291dGxldC5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIGFzeW5jXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvYXN5bmMnKTtcclxudmFyIFN5bmNSb3V0ZUhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3luY1JvdXRlSGFuZGxlcihjb21wb25lbnRUeXBlLCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLl9yZXNvbHZlZENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb21wb25lbnQgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUoY29tcG9uZW50VHlwZSk7XHJcbiAgICB9XHJcbiAgICBTeW5jUm91dGVIYW5kbGVyLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQ29tcG9uZW50OyB9O1xyXG4gICAgcmV0dXJuIFN5bmNSb3V0ZUhhbmRsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU3luY1JvdXRlSGFuZGxlciA9IFN5bmNSb3V0ZUhhbmRsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5bmNfcm91dGVfaGFuZGxlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJ2FuZ3VsYXIyL3NyYy9jb3JlL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XHJcbnZhciBsYW5nXzEgPSByZXF1aXJlKCdhbmd1bGFyMi9zcmMvY29yZS9mYWNhZGUvbGFuZycpO1xyXG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnYW5ndWxhcjIvc3JjL2NvcmUvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIHBhcnNlZCBVUkxcclxuICovXHJcbnZhciBVcmwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXJsKHBhdGgsIGNoaWxkLCBhdXhpbGlhcnksIHBhcmFtcykge1xyXG4gICAgICAgIGlmIChjaGlsZCA9PT0gdm9pZCAwKSB7IGNoaWxkID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChhdXhpbGlhcnkgPT09IHZvaWQgMCkgeyBhdXhpbGlhcnkgPSBsYW5nXzEuQ09OU1RfRVhQUihbXSk7IH1cclxuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMuYXV4aWxpYXJ5ID0gYXV4aWxpYXJ5O1xyXG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgVXJsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoICsgdGhpcy5fbWF0cml4UGFyYW1zVG9TdHJpbmcoKSArIHRoaXMuX2F1eFRvU3RyaW5nKCkgKyB0aGlzLl9jaGlsZFN0cmluZygpO1xyXG4gICAgfTtcclxuICAgIFVybC5wcm90b3R5cGUuc2VnbWVudFRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXRoICsgdGhpcy5fbWF0cml4UGFyYW1zVG9TdHJpbmcoKTsgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIFVybC5wcm90b3R5cGUuX2F1eFRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1eGlsaWFyeS5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgKCcoJyArIHRoaXMuYXV4aWxpYXJ5Lm1hcChmdW5jdGlvbiAoc2libGluZykgeyByZXR1cm4gc2libGluZy50b1N0cmluZygpOyB9KS5qb2luKCcvLycpICsgJyknKSA6XHJcbiAgICAgICAgICAgICcnO1xyXG4gICAgfTtcclxuICAgIFVybC5wcm90b3R5cGUuX21hdHJpeFBhcmFtc1RvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLnBhcmFtcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzsnICsgc2VyaWFsaXplUGFyYW1zKHRoaXMucGFyYW1zKS5qb2luKCc7Jyk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgVXJsLnByb3RvdHlwZS5fY2hpbGRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY2hpbGQpID8gKCcvJyArIHRoaXMuY2hpbGQudG9TdHJpbmcoKSkgOiAnJzsgfTtcclxuICAgIHJldHVybiBVcmw7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVXJsID0gVXJsO1xyXG52YXIgUm9vdFVybCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm9vdFVybCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJvb3RVcmwocGF0aCwgY2hpbGQsIGF1eGlsaWFyeSwgcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkID09PSB2b2lkIDApIHsgY2hpbGQgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGF1eGlsaWFyeSA9PT0gdm9pZCAwKSB7IGF1eGlsaWFyeSA9IGxhbmdfMS5DT05TVF9FWFBSKFtdKTsgfVxyXG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSBudWxsOyB9XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgY2hpbGQsIGF1eGlsaWFyeSwgcGFyYW1zKTtcclxuICAgIH1cclxuICAgIFJvb3RVcmwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGggKyB0aGlzLl9hdXhUb1N0cmluZygpICsgdGhpcy5fY2hpbGRTdHJpbmcoKSArIHRoaXMuX3F1ZXJ5UGFyYW1zVG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBSb290VXJsLnByb3RvdHlwZS5zZWdtZW50VG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhdGggKyB0aGlzLl9xdWVyeVBhcmFtc1RvU3RyaW5nKCk7IH07XHJcbiAgICBSb290VXJsLnByb3RvdHlwZS5fcXVlcnlQYXJhbXNUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5wYXJhbXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc/JyArIHNlcmlhbGl6ZVBhcmFtcyh0aGlzLnBhcmFtcykuam9pbignJicpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSb290VXJsO1xyXG59KShVcmwpO1xyXG5leHBvcnRzLlJvb3RVcmwgPSBSb290VXJsO1xyXG5mdW5jdGlvbiBwYXRoU2VnbWVudHNUb1VybChwYXRoU2VnbWVudHMpIHtcclxuICAgIHZhciB1cmwgPSBuZXcgVXJsKHBhdGhTZWdtZW50c1twYXRoU2VnbWVudHMubGVuZ3RoIC0gMV0pO1xyXG4gICAgZm9yICh2YXIgaSA9IHBhdGhTZWdtZW50cy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgIHVybCA9IG5ldyBVcmwocGF0aFNlZ21lbnRzW2ldLCB1cmwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5leHBvcnRzLnBhdGhTZWdtZW50c1RvVXJsID0gcGF0aFNlZ21lbnRzVG9Vcmw7XHJcbnZhciBTRUdNRU5UX1JFID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCdeW15cXFxcL1xcXFwoXFxcXClcXFxcPzs9JiNdKycpO1xyXG5mdW5jdGlvbiBtYXRjaFVybFNlZ21lbnQoc3RyKSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKFNFR01FTlRfUkUsIHN0cik7XHJcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChtYXRjaCkgPyBtYXRjaFswXSA6ICcnO1xyXG59XHJcbnZhciBVcmxQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXJsUGFyc2VyKCkge1xyXG4gICAgfVxyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wZWVrU3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0YXJ0c1dpdGgodGhpcy5fcmVtYWluaW5nLCBzdHIpOyB9O1xyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIGlmICghbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RhcnRzV2l0aCh0aGlzLl9yZW1haW5pbmcsIHN0cikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRXhwZWN0ZWQgXFxcIlwiICsgc3RyICsgXCJcXFwiLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nID0gdGhpcy5fcmVtYWluaW5nLnN1YnN0cmluZyhzdHIubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IHVybDtcclxuICAgICAgICBpZiAodXJsID09ICcnIHx8IHVybCA9PSAnLycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmwoJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJvb3QoKTtcclxuICAgIH07XHJcbiAgICAvLyBzZWdtZW50ICsgKGF1eCBzZWdtZW50cykgKyAocXVlcnkgcGFyYW1zKVxyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdGggPSBtYXRjaFVybFNlZ21lbnQodGhpcy5fcmVtYWluaW5nKTtcclxuICAgICAgICB0aGlzLmNhcHR1cmUocGF0aCk7XHJcbiAgICAgICAgdmFyIGF1eCA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcoJykpIHtcclxuICAgICAgICAgICAgYXV4ID0gdGhpcy5wYXJzZUF1eGlsaWFyeVJvdXRlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnOycpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB0aGVzZSBwYXJhbXMganVzdCBiZSBkcm9wcGVkP1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlTWF0cml4UGFyYW1zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8nKSAmJiAhdGhpcy5wZWVrU3RhcnRzV2l0aCgnLy8nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcclxuICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnBhcnNlU2VnbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCc/JykpIHtcclxuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSB0aGlzLnBhcnNlUXVlcnlQYXJhbXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSb290VXJsKHBhdGgsIGNoaWxkLCBhdXgsIHF1ZXJ5UGFyYW1zKTtcclxuICAgIH07XHJcbiAgICAvLyBzZWdtZW50ICsgKG1hdHJpeCBwYXJhbXMpICsgKGF1eCBzZWdtZW50cylcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gbWF0Y2hVcmxTZWdtZW50KHRoaXMuX3JlbWFpbmluZyk7XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlKHBhdGgpO1xyXG4gICAgICAgIHZhciBtYXRyaXhQYXJhbXMgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCc7JykpIHtcclxuICAgICAgICAgICAgbWF0cml4UGFyYW1zID0gdGhpcy5wYXJzZU1hdHJpeFBhcmFtcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXV4ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJygnKSkge1xyXG4gICAgICAgICAgICBhdXggPSB0aGlzLnBhcnNlQXV4aWxpYXJ5Um91dGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8nKSAmJiAhdGhpcy5wZWVrU3RhcnRzV2l0aCgnLy8nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcclxuICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnBhcnNlU2VnbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVybChwYXRoLCBjaGlsZCwgYXV4LCBtYXRyaXhQYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlKCc/Jyk7XHJcbiAgICAgICAgdGhpcy5wYXJzZVBhcmFtKHBhcmFtcyk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlbWFpbmluZy5sZW5ndGggPiAwICYmIHRoaXMucGVla1N0YXJ0c1dpdGgoJyYnKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJyYnKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZVBhcmFtKHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1hdHJpeFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlbWFpbmluZy5sZW5ndGggPiAwICYmIHRoaXMucGVla1N0YXJ0c1dpdGgoJzsnKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJzsnKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZVBhcmFtKHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBrZXkgPSBtYXRjaFVybFNlZ21lbnQodGhpcy5fcmVtYWluaW5nKTtcclxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FwdHVyZShrZXkpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJz0nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJz0nKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlTWF0Y2ggPSBtYXRjaFVybFNlZ21lbnQodGhpcy5fcmVtYWluaW5nKTtcclxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsdWVNYXRjaCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVNYXRjaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlQXV4aWxpYXJ5Um91dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3V0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNhcHR1cmUoJygnKTtcclxuICAgICAgICB3aGlsZSAoIXRoaXMucGVla1N0YXJ0c1dpdGgoJyknKSAmJiB0aGlzLl9yZW1haW5pbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByb3V0ZXMucHVzaCh0aGlzLnBhcnNlU2VnbWVudCgpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLy8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhcHR1cmUoJyknKTtcclxuICAgICAgICByZXR1cm4gcm91dGVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVcmxQYXJzZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVXJsUGFyc2VyID0gVXJsUGFyc2VyO1xyXG5leHBvcnRzLnBhcnNlciA9IG5ldyBVcmxQYXJzZXIoKTtcclxuZnVuY3Rpb24gc2VyaWFsaXplUGFyYW1zKHBhcmFtTWFwKSB7XHJcbiAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJhbU1hcCkpIHtcclxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHBhcmFtTWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5leHBvcnRzLnNlcmlhbGl6ZVBhcmFtcyA9IHNlcmlhbGl6ZVBhcmFtcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsX3BhcnNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7Ly8gTm90ZTogVGhpcyBjbGFzcyBpcyBvbmx5IGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIGl0IGZyb20gVHlwZVNjcmlwdCBjb2RlLlxyXG4vLyBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGxpdmVzIHVuZGVyIG1vZHVsZXNfZGFydC5cclxuLy8gVE9ETyh0Ym9zY2gpOiBNb3ZlIHRoZSBjb3JyZXNwb25kaW5nIGNvZGUgaW50byBhbmd1bGFyMi9zcmMvY29yZS9jb21waWxlciBvbmNlXHJcbi8vIHRoZSBuZXcgY29tcGlsZXIgaXMgZG9uZS5cclxudmFyIENvZGVnZW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29kZWdlbihtb2R1bGVBbGlhcykge1xyXG4gICAgfVxyXG4gICAgQ29kZWdlbi5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAodHlwZU5hbWUsIGNoYW5nZURldGVjdG9yVHlwZU5hbWUsIGRlZikge1xyXG4gICAgICAgIHRocm93IFwiTm90IGltcGxlbWVudGVkIGluIEpTXCI7XHJcbiAgICB9O1xyXG4gICAgQ29kZWdlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHRocm93IFwiTm90IGltcGxlbWVudGVkIGluIEpTXCI7IH07XHJcbiAgICByZXR1cm4gQ29kZWdlbjtcclxufSkoKTtcclxuZXhwb3J0cy5Db2RlZ2VuID0gQ29kZWdlbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdG9yX2NvZGVnZW4uanMubWFwIiwiLy8gVGhpcyBmaWxlIGlzIGF1dG9nZW5lcmF0ZWQgdmlhIHRoZSBgY29tbW9uanNgIEdydW50IHRhc2suIFlvdSBjYW4gcmVxdWlyZSgpIHRoaXMgZmlsZSBpbiBhIENvbW1vbkpTIGVudmlyb25tZW50LlxucmVxdWlyZSgnLi4vLi4vanMvdHJhbnNpdGlvbi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9hbGVydC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9idXR0b24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY2Fyb3VzZWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY29sbGFwc2UuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvZHJvcGRvd24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvbW9kYWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvdG9vbHRpcC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9wb3BvdmVyLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3Njcm9sbHNweS5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy90YWIuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvYWZmaXguanMnKSIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhZmZpeC5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FmZml4XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUZGSVggQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEFmZml4ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWZmaXguREVGQVVMVFMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLiR0YXJnZXQgPSAkKHRoaXMub3B0aW9ucy50YXJnZXQpXG4gICAgICAub24oJ3Njcm9sbC5icy5hZmZpeC5kYXRhLWFwaScsICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSlcbiAgICAgIC5vbignY2xpY2suYnMuYWZmaXguZGF0YS1hcGknLCAgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLCB0aGlzKSlcblxuICAgIHRoaXMuJGVsZW1lbnQgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuYWZmaXhlZCAgICAgID0gbnVsbFxuICAgIHRoaXMudW5waW4gICAgICAgID0gbnVsbFxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy41J1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgc2Nyb2xsVG9wIDw9IG9mZnNldFRvcCkgcmV0dXJuICd0b3AnXG4gICAgaWYgKG9mZnNldEJvdHRvbSAhPSBudWxsICYmIChjb2xsaWRlclRvcCArIGNvbGxpZGVySGVpZ2h0ID49IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkpIHJldHVybiAnYm90dG9tJ1xuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBpbm5lZE9mZnNldCkgcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVCkuYWRkQ2xhc3MoJ2FmZml4JylcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICByZXR1cm4gKHRoaXMucGlubmVkT2Zmc2V0ID0gcG9zaXRpb24udG9wIC0gc2Nyb2xsVG9wKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpLCAxKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSByZXR1cm5cblxuICAgIHZhciBoZWlnaHQgICAgICAgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldCAgICAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcFxuICAgIHZhciBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IE1hdGgubWF4KCQoZG9jdW1lbnQpLmhlaWdodCgpLCAkKGRvY3VtZW50LmJvZHkpLmhlaWdodCgpKVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ29iamVjdCcpICAgICAgICAgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wID0gb2Zmc2V0XG4gICAgaWYgKHR5cGVvZiBvZmZzZXRUb3AgPT0gJ2Z1bmN0aW9uJykgICAgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcCh0aGlzLiRlbGVtZW50KVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0Qm90dG9tID09ICdmdW5jdGlvbicpIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b20odGhpcy4kZWxlbWVudClcblxuICAgIHZhciBhZmZpeCA9IHRoaXMuZ2V0U3RhdGUoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCAhPSBhZmZpeCkge1xuICAgICAgaWYgKHRoaXMudW5waW4gIT0gbnVsbCkgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsICcnKVxuXG4gICAgICB2YXIgYWZmaXhUeXBlID0gJ2FmZml4JyArIChhZmZpeCA/ICctJyArIGFmZml4IDogJycpXG4gICAgICB2YXIgZSAgICAgICAgID0gJC5FdmVudChhZmZpeFR5cGUgKyAnLmJzLmFmZml4JylcblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgdGhpcy5hZmZpeGVkID0gYWZmaXhcbiAgICAgIHRoaXMudW5waW4gPSBhZmZpeCA9PSAnYm90dG9tJyA/IHRoaXMuZ2V0UGlubmVkT2Zmc2V0KCkgOiBudWxsXG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKVxuICAgICAgICAuYWRkQ2xhc3MoYWZmaXhUeXBlKVxuICAgICAgICAudHJpZ2dlcihhZmZpeFR5cGUucmVwbGFjZSgnYWZmaXgnLCAnYWZmaXhlZCcpICsgJy5icy5hZmZpeCcpXG4gICAgfVxuXG4gICAgaWYgKGFmZml4ID09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldCh7XG4gICAgICAgIHRvcDogc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0IC0gb2Zmc2V0Qm90dG9tXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQUZGSVggUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYWZmaXgnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFmZml4JywgKGRhdGEgPSBuZXcgQWZmaXgodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFmZml4XG5cbiAgJC5mbi5hZmZpeCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFmZml4LkNvbnN0cnVjdG9yID0gQWZmaXhcblxuXG4gIC8vIEFGRklYIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hZmZpeC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWZmaXggPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBRkZJWCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJhZmZpeFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSA9ICRzcHkuZGF0YSgpXG5cbiAgICAgIGRhdGEub2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwge31cblxuICAgICAgaWYgKGRhdGEub2Zmc2V0Qm90dG9tICE9IG51bGwpIGRhdGEub2Zmc2V0LmJvdHRvbSA9IGRhdGEub2Zmc2V0Qm90dG9tXG4gICAgICBpZiAoZGF0YS5vZmZzZXRUb3AgICAgIT0gbnVsbCkgZGF0YS5vZmZzZXQudG9wICAgID0gZGF0YS5vZmZzZXRUb3BcblxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgZGF0YSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjUnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBidXR0b24uanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNidXR0b25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQlVUVE9OIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBCdXR0b24gPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gJC5leHRlbmQoe30sIEJ1dHRvbi5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gIH1cblxuICBCdXR0b24uVkVSU0lPTiAgPSAnMy4zLjUnXG5cbiAgQnV0dG9uLkRFRkFVTFRTID0ge1xuICAgIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZCAgICA9ICdkaXNhYmxlZCdcbiAgICB2YXIgJGVsICA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgdmFsICA9ICRlbC5pcygnaW5wdXQnKSA/ICd2YWwnIDogJ2h0bWwnXG4gICAgdmFyIGRhdGEgPSAkZWwuZGF0YSgpXG5cbiAgICBzdGF0ZSArPSAnVGV4dCdcblxuICAgIGlmIChkYXRhLnJlc2V0VGV4dCA9PSBudWxsKSAkZWwuZGF0YSgncmVzZXRUZXh0JywgJGVsW3ZhbF0oKSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gPT0gbnVsbCA/IHRoaXMub3B0aW9uc1tzdGF0ZV0gOiBkYXRhW3N0YXRlXSlcblxuICAgICAgaWYgKHN0YXRlID09ICdsb2FkaW5nVGV4dCcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICAgIH1cbiAgICB9LCB0aGlzKSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZVxuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKVxuICAgICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgICBpZiAoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSkgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICRwYXJlbnQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgfSBlbHNlIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdjaGVja2JveCcpIHtcbiAgICAgICAgaWYgKCgkaW5wdXQucHJvcCgnY2hlY2tlZCcpKSAhPT0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgfVxuICAgICAgJGlucHV0LnByb3AoJ2NoZWNrZWQnLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSlcbiAgICAgIGlmIChjaGFuZ2VkKSAkaW5wdXQudHJpZ2dlcignY2hhbmdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLXByZXNzZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQlVUVE9OIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5idXR0b24nKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicsIChkYXRhID0gbmV3IEJ1dHRvbih0aGlzLCBvcHRpb25zKSkpXG5cbiAgICAgIGlmIChvcHRpb24gPT0gJ3RvZ2dsZScpIGRhdGEudG9nZ2xlKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmJ1dHRvblxuXG4gICQuZm4uYnV0dG9uICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuICAvLyBCVVRUT04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5idXR0b24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmJ1dHRvbiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICRidG4gPSAkKGUudGFyZ2V0KVxuICAgICAgaWYgKCEkYnRuLmhhc0NsYXNzKCdidG4nKSkgJGJ0biA9ICRidG4uY2xvc2VzdCgnLmJ0bicpXG4gICAgICBQbHVnaW4uY2FsbCgkYnRuLCAndG9nZ2xlJylcbiAgICAgIGlmICghKCQoZS50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSB8fCAkKGUudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykpKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZS50eXBlKSlcbiAgICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY2Fyb3VzZWwuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjYXJvdXNlbFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENBUk9VU0VMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRpbmRpY2F0b3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuY2Fyb3VzZWwtaW5kaWNhdG9ycycpXG4gICAgdGhpcy5vcHRpb25zICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLnBhdXNlZCAgICAgID0gbnVsbFxuICAgIHRoaXMuc2xpZGluZyAgICAgPSBudWxsXG4gICAgdGhpcy5pbnRlcnZhbCAgICA9IG51bGxcbiAgICB0aGlzLiRhY3RpdmUgICAgID0gbnVsbFxuICAgIHRoaXMuJGl0ZW1zICAgICAgPSBudWxsXG5cbiAgICB0aGlzLm9wdGlvbnMua2V5Ym9hcmQgJiYgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSlcblxuICAgIHRoaXMub3B0aW9ucy5wYXVzZSA9PSAnaG92ZXInICYmICEoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMucGF1c2UsIHRoaXMpKVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmN5Y2xlLCB0aGlzKSlcbiAgfVxuXG4gIENhcm91c2VsLlZFUlNJT04gID0gJzMuMy41J1xuXG4gIENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDBcblxuICBDYXJvdXNlbC5ERUZBVUxUUyA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBwYXVzZTogJ2hvdmVyJyxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgY2FzZSAzNzogdGhpcy5wcmV2KCk7IGJyZWFrXG4gICAgICBjYXNlIDM5OiB0aGlzLm5leHQoKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IHJldHVyblxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlIHx8ICh0aGlzLnBhdXNlZCA9IGZhbHNlKVxuXG4gICAgdGhpcy5pbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICB0aGlzLm9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICYmICF0aGlzLnBhdXNlZFxuICAgICAgJiYgKHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMubmV4dCwgdGhpcyksIHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy4kaXRlbXMgPSBpdGVtLnBhcmVudCgpLmNoaWxkcmVuKCcuaXRlbScpXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmluZGV4KGl0ZW0gfHwgdGhpcy4kYWN0aXZlKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCBhY3RpdmUpIHtcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleChhY3RpdmUpXG4gICAgdmFyIHdpbGxXcmFwID0gKGRpcmVjdGlvbiA9PSAncHJldicgJiYgYWN0aXZlSW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgfHwgKGRpcmVjdGlvbiA9PSAnbmV4dCcgJiYgYWN0aXZlSW5kZXggPT0gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpKVxuICAgIGlmICh3aWxsV3JhcCAmJiAhdGhpcy5vcHRpb25zLndyYXApIHJldHVybiBhY3RpdmVcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT0gJ3ByZXYnID8gLTEgOiAxXG4gICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuJGl0ZW1zLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5lcShpdGVtSW5kZXgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIHRoYXQgICAgICAgID0gdGhpc1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJykpXG5cbiAgICBpZiAocG9zID4gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpIHx8IHBvcyA8IDApIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc2xpZGluZykgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQub25lKCdzbGlkLmJzLmNhcm91c2VsJywgZnVuY3Rpb24gKCkgeyB0aGF0LnRvKHBvcykgfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmIChhY3RpdmVJbmRleCA9PSBwb3MpIHJldHVybiB0aGlzLnBhdXNlKCkuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUocG9zID4gYWN0aXZlSW5kZXggPyAnbmV4dCcgOiAncHJldicsIHRoaXMuJGl0ZW1zLmVxKHBvcykpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gdHJ1ZSlcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJy5uZXh0LCAucHJldicpLmxlbmd0aCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsID0gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCduZXh0JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCdwcmV2JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zbGlkZSA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0KSB7XG4gICAgdmFyICRhY3RpdmUgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJylcbiAgICB2YXIgJG5leHQgICAgID0gbmV4dCB8fCB0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24odHlwZSwgJGFjdGl2ZSlcbiAgICB2YXIgaXNDeWNsaW5nID0gdGhpcy5pbnRlcnZhbFxuICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB2YXIgdGhhdCAgICAgID0gdGhpc1xuXG4gICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuICh0aGlzLnNsaWRpbmcgPSBmYWxzZSlcblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJG5leHRbMF1cbiAgICB2YXIgc2xpZGVFdmVudCA9ICQuRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSlcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZGVFdmVudClcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLnNsaWRpbmcgPSB0cnVlXG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICBpZiAodGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgdmFyICRuZXh0SW5kaWNhdG9yID0gJCh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoJG5leHQpXSlcbiAgICAgICRuZXh0SW5kaWNhdG9yICYmICRuZXh0SW5kaWNhdG9yLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIHZhciBzbGlkRXZlbnQgPSAkLkV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3NsaWRlJykpIHtcbiAgICAgICRuZXh0LmFkZENsYXNzKHR5cGUpXG4gICAgICAkbmV4dFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJG5leHQucmVtb3ZlQ2xhc3MoW3R5cGUsIGRpcmVjdGlvbl0uam9pbignICcpKS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKFsnYWN0aXZlJywgZGlyZWN0aW9uXS5qb2luKCcgJykpXG4gICAgICAgICAgdGhhdC5zbGlkaW5nID0gZmFsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfSBlbHNlIHtcbiAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkbmV4dC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgIH1cblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENhcm91c2VsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgdmFyIGFjdGlvbiAgPSB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9ucy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJywgKGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ251bWJlcicpIGRhdGEudG8ob3B0aW9uKVxuICAgICAgZWxzZSBpZiAoYWN0aW9uKSBkYXRhW2FjdGlvbl0oKVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5pbnRlcnZhbCkgZGF0YS5wYXVzZSgpLmN5Y2xlKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY2Fyb3VzZWxcblxuICAkLmZuLmNhcm91c2VsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuXG5cbiAgLy8gQ0FST1VTRUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNhcm91c2VsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jYXJvdXNlbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiA9ICR0aGlzLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcbiAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2Nhcm91c2VsJykpIHJldHVyblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG4gICAgdmFyIHNsaWRlSW5kZXggPSAkdGhpcy5hdHRyKCdkYXRhLXNsaWRlLXRvJylcbiAgICBpZiAoc2xpZGVJbmRleCkgb3B0aW9ucy5pbnRlcnZhbCA9IGZhbHNlXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb25zKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICR0YXJnZXQuZGF0YSgnYnMuY2Fyb3VzZWwnKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlLXRvXScsIGNsaWNrSGFuZGxlcilcblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNhcm91c2VsID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjb2xsYXBzZS5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2NvbGxhcHNlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ09MTEFQU0UgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2UuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy4kdHJpZ2dlciAgICAgID0gJCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnICsgZWxlbWVudC5pZCArICdcIl0sJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdJylcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBudWxsXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LCB0aGlzLiR0cmlnZ2VyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlKSB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBDb2xsYXBzZS5WRVJTSU9OICA9ICczLjMuNSdcblxuICBDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzUwXG5cbiAgQ29sbGFwc2UuREVGQVVMVFMgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuY2hpbGRyZW4oJy5wYW5lbCcpLmNoaWxkcmVuKCcuaW4sIC5jb2xsYXBzaW5nJylcblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnc2hvdy5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIFBsdWdpbi5jYWxsKGFjdGl2ZXMsICdoaWRlJylcbiAgICAgIGFjdGl2ZXNEYXRhIHx8IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnLCBudWxsKVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpW2RpbWVuc2lvbl0oMClcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZSBpbicpW2RpbWVuc2lvbl0oJycpXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHZhciBzY3JvbGxTaXplID0gJC5jYW1lbENhc2UoWydzY3JvbGwnLCBkaW1lbnNpb25dLmpvaW4oJy0nKSlcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pW2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFswXVtzY3JvbGxTaXplXSlcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSgpKVswXS5vZmZzZXRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlIGluJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIFtkaW1lbnNpb25dKDApXG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykgPyAnaGlkZScgOiAnc2hvdyddKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQodGhpcy5vcHRpb25zLnBhcmVudClcbiAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLm9wdGlvbnMucGFyZW50ICsgJ1wiXScpXG4gICAgICAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJGVsZW1lbnQpLCAkZWxlbWVudClcbiAgICAgIH0sIHRoaXMpKVxuICAgICAgLmVuZCgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkdHJpZ2dlcikge1xuICAgIHZhciBpc09wZW4gPSAkZWxlbWVudC5oYXNDbGFzcygnaW4nKVxuXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICAkdHJpZ2dlclxuICAgICAgLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNPcGVuKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdHJpZ2dlcikge1xuICAgIHZhciBocmVmXG4gICAgdmFyIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgIHx8IChocmVmID0gJHRyaWdnZXIuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICByZXR1cm4gJCh0YXJnZXQpXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9ucy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChvcHRpb24pKSBvcHRpb25zLnRvZ2dsZSA9IGZhbHNlXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJywgKGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmNvbGxhcHNlXG5cbiAgJC5mbi5jb2xsYXBzZSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmNvbGxhcHNlLkNvbnN0cnVjdG9yID0gQ29sbGFwc2VcblxuXG4gIC8vIENPTExBUFNFIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5jb2xsYXBzZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY29sbGFwc2UgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDT0xMQVBTRSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG5cbiAgICBpZiAoISR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdmFyICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdGhpcylcbiAgICB2YXIgZGF0YSAgICA9ICR0YXJnZXQuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgIHZhciBvcHRpb24gID0gZGF0YSA/ICd0b2dnbGUnIDogJHRoaXMuZGF0YSgpXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuNSdcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgaWYgKGUgJiYgZS50eXBlID09ICdjbGljaycgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSAmJiAkLmNvbnRhaW5zKCRwYXJlbnRbMF0sIGUudGFyZ2V0KSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJ2hpZGRlbi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBjbGVhck1lbnVzKClcblxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgISRwYXJlbnQuY2xvc2VzdCgnLm5hdmJhci1uYXYnKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgLmFkZENsYXNzKCdkcm9wZG93bi1iYWNrZHJvcCcpXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQodGhpcykpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSB8fCAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpKSByZXR1cm5cblxuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBpZiAoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcgfHwgaXNBY3RpdmUgJiYgZS53aGljaCA9PSAyNykge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCcuZHJvcGRvd24tbWVudScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93bi1tZW51JywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBtb2RhbC5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI21vZGFsc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIE1PREFMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zICAgICAgICAgICAgID0gb3B0aW9uc1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgICAgICA9ICQoZG9jdW1lbnQuYm9keSlcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy4kZGlhbG9nICAgICAgICAgICAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcubW9kYWwtZGlhbG9nJylcbiAgICB0aGlzLiRiYWNrZHJvcCAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5pc1Nob3duICAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkICAgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoICAgICAgPSAwXG4gICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3RlKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5maW5kKCcubW9kYWwtY29udGVudCcpXG4gICAgICAgIC5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsICQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignbG9hZGVkLmJzLm1vZGFsJylcbiAgICAgICAgfSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwuVkVSU0lPTiAgPSAnMy4zLjUnXG5cbiAgTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDMwMFxuICBNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgTW9kYWwuREVGQVVMVFMgPSB7XG4gICAgYmFja2Ryb3A6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgc2hvdzogdHJ1ZVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmlzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdzaG93LmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAodGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9uKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub25lKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhhdC4kZWxlbWVudCkpIHRoYXQuaWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGF0LiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJylcblxuICAgICAgaWYgKCF0aGF0LiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgICB0aGF0LiRlbGVtZW50LmFwcGVuZFRvKHRoYXQuJGJvZHkpIC8vIGRvbid0IG1vdmUgbW9kYWxzIGRvbSBwb3NpdGlvblxuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKVxuXG4gICAgICB0aGF0LmFkanVzdERpYWxvZygpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcblxuICAgICAgdGhhdC5lbmZvcmNlRm9jdXMoKVxuXG4gICAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3duLmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgICB0cmFuc2l0aW9uID9cbiAgICAgICAgdGhhdC4kZGlhbG9nIC8vIHdhaXQgZm9yIG1vZGFsIHRvIHNsaWRlIGluXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBlID0gJC5FdmVudCgnaGlkZS5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gZmFsc2VcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXG4gICAgICAub2ZmKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICAgIC5vZmYoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRkaWFsb2cub2ZmKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KHRoaXMuaGlkZU1vZGFsLCB0aGlzKSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHRoaXMuaGlkZU1vZGFsKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lbmZvcmNlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbignZm9jdXNpbi5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmICF0aGlzLiRlbGVtZW50LmhhcyhlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93bikge1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYnMubW9kYWwnLCAkLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLCB0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRib2R5LnJlbW92ZUNsYXNzKCdtb2RhbC1vcGVuJylcbiAgICAgIHRoYXQucmVzZXRBZGp1c3RtZW50cygpXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcbiAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuLmJzLm1vZGFsJylcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgdGhpcy4kYmFja2Ryb3AgPSBudWxsXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuYmFja2Ryb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcblxuICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlKVxuICAgICAgICAuYXBwZW5kVG8odGhpcy4kYm9keSlcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICB0aGlzLm9wdGlvbnMuYmFja2Ryb3AgPT0gJ3N0YXRpYydcbiAgICAgICAgICA/IHRoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKVxuICAgICAgICAgIDogdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuXG4gICAgICBpZiAoZG9BbmltYXRlKSB0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcblxuICAgICAgdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJylcblxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgIGRvQW5pbWF0ZSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2spXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2soKVxuXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duICYmIHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICB0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgICB2YXIgY2FsbGJhY2tSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQucmVtb3ZlQmFja2Ryb3AoKVxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrUmVtb3ZlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrUmVtb3ZlKClcblxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyB0aGVzZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG5cbiAgTW9kYWwucHJvdG90eXBlLmhhbmRsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkanVzdERpYWxvZygpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuYWRqdXN0RGlhbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RhbElzT3ZlcmZsb3dpbmcgPSB0aGlzLiRlbGVtZW50WzBdLnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAgIXRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiB0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmICFtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0QWRqdXN0bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICcnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuY2hlY2tTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZ1bGxXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgaWYgKCFmdWxsV2luZG93V2lkdGgpIHsgLy8gd29ya2Fyb3VuZCBmb3IgbWlzc2luZyB3aW5kb3cuaW5uZXJXaWR0aCBpbiBJRThcbiAgICAgIHZhciBkb2N1bWVudEVsZW1lbnRSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBmdWxsV2luZG93V2lkdGggPSBkb2N1bWVudEVsZW1lbnRSZWN0LnJpZ2h0IC0gTWF0aC5hYnMoZG9jdW1lbnRFbGVtZW50UmVjdC5sZWZ0KVxuICAgIH1cbiAgICB0aGlzLmJvZHlJc092ZXJmbG93aW5nID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCA8IGZ1bGxXaW5kb3dXaWR0aFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLm1lYXN1cmVTY3JvbGxiYXIoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9keVBhZCA9IHBhcnNlSW50KCh0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcpIHx8IDApLCAxMClcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0IHx8ICcnXG4gICAgaWYgKHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCB0aGlzLm9yaWdpbmFsQm9keVBhZClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xuICAgIHRoaXMuJGJvZHkuYXBwZW5kKHNjcm9sbERpdilcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG5cbiAgLy8gTU9EQUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uLCBfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLm1vZGFsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLm1vZGFsJywgKGRhdGEgPSBuZXcgTW9kYWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5tb2RhbFxuXG4gICQuZm4ubW9kYWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuICAvLyBNT0RBTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ubW9kYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLm1vZGFsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMubW9kYWwuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciBocmVmICAgID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy41J1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG5cbiAgLy8gUE9QT1ZFUiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChvcHRpb24pKSByZXR1cm5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnBvcG92ZXJcblxuICAkLmZuLnBvcG92ZXIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG5cbiAgLy8gUE9QT1ZFUiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5wb3BvdmVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5wb3BvdmVyID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogc2Nyb2xsc3B5LmpzIHYzLjMuNVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jc2Nyb2xsc3B5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU0NST0xMU1BZIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudCA9ICQoZWxlbWVudCkuaXMoZG9jdW1lbnQuYm9keSkgPyAkKHdpbmRvdykgOiAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9ICQuZXh0ZW5kKHt9LCBTY3JvbGxTcHkuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5zZWxlY3RvciAgICAgICA9ICh0aGlzLm9wdGlvbnMudGFyZ2V0IHx8ICcnKSArICcgLm5hdiBsaSA+IGEnXG4gICAgdGhpcy5vZmZzZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbEhlaWdodCAgID0gMFxuXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudC5vbignc2Nyb2xsLmJzLnNjcm9sbHNweScsICQucHJveHkodGhpcy5wcm9jZXNzLCB0aGlzKSlcbiAgICB0aGlzLnJlZnJlc2goKVxuICAgIHRoaXMucHJvY2VzcygpXG4gIH1cblxuICBTY3JvbGxTcHkuVkVSU0lPTiAgPSAnMy4zLjUnXG5cbiAgU2Nyb2xsU3B5LkRFRkFVTFRTID0ge1xuICAgIG9mZnNldDogMTBcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodClcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICA9IHRoaXNcbiAgICB2YXIgb2Zmc2V0TWV0aG9kICA9ICdvZmZzZXQnXG4gICAgdmFyIG9mZnNldEJhc2UgICAgPSAwXG5cbiAgICB0aGlzLm9mZnNldHMgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgPSBbXVxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgaWYgKCEkLmlzV2luZG93KHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0pKSB7XG4gICAgICBvZmZzZXRNZXRob2QgPSAncG9zaXRpb24nXG4gICAgICBvZmZzZXRCYXNlICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpXG4gICAgfVxuXG4gICAgdGhpcy4kYm9keVxuICAgICAgLmZpbmQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsICAgPSAkKHRoaXMpXG4gICAgICAgIHZhciBocmVmICA9ICRlbC5kYXRhKCd0YXJnZXQnKSB8fCAkZWwuYXR0cignaHJlZicpXG4gICAgICAgIHZhciAkaHJlZiA9IC9eIy4vLnRlc3QoaHJlZikgJiYgJChocmVmKVxuXG4gICAgICAgIHJldHVybiAoJGhyZWZcbiAgICAgICAgICAmJiAkaHJlZi5sZW5ndGhcbiAgICAgICAgICAmJiAkaHJlZi5pcygnOnZpc2libGUnKVxuICAgICAgICAgICYmIFtbJGhyZWZbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIGhyZWZdXSkgfHwgbnVsbFxuICAgICAgfSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXSB9KVxuICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0Lm9mZnNldHMucHVzaCh0aGlzWzBdKVxuICAgICAgICB0aGF0LnRhcmdldHMucHVzaCh0aGlzWzFdKVxuICAgICAgfSlcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSArIHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuICAgIHZhciBtYXhTY3JvbGwgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy4kc2Nyb2xsRWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXRzICAgICAgPSB0aGlzLm9mZnNldHNcbiAgICB2YXIgdGFyZ2V0cyAgICAgID0gdGhpcy50YXJnZXRzXG4gICAgdmFyIGFjdGl2ZVRhcmdldCA9IHRoaXMuYWN0aXZlVGFyZ2V0XG4gICAgdmFyIGlcblxuICAgIGlmICh0aGlzLnNjcm9sbEhlaWdodCAhPSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIHJldHVybiBhY3RpdmVUYXJnZXQgIT0gKGkgPSB0YXJnZXRzW3RhcmdldHMubGVuZ3RoIC0gMV0pICYmIHRoaXMuYWN0aXZhdGUoaSlcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IG9mZnNldHNbMF0pIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBhY3RpdmVUYXJnZXQgIT0gdGFyZ2V0c1tpXVxuICAgICAgICAmJiBzY3JvbGxUb3AgPj0gb2Zmc2V0c1tpXVxuICAgICAgICAmJiAob2Zmc2V0c1tpICsgMV0gPT09IHVuZGVmaW5lZCB8fCBzY3JvbGxUb3AgPCBvZmZzZXRzW2kgKyAxXSlcbiAgICAgICAgJiYgdGhpcy5hY3RpdmF0ZSh0YXJnZXRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgPSB0YXJnZXRcblxuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArXG4gICAgICAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArXG4gICAgICB0aGlzLnNlbGVjdG9yICsgJ1tocmVmPVwiJyArIHRhcmdldCArICdcIl0nXG5cbiAgICB2YXIgYWN0aXZlID0gJChzZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzKCdsaScpXG4gICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG5cbiAgICBpZiAoYWN0aXZlLnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKS5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZSA9IGFjdGl2ZVxuICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgYWN0aXZlLnRyaWdnZXIoJ2FjdGl2YXRlLmJzLnNjcm9sbHNweScpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCwgJy5hY3RpdmUnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JywgKGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5zY3JvbGxzcHlcblxuICAkLmZuLnNjcm9sbHNweSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3RvciA9IFNjcm9sbFNweVxuXG5cbiAgLy8gU0NST0xMU1BZIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5zY3JvbGxzcHkgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRhYi5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RhYnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUQUIgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUYWIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlRG9sbGFyQmVmb3JlalF1ZXJ5QXNzaWdubWVudFxuICAgIHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAvLyBqc2NzOmVuYWJsZSByZXF1aXJlRG9sbGFyQmVmb3JlalF1ZXJ5QXNzaWdubWVudFxuICB9XG5cbiAgVGFiLlZFUlNJT04gPSAnMy4zLjUnXG5cbiAgVGFiLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUYWIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aGlzICAgID0gdGhpcy5lbGVtZW50XG4gICAgdmFyICR1bCAgICAgID0gJHRoaXMuY2xvc2VzdCgndWw6bm90KC5kcm9wZG93bi1tZW51KScpXG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuZGF0YSgndGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgaWYgKCR0aGlzLnBhcmVudCgnbGknKS5oYXNDbGFzcygnYWN0aXZlJykpIHJldHVyblxuXG4gICAgdmFyICRwcmV2aW91cyA9ICR1bC5maW5kKCcuYWN0aXZlOmxhc3QgYScpXG4gICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoJ2hpZGUuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICB9KVxuICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KCdzaG93LmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgIH0pXG5cbiAgICAkcHJldmlvdXMudHJpZ2dlcihoaWRlRXZlbnQpXG4gICAgJHRoaXMudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRhcmdldCA9ICQoc2VsZWN0b3IpXG5cbiAgICB0aGlzLmFjdGl2YXRlKCR0aGlzLmNsb3Nlc3QoJ2xpJyksICR1bClcbiAgICB0aGlzLmFjdGl2YXRlKCR0YXJnZXQsICR0YXJnZXQucGFyZW50KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICRwcmV2aW91cy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2hpZGRlbi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgICAgfSlcbiAgICAgICR0aGlzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnc2hvd24uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBUYWIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICB2YXIgJGFjdGl2ZSAgICA9IGNvbnRhaW5lci5maW5kKCc+IC5hY3RpdmUnKVxuICAgIHZhciB0cmFuc2l0aW9uID0gY2FsbGJhY2tcbiAgICAgICYmICQuc3VwcG9ydC50cmFuc2l0aW9uXG4gICAgICAmJiAoJGFjdGl2ZS5sZW5ndGggJiYgJGFjdGl2ZS5oYXNDbGFzcygnZmFkZScpIHx8ICEhY29udGFpbmVyLmZpbmQoJz4gLmZhZGUnKS5sZW5ndGgpXG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCc+IC5kcm9wZG93bi1tZW51ID4gLmFjdGl2ZScpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgICAgZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyByZWZsb3cgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnZmFkZScpXG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKS5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICAkYWN0aXZlLmxlbmd0aCAmJiB0cmFuc2l0aW9uID9cbiAgICAgICRhY3RpdmVcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgbmV4dClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBuZXh0KClcblxuICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2luJylcbiAgfVxuXG5cbiAgLy8gVEFCIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLnRhYicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudGFiJywgKGRhdGEgPSBuZXcgVGFiKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50YWJcblxuICAkLmZuLnRhYiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRhYi5Db25zdHJ1Y3RvciA9IFRhYlxuXG5cbiAgLy8gVEFCIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQuZm4udGFiLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50YWIgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBUQUIgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgUGx1Z2luLmNhbGwoJCh0aGlzKSwgJ3Nob3cnKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nLCBjbGlja0hhbmRsZXIpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsIGNsaWNrSGFuZGxlcilcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRvb2x0aXAuanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0b29sdGlwXG4gKiBJbnNwaXJlZCBieSB0aGUgb3JpZ2luYWwgalF1ZXJ5LnRpcHN5IGJ5IEphc29uIEZyYW1lXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVE9PTFRJUCBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSAgICAgICA9IG51bGxcbiAgICB0aGlzLm9wdGlvbnMgICAgPSBudWxsXG4gICAgdGhpcy5lbmFibGVkICAgID0gbnVsbFxuICAgIHRoaXMudGltZW91dCAgICA9IG51bGxcbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG4gICAgdGhpcy4kZWxlbWVudCAgID0gbnVsbFxuICAgIHRoaXMuaW5TdGF0ZSAgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy41J1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMudmlld3BvcnQpID8gdGhpcy5vcHRpb25zLnZpZXdwb3J0LmNhbGwodGhpcywgdGhpcy4kZWxlbWVudCkgOiAodGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy52aWV3cG9ydCkpXG4gICAgdGhpcy5pblN0YXRlICAgPSB7IGNsaWNrOiBmYWxzZSwgaG92ZXI6IGZhbHNlLCBmb2N1czogZmFsc2UgfVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciAmJiAhdGhpcy5vcHRpb25zLnNlbGVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nICcgKyB0aGlzLnR5cGUgKyAnIG9uIHRoZSB3aW5kb3cuZG9jdW1lbnQgb2JqZWN0IScpXG4gICAgfVxuXG4gICAgdmFyIHRyaWdnZXJzID0gdGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgZm9yICh2YXIgaSA9IHRyaWdnZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXVxuXG4gICAgICBpZiAodHJpZ2dlciA9PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLnRvZ2dsZSwgdGhpcykpXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgdmFyIGV2ZW50SW4gID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlZW50ZXInIDogJ2ZvY3VzaW4nXG4gICAgICAgIHZhciBldmVudE91dCA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWxlYXZlJyA6ICdmb2N1c291dCdcblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50SW4gICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5lbnRlciwgdGhpcykpXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRPdXQgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmxlYXZlLCB0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgP1xuICAgICAgKHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7IHRyaWdnZXI6ICdtYW51YWwnLCBzZWxlY3RvcjogJycgfSkpIDpcbiAgICAgIHRoaXMuZml4VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRvb2x0aXAuREVGQVVMVFNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5nZXREZWZhdWx0cygpLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLmRlbGF5ICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ID09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBoaWRlOiBvcHRpb25zLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSB7fVxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZ2V0RGVmYXVsdHMoKVxuXG4gICAgdGhpcy5fb3B0aW9ucyAmJiAkLmVhY2godGhpcy5fb3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChkZWZhdWx0c1trZXldICE9IHZhbHVlKSBvcHRpb25zW2tleV0gPSB2YWx1ZVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mICQuRXZlbnQpIHtcbiAgICAgIHNlbGYuaW5TdGF0ZVtvYmoudHlwZSA9PSAnZm9jdXNpbicgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgfHwgc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpIHJldHVybiBzZWxmLnNob3coKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHNlbGYuc2hvdygpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmluU3RhdGVba2V5XSkgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiAkLkV2ZW50KSB7XG4gICAgICBzZWxmLmluU3RhdGVbb2JqLnR5cGUgPT0gJ2ZvY3Vzb3V0JyA/ICdmb2N1cycgOiAnaG92ZXInXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSByZXR1cm5cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnb3V0J1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5oaWRlKSByZXR1cm4gc2VsZi5oaWRlKClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnb3V0Jykgc2VsZi5oaWRlKClcbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93LmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAodGhpcy5oYXNDb250ZW50KCkgJiYgdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgdmFyIGluRG9tID0gJC5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWluRG9tKSByZXR1cm5cbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcblxuICAgICAgdmFyIHRpcElkID0gdGhpcy5nZXRVSUQodGhpcy50eXBlKVxuXG4gICAgICB0aGlzLnNldENvbnRlbnQoKVxuICAgICAgJHRpcC5hdHRyKCdpZCcsIHRpcElkKVxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSAkdGlwLmFkZENsYXNzKCdmYWRlJylcblxuICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50XG5cbiAgICAgIHZhciBhdXRvVG9rZW4gPSAvXFxzP2F1dG8/XFxzPy9pXG4gICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KVxuICAgICAgaWYgKGF1dG9QbGFjZSkgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoYXV0b1Rva2VuLCAnJykgfHwgJ3RvcCdcblxuICAgICAgJHRpcFxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgZGlzcGxheTogJ2Jsb2NrJyB9KVxuICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgdGhpcylcblxuICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/ICR0aXAuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcikgOiAkdGlwLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2luc2VydGVkLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICAgIHZhciBwb3MgICAgICAgICAgPSB0aGlzLmdldFBvc2l0aW9uKClcbiAgICAgIHZhciBhY3R1YWxXaWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICB2YXIgb3JnUGxhY2VtZW50ID0gcGxhY2VtZW50XG4gICAgICAgIHZhciB2aWV3cG9ydERpbSA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpXG5cbiAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50ID09ICdib3R0b20nICYmIHBvcy5ib3R0b20gKyBhY3R1YWxIZWlnaHQgPiB2aWV3cG9ydERpbS5ib3R0b20gPyAndG9wJyAgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgIC0gYWN0dWFsSGVpZ2h0IDwgdmlld3BvcnREaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IHZpZXdwb3J0RGltLndpZHRoICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgICYmIHBvcy5sZWZ0ICAgLSBhY3R1YWxXaWR0aCAgPCB2aWV3cG9ydERpbS5sZWZ0ICAgPyAncmlnaHQnICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFxuXG4gICAgICAgICR0aXBcbiAgICAgICAgICAucmVtb3ZlQ2xhc3Mob3JnUGxhY2VtZW50KVxuICAgICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxjdWxhdGVkT2Zmc2V0ID0gdGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KGNhbGN1bGF0ZWRPZmZzZXQsIHBsYWNlbWVudClcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSB0aGF0LmhvdmVyU3RhdGVcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdzaG93bi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgICB0aGF0LmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09ICdvdXQnKSB0aGF0LmxlYXZlKHRoYXQpXG4gICAgICB9XG5cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFwcGx5UGxhY2VtZW50ID0gZnVuY3Rpb24gKG9mZnNldCwgcGxhY2VtZW50KSB7XG4gICAgdmFyICR0aXAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgd2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBoZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgLy8gbWFudWFsbHkgcmVhZCBtYXJnaW5zIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluY2x1ZGVzIGRpZmZlcmVuY2VcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi10b3AnKSwgMTApXG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLWxlZnQnKSwgMTApXG5cbiAgICAvLyB3ZSBtdXN0IGNoZWNrIGZvciBOYU4gZm9yIGllIDgvOVxuICAgIGlmIChpc05hTihtYXJnaW5Ub3ApKSAgbWFyZ2luVG9wICA9IDBcbiAgICBpZiAoaXNOYU4obWFyZ2luTGVmdCkpIG1hcmdpbkxlZnQgPSAwXG5cbiAgICBvZmZzZXQudG9wICArPSBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCArPSBtYXJnaW5MZWZ0XG5cbiAgICAvLyAkLmZuLm9mZnNldCBkb2Vzbid0IHJvdW5kIHBpeGVsIHZhbHVlc1xuICAgIC8vIHNvIHdlIHVzZSBzZXRPZmZzZXQgZGlyZWN0bHkgd2l0aCBvdXIgb3duIGZ1bmN0aW9uIEItMFxuICAgICQub2Zmc2V0LnNldE9mZnNldCgkdGlwWzBdLCAkLmV4dGVuZCh7XG4gICAgICB1c2luZzogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICR0aXAuY3NzKHtcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQocHJvcHMudG9wKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKHByb3BzLmxlZnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgb2Zmc2V0KSwgMClcblxuICAgICR0aXAuYWRkQ2xhc3MoJ2luJylcblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBwbGFjaW5nIHRpcCBpbiBuZXcgb2Zmc2V0IGNhdXNlZCB0aGUgdGlwIHRvIHJlc2l6ZSBpdHNlbGZcbiAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgaWYgKHBsYWNlbWVudCA9PSAndG9wJyAmJiBhY3R1YWxIZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBvZmZzZXQudG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodCAtIGFjdHVhbEhlaWdodFxuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKHBsYWNlbWVudCwgb2Zmc2V0LCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgaWYgKGRlbHRhLmxlZnQpIG9mZnNldC5sZWZ0ICs9IGRlbHRhLmxlZnRcbiAgICBlbHNlIG9mZnNldC50b3AgKz0gZGVsdGEudG9wXG5cbiAgICB2YXIgaXNWZXJ0aWNhbCAgICAgICAgICA9IC90b3B8Ym90dG9tLy50ZXN0KHBsYWNlbWVudClcbiAgICB2YXIgYXJyb3dEZWx0YSAgICAgICAgICA9IGlzVmVydGljYWwgPyBkZWx0YS5sZWZ0ICogMiAtIHdpZHRoICsgYWN0dWFsV2lkdGggOiBkZWx0YS50b3AgKiAyIC0gaGVpZ2h0ICsgYWN0dWFsSGVpZ2h0XG4gICAgdmFyIGFycm93T2Zmc2V0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnXG5cbiAgICAkdGlwLm9mZnNldChvZmZzZXQpXG4gICAgdGhpcy5yZXBsYWNlQXJyb3coYXJyb3dEZWx0YSwgJHRpcFswXVthcnJvd09mZnNldFBvc2l0aW9uXSwgaXNWZXJ0aWNhbClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnJlcGxhY2VBcnJvdyA9IGZ1bmN0aW9uIChkZWx0YSwgZGltZW5zaW9uLCBpc1ZlcnRpY2FsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJywgNTAgKiAoMSAtIGRlbHRhIC8gZGltZW5zaW9uKSArICclJylcbiAgICAgIC5jc3MoaXNWZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLCAnJylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKVxuXG4gICAgJHRpcC5maW5kKCcudG9vbHRpcC1pbm5lcicpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodCcpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyICR0aXAgPSAkKHRoaXMuJHRpcClcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ2hpZGUuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgaWYgKHRoYXQuaG92ZXJTdGF0ZSAhPSAnaW4nKSAkdGlwLmRldGFjaCgpXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICR0aXBcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIGNvbXBsZXRlKClcblxuICAgIHRoaXMuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5maXhUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgaWYgKCRlLmF0dHIoJ3RpdGxlJykgfHwgdHlwZW9mICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgID8geyB0b3A6IHBvcy50b3AgLSBhY3R1YWxIZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGggfSA6XG4gICAgICAgIC8qIHBsYWNlbWVudCA9PSAncmlnaHQnICovIHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCB9XG5cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCkge1xuICAgIHZhciBkZWx0YSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH1cbiAgICBpZiAoIXRoaXMuJHZpZXdwb3J0KSByZXR1cm4gZGVsdGFcblxuICAgIHZhciB2aWV3cG9ydFBhZGRpbmcgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgdGhpcy5vcHRpb25zLnZpZXdwb3J0LnBhZGRpbmcgfHwgMFxuICAgIHZhciB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgaWYgKC9yaWdodHxsZWZ0Ly50ZXN0KHBsYWNlbWVudCkpIHtcbiAgICAgIHZhciB0b3BFZGdlT2Zmc2V0ICAgID0gcG9zLnRvcCAtIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGxcbiAgICAgIHZhciBib3R0b21FZGdlT2Zmc2V0ID0gcG9zLnRvcCArIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGwgKyBhY3R1YWxIZWlnaHRcbiAgICAgIGlmICh0b3BFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLnRvcCkgeyAvLyB0b3Agb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCAtIHRvcEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAoYm90dG9tRWRnZU9mZnNldCA+IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0KSB7IC8vIGJvdHRvbSBvdmVyZmxvd1xuICAgICAgICBkZWx0YS50b3AgPSB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAtIGJvdHRvbUVkZ2VPZmZzZXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZnRFZGdlT2Zmc2V0ICA9IHBvcy5sZWZ0IC0gdmlld3BvcnRQYWRkaW5nXG4gICAgICB2YXIgcmlnaHRFZGdlT2Zmc2V0ID0gcG9zLmxlZnQgKyB2aWV3cG9ydFBhZGRpbmcgKyBhY3R1YWxXaWR0aFxuICAgICAgaWYgKGxlZnRFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLmxlZnQpIHsgLy8gbGVmdCBvdmVyZmxvd1xuICAgICAgICBkZWx0YS5sZWZ0ID0gdmlld3BvcnREaW1lbnNpb25zLmxlZnQgLSBsZWZ0RWRnZU9mZnNldFxuICAgICAgfSBlbHNlIGlmIChyaWdodEVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMucmlnaHQpIHsgLy8gcmlnaHQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgdmlld3BvcnREaW1lbnNpb25zLndpZHRoIC0gcmlnaHRFZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGl0bGVcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICB0aXRsZSA9ICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICAgICAgfHwgKHR5cGVvZiBvLnRpdGxlID09ICdmdW5jdGlvbicgPyBvLnRpdGxlLmNhbGwoJGVbMF0pIDogIG8udGl0bGUpXG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFVJRCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBkbyBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApXG4gICAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudGlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy4kdGlwKSB7XG4gICAgICB0aGlzLiR0aXAgPSAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSlcbiAgICAgIGlmICh0aGlzLiR0aXAubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudHlwZSArICcgYHRlbXBsYXRlYCBvcHRpb24gbXVzdCBjb25zaXN0IG9mIGV4YWN0bHkgMSB0b3AtbGV2ZWwgZWxlbWVudCEnKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kdGlwXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBzZWxmLmluU3RhdGUuY2xpY2sgPSAhc2VsZi5pblN0YXRlLmNsaWNrXG4gICAgICBpZiAoc2VsZi5pc0luU3RhdGVUcnVlKCkpIHNlbGYuZW50ZXIoc2VsZilcbiAgICAgIGVsc2Ugc2VsZi5sZWF2ZShzZWxmKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRpcCgpLmhhc0NsYXNzKCdpbicpID8gc2VsZi5sZWF2ZShzZWxmKSA6IHNlbGYuZW50ZXIoc2VsZilcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5oaWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub2ZmKCcuJyArIHRoYXQudHlwZSkucmVtb3ZlRGF0YSgnYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGlmICh0aGF0LiR0aXApIHtcbiAgICAgICAgdGhhdC4kdGlwLmRldGFjaCgpXG4gICAgICB9XG4gICAgICB0aGF0LiR0aXAgPSBudWxsXG4gICAgICB0aGF0LiRhcnJvdyA9IG51bGxcbiAgICAgIHRoYXQuJHZpZXdwb3J0ID0gbnVsbFxuICAgIH0pXG4gIH1cblxuXG4gIC8vIFRPT0xUSVAgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy50b29sdGlwJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3Qob3B0aW9uKSkgcmV0dXJuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50b29sdGlwXG5cbiAgJC5mbi50b29sdGlwICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udG9vbHRpcC5Db25zdHJ1Y3RvciA9IFRvb2x0aXBcblxuXG4gIC8vIFRPT0xUSVAgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4udG9vbHRpcC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udG9vbHRpcCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRyYW5zaXRpb24uanMgdjMuMy41XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0cmFuc2l0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKGVsLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kOiB0cmFuc0VuZEV2ZW50TmFtZXNbbmFtZV0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgfVxuXG4gIC8vIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyICRlbCA9IHRoaXNcbiAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBpZiAoIWNhbGxlZCkgJCgkZWwpLnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSB9XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZCgpXG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICQuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQgPSB7XG4gICAgICBiaW5kVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgZGVsZWdhdGVUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyohIEBsaWNlbnNlIEZpcmViYXNlIHYyLjMuMVxuICAgIExpY2Vuc2U6IGh0dHBzOi8vd3d3LmZpcmViYXNlLmNvbS90ZXJtcy90ZXJtcy1vZi1zZXJ2aWNlLmh0bWwgKi9cbihmdW5jdGlvbigpIHt2YXIgZyxhYT10aGlzO2Z1bmN0aW9uIG4oYSl7cmV0dXJuIHZvaWQgMCE9PWF9ZnVuY3Rpb24gYmEoKXt9ZnVuY3Rpb24gY2EoYSl7YS51Yj1mdW5jdGlvbigpe3JldHVybiBhLnVmP2EudWY6YS51Zj1uZXcgYX19XG5mdW5jdGlvbiBkYShhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKXJldHVyblwiZnVuY3Rpb25cIn1lbHNlIHJldHVyblwibnVsbFwiO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn1mdW5jdGlvbiBlYShhKXtyZXR1cm5cImFycmF5XCI9PWRhKGEpfWZ1bmN0aW9uIGZhKGEpe3ZhciBiPWRhKGEpO3JldHVyblwiYXJyYXlcIj09Ynx8XCJvYmplY3RcIj09YiYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RofWZ1bmN0aW9uIHAoYSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF9ZnVuY3Rpb24gZ2EoYSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGF9ZnVuY3Rpb24gaGEoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT1kYShhKX1mdW5jdGlvbiBpYShhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9ZnVuY3Rpb24gamEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9XG5mdW5jdGlvbiBrYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBxKGEsYixjKXtxPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/amE6a2E7cmV0dXJuIHEuYXBwbHkobnVsbCxhcmd1bWVudHMpfXZhciBsYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O1xuZnVuY3Rpb24gbWEoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuYmg9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLllnPWZ1bmN0aW9uKGEsYyxmKXtmb3IodmFyIGg9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0yKSxrPTI7azxhcmd1bWVudHMubGVuZ3RoO2srKyloW2stMl09YXJndW1lbnRzW2tdO3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLGgpfX07ZnVuY3Rpb24gcihhLGIpe2Zvcih2YXIgYyBpbiBhKWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpfWZ1bmN0aW9uIG5hKGEsYil7dmFyIGM9e30sZDtmb3IoZCBpbiBhKWNbZF09Yi5jYWxsKHZvaWQgMCxhW2RdLGQsYSk7cmV0dXJuIGN9ZnVuY3Rpb24gb2EoYSxiKXtmb3IodmFyIGMgaW4gYSlpZighYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gcGEoYSl7dmFyIGI9MCxjO2ZvcihjIGluIGEpYisrO3JldHVybiBifWZ1bmN0aW9uIHFhKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiBifWZ1bmN0aW9uIHJhKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWFbZF07cmV0dXJuIGJ9ZnVuY3Rpb24gc2EoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn1mdW5jdGlvbiB0YShhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKGFbY109PWIpcmV0dXJuITA7cmV0dXJuITF9XG5mdW5jdGlvbiB1YShhLGIsYyl7Zm9yKHZhciBkIGluIGEpaWYoYi5jYWxsKGMsYVtkXSxkLGEpKXJldHVybiBkfWZ1bmN0aW9uIHZhKGEsYil7dmFyIGM9dWEoYSxiLHZvaWQgMCk7cmV0dXJuIGMmJmFbY119ZnVuY3Rpb24gd2EoYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24geGEoYSl7dmFyIGI9e30sYztmb3IoYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn12YXIgeWE9XCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIik7XG5mdW5jdGlvbiB6YShhLGIpe2Zvcih2YXIgYyxkLGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXtkPWFyZ3VtZW50c1tlXTtmb3IoYyBpbiBkKWFbY109ZFtjXTtmb3IodmFyIGY9MDtmPHlhLmxlbmd0aDtmKyspYz15YVtmXSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCxjKSYmKGFbY109ZFtjXSl9fTtmdW5jdGlvbiBBYShhKXthPVN0cmluZyhhKTtpZigvXlxccyokLy50ZXN0KGEpPzA6L15bXFxdLDp7fVxcc1xcdTIwMjhcXHUyMDI5XSokLy50ZXN0KGEucmVwbGFjZSgvXFxcXFtcIlxcXFxcXC9iZm5ydHVdL2csXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOVxceDAwLVxceDA4XFx4MGEtXFx4MWZdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpbXFxzXFx1MjAyOFxcdTIwMjldKlxcWykrL2csXCJcIikpKXRyeXtyZXR1cm4gZXZhbChcIihcIithK1wiKVwiKX1jYXRjaChiKXt9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIithKTt9ZnVuY3Rpb24gQmEoKXt0aGlzLlNkPXZvaWQgMH1cbmZ1bmN0aW9uIENhKGEsYixjKXtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJzdHJpbmdcIjpEYShiLGMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJiFpc05hTihiKT9iOlwibnVsbFwiKTticmVhaztjYXNlIFwiYm9vbGVhblwiOmMucHVzaChiKTticmVhaztjYXNlIFwidW5kZWZpbmVkXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztjYXNlIFwib2JqZWN0XCI6aWYobnVsbD09Yil7Yy5wdXNoKFwibnVsbFwiKTticmVha31pZihlYShiKSl7dmFyIGQ9Yi5sZW5ndGg7Yy5wdXNoKFwiW1wiKTtmb3IodmFyIGU9XCJcIixmPTA7ZjxkO2YrKyljLnB1c2goZSksZT1iW2ZdLENhKGEsYS5TZD9hLlNkLmNhbGwoYixTdHJpbmcoZiksZSk6ZSxjKSxlPVwiLFwiO2MucHVzaChcIl1cIik7YnJlYWt9Yy5wdXNoKFwie1wiKTtkPVwiXCI7Zm9yKGYgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixmKSYmKGU9YltmXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoYy5wdXNoKGQpLERhKGYsYyksXG5jLnB1c2goXCI6XCIpLENhKGEsYS5TZD9hLlNkLmNhbGwoYixmLGUpOmUsYyksZD1cIixcIikpO2MucHVzaChcIn1cIik7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZTogXCIrdHlwZW9mIGIpO319dmFyIEVhPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LEZhPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nOi9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nO1xuZnVuY3Rpb24gRGEoYSxiKXtiLnB1c2goJ1wiJyxhLnJlcGxhY2UoRmEsZnVuY3Rpb24oYSl7aWYoYSBpbiBFYSlyZXR1cm4gRWFbYV07dmFyIGI9YS5jaGFyQ29kZUF0KDApLGU9XCJcXFxcdVwiOzE2PmI/ZSs9XCIwMDBcIjoyNTY+Yj9lKz1cIjAwXCI6NDA5Nj5iJiYoZSs9XCIwXCIpO3JldHVybiBFYVthXT1lK2IudG9TdHJpbmcoMTYpfSksJ1wiJyl9O2Z1bmN0aW9uIEdhKCl7cmV0dXJuIE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikrTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4Kk1hdGgucmFuZG9tKCkpXmxhKCkpLnRvU3RyaW5nKDM2KX07dmFyIEhhO2E6e3ZhciBJYT1hYS5uYXZpZ2F0b3I7aWYoSWEpe3ZhciBKYT1JYS51c2VyQWdlbnQ7aWYoSmEpe0hhPUphO2JyZWFrIGF9fUhhPVwiXCJ9O2Z1bmN0aW9uIEthKCl7dGhpcy5WYT0tMX07ZnVuY3Rpb24gTGEoKXt0aGlzLlZhPS0xO3RoaXMuVmE9NjQ7dGhpcy5OPVtdO3RoaXMubWU9W107dGhpcy5XZj1bXTt0aGlzLkxkPVtdO3RoaXMuTGRbMF09MTI4O2Zvcih2YXIgYT0xO2E8dGhpcy5WYTsrK2EpdGhpcy5MZFthXT0wO3RoaXMuZGU9dGhpcy5hYz0wO3RoaXMucmVzZXQoKX1tYShMYSxLYSk7TGEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5OWzBdPTE3MzI1ODQxOTM7dGhpcy5OWzFdPTQwMjMyMzM0MTc7dGhpcy5OWzJdPTI1NjIzODMxMDI7dGhpcy5OWzNdPTI3MTczMzg3ODt0aGlzLk5bNF09MzI4NTM3NzUyMDt0aGlzLmRlPXRoaXMuYWM9MH07XG5mdW5jdGlvbiBNYShhLGIsYyl7Y3x8KGM9MCk7dmFyIGQ9YS5XZjtpZihwKGIpKWZvcih2YXIgZT0wOzE2PmU7ZSsrKWRbZV09Yi5jaGFyQ29kZUF0KGMpPDwyNHxiLmNoYXJDb2RlQXQoYysxKTw8MTZ8Yi5jaGFyQ29kZUF0KGMrMik8PDh8Yi5jaGFyQ29kZUF0KGMrMyksYys9NDtlbHNlIGZvcihlPTA7MTY+ZTtlKyspZFtlXT1iW2NdPDwyNHxiW2MrMV08PDE2fGJbYysyXTw8OHxiW2MrM10sYys9NDtmb3IoZT0xNjs4MD5lO2UrKyl7dmFyIGY9ZFtlLTNdXmRbZS04XV5kW2UtMTRdXmRbZS0xNl07ZFtlXT0oZjw8MXxmPj4+MzEpJjQyOTQ5NjcyOTV9Yj1hLk5bMF07Yz1hLk5bMV07Zm9yKHZhciBoPWEuTlsyXSxrPWEuTlszXSxsPWEuTls0XSxtLGU9MDs4MD5lO2UrKyk0MD5lPzIwPmU/KGY9a15jJihoXmspLG09MTUxODUwMDI0OSk6KGY9Y15oXmssbT0xODU5Nzc1MzkzKTo2MD5lPyhmPWMmaHxrJihjfGgpLG09MjQwMDk1OTcwOCk6KGY9Y15oXmssbT0zMzk1NDY5NzgyKSxmPShiPDxcbjV8Yj4+PjI3KStmK2wrbStkW2VdJjQyOTQ5NjcyOTUsbD1rLGs9aCxoPShjPDwzMHxjPj4+MikmNDI5NDk2NzI5NSxjPWIsYj1mO2EuTlswXT1hLk5bMF0rYiY0Mjk0OTY3Mjk1O2EuTlsxXT1hLk5bMV0rYyY0Mjk0OTY3Mjk1O2EuTlsyXT1hLk5bMl0raCY0Mjk0OTY3Mjk1O2EuTlszXT1hLk5bM10rayY0Mjk0OTY3Mjk1O2EuTls0XT1hLk5bNF0rbCY0Mjk0OTY3Mjk1fVxuTGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe24oYil8fChiPWEubGVuZ3RoKTtmb3IodmFyIGM9Yi10aGlzLlZhLGQ9MCxlPXRoaXMubWUsZj10aGlzLmFjO2Q8Yjspe2lmKDA9PWYpZm9yKDtkPD1jOylNYSh0aGlzLGEsZCksZCs9dGhpcy5WYTtpZihwKGEpKWZvcig7ZDxiOyl7aWYoZVtmXT1hLmNoYXJDb2RlQXQoZCksKytmLCsrZCxmPT10aGlzLlZhKXtNYSh0aGlzLGUpO2Y9MDticmVha319ZWxzZSBmb3IoO2Q8YjspaWYoZVtmXT1hW2RdLCsrZiwrK2QsZj09dGhpcy5WYSl7TWEodGhpcyxlKTtmPTA7YnJlYWt9fXRoaXMuYWM9Zjt0aGlzLmRlKz1ifX07dmFyIHU9QXJyYXkucHJvdG90eXBlLE5hPXUuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHUuaW5kZXhPZi5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbD09Yz8wOjA+Yz9NYXRoLm1heCgwLGEubGVuZ3RoK2MpOmM7aWYocChhKSlyZXR1cm4gcChiKSYmMT09Yi5sZW5ndGg/YS5pbmRleE9mKGIsYyk6LTE7Zm9yKDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxPYT11LmZvckVhY2g/ZnVuY3Rpb24oYSxiLGMpe3UuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfSxQYT11LmZpbHRlcj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHUuZmlsdGVyLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9W10sZj0wLGg9cChhKT9cbmEuc3BsaXQoXCJcIik6YSxrPTA7azxkO2srKylpZihrIGluIGgpe3ZhciBsPWhba107Yi5jYWxsKGMsbCxrLGEpJiYoZVtmKytdPWwpfXJldHVybiBlfSxRYT11Lm1hcD9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHUubWFwLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9QXJyYXkoZCksZj1wKGEpP2Euc3BsaXQoXCJcIik6YSxoPTA7aDxkO2grKyloIGluIGYmJihlW2hdPWIuY2FsbChjLGZbaF0saCxhKSk7cmV0dXJuIGV9LFJhPXUucmVkdWNlP2Z1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZT1bXSxmPTEsaD1hcmd1bWVudHMubGVuZ3RoO2Y8aDtmKyspZS5wdXNoKGFyZ3VtZW50c1tmXSk7ZCYmKGVbMF09cShiLGQpKTtyZXR1cm4gdS5yZWR1Y2UuYXBwbHkoYSxlKX06ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YztPYShhLGZ1bmN0aW9uKGMsaCl7ZT1iLmNhbGwoZCxlLGMsaCxhKX0pO3JldHVybiBlfSxTYT11LmV2ZXJ5P2Z1bmN0aW9uKGEsYixcbmMpe3JldHVybiB1LmV2ZXJ5LmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9cChhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiYhYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiExO3JldHVybiEwfTtmdW5jdGlvbiBUYShhLGIpe3ZhciBjPVVhKGEsYix2b2lkIDApO3JldHVybiAwPmM/bnVsbDpwKGEpP2EuY2hhckF0KGMpOmFbY119ZnVuY3Rpb24gVWEoYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiBmO3JldHVybi0xfWZ1bmN0aW9uIFZhKGEsYil7dmFyIGM9TmEoYSxiKTswPD1jJiZ1LnNwbGljZS5jYWxsKGEsYywxKX1mdW5jdGlvbiBXYShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/dS5zbGljZS5jYWxsKGEsYik6dS5zbGljZS5jYWxsKGEsYixjKX1cbmZ1bmN0aW9uIFhhKGEsYil7YS5zb3J0KGJ8fFlhKX1mdW5jdGlvbiBZYShhLGIpe3JldHVybiBhPmI/MTphPGI/LTE6MH07dmFyIFphPS0xIT1IYS5pbmRleE9mKFwiT3BlcmFcIil8fC0xIT1IYS5pbmRleE9mKFwiT1BSXCIpLCRhPS0xIT1IYS5pbmRleE9mKFwiVHJpZGVudFwiKXx8LTEhPUhhLmluZGV4T2YoXCJNU0lFXCIpLGFiPS0xIT1IYS5pbmRleE9mKFwiR2Vja29cIikmJi0xPT1IYS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIikmJiEoLTEhPUhhLmluZGV4T2YoXCJUcmlkZW50XCIpfHwtMSE9SGEuaW5kZXhPZihcIk1TSUVcIikpLGJiPS0xIT1IYS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ3ZWJraXRcIik7XG4oZnVuY3Rpb24oKXt2YXIgYT1cIlwiLGI7aWYoWmEmJmFhLm9wZXJhKXJldHVybiBhPWFhLm9wZXJhLnZlcnNpb24saGEoYSk/YSgpOmE7YWI/Yj0vcnZcXDooW15cXCk7XSspKFxcKXw7KS86JGE/Yj0vXFxiKD86TVNJRXxydilbOiBdKFteXFwpO10rKShcXCl8OykvOmJiJiYoYj0vV2ViS2l0XFwvKFxcUyspLyk7YiYmKGE9KGE9Yi5leGVjKEhhKSk/YVsxXTpcIlwiKTtyZXR1cm4gJGEmJihiPShiPWFhLmRvY3VtZW50KT9iLmRvY3VtZW50TW9kZTp2b2lkIDAsYj5wYXJzZUZsb2F0KGEpKT9TdHJpbmcoYik6YX0pKCk7dmFyIGNiPW51bGwsZGI9bnVsbCxlYj1udWxsO2Z1bmN0aW9uIGZiKGEsYil7aWYoIWZhKGEpKXRocm93IEVycm9yKFwiZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyXCIpO2diKCk7Zm9yKHZhciBjPWI/ZGI6Y2IsZD1bXSxlPTA7ZTxhLmxlbmd0aDtlKz0zKXt2YXIgZj1hW2VdLGg9ZSsxPGEubGVuZ3RoLGs9aD9hW2UrMV06MCxsPWUrMjxhLmxlbmd0aCxtPWw/YVtlKzJdOjAsdD1mPj4yLGY9KGYmMyk8PDR8az4+NCxrPShrJjE1KTw8MnxtPj42LG09bSY2MztsfHwobT02NCxofHwoaz02NCkpO2QucHVzaChjW3RdLGNbZl0sY1trXSxjW21dKX1yZXR1cm4gZC5qb2luKFwiXCIpfVxuZnVuY3Rpb24gZ2IoKXtpZighY2Ipe2NiPXt9O2RiPXt9O2ViPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKWNiW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksZGJbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fLlwiLmNoYXJBdChhKSxlYltkYlthXV09YSw2Mjw9YSYmKGViW1wiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSldPWEpfX07dmFyIGhiPWhifHxcIjIuMy4xXCI7ZnVuY3Rpb24gdihhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX1mdW5jdGlvbiB3KGEsYil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYikpcmV0dXJuIGFbYl19ZnVuY3Rpb24gaWIoYSxiKXtmb3IodmFyIGMgaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSYmYihjLGFbY10pfWZ1bmN0aW9uIGpiKGEpe3ZhciBiPXt9O2liKGEsZnVuY3Rpb24oYSxkKXtiW2FdPWR9KTtyZXR1cm4gYn07ZnVuY3Rpb24ga2IoYSl7dmFyIGI9W107aWIoYSxmdW5jdGlvbihhLGQpe2VhKGQpP09hKGQsZnVuY3Rpb24oZCl7Yi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZCkpfSk6Yi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZCkpfSk7cmV0dXJuIGIubGVuZ3RoP1wiJlwiK2Iuam9pbihcIiZcIik6XCJcIn1mdW5jdGlvbiBsYihhKXt2YXIgYj17fTthPWEucmVwbGFjZSgvXlxcPy8sXCJcIikuc3BsaXQoXCImXCIpO09hKGEsZnVuY3Rpb24oYSl7YSYmKGE9YS5zcGxpdChcIj1cIiksYlthWzBdXT1hWzFdKX0pO3JldHVybiBifTtmdW5jdGlvbiB4KGEsYixjLGQpe3ZhciBlO2Q8Yj9lPVwiYXQgbGVhc3QgXCIrYjpkPmMmJihlPTA9PT1jP1wibm9uZVwiOlwibm8gbW9yZSB0aGFuIFwiK2MpO2lmKGUpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCBcIitkKygxPT09ZD9cIiBhcmd1bWVudC5cIjpcIiBhcmd1bWVudHMuXCIpK1wiIEV4cGVjdHMgXCIrZStcIi5cIik7fWZ1bmN0aW9uIHkoYSxiLGMpe3ZhciBkPVwiXCI7c3dpdGNoKGIpe2Nhc2UgMTpkPWM/XCJmaXJzdFwiOlwiRmlyc3RcIjticmVhaztjYXNlIDI6ZD1jP1wic2Vjb25kXCI6XCJTZWNvbmRcIjticmVhaztjYXNlIDM6ZD1jP1widGhpcmRcIjpcIlRoaXJkXCI7YnJlYWs7Y2FzZSA0OmQ9Yz9cImZvdXJ0aFwiOlwiRm91cnRoXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImVycm9yUHJlZml4IGNhbGxlZCB3aXRoIGFyZ3VtZW50TnVtYmVyID4gNC4gIE5lZWQgdG8gdXBkYXRlIGl0P1wiKTt9cmV0dXJuIGE9YStcIiBmYWlsZWQ6IFwiKyhkK1wiIGFyZ3VtZW50IFwiKX1cbmZ1bmN0aW9uIEEoYSxiLGMsZCl7aWYoKCFkfHxuKGMpKSYmIWhhKGMpKXRocm93IEVycm9yKHkoYSxiLGQpK1wibXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLlwiKTt9ZnVuY3Rpb24gbWIoYSxiLGMpe2lmKG4oYykmJighaWEoYyl8fG51bGw9PT1jKSl0aHJvdyBFcnJvcih5KGEsYiwhMCkrXCJtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuXCIpO307ZnVuY3Rpb24gbmIoYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZuKEpTT04ucGFyc2UpP0pTT04ucGFyc2UoYSk6QWEoYSl9ZnVuY3Rpb24gQihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIEpTT04mJm4oSlNPTi5zdHJpbmdpZnkpKWE9SlNPTi5zdHJpbmdpZnkoYSk7ZWxzZXt2YXIgYj1bXTtDYShuZXcgQmEsYSxiKTthPWIuam9pbihcIlwiKX1yZXR1cm4gYX07ZnVuY3Rpb24gb2IoKXt0aGlzLldkPUN9b2IucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuV2QuUShhKX07b2IucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuV2QudG9TdHJpbmcoKX07ZnVuY3Rpb24gcGIoKXt9cGIucHJvdG90eXBlLnFmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3BiLnByb3RvdHlwZS55ZT1mdW5jdGlvbigpe3JldHVybiBudWxsfTt2YXIgcWI9bmV3IHBiO2Z1bmN0aW9uIHJiKGEsYixjKXt0aGlzLlRmPWE7dGhpcy5LYT1iO3RoaXMuS2Q9Y31yYi5wcm90b3R5cGUucWY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5LYS5PO2lmKHNiKGIsYSkpcmV0dXJuIGIuaigpLlIoYSk7Yj1udWxsIT10aGlzLktkP25ldyB0Yih0aGlzLktkLCEwLCExKTp0aGlzLkthLncoKTtyZXR1cm4gdGhpcy5UZi54YyhhLGIpfTtyYi5wcm90b3R5cGUueWU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPXRoaXMuS2Q/dGhpcy5LZDp1Yih0aGlzLkthKTthPXRoaXMuVGYubmUoZCxiLDEsYyxhKTtyZXR1cm4gMD09PWEubGVuZ3RoP251bGw6YVswXX07ZnVuY3Rpb24gdmIoKXt0aGlzLnRiPVtdfWZ1bmN0aW9uIHdiKGEsYil7Zm9yKHZhciBjPW51bGwsZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdLGY9ZS5aYigpO251bGw9PT1jfHxmLmNhKGMuWmIoKSl8fChhLnRiLnB1c2goYyksYz1udWxsKTtudWxsPT09YyYmKGM9bmV3IHhiKGYpKTtjLmFkZChlKX1jJiZhLnRiLnB1c2goYyl9ZnVuY3Rpb24geWIoYSxiLGMpe3diKGEsYyk7emIoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5jYShiKX0pfWZ1bmN0aW9uIEFiKGEsYixjKXt3YihhLGMpO3piKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEuY29udGFpbnMoYil8fGIuY29udGFpbnMoYSl9KX1cbmZ1bmN0aW9uIHpiKGEsYil7Zm9yKHZhciBjPSEwLGQ9MDtkPGEudGIubGVuZ3RoO2QrKyl7dmFyIGU9YS50YltkXTtpZihlKWlmKGU9ZS5aYigpLGIoZSkpe2Zvcih2YXIgZT1hLnRiW2RdLGY9MDtmPGUudmQubGVuZ3RoO2YrKyl7dmFyIGg9ZS52ZFtmXTtpZihudWxsIT09aCl7ZS52ZFtmXT1udWxsO3ZhciBrPWguVmIoKTtCYiYmQ2IoXCJldmVudDogXCIraC50b1N0cmluZygpKTtEYihrKX19YS50YltkXT1udWxsfWVsc2UgYz0hMX1jJiYoYS50Yj1bXSl9ZnVuY3Rpb24geGIoYSl7dGhpcy5yYT1hO3RoaXMudmQ9W119eGIucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXt0aGlzLnZkLnB1c2goYSl9O3hiLnByb3RvdHlwZS5aYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJhfTtmdW5jdGlvbiBEKGEsYixjLGQpe3RoaXMudHlwZT1hO3RoaXMuSmE9Yjt0aGlzLldhPWM7dGhpcy5LZT1kO3RoaXMuUWQ9dm9pZCAwfWZ1bmN0aW9uIEViKGEpe3JldHVybiBuZXcgRChGYixhKX12YXIgRmI9XCJ2YWx1ZVwiO2Z1bmN0aW9uIEdiKGEsYixjLGQpe3RoaXMudWU9Yjt0aGlzLlpkPWM7dGhpcy5RZD1kO3RoaXMudWQ9YX1HYi5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlpkLkliKCk7cmV0dXJuXCJ2YWx1ZVwiPT09dGhpcy51ZD9hLnBhdGg6YS5wYXJlbnQoKS5wYXRofTtHYi5wcm90b3R5cGUuemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51ZH07R2IucHJvdG90eXBlLlZiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWUuVmIodGhpcyl9O0diLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLlpiKCkudG9TdHJpbmcoKStcIjpcIit0aGlzLnVkK1wiOlwiK0IodGhpcy5aZC5tZigpKX07ZnVuY3Rpb24gSGIoYSxiLGMpe3RoaXMudWU9YTt0aGlzLmVycm9yPWI7dGhpcy5wYXRoPWN9SGIucHJvdG90eXBlLlpiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aH07SGIucHJvdG90eXBlLnplPWZ1bmN0aW9uKCl7cmV0dXJuXCJjYW5jZWxcIn07XG5IYi5wcm90b3R5cGUuVmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51ZS5WYih0aGlzKX07SGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpK1wiOmNhbmNlbFwifTtmdW5jdGlvbiB0YihhLGIsYyl7dGhpcy5BPWE7dGhpcy5lYT1iO3RoaXMuVWI9Y31mdW5jdGlvbiBJYihhKXtyZXR1cm4gYS5lYX1mdW5jdGlvbiBKYihhKXtyZXR1cm4gYS5VYn1mdW5jdGlvbiBLYihhLGIpe3JldHVybiBiLmUoKT9hLmVhJiYhYS5VYjpzYihhLEUoYikpfWZ1bmN0aW9uIHNiKGEsYil7cmV0dXJuIGEuZWEmJiFhLlVifHxhLkEuRGEoYil9dGIucHJvdG90eXBlLmo9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BfTtmdW5jdGlvbiBMYihhKXt0aGlzLmdnPWE7dGhpcy5EZD1udWxsfUxiLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdnLmdldCgpLGI9eGEoYSk7aWYodGhpcy5EZClmb3IodmFyIGMgaW4gdGhpcy5EZCliW2NdLT10aGlzLkRkW2NdO3RoaXMuRGQ9YTtyZXR1cm4gYn07ZnVuY3Rpb24gTWIoYSxiKXt0aGlzLk9mPXt9O3RoaXMuZmQ9bmV3IExiKGEpO3RoaXMuYmE9Yjt2YXIgYz0xRTQrMkU0Kk1hdGgucmFuZG9tKCk7c2V0VGltZW91dChxKHRoaXMuSWYsdGhpcyksTWF0aC5mbG9vcihjKSl9TWIucHJvdG90eXBlLklmPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5mZC5nZXQoKSxiPXt9LGM9ITEsZDtmb3IoZCBpbiBhKTA8YVtkXSYmdih0aGlzLk9mLGQpJiYoYltkXT1hW2RdLGM9ITApO2MmJnRoaXMuYmEuVWUoYik7c2V0VGltZW91dChxKHRoaXMuSWYsdGhpcyksTWF0aC5mbG9vcig2RTUqTWF0aC5yYW5kb20oKSkpfTtmdW5jdGlvbiBOYigpe3RoaXMuRWM9e319ZnVuY3Rpb24gT2IoYSxiLGMpe24oYyl8fChjPTEpO3YoYS5FYyxiKXx8KGEuRWNbYl09MCk7YS5FY1tiXSs9Y31OYi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHhhKHRoaXMuRWMpfTt2YXIgUGI9e30sUWI9e307ZnVuY3Rpb24gUmIoYSl7YT1hLnRvU3RyaW5nKCk7UGJbYV18fChQYlthXT1uZXcgTmIpO3JldHVybiBQYlthXX1mdW5jdGlvbiBTYihhLGIpe3ZhciBjPWEudG9TdHJpbmcoKTtRYltjXXx8KFFiW2NdPWIoKSk7cmV0dXJuIFFiW2NdfTtmdW5jdGlvbiBGKGEsYil7dGhpcy5uYW1lPWE7dGhpcy5TPWJ9ZnVuY3Rpb24gVGIoYSxiKXtyZXR1cm4gbmV3IEYoYSxiKX07ZnVuY3Rpb24gVWIoYSxiKXtyZXR1cm4gVmIoYS5uYW1lLGIubmFtZSl9ZnVuY3Rpb24gV2IoYSxiKXtyZXR1cm4gVmIoYSxiKX07ZnVuY3Rpb24gWGIoYSxiLGMpe3RoaXMudHlwZT1ZYjt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1iO3RoaXMuR2E9Y31YYi5wcm90b3R5cGUuWGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucGF0aC5lKCk/bmV3IFhiKHRoaXMuc291cmNlLEcsdGhpcy5HYS5SKGEpKTpuZXcgWGIodGhpcy5zb3VyY2UsSCh0aGlzLnBhdGgpLHRoaXMuR2EpfTtYYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgb3ZlcndyaXRlOiBcIit0aGlzLkdhLnRvU3RyaW5nKCkrXCIpXCJ9O2Z1bmN0aW9uIFpiKGEsYil7dGhpcy50eXBlPSRiO3RoaXMuc291cmNlPWE7dGhpcy5wYXRoPWJ9WmIucHJvdG90eXBlLlhjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC5lKCk/bmV3IFpiKHRoaXMuc291cmNlLEcpOm5ldyBaYih0aGlzLnNvdXJjZSxIKHRoaXMucGF0aCkpfTtaYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgbGlzdGVuX2NvbXBsZXRlKVwifTtmdW5jdGlvbiBhYyhhLGIpe3RoaXMuTGE9YTt0aGlzLndhPWI/YjpiY31nPWFjLnByb3RvdHlwZTtnLk9hPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBhYyh0aGlzLkxhLHRoaXMud2EuT2EoYSxiLHRoaXMuTGEpLlkobnVsbCxudWxsLCExLG51bGwsbnVsbCkpfTtnLnJlbW92ZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGFjKHRoaXMuTGEsdGhpcy53YS5yZW1vdmUoYSx0aGlzLkxhKS5ZKG51bGwsbnVsbCwhMSxudWxsLG51bGwpKX07Zy5nZXQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGM9dGhpcy53YTshYy5lKCk7KXtiPXRoaXMuTGEoYSxjLmtleSk7aWYoMD09PWIpcmV0dXJuIGMudmFsdWU7MD5iP2M9Yy5sZWZ0OjA8YiYmKGM9Yy5yaWdodCl9cmV0dXJuIG51bGx9O1xuZnVuY3Rpb24gY2MoYSxiKXtmb3IodmFyIGMsZD1hLndhLGU9bnVsbDshZC5lKCk7KXtjPWEuTGEoYixkLmtleSk7aWYoMD09PWMpe2lmKGQubGVmdC5lKCkpcmV0dXJuIGU/ZS5rZXk6bnVsbDtmb3IoZD1kLmxlZnQ7IWQucmlnaHQuZSgpOylkPWQucmlnaHQ7cmV0dXJuIGQua2V5fTA+Yz9kPWQubGVmdDowPGMmJihlPWQsZD1kLnJpZ2h0KX10aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzP1wiKTt9Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2EuZSgpfTtnLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2EuY291bnQoKX07Zy5TYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhLlNjKCl9O2cuZmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YS5mYygpfTtnLmlhPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLndhLmlhKGEpfTtcbmcuWGI9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBkYyh0aGlzLndhLG51bGwsdGhpcy5MYSwhMSxhKX07Zy5ZYj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgZGModGhpcy53YSxhLHRoaXMuTGEsITEsYil9O2cuJGI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGRjKHRoaXMud2EsYSx0aGlzLkxhLCEwLGIpfTtnLnNmPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgZGModGhpcy53YSxudWxsLHRoaXMuTGEsITAsYSl9O2Z1bmN0aW9uIGRjKGEsYixjLGQsZSl7dGhpcy5VZD1lfHxudWxsO3RoaXMuRmU9ZDt0aGlzLlBhPVtdO2ZvcihlPTE7IWEuZSgpOylpZihlPWI/YyhhLmtleSxiKToxLGQmJihlKj0tMSksMD5lKWE9dGhpcy5GZT9hLmxlZnQ6YS5yaWdodDtlbHNlIGlmKDA9PT1lKXt0aGlzLlBhLnB1c2goYSk7YnJlYWt9ZWxzZSB0aGlzLlBhLnB1c2goYSksYT10aGlzLkZlP2EucmlnaHQ6YS5sZWZ0fVxuZnVuY3Rpb24gSihhKXtpZigwPT09YS5QYS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGI9YS5QYS5wb3AoKSxjO2M9YS5VZD9hLlVkKGIua2V5LGIudmFsdWUpOntrZXk6Yi5rZXksdmFsdWU6Yi52YWx1ZX07aWYoYS5GZSlmb3IoYj1iLmxlZnQ7IWIuZSgpOylhLlBhLnB1c2goYiksYj1iLnJpZ2h0O2Vsc2UgZm9yKGI9Yi5yaWdodDshYi5lKCk7KWEuUGEucHVzaChiKSxiPWIubGVmdDtyZXR1cm4gY31mdW5jdGlvbiBlYyhhKXtpZigwPT09YS5QYS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGI7Yj1hLlBhO2I9YltiLmxlbmd0aC0xXTtyZXR1cm4gYS5VZD9hLlVkKGIua2V5LGIudmFsdWUpOntrZXk6Yi5rZXksdmFsdWU6Yi52YWx1ZX19ZnVuY3Rpb24gZmMoYSxiLGMsZCxlKXt0aGlzLmtleT1hO3RoaXMudmFsdWU9Yjt0aGlzLmNvbG9yPW51bGwhPWM/YzohMDt0aGlzLmxlZnQ9bnVsbCE9ZD9kOmJjO3RoaXMucmlnaHQ9bnVsbCE9ZT9lOmJjfWc9ZmMucHJvdG90eXBlO1xuZy5ZPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBmYyhudWxsIT1hP2E6dGhpcy5rZXksbnVsbCE9Yj9iOnRoaXMudmFsdWUsbnVsbCE9Yz9jOnRoaXMuY29sb3IsbnVsbCE9ZD9kOnRoaXMubGVmdCxudWxsIT1lP2U6dGhpcy5yaWdodCl9O2cuY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZWZ0LmNvdW50KCkrMSt0aGlzLnJpZ2h0LmNvdW50KCl9O2cuZT1mdW5jdGlvbigpe3JldHVybiExfTtnLmlhPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmxlZnQuaWEoYSl8fGEodGhpcy5rZXksdGhpcy52YWx1ZSl8fHRoaXMucmlnaHQuaWEoYSl9O2Z1bmN0aW9uIGdjKGEpe3JldHVybiBhLmxlZnQuZSgpP2E6Z2MoYS5sZWZ0KX1nLlNjPWZ1bmN0aW9uKCl7cmV0dXJuIGdjKHRoaXMpLmtleX07Zy5mYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJpZ2h0LmUoKT90aGlzLmtleTp0aGlzLnJpZ2h0LmZjKCl9O1xuZy5PYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtlPXRoaXM7ZD1jKGEsZS5rZXkpO2U9MD5kP2UuWShudWxsLG51bGwsbnVsbCxlLmxlZnQuT2EoYSxiLGMpLG51bGwpOjA9PT1kP2UuWShudWxsLGIsbnVsbCxudWxsLG51bGwpOmUuWShudWxsLG51bGwsbnVsbCxudWxsLGUucmlnaHQuT2EoYSxiLGMpKTtyZXR1cm4gaGMoZSl9O2Z1bmN0aW9uIGljKGEpe2lmKGEubGVmdC5lKCkpcmV0dXJuIGJjO2EubGVmdC5mYSgpfHxhLmxlZnQubGVmdC5mYSgpfHwoYT1qYyhhKSk7YT1hLlkobnVsbCxudWxsLG51bGwsaWMoYS5sZWZ0KSxudWxsKTtyZXR1cm4gaGMoYSl9XG5nLnJlbW92ZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ7Yz10aGlzO2lmKDA+YihhLGMua2V5KSljLmxlZnQuZSgpfHxjLmxlZnQuZmEoKXx8Yy5sZWZ0LmxlZnQuZmEoKXx8KGM9amMoYykpLGM9Yy5ZKG51bGwsbnVsbCxudWxsLGMubGVmdC5yZW1vdmUoYSxiKSxudWxsKTtlbHNle2MubGVmdC5mYSgpJiYoYz1rYyhjKSk7Yy5yaWdodC5lKCl8fGMucmlnaHQuZmEoKXx8Yy5yaWdodC5sZWZ0LmZhKCl8fChjPWxjKGMpLGMubGVmdC5sZWZ0LmZhKCkmJihjPWtjKGMpLGM9bGMoYykpKTtpZigwPT09YihhLGMua2V5KSl7aWYoYy5yaWdodC5lKCkpcmV0dXJuIGJjO2Q9Z2MoYy5yaWdodCk7Yz1jLlkoZC5rZXksZC52YWx1ZSxudWxsLG51bGwsaWMoYy5yaWdodCkpfWM9Yy5ZKG51bGwsbnVsbCxudWxsLG51bGwsYy5yaWdodC5yZW1vdmUoYSxiKSl9cmV0dXJuIGhjKGMpfTtnLmZhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29sb3J9O1xuZnVuY3Rpb24gaGMoYSl7YS5yaWdodC5mYSgpJiYhYS5sZWZ0LmZhKCkmJihhPW1jKGEpKTthLmxlZnQuZmEoKSYmYS5sZWZ0LmxlZnQuZmEoKSYmKGE9a2MoYSkpO2EubGVmdC5mYSgpJiZhLnJpZ2h0LmZhKCkmJihhPWxjKGEpKTtyZXR1cm4gYX1mdW5jdGlvbiBqYyhhKXthPWxjKGEpO2EucmlnaHQubGVmdC5mYSgpJiYoYT1hLlkobnVsbCxudWxsLG51bGwsbnVsbCxrYyhhLnJpZ2h0KSksYT1tYyhhKSxhPWxjKGEpKTtyZXR1cm4gYX1mdW5jdGlvbiBtYyhhKXtyZXR1cm4gYS5yaWdodC5ZKG51bGwsbnVsbCxhLmNvbG9yLGEuWShudWxsLG51bGwsITAsbnVsbCxhLnJpZ2h0LmxlZnQpLG51bGwpfWZ1bmN0aW9uIGtjKGEpe3JldHVybiBhLmxlZnQuWShudWxsLG51bGwsYS5jb2xvcixudWxsLGEuWShudWxsLG51bGwsITAsYS5sZWZ0LnJpZ2h0LG51bGwpKX1cbmZ1bmN0aW9uIGxjKGEpe3JldHVybiBhLlkobnVsbCxudWxsLCFhLmNvbG9yLGEubGVmdC5ZKG51bGwsbnVsbCwhYS5sZWZ0LmNvbG9yLG51bGwsbnVsbCksYS5yaWdodC5ZKG51bGwsbnVsbCwhYS5yaWdodC5jb2xvcixudWxsLG51bGwpKX1mdW5jdGlvbiBuYygpe31nPW5jLnByb3RvdHlwZTtnLlk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5PYT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgZmMoYSxiLG51bGwpfTtnLnJlbW92ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtnLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIDB9O2cuZT1mdW5jdGlvbigpe3JldHVybiEwfTtnLmlhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuU2M9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07Zy5mYz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtnLmZhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O3ZhciBiYz1uZXcgbmM7ZnVuY3Rpb24gb2MoYSxiKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhPyhLKFwiLnN2XCJpbiBhLFwiVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHNcIiksYlthW1wiLnN2XCJdXSk6YX1mdW5jdGlvbiBwYyhhLGIpe3ZhciBjPW5ldyBxYztyYyhhLG5ldyBMKFwiXCIpLGZ1bmN0aW9uKGEsZSl7Yy5uYyhhLHNjKGUsYikpfSk7cmV0dXJuIGN9ZnVuY3Rpb24gc2MoYSxiKXt2YXIgYz1hLkMoKS5JKCksYz1vYyhjLGIpLGQ7aWYoYS5LKCkpe3ZhciBlPW9jKGEuQ2EoKSxiKTtyZXR1cm4gZSE9PWEuQ2EoKXx8YyE9PWEuQygpLkkoKT9uZXcgdGMoZSxNKGMpKTphfWQ9YTtjIT09YS5DKCkuSSgpJiYoZD1kLmdhKG5ldyB0YyhjKSkpO2EuUChOLGZ1bmN0aW9uKGEsYyl7dmFyIGU9c2MoYyxiKTtlIT09YyYmKGQ9ZC5VKGEsZSkpfSk7cmV0dXJuIGR9O2Z1bmN0aW9uIHVjKCl7dGhpcy53Yz17fX11Yy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj9kZWxldGUgdGhpcy53Y1thXTp0aGlzLndjW2FdPWJ9O3VjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHYodGhpcy53YyxhKT90aGlzLndjW2FdOm51bGx9O3VjLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMud2NbYV19O3VjLnByb3RvdHlwZS53Zj0hMDtmdW5jdGlvbiB2YyhhKXt0aGlzLkZjPWE7dGhpcy5QZD1cImZpcmViYXNlOlwifWc9dmMucHJvdG90eXBlO2cuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj90aGlzLkZjLnJlbW92ZUl0ZW0odGhpcy5QZCthKTp0aGlzLkZjLnNldEl0ZW0odGhpcy5QZCthLEIoYikpfTtnLmdldD1mdW5jdGlvbihhKXthPXRoaXMuRmMuZ2V0SXRlbSh0aGlzLlBkK2EpO3JldHVybiBudWxsPT1hP251bGw6bmIoYSl9O2cucmVtb3ZlPWZ1bmN0aW9uKGEpe3RoaXMuRmMucmVtb3ZlSXRlbSh0aGlzLlBkK2EpfTtnLndmPSExO2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5GYy50b1N0cmluZygpfTtmdW5jdGlvbiB3YyhhKXt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93W2FdKXt2YXIgYj13aW5kb3dbYV07Yi5zZXRJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIixcImNhY2hlXCIpO2IucmVtb3ZlSXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIpO3JldHVybiBuZXcgdmMoYil9fWNhdGNoKGMpe31yZXR1cm4gbmV3IHVjfXZhciB4Yz13YyhcImxvY2FsU3RvcmFnZVwiKSx5Yz13YyhcInNlc3Npb25TdG9yYWdlXCIpO2Z1bmN0aW9uIHpjKGEsYixjLGQsZSl7dGhpcy5ob3N0PWEudG9Mb3dlckNhc2UoKTt0aGlzLmRvbWFpbj10aGlzLmhvc3Quc3Vic3RyKHRoaXMuaG9zdC5pbmRleE9mKFwiLlwiKSsxKTt0aGlzLmtiPWI7dGhpcy5oYz1jO3RoaXMuV2c9ZDt0aGlzLk9kPWV8fFwiXCI7dGhpcy5ZYT14Yy5nZXQoXCJob3N0OlwiK2EpfHx0aGlzLmhvc3R9ZnVuY3Rpb24gQWMoYSxiKXtiIT09YS5ZYSYmKGEuWWE9YixcInMtXCI9PT1hLllhLnN1YnN0cigwLDIpJiZ4Yy5zZXQoXCJob3N0OlwiK2EuaG9zdCxhLllhKSl9XG5mdW5jdGlvbiBCYyhhLGIsYyl7SyhcInN0cmluZ1wiPT09dHlwZW9mIGIsXCJ0eXBlb2YgdHlwZSBtdXN0ID09IHN0cmluZ1wiKTtLKFwib2JqZWN0XCI9PT10eXBlb2YgYyxcInR5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3RcIik7aWYoYj09PUNjKWI9KGEua2I/XCJ3c3M6Ly9cIjpcIndzOi8vXCIpK2EuWWErXCIvLndzP1wiO2Vsc2UgaWYoYj09PURjKWI9KGEua2I/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSthLllhK1wiLy5scD9cIjtlbHNlIHRocm93IEVycm9yKFwiVW5rbm93biBjb25uZWN0aW9uIHR5cGU6IFwiK2IpO2EuaG9zdCE9PWEuWWEmJihjLm5zPWEuaGMpO3ZhciBkPVtdO3IoYyxmdW5jdGlvbihhLGIpe2QucHVzaChiK1wiPVwiK2EpfSk7cmV0dXJuIGIrZC5qb2luKFwiJlwiKX16Yy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT0odGhpcy5rYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuaG9zdDt0aGlzLk9kJiYoYSs9XCI8XCIrdGhpcy5PZCtcIj5cIik7cmV0dXJuIGF9O3ZhciBFYz1mdW5jdGlvbigpe3ZhciBhPTE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGErK319KCk7ZnVuY3Rpb24gSyhhLGIpe2lmKCFhKXRocm93IEZjKGIpO31mdW5jdGlvbiBGYyhhKXtyZXR1cm4gRXJyb3IoXCJGaXJlYmFzZSAoXCIraGIrXCIpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6IFwiK2EpfVxuZnVuY3Rpb24gR2MoYSl7dHJ5e3ZhciBiO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYXRvYiliPWF0b2IoYSk7ZWxzZXtnYigpO2Zvcih2YXIgYz1lYixkPVtdLGU9MDtlPGEubGVuZ3RoOyl7dmFyIGY9Y1thLmNoYXJBdChlKyspXSxoPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06MDsrK2U7dmFyIGs9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7dmFyIGw9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7aWYobnVsbD09Znx8bnVsbD09aHx8bnVsbD09a3x8bnVsbD09bCl0aHJvdyBFcnJvcigpO2QucHVzaChmPDwyfGg+PjQpOzY0IT1rJiYoZC5wdXNoKGg8PDQmMjQwfGs+PjIpLDY0IT1sJiZkLnB1c2goazw8NiYxOTJ8bCkpfWlmKDgxOTI+ZC5sZW5ndGgpYj1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZCk7ZWxzZXthPVwiXCI7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrPTgxOTIpYSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLFdhKGQsYyxcbmMrODE5MikpO2I9YX19cmV0dXJuIGJ9Y2F0Y2gobSl7Q2IoXCJiYXNlNjREZWNvZGUgZmFpbGVkOiBcIixtKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBIYyhhKXt2YXIgYj1JYyhhKTthPW5ldyBMYTthLnVwZGF0ZShiKTt2YXIgYj1bXSxjPTgqYS5kZTs1Nj5hLmFjP2EudXBkYXRlKGEuTGQsNTYtYS5hYyk6YS51cGRhdGUoYS5MZCxhLlZhLShhLmFjLTU2KSk7Zm9yKHZhciBkPWEuVmEtMTs1Njw9ZDtkLS0pYS5tZVtkXT1jJjI1NSxjLz0yNTY7TWEoYSxhLm1lKTtmb3IoZD1jPTA7NT5kO2QrKylmb3IodmFyIGU9MjQ7MDw9ZTtlLT04KWJbY109YS5OW2RdPj5lJjI1NSwrK2M7cmV0dXJuIGZiKGIpfVxuZnVuY3Rpb24gSmMoYSl7Zm9yKHZhciBiPVwiXCIsYz0wO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYj1mYShhcmd1bWVudHNbY10pP2IrSmMuYXBwbHkobnVsbCxhcmd1bWVudHNbY10pOlwib2JqZWN0XCI9PT10eXBlb2YgYXJndW1lbnRzW2NdP2IrQihhcmd1bWVudHNbY10pOmIrYXJndW1lbnRzW2NdLGIrPVwiIFwiO3JldHVybiBifXZhciBCYj1udWxsLEtjPSEwO2Z1bmN0aW9uIENiKGEpeyEwPT09S2MmJihLYz0hMSxudWxsPT09QmImJiEwPT09eWMuZ2V0KFwibG9nZ2luZ19lbmFibGVkXCIpJiZMYyghMCkpO2lmKEJiKXt2YXIgYj1KYy5hcHBseShudWxsLGFyZ3VtZW50cyk7QmIoYil9fWZ1bmN0aW9uIE1jKGEpe3JldHVybiBmdW5jdGlvbigpe0NiKGEsYXJndW1lbnRzKX19XG5mdW5jdGlvbiBOYyhhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBiPVwiRklSRUJBU0UgSU5URVJOQUwgRVJST1I6IFwiK0pjLmFwcGx5KG51bGwsYXJndW1lbnRzKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUuZXJyb3I/Y29uc29sZS5lcnJvcihiKTpjb25zb2xlLmxvZyhiKX19ZnVuY3Rpb24gT2MoYSl7dmFyIGI9SmMuYXBwbHkobnVsbCxhcmd1bWVudHMpO3Rocm93IEVycm9yKFwiRklSRUJBU0UgRkFUQUwgRVJST1I6IFwiK2IpO31mdW5jdGlvbiBPKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIGI9XCJGSVJFQkFTRSBXQVJOSU5HOiBcIitKYy5hcHBseShudWxsLGFyZ3VtZW50cyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlLndhcm4/Y29uc29sZS53YXJuKGIpOmNvbnNvbGUubG9nKGIpfX1cbmZ1bmN0aW9uIFBjKGEpe3ZhciBiPVwiXCIsYz1cIlwiLGQ9XCJcIixlPVwiXCIsZj0hMCxoPVwiaHR0cHNcIixrPTQ0MztpZihwKGEpKXt2YXIgbD1hLmluZGV4T2YoXCIvL1wiKTswPD1sJiYoaD1hLnN1YnN0cmluZygwLGwtMSksYT1hLnN1YnN0cmluZyhsKzIpKTtsPWEuaW5kZXhPZihcIi9cIik7LTE9PT1sJiYobD1hLmxlbmd0aCk7Yj1hLnN1YnN0cmluZygwLGwpO2U9XCJcIjthPWEuc3Vic3RyaW5nKGwpLnNwbGl0KFwiL1wiKTtmb3IobD0wO2w8YS5sZW5ndGg7bCsrKWlmKDA8YVtsXS5sZW5ndGgpe3ZhciBtPWFbbF07dHJ5e209ZGVjb2RlVVJJQ29tcG9uZW50KG0ucmVwbGFjZSgvXFwrL2csXCIgXCIpKX1jYXRjaCh0KXt9ZSs9XCIvXCIrbX1hPWIuc3BsaXQoXCIuXCIpOzM9PT1hLmxlbmd0aD8oYz1hWzFdLGQ9YVswXS50b0xvd2VyQ2FzZSgpKToyPT09YS5sZW5ndGgmJihjPWFbMF0pO2w9Yi5pbmRleE9mKFwiOlwiKTswPD1sJiYoZj1cImh0dHBzXCI9PT1ofHxcIndzc1wiPT09aCxrPWIuc3Vic3RyaW5nKGwrMSksaXNGaW5pdGUoaykmJlxuKGs9U3RyaW5nKGspKSxrPXAoayk/L15cXHMqLT8weC9pLnRlc3Qoayk/cGFyc2VJbnQoaywxNik6cGFyc2VJbnQoaywxMCk6TmFOKX1yZXR1cm57aG9zdDpiLHBvcnQ6ayxkb21haW46YyxUZzpkLGtiOmYsc2NoZW1lOmgsJGM6ZX19ZnVuY3Rpb24gUWMoYSl7cmV0dXJuIGdhKGEpJiYoYSE9YXx8YT09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfHxhPT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpfVxuZnVuY3Rpb24gUmMoYSl7aWYoXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSlhKCk7ZWxzZXt2YXIgYj0hMSxjPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keT9ifHwoYj0hMCxhKCkpOnNldFRpbWVvdXQoYyxNYXRoLmZsb29yKDEwKSl9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI/KGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsYywhMSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsYywhMSkpOmRvY3VtZW50LmF0dGFjaEV2ZW50JiYoZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJmMoKX0pLHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubG9hZFwiLGMpKX19XG5mdW5jdGlvbiBWYihhLGIpe2lmKGE9PT1iKXJldHVybiAwO2lmKFwiW01JTl9OQU1FXVwiPT09YXx8XCJbTUFYX05BTUVdXCI9PT1iKXJldHVybi0xO2lmKFwiW01JTl9OQU1FXVwiPT09Ynx8XCJbTUFYX05BTUVdXCI9PT1hKXJldHVybiAxO3ZhciBjPVNjKGEpLGQ9U2MoYik7cmV0dXJuIG51bGwhPT1jP251bGwhPT1kPzA9PWMtZD9hLmxlbmd0aC1iLmxlbmd0aDpjLWQ6LTE6bnVsbCE9PWQ/MTphPGI/LTE6MX1mdW5jdGlvbiBUYyhhLGIpe2lmKGImJmEgaW4gYilyZXR1cm4gYlthXTt0aHJvdyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQga2V5IChcIithK1wiKSBpbiBvYmplY3Q6IFwiK0IoYikpO31cbmZ1bmN0aW9uIFVjKGEpe2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWEpcmV0dXJuIEIoYSk7dmFyIGI9W10sYztmb3IoYyBpbiBhKWIucHVzaChjKTtiLnNvcnQoKTtjPVwie1wiO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKTAhPT1kJiYoYys9XCIsXCIpLGMrPUIoYltkXSksYys9XCI6XCIsYys9VWMoYVtiW2RdXSk7cmV0dXJuIGMrXCJ9XCJ9ZnVuY3Rpb24gVmMoYSxiKXtpZihhLmxlbmd0aDw9YilyZXR1cm5bYV07Zm9yKHZhciBjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrPWIpZCtiPmE/Yy5wdXNoKGEuc3Vic3RyaW5nKGQsYS5sZW5ndGgpKTpjLnB1c2goYS5zdWJzdHJpbmcoZCxkK2IpKTtyZXR1cm4gY31mdW5jdGlvbiBXYyhhLGIpe2lmKGVhKGEpKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7KytjKWIoYyxhW2NdKTtlbHNlIHIoYSxiKX1cbmZ1bmN0aW9uIFhjKGEpe0soIVFjKGEpLFwiSW52YWxpZCBKU09OIG51bWJlclwiKTt2YXIgYixjLGQsZTswPT09YT8oZD1jPTAsYj0tSW5maW5pdHk9PT0xL2E/MTowKTooYj0wPmEsYT1NYXRoLmFicyhhKSxhPj1NYXRoLnBvdygyLC0xMDIyKT8oZD1NYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGguTE4yKSwxMDIzKSxjPWQrMTAyMyxkPU1hdGgucm91bmQoYSpNYXRoLnBvdygyLDUyLWQpLU1hdGgucG93KDIsNTIpKSk6KGM9MCxkPU1hdGgucm91bmQoYS9NYXRoLnBvdygyLC0xMDc0KSkpKTtlPVtdO2ZvcihhPTUyO2E7LS1hKWUucHVzaChkJTI/MTowKSxkPU1hdGguZmxvb3IoZC8yKTtmb3IoYT0xMTthOy0tYSllLnB1c2goYyUyPzE6MCksYz1NYXRoLmZsb29yKGMvMik7ZS5wdXNoKGI/MTowKTtlLnJldmVyc2UoKTtiPWUuam9pbihcIlwiKTtjPVwiXCI7Zm9yKGE9MDs2ND5hO2ErPTgpZD1wYXJzZUludChiLnN1YnN0cihhLDgpLDIpLnRvU3RyaW5nKDE2KSwxPT09ZC5sZW5ndGgmJlxuKGQ9XCIwXCIrZCksYys9ZDtyZXR1cm4gYy50b0xvd2VyQ2FzZSgpfXZhciBZYz0vXi0/XFxkezEsMTB9JC87ZnVuY3Rpb24gU2MoYSl7cmV0dXJuIFljLnRlc3QoYSkmJihhPU51bWJlcihhKSwtMjE0NzQ4MzY0ODw9YSYmMjE0NzQ4MzY0Nz49YSk/YTpudWxsfWZ1bmN0aW9uIERiKGEpe3RyeXthKCl9Y2F0Y2goYil7c2V0VGltZW91dChmdW5jdGlvbigpe08oXCJFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLlwiLGIuc3RhY2t8fFwiXCIpO3Rocm93IGI7fSxNYXRoLmZsb29yKDApKX19ZnVuY3Rpb24gUChhLGIpe2lmKGhhKGEpKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkuc2xpY2UoKTtEYihmdW5jdGlvbigpe2EuYXBwbHkobnVsbCxjKX0pfX07ZnVuY3Rpb24gSWMoYSl7Zm9yKHZhciBiPVtdLGM9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPWEuY2hhckNvZGVBdChkKTs1NTI5Njw9ZSYmNTYzMTk+PWUmJihlLT01NTI5NixkKyssSyhkPGEubGVuZ3RoLFwiU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuXCIpLGU9NjU1MzYrKGU8PDEwKSsoYS5jaGFyQ29kZUF0KGQpLTU2MzIwKSk7MTI4PmU/YltjKytdPWU6KDIwNDg+ZT9iW2MrK109ZT4+NnwxOTI6KDY1NTM2PmU/YltjKytdPWU+PjEyfDIyNDooYltjKytdPWU+PjE4fDI0MCxiW2MrK109ZT4+MTImNjN8MTI4KSxiW2MrK109ZT4+NiY2M3wxMjgpLGJbYysrXT1lJjYzfDEyOCl9cmV0dXJuIGJ9ZnVuY3Rpb24gWmMoYSl7Zm9yKHZhciBiPTAsYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hLmNoYXJDb2RlQXQoYyk7MTI4PmQ/YisrOjIwNDg+ZD9iKz0yOjU1Mjk2PD1kJiY1NjMxOT49ZD8oYis9NCxjKyspOmIrPTN9cmV0dXJuIGJ9O2Z1bmN0aW9uICRjKGEpe3ZhciBiPXt9LGM9e30sZD17fSxlPVwiXCI7dHJ5e3ZhciBmPWEuc3BsaXQoXCIuXCIpLGI9bmIoR2MoZlswXSl8fFwiXCIpLGM9bmIoR2MoZlsxXSl8fFwiXCIpLGU9ZlsyXSxkPWMuZHx8e307ZGVsZXRlIGMuZH1jYXRjaChoKXt9cmV0dXJue1pnOmIsQmM6YyxkYXRhOmQsUWc6ZX19ZnVuY3Rpb24gYWQoYSl7YT0kYyhhKS5CYztyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJmEuaGFzT3duUHJvcGVydHkoXCJpYXRcIik/dyhhLFwiaWF0XCIpOm51bGx9ZnVuY3Rpb24gYmQoYSl7YT0kYyhhKTt2YXIgYj1hLkJjO3JldHVybiEhYS5RZyYmISFiJiZcIm9iamVjdFwiPT09dHlwZW9mIGImJmIuaGFzT3duUHJvcGVydHkoXCJpYXRcIil9O2Z1bmN0aW9uIGNkKGEpe3RoaXMuVz1hO3RoaXMuZz1hLm4uZ31mdW5jdGlvbiBkZChhLGIsYyxkKXt2YXIgZT1bXSxmPVtdO09hKGIsZnVuY3Rpb24oYil7XCJjaGlsZF9jaGFuZ2VkXCI9PT1iLnR5cGUmJmEuZy5BZChiLktlLGIuSmEpJiZmLnB1c2gobmV3IEQoXCJjaGlsZF9tb3ZlZFwiLGIuSmEsYi5XYSkpfSk7ZWQoYSxlLFwiY2hpbGRfcmVtb3ZlZFwiLGIsZCxjKTtlZChhLGUsXCJjaGlsZF9hZGRlZFwiLGIsZCxjKTtlZChhLGUsXCJjaGlsZF9tb3ZlZFwiLGYsZCxjKTtlZChhLGUsXCJjaGlsZF9jaGFuZ2VkXCIsYixkLGMpO2VkKGEsZSxGYixiLGQsYyk7cmV0dXJuIGV9ZnVuY3Rpb24gZWQoYSxiLGMsZCxlLGYpe2Q9UGEoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS50eXBlPT09Y30pO1hhKGQscShhLmhnLGEpKTtPYShkLGZ1bmN0aW9uKGMpe3ZhciBkPWZkKGEsYyxmKTtPYShlLGZ1bmN0aW9uKGUpe2UuS2YoYy50eXBlKSYmYi5wdXNoKGUuY3JlYXRlRXZlbnQoZCxhLlcpKX0pfSl9XG5mdW5jdGlvbiBmZChhLGIsYyl7XCJ2YWx1ZVwiIT09Yi50eXBlJiZcImNoaWxkX3JlbW92ZWRcIiE9PWIudHlwZSYmKGIuUWQ9Yy5yZihiLldhLGIuSmEsYS5nKSk7cmV0dXJuIGJ9Y2QucHJvdG90eXBlLmhnPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YS5XYXx8bnVsbD09Yi5XYSl0aHJvdyBGYyhcIlNob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy5cIik7cmV0dXJuIHRoaXMuZy5jb21wYXJlKG5ldyBGKGEuV2EsYS5KYSksbmV3IEYoYi5XYSxiLkphKSl9O2Z1bmN0aW9uIGdkKCl7dGhpcy5iYj17fX1cbmZ1bmN0aW9uIGhkKGEsYil7dmFyIGM9Yi50eXBlLGQ9Yi5XYTtLKFwiY2hpbGRfYWRkZWRcIj09Y3x8XCJjaGlsZF9jaGFuZ2VkXCI9PWN8fFwiY2hpbGRfcmVtb3ZlZFwiPT1jLFwiT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmdcIik7SyhcIi5wcmlvcml0eVwiIT09ZCxcIk9ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuXCIpO3ZhciBlPXcoYS5iYixkKTtpZihlKXt2YXIgZj1lLnR5cGU7aWYoXCJjaGlsZF9hZGRlZFwiPT1jJiZcImNoaWxkX3JlbW92ZWRcIj09ZilhLmJiW2RdPW5ldyBEKFwiY2hpbGRfY2hhbmdlZFwiLGIuSmEsZCxlLkphKTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2FkZGVkXCI9PWYpZGVsZXRlIGEuYmJbZF07ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5iYltkXT1uZXcgRChcImNoaWxkX3JlbW92ZWRcIixlLktlLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlxuXCJjaGlsZF9hZGRlZFwiPT1mKWEuYmJbZF09bmV3IEQoXCJjaGlsZF9hZGRlZFwiLGIuSmEsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5iYltkXT1uZXcgRChcImNoaWxkX2NoYW5nZWRcIixiLkphLGQsZS5LZSk7ZWxzZSB0aHJvdyBGYyhcIklsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogXCIrYitcIiBvY2N1cnJlZCBhZnRlciBcIitlKTt9ZWxzZSBhLmJiW2RdPWJ9O2Z1bmN0aW9uIGlkKGEsYixjKXt0aGlzLlJiPWE7dGhpcy5wYj1iO3RoaXMucmI9Y3x8bnVsbH1nPWlkLnByb3RvdHlwZTtnLktmPWZ1bmN0aW9uKGEpe3JldHVyblwidmFsdWVcIj09PWF9O2cuY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLm4uZztyZXR1cm4gbmV3IEdiKFwidmFsdWVcIix0aGlzLG5ldyBRKGEuSmEsYi5JYigpLGMpKX07Zy5WYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnJiO2lmKFwiY2FuY2VsXCI9PT1hLnplKCkpe0sodGhpcy5wYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLnBiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLlJiO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuWmQpfX07Zy5nZj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnBiP25ldyBIYih0aGlzLGEsYik6bnVsbH07XG5nLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBpZD9hLlJiJiZ0aGlzLlJiP2EuUmI9PT10aGlzLlJiJiZhLnJiPT09dGhpcy5yYjohMDohMX07Zy50Zj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5SYn07ZnVuY3Rpb24gamQoYSxiLGMpe3RoaXMuaGE9YTt0aGlzLnBiPWI7dGhpcy5yYj1jfWc9amQucHJvdG90eXBlO2cuS2Y9ZnVuY3Rpb24oYSl7YT1cImNoaWxkcmVuX2FkZGVkXCI9PT1hP1wiY2hpbGRfYWRkZWRcIjphO3JldHVybihcImNoaWxkcmVuX3JlbW92ZWRcIj09PWE/XCJjaGlsZF9yZW1vdmVkXCI6YSlpbiB0aGlzLmhhfTtnLmdmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucGI/bmV3IEhiKHRoaXMsYSxiKTpudWxsfTtcbmcuY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXtLKG51bGwhPWEuV2EsXCJDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuXCIpO3ZhciBjPWIuSWIoKS51KGEuV2EpO3JldHVybiBuZXcgR2IoYS50eXBlLHRoaXMsbmV3IFEoYS5KYSxjLGIubi5nKSxhLlFkKX07Zy5WYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnJiO2lmKFwiY2FuY2VsXCI9PT1hLnplKCkpe0sodGhpcy5wYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLnBiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLmhhW2EudWRdO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuWmQsYS5RZCl9fTtcbmcubWF0Y2hlcz1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgamQpe2lmKCF0aGlzLmhhfHwhYS5oYSlyZXR1cm4hMDtpZih0aGlzLnJiPT09YS5yYil7dmFyIGI9cGEoYS5oYSk7aWYoYj09PXBhKHRoaXMuaGEpKXtpZigxPT09Yil7dmFyIGI9cWEoYS5oYSksYz1xYSh0aGlzLmhhKTtyZXR1cm4gYz09PWImJighYS5oYVtiXXx8IXRoaXMuaGFbY118fGEuaGFbYl09PT10aGlzLmhhW2NdKX1yZXR1cm4gb2EodGhpcy5oYSxmdW5jdGlvbihiLGMpe3JldHVybiBhLmhhW2NdPT09Yn0pfX19cmV0dXJuITF9O2cudGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuaGF9O2Z1bmN0aW9uIGtkKGEpe3RoaXMuZz1hfWc9a2QucHJvdG90eXBlO2cuRz1mdW5jdGlvbihhLGIsYyxkLGUsZil7SyhhLkpjKHRoaXMuZyksXCJBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkXCIpO2U9YS5SKGIpO2lmKGUuUShkKS5jYShjLlEoZCkpJiZlLmUoKT09Yy5lKCkpcmV0dXJuIGE7bnVsbCE9ZiYmKGMuZSgpP2EuRGEoYik/aGQoZixuZXcgRChcImNoaWxkX3JlbW92ZWRcIixlLGIpKTpLKGEuSygpLFwiQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZVwiKTplLmUoKT9oZChmLG5ldyBEKFwiY2hpbGRfYWRkZWRcIixjLGIpKTpoZChmLG5ldyBEKFwiY2hpbGRfY2hhbmdlZFwiLGMsYixlKSkpO3JldHVybiBhLksoKSYmYy5lKCk/YTphLlUoYixjKS5sYih0aGlzLmcpfTtcbmcueGE9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWMmJihhLksoKXx8YS5QKE4sZnVuY3Rpb24oYSxlKXtiLkRhKGEpfHxoZChjLG5ldyBEKFwiY2hpbGRfcmVtb3ZlZFwiLGUsYSkpfSksYi5LKCl8fGIuUChOLGZ1bmN0aW9uKGIsZSl7aWYoYS5EYShiKSl7dmFyIGY9YS5SKGIpO2YuY2EoZSl8fGhkKGMsbmV3IEQoXCJjaGlsZF9jaGFuZ2VkXCIsZSxiLGYpKX1lbHNlIGhkKGMsbmV3IEQoXCJjaGlsZF9hZGRlZFwiLGUsYikpfSkpO3JldHVybiBiLmxiKHRoaXMuZyl9O2cuZ2E9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5lKCk/QzphLmdhKGIpfTtnLk5hPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZnVuY3Rpb24gbGQoYSl7dGhpcy5CZT1uZXcga2QoYS5nKTt0aGlzLmc9YS5nO3ZhciBiO2EubWE/KGI9bWQoYSksYj1hLmcuUGMobmQoYSksYikpOmI9YS5nLlRjKCk7dGhpcy5lZD1iO2EucGE/KGI9b2QoYSksYT1hLmcuUGMocGQoYSksYikpOmE9YS5nLlFjKCk7dGhpcy5HYz1hfWc9bGQucHJvdG90eXBlO2cubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gMD49dGhpcy5nLmNvbXBhcmUodGhpcy5lZCxhKSYmMD49dGhpcy5nLmNvbXBhcmUoYSx0aGlzLkdjKX07Zy5HPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLm1hdGNoZXMobmV3IEYoYixjKSl8fChjPUMpO3JldHVybiB0aGlzLkJlLkcoYSxiLGMsZCxlLGYpfTtcbmcueGE9ZnVuY3Rpb24oYSxiLGMpe2IuSygpJiYoYj1DKTt2YXIgZD1iLmxiKHRoaXMuZyksZD1kLmdhKEMpLGU9dGhpcztiLlAoTixmdW5jdGlvbihhLGIpe2UubWF0Y2hlcyhuZXcgRihhLGIpKXx8KGQ9ZC5VKGEsQykpfSk7cmV0dXJuIHRoaXMuQmUueGEoYSxkLGMpfTtnLmdhPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtnLk5hPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5CZX07ZnVuY3Rpb24gcWQoYSl7dGhpcy5zYT1uZXcgbGQoYSk7dGhpcy5nPWEuZztLKGEuamEsXCJPbmx5IHZhbGlkIGlmIGxpbWl0IGhhcyBiZWVuIHNldFwiKTt0aGlzLmthPWEua2E7dGhpcy5KYj0hcmQoYSl9Zz1xZC5wcm90b3R5cGU7Zy5HPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLnNhLm1hdGNoZXMobmV3IEYoYixjKSl8fChjPUMpO3JldHVybiBhLlIoYikuY2EoYyk/YTphLkRiKCk8dGhpcy5rYT90aGlzLnNhLldiKCkuRyhhLGIsYyxkLGUsZik6c2QodGhpcyxhLGIsYyxlLGYpfTtcbmcueGE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGIuSygpfHxiLmUoKSlkPUMubGIodGhpcy5nKTtlbHNlIGlmKDIqdGhpcy5rYTxiLkRiKCkmJmIuSmModGhpcy5nKSl7ZD1DLmxiKHRoaXMuZyk7Yj10aGlzLkpiP2IuJGIodGhpcy5zYS5HYyx0aGlzLmcpOmIuWWIodGhpcy5zYS5lZCx0aGlzLmcpO2Zvcih2YXIgZT0wOzA8Yi5QYS5sZW5ndGgmJmU8dGhpcy5rYTspe3ZhciBmPUooYiksaDtpZihoPXRoaXMuSmI/MD49dGhpcy5nLmNvbXBhcmUodGhpcy5zYS5lZCxmKTowPj10aGlzLmcuY29tcGFyZShmLHRoaXMuc2EuR2MpKWQ9ZC5VKGYubmFtZSxmLlMpLGUrKztlbHNlIGJyZWFrfX1lbHNle2Q9Yi5sYih0aGlzLmcpO2Q9ZC5nYShDKTt2YXIgayxsLG07aWYodGhpcy5KYil7Yj1kLnNmKHRoaXMuZyk7az10aGlzLnNhLkdjO2w9dGhpcy5zYS5lZDt2YXIgdD10ZCh0aGlzLmcpO209ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdChiLGEpfX1lbHNlIGI9ZC5YYih0aGlzLmcpLGs9dGhpcy5zYS5lZCxcbmw9dGhpcy5zYS5HYyxtPXRkKHRoaXMuZyk7Zm9yKHZhciBlPTAsej0hMTswPGIuUGEubGVuZ3RoOylmPUooYiksIXomJjA+PW0oayxmKSYmKHo9ITApLChoPXomJmU8dGhpcy5rYSYmMD49bShmLGwpKT9lKys6ZD1kLlUoZi5uYW1lLEMpfXJldHVybiB0aGlzLnNhLldiKCkueGEoYSxkLGMpfTtnLmdhPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtnLk5hPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zYS5XYigpfTtcbmZ1bmN0aW9uIHNkKGEsYixjLGQsZSxmKXt2YXIgaDtpZihhLkpiKXt2YXIgaz10ZChhLmcpO2g9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gayhiLGEpfX1lbHNlIGg9dGQoYS5nKTtLKGIuRGIoKT09YS5rYSxcIlwiKTt2YXIgbD1uZXcgRihjLGQpLG09YS5KYj91ZChiLGEuZyk6dmQoYixhLmcpLHQ9YS5zYS5tYXRjaGVzKGwpO2lmKGIuRGEoYykpe2Zvcih2YXIgej1iLlIoYyksbT1lLnllKGEuZyxtLGEuSmIpO251bGwhPW0mJihtLm5hbWU9PWN8fGIuRGEobS5uYW1lKSk7KW09ZS55ZShhLmcsbSxhLkpiKTtlPW51bGw9PW0/MTpoKG0sbCk7aWYodCYmIWQuZSgpJiYwPD1lKXJldHVybiBudWxsIT1mJiZoZChmLG5ldyBEKFwiY2hpbGRfY2hhbmdlZFwiLGQsYyx6KSksYi5VKGMsZCk7bnVsbCE9ZiYmaGQoZixuZXcgRChcImNoaWxkX3JlbW92ZWRcIix6LGMpKTtiPWIuVShjLEMpO3JldHVybiBudWxsIT1tJiZhLnNhLm1hdGNoZXMobSk/KG51bGwhPWYmJmhkKGYsbmV3IEQoXCJjaGlsZF9hZGRlZFwiLFxubS5TLG0ubmFtZSkpLGIuVShtLm5hbWUsbS5TKSk6Yn1yZXR1cm4gZC5lKCk/Yjp0JiYwPD1oKG0sbCk/KG51bGwhPWYmJihoZChmLG5ldyBEKFwiY2hpbGRfcmVtb3ZlZFwiLG0uUyxtLm5hbWUpKSxoZChmLG5ldyBEKFwiY2hpbGRfYWRkZWRcIixkLGMpKSksYi5VKGMsZCkuVShtLm5hbWUsQykpOmJ9O2Z1bmN0aW9uIHdkKGEsYil7dGhpcy5qZT1hO3RoaXMuZmc9Yn1mdW5jdGlvbiB4ZChhKXt0aGlzLlY9YX1cbnhkLnByb3RvdHlwZS5hYj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgZ2QsZjtpZihiLnR5cGU9PT1ZYiliLnNvdXJjZS53ZT9jPXlkKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZSk6KEsoYi5zb3VyY2UucGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5hZnx8SmIoYS53KCkpJiYhYi5wYXRoLmUoKSxjPUFkKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1CZCliLnNvdXJjZS53ZT9jPUNkKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZSk6KEsoYi5zb3VyY2UucGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5hZnx8SmIoYS53KCkpLGM9RGQodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PUVkKWlmKGIuVmQpaWYoYj1iLnBhdGgsbnVsbCE9Yy50YyhiKSljPWE7ZWxzZXtmPW5ldyByYihjLGEsZCk7ZD1hLk8uaigpO2lmKGIuZSgpfHxcIi5wcmlvcml0eVwiPT09RShiKSlJYihhLncoKSk/XG5iPWMuemEodWIoYSkpOihiPWEudygpLmooKSxLKGIgaW5zdGFuY2VvZiBSLFwic2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlXCIpLGI9Yy55YyhiKSksYj10aGlzLlYueGEoZCxiLGUpO2Vsc2V7dmFyIGg9RShiKSxrPWMueGMoaCxhLncoKSk7bnVsbD09ayYmc2IoYS53KCksaCkmJihrPWQuUihoKSk7Yj1udWxsIT1rP3RoaXMuVi5HKGQsaCxrLEgoYiksZixlKTphLk8uaigpLkRhKGgpP3RoaXMuVi5HKGQsaCxDLEgoYiksZixlKTpkO2IuZSgpJiZJYihhLncoKSkmJihkPWMuemEodWIoYSkpLGQuSygpJiYoYj10aGlzLlYueGEoYixkLGUpKSl9ZD1JYihhLncoKSl8fG51bGwhPWMudGMoRyk7Yz1GZChhLGIsZCx0aGlzLlYuTmEoKSl9ZWxzZSBjPUdkKHRoaXMsYSxiLnBhdGgsYi5RYixjLGQsZSk7ZWxzZSBpZihiLnR5cGU9PT0kYilkPWIucGF0aCxiPWEudygpLGY9Yi5qKCksaD1iLmVhfHxkLmUoKSxjPUhkKHRoaXMsbmV3IElkKGEuTyxuZXcgdGIoZixcbmgsYi5VYikpLGQsYyxxYixlKTtlbHNlIHRocm93IEZjKFwiVW5rbm93biBvcGVyYXRpb24gdHlwZTogXCIrYi50eXBlKTtlPXJhKGUuYmIpO2Q9YztiPWQuTztiLmVhJiYoZj1iLmooKS5LKCl8fGIuaigpLmUoKSxoPUpkKGEpLCgwPGUubGVuZ3RofHwhYS5PLmVhfHxmJiYhYi5qKCkuY2EoaCl8fCFiLmooKS5DKCkuY2EoaC5DKCkpKSYmZS5wdXNoKEViKEpkKGQpKSkpO3JldHVybiBuZXcgd2QoYyxlKX07XG5mdW5jdGlvbiBIZChhLGIsYyxkLGUsZil7dmFyIGg9Yi5PO2lmKG51bGwhPWQudGMoYykpcmV0dXJuIGI7dmFyIGs7aWYoYy5lKCkpSyhJYihiLncoKSksXCJJZiBjaGFuZ2UgcGF0aCBpcyBlbXB0eSwgd2UgbXVzdCBoYXZlIGNvbXBsZXRlIHNlcnZlciBkYXRhXCIpLEpiKGIudygpKT8oZT11YihiKSxkPWQueWMoZSBpbnN0YW5jZW9mIFI/ZTpDKSk6ZD1kLnphKHViKGIpKSxmPWEuVi54YShiLk8uaigpLGQsZik7ZWxzZXt2YXIgbD1FKGMpO2lmKFwiLnByaW9yaXR5XCI9PWwpSygxPT1LZChjKSxcIkNhbid0IGhhdmUgYSBwcmlvcml0eSB3aXRoIGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzXCIpLGY9aC5qKCksaz1iLncoKS5qKCksZD1kLmxkKGMsZixrKSxmPW51bGwhPWQ/YS5WLmdhKGYsZCk6aC5qKCk7ZWxzZXt2YXIgbT1IKGMpO3NiKGgsbCk/KGs9Yi53KCkuaigpLGQ9ZC5sZChjLGguaigpLGspLGQ9bnVsbCE9ZD9oLmooKS5SKGwpLkcobSxkKTpoLmooKS5SKGwpKTpkPWQueGMobCxcbmIudygpKTtmPW51bGwhPWQ/YS5WLkcoaC5qKCksbCxkLG0sZSxmKTpoLmooKX19cmV0dXJuIEZkKGIsZixoLmVhfHxjLmUoKSxhLlYuTmEoKSl9ZnVuY3Rpb24gQWQoYSxiLGMsZCxlLGYsaCxrKXt2YXIgbD1iLncoKTtoPWg/YS5WOmEuVi5XYigpO2lmKGMuZSgpKWQ9aC54YShsLmooKSxkLG51bGwpO2Vsc2UgaWYoaC5OYSgpJiYhbC5VYilkPWwuaigpLkcoYyxkKSxkPWgueGEobC5qKCksZCxudWxsKTtlbHNle3ZhciBtPUUoYyk7aWYoIUtiKGwsYykmJjE8S2QoYykpcmV0dXJuIGI7dmFyIHQ9SChjKTtkPWwuaigpLlIobSkuRyh0LGQpO2Q9XCIucHJpb3JpdHlcIj09bT9oLmdhKGwuaigpLGQpOmguRyhsLmooKSxtLGQsdCxxYixudWxsKX1sPWwuZWF8fGMuZSgpO2I9bmV3IElkKGIuTyxuZXcgdGIoZCxsLGguTmEoKSkpO3JldHVybiBIZChhLGIsYyxlLG5ldyByYihlLGIsZiksayl9XG5mdW5jdGlvbiB5ZChhLGIsYyxkLGUsZixoKXt2YXIgaz1iLk87ZT1uZXcgcmIoZSxiLGYpO2lmKGMuZSgpKWg9YS5WLnhhKGIuTy5qKCksZCxoKSxhPUZkKGIsaCwhMCxhLlYuTmEoKSk7ZWxzZSBpZihmPUUoYyksXCIucHJpb3JpdHlcIj09PWYpaD1hLlYuZ2EoYi5PLmooKSxkKSxhPUZkKGIsaCxrLmVhLGsuVWIpO2Vsc2V7Yz1IKGMpO3ZhciBsPWsuaigpLlIoZik7aWYoIWMuZSgpKXt2YXIgbT1lLnFmKGYpO2Q9bnVsbCE9bT9cIi5wcmlvcml0eVwiPT09TGQoYykmJm0uUShjLnBhcmVudCgpKS5lKCk/bTptLkcoYyxkKTpDfWwuY2EoZCk/YT1iOihoPWEuVi5HKGsuaigpLGYsZCxjLGUsaCksYT1GZChiLGgsay5lYSxhLlYuTmEoKSkpfXJldHVybiBhfVxuZnVuY3Rpb24gQ2QoYSxiLGMsZCxlLGYsaCl7dmFyIGs9YjtNZChkLGZ1bmN0aW9uKGQsbSl7dmFyIHQ9Yy51KGQpO3NiKGIuTyxFKHQpKSYmKGs9eWQoYSxrLHQsbSxlLGYsaCkpfSk7TWQoZCxmdW5jdGlvbihkLG0pe3ZhciB0PWMudShkKTtzYihiLk8sRSh0KSl8fChrPXlkKGEsayx0LG0sZSxmLGgpKX0pO3JldHVybiBrfWZ1bmN0aW9uIE5kKGEsYil7TWQoYixmdW5jdGlvbihiLGQpe2E9YS5HKGIsZCl9KTtyZXR1cm4gYX1cbmZ1bmN0aW9uIERkKGEsYixjLGQsZSxmLGgsayl7aWYoYi53KCkuaigpLmUoKSYmIUliKGIudygpKSlyZXR1cm4gYjt2YXIgbD1iO2M9Yy5lKCk/ZDpPZChQZCxjLGQpO3ZhciBtPWIudygpLmooKTtjLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGMsZCl7aWYobS5EYShjKSl7dmFyIEk9Yi53KCkuaigpLlIoYyksST1OZChJLGQpO2w9QWQoYSxsLG5ldyBMKGMpLEksZSxmLGgsayl9fSk7Yy5jaGlsZHJlbi5pYShmdW5jdGlvbihjLGQpe3ZhciBJPSFzYihiLncoKSxjKSYmbnVsbD09ZC52YWx1ZTttLkRhKGMpfHxJfHwoST1iLncoKS5qKCkuUihjKSxJPU5kKEksZCksbD1BZChhLGwsbmV3IEwoYyksSSxlLGYsaCxrKSl9KTtyZXR1cm4gbH1cbmZ1bmN0aW9uIEdkKGEsYixjLGQsZSxmLGgpe2lmKG51bGwhPWUudGMoYykpcmV0dXJuIGI7dmFyIGs9SmIoYi53KCkpLGw9Yi53KCk7aWYobnVsbCE9ZC52YWx1ZSl7aWYoYy5lKCkmJmwuZWF8fEtiKGwsYykpcmV0dXJuIEFkKGEsYixjLGwuaigpLlEoYyksZSxmLGssaCk7aWYoYy5lKCkpe3ZhciBtPVBkO2wuaigpLlAoUWQsZnVuY3Rpb24oYSxiKXttPW0uc2V0KG5ldyBMKGEpLGIpfSk7cmV0dXJuIERkKGEsYixjLG0sZSxmLGssaCl9cmV0dXJuIGJ9bT1QZDtNZChkLGZ1bmN0aW9uKGEpe3ZhciBiPWMudShhKTtLYihsLGIpJiYobT1tLnNldChhLGwuaigpLlEoYikpKX0pO3JldHVybiBEZChhLGIsYyxtLGUsZixrLGgpfTtmdW5jdGlvbiBSZCgpe312YXIgU2Q9e307ZnVuY3Rpb24gdGQoYSl7cmV0dXJuIHEoYS5jb21wYXJlLGEpfVJkLnByb3RvdHlwZS5BZD1mdW5jdGlvbihhLGIpe3JldHVybiAwIT09dGhpcy5jb21wYXJlKG5ldyBGKFwiW01JTl9OQU1FXVwiLGEpLG5ldyBGKFwiW01JTl9OQU1FXVwiLGIpKX07UmQucHJvdG90eXBlLlRjPWZ1bmN0aW9uKCl7cmV0dXJuIFRkfTtmdW5jdGlvbiBVZChhKXtLKCFhLmUoKSYmXCIucHJpb3JpdHlcIiE9PUUoYSksXCJDYW4ndCBjcmVhdGUgUGF0aEluZGV4IHdpdGggZW1wdHkgcGF0aCBvciAucHJpb3JpdHkga2V5XCIpO3RoaXMuY2M9YX1tYShVZCxSZCk7Zz1VZC5wcm90b3R5cGU7Zy5JYz1mdW5jdGlvbihhKXtyZXR1cm4hYS5RKHRoaXMuY2MpLmUoKX07Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLlEodGhpcy5jYyksZD1iLlMuUSh0aGlzLmNjKSxjPWMuRGMoZCk7cmV0dXJuIDA9PT1jP1ZiKGEubmFtZSxiLm5hbWUpOmN9O1xuZy5QYz1mdW5jdGlvbihhLGIpe3ZhciBjPU0oYSksYz1DLkcodGhpcy5jYyxjKTtyZXR1cm4gbmV3IEYoYixjKX07Zy5RYz1mdW5jdGlvbigpe3ZhciBhPUMuRyh0aGlzLmNjLFZkKTtyZXR1cm4gbmV3IEYoXCJbTUFYX05BTUVdXCIsYSl9O2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYy5zbGljZSgpLmpvaW4oXCIvXCIpfTtmdW5jdGlvbiBXZCgpe31tYShXZCxSZCk7Zz1XZC5wcm90b3R5cGU7Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLkMoKSxkPWIuUy5DKCksYz1jLkRjKGQpO3JldHVybiAwPT09Yz9WYihhLm5hbWUsYi5uYW1lKTpjfTtnLkljPWZ1bmN0aW9uKGEpe3JldHVybiFhLkMoKS5lKCl9O2cuQWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5DKCkuY2EoYi5DKCkpfTtnLlRjPWZ1bmN0aW9uKCl7cmV0dXJuIFRkfTtnLlFjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGKFwiW01BWF9OQU1FXVwiLG5ldyB0YyhcIltQUklPUklUWS1QT1NUXVwiLFZkKSl9O1xuZy5QYz1mdW5jdGlvbihhLGIpe3ZhciBjPU0oYSk7cmV0dXJuIG5ldyBGKGIsbmV3IHRjKFwiW1BSSU9SSVRZLVBPU1RdXCIsYykpfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIucHJpb3JpdHlcIn07dmFyIE49bmV3IFdkO2Z1bmN0aW9uIFhkKCl7fW1hKFhkLFJkKTtnPVhkLnByb3RvdHlwZTtnLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVmIoYS5uYW1lLGIubmFtZSl9O2cuSWM9ZnVuY3Rpb24oKXt0aHJvdyBGYyhcIktleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuXCIpO307Zy5BZD1mdW5jdGlvbigpe3JldHVybiExfTtnLlRjPWZ1bmN0aW9uKCl7cmV0dXJuIFRkfTtnLlFjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGKFwiW01BWF9OQU1FXVwiLEMpfTtnLlBjPWZ1bmN0aW9uKGEpe0socChhKSxcIktleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuXCIpO3JldHVybiBuZXcgRihhLEMpfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIua2V5XCJ9O1xudmFyIFFkPW5ldyBYZDtmdW5jdGlvbiBZZCgpe31tYShZZCxSZCk7Zz1ZZC5wcm90b3R5cGU7Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLkRjKGIuUyk7cmV0dXJuIDA9PT1jP1ZiKGEubmFtZSxiLm5hbWUpOmN9O2cuSWM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5BZD1mdW5jdGlvbihhLGIpe3JldHVybiFhLmNhKGIpfTtnLlRjPWZ1bmN0aW9uKCl7cmV0dXJuIFRkfTtnLlFjPWZ1bmN0aW9uKCl7cmV0dXJuIFpkfTtnLlBjPWZ1bmN0aW9uKGEsYil7dmFyIGM9TShhKTtyZXR1cm4gbmV3IEYoYixjKX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnZhbHVlXCJ9O3ZhciAkZD1uZXcgWWQ7ZnVuY3Rpb24gYWUoKXt0aGlzLlRiPXRoaXMucGE9dGhpcy5MYj10aGlzLm1hPXRoaXMuamE9ITE7dGhpcy5rYT0wO3RoaXMuTmI9XCJcIjt0aGlzLmVjPW51bGw7dGhpcy54Yj1cIlwiO3RoaXMuYmM9bnVsbDt0aGlzLnZiPVwiXCI7dGhpcy5nPU59dmFyIGJlPW5ldyBhZTtmdW5jdGlvbiByZChhKXtyZXR1cm5cIlwiPT09YS5OYj9hLm1hOlwibFwiPT09YS5OYn1mdW5jdGlvbiBuZChhKXtLKGEubWEsXCJPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5lY31mdW5jdGlvbiBtZChhKXtLKGEubWEsXCJPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5MYj9hLnhiOlwiW01JTl9OQU1FXVwifWZ1bmN0aW9uIHBkKGEpe0soYS5wYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5iY31cbmZ1bmN0aW9uIG9kKGEpe0soYS5wYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5UYj9hLnZiOlwiW01BWF9OQU1FXVwifWZ1bmN0aW9uIGNlKGEpe3ZhciBiPW5ldyBhZTtiLmphPWEuamE7Yi5rYT1hLmthO2IubWE9YS5tYTtiLmVjPWEuZWM7Yi5MYj1hLkxiO2IueGI9YS54YjtiLnBhPWEucGE7Yi5iYz1hLmJjO2IuVGI9YS5UYjtiLnZiPWEudmI7Yi5nPWEuZztyZXR1cm4gYn1nPWFlLnByb3RvdHlwZTtnLkhlPWZ1bmN0aW9uKGEpe3ZhciBiPWNlKHRoaXMpO2IuamE9ITA7Yi5rYT1hO2IuTmI9XCJcIjtyZXR1cm4gYn07Zy5JZT1mdW5jdGlvbihhKXt2YXIgYj1jZSh0aGlzKTtiLmphPSEwO2Iua2E9YTtiLk5iPVwibFwiO3JldHVybiBifTtnLkplPWZ1bmN0aW9uKGEpe3ZhciBiPWNlKHRoaXMpO2IuamE9ITA7Yi5rYT1hO2IuTmI9XCJyXCI7cmV0dXJuIGJ9O1xuZy4kZD1mdW5jdGlvbihhLGIpe3ZhciBjPWNlKHRoaXMpO2MubWE9ITA7bihhKXx8KGE9bnVsbCk7Yy5lYz1hO251bGwhPWI/KGMuTGI9ITAsYy54Yj1iKTooYy5MYj0hMSxjLnhiPVwiXCIpO3JldHVybiBjfTtnLnRkPWZ1bmN0aW9uKGEsYil7dmFyIGM9Y2UodGhpcyk7Yy5wYT0hMDtuKGEpfHwoYT1udWxsKTtjLmJjPWE7bihiKT8oYy5UYj0hMCxjLnZiPWIpOihjLmFoPSExLGMudmI9XCJcIik7cmV0dXJuIGN9O2Z1bmN0aW9uIGRlKGEsYil7dmFyIGM9Y2UoYSk7Yy5nPWI7cmV0dXJuIGN9ZnVuY3Rpb24gZWUoYSl7dmFyIGI9e307YS5tYSYmKGIuc3A9YS5lYyxhLkxiJiYoYi5zbj1hLnhiKSk7YS5wYSYmKGIuZXA9YS5iYyxhLlRiJiYoYi5lbj1hLnZiKSk7aWYoYS5qYSl7Yi5sPWEua2E7dmFyIGM9YS5OYjtcIlwiPT09YyYmKGM9cmQoYSk/XCJsXCI6XCJyXCIpO2IudmY9Y31hLmchPT1OJiYoYi5pPWEuZy50b1N0cmluZygpKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIFMoYSl7cmV0dXJuIShhLm1hfHxhLnBhfHxhLmphKX1mdW5jdGlvbiBmZShhKXtyZXR1cm4gUyhhKSYmYS5nPT1OfWZ1bmN0aW9uIGdlKGEpe3ZhciBiPXt9O2lmKGZlKGEpKXJldHVybiBiO3ZhciBjO2EuZz09PU4/Yz1cIiRwcmlvcml0eVwiOmEuZz09PSRkP2M9XCIkdmFsdWVcIjphLmc9PT1RZD9jPVwiJGtleVwiOihLKGEuZyBpbnN0YW5jZW9mIFVkLFwiVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhXCIpLGM9YS5nLnRvU3RyaW5nKCkpO2Iub3JkZXJCeT1CKGMpO2EubWEmJihiLnN0YXJ0QXQ9QihhLmVjKSxhLkxiJiYoYi5zdGFydEF0Kz1cIixcIitCKGEueGIpKSk7YS5wYSYmKGIuZW5kQXQ9QihhLmJjKSxhLlRiJiYoYi5lbmRBdCs9XCIsXCIrQihhLnZiKSkpO2EuamEmJihyZChhKT9iLmxpbWl0VG9GaXJzdD1hLmthOmIubGltaXRUb0xhc3Q9YS5rYSk7cmV0dXJuIGJ9Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBCKGVlKHRoaXMpKX07ZnVuY3Rpb24gaGUoYSxiKXt0aGlzLkJkPWE7dGhpcy5kYz1ifWhlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dyh0aGlzLkJkLGEpO2lmKCFiKXRocm93IEVycm9yKFwiTm8gaW5kZXggZGVmaW5lZCBmb3IgXCIrYSk7cmV0dXJuIGI9PT1TZD9udWxsOmJ9O2Z1bmN0aW9uIGllKGEsYixjKXt2YXIgZD1uYShhLkJkLGZ1bmN0aW9uKGQsZil7dmFyIGg9dyhhLmRjLGYpO0soaCxcIk1pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yIFwiK2YpO2lmKGQ9PT1TZCl7aWYoaC5JYyhiLlMpKXtmb3IodmFyIGs9W10sbD1jLlhiKFRiKSxtPUoobCk7bTspbS5uYW1lIT1iLm5hbWUmJmsucHVzaChtKSxtPUoobCk7ay5wdXNoKGIpO3JldHVybiBqZShrLHRkKGgpKX1yZXR1cm4gU2R9aD1jLmdldChiLm5hbWUpO2s9ZDtoJiYoaz1rLnJlbW92ZShuZXcgRihiLm5hbWUsaCkpKTtyZXR1cm4gay5PYShiLGIuUyl9KTtyZXR1cm4gbmV3IGhlKGQsYS5kYyl9XG5mdW5jdGlvbiBrZShhLGIsYyl7dmFyIGQ9bmEoYS5CZCxmdW5jdGlvbihhKXtpZihhPT09U2QpcmV0dXJuIGE7dmFyIGQ9Yy5nZXQoYi5uYW1lKTtyZXR1cm4gZD9hLnJlbW92ZShuZXcgRihiLm5hbWUsZCkpOmF9KTtyZXR1cm4gbmV3IGhlKGQsYS5kYyl9dmFyIGxlPW5ldyBoZSh7XCIucHJpb3JpdHlcIjpTZH0se1wiLnByaW9yaXR5XCI6Tn0pO2Z1bmN0aW9uIHRjKGEsYil7dGhpcy5CPWE7SyhuKHRoaXMuQikmJm51bGwhPT10aGlzLkIsXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTt0aGlzLmFhPWJ8fEM7bWUodGhpcy5hYSk7dGhpcy5DYj1udWxsfXZhciBuZT1bXCJvYmplY3RcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwic3RyaW5nXCJdO2c9dGMucHJvdG90eXBlO2cuSz1mdW5jdGlvbigpe3JldHVybiEwfTtnLkM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYX07Zy5nYT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IHRjKHRoaXMuQixhKX07Zy5SPWZ1bmN0aW9uKGEpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuYWE6Q307Zy5RPWZ1bmN0aW9uKGEpe3JldHVybiBhLmUoKT90aGlzOlwiLnByaW9yaXR5XCI9PT1FKGEpP3RoaXMuYWE6Q307Zy5EYT1mdW5jdGlvbigpe3JldHVybiExfTtnLnJmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuZy5VPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5nYShiKTpiLmUoKSYmXCIucHJpb3JpdHlcIiE9PWE/dGhpczpDLlUoYSxiKS5nYSh0aGlzLmFhKX07Zy5HPWZ1bmN0aW9uKGEsYil7dmFyIGM9RShhKTtpZihudWxsPT09YylyZXR1cm4gYjtpZihiLmUoKSYmXCIucHJpb3JpdHlcIiE9PWMpcmV0dXJuIHRoaXM7SyhcIi5wcmlvcml0eVwiIT09Y3x8MT09PUtkKGEpLFwiLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoXCIpO3JldHVybiB0aGlzLlUoYyxDLkcoSChhKSxiKSl9O2cuZT1mdW5jdGlvbigpe3JldHVybiExfTtnLkRiPWZ1bmN0aW9uKCl7cmV0dXJuIDB9O2cuUD1mdW5jdGlvbigpe3JldHVybiExfTtnLkk9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJiF0aGlzLkMoKS5lKCk/e1wiLnZhbHVlXCI6dGhpcy5DYSgpLFwiLnByaW9yaXR5XCI6dGhpcy5DKCkuSSgpfTp0aGlzLkNhKCl9O1xuZy5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuQ2Ipe3ZhciBhPVwiXCI7dGhpcy5hYS5lKCl8fChhKz1cInByaW9yaXR5OlwiK29lKHRoaXMuYWEuSSgpKStcIjpcIik7dmFyIGI9dHlwZW9mIHRoaXMuQixhPWErKGIrXCI6XCIpLGE9XCJudW1iZXJcIj09PWI/YStYYyh0aGlzLkIpOmErdGhpcy5CO3RoaXMuQ2I9SGMoYSl9cmV0dXJuIHRoaXMuQ2J9O2cuQ2E9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5CfTtnLkRjPWZ1bmN0aW9uKGEpe2lmKGE9PT1DKXJldHVybiAxO2lmKGEgaW5zdGFuY2VvZiBSKXJldHVybi0xO0soYS5LKCksXCJVbmtub3duIG5vZGUgdHlwZVwiKTt2YXIgYj10eXBlb2YgYS5CLGM9dHlwZW9mIHRoaXMuQixkPU5hKG5lLGIpLGU9TmEobmUsYyk7SygwPD1kLFwiVW5rbm93biBsZWFmIHR5cGU6IFwiK2IpO0soMDw9ZSxcIlVua25vd24gbGVhZiB0eXBlOiBcIitjKTtyZXR1cm4gZD09PWU/XCJvYmplY3RcIj09PWM/MDp0aGlzLkI8YS5CPy0xOnRoaXMuQj09PWEuQj8wOjE6ZS1kfTtcbmcubGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5KYz1mdW5jdGlvbigpe3JldHVybiEwfTtnLmNhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpcz8hMDphLksoKT90aGlzLkI9PT1hLkImJnRoaXMuYWEuY2EoYS5hYSk6ITF9O2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzLkkoITApKX07ZnVuY3Rpb24gUihhLGIsYyl7dGhpcy5tPWE7KHRoaXMuYWE9YikmJm1lKHRoaXMuYWEpO2EuZSgpJiZLKCF0aGlzLmFhfHx0aGlzLmFhLmUoKSxcIkFuIGVtcHR5IG5vZGUgY2Fubm90IGhhdmUgYSBwcmlvcml0eVwiKTt0aGlzLndiPWM7dGhpcy5DYj1udWxsfWc9Ui5wcm90b3R5cGU7Zy5LPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuQz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFhfHxDfTtnLmdhPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm0uZSgpP3RoaXM6bmV3IFIodGhpcy5tLGEsdGhpcy53Yil9O2cuUj1mdW5jdGlvbihhKXtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5DKCk7YT10aGlzLm0uZ2V0KGEpO3JldHVybiBudWxsPT09YT9DOmF9O2cuUT1mdW5jdGlvbihhKXt2YXIgYj1FKGEpO3JldHVybiBudWxsPT09Yj90aGlzOnRoaXMuUihiKS5RKEgoYSkpfTtnLkRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09dGhpcy5tLmdldChhKX07XG5nLlU9ZnVuY3Rpb24oYSxiKXtLKGIsXCJXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXNcIik7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuZ2EoYik7dmFyIGM9bmV3IEYoYSxiKSxkLGU7Yi5lKCk/KGQ9dGhpcy5tLnJlbW92ZShhKSxjPWtlKHRoaXMud2IsYyx0aGlzLm0pKTooZD10aGlzLm0uT2EoYSxiKSxjPWllKHRoaXMud2IsYyx0aGlzLm0pKTtlPWQuZSgpP0M6dGhpcy5hYTtyZXR1cm4gbmV3IFIoZCxlLGMpfTtnLkc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1FKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO0soXCIucHJpb3JpdHlcIiE9PUUoYSl8fDE9PT1LZChhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTt2YXIgZD10aGlzLlIoYykuRyhIKGEpLGIpO3JldHVybiB0aGlzLlUoYyxkKX07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5lKCl9O2cuRGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tLmNvdW50KCl9O1xudmFyIHBlPS9eKDB8WzEtOV1cXGQqKSQvO2c9Ui5wcm90b3R5cGU7Zy5JPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZSgpKXJldHVybiBudWxsO3ZhciBiPXt9LGM9MCxkPTAsZT0hMDt0aGlzLlAoTixmdW5jdGlvbihmLGgpe2JbZl09aC5JKGEpO2MrKztlJiZwZS50ZXN0KGYpP2Q9TWF0aC5tYXgoZCxOdW1iZXIoZikpOmU9ITF9KTtpZighYSYmZSYmZDwyKmMpe3ZhciBmPVtdLGg7Zm9yKGggaW4gYilmW2hdPWJbaF07cmV0dXJuIGZ9YSYmIXRoaXMuQygpLmUoKSYmKGJbXCIucHJpb3JpdHlcIl09dGhpcy5DKCkuSSgpKTtyZXR1cm4gYn07Zy5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuQ2Ipe3ZhciBhPVwiXCI7dGhpcy5DKCkuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitvZSh0aGlzLkMoKS5JKCkpK1wiOlwiKTt0aGlzLlAoTixmdW5jdGlvbihiLGMpe3ZhciBkPWMuaGFzaCgpO1wiXCIhPT1kJiYoYSs9XCI6XCIrYitcIjpcIitkKX0pO3RoaXMuQ2I9XCJcIj09PWE/XCJcIjpIYyhhKX1yZXR1cm4gdGhpcy5DYn07XG5nLnJmPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4oYz1xZSh0aGlzLGMpKT8oYT1jYyhjLG5ldyBGKGEsYikpKT9hLm5hbWU6bnVsbDpjYyh0aGlzLm0sYSl9O2Z1bmN0aW9uIHVkKGEsYil7dmFyIGM7Yz0oYz1xZShhLGIpKT8oYz1jLlNjKCkpJiZjLm5hbWU6YS5tLlNjKCk7cmV0dXJuIGM/bmV3IEYoYyxhLm0uZ2V0KGMpKTpudWxsfWZ1bmN0aW9uIHZkKGEsYil7dmFyIGM7Yz0oYz1xZShhLGIpKT8oYz1jLmZjKCkpJiZjLm5hbWU6YS5tLmZjKCk7cmV0dXJuIGM/bmV3IEYoYyxhLm0uZ2V0KGMpKTpudWxsfWcuUD1mdW5jdGlvbihhLGIpe3ZhciBjPXFlKHRoaXMsYSk7cmV0dXJuIGM/Yy5pYShmdW5jdGlvbihhKXtyZXR1cm4gYihhLm5hbWUsYS5TKX0pOnRoaXMubS5pYShiKX07Zy5YYj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ZYihhLlRjKCksYSl9O1xuZy5ZYj1mdW5jdGlvbihhLGIpe3ZhciBjPXFlKHRoaXMsYik7aWYoYylyZXR1cm4gYy5ZYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5ZYihhLm5hbWUsVGIpLGQ9ZWMoYyk7bnVsbCE9ZCYmMD5iLmNvbXBhcmUoZCxhKTspSihjKSxkPWVjKGMpO3JldHVybiBjfTtnLnNmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLiRiKGEuUWMoKSxhKX07Zy4kYj1mdW5jdGlvbihhLGIpe3ZhciBjPXFlKHRoaXMsYik7aWYoYylyZXR1cm4gYy4kYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS4kYihhLm5hbWUsVGIpLGQ9ZWMoYyk7bnVsbCE9ZCYmMDxiLmNvbXBhcmUoZCxhKTspSihjKSxkPWVjKGMpO3JldHVybiBjfTtnLkRjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmUoKT9hLmUoKT8wOi0xOmEuSygpfHxhLmUoKT8xOmE9PT1WZD8tMTowfTtcbmcubGI9ZnVuY3Rpb24oYSl7aWYoYT09PVFkfHx0YSh0aGlzLndiLmRjLGEudG9TdHJpbmcoKSkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy53YixjPXRoaXMubTtLKGEhPT1RZCxcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7Zm9yKHZhciBkPVtdLGU9ITEsYz1jLlhiKFRiKSxmPUooYyk7ZjspZT1lfHxhLkljKGYuUyksZC5wdXNoKGYpLGY9SihjKTtkPWU/amUoZCx0ZChhKSk6U2Q7ZT1hLnRvU3RyaW5nKCk7Yz14YShiLmRjKTtjW2VdPWE7YT14YShiLkJkKTthW2VdPWQ7cmV0dXJuIG5ldyBSKHRoaXMubSx0aGlzLmFhLG5ldyBoZShhLGMpKX07Zy5KYz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PVFkfHx0YSh0aGlzLndiLmRjLGEudG9TdHJpbmcoKSl9O1xuZy5jYT1mdW5jdGlvbihhKXtpZihhPT09dGhpcylyZXR1cm4hMDtpZihhLksoKSlyZXR1cm4hMTtpZih0aGlzLkMoKS5jYShhLkMoKSkmJnRoaXMubS5jb3VudCgpPT09YS5tLmNvdW50KCkpe3ZhciBiPXRoaXMuWGIoTik7YT1hLlhiKE4pO2Zvcih2YXIgYz1KKGIpLGQ9SihhKTtjJiZkOyl7aWYoYy5uYW1lIT09ZC5uYW1lfHwhYy5TLmNhKGQuUykpcmV0dXJuITE7Yz1KKGIpO2Q9SihhKX1yZXR1cm4gbnVsbD09PWMmJm51bGw9PT1kfXJldHVybiExfTtmdW5jdGlvbiBxZShhLGIpe3JldHVybiBiPT09UWQ/bnVsbDphLndiLmdldChiLnRvU3RyaW5nKCkpfWcudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzLkkoITApKX07ZnVuY3Rpb24gTShhLGIpe2lmKG51bGw9PT1hKXJldHVybiBDO3ZhciBjPW51bGw7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi5wcmlvcml0eVwiaW4gYT9jPWFbXCIucHJpb3JpdHlcIl06XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiJiYoYz1iKTtLKG51bGw9PT1jfHxcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgY3x8XCJvYmplY3RcIj09PXR5cGVvZiBjJiZcIi5zdlwiaW4gYyxcIkludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogXCIrdHlwZW9mIGMpO1wib2JqZWN0XCI9PT10eXBlb2YgYSYmXCIudmFsdWVcImluIGEmJm51bGwhPT1hW1wiLnZhbHVlXCJdJiYoYT1hW1wiLnZhbHVlXCJdKTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fFwiLnN2XCJpbiBhKXJldHVybiBuZXcgdGMoYSxNKGMpKTtpZihhIGluc3RhbmNlb2YgQXJyYXkpe3ZhciBkPUMsZT1hO3IoZSxmdW5jdGlvbihhLGIpe2lmKHYoZSxiKSYmXCIuXCIhPT1iLnN1YnN0cmluZygwLDEpKXt2YXIgYz1NKGEpO2lmKGMuSygpfHwhYy5lKCkpZD1cbmQuVShiLGMpfX0pO3JldHVybiBkLmdhKE0oYykpfXZhciBmPVtdLGg9ITEsaz1hO2liKGssZnVuY3Rpb24oYSl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhfHxcIi5cIiE9PWEuc3Vic3RyaW5nKDAsMSkpe3ZhciBiPU0oa1thXSk7Yi5lKCl8fChoPWh8fCFiLkMoKS5lKCksZi5wdXNoKG5ldyBGKGEsYikpKX19KTtpZigwPT1mLmxlbmd0aClyZXR1cm4gQzt2YXIgbD1qZShmLFViLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWV9LFdiKTtpZihoKXt2YXIgbT1qZShmLHRkKE4pKTtyZXR1cm4gbmV3IFIobCxNKGMpLG5ldyBoZSh7XCIucHJpb3JpdHlcIjptfSx7XCIucHJpb3JpdHlcIjpOfSkpfXJldHVybiBuZXcgUihsLE0oYyksbGUpfXZhciByZT1NYXRoLmxvZygyKTtcbmZ1bmN0aW9uIHNlKGEpe3RoaXMuY291bnQ9cGFyc2VJbnQoTWF0aC5sb2coYSsxKS9yZSwxMCk7dGhpcy5qZj10aGlzLmNvdW50LTE7dGhpcy5lZz1hKzEmcGFyc2VJbnQoQXJyYXkodGhpcy5jb3VudCsxKS5qb2luKFwiMVwiKSwyKX1mdW5jdGlvbiB0ZShhKXt2YXIgYj0hKGEuZWcmMTw8YS5qZik7YS5qZi0tO3JldHVybiBifVxuZnVuY3Rpb24gamUoYSxiLGMsZCl7ZnVuY3Rpb24gZShiLGQpe3ZhciBmPWQtYjtpZigwPT1mKXJldHVybiBudWxsO2lmKDE9PWYpe3ZhciBtPWFbYl0sdD1jP2MobSk6bTtyZXR1cm4gbmV3IGZjKHQsbS5TLCExLG51bGwsbnVsbCl9dmFyIG09cGFyc2VJbnQoZi8yLDEwKStiLGY9ZShiLG0pLHo9ZShtKzEsZCksbT1hW21dLHQ9Yz9jKG0pOm07cmV0dXJuIG5ldyBmYyh0LG0uUywhMSxmLHopfWEuc29ydChiKTt2YXIgZj1mdW5jdGlvbihiKXtmdW5jdGlvbiBkKGIsaCl7dmFyIGs9dC1iLHo9dDt0LT1iO3ZhciB6PWUoaysxLHopLGs9YVtrXSxJPWM/YyhrKTprLHo9bmV3IGZjKEksay5TLGgsbnVsbCx6KTtmP2YubGVmdD16Om09ejtmPXp9Zm9yKHZhciBmPW51bGwsbT1udWxsLHQ9YS5sZW5ndGgsej0wO3o8Yi5jb3VudDsrK3ope3ZhciBJPXRlKGIpLHpkPU1hdGgucG93KDIsYi5jb3VudC0oeisxKSk7ST9kKHpkLCExKTooZCh6ZCwhMSksZCh6ZCwhMCkpfXJldHVybiBtfShuZXcgc2UoYS5sZW5ndGgpKTtcbnJldHVybiBudWxsIT09Zj9uZXcgYWMoZHx8YixmKTpuZXcgYWMoZHx8Yil9ZnVuY3Rpb24gb2UoYSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhP1wibnVtYmVyOlwiK1hjKGEpOlwic3RyaW5nOlwiK2F9ZnVuY3Rpb24gbWUoYSl7aWYoYS5LKCkpe3ZhciBiPWEuSSgpO0soXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwib2JqZWN0XCI9PT10eXBlb2YgYiYmdihiLFwiLnN2XCIpLFwiUHJpb3JpdHkgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIuXCIpfWVsc2UgSyhhPT09VmR8fGEuZSgpLFwicHJpb3JpdHkgb2YgdW5leHBlY3RlZCB0eXBlLlwiKTtLKGE9PT1WZHx8YS5DKCkuZSgpLFwiUHJpb3JpdHkgbm9kZXMgY2FuJ3QgaGF2ZSBhIHByaW9yaXR5IG9mIHRoZWlyIG93bi5cIil9dmFyIEM9bmV3IFIobmV3IGFjKFdiKSxudWxsLGxlKTtmdW5jdGlvbiB1ZSgpe1IuY2FsbCh0aGlzLG5ldyBhYyhXYiksQyxsZSl9bWEodWUsUik7Zz11ZS5wcm90b3R5cGU7XG5nLkRjPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpcz8wOjF9O2cuY2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT10aGlzfTtnLkM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5SPWZ1bmN0aW9uKCl7cmV0dXJuIEN9O2cuZT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgVmQ9bmV3IHVlLFRkPW5ldyBGKFwiW01JTl9OQU1FXVwiLEMpLFpkPW5ldyBGKFwiW01BWF9OQU1FXVwiLFZkKTtmdW5jdGlvbiBJZChhLGIpe3RoaXMuTz1hO3RoaXMuWWQ9Yn1mdW5jdGlvbiBGZChhLGIsYyxkKXtyZXR1cm4gbmV3IElkKG5ldyB0YihiLGMsZCksYS5ZZCl9ZnVuY3Rpb24gSmQoYSl7cmV0dXJuIGEuTy5lYT9hLk8uaigpOm51bGx9SWQucHJvdG90eXBlLnc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ZZH07ZnVuY3Rpb24gdWIoYSl7cmV0dXJuIGEuWWQuZWE/YS5ZZC5qKCk6bnVsbH07ZnVuY3Rpb24gdmUoYSxiKXt0aGlzLlc9YTt2YXIgYz1hLm4sZD1uZXcga2QoYy5nKSxjPVMoYyk/bmV3IGtkKGMuZyk6Yy5qYT9uZXcgcWQoYyk6bmV3IGxkKGMpO3RoaXMuSGY9bmV3IHhkKGMpO3ZhciBlPWIudygpLGY9Yi5PLGg9ZC54YShDLGUuaigpLG51bGwpLGs9Yy54YShDLGYuaigpLG51bGwpO3RoaXMuS2E9bmV3IElkKG5ldyB0YihrLGYuZWEsYy5OYSgpKSxuZXcgdGIoaCxlLmVhLGQuTmEoKSkpO3RoaXMuWGE9W107dGhpcy5sZz1uZXcgY2QoYSl9ZnVuY3Rpb24gd2UoYSl7cmV0dXJuIGEuV31nPXZlLnByb3RvdHlwZTtnLnc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5LYS53KCkuaigpfTtnLmZiPWZ1bmN0aW9uKGEpe3ZhciBiPXViKHRoaXMuS2EpO3JldHVybiBiJiYoUyh0aGlzLlcubil8fCFhLmUoKSYmIWIuUihFKGEpKS5lKCkpP2IuUShhKTpudWxsfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuWGEubGVuZ3RofTtnLlBiPWZ1bmN0aW9uKGEpe3RoaXMuWGEucHVzaChhKX07XG5nLmpiPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYoYil7SyhudWxsPT1hLFwiQSBjYW5jZWwgc2hvdWxkIGNhbmNlbCBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucy5cIik7dmFyIGQ9dGhpcy5XLnBhdGg7T2EodGhpcy5YYSxmdW5jdGlvbihhKXsoYT1hLmdmKGIsZCkpJiZjLnB1c2goYSl9KX1pZihhKXtmb3IodmFyIGU9W10sZj0wO2Y8dGhpcy5YYS5sZW5ndGg7KytmKXt2YXIgaD10aGlzLlhhW2ZdO2lmKCFoLm1hdGNoZXMoYSkpZS5wdXNoKGgpO2Vsc2UgaWYoYS50ZigpKXtlPWUuY29uY2F0KHRoaXMuWGEuc2xpY2UoZisxKSk7YnJlYWt9fXRoaXMuWGE9ZX1lbHNlIHRoaXMuWGE9W107cmV0dXJuIGN9O1xuZy5hYj1mdW5jdGlvbihhLGIsYyl7YS50eXBlPT09QmQmJm51bGwhPT1hLnNvdXJjZS5IYiYmKEsodWIodGhpcy5LYSksXCJXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXNcIiksSyhKZCh0aGlzLkthKSxcIk1pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGVcIikpO3ZhciBkPXRoaXMuS2E7YT10aGlzLkhmLmFiKGQsYSxiLGMpO2I9dGhpcy5IZjtjPWEuamU7SyhjLk8uaigpLkpjKGIuVi5nKSxcIkV2ZW50IHNuYXAgbm90IGluZGV4ZWRcIik7SyhjLncoKS5qKCkuSmMoYi5WLmcpLFwiU2VydmVyIHNuYXAgbm90IGluZGV4ZWRcIik7SyhJYihhLmplLncoKSl8fCFJYihkLncoKSksXCJPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrXCIpO3RoaXMuS2E9YS5qZTtyZXR1cm4geGUodGhpcyxhLmZnLGEuamUuTy5qKCksbnVsbCl9O1xuZnVuY3Rpb24geWUoYSxiKXt2YXIgYz1hLkthLk8sZD1bXTtjLmooKS5LKCl8fGMuaigpLlAoTixmdW5jdGlvbihhLGIpe2QucHVzaChuZXcgRChcImNoaWxkX2FkZGVkXCIsYixhKSl9KTtjLmVhJiZkLnB1c2goRWIoYy5qKCkpKTtyZXR1cm4geGUoYSxkLGMuaigpLGIpfWZ1bmN0aW9uIHhlKGEsYixjLGQpe3JldHVybiBkZChhLmxnLGIsYyxkP1tkXTphLlhhKX07ZnVuY3Rpb24gemUoYSxiLGMpe3RoaXMudHlwZT1CZDt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1iO3RoaXMuY2hpbGRyZW49Y316ZS5wcm90b3R5cGUuWGM9ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXRoLmUoKSlyZXR1cm4gYT10aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IEwoYSkpLGEuZSgpP251bGw6YS52YWx1ZT9uZXcgWGIodGhpcy5zb3VyY2UsRyxhLnZhbHVlKTpuZXcgemUodGhpcy5zb3VyY2UsRyxhKTtLKEUodGhpcy5wYXRoKT09PWEsXCJDYW4ndCBnZXQgYSBtZXJnZSBmb3IgYSBjaGlsZCBub3Qgb24gdGhlIHBhdGggb2YgdGhlIG9wZXJhdGlvblwiKTtyZXR1cm4gbmV3IHplKHRoaXMuc291cmNlLEgodGhpcy5wYXRoKSx0aGlzLmNoaWxkcmVuKX07emUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG1lcmdlOiBcIit0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkrXCIpXCJ9O2Z1bmN0aW9uIEFlKGEsYil7dGhpcy5mPU1jKFwicDpyZXN0OlwiKTt0aGlzLkY9YTt0aGlzLkdiPWI7dGhpcy5BYT1udWxsO3RoaXMuJD17fX1mdW5jdGlvbiBCZShhLGIpe2lmKG4oYikpcmV0dXJuXCJ0YWckXCIrYjtLKGZlKGEubiksXCJzaG91bGQgaGF2ZSBhIHRhZyBpZiBpdCdzIG5vdCBhIGRlZmF1bHQgcXVlcnkuXCIpO3JldHVybiBhLnBhdGgudG9TdHJpbmcoKX1nPUFlLnByb3RvdHlwZTtcbmcueWY9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5wYXRoLnRvU3RyaW5nKCk7dGhpcy5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZStcIiBcIithLnZhKCkpO3ZhciBmPUJlKGEsYyksaD17fTt0aGlzLiRbZl09aDthPWdlKGEubik7dmFyIGs9dGhpcztDZSh0aGlzLGUrXCIuanNvblwiLGEsZnVuY3Rpb24oYSxiKXt2YXIgdD1iOzQwND09PWEmJihhPXQ9bnVsbCk7bnVsbD09PWEmJmsuR2IoZSx0LCExLGMpO3coay4kLGYpPT09aCYmZChhPzQwMT09YT9cInBlcm1pc3Npb25fZGVuaWVkXCI6XCJyZXN0X2Vycm9yOlwiK2E6XCJva1wiLG51bGwpfSl9O2cuUmY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1CZShhLGIpO2RlbGV0ZSB0aGlzLiRbY119O2cuTT1mdW5jdGlvbihhLGIpe3RoaXMuQWE9YTt2YXIgYz0kYyhhKSxkPWMuZGF0YSxjPWMuQmMmJmMuQmMuZXhwO2ImJmIoXCJva1wiLHthdXRoOmQsZXhwaXJlczpjfSl9O2cuZ2U9ZnVuY3Rpb24oYSl7dGhpcy5BYT1udWxsO2EoXCJva1wiLG51bGwpfTtnLk1lPWZ1bmN0aW9uKCl7fTtcbmcuQ2Y9ZnVuY3Rpb24oKXt9O2cuSmQ9ZnVuY3Rpb24oKXt9O2cucHV0PWZ1bmN0aW9uKCl7fTtnLnpmPWZ1bmN0aW9uKCl7fTtnLlVlPWZ1bmN0aW9uKCl7fTtcbmZ1bmN0aW9uIENlKGEsYixjLGQpe2M9Y3x8e307Yy5mb3JtYXQ9XCJleHBvcnRcIjthLkFhJiYoYy5hdXRoPWEuQWEpO3ZhciBlPShhLkYua2I/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSthLkYuaG9zdCtiK1wiP1wiK2tiKGMpO2EuZihcIlNlbmRpbmcgUkVTVCByZXF1ZXN0IGZvciBcIitlKTt2YXIgZj1uZXcgWE1MSHR0cFJlcXVlc3Q7Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihkJiY0PT09Zi5yZWFkeVN0YXRlKXthLmYoXCJSRVNUIFJlc3BvbnNlIGZvciBcIitlK1wiIHJlY2VpdmVkLiBzdGF0dXM6XCIsZi5zdGF0dXMsXCJyZXNwb25zZTpcIixmLnJlc3BvbnNlVGV4dCk7dmFyIGI9bnVsbDtpZigyMDA8PWYuc3RhdHVzJiYzMDA+Zi5zdGF0dXMpe3RyeXtiPW5iKGYucmVzcG9uc2VUZXh0KX1jYXRjaChjKXtPKFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2UgZm9yIFwiK2UrXCI6IFwiK2YucmVzcG9uc2VUZXh0KX1kKG51bGwsYil9ZWxzZSA0MDEhPT1mLnN0YXR1cyYmNDA0IT09XG5mLnN0YXR1cyYmTyhcIkdvdCB1bnN1Y2Nlc3NmdWwgUkVTVCByZXNwb25zZSBmb3IgXCIrZStcIiBTdGF0dXM6IFwiK2Yuc3RhdHVzKSxkKGYuc3RhdHVzKTtkPW51bGx9fTtmLm9wZW4oXCJHRVRcIixlLCEwKTtmLnNlbmQoKX07ZnVuY3Rpb24gRGUoYSl7SyhlYShhKSYmMDxhLmxlbmd0aCxcIlJlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5XCIpO3RoaXMuWGY9YTt0aGlzLk9jPXt9fURlLnByb3RvdHlwZS5mZT1mdW5jdGlvbihhLGIpe3ZhciBjO2M9dGhpcy5PY1thXXx8W107dmFyIGQ9Yy5sZW5ndGg7aWYoMDxkKXtmb3IodmFyIGU9QXJyYXkoZCksZj0wO2Y8ZDtmKyspZVtmXT1jW2ZdO2M9ZX1lbHNlIGM9W107Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLnpjLmFwcGx5KGNbZF0uTWEsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX07RGUucHJvdG90eXBlLkViPWZ1bmN0aW9uKGEsYixjKXtFZSh0aGlzLGEpO3RoaXMuT2NbYV09dGhpcy5PY1thXXx8W107dGhpcy5PY1thXS5wdXNoKHt6YzpiLE1hOmN9KTsoYT10aGlzLkFlKGEpKSYmYi5hcHBseShjLGEpfTtcbkRlLnByb3RvdHlwZS5pYz1mdW5jdGlvbihhLGIsYyl7RWUodGhpcyxhKTthPXRoaXMuT2NbYV18fFtdO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKGFbZF0uemM9PT1iJiYoIWN8fGM9PT1hW2RdLk1hKSl7YS5zcGxpY2UoZCwxKTticmVha319O2Z1bmN0aW9uIEVlKGEsYil7SyhUYShhLlhmLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09Yn0pLFwiVW5rbm93biBldmVudDogXCIrYil9O3ZhciBGZT1mdW5jdGlvbigpe3ZhciBhPTAsYj1bXTtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9Yz09PWE7YT1jO2Zvcih2YXIgZT1BcnJheSg4KSxmPTc7MDw9ZjtmLS0pZVtmXT1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYyU2NCksYz1NYXRoLmZsb29yKGMvNjQpO0soMD09PWMsXCJDYW5ub3QgcHVzaCBhdCB0aW1lID09IDBcIik7Yz1lLmpvaW4oXCJcIik7aWYoZCl7Zm9yKGY9MTE7MDw9ZiYmNjM9PT1iW2ZdO2YtLSliW2ZdPTA7YltmXSsrfWVsc2UgZm9yKGY9MDsxMj5mO2YrKyliW2ZdPU1hdGguZmxvb3IoNjQqTWF0aC5yYW5kb20oKSk7Zm9yKGY9MDsxMj5mO2YrKyljKz1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYltmXSk7SygyMD09PWMubGVuZ3RoLFwibmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC5cIik7XG5yZXR1cm4gY319KCk7ZnVuY3Rpb24gR2UoKXtEZS5jYWxsKHRoaXMsW1wib25saW5lXCJdKTt0aGlzLmtjPSEwO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKXt2YXIgYT10aGlzO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsZnVuY3Rpb24oKXthLmtjfHwoYS5rYz0hMCxhLmZlKFwib25saW5lXCIsITApKX0sITEpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7YS5rYyYmKGEua2M9ITEsYS5mZShcIm9ubGluZVwiLCExKSl9LCExKX19bWEoR2UsRGUpO0dlLnByb3RvdHlwZS5BZT1mdW5jdGlvbihhKXtLKFwib25saW5lXCI9PT1hLFwiVW5rbm93biBldmVudCB0eXBlOiBcIithKTtyZXR1cm5bdGhpcy5rY119O2NhKEdlKTtmdW5jdGlvbiBIZSgpe0RlLmNhbGwodGhpcyxbXCJ2aXNpYmxlXCJdKTt2YXIgYSxiO1widW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciYmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQuaGlkZGVuPyhiPVwidmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJoaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4/KGI9XCJtb3p2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIm1vekhpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50Lm1zSGlkZGVuPyhiPVwibXN2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIm1zSGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuJiYoYj1cIndlYmtpdHZpc2liaWxpdHljaGFuZ2VcIixhPVwid2Via2l0SGlkZGVuXCIpKTt0aGlzLk9iPSEwO2lmKGIpe3ZhciBjPXRoaXM7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiLFxuZnVuY3Rpb24oKXt2YXIgYj0hZG9jdW1lbnRbYV07YiE9PWMuT2ImJihjLk9iPWIsYy5mZShcInZpc2libGVcIixiKSl9LCExKX19bWEoSGUsRGUpO0hlLnByb3RvdHlwZS5BZT1mdW5jdGlvbihhKXtLKFwidmlzaWJsZVwiPT09YSxcIlVua25vd24gZXZlbnQgdHlwZTogXCIrYSk7cmV0dXJuW3RoaXMuT2JdfTtjYShIZSk7ZnVuY3Rpb24gTChhLGIpe2lmKDE9PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubz1hLnNwbGl0KFwiL1wiKTtmb3IodmFyIGM9MCxkPTA7ZDx0aGlzLm8ubGVuZ3RoO2QrKykwPHRoaXMub1tkXS5sZW5ndGgmJih0aGlzLm9bY109dGhpcy5vW2RdLGMrKyk7dGhpcy5vLmxlbmd0aD1jO3RoaXMuWj0wfWVsc2UgdGhpcy5vPWEsdGhpcy5aPWJ9ZnVuY3Rpb24gVChhLGIpe3ZhciBjPUUoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYz09PUUoYikpcmV0dXJuIFQoSChhKSxIKGIpKTt0aHJvdyBFcnJvcihcIklOVEVSTkFMIEVSUk9SOiBpbm5lclBhdGggKFwiK2IrXCIpIGlzIG5vdCB3aXRoaW4gb3V0ZXJQYXRoIChcIithK1wiKVwiKTt9XG5mdW5jdGlvbiBJZShhLGIpe2Zvcih2YXIgYz1hLnNsaWNlKCksZD1iLnNsaWNlKCksZT0wO2U8Yy5sZW5ndGgmJmU8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1WYihjW2VdLGRbZV0pO2lmKDAhPT1mKXJldHVybiBmfXJldHVybiBjLmxlbmd0aD09PWQubGVuZ3RoPzA6Yy5sZW5ndGg8ZC5sZW5ndGg/LTE6MX1mdW5jdGlvbiBFKGEpe3JldHVybiBhLlo+PWEuby5sZW5ndGg/bnVsbDphLm9bYS5aXX1mdW5jdGlvbiBLZChhKXtyZXR1cm4gYS5vLmxlbmd0aC1hLlp9ZnVuY3Rpb24gSChhKXt2YXIgYj1hLlo7YjxhLm8ubGVuZ3RoJiZiKys7cmV0dXJuIG5ldyBMKGEubyxiKX1mdW5jdGlvbiBMZChhKXtyZXR1cm4gYS5aPGEuby5sZW5ndGg/YS5vW2Euby5sZW5ndGgtMV06bnVsbH1nPUwucHJvdG90eXBlO1xuZy50b1N0cmluZz1mdW5jdGlvbigpe2Zvcih2YXIgYT1cIlwiLGI9dGhpcy5aO2I8dGhpcy5vLmxlbmd0aDtiKyspXCJcIiE9PXRoaXMub1tiXSYmKGErPVwiL1wiK3RoaXMub1tiXSk7cmV0dXJuIGF8fFwiL1wifTtnLnNsaWNlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm8uc2xpY2UodGhpcy5aKyhhfHwwKSl9O2cucGFyZW50PWZ1bmN0aW9uKCl7aWYodGhpcy5aPj10aGlzLm8ubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgYT1bXSxiPXRoaXMuWjtiPHRoaXMuby5sZW5ndGgtMTtiKyspYS5wdXNoKHRoaXMub1tiXSk7cmV0dXJuIG5ldyBMKGEsMCl9O1xuZy51PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPXRoaXMuWjtjPHRoaXMuby5sZW5ndGg7YysrKWIucHVzaCh0aGlzLm9bY10pO2lmKGEgaW5zdGFuY2VvZiBMKWZvcihjPWEuWjtjPGEuby5sZW5ndGg7YysrKWIucHVzaChhLm9bY10pO2Vsc2UgZm9yKGE9YS5zcGxpdChcIi9cIiksYz0wO2M8YS5sZW5ndGg7YysrKTA8YVtjXS5sZW5ndGgmJmIucHVzaChhW2NdKTtyZXR1cm4gbmV3IEwoYiwwKX07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWj49dGhpcy5vLmxlbmd0aH07Zy5jYT1mdW5jdGlvbihhKXtpZihLZCh0aGlzKSE9PUtkKGEpKXJldHVybiExO2Zvcih2YXIgYj10aGlzLlosYz1hLlo7Yjw9dGhpcy5vLmxlbmd0aDtiKyssYysrKWlmKHRoaXMub1tiXSE9PWEub1tjXSlyZXR1cm4hMTtyZXR1cm4hMH07XG5nLmNvbnRhaW5zPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuWixjPWEuWjtpZihLZCh0aGlzKT5LZChhKSlyZXR1cm4hMTtmb3IoO2I8dGhpcy5vLmxlbmd0aDspe2lmKHRoaXMub1tiXSE9PWEub1tjXSlyZXR1cm4hMTsrK2I7KytjfXJldHVybiEwfTt2YXIgRz1uZXcgTChcIlwiKTtmdW5jdGlvbiBKZShhLGIpe3RoaXMuUWE9YS5zbGljZSgpO3RoaXMuSGE9TWF0aC5tYXgoMSx0aGlzLlFhLmxlbmd0aCk7dGhpcy5sZj1iO2Zvcih2YXIgYz0wO2M8dGhpcy5RYS5sZW5ndGg7YysrKXRoaXMuSGErPVpjKHRoaXMuUWFbY10pO0tlKHRoaXMpfUplLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEpezA8dGhpcy5RYS5sZW5ndGgmJih0aGlzLkhhKz0xKTt0aGlzLlFhLnB1c2goYSk7dGhpcy5IYSs9WmMoYSk7S2UodGhpcyl9O0plLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlFhLnBvcCgpO3RoaXMuSGEtPVpjKGEpOzA8dGhpcy5RYS5sZW5ndGgmJi0tdGhpcy5IYX07XG5mdW5jdGlvbiBLZShhKXtpZig3Njg8YS5IYSl0aHJvdyBFcnJvcihhLmxmK1wiaGFzIGEga2V5IHBhdGggbG9uZ2VyIHRoYW4gNzY4IGJ5dGVzIChcIithLkhhK1wiKS5cIik7aWYoMzI8YS5RYS5sZW5ndGgpdGhyb3cgRXJyb3IoYS5sZitcInBhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoMzIpIG9yIG9iamVjdCBjb250YWlucyBhIGN5Y2xlIFwiK0xlKGEpKTt9ZnVuY3Rpb24gTGUoYSl7cmV0dXJuIDA9PWEuUWEubGVuZ3RoP1wiXCI6XCJpbiBwcm9wZXJ0eSAnXCIrYS5RYS5qb2luKFwiLlwiKStcIidcIn07ZnVuY3Rpb24gTWUoYSxiKXt0aGlzLnZhbHVlPWE7dGhpcy5jaGlsZHJlbj1ifHxOZX12YXIgTmU9bmV3IGFjKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9PT1iPzA6YTxiPy0xOjF9KTtmdW5jdGlvbiBPZShhKXt2YXIgYj1QZDtyKGEsZnVuY3Rpb24oYSxkKXtiPWIuc2V0KG5ldyBMKGQpLGEpfSk7cmV0dXJuIGJ9Zz1NZS5wcm90b3R5cGU7Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlJiZ0aGlzLmNoaWxkcmVuLmUoKX07ZnVuY3Rpb24gUGUoYSxiLGMpe2lmKG51bGwhPWEudmFsdWUmJmMoYS52YWx1ZSkpcmV0dXJue3BhdGg6Ryx2YWx1ZTphLnZhbHVlfTtpZihiLmUoKSlyZXR1cm4gbnVsbDt2YXIgZD1FKGIpO2E9YS5jaGlsZHJlbi5nZXQoZCk7cmV0dXJuIG51bGwhPT1hPyhiPVBlKGEsSChiKSxjKSxudWxsIT1iP3twYXRoOihuZXcgTChkKSkudShiLnBhdGgpLHZhbHVlOmIudmFsdWV9Om51bGwpOm51bGx9XG5mdW5jdGlvbiBRZShhLGIpe3JldHVybiBQZShhLGIsZnVuY3Rpb24oKXtyZXR1cm4hMH0pfWcuc3VidHJlZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLmNoaWxkcmVuLmdldChFKGEpKTtyZXR1cm4gbnVsbCE9PWI/Yi5zdWJ0cmVlKEgoYSkpOlBkfTtnLnNldD1mdW5jdGlvbihhLGIpe2lmKGEuZSgpKXJldHVybiBuZXcgTWUoYix0aGlzLmNoaWxkcmVuKTt2YXIgYz1FKGEpLGQ9KHRoaXMuY2hpbGRyZW4uZ2V0KGMpfHxQZCkuc2V0KEgoYSksYiksYz10aGlzLmNoaWxkcmVuLk9hKGMsZCk7cmV0dXJuIG5ldyBNZSh0aGlzLnZhbHVlLGMpfTtcbmcucmVtb3ZlPWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzLmNoaWxkcmVuLmUoKT9QZDpuZXcgTWUobnVsbCx0aGlzLmNoaWxkcmVuKTt2YXIgYj1FKGEpLGM9dGhpcy5jaGlsZHJlbi5nZXQoYik7cmV0dXJuIGM/KGE9Yy5yZW1vdmUoSChhKSksYj1hLmUoKT90aGlzLmNoaWxkcmVuLnJlbW92ZShiKTp0aGlzLmNoaWxkcmVuLk9hKGIsYSksbnVsbD09PXRoaXMudmFsdWUmJmIuZSgpP1BkOm5ldyBNZSh0aGlzLnZhbHVlLGIpKTp0aGlzfTtnLmdldD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy52YWx1ZTt2YXIgYj10aGlzLmNoaWxkcmVuLmdldChFKGEpKTtyZXR1cm4gYj9iLmdldChIKGEpKTpudWxsfTtcbmZ1bmN0aW9uIE9kKGEsYixjKXtpZihiLmUoKSlyZXR1cm4gYzt2YXIgZD1FKGIpO2I9T2QoYS5jaGlsZHJlbi5nZXQoZCl8fFBkLEgoYiksYyk7ZD1iLmUoKT9hLmNoaWxkcmVuLnJlbW92ZShkKTphLmNoaWxkcmVuLk9hKGQsYik7cmV0dXJuIG5ldyBNZShhLnZhbHVlLGQpfWZ1bmN0aW9uIFJlKGEsYil7cmV0dXJuIFNlKGEsRyxiKX1mdW5jdGlvbiBTZShhLGIsYyl7dmFyIGQ9e307YS5jaGlsZHJlbi5pYShmdW5jdGlvbihhLGYpe2RbYV09U2UoZixiLnUoYSksYyl9KTtyZXR1cm4gYyhiLGEudmFsdWUsZCl9ZnVuY3Rpb24gVGUoYSxiLGMpe3JldHVybiBVZShhLGIsRyxjKX1mdW5jdGlvbiBVZShhLGIsYyxkKXt2YXIgZT1hLnZhbHVlP2QoYyxhLnZhbHVlKTohMTtpZihlKXJldHVybiBlO2lmKGIuZSgpKXJldHVybiBudWxsO2U9RShiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/VWUoYSxIKGIpLGMudShlKSxkKTpudWxsfVxuZnVuY3Rpb24gVmUoYSxiLGMpe3ZhciBkPUc7aWYoIWIuZSgpKXt2YXIgZT0hMDthLnZhbHVlJiYoZT1jKGQsYS52YWx1ZSkpOyEwPT09ZSYmKGU9RShiKSwoYT1hLmNoaWxkcmVuLmdldChlKSkmJldlKGEsSChiKSxkLnUoZSksYykpfX1mdW5jdGlvbiBXZShhLGIsYyxkKXtpZihiLmUoKSlyZXR1cm4gYTthLnZhbHVlJiZkKGMsYS52YWx1ZSk7dmFyIGU9RShiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/V2UoYSxIKGIpLGMudShlKSxkKTpQZH1mdW5jdGlvbiBNZChhLGIpe1hlKGEsRyxiKX1mdW5jdGlvbiBYZShhLGIsYyl7YS5jaGlsZHJlbi5pYShmdW5jdGlvbihhLGUpe1hlKGUsYi51KGEpLGMpfSk7YS52YWx1ZSYmYyhiLGEudmFsdWUpfWZ1bmN0aW9uIFllKGEsYil7YS5jaGlsZHJlbi5pYShmdW5jdGlvbihhLGQpe2QudmFsdWUmJmIoYSxkLnZhbHVlKX0pfXZhciBQZD1uZXcgTWUobnVsbCk7XG5NZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT17fTtNZCh0aGlzLGZ1bmN0aW9uKGIsYyl7YVtiLnRvU3RyaW5nKCldPWMudG9TdHJpbmcoKX0pO3JldHVybiBCKGEpfTtmdW5jdGlvbiBaZShhLGIsYyl7dGhpcy50eXBlPUVkO3RoaXMuc291cmNlPSRlO3RoaXMucGF0aD1hO3RoaXMuUWI9Yjt0aGlzLlZkPWN9WmUucHJvdG90eXBlLlhjPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpe2lmKG51bGwhPXRoaXMuUWIudmFsdWUpcmV0dXJuIEsodGhpcy5RYi5jaGlsZHJlbi5lKCksXCJhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLlwiKSx0aGlzO2E9dGhpcy5RYi5zdWJ0cmVlKG5ldyBMKGEpKTtyZXR1cm4gbmV3IFplKEcsYSx0aGlzLlZkKX1LKEUodGhpcy5wYXRoKT09PWEsXCJvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC5cIik7cmV0dXJuIG5ldyBaZShIKHRoaXMucGF0aCksdGhpcy5RYix0aGlzLlZkKX07XG5aZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgYWNrIHdyaXRlIHJldmVydD1cIit0aGlzLlZkK1wiIGFmZmVjdGVkVHJlZT1cIit0aGlzLlFiK1wiKVwifTt2YXIgWWI9MCxCZD0xLEVkPTIsJGI9MztmdW5jdGlvbiBhZihhLGIsYyxkKXt0aGlzLndlPWE7dGhpcy5wZj1iO3RoaXMuSGI9Yzt0aGlzLmFmPWQ7SyghZHx8YixcIlRhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuXCIpfXZhciAkZT1uZXcgYWYoITAsITEsbnVsbCwhMSksYmY9bmV3IGFmKCExLCEwLG51bGwsITEpO2FmLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndlP1widXNlclwiOnRoaXMuYWY/XCJzZXJ2ZXIocXVlcnlJRD1cIit0aGlzLkhiK1wiKVwiOlwic2VydmVyXCJ9O2Z1bmN0aW9uIGNmKGEpe3RoaXMuWD1hfXZhciBkZj1uZXcgY2YobmV3IE1lKG51bGwpKTtmdW5jdGlvbiBlZihhLGIsYyl7aWYoYi5lKCkpcmV0dXJuIG5ldyBjZihuZXcgTWUoYykpO3ZhciBkPVFlKGEuWCxiKTtpZihudWxsIT1kKXt2YXIgZT1kLnBhdGgsZD1kLnZhbHVlO2I9VChlLGIpO2Q9ZC5HKGIsYyk7cmV0dXJuIG5ldyBjZihhLlguc2V0KGUsZCkpfWE9T2QoYS5YLGIsbmV3IE1lKGMpKTtyZXR1cm4gbmV3IGNmKGEpfWZ1bmN0aW9uIGZmKGEsYixjKXt2YXIgZD1hO2liKGMsZnVuY3Rpb24oYSxjKXtkPWVmKGQsYi51KGEpLGMpfSk7cmV0dXJuIGR9Y2YucHJvdG90eXBlLlJkPWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiBkZjthPU9kKHRoaXMuWCxhLFBkKTtyZXR1cm4gbmV3IGNmKGEpfTtmdW5jdGlvbiBnZihhLGIpe3ZhciBjPVFlKGEuWCxiKTtyZXR1cm4gbnVsbCE9Yz9hLlguZ2V0KGMucGF0aCkuUShUKGMucGF0aCxiKSk6bnVsbH1cbmZ1bmN0aW9uIGhmKGEpe3ZhciBiPVtdLGM9YS5YLnZhbHVlO251bGwhPWM/Yy5LKCl8fGMuUChOLGZ1bmN0aW9uKGEsYyl7Yi5wdXNoKG5ldyBGKGEsYykpfSk6YS5YLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGEsYyl7bnVsbCE9Yy52YWx1ZSYmYi5wdXNoKG5ldyBGKGEsYy52YWx1ZSkpfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gamYoYSxiKXtpZihiLmUoKSlyZXR1cm4gYTt2YXIgYz1nZihhLGIpO3JldHVybiBudWxsIT1jP25ldyBjZihuZXcgTWUoYykpOm5ldyBjZihhLlguc3VidHJlZShiKSl9Y2YucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5YLmUoKX07Y2YucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe3JldHVybiBrZihHLHRoaXMuWCxhKX07XG5mdW5jdGlvbiBrZihhLGIsYyl7aWYobnVsbCE9Yi52YWx1ZSlyZXR1cm4gYy5HKGEsYi52YWx1ZSk7dmFyIGQ9bnVsbDtiLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGIsZil7XCIucHJpb3JpdHlcIj09PWI/KEsobnVsbCE9PWYudmFsdWUsXCJQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2Rlc1wiKSxkPWYudmFsdWUpOmM9a2YoYS51KGIpLGYsYyl9KTtjLlEoYSkuZSgpfHxudWxsPT09ZHx8KGM9Yy5HKGEudShcIi5wcmlvcml0eVwiKSxkKSk7cmV0dXJuIGN9O2Z1bmN0aW9uIGxmKCl7dGhpcy5UPWRmO3RoaXMubmE9W107dGhpcy5NYz0tMX1mdW5jdGlvbiBtZihhLGIpe2Zvcih2YXIgYz0wO2M8YS5uYS5sZW5ndGg7YysrKXt2YXIgZD1hLm5hW2NdO2lmKGQua2Q9PT1iKXJldHVybiBkfXJldHVybiBudWxsfWc9bGYucHJvdG90eXBlO1xuZy5SZD1mdW5jdGlvbihhKXt2YXIgYj1VYSh0aGlzLm5hLGZ1bmN0aW9uKGIpe3JldHVybiBiLmtkPT09YX0pO0soMDw9YixcInJlbW92ZVdyaXRlIGNhbGxlZCB3aXRoIG5vbmV4aXN0ZW50IHdyaXRlSWQuXCIpO3ZhciBjPXRoaXMubmFbYl07dGhpcy5uYS5zcGxpY2UoYiwxKTtmb3IodmFyIGQ9Yy52aXNpYmxlLGU9ITEsZj10aGlzLm5hLmxlbmd0aC0xO2QmJjA8PWY7KXt2YXIgaD10aGlzLm5hW2ZdO2gudmlzaWJsZSYmKGY+PWImJm5mKGgsYy5wYXRoKT9kPSExOmMucGF0aC5jb250YWlucyhoLnBhdGgpJiYoZT0hMCkpO2YtLX1pZihkKXtpZihlKXRoaXMuVD1vZih0aGlzLm5hLHBmLEcpLHRoaXMuTWM9MDx0aGlzLm5hLmxlbmd0aD90aGlzLm5hW3RoaXMubmEubGVuZ3RoLTFdLmtkOi0xO2Vsc2UgaWYoYy5HYSl0aGlzLlQ9dGhpcy5ULlJkKGMucGF0aCk7ZWxzZXt2YXIgaz10aGlzO3IoYy5jaGlsZHJlbixmdW5jdGlvbihhLGIpe2suVD1rLlQuUmQoYy5wYXRoLnUoYikpfSl9cmV0dXJuITB9cmV0dXJuITF9O1xuZy56YT1mdW5jdGlvbihhLGIsYyxkKXtpZihjfHxkKXt2YXIgZT1qZih0aGlzLlQsYSk7cmV0dXJuIWQmJmUuZSgpP2I6ZHx8bnVsbCE9Ynx8bnVsbCE9Z2YoZSxHKT8oZT1vZih0aGlzLm5hLGZ1bmN0aW9uKGIpe3JldHVybihiLnZpc2libGV8fGQpJiYoIWN8fCEoMDw9TmEoYyxiLmtkKSkpJiYoYi5wYXRoLmNvbnRhaW5zKGEpfHxhLmNvbnRhaW5zKGIucGF0aCkpfSxhKSxiPWJ8fEMsZS5hcHBseShiKSk6bnVsbH1lPWdmKHRoaXMuVCxhKTtpZihudWxsIT1lKXJldHVybiBlO2U9amYodGhpcy5ULGEpO3JldHVybiBlLmUoKT9iOm51bGwhPWJ8fG51bGwhPWdmKGUsRyk/KGI9Ynx8QyxlLmFwcGx5KGIpKTpudWxsfTtcbmcueWM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1DLGQ9Z2YodGhpcy5ULGEpO2lmKGQpZC5LKCl8fGQuUChOLGZ1bmN0aW9uKGEsYil7Yz1jLlUoYSxiKX0pO2Vsc2UgaWYoYil7dmFyIGU9amYodGhpcy5ULGEpO2IuUChOLGZ1bmN0aW9uKGEsYil7dmFyIGQ9amYoZSxuZXcgTChhKSkuYXBwbHkoYik7Yz1jLlUoYSxkKX0pO09hKGhmKGUpLGZ1bmN0aW9uKGEpe2M9Yy5VKGEubmFtZSxhLlMpfSl9ZWxzZSBlPWpmKHRoaXMuVCxhKSxPYShoZihlKSxmdW5jdGlvbihhKXtjPWMuVShhLm5hbWUsYS5TKX0pO3JldHVybiBjfTtnLmxkPWZ1bmN0aW9uKGEsYixjLGQpe0soY3x8ZCxcIkVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFwiKTthPWEudShiKTtpZihudWxsIT1nZih0aGlzLlQsYSkpcmV0dXJuIG51bGw7YT1qZih0aGlzLlQsYSk7cmV0dXJuIGEuZSgpP2QuUShiKTphLmFwcGx5KGQuUShiKSl9O1xuZy54Yz1mdW5jdGlvbihhLGIsYyl7YT1hLnUoYik7dmFyIGQ9Z2YodGhpcy5ULGEpO3JldHVybiBudWxsIT1kP2Q6c2IoYyxiKT9qZih0aGlzLlQsYSkuYXBwbHkoYy5qKCkuUihiKSk6bnVsbH07Zy50Yz1mdW5jdGlvbihhKXtyZXR1cm4gZ2YodGhpcy5ULGEpfTtnLm5lPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgaDthPWpmKHRoaXMuVCxhKTtoPWdmKGEsRyk7aWYobnVsbD09aClpZihudWxsIT1iKWg9YS5hcHBseShiKTtlbHNlIHJldHVybltdO2g9aC5sYihmKTtpZihoLmUoKXx8aC5LKCkpcmV0dXJuW107Yj1bXTthPXRkKGYpO2U9ZT9oLiRiKGMsZik6aC5ZYihjLGYpO2ZvcihmPUooZSk7ZiYmYi5sZW5ndGg8ZDspMCE9PWEoZixjKSYmYi5wdXNoKGYpLGY9SihlKTtyZXR1cm4gYn07XG5mdW5jdGlvbiBuZihhLGIpe3JldHVybiBhLkdhP2EucGF0aC5jb250YWlucyhiKTohIXVhKGEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXtyZXR1cm4gYS5wYXRoLnUoZCkuY29udGFpbnMoYil9KX1mdW5jdGlvbiBwZihhKXtyZXR1cm4gYS52aXNpYmxlfVxuZnVuY3Rpb24gb2YoYSxiLGMpe2Zvcih2YXIgZD1kZixlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoYihmKSl7dmFyIGg9Zi5wYXRoO2lmKGYuR2EpYy5jb250YWlucyhoKT8oaD1UKGMsaCksZD1lZihkLGgsZi5HYSkpOmguY29udGFpbnMoYykmJihoPVQoaCxjKSxkPWVmKGQsRyxmLkdhLlEoaCkpKTtlbHNlIGlmKGYuY2hpbGRyZW4paWYoYy5jb250YWlucyhoKSloPVQoYyxoKSxkPWZmKGQsaCxmLmNoaWxkcmVuKTtlbHNle2lmKGguY29udGFpbnMoYykpaWYoaD1UKGgsYyksaC5lKCkpZD1mZihkLEcsZi5jaGlsZHJlbik7ZWxzZSBpZihmPXcoZi5jaGlsZHJlbixFKGgpKSlmPWYuUShIKGgpKSxkPWVmKGQsRyxmKX1lbHNlIHRocm93IEZjKFwiV3JpdGVSZWNvcmQgc2hvdWxkIGhhdmUgLnNuYXAgb3IgLmNoaWxkcmVuXCIpO319cmV0dXJuIGR9ZnVuY3Rpb24gcWYoYSxiKXt0aGlzLk1iPWE7dGhpcy5YPWJ9Zz1xZi5wcm90b3R5cGU7XG5nLnphPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5YLnphKHRoaXMuTWIsYSxiLGMpfTtnLnljPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlgueWModGhpcy5NYixhKX07Zy5sZD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuWC5sZCh0aGlzLk1iLGEsYixjKX07Zy50Yz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5YLnRjKHRoaXMuTWIudShhKSl9O2cubmU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5YLm5lKHRoaXMuTWIsYSxiLGMsZCxlKX07Zy54Yz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLlgueGModGhpcy5NYixhLGIpfTtnLnU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBxZih0aGlzLk1iLnUoYSksdGhpcy5YKX07ZnVuY3Rpb24gcmYoKXt0aGlzLnlhPXt9fWc9cmYucHJvdG90eXBlO2cuZT1mdW5jdGlvbigpe3JldHVybiB3YSh0aGlzLnlhKX07Zy5hYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5zb3VyY2UuSGI7aWYobnVsbCE9PWQpcmV0dXJuIGQ9dyh0aGlzLnlhLGQpLEsobnVsbCE9ZCxcIlN5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuXCIpLGQuYWIoYSxiLGMpO3ZhciBlPVtdO3IodGhpcy55YSxmdW5jdGlvbihkKXtlPWUuY29uY2F0KGQuYWIoYSxiLGMpKX0pO3JldHVybiBlfTtnLlBiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS52YSgpLGg9dyh0aGlzLnlhLGYpO2lmKCFoKXt2YXIgaD1jLnphKGU/ZDpudWxsKSxrPSExO2g/az0hMDooaD1kIGluc3RhbmNlb2YgUj9jLnljKGQpOkMsaz0hMSk7aD1uZXcgdmUoYSxuZXcgSWQobmV3IHRiKGgsaywhMSksbmV3IHRiKGQsZSwhMSkpKTt0aGlzLnlhW2ZdPWh9aC5QYihiKTtyZXR1cm4geWUoaCxiKX07XG5nLmpiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnZhKCksZT1bXSxmPVtdLGg9bnVsbCE9c2YodGhpcyk7aWYoXCJkZWZhdWx0XCI9PT1kKXt2YXIgaz10aGlzO3IodGhpcy55YSxmdW5jdGlvbihhLGQpe2Y9Zi5jb25jYXQoYS5qYihiLGMpKTthLmUoKSYmKGRlbGV0ZSBrLnlhW2RdLFMoYS5XLm4pfHxlLnB1c2goYS5XKSl9KX1lbHNle3ZhciBsPXcodGhpcy55YSxkKTtsJiYoZj1mLmNvbmNhdChsLmpiKGIsYykpLGwuZSgpJiYoZGVsZXRlIHRoaXMueWFbZF0sUyhsLlcubil8fGUucHVzaChsLlcpKSl9aCYmbnVsbD09c2YodGhpcykmJmUucHVzaChuZXcgVShhLmssYS5wYXRoKSk7cmV0dXJue0tnOmUsbWc6Zn19O2Z1bmN0aW9uIHRmKGEpe3JldHVybiBQYShyYShhLnlhKSxmdW5jdGlvbihhKXtyZXR1cm4hUyhhLlcubil9KX1nLmZiPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7cih0aGlzLnlhLGZ1bmN0aW9uKGMpe2I9Ynx8Yy5mYihhKX0pO3JldHVybiBifTtcbmZ1bmN0aW9uIHVmKGEsYil7aWYoUyhiLm4pKXJldHVybiBzZihhKTt2YXIgYz1iLnZhKCk7cmV0dXJuIHcoYS55YSxjKX1mdW5jdGlvbiBzZihhKXtyZXR1cm4gdmEoYS55YSxmdW5jdGlvbihhKXtyZXR1cm4gUyhhLlcubil9KXx8bnVsbH07ZnVuY3Rpb24gdmYoYSl7dGhpcy50YT1QZDt0aGlzLmliPW5ldyBsZjt0aGlzLiRlPXt9O3RoaXMubWM9e307dGhpcy5OYz1hfWZ1bmN0aW9uIHdmKGEsYixjLGQsZSl7dmFyIGY9YS5pYixoPWU7SyhkPmYuTWMsXCJTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lc1wiKTtuKGgpfHwoaD0hMCk7Zi5uYS5wdXNoKHtwYXRoOmIsR2E6YyxrZDpkLHZpc2libGU6aH0pO2gmJihmLlQ9ZWYoZi5ULGIsYykpO2YuTWM9ZDtyZXR1cm4gZT94ZihhLG5ldyBYYigkZSxiLGMpKTpbXX1mdW5jdGlvbiB5ZihhLGIsYyxkKXt2YXIgZT1hLmliO0soZD5lLk1jLFwiU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7ZS5uYS5wdXNoKHtwYXRoOmIsY2hpbGRyZW46YyxrZDpkLHZpc2libGU6ITB9KTtlLlQ9ZmYoZS5ULGIsYyk7ZS5NYz1kO2M9T2UoYyk7cmV0dXJuIHhmKGEsbmV3IHplKCRlLGIsYykpfVxuZnVuY3Rpb24gemYoYSxiLGMpe2M9Y3x8ITE7dmFyIGQ9bWYoYS5pYixiKTtpZihhLmliLlJkKGIpKXt2YXIgZT1QZDtudWxsIT1kLkdhP2U9ZS5zZXQoRywhMCk6aWIoZC5jaGlsZHJlbixmdW5jdGlvbihhLGIpe2U9ZS5zZXQobmV3IEwoYSksYil9KTtyZXR1cm4geGYoYSxuZXcgWmUoZC5wYXRoLGUsYykpfXJldHVybltdfWZ1bmN0aW9uIEFmKGEsYixjKXtjPU9lKGMpO3JldHVybiB4ZihhLG5ldyB6ZShiZixiLGMpKX1mdW5jdGlvbiBCZihhLGIsYyxkKXtkPUNmKGEsZCk7aWYobnVsbCE9ZCl7dmFyIGU9RGYoZCk7ZD1lLnBhdGg7ZT1lLkhiO2I9VChkLGIpO2M9bmV3IFhiKG5ldyBhZighMSwhMCxlLCEwKSxiLGMpO3JldHVybiBFZihhLGQsYyl9cmV0dXJuW119XG5mdW5jdGlvbiBGZihhLGIsYyxkKXtpZihkPUNmKGEsZCkpe3ZhciBlPURmKGQpO2Q9ZS5wYXRoO2U9ZS5IYjtiPVQoZCxiKTtjPU9lKGMpO2M9bmV3IHplKG5ldyBhZighMSwhMCxlLCEwKSxiLGMpO3JldHVybiBFZihhLGQsYyl9cmV0dXJuW119XG52Zi5wcm90b3R5cGUuUGI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnBhdGgsZD1udWxsLGU9ITE7VmUodGhpcy50YSxjLGZ1bmN0aW9uKGEsYil7dmFyIGY9VChhLGMpO2Q9Yi5mYihmKTtlPWV8fG51bGwhPXNmKGIpO3JldHVybiFkfSk7dmFyIGY9dGhpcy50YS5nZXQoYyk7Zj8oZT1lfHxudWxsIT1zZihmKSxkPWR8fGYuZmIoRykpOihmPW5ldyByZix0aGlzLnRhPXRoaXMudGEuc2V0KGMsZikpO3ZhciBoO251bGwhPWQ/aD0hMDooaD0hMSxkPUMsWWUodGhpcy50YS5zdWJ0cmVlKGMpLGZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5mYihHKTtjJiYoZD1kLlUoYSxjKSl9KSk7dmFyIGs9bnVsbCE9dWYoZixhKTtpZighayYmIVMoYS5uKSl7dmFyIGw9R2YoYSk7SyghKGwgaW4gdGhpcy5tYyksXCJWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZ1wiKTt2YXIgbT1IZisrO3RoaXMubWNbbF09bTt0aGlzLiRlW1wiX1wiK21dPWx9aD1mLlBiKGEsYixuZXcgcWYoYyx0aGlzLmliKSxkLFxuaCk7a3x8ZXx8KGY9dWYoZixhKSxoPWguY29uY2F0KElmKHRoaXMsYSxmKSkpO3JldHVybiBofTtcbnZmLnByb3RvdHlwZS5qYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5wYXRoLGU9dGhpcy50YS5nZXQoZCksZj1bXTtpZihlJiYoXCJkZWZhdWx0XCI9PT1hLnZhKCl8fG51bGwhPXVmKGUsYSkpKXtmPWUuamIoYSxiLGMpO2UuZSgpJiYodGhpcy50YT10aGlzLnRhLnJlbW92ZShkKSk7ZT1mLktnO2Y9Zi5tZztiPS0xIT09VWEoZSxmdW5jdGlvbihhKXtyZXR1cm4gUyhhLm4pfSk7dmFyIGg9VGUodGhpcy50YSxkLGZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPXNmKGIpfSk7aWYoYiYmIWgmJihkPXRoaXMudGEuc3VidHJlZShkKSwhZC5lKCkpKWZvcih2YXIgZD1KZihkKSxrPTA7azxkLmxlbmd0aDsrK2spe3ZhciBsPWRba10sbT1sLlcsbD1LZih0aGlzLGwpO3RoaXMuTmMuWGUoTGYobSksTWYodGhpcyxtKSxsLnhkLGwuSCl9aWYoIWgmJjA8ZS5sZW5ndGgmJiFjKWlmKGIpdGhpcy5OYy5hZShMZihhKSxudWxsKTtlbHNle3ZhciB0PXRoaXM7T2EoZSxmdW5jdGlvbihhKXthLnZhKCk7XG52YXIgYj10Lm1jW0dmKGEpXTt0Lk5jLmFlKExmKGEpLGIpfSl9TmYodGhpcyxlKX1yZXR1cm4gZn07dmYucHJvdG90eXBlLnphPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5pYixkPVRlKHRoaXMudGEsYSxmdW5jdGlvbihiLGMpe3ZhciBkPVQoYixhKTtpZihkPWMuZmIoZCkpcmV0dXJuIGR9KTtyZXR1cm4gYy56YShhLGQsYiwhMCl9O2Z1bmN0aW9uIEpmKGEpe3JldHVybiBSZShhLGZ1bmN0aW9uKGEsYyxkKXtpZihjJiZudWxsIT1zZihjKSlyZXR1cm5bc2YoYyldO3ZhciBlPVtdO2MmJihlPXRmKGMpKTtyKGQsZnVuY3Rpb24oYSl7ZT1lLmNvbmNhdChhKX0pO3JldHVybiBlfSl9ZnVuY3Rpb24gTmYoYSxiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoOysrYyl7dmFyIGQ9YltjXTtpZighUyhkLm4pKXt2YXIgZD1HZihkKSxlPWEubWNbZF07ZGVsZXRlIGEubWNbZF07ZGVsZXRlIGEuJGVbXCJfXCIrZV19fX1cbmZ1bmN0aW9uIExmKGEpe3JldHVybiBTKGEubikmJiFmZShhLm4pP2EuSWIoKTphfWZ1bmN0aW9uIElmKGEsYixjKXt2YXIgZD1iLnBhdGgsZT1NZihhLGIpO2M9S2YoYSxjKTtiPWEuTmMuWGUoTGYoYiksZSxjLnhkLGMuSCk7ZD1hLnRhLnN1YnRyZWUoZCk7aWYoZSlLKG51bGw9PXNmKGQudmFsdWUpLFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtlbHNlIGZvcihlPVJlKGQsZnVuY3Rpb24oYSxiLGMpe2lmKCFhLmUoKSYmYiYmbnVsbCE9c2YoYikpcmV0dXJuW3dlKHNmKGIpKV07dmFyIGQ9W107YiYmKGQ9ZC5jb25jYXQoUWEodGYoYiksZnVuY3Rpb24oYSl7cmV0dXJuIGEuV30pKSk7cihjLGZ1bmN0aW9uKGEpe2Q9ZC5jb25jYXQoYSl9KTtyZXR1cm4gZH0pLGQ9MDtkPGUubGVuZ3RoOysrZCljPWVbZF0sYS5OYy5hZShMZihjKSxNZihhLGMpKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIEtmKGEsYil7dmFyIGM9Yi5XLGQ9TWYoYSxjKTtyZXR1cm57eGQ6ZnVuY3Rpb24oKXtyZXR1cm4oYi53KCl8fEMpLmhhc2goKX0sSDpmdW5jdGlvbihiKXtpZihcIm9rXCI9PT1iKXtpZihkKXt2YXIgZj1jLnBhdGg7aWYoYj1DZihhLGQpKXt2YXIgaD1EZihiKTtiPWgucGF0aDtoPWguSGI7Zj1UKGIsZik7Zj1uZXcgWmIobmV3IGFmKCExLCEwLGgsITApLGYpO2I9RWYoYSxiLGYpfWVsc2UgYj1bXX1lbHNlIGI9eGYoYSxuZXcgWmIoYmYsYy5wYXRoKSk7cmV0dXJuIGJ9Zj1cIlVua25vd24gRXJyb3JcIjtcInRvb19iaWdcIj09PWI/Zj1cIlRoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgdGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0LlwiOlwicGVybWlzc2lvbl9kZW5pZWRcIj09Yj9mPVwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiOlwidW5hdmFpbGFibGVcIj09YiYmXG4oZj1cIlRoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlXCIpO2Y9RXJyb3IoYitcIjogXCIrZik7Zi5jb2RlPWIudG9VcHBlckNhc2UoKTtyZXR1cm4gYS5qYihjLG51bGwsZil9fX1mdW5jdGlvbiBHZihhKXtyZXR1cm4gYS5wYXRoLnRvU3RyaW5nKCkrXCIkXCIrYS52YSgpfWZ1bmN0aW9uIERmKGEpe3ZhciBiPWEuaW5kZXhPZihcIiRcIik7SygtMSE9PWImJmI8YS5sZW5ndGgtMSxcIkJhZCBxdWVyeUtleS5cIik7cmV0dXJue0hiOmEuc3Vic3RyKGIrMSkscGF0aDpuZXcgTChhLnN1YnN0cigwLGIpKX19ZnVuY3Rpb24gQ2YoYSxiKXt2YXIgYz1hLiRlLGQ9XCJfXCIrYjtyZXR1cm4gZCBpbiBjP2NbZF06dm9pZCAwfWZ1bmN0aW9uIE1mKGEsYil7dmFyIGM9R2YoYik7cmV0dXJuIHcoYS5tYyxjKX12YXIgSGY9MTtcbmZ1bmN0aW9uIEVmKGEsYixjKXt2YXIgZD1hLnRhLmdldChiKTtLKGQsXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO3JldHVybiBkLmFiKGMsbmV3IHFmKGIsYS5pYiksbnVsbCl9ZnVuY3Rpb24geGYoYSxiKXtyZXR1cm4gT2YoYSxiLGEudGEsbnVsbCxuZXcgcWYoRyxhLmliKSl9ZnVuY3Rpb24gT2YoYSxiLGMsZCxlKXtpZihiLnBhdGguZSgpKXJldHVybiBQZihhLGIsYyxkLGUpO3ZhciBmPWMuZ2V0KEcpO251bGw9PWQmJm51bGwhPWYmJihkPWYuZmIoRykpO3ZhciBoPVtdLGs9RShiLnBhdGgpLGw9Yi5YYyhrKTtpZigoYz1jLmNoaWxkcmVuLmdldChrKSkmJmwpdmFyIG09ZD9kLlIoayk6bnVsbCxrPWUudShrKSxoPWguY29uY2F0KE9mKGEsbCxjLG0saykpO2YmJihoPWguY29uY2F0KGYuYWIoYixlLGQpKSk7cmV0dXJuIGh9XG5mdW5jdGlvbiBQZihhLGIsYyxkLGUpe3ZhciBmPWMuZ2V0KEcpO251bGw9PWQmJm51bGwhPWYmJihkPWYuZmIoRykpO3ZhciBoPVtdO2MuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYyxmKXt2YXIgbT1kP2QuUihjKTpudWxsLHQ9ZS51KGMpLHo9Yi5YYyhjKTt6JiYoaD1oLmNvbmNhdChQZihhLHosZixtLHQpKSl9KTtmJiYoaD1oLmNvbmNhdChmLmFiKGIsZSxkKSkpO3JldHVybiBofTtmdW5jdGlvbiBRZigpe3RoaXMuY2hpbGRyZW49e307dGhpcy5uZD0wO3RoaXMudmFsdWU9bnVsbH1mdW5jdGlvbiBSZihhLGIsYyl7dGhpcy5HZD1hP2E6XCJcIjt0aGlzLlpjPWI/YjpudWxsO3RoaXMuQT1jP2M6bmV3IFFmfWZ1bmN0aW9uIFNmKGEsYil7Zm9yKHZhciBjPWIgaW5zdGFuY2VvZiBMP2I6bmV3IEwoYiksZD1hLGU7bnVsbCE9PShlPUUoYykpOylkPW5ldyBSZihlLGQsdyhkLkEuY2hpbGRyZW4sZSl8fG5ldyBRZiksYz1IKGMpO3JldHVybiBkfWc9UmYucHJvdG90eXBlO2cuQ2E9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BLnZhbHVlfTtmdW5jdGlvbiBUZihhLGIpe0soXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiLFwiQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWRcIik7YS5BLnZhbHVlPWI7VWYoYSl9Zy5jbGVhcj1mdW5jdGlvbigpe3RoaXMuQS52YWx1ZT1udWxsO3RoaXMuQS5jaGlsZHJlbj17fTt0aGlzLkEubmQ9MDtVZih0aGlzKX07XG5nLndkPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5BLm5kfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuQ2EoKSYmIXRoaXMud2QoKX07Zy5QPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cih0aGlzLkEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXthKG5ldyBSZihkLGIsYykpfSl9O2Z1bmN0aW9uIFZmKGEsYixjLGQpe2MmJiFkJiZiKGEpO2EuUChmdW5jdGlvbihhKXtWZihhLGIsITAsZCl9KTtjJiZkJiZiKGEpfWZ1bmN0aW9uIFdmKGEsYil7Zm9yKHZhciBjPWEucGFyZW50KCk7bnVsbCE9PWMmJiFiKGMpOyljPWMucGFyZW50KCl9Zy5wYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMKG51bGw9PT10aGlzLlpjP3RoaXMuR2Q6dGhpcy5aYy5wYXRoKCkrXCIvXCIrdGhpcy5HZCl9O2cubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkdkfTtnLnBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLlpjfTtcbmZ1bmN0aW9uIFVmKGEpe2lmKG51bGwhPT1hLlpjKXt2YXIgYj1hLlpjLGM9YS5HZCxkPWEuZSgpLGU9dihiLkEuY2hpbGRyZW4sYyk7ZCYmZT8oZGVsZXRlIGIuQS5jaGlsZHJlbltjXSxiLkEubmQtLSxVZihiKSk6ZHx8ZXx8KGIuQS5jaGlsZHJlbltjXT1hLkEsYi5BLm5kKyssVWYoYikpfX07dmFyIFhmPS9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLFlmPS9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLFpmPS9eW2EtekEtWl1bYS16QS1aLl9cXC0rXSskLztmdW5jdGlvbiAkZihhKXtyZXR1cm4gcChhKSYmMCE9PWEubGVuZ3RoJiYhWGYudGVzdChhKX1mdW5jdGlvbiBhZyhhKXtyZXR1cm4gbnVsbD09PWF8fHAoYSl8fGdhKGEpJiYhUWMoYSl8fGlhKGEpJiZ2KGEsXCIuc3ZcIil9ZnVuY3Rpb24gYmcoYSxiLGMsZCl7ZCYmIW4oYil8fGNnKHkoYSwxLGQpLGIsYyl9XG5mdW5jdGlvbiBjZyhhLGIsYyl7YyBpbnN0YW5jZW9mIEwmJihjPW5ldyBKZShjLGEpKTtpZighbihiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgdW5kZWZpbmVkIFwiK0xlKGMpKTtpZihoYShiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYSBmdW5jdGlvbiBcIitMZShjKStcIiB3aXRoIGNvbnRlbnRzOiBcIitiLnRvU3RyaW5nKCkpO2lmKFFjKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBcIitiLnRvU3RyaW5nKCkrXCIgXCIrTGUoYykpO2lmKHAoYikmJmIubGVuZ3RoPjEwNDg1NzYwLzMmJjEwNDg1NzYwPFpjKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gMTA0ODU3NjAgdXRmOCBieXRlcyBcIitMZShjKStcIiAoJ1wiK2Iuc3Vic3RyaW5nKDAsNTApK1wiLi4uJylcIik7aWYoaWEoYikpe3ZhciBkPSExLGU9ITE7aWIoYixmdW5jdGlvbihiLGgpe2lmKFwiLnZhbHVlXCI9PT1iKWQ9ITA7ZWxzZSBpZihcIi5wcmlvcml0eVwiIT09YiYmXCIuc3ZcIiE9PWImJihlPVxuITAsISRmKGIpKSl0aHJvdyBFcnJvcihhK1wiIGNvbnRhaW5zIGFuIGludmFsaWQga2V5IChcIitiK1wiKSBcIitMZShjKSsnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO2MucHVzaChiKTtjZyhhLGgsYyk7Yy5wb3AoKX0pO2lmKGQmJmUpdGhyb3cgRXJyb3IoYSsnIGNvbnRhaW5zIFwiLnZhbHVlXCIgY2hpbGQgJytMZShjKStcIiBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uXCIpO319XG5mdW5jdGlvbiBkZyhhLGIpe3ZhciBjLGQ7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl7ZD1iW2NdO2Zvcih2YXIgZT1kLnNsaWNlKCksZj0wO2Y8ZS5sZW5ndGg7ZisrKWlmKChcIi5wcmlvcml0eVwiIT09ZVtmXXx8ZiE9PWUubGVuZ3RoLTEpJiYhJGYoZVtmXSkpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGFuIGludmFsaWQga2V5IChcIitlW2ZdK1wiKSBpbiBwYXRoIFwiK2QudG9TdHJpbmcoKSsnLiBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7fWIuc29ydChJZSk7ZT1udWxsO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspe2Q9YltjXTtpZihudWxsIT09ZSYmZS5jb250YWlucyhkKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYSBwYXRoIFwiK2UudG9TdHJpbmcoKStcIiB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCBcIitkLnRvU3RyaW5nKCkpO2U9ZH19XG5mdW5jdGlvbiBlZyhhLGIsYyl7dmFyIGQ9eShhLDEsITEpO2lmKCFpYShiKXx8ZWEoYikpdGhyb3cgRXJyb3IoZCtcIiBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLlwiKTt2YXIgZT1bXTtpYihiLGZ1bmN0aW9uKGEsYil7dmFyIGs9bmV3IEwoYSk7Y2coZCxiLGMudShrKSk7aWYoXCIucHJpb3JpdHlcIj09PUxkKGspJiYhYWcoYikpdGhyb3cgRXJyb3IoZCtcImNvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIitrLnRvU3RyaW5nKCkrXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTtlLnB1c2goayl9KTtkZyhkLGUpfVxuZnVuY3Rpb24gZmcoYSxiLGMpe2lmKFFjKGMpKXRocm93IEVycm9yKHkoYSxiLCExKStcImlzIFwiK2MudG9TdHJpbmcoKStcIiwgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO2lmKCFhZyhjKSl0aHJvdyBFcnJvcih5KGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTt9XG5mdW5jdGlvbiBnZyhhLGIsYyl7aWYoIWN8fG4oYikpc3dpdGNoKGIpe2Nhc2UgXCJ2YWx1ZVwiOmNhc2UgXCJjaGlsZF9hZGRlZFwiOmNhc2UgXCJjaGlsZF9yZW1vdmVkXCI6Y2FzZSBcImNoaWxkX2NoYW5nZWRcIjpjYXNlIFwiY2hpbGRfbW92ZWRcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKHkoYSwxLGMpKydtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZTogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO319ZnVuY3Rpb24gaGcoYSxiKXtpZihuKGIpJiYhJGYoYikpdGhyb3cgRXJyb3IoeShhLDIsITApKyd3YXMgYW4gaW52YWxpZCBrZXk6IFwiJytiKydcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO31cbmZ1bmN0aW9uIGlnKGEsYil7aWYoIXAoYil8fDA9PT1iLmxlbmd0aHx8WWYudGVzdChiKSl0aHJvdyBFcnJvcih5KGEsMSwhMSkrJ3dhcyBhbiBpbnZhbGlkIHBhdGg6IFwiJytiKydcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO31mdW5jdGlvbiBqZyhhLGIpe2lmKFwiLmluZm9cIj09PUUoYikpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7fWZ1bmN0aW9uIGtnKGEsYil7aWYoIXAoYikpdGhyb3cgRXJyb3IoeShhLDEsITEpK1wibXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS5cIik7fWZ1bmN0aW9uIGxnKGEsYixjKXtpZighcChjKSl0aHJvdyBFcnJvcih5KGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLlwiKTt9XG5mdW5jdGlvbiBtZyhhLGIpe2xnKGEsMSxiKTtpZighWmYudGVzdChiKSl0aHJvdyBFcnJvcih5KGEsMSwhMSkrXCInXCIrYitcIicgaXMgbm90IGEgdmFsaWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIuXCIpO31mdW5jdGlvbiBuZyhhLGIsYyxkKXtpZighZHx8bihjKSlpZighaWEoYyl8fG51bGw9PT1jKXRocm93IEVycm9yKHkoYSxiLGQpK1wibXVzdCBiZSBhIHZhbGlkIG9iamVjdC5cIik7fWZ1bmN0aW9uIG9nKGEsYixjKXtpZighaWEoYil8fCF2KGIsYykpdGhyb3cgRXJyb3IoeShhLDEsITEpKydtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicrYysnXCInKTtpZighcCh3KGIsYykpKXRocm93IEVycm9yKHkoYSwxLCExKSsnbXVzdCBjb250YWluIHRoZSBrZXkgXCInK2MrJ1wiIHdpdGggdHlwZSBcInN0cmluZ1wiJyk7fTtmdW5jdGlvbiBwZygpe3RoaXMuc2V0PXt9fWc9cGcucHJvdG90eXBlO2cuYWRkPWZ1bmN0aW9uKGEsYil7dGhpcy5zZXRbYV09bnVsbCE9PWI/YjohMH07Zy5jb250YWlucz1mdW5jdGlvbihhKXtyZXR1cm4gdih0aGlzLnNldCxhKX07Zy5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuY29udGFpbnMoYSk/dGhpcy5zZXRbYV06dm9pZCAwfTtnLnJlbW92ZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5zZXRbYV19O2cuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLnNldD17fX07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIHdhKHRoaXMuc2V0KX07Zy5jb3VudD1mdW5jdGlvbigpe3JldHVybiBwYSh0aGlzLnNldCl9O2Z1bmN0aW9uIHFnKGEsYil7cihhLnNldCxmdW5jdGlvbihhLGQpe2IoZCxhKX0pfWcua2V5cz1mdW5jdGlvbigpe3ZhciBhPVtdO3IodGhpcy5zZXQsZnVuY3Rpb24oYixjKXthLnB1c2goYyl9KTtyZXR1cm4gYX07ZnVuY3Rpb24gcWMoKXt0aGlzLm09dGhpcy5CPW51bGx9cWMucHJvdG90eXBlLmZpbmQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5CKXJldHVybiB0aGlzLkIuUShhKTtpZihhLmUoKXx8bnVsbD09dGhpcy5tKXJldHVybiBudWxsO3ZhciBiPUUoYSk7YT1IKGEpO3JldHVybiB0aGlzLm0uY29udGFpbnMoYik/dGhpcy5tLmdldChiKS5maW5kKGEpOm51bGx9O3FjLnByb3RvdHlwZS5uYz1mdW5jdGlvbihhLGIpe2lmKGEuZSgpKXRoaXMuQj1iLHRoaXMubT1udWxsO2Vsc2UgaWYobnVsbCE9PXRoaXMuQil0aGlzLkI9dGhpcy5CLkcoYSxiKTtlbHNle251bGw9PXRoaXMubSYmKHRoaXMubT1uZXcgcGcpO3ZhciBjPUUoYSk7dGhpcy5tLmNvbnRhaW5zKGMpfHx0aGlzLm0uYWRkKGMsbmV3IHFjKTtjPXRoaXMubS5nZXQoYyk7YT1IKGEpO2MubmMoYSxiKX19O1xuZnVuY3Rpb24gcmcoYSxiKXtpZihiLmUoKSlyZXR1cm4gYS5CPW51bGwsYS5tPW51bGwsITA7aWYobnVsbCE9PWEuQil7aWYoYS5CLksoKSlyZXR1cm4hMTt2YXIgYz1hLkI7YS5CPW51bGw7Yy5QKE4sZnVuY3Rpb24oYixjKXthLm5jKG5ldyBMKGIpLGMpfSk7cmV0dXJuIHJnKGEsYil9cmV0dXJuIG51bGwhPT1hLm0/KGM9RShiKSxiPUgoYiksYS5tLmNvbnRhaW5zKGMpJiZyZyhhLm0uZ2V0KGMpLGIpJiZhLm0ucmVtb3ZlKGMpLGEubS5lKCk/KGEubT1udWxsLCEwKTohMSk6ITB9ZnVuY3Rpb24gcmMoYSxiLGMpe251bGwhPT1hLkI/YyhiLGEuQik6YS5QKGZ1bmN0aW9uKGEsZSl7dmFyIGY9bmV3IEwoYi50b1N0cmluZygpK1wiL1wiK2EpO3JjKGUsZixjKX0pfXFjLnByb3RvdHlwZS5QPWZ1bmN0aW9uKGEpe251bGwhPT10aGlzLm0mJnFnKHRoaXMubSxmdW5jdGlvbihiLGMpe2EoYixjKX0pfTt2YXIgc2c9XCJhdXRoLmZpcmViYXNlLmNvbVwiO2Z1bmN0aW9uIHRnKGEsYixjKXt0aGlzLm9kPWF8fHt9O3RoaXMuZWU9Ynx8e307dGhpcy4kYT1jfHx7fTt0aGlzLm9kLnJlbWVtYmVyfHwodGhpcy5vZC5yZW1lbWJlcj1cImRlZmF1bHRcIil9dmFyIHVnPVtcInJlbWVtYmVyXCIsXCJyZWRpcmVjdFRvXCJdO2Z1bmN0aW9uIHZnKGEpe3ZhciBiPXt9LGM9e307aWIoYXx8e30sZnVuY3Rpb24oYSxlKXswPD1OYSh1ZyxhKT9iW2FdPWU6Y1thXT1lfSk7cmV0dXJuIG5ldyB0ZyhiLHt9LGMpfTtmdW5jdGlvbiB3ZyhhLGIpe3RoaXMuUWU9W1wic2Vzc2lvblwiLGEuT2QsYS5oY10uam9pbihcIjpcIik7dGhpcy5iZT1ifXdnLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtpZighYilpZih0aGlzLmJlLmxlbmd0aCliPXRoaXMuYmVbMF07ZWxzZSB0aHJvdyBFcnJvcihcImZiLmxvZ2luLlNlc3Npb25NYW5hZ2VyIDogTm8gc3RvcmFnZSBvcHRpb25zIGF2YWlsYWJsZSFcIik7Yi5zZXQodGhpcy5RZSxhKX07d2cucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPVFhKHRoaXMuYmUscSh0aGlzLnFnLHRoaXMpKSxhPVBhKGEsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hfSk7WGEoYSxmdW5jdGlvbihhLGMpe3JldHVybiBhZChjLnRva2VuKS1hZChhLnRva2VuKX0pO3JldHVybiAwPGEubGVuZ3RoP2Euc2hpZnQoKTpudWxsfTt3Zy5wcm90b3R5cGUucWc9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPWEuZ2V0KHRoaXMuUWUpO2lmKGImJmIudG9rZW4pcmV0dXJuIGJ9Y2F0Y2goYyl7fXJldHVybiBudWxsfTtcbndnLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7T2EodGhpcy5iZSxmdW5jdGlvbihiKXtiLnJlbW92ZShhLlFlKX0pfTtmdW5jdGlvbiB4Zygpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZcInN0cmluZ1wiPT09dHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ/bmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwifWZ1bmN0aW9uIHlnKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJiEhKHdpbmRvdy5jb3Jkb3ZhfHx3aW5kb3cucGhvbmVnYXB8fHdpbmRvdy5QaG9uZUdhcCkmJi9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KHhnKCkpfWZ1bmN0aW9uIHpnKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmL15maWxlOlxcLy8udGVzdChsb2NhdGlvbi5ocmVmKX1cbmZ1bmN0aW9uIEFnKGEpe3ZhciBiPXhnKCk7aWYoXCJcIj09PWIpcmV0dXJuITE7aWYoXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIj09PW5hdmlnYXRvci5hcHBOYW1lKXtpZigoYj1iLm1hdGNoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykpJiYxPGIubGVuZ3RoKXJldHVybiBwYXJzZUZsb2F0KGJbMV0pPj1hfWVsc2UgaWYoLTE8Yi5pbmRleE9mKFwiVHJpZGVudFwiKSYmKGI9Yi5tYXRjaCgvcnY6KFswLTldezIsMn1bXFwuMC05XXswLH0pLykpJiYxPGIubGVuZ3RoKXJldHVybiBwYXJzZUZsb2F0KGJbMV0pPj1hO3JldHVybiExfTtmdW5jdGlvbiBCZygpe3ZhciBhPXdpbmRvdy5vcGVuZXIuZnJhbWVzLGI7Zm9yKGI9YS5sZW5ndGgtMTswPD1iO2ItLSl0cnl7aWYoYVtiXS5sb2NhdGlvbi5wcm90b2NvbD09PXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmYVtiXS5sb2NhdGlvbi5ob3N0PT09d2luZG93LmxvY2F0aW9uLmhvc3QmJlwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCI9PT1hW2JdLm5hbWUpcmV0dXJuIGFbYl19Y2F0Y2goYyl7fXJldHVybiBudWxsfWZ1bmN0aW9uIENnKGEsYixjKXthLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6YS5hZGRFdmVudExpc3RlbmVyJiZhLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX1mdW5jdGlvbiBEZyhhLGIsYyl7YS5kZXRhY2hFdmVudD9hLmRldGFjaEV2ZW50KFwib25cIitiLGMpOmEucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBFZyhhKXsvXmh0dHBzPzpcXC9cXC8vLnRlc3QoYSl8fChhPXdpbmRvdy5sb2NhdGlvbi5ocmVmKTt2YXIgYj0vXihodHRwcz86XFwvXFwvW1xcLV9hLXpBLVpcXC4wLTk6XSspLy5leGVjKGEpO3JldHVybiBiP2JbMV06YX1mdW5jdGlvbiBGZyhhKXt2YXIgYj1cIlwiO3RyeXthPWEucmVwbGFjZShcIiNcIixcIlwiKTt2YXIgYz1sYihhKTtjJiZ2KGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpJiYoYj13KGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpKX1jYXRjaChkKXt9cmV0dXJuIGJ9ZnVuY3Rpb24gR2coKXt2YXIgYT1QYyhzZyk7cmV0dXJuIGEuc2NoZW1lK1wiOi8vXCIrYS5ob3N0K1wiL3YyXCJ9ZnVuY3Rpb24gSGcoYSl7cmV0dXJuIEdnKCkrXCIvXCIrYStcIi9hdXRoL2NoYW5uZWxcIn07ZnVuY3Rpb24gSWcoYSl7dmFyIGI9dGhpczt0aGlzLkFjPWE7dGhpcy5jZT1cIipcIjtBZyg4KT90aGlzLlJjPXRoaXMuemQ9QmcoKToodGhpcy5SYz13aW5kb3cub3BlbmVyLHRoaXMuemQ9d2luZG93KTtpZighYi5SYyl0aHJvd1wiVW5hYmxlIHRvIGZpbmQgcmVsYXkgZnJhbWVcIjtDZyh0aGlzLnpkLFwibWVzc2FnZVwiLHEodGhpcy5qYyx0aGlzKSk7Q2codGhpcy56ZCxcIm1lc3NhZ2VcIixxKHRoaXMuQmYsdGhpcykpO3RyeXtKZyh0aGlzLHthOlwicmVhZHlcIn0pfWNhdGNoKGMpe0NnKHRoaXMuUmMsXCJsb2FkXCIsZnVuY3Rpb24oKXtKZyhiLHthOlwicmVhZHlcIn0pfSl9Q2cod2luZG93LFwidW5sb2FkXCIscSh0aGlzLkJnLHRoaXMpKX1mdW5jdGlvbiBKZyhhLGIpe2I9QihiKTtBZyg4KT9hLlJjLmRvUG9zdChiLGEuY2UpOmEuUmMucG9zdE1lc3NhZ2UoYixhLmNlKX1cbklnLnByb3RvdHlwZS5qYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM7dHJ5e2M9bmIoYS5kYXRhKX1jYXRjaChkKXt9YyYmXCJyZXF1ZXN0XCI9PT1jLmEmJihEZyh3aW5kb3csXCJtZXNzYWdlXCIsdGhpcy5qYyksdGhpcy5jZT1hLm9yaWdpbix0aGlzLkFjJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5BYyhiLmNlLGMuZCxmdW5jdGlvbihhLGMpe2IuZGc9IWM7Yi5BYz12b2lkIDA7SmcoYix7YTpcInJlc3BvbnNlXCIsZDphLGZvcmNlS2VlcFdpbmRvd09wZW46Y30pfSl9LDApKX07SWcucHJvdG90eXBlLkJnPWZ1bmN0aW9uKCl7dHJ5e0RnKHRoaXMuemQsXCJtZXNzYWdlXCIsdGhpcy5CZil9Y2F0Y2goYSl7fXRoaXMuQWMmJihKZyh0aGlzLHthOlwiZXJyb3JcIixkOlwidW5rbm93biBjbG9zZWQgd2luZG93XCJ9KSx0aGlzLkFjPXZvaWQgMCk7dHJ5e3dpbmRvdy5jbG9zZSgpfWNhdGNoKGIpe319O0lnLnByb3RvdHlwZS5CZj1mdW5jdGlvbihhKXtpZih0aGlzLmRnJiZcImRpZVwiPT09YS5kYXRhKXRyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtmdW5jdGlvbiBLZyhhKXt0aGlzLnBjPUdhKCkrR2EoKStHYSgpO3RoaXMuRWY9YX1LZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3ljLnNldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIix0aGlzLnBjKTt5Yy5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5wYyk7Yi5yZXF1ZXN0SWQ9dGhpcy5wYztiLnJlZGlyZWN0VG89Yi5yZWRpcmVjdFRvfHx3aW5kb3cubG9jYXRpb24uaHJlZjthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKStrYihiKTt3aW5kb3cubG9jYXRpb249YX07S2cuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hemcoKSYmIXlnKCl9O0tnLnByb3RvdHlwZS5DYz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07dmFyIExnPXtORVRXT1JLX0VSUk9SOlwiVW5hYmxlIHRvIGNvbnRhY3QgdGhlIEZpcmViYXNlIHNlcnZlci5cIixTRVJWRVJfRVJST1I6XCJBbiB1bmtub3duIHNlcnZlciBlcnJvciBvY2N1cnJlZC5cIixUUkFOU1BPUlRfVU5BVkFJTEFCTEU6XCJUaGVyZSBhcmUgbm8gbG9naW4gdHJhbnNwb3J0cyBhdmFpbGFibGUgZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kLlwiLFJFUVVFU1RfSU5URVJSVVBURUQ6XCJUaGUgYnJvd3NlciByZWRpcmVjdGVkIHRoZSBwYWdlIGJlZm9yZSB0aGUgbG9naW4gcmVxdWVzdCBjb3VsZCBjb21wbGV0ZS5cIixVU0VSX0NBTkNFTExFRDpcIlRoZSB1c2VyIGNhbmNlbGxlZCBhdXRoZW50aWNhdGlvbi5cIn07ZnVuY3Rpb24gTWcoYSl7dmFyIGI9RXJyb3IodyhMZyxhKSxhKTtiLmNvZGU9YTtyZXR1cm4gYn07ZnVuY3Rpb24gTmcoYSl7dmFyIGI7KGI9IWEud2luZG93X2ZlYXR1cmVzKXx8KGI9eGcoKSxiPS0xIT09Yi5pbmRleE9mKFwiRmVubmVjL1wiKXx8LTEhPT1iLmluZGV4T2YoXCJGaXJlZm94L1wiKSYmLTEhPT1iLmluZGV4T2YoXCJBbmRyb2lkXCIpKTtiJiYoYS53aW5kb3dfZmVhdHVyZXM9dm9pZCAwKTthLndpbmRvd19uYW1lfHwoYS53aW5kb3dfbmFtZT1cIl9ibGFua1wiKTt0aGlzLm9wdGlvbnM9YX1cbk5nLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe2gmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGgpLGg9dm9pZCAwKTt0JiYodD1jbGVhckludGVydmFsKHQpKTtEZyh3aW5kb3csXCJtZXNzYWdlXCIsZSk7RGcod2luZG93LFwidW5sb2FkXCIsZCk7aWYobSYmIWEpdHJ5e20uY2xvc2UoKX1jYXRjaChiKXtrLnBvc3RNZXNzYWdlKFwiZGllXCIsbCl9bT1rPXZvaWQgMH1mdW5jdGlvbiBlKGEpe2lmKGEub3JpZ2luPT09bCl0cnl7dmFyIGI9bmIoYS5kYXRhKTtcInJlYWR5XCI9PT1iLmE/ay5wb3N0TWVzc2FnZSh6LGwpOlwiZXJyb3JcIj09PWIuYT8oZCghMSksYyYmKGMoYi5kKSxjPW51bGwpKTpcInJlc3BvbnNlXCI9PT1iLmEmJihkKGIuZm9yY2VLZWVwV2luZG93T3BlbiksYyYmKGMobnVsbCxiLmQpLGM9bnVsbCkpfWNhdGNoKGUpe319dmFyIGY9QWcoOCksaCxrO2lmKCF0aGlzLm9wdGlvbnMucmVsYXlfdXJsKXJldHVybiBjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKTtcbnZhciBsPUVnKGEpO2lmKGwhPT1FZyh0aGlzLm9wdGlvbnMucmVsYXlfdXJsKSljJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhFcnJvcihcImludmFsaWQgYXJndW1lbnRzOiBvcmlnaW4gb2YgdXJsIGFuZCByZWxheV91cmwgbXVzdCBtYXRjaFwiKSl9LDApO2Vsc2V7ZiYmKGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSxoLnNldEF0dHJpYnV0ZShcInNyY1wiLHRoaXMub3B0aW9ucy5yZWxheV91cmwpLGguc3R5bGUuZGlzcGxheT1cIm5vbmVcIixoLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGgpLGs9aC5jb250ZW50V2luZG93KTthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKStrYihiKTt2YXIgbT13aW5kb3cub3BlbihhLHRoaXMub3B0aW9ucy53aW5kb3dfbmFtZSx0aGlzLm9wdGlvbnMud2luZG93X2ZlYXR1cmVzKTtrfHwoaz1tKTt2YXIgdD1zZXRJbnRlcnZhbChmdW5jdGlvbigpe20mJm0uY2xvc2VkJiZcbihkKCExKSxjJiYoYyhNZyhcIlVTRVJfQ0FOQ0VMTEVEXCIpKSxjPW51bGwpKX0sNTAwKSx6PUIoe2E6XCJyZXF1ZXN0XCIsZDpifSk7Q2cod2luZG93LFwidW5sb2FkXCIsZCk7Q2cod2luZG93LFwibWVzc2FnZVwiLGUpfX07XG5OZy5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3ZhciBhO2lmKGE9XCJwb3N0TWVzc2FnZVwiaW4gd2luZG93JiYhemcoKSkoYT15ZygpfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmKCEheGcoKS5tYXRjaCgvV2luZG93cyBQaG9uZS8pfHwhIXdpbmRvdy5XaW5kb3dzJiYvXm1zLWFwcHg6Ly50ZXN0KGxvY2F0aW9uLmhyZWYpKSl8fChhPXhnKCksYT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJiEhKGEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaSl8fGEubWF0Y2goL0NyaU9TLyl8fGEubWF0Y2goL1R3aXR0ZXIgZm9yIGlQaG9uZS8pfHxhLm1hdGNoKC9GQkFOXFwvRkJJT1MvKXx8d2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lKSksYT0hYTtyZXR1cm4gYSYmIXhnKCkubWF0Y2goL1BoYW50b21KUy8pfTtOZy5wcm90b3R5cGUuQ2M9ZnVuY3Rpb24oKXtyZXR1cm5cInBvcHVwXCJ9O2Z1bmN0aW9uIE9nKGEpe2EubWV0aG9kfHwoYS5tZXRob2Q9XCJHRVRcIik7YS5oZWFkZXJzfHwoYS5oZWFkZXJzPXt9KTthLmhlYWRlcnMuY29udGVudF90eXBlfHwoYS5oZWFkZXJzLmNvbnRlbnRfdHlwZT1cImFwcGxpY2F0aW9uL2pzb25cIik7YS5oZWFkZXJzLmNvbnRlbnRfdHlwZT1hLmhlYWRlcnMuY29udGVudF90eXBlLnRvTG93ZXJDYXNlKCk7dGhpcy5vcHRpb25zPWF9XG5PZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKE1nKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX12YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3QsZj10aGlzLm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCksaDtDZyh3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKTtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGMmJjQ9PT1lLnJlYWR5U3RhdGUpe3ZhciBhO2lmKDIwMDw9ZS5zdGF0dXMmJjMwMD5lLnN0YXR1cyl7dHJ5e2E9bmIoZS5yZXNwb25zZVRleHQpfWNhdGNoKGIpe31jKG51bGwsYSl9ZWxzZSA1MDA8PWUuc3RhdHVzJiY2MDA+ZS5zdGF0dXM/YyhNZyhcIlNFUlZFUl9FUlJPUlwiKSk6YyhNZyhcIk5FVFdPUktfRVJST1JcIikpO2M9bnVsbDtEZyh3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKX19O2lmKFwiR0VUXCI9PT1mKWErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK2tiKGIpLGg9bnVsbDtlbHNle3ZhciBrPXRoaXMub3B0aW9ucy5oZWFkZXJzLmNvbnRlbnRfdHlwZTtcblwiYXBwbGljYXRpb24vanNvblwiPT09ayYmKGg9QihiKSk7XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIj09PWsmJihoPWtiKGIpKX1lLm9wZW4oZixhLCEwKTthPXtcIlgtUmVxdWVzdGVkLVdpdGhcIjpcIlhNTEh0dHBSZXF1ZXN0XCIsQWNjZXB0OlwiYXBwbGljYXRpb24vanNvbjt0ZXh0L3BsYWluXCJ9O3phKGEsdGhpcy5vcHRpb25zLmhlYWRlcnMpO2Zvcih2YXIgbCBpbiBhKWUuc2V0UmVxdWVzdEhlYWRlcihsLGFbbF0pO2Uuc2VuZChoKX07T2cuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXt2YXIgYTtpZihhPSEhd2luZG93LlhNTEh0dHBSZXF1ZXN0KWE9eGcoKSxhPSEoYS5tYXRjaCgvTVNJRS8pfHxhLm1hdGNoKC9UcmlkZW50LykpfHxBZygxMCk7cmV0dXJuIGF9O09nLnByb3RvdHlwZS5DYz1mdW5jdGlvbigpe3JldHVyblwianNvblwifTtmdW5jdGlvbiBQZyhhKXt0aGlzLnBjPUdhKCkrR2EoKStHYSgpO3RoaXMuRWY9YX1cblBnLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoTWcoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKX12YXIgZT10aGlzLGY9UGMoc2cpLGg7Yi5yZXF1ZXN0SWQ9dGhpcy5wYztiLnJlZGlyZWN0VG89Zi5zY2hlbWUrXCI6Ly9cIitmLmhvc3QrXCIvYmxhbmsvcGFnZS5odG1sXCI7YSs9L1xcPy8udGVzdChhKT9cIlwiOlwiP1wiO2ErPWtiKGIpOyhoPXdpbmRvdy5vcGVuKGEsXCJfYmxhbmtcIixcImxvY2F0aW9uPW5vXCIpKSYmaGEoaC5hZGRFdmVudExpc3RlbmVyKT8oaC5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsZnVuY3Rpb24oYSl7dmFyIGI7aWYoYj1hJiZhLnVybClhOnt0cnl7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7bS5ocmVmPWEudXJsO2I9bS5ob3N0PT09Zi5ob3N0JiZcIi9ibGFuay9wYWdlLmh0bWxcIj09PW0ucGF0aG5hbWU7YnJlYWsgYX1jYXRjaCh0KXt9Yj0hMX1iJiYoYT1GZyhhLnVybCksaC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXhpdFwiLFxuZCksaC5jbG9zZSgpLGE9bmV3IHRnKG51bGwsbnVsbCx7cmVxdWVzdElkOmUucGMscmVxdWVzdEtleTphfSksZS5FZi5yZXF1ZXN0V2l0aENyZWRlbnRpYWwoXCIvYXV0aC9zZXNzaW9uXCIsYSxjKSxjPW51bGwpfSksaC5hZGRFdmVudExpc3RlbmVyKFwiZXhpdFwiLGQpKTpjKE1nKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX07UGcuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4geWcoKX07UGcucHJvdG90eXBlLkNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJyZWRpcmVjdFwifTtmdW5jdGlvbiBRZyhhKXthLmNhbGxiYWNrX3BhcmFtZXRlcnx8KGEuY2FsbGJhY2tfcGFyYW1ldGVyPVwiY2FsbGJhY2tcIik7dGhpcy5vcHRpb25zPWE7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD13aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wfHx7fX1cblFnLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoTWcoXCJSRVFVRVNUX0lOVEVSUlVQVEVEXCIpKSxjPW51bGwpfWZ1bmN0aW9uIGUoKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucFtmXT12b2lkIDA7d2Eod2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucCkmJih3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wPXZvaWQgMCk7dHJ5e3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGYpO2EmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX1jYXRjaChiKXt9fSwxKTtEZyh3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKX12YXIgZj1cImZuXCIrKG5ldyBEYXRlKS5nZXRUaW1lKCkrTWF0aC5mbG9vcig5OTk5OSpNYXRoLnJhbmRvbSgpKTtiW3RoaXMub3B0aW9ucy5jYWxsYmFja19wYXJhbWV0ZXJdPVwiX19maXJlYmFzZV9hdXRoX2pzb25wLlwiK2Y7YSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikra2IoYik7XG5DZyh3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKTt3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wW2ZdPWZ1bmN0aW9uKGEpe2MmJihjKG51bGwsYSksYz1udWxsKTtlKCl9O1JnKGYsYSxjKX07XG5mdW5jdGlvbiBSZyhhLGIsYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3RyeXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2QudHlwZT1cInRleHQvamF2YXNjcmlwdFwiO2QuaWQ9YTtkLmFzeW5jPSEwO2Quc3JjPWI7ZC5vbmVycm9yPWZ1bmN0aW9uKCl7dmFyIGI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7bnVsbCE9PWImJmIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtjJiZjKE1nKFwiTkVUV09SS19FUlJPUlwiKSl9O3ZhciBlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKTsoZSYmMCE9ZS5sZW5ndGg/ZVswXTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKGQpfWNhdGNoKGYpe2MmJmMoTWcoXCJORVRXT1JLX0VSUk9SXCIpKX19LDApfVFnLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmbnVsbCE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudH07XG5RZy5wcm90b3R5cGUuQ2M9ZnVuY3Rpb24oKXtyZXR1cm5cImpzb25cIn07ZnVuY3Rpb24gU2coYSxiLGMsZCl7RGUuY2FsbCh0aGlzLFtcImF1dGhfc3RhdHVzXCJdKTt0aGlzLkY9YTt0aGlzLmRmPWI7dGhpcy5WZz1jO3RoaXMuTGU9ZDt0aGlzLnNjPW5ldyB3ZyhhLFt4Yyx5Y10pO3RoaXMubWI9bnVsbDt0aGlzLlNlPSExO1RnKHRoaXMpfW1hKFNnLERlKTtnPVNnLnByb3RvdHlwZTtnLnhlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWJ8fG51bGx9O2Z1bmN0aW9uIFRnKGEpe3ljLmdldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIikmJlVnKGEpO3ZhciBiPWEuc2MuZ2V0KCk7YiYmYi50b2tlbj8oVmcoYSxiKSxhLmRmKGIudG9rZW4sZnVuY3Rpb24oYyxkKXtXZyhhLGMsZCwhMSxiLnRva2VuLGIpfSxmdW5jdGlvbihiLGQpe1hnKGEsXCJyZXN1bWVTZXNzaW9uKClcIixiLGQpfSkpOlZnKGEsbnVsbCl9XG5mdW5jdGlvbiBZZyhhLGIsYyxkLGUsZil7XCJmaXJlYmFzZWlvLWRlbW8uY29tXCI9PT1hLkYuZG9tYWluJiZPKFwiRmlyZWJhc2UgYXV0aGVudGljYXRpb24gaXMgbm90IHN1cHBvcnRlZCBvbiBkZW1vIEZpcmViYXNlcyAoKi5maXJlYmFzZWlvLWRlbW8uY29tKS4gVG8gc2VjdXJlIHlvdXIgRmlyZWJhc2UsIGNyZWF0ZSBhIHByb2R1Y3Rpb24gRmlyZWJhc2UgYXQgaHR0cHM6Ly93d3cuZmlyZWJhc2UuY29tLlwiKTthLmRmKGIsZnVuY3Rpb24oZixrKXtXZyhhLGYsaywhMCxiLGMsZHx8e30sZSl9LGZ1bmN0aW9uKGIsYyl7WGcoYSxcImF1dGgoKVwiLGIsYyxmKX0pfWZ1bmN0aW9uIFpnKGEsYil7YS5zYy5jbGVhcigpO1ZnKGEsbnVsbCk7YS5WZyhmdW5jdGlvbihhLGQpe2lmKFwib2tcIj09PWEpUChiLG51bGwpO2Vsc2V7dmFyIGU9KGF8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxmPWU7ZCYmKGYrPVwiOiBcIitkKTtmPUVycm9yKGYpO2YuY29kZT1lO1AoYixmKX19KX1cbmZ1bmN0aW9uIFdnKGEsYixjLGQsZSxmLGgsayl7XCJva1wiPT09Yj8oZCYmKGI9Yy5hdXRoLGYuYXV0aD1iLGYuZXhwaXJlcz1jLmV4cGlyZXMsZi50b2tlbj1iZChlKT9lOlwiXCIsYz1udWxsLGImJnYoYixcInVpZFwiKT9jPXcoYixcInVpZFwiKTp2KGYsXCJ1aWRcIikmJihjPXcoZixcInVpZFwiKSksZi51aWQ9YyxjPVwiY3VzdG9tXCIsYiYmdihiLFwicHJvdmlkZXJcIik/Yz13KGIsXCJwcm92aWRlclwiKTp2KGYsXCJwcm92aWRlclwiKSYmKGM9dyhmLFwicHJvdmlkZXJcIikpLGYucHJvdmlkZXI9YyxhLnNjLmNsZWFyKCksYmQoZSkmJihoPWh8fHt9LGM9eGMsXCJzZXNzaW9uT25seVwiPT09aC5yZW1lbWJlciYmKGM9eWMpLFwibm9uZVwiIT09aC5yZW1lbWJlciYmYS5zYy5zZXQoZixjKSksVmcoYSxmKSksUChrLG51bGwsZikpOihhLnNjLmNsZWFyKCksVmcoYSxudWxsKSxmPWE9KGJ8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxjJiYoZis9XCI6IFwiK2MpLGY9RXJyb3IoZiksZi5jb2RlPWEsUChrLGYpKX1cbmZ1bmN0aW9uIFhnKGEsYixjLGQsZSl7TyhiK1wiIHdhcyBjYW5jZWxlZDogXCIrZCk7YS5zYy5jbGVhcigpO1ZnKGEsbnVsbCk7YT1FcnJvcihkKTthLmNvZGU9Yy50b1VwcGVyQ2FzZSgpO1AoZSxhKX1mdW5jdGlvbiAkZyhhLGIsYyxkLGUpe2FoKGEpO2M9bmV3IHRnKGR8fHt9LHt9LGN8fHt9KTtiaChhLFtPZyxRZ10sXCIvYXV0aC9cIitiLGMsZSl9XG5mdW5jdGlvbiBjaChhLGIsYyxkKXthaChhKTt2YXIgZT1bTmcsUGddO2M9dmcoYyk7XCJhbm9ueW1vdXNcIj09PWJ8fFwicGFzc3dvcmRcIj09PWI/c2V0VGltZW91dChmdW5jdGlvbigpe1AoZCxNZyhcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9LDApOihjLmVlLndpbmRvd19mZWF0dXJlcz1cIm1lbnViYXI9eWVzLG1vZGFsPXllcyxhbHdheXNSYWlzZWQ9eWVzbG9jYXRpb249eWVzLHJlc2l6YWJsZT15ZXMsc2Nyb2xsYmFycz15ZXMsc3RhdHVzPXllcyxoZWlnaHQ9NjI1LHdpZHRoPTYyNSx0b3A9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4uaGVpZ2h0LTYyNSk6MCkrXCIsbGVmdD1cIisoXCJvYmplY3RcIj09PXR5cGVvZiBzY3JlZW4/LjUqKHNjcmVlbi53aWR0aC02MjUpOjApLGMuZWUucmVsYXlfdXJsPUhnKGEuRi5oYyksYy5lZS5yZXF1ZXN0V2l0aENyZWRlbnRpYWw9cShhLnFjLGEpLGJoKGEsZSxcIi9hdXRoL1wiK2IsYyxkKSl9XG5mdW5jdGlvbiBVZyhhKXt2YXIgYj15Yy5nZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO2lmKGIpe3ZhciBjPXljLmdldChcInJlZGlyZWN0X2NsaWVudF9vcHRpb25zXCIpO3ljLnJlbW92ZShcInJlZGlyZWN0X3JlcXVlc3RfaWRcIik7eWMucmVtb3ZlKFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIik7dmFyIGQ9W09nLFFnXSxiPXtyZXF1ZXN0SWQ6YixyZXF1ZXN0S2V5OkZnKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpfSxjPW5ldyB0ZyhjLHt9LGIpO2EuU2U9ITA7dHJ5e2RvY3VtZW50LmxvY2F0aW9uLmhhc2g9ZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKC8mX19maXJlYmFzZV9yZXF1ZXN0X2tleT0oW2EtekEtejAtOV0qKS8sXCJcIil9Y2F0Y2goZSl7fWJoKGEsZCxcIi9hdXRoL3Nlc3Npb25cIixjLGZ1bmN0aW9uKCl7dGhpcy5TZT0hMX0uYmluZChhKSl9fVxuZy5zZT1mdW5jdGlvbihhLGIpe2FoKHRoaXMpO3ZhciBjPXZnKGEpO2MuJGEuX21ldGhvZD1cIlBPU1RcIjt0aGlzLnFjKFwiL3VzZXJzXCIsYyxmdW5jdGlvbihhLGMpe2E/UChiLGEpOlAoYixhLGMpfSl9O2cuVGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2FoKHRoaXMpO3ZhciBkPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKSxlPXZnKGEpO2UuJGEuX21ldGhvZD1cIkRFTEVURVwiO3RoaXMucWMoZCxlLGZ1bmN0aW9uKGEsZCl7IWEmJmQmJmQudWlkJiZjLm1iJiZjLm1iLnVpZCYmYy5tYi51aWQ9PT1kLnVpZCYmWmcoYyk7UChiLGEpfSl9O2cucGU9ZnVuY3Rpb24oYSxiKXthaCh0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPXZnKGEpO2QuJGEuX21ldGhvZD1cIlBVVFwiO2QuJGEucGFzc3dvcmQ9YS5uZXdQYXNzd29yZDt0aGlzLnFjKGMsZCxmdW5jdGlvbihhKXtQKGIsYSl9KX07XG5nLm9lPWZ1bmN0aW9uKGEsYil7YWgodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEub2xkRW1haWwpK1wiL2VtYWlsXCIsZD12ZyhhKTtkLiRhLl9tZXRob2Q9XCJQVVRcIjtkLiRhLmVtYWlsPWEubmV3RW1haWw7ZC4kYS5wYXNzd29yZD1hLnBhc3N3b3JkO3RoaXMucWMoYyxkLGZ1bmN0aW9uKGEpe1AoYixhKX0pfTtnLlZlPWZ1bmN0aW9uKGEsYil7YWgodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpK1wiL3Bhc3N3b3JkXCIsZD12ZyhhKTtkLiRhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5xYyhjLGQsZnVuY3Rpb24oYSl7UChiLGEpfSl9O2cucWM9ZnVuY3Rpb24oYSxiLGMpe2RoKHRoaXMsW09nLFFnXSxhLGIsYyl9O1xuZnVuY3Rpb24gYmgoYSxiLGMsZCxlKXtkaChhLGIsYyxkLGZ1bmN0aW9uKGIsYyl7IWImJmMmJmMudG9rZW4mJmMudWlkP1lnKGEsYy50b2tlbixjLGQub2QsZnVuY3Rpb24oYSxiKXthP1AoZSxhKTpQKGUsbnVsbCxiKX0pOlAoZSxifHxNZyhcIlVOS05PV05fRVJST1JcIikpfSl9XG5mdW5jdGlvbiBkaChhLGIsYyxkLGUpe2I9UGEoYixmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5pc0F2YWlsYWJsZSYmYS5pc0F2YWlsYWJsZSgpfSk7MD09PWIubGVuZ3RoP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtQKGUsTWcoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYj1uZXcgKGIuc2hpZnQoKSkoZC5lZSksZD1qYihkLiRhKSxkLnY9XCJqcy1cIitoYixkLnRyYW5zcG9ydD1iLkNjKCksZC5zdXBwcmVzc19zdGF0dXNfY29kZXM9ITAsYT1HZygpK1wiL1wiK2EuRi5oYytjLGIub3BlbihhLGQsZnVuY3Rpb24oYSxiKXtpZihhKVAoZSxhKTtlbHNlIGlmKGImJmIuZXJyb3Ipe3ZhciBjPUVycm9yKGIuZXJyb3IubWVzc2FnZSk7Yy5jb2RlPWIuZXJyb3IuY29kZTtjLmRldGFpbHM9Yi5lcnJvci5kZXRhaWxzO1AoZSxjKX1lbHNlIFAoZSxudWxsLGIpfSkpfVxuZnVuY3Rpb24gVmcoYSxiKXt2YXIgYz1udWxsIT09YS5tYnx8bnVsbCE9PWI7YS5tYj1iO2MmJmEuZmUoXCJhdXRoX3N0YXR1c1wiLGIpO2EuTGUobnVsbCE9PWIpfWcuQWU9ZnVuY3Rpb24oYSl7SyhcImF1dGhfc3RhdHVzXCI9PT1hLCdpbml0aWFsIGV2ZW50IG11c3QgYmUgb2YgdHlwZSBcImF1dGhfc3RhdHVzXCInKTtyZXR1cm4gdGhpcy5TZT9udWxsOlt0aGlzLm1iXX07ZnVuY3Rpb24gYWgoYSl7dmFyIGI9YS5GO2lmKFwiZmlyZWJhc2Vpby5jb21cIiE9PWIuZG9tYWluJiZcImZpcmViYXNlaW8tZGVtby5jb21cIiE9PWIuZG9tYWluJiZcImF1dGguZmlyZWJhc2UuY29tXCI9PT1zZyl0aHJvdyBFcnJvcihcIlRoaXMgY3VzdG9tIEZpcmViYXNlIHNlcnZlciAoJ1wiK2EuRi5kb21haW4rXCInKSBkb2VzIG5vdCBzdXBwb3J0IGRlbGVnYXRlZCBsb2dpbi5cIik7fTt2YXIgQ2M9XCJ3ZWJzb2NrZXRcIixEYz1cImxvbmdfcG9sbGluZ1wiO2Z1bmN0aW9uIGVoKGEpe3RoaXMuamM9YTt0aGlzLk5kPVtdO3RoaXMuU2I9MDt0aGlzLnFlPS0xO3RoaXMuRmI9bnVsbH1mdW5jdGlvbiBmaChhLGIsYyl7YS5xZT1iO2EuRmI9YzthLnFlPGEuU2ImJihhLkZiKCksYS5GYj1udWxsKX1mdW5jdGlvbiBnaChhLGIsYyl7Zm9yKGEuTmRbYl09YzthLk5kW2EuU2JdOyl7dmFyIGQ9YS5OZFthLlNiXTtkZWxldGUgYS5OZFthLlNiXTtmb3IodmFyIGU9MDtlPGQubGVuZ3RoOysrZSlpZihkW2VdKXt2YXIgZj1hO0RiKGZ1bmN0aW9uKCl7Zi5qYyhkW2VdKX0pfWlmKGEuU2I9PT1hLnFlKXthLkZiJiYoY2xlYXJUaW1lb3V0KGEuRmIpLGEuRmIoKSxhLkZiPW51bGwpO2JyZWFrfWEuU2IrK319O2Z1bmN0aW9uIGhoKGEsYixjLGQpe3RoaXMucmU9YTt0aGlzLmY9TWMoYSk7dGhpcy5uYj10aGlzLm9iPTA7dGhpcy5VYT1SYihiKTt0aGlzLlFmPWM7dGhpcy5IYz0hMTt0aGlzLkJiPWQ7dGhpcy5qZD1mdW5jdGlvbihhKXtyZXR1cm4gQmMoYixEYyxhKX19dmFyIGloLGpoO1xuaGgucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt0aGlzLmhmPTA7dGhpcy5sYT1iO3RoaXMuQWY9bmV3IGVoKGEpO3RoaXMuemI9ITE7dmFyIGM9dGhpczt0aGlzLnFiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuXCIpO2MuZ2IoKTtjLnFiPW51bGx9LE1hdGguZmxvb3IoM0U0KSk7UmMoZnVuY3Rpb24oKXtpZighYy56Yil7Yy5TYT1uZXcga2goZnVuY3Rpb24oYSxiLGQsayxsKXtsaChjLGFyZ3VtZW50cyk7aWYoYy5TYSlpZihjLnFiJiYoY2xlYXJUaW1lb3V0KGMucWIpLGMucWI9bnVsbCksYy5IYz0hMCxcInN0YXJ0XCI9PWEpYy5pZD1iLGMuR2Y9ZDtlbHNlIGlmKFwiY2xvc2VcIj09PWEpYj8oYy5TYS5YZD0hMSxmaChjLkFmLGIsZnVuY3Rpb24oKXtjLmdiKCl9KSk6Yy5nYigpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogXCIrYSk7fSxmdW5jdGlvbihhLGIpe2xoKGMsYXJndW1lbnRzKTtcbmdoKGMuQWYsYSxiKX0sZnVuY3Rpb24oKXtjLmdiKCl9LGMuamQpO3ZhciBhPXtzdGFydDpcInRcIn07YS5zZXI9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7Yy5TYS5oZSYmKGEuY2I9Yy5TYS5oZSk7YS52PVwiNVwiO2MuUWYmJihhLnM9Yy5RZik7Yy5CYiYmKGEubHM9Yy5CYik7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKGEucj1cImZcIik7YT1jLmpkKGEpO2MuZihcIkNvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byBcIithKTttaChjLlNhLGEsZnVuY3Rpb24oKXt9KX19KX07XG5oaC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlNhLGI9dGhpcy5HZjthLnVnPXRoaXMuaWQ7YS52Zz1iO2ZvcihhLmxlPSEwO25oKGEpOyk7YT10aGlzLmlkO2I9dGhpcy5HZjt0aGlzLmdjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7dmFyIGM9e2RmcmFtZTpcInRcIn07Yy5pZD1hO2MucHc9Yjt0aGlzLmdjLnNyYz10aGlzLmpkKGMpO3RoaXMuZ2Muc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZ2MpfTtcbmhoLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGlofHwhamgmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQmJm51bGwhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQmJiEoXCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jaHJvbWUmJndpbmRvdy5jaHJvbWUuZXh0ZW5zaW9uJiYhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKSYmIShcIm9iamVjdFwiPT09dHlwZW9mIFdpbmRvd3MmJlwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cy5YZykmJiEwfTtnPWhoLnByb3RvdHlwZTtnLkVkPWZ1bmN0aW9uKCl7fTtnLmRkPWZ1bmN0aW9uKCl7dGhpcy56Yj0hMDt0aGlzLlNhJiYodGhpcy5TYS5jbG9zZSgpLHRoaXMuU2E9bnVsbCk7dGhpcy5nYyYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5nYyksdGhpcy5nYz1udWxsKTt0aGlzLnFiJiYoY2xlYXJUaW1lb3V0KHRoaXMucWIpLHRoaXMucWI9bnVsbCl9O1xuZy5nYj1mdW5jdGlvbigpe3RoaXMuemJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLmRkKCksdGhpcy5sYSYmKHRoaXMubGEodGhpcy5IYyksdGhpcy5sYT1udWxsKSl9O2cuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnpifHwodGhpcy5mKFwiTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLlwiKSx0aGlzLmRkKCkpfTtnLnNlbmQ9ZnVuY3Rpb24oYSl7YT1CKGEpO3RoaXMub2IrPWEubGVuZ3RoO09iKHRoaXMuVWEsXCJieXRlc19zZW50XCIsYS5sZW5ndGgpO2E9SWMoYSk7YT1mYihhLCEwKTthPVZjKGEsMTg0MCk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuU2E7Yy5hZC5wdXNoKHtNZzp0aGlzLmhmLFVnOmEubGVuZ3RoLGtmOmFbYl19KTtjLmxlJiZuaChjKTt0aGlzLmhmKyt9fTtmdW5jdGlvbiBsaChhLGIpe3ZhciBjPUIoYikubGVuZ3RoO2EubmIrPWM7T2IoYS5VYSxcImJ5dGVzX3JlY2VpdmVkXCIsYyl9XG5mdW5jdGlvbiBraChhLGIsYyxkKXt0aGlzLmpkPWQ7dGhpcy5oYj1jO3RoaXMuUGU9bmV3IHBnO3RoaXMuYWQ9W107dGhpcy50ZT1NYXRoLmZsb29yKDFFOCpNYXRoLnJhbmRvbSgpKTt0aGlzLlhkPSEwO3RoaXMuaGU9RWMoKTt3aW5kb3dbXCJwTFBDb21tYW5kXCIrdGhpcy5oZV09YTt3aW5kb3dbXCJwUlRMUENCXCIrdGhpcy5oZV09YjthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2lmKGRvY3VtZW50LmJvZHkpe2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7dHJ5e2EuY29udGVudFdpbmRvdy5kb2N1bWVudHx8Q2IoXCJObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZFwiKX1jYXRjaChlKXthLnNyYz1cImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIitkb2N1bWVudC5kb21haW4rXCInO2RvY3VtZW50LmNsb3NlKCk7fSkoKSlcIn19ZWxzZSB0aHJvd1wiRG9jdW1lbnQgYm9keSBoYXMgbm90IGluaXRpYWxpemVkLiBXYWl0IHRvIGluaXRpYWxpemUgRmlyZWJhc2UgdW50aWwgYWZ0ZXIgdGhlIGRvY3VtZW50IGlzIHJlYWR5LlwiO1xuYS5jb250ZW50RG9jdW1lbnQ/YS5lYj1hLmNvbnRlbnREb2N1bWVudDphLmNvbnRlbnRXaW5kb3c/YS5lYj1hLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6YS5kb2N1bWVudCYmKGEuZWI9YS5kb2N1bWVudCk7dGhpcy5FYT1hO2E9XCJcIjt0aGlzLkVhLnNyYyYmXCJqYXZhc2NyaXB0OlwiPT09dGhpcy5FYS5zcmMuc3Vic3RyKDAsMTEpJiYoYT0nPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInK2RvY3VtZW50LmRvbWFpbisnXCI7XFx4M2Mvc2NyaXB0PicpO2E9XCI8aHRtbD48Ym9keT5cIithK1wiPC9ib2R5PjwvaHRtbD5cIjt0cnl7dGhpcy5FYS5lYi5vcGVuKCksdGhpcy5FYS5lYi53cml0ZShhKSx0aGlzLkVhLmViLmNsb3NlKCl9Y2F0Y2goZil7Q2IoXCJmcmFtZSB3cml0aW5nIGV4Y2VwdGlvblwiKSxmLnN0YWNrJiZDYihmLnN0YWNrKSxDYihmKX19XG5raC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLmxlPSExO2lmKHRoaXMuRWEpe3RoaXMuRWEuZWIuYm9keS5pbm5lckhUTUw9XCJcIjt2YXIgYT10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtudWxsIT09YS5FYSYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYS5FYSksYS5FYT1udWxsKX0sTWF0aC5mbG9vcigwKSl9dmFyIGI9dGhpcy5oYjtiJiYodGhpcy5oYj1udWxsLGIoKSl9O1xuZnVuY3Rpb24gbmgoYSl7aWYoYS5sZSYmYS5YZCYmYS5QZS5jb3VudCgpPCgwPGEuYWQubGVuZ3RoPzI6MSkpe2EudGUrKzt2YXIgYj17fTtiLmlkPWEudWc7Yi5wdz1hLnZnO2Iuc2VyPWEudGU7Zm9yKHZhciBiPWEuamQoYiksYz1cIlwiLGQ9MDswPGEuYWQubGVuZ3RoOylpZigxODcwPj1hLmFkWzBdLmtmLmxlbmd0aCszMCtjLmxlbmd0aCl7dmFyIGU9YS5hZC5zaGlmdCgpLGM9YytcIiZzZWdcIitkK1wiPVwiK2UuTWcrXCImdHNcIitkK1wiPVwiK2UuVWcrXCImZFwiK2QrXCI9XCIrZS5rZjtkKyt9ZWxzZSBicmVhaztvaChhLGIrYyxhLnRlKTtyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBvaChhLGIsYyl7ZnVuY3Rpb24gZCgpe2EuUGUucmVtb3ZlKGMpO25oKGEpfWEuUGUuYWRkKGMsMSk7dmFyIGU9c2V0VGltZW91dChkLE1hdGguZmxvb3IoMjVFMykpO21oKGEsYixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlKTtkKCl9KX1cbmZ1bmN0aW9uIG1oKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e2lmKGEuWGQpe3ZhciBkPWEuRWEuZWIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmFzeW5jPSEwO2Quc3JjPWI7ZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT1kLnJlYWR5U3RhdGU7YSYmXCJsb2FkZWRcIiE9PWEmJlwiY29tcGxldGVcIiE9PWF8fChkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGQucGFyZW50Tm9kZSYmZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGMoKSl9O2Qub25lcnJvcj1mdW5jdGlvbigpe0NiKFwiTG9uZy1wb2xsIHNjcmlwdCBmYWlsZWQgdG8gbG9hZDogXCIrYik7YS5YZD0hMTthLmNsb3NlKCl9O2EuRWEuZWIuYm9keS5hcHBlbmRDaGlsZChkKX19Y2F0Y2goZSl7fX0sTWF0aC5mbG9vcigxKSl9O3ZhciBwaD1udWxsO1widW5kZWZpbmVkXCIhPT10eXBlb2YgTW96V2ViU29ja2V0P3BoPU1veldlYlNvY2tldDpcInVuZGVmaW5lZFwiIT09dHlwZW9mIFdlYlNvY2tldCYmKHBoPVdlYlNvY2tldCk7ZnVuY3Rpb24gcWgoYSxiLGMsZCl7dGhpcy5yZT1hO3RoaXMuZj1NYyh0aGlzLnJlKTt0aGlzLmZyYW1lcz10aGlzLktjPW51bGw7dGhpcy5uYj10aGlzLm9iPXRoaXMuYmY9MDt0aGlzLlVhPVJiKGIpO2E9e3Y6XCI1XCJ9O1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2MmJihhLnM9Yyk7ZCYmKGEubHM9ZCk7dGhpcy5lZj1CYyhiLENjLGEpfXZhciByaDtcbnFoLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy5oYj1iO3RoaXMuemc9YTt0aGlzLmYoXCJXZWJzb2NrZXQgY29ubmVjdGluZyB0byBcIit0aGlzLmVmKTt0aGlzLkhjPSExO3hjLnNldChcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIsITApO3RyeXt0aGlzLnVhPW5ldyBwaCh0aGlzLmVmKX1jYXRjaChjKXt0aGlzLmYoXCJFcnJvciBpbnN0YW50aWF0aW5nIFdlYlNvY2tldC5cIik7dmFyIGQ9Yy5tZXNzYWdlfHxjLmRhdGE7ZCYmdGhpcy5mKGQpO3RoaXMuZ2IoKTtyZXR1cm59dmFyIGU9dGhpczt0aGlzLnVhLm9ub3Blbj1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0ZWQuXCIpO2UuSGM9ITB9O3RoaXMudWEub25jbG9zZT1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuXCIpO2UudWE9bnVsbDtlLmdiKCl9O3RoaXMudWEub25tZXNzYWdlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1lLnVhKWlmKGE9YS5kYXRhLGUubmIrPVxuYS5sZW5ndGgsT2IoZS5VYSxcImJ5dGVzX3JlY2VpdmVkXCIsYS5sZW5ndGgpLHNoKGUpLG51bGwhPT1lLmZyYW1lcyl0aChlLGEpO2Vsc2V7YTp7SyhudWxsPT09ZS5mcmFtZXMsXCJXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXJcIik7aWYoNj49YS5sZW5ndGgpe3ZhciBiPU51bWJlcihhKTtpZighaXNOYU4oYikpe2UuYmY9YjtlLmZyYW1lcz1bXTthPW51bGw7YnJlYWsgYX19ZS5iZj0xO2UuZnJhbWVzPVtdfW51bGwhPT1hJiZ0aChlLGEpfX07dGhpcy51YS5vbmVycm9yPWZ1bmN0aW9uKGEpe2UuZihcIldlYlNvY2tldCBlcnJvci4gIENsb3NpbmcgY29ubmVjdGlvbi5cIik7KGE9YS5tZXNzYWdlfHxhLmRhdGEpJiZlLmYoYSk7ZS5nYigpfX07cWgucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7fTtcbnFoLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7dmFyIGE9ITE7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQpe3ZhciBiPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvKTtiJiYxPGIubGVuZ3RoJiY0LjQ+cGFyc2VGbG9hdChiWzFdKSYmKGE9ITApfXJldHVybiFhJiZudWxsIT09cGgmJiFyaH07cWgucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeT0yO3FoLmhlYWx0aHlUaW1lb3V0PTNFNDtnPXFoLnByb3RvdHlwZTtnLkVkPWZ1bmN0aW9uKCl7eGMucmVtb3ZlKFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIil9O2Z1bmN0aW9uIHRoKGEsYil7YS5mcmFtZXMucHVzaChiKTtpZihhLmZyYW1lcy5sZW5ndGg9PWEuYmYpe3ZhciBjPWEuZnJhbWVzLmpvaW4oXCJcIik7YS5mcmFtZXM9bnVsbDtjPW5iKGMpO2EuemcoYyl9fVxuZy5zZW5kPWZ1bmN0aW9uKGEpe3NoKHRoaXMpO2E9QihhKTt0aGlzLm9iKz1hLmxlbmd0aDtPYih0aGlzLlVhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPVZjKGEsMTYzODQpOzE8YS5sZW5ndGgmJnRoaXMudWEuc2VuZChTdHJpbmcoYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnVhLnNlbmQoYVtiXSl9O2cuZGQ9ZnVuY3Rpb24oKXt0aGlzLnpiPSEwO3RoaXMuS2MmJihjbGVhckludGVydmFsKHRoaXMuS2MpLHRoaXMuS2M9bnVsbCk7dGhpcy51YSYmKHRoaXMudWEuY2xvc2UoKSx0aGlzLnVhPW51bGwpfTtnLmdiPWZ1bmN0aW9uKCl7dGhpcy56Ynx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLmRkKCksdGhpcy5oYiYmKHRoaXMuaGIodGhpcy5IYyksdGhpcy5oYj1udWxsKSl9O2cuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnpifHwodGhpcy5mKFwiV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZFwiKSx0aGlzLmRkKCkpfTtcbmZ1bmN0aW9uIHNoKGEpe2NsZWFySW50ZXJ2YWwoYS5LYyk7YS5LYz1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2EudWEmJmEudWEuc2VuZChcIjBcIik7c2goYSl9LE1hdGguZmxvb3IoNDVFMykpfTtmdW5jdGlvbiB1aChhKXt2aCh0aGlzLGEpfXZhciB3aD1baGgscWhdO2Z1bmN0aW9uIHZoKGEsYil7dmFyIGM9cWgmJnFoLmlzQXZhaWxhYmxlKCksZD1jJiYhKHhjLndmfHwhMD09PXhjLmdldChcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIpKTtiLldnJiYoY3x8TyhcIndzczovLyBVUkwgdXNlZCwgYnV0IGJyb3dzZXIgaXNuJ3Qga25vd24gdG8gc3VwcG9ydCB3ZWJzb2NrZXRzLiAgVHJ5aW5nIGFueXdheS5cIiksZD0hMCk7aWYoZClhLmdkPVtxaF07ZWxzZXt2YXIgZT1hLmdkPVtdO1djKHdoLGZ1bmN0aW9uKGEsYil7YiYmYi5pc0F2YWlsYWJsZSgpJiZlLnB1c2goYil9KX19ZnVuY3Rpb24geGgoYSl7aWYoMDxhLmdkLmxlbmd0aClyZXR1cm4gYS5nZFswXTt0aHJvdyBFcnJvcihcIk5vIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIpO307ZnVuY3Rpb24geWgoYSxiLGMsZCxlLGYsaCl7dGhpcy5pZD1hO3RoaXMuZj1NYyhcImM6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy5qYz1jO3RoaXMuV2M9ZDt0aGlzLmxhPWU7dGhpcy5OZT1mO3RoaXMuRj1iO3RoaXMuTWQ9W107dGhpcy5mZj0wO3RoaXMuUGY9bmV3IHVoKGIpO3RoaXMuVGE9MDt0aGlzLkJiPWg7dGhpcy5mKFwiQ29ubmVjdGlvbiBjcmVhdGVkXCIpO3poKHRoaXMpfVxuZnVuY3Rpb24gemgoYSl7dmFyIGI9eGgoYS5QZik7YS5KPW5ldyBiKFwiYzpcIithLmlkK1wiOlwiK2EuZmYrKyxhLkYsdm9pZCAwLGEuQmIpO2EuUmU9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO3ZhciBjPUFoKGEsYS5KKSxkPUJoKGEsYS5KKTthLmhkPWEuSjthLmNkPWEuSjthLkQ9bnVsbDthLkFiPSExO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkomJmEuSi5vcGVuKGMsZCl9LE1hdGguZmxvb3IoMCkpO2I9Yi5oZWFsdGh5VGltZW91dHx8MDswPGImJihhLnlkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLnlkPW51bGw7YS5BYnx8KGEuSiYmMTAyNDAwPGEuSi5uYj8oYS5mKFwiQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCBcIithLkoubmIrXCIgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS5cIiksYS5BYj0hMCxhLkouRWQoKSk6YS5KJiYxMDI0MDxhLkoub2I/YS5mKFwiQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyBzZW50IFwiK1xuYS5KLm9iK1wiIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLlwiKTooYS5mKFwiQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LlwiKSxhLmNsb3NlKCkpKX0sTWF0aC5mbG9vcihiKSkpfWZ1bmN0aW9uIEJoKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2I9PT1hLko/KGEuSj1udWxsLGN8fDAhPT1hLlRhPzE9PT1hLlRhJiZhLmYoXCJSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuXCIpOihhLmYoXCJSZWFsdGltZSBjb25uZWN0aW9uIGZhaWxlZC5cIiksXCJzLVwiPT09YS5GLllhLnN1YnN0cigwLDIpJiYoeGMucmVtb3ZlKFwiaG9zdDpcIithLkYuaG9zdCksYS5GLllhPWEuRi5ob3N0KSksYS5jbG9zZSgpKTpiPT09YS5EPyhhLmYoXCJTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LlwiKSxjPWEuRCxhLkQ9bnVsbCxhLmhkIT09YyYmYS5jZCE9PWN8fGEuY2xvc2UoKSk6YS5mKFwiY2xvc2luZyBhbiBvbGQgY29ubmVjdGlvblwiKX19XG5mdW5jdGlvbiBBaChhLGIpe3JldHVybiBmdW5jdGlvbihjKXtpZigyIT1hLlRhKWlmKGI9PT1hLmNkKXt2YXIgZD1UYyhcInRcIixjKTtjPVRjKFwiZFwiLGMpO2lmKFwiY1wiPT1kKXtpZihkPVRjKFwidFwiLGMpLFwiZFwiaW4gYylpZihjPWMuZCxcImhcIj09PWQpe3ZhciBkPWMudHMsZT1jLnYsZj1jLmg7YS5OZj1jLnM7QWMoYS5GLGYpOzA9PWEuVGEmJihhLkouc3RhcnQoKSxDaChhLGEuSixkKSxcIjVcIiE9PWUmJk8oXCJQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkXCIpLGM9YS5QZiwoYz0xPGMuZ2QubGVuZ3RoP2MuZ2RbMV06bnVsbCkmJkRoKGEsYykpfWVsc2UgaWYoXCJuXCI9PT1kKXthLmYoXCJyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnlcIik7YS5jZD1hLkQ7Zm9yKGM9MDtjPGEuTWQubGVuZ3RoOysrYylhLklkKGEuTWRbY10pO2EuTWQ9W107RWgoYSl9ZWxzZVwic1wiPT09ZD8oYS5mKFwiQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uXCIpLFxuYS5OZSYmKGEuTmUoYyksYS5OZT1udWxsKSxhLmxhPW51bGwsYS5jbG9zZSgpKTpcInJcIj09PWQ/KGEuZihcIlJlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiBcIitjKSxBYyhhLkYsYyksMT09PWEuVGE/YS5jbG9zZSgpOihGaChhKSx6aChhKSkpOlwiZVwiPT09ZD9OYyhcIlNlcnZlciBFcnJvcjogXCIrYyk6XCJvXCI9PT1kPyhhLmYoXCJnb3QgcG9uZyBvbiBwcmltYXJ5LlwiKSxHaChhKSxIaChhKSk6TmMoXCJVbmtub3duIGNvbnRyb2wgcGFja2V0IGNvbW1hbmQ6IFwiK2QpfWVsc2VcImRcIj09ZCYmYS5JZChjKX1lbHNlIGlmKGI9PT1hLkQpaWYoZD1UYyhcInRcIixjKSxjPVRjKFwiZFwiLGMpLFwiY1wiPT1kKVwidFwiaW4gYyYmKGM9Yy50LFwiYVwiPT09Yz9JaChhKTpcInJcIj09PWM/KGEuZihcIkdvdCBhIHJlc2V0IG9uIHNlY29uZGFyeSwgY2xvc2luZyBpdFwiKSxhLkQuY2xvc2UoKSxhLmhkIT09YS5EJiZhLmNkIT09YS5EfHxhLmNsb3NlKCkpOlwib1wiPT09YyYmKGEuZihcImdvdCBwb25nIG9uIHNlY29uZGFyeS5cIiksXG5hLk1mLS0sSWgoYSkpKTtlbHNlIGlmKFwiZFwiPT1kKWEuTWQucHVzaChjKTtlbHNlIHRocm93IEVycm9yKFwiVW5rbm93biBwcm90b2NvbCBsYXllcjogXCIrZCk7ZWxzZSBhLmYoXCJtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uXCIpfX15aC5wcm90b3R5cGUuRmE9ZnVuY3Rpb24oYSl7SmgodGhpcyx7dDpcImRcIixkOmF9KX07ZnVuY3Rpb24gRWgoYSl7YS5oZD09PWEuRCYmYS5jZD09PWEuRCYmKGEuZihcImNsZWFuaW5nIHVwIGFuZCBwcm9tb3RpbmcgYSBjb25uZWN0aW9uOiBcIithLkQucmUpLGEuSj1hLkQsYS5EPW51bGwpfVxuZnVuY3Rpb24gSWgoYSl7MD49YS5NZj8oYS5mKFwiU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5BYj0hMCxhLkQuRWQoKSxhLkQuc3RhcnQoKSxhLmYoXCJzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5XCIpLGEuRC5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJhXCIsZDp7fX19KSxhLmYoXCJFbmRpbmcgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnlcIiksYS5KLnNlbmQoe3Q6XCJjXCIsZDp7dDpcIm5cIixkOnt9fX0pLGEuaGQ9YS5ELEVoKGEpKTooYS5mKFwic2VuZGluZyBwaW5nIG9uIHNlY29uZGFyeS5cIiksYS5ELnNlbmQoe3Q6XCJjXCIsZDp7dDpcInBcIixkOnt9fX0pKX15aC5wcm90b3R5cGUuSWQ9ZnVuY3Rpb24oYSl7R2godGhpcyk7dGhpcy5qYyhhKX07ZnVuY3Rpb24gR2goYSl7YS5BYnx8KGEuUmUtLSwwPj1hLlJlJiYoYS5mKFwiUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEuQWI9ITAsYS5KLkVkKCkpKX1cbmZ1bmN0aW9uIERoKGEsYil7YS5EPW5ldyBiKFwiYzpcIithLmlkK1wiOlwiK2EuZmYrKyxhLkYsYS5OZik7YS5NZj1iLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHl8fDA7YS5ELm9wZW4oQWgoYSxhLkQpLEJoKGEsYS5EKSk7c2V0VGltZW91dChmdW5jdGlvbigpe2EuRCYmKGEuZihcIlRpbWVkIG91dCB0cnlpbmcgdG8gdXBncmFkZS5cIiksYS5ELmNsb3NlKCkpfSxNYXRoLmZsb29yKDZFNCkpfWZ1bmN0aW9uIENoKGEsYixjKXthLmYoXCJSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLlwiKTthLko9YjthLlRhPTE7YS5XYyYmKGEuV2MoYyxhLk5mKSxhLldjPW51bGwpOzA9PT1hLlJlPyhhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5BYj0hMCk6c2V0VGltZW91dChmdW5jdGlvbigpe0hoKGEpfSxNYXRoLmZsb29yKDVFMykpfVxuZnVuY3Rpb24gSGgoYSl7YS5BYnx8MSE9PWEuVGF8fChhLmYoXCJzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS5cIiksSmgoYSx7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfWZ1bmN0aW9uIEpoKGEsYil7aWYoMSE9PWEuVGEpdGhyb3dcIkNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZFwiO2EuaGQuc2VuZChiKX15aC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXsyIT09dGhpcy5UYSYmKHRoaXMuZihcIkNsb3NpbmcgcmVhbHRpbWUgY29ubmVjdGlvbi5cIiksdGhpcy5UYT0yLEZoKHRoaXMpLHRoaXMubGEmJih0aGlzLmxhKCksdGhpcy5sYT1udWxsKSl9O2Z1bmN0aW9uIEZoKGEpe2EuZihcIlNodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zXCIpO2EuSiYmKGEuSi5jbG9zZSgpLGEuSj1udWxsKTthLkQmJihhLkQuY2xvc2UoKSxhLkQ9bnVsbCk7YS55ZCYmKGNsZWFyVGltZW91dChhLnlkKSxhLnlkPW51bGwpfTtmdW5jdGlvbiBLaChhLGIsYyxkKXt0aGlzLmlkPUxoKys7dGhpcy5mPU1jKFwicDpcIit0aGlzLmlkK1wiOlwiKTt0aGlzLnhmPXRoaXMuRWU9ITE7dGhpcy4kPXt9O3RoaXMucWE9W107dGhpcy5ZYz0wO3RoaXMuVmM9W107dGhpcy5vYT0hMTt0aGlzLlphPTFFMzt0aGlzLkZkPTNFNTt0aGlzLkdiPWI7dGhpcy5VYz1jO3RoaXMuT2U9ZDt0aGlzLkY9YTt0aGlzLnNiPXRoaXMuQWE9dGhpcy5JYT10aGlzLkJiPXRoaXMuV2U9bnVsbDt0aGlzLk9iPSExO3RoaXMuVGQ9e307dGhpcy5MZz0wO3RoaXMubmY9ITA7dGhpcy5MYz10aGlzLkdlPW51bGw7TWgodGhpcywwKTtIZS51YigpLkViKFwidmlzaWJsZVwiLHRoaXMuQ2csdGhpcyk7LTE9PT1hLmhvc3QuaW5kZXhPZihcImZibG9jYWxcIikmJkdlLnViKCkuRWIoXCJvbmxpbmVcIix0aGlzLkFnLHRoaXMpfXZhciBMaD0wLE5oPTA7Zz1LaC5wcm90b3R5cGU7XG5nLkZhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0rK3RoaXMuTGc7YT17cjpkLGE6YSxiOmJ9O3RoaXMuZihCKGEpKTtLKHRoaXMub2EsXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7dGhpcy5JYS5GYShhKTtjJiYodGhpcy5UZFtkXT1jKX07Zy55Zj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hLnZhKCksZj1hLnBhdGgudG9TdHJpbmcoKTt0aGlzLmYoXCJMaXN0ZW4gY2FsbGVkIGZvciBcIitmK1wiIFwiK2UpO3RoaXMuJFtmXT10aGlzLiRbZl18fHt9O0soZmUoYS5uKXx8IVMoYS5uKSxcImxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5XCIpO0soIXRoaXMuJFtmXVtlXSxcImxpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuXCIpO2E9e0g6ZCx4ZDpiLElnOmEsdGFnOmN9O3RoaXMuJFtmXVtlXT1hO3RoaXMub2EmJk9oKHRoaXMsYSl9O1xuZnVuY3Rpb24gT2goYSxiKXt2YXIgYz1iLklnLGQ9Yy5wYXRoLnRvU3RyaW5nKCksZT1jLnZhKCk7YS5mKFwiTGlzdGVuIG9uIFwiK2QrXCIgZm9yIFwiK2UpO3ZhciBmPXtwOmR9O2IudGFnJiYoZi5xPWVlKGMubiksZi50PWIudGFnKTtmLmg9Yi54ZCgpO2EuRmEoXCJxXCIsZixmdW5jdGlvbihmKXt2YXIgaz1mLmQsbD1mLnM7aWYoayYmXCJvYmplY3RcIj09PXR5cGVvZiBrJiZ2KGssXCJ3XCIpKXt2YXIgbT13KGssXCJ3XCIpO2VhKG0pJiYwPD1OYShtLFwibm9faW5kZXhcIikmJk8oXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gQ29uc2lkZXIgYWRkaW5nIFwiKygnXCIuaW5kZXhPblwiOiBcIicrYy5uLmcudG9TdHJpbmcoKSsnXCInKStcIiBhdCBcIitjLnBhdGgudG9TdHJpbmcoKStcIiB0byB5b3VyIHNlY3VyaXR5IHJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcIil9KGEuJFtkXSYmYS4kW2RdW2VdKT09PWImJihhLmYoXCJsaXN0ZW4gcmVzcG9uc2VcIixmKSxcIm9rXCIhPT1sJiZQaChhLGQsZSksYi5IJiZiLkgobCxcbmspKX0pfWcuTT1mdW5jdGlvbihhLGIsYyl7dGhpcy5BYT17aWc6YSxvZjohMSx6YzpiLG1kOmN9O3RoaXMuZihcIkF1dGhlbnRpY2F0aW5nIHVzaW5nIGNyZWRlbnRpYWw6IFwiK2EpO1FoKHRoaXMpOyhiPTQwPT1hLmxlbmd0aCl8fChhPSRjKGEpLkJjLGI9XCJvYmplY3RcIj09PXR5cGVvZiBhJiYhMD09PXcoYSxcImFkbWluXCIpKTtiJiYodGhpcy5mKFwiQWRtaW4gYXV0aCBjcmVkZW50aWFsIGRldGVjdGVkLiAgUmVkdWNpbmcgbWF4IHJlY29ubmVjdCB0aW1lLlwiKSx0aGlzLkZkPTNFNCl9O2cuZ2U9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuQWE7dGhpcy5vYSYmdGhpcy5GYShcInVuYXV0aFwiLHt9LGZ1bmN0aW9uKGIpe2EoYi5zLGIuZCl9KX07XG5mdW5jdGlvbiBRaChhKXt2YXIgYj1hLkFhO2Eub2EmJmImJmEuRmEoXCJhdXRoXCIse2NyZWQ6Yi5pZ30sZnVuY3Rpb24oYyl7dmFyIGQ9Yy5zO2M9Yy5kfHxcImVycm9yXCI7XCJva1wiIT09ZCYmYS5BYT09PWImJmRlbGV0ZSBhLkFhO2Iub2Y/XCJva1wiIT09ZCYmYi5tZCYmYi5tZChkLGMpOihiLm9mPSEwLGIuemMmJmIuemMoZCxjKSl9KX1nLlJmPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLnRvU3RyaW5nKCksZD1hLnZhKCk7dGhpcy5mKFwiVW5saXN0ZW4gY2FsbGVkIGZvciBcIitjK1wiIFwiK2QpO0soZmUoYS5uKXx8IVMoYS5uKSxcInVubGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnlcIik7aWYoUGgodGhpcyxjLGQpJiZ0aGlzLm9hKXt2YXIgZT1lZShhLm4pO3RoaXMuZihcIlVubGlzdGVuIG9uIFwiK2MrXCIgZm9yIFwiK2QpO2M9e3A6Y307YiYmKGMucT1lLGMudD1iKTt0aGlzLkZhKFwiblwiLGMpfX07XG5nLk1lPWZ1bmN0aW9uKGEsYixjKXt0aGlzLm9hP1JoKHRoaXMsXCJvXCIsYSxiLGMpOnRoaXMuVmMucHVzaCh7JGM6YSxhY3Rpb246XCJvXCIsZGF0YTpiLEg6Y30pfTtnLkNmPWZ1bmN0aW9uKGEsYixjKXt0aGlzLm9hP1JoKHRoaXMsXCJvbVwiLGEsYixjKTp0aGlzLlZjLnB1c2goeyRjOmEsYWN0aW9uOlwib21cIixkYXRhOmIsSDpjfSl9O2cuSmQ9ZnVuY3Rpb24oYSxiKXt0aGlzLm9hP1JoKHRoaXMsXCJvY1wiLGEsbnVsbCxiKTp0aGlzLlZjLnB1c2goeyRjOmEsYWN0aW9uOlwib2NcIixkYXRhOm51bGwsSDpifSl9O2Z1bmN0aW9uIFJoKGEsYixjLGQsZSl7Yz17cDpjLGQ6ZH07YS5mKFwib25EaXNjb25uZWN0IFwiK2IsYyk7YS5GYShiLGMsZnVuY3Rpb24oYSl7ZSYmc2V0VGltZW91dChmdW5jdGlvbigpe2UoYS5zLGEuZCl9LE1hdGguZmxvb3IoMCkpfSl9Zy5wdXQ9ZnVuY3Rpb24oYSxiLGMsZCl7U2godGhpcyxcInBcIixhLGIsYyxkKX07XG5nLnpmPWZ1bmN0aW9uKGEsYixjLGQpe1NoKHRoaXMsXCJtXCIsYSxiLGMsZCl9O2Z1bmN0aW9uIFNoKGEsYixjLGQsZSxmKXtkPXtwOmMsZDpkfTtuKGYpJiYoZC5oPWYpO2EucWEucHVzaCh7YWN0aW9uOmIsSmY6ZCxIOmV9KTthLlljKys7Yj1hLnFhLmxlbmd0aC0xO2Eub2E/VGgoYSxiKTphLmYoXCJCdWZmZXJpbmcgcHV0OiBcIitjKX1mdW5jdGlvbiBUaChhLGIpe3ZhciBjPWEucWFbYl0uYWN0aW9uLGQ9YS5xYVtiXS5KZixlPWEucWFbYl0uSDthLnFhW2JdLkpnPWEub2E7YS5GYShjLGQsZnVuY3Rpb24oZCl7YS5mKGMrXCIgcmVzcG9uc2VcIixkKTtkZWxldGUgYS5xYVtiXTthLlljLS07MD09PWEuWWMmJihhLnFhPVtdKTtlJiZlKGQucyxkLmQpfSl9XG5nLlVlPWZ1bmN0aW9uKGEpe3RoaXMub2EmJihhPXtjOmF9LHRoaXMuZihcInJlcG9ydFN0YXRzXCIsYSksdGhpcy5GYShcInNcIixhLGZ1bmN0aW9uKGEpe1wib2tcIiE9PWEucyYmdGhpcy5mKFwicmVwb3J0U3RhdHNcIixcIkVycm9yIHNlbmRpbmcgc3RhdHM6IFwiK2EuZCl9KSl9O1xuZy5JZD1mdW5jdGlvbihhKXtpZihcInJcImluIGEpe3RoaXMuZihcImZyb20gc2VydmVyOiBcIitCKGEpKTt2YXIgYj1hLnIsYz10aGlzLlRkW2JdO2MmJihkZWxldGUgdGhpcy5UZFtiXSxjKGEuYikpfWVsc2V7aWYoXCJlcnJvclwiaW4gYSl0aHJvd1wiQSBzZXJ2ZXItc2lkZSBlcnJvciBoYXMgb2NjdXJyZWQ6IFwiK2EuZXJyb3I7XCJhXCJpbiBhJiYoYj1hLmEsYz1hLmIsdGhpcy5mKFwiaGFuZGxlU2VydmVyTWVzc2FnZVwiLGIsYyksXCJkXCI9PT1iP3RoaXMuR2IoYy5wLGMuZCwhMSxjLnQpOlwibVwiPT09Yj90aGlzLkdiKGMucCxjLmQsITAsYy50KTpcImNcIj09PWI/VWgodGhpcyxjLnAsYy5xKTpcImFjXCI9PT1iPyhhPWMucyxiPWMuZCxjPXRoaXMuQWEsZGVsZXRlIHRoaXMuQWEsYyYmYy5tZCYmYy5tZChhLGIpKTpcInNkXCI9PT1iP3RoaXMuV2U/dGhpcy5XZShjKTpcIm1zZ1wiaW4gYyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiZjb25zb2xlLmxvZyhcIkZJUkVCQVNFOiBcIitjLm1zZy5yZXBsYWNlKFwiXFxuXCIsXG5cIlxcbkZJUkVCQVNFOiBcIikpOk5jKFwiVW5yZWNvZ25pemVkIGFjdGlvbiByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIrQihiKStcIlxcbkFyZSB5b3UgdXNpbmcgdGhlIGxhdGVzdCBjbGllbnQ/XCIpKX19O2cuV2M9ZnVuY3Rpb24oYSxiKXt0aGlzLmYoXCJjb25uZWN0aW9uIHJlYWR5XCIpO3RoaXMub2E9ITA7dGhpcy5MYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLk9lKHtzZXJ2ZXJUaW1lT2Zmc2V0OmEtKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTt0aGlzLkJiPWI7aWYodGhpcy5uZil7dmFyIGM9e307Y1tcInNkay5qcy5cIitoYi5yZXBsYWNlKC9cXC4vZyxcIi1cIildPTE7eWcoKSYmKGNbXCJmcmFtZXdvcmsuY29yZG92YVwiXT0xKTt0aGlzLlVlKGMpfVZoKHRoaXMpO3RoaXMubmY9ITE7dGhpcy5VYyghMCl9O1xuZnVuY3Rpb24gTWgoYSxiKXtLKCFhLklhLFwiU2NoZWR1bGluZyBhIGNvbm5lY3Qgd2hlbiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZC9pbmc/XCIpO2Euc2ImJmNsZWFyVGltZW91dChhLnNiKTthLnNiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLnNiPW51bGw7V2goYSl9LE1hdGguZmxvb3IoYikpfWcuQ2c9ZnVuY3Rpb24oYSl7YSYmIXRoaXMuT2ImJnRoaXMuWmE9PT10aGlzLkZkJiYodGhpcy5mKFwiV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuXCIpLHRoaXMuWmE9MUUzLHRoaXMuSWF8fE1oKHRoaXMsMCkpO3RoaXMuT2I9YX07Zy5BZz1mdW5jdGlvbihhKXthPyh0aGlzLmYoXCJCcm93c2VyIHdlbnQgb25saW5lLlwiKSx0aGlzLlphPTFFMyx0aGlzLklhfHxNaCh0aGlzLDApKToodGhpcy5mKFwiQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uXCIpLHRoaXMuSWEmJnRoaXMuSWEuY2xvc2UoKSl9O1xuZy5EZj1mdW5jdGlvbigpe3RoaXMuZihcImRhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZFwiKTt0aGlzLm9hPSExO3RoaXMuSWE9bnVsbDtmb3IodmFyIGE9MDthPHRoaXMucWEubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5xYVthXTtiJiZcImhcImluIGIuSmYmJmIuSmcmJihiLkgmJmIuSChcImRpc2Nvbm5lY3RcIiksZGVsZXRlIHRoaXMucWFbYV0sdGhpcy5ZYy0tKX0wPT09dGhpcy5ZYyYmKHRoaXMucWE9W10pO3RoaXMuVGQ9e307WGgodGhpcykmJih0aGlzLk9iP3RoaXMuTGMmJigzRTQ8KG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5MYyYmKHRoaXMuWmE9MUUzKSx0aGlzLkxjPW51bGwpOih0aGlzLmYoXCJXaW5kb3cgaXNuJ3QgdmlzaWJsZS4gIERlbGF5aW5nIHJlY29ubmVjdC5cIiksdGhpcy5aYT10aGlzLkZkLHRoaXMuR2U9KG5ldyBEYXRlKS5nZXRUaW1lKCkpLGE9TWF0aC5tYXgoMCx0aGlzLlphLSgobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLkdlKSksYSo9TWF0aC5yYW5kb20oKSx0aGlzLmYoXCJUcnlpbmcgdG8gcmVjb25uZWN0IGluIFwiK1xuYStcIm1zXCIpLE1oKHRoaXMsYSksdGhpcy5aYT1NYXRoLm1pbih0aGlzLkZkLDEuMyp0aGlzLlphKSk7dGhpcy5VYyghMSl9O2Z1bmN0aW9uIFdoKGEpe2lmKFhoKGEpKXthLmYoXCJNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHRcIik7YS5HZT0obmV3IERhdGUpLmdldFRpbWUoKTthLkxjPW51bGw7dmFyIGI9cShhLklkLGEpLGM9cShhLldjLGEpLGQ9cShhLkRmLGEpLGU9YS5pZCtcIjpcIitOaCsrO2EuSWE9bmV3IHloKGUsYS5GLGIsYyxkLGZ1bmN0aW9uKGIpe08oYitcIiAoXCIrYS5GLnRvU3RyaW5nKCkrXCIpXCIpO2EueGY9ITB9LGEuQmIpfX1nLnliPWZ1bmN0aW9uKCl7dGhpcy5FZT0hMDt0aGlzLklhP3RoaXMuSWEuY2xvc2UoKToodGhpcy5zYiYmKGNsZWFyVGltZW91dCh0aGlzLnNiKSx0aGlzLnNiPW51bGwpLHRoaXMub2EmJnRoaXMuRGYoKSl9O2cucmM9ZnVuY3Rpb24oKXt0aGlzLkVlPSExO3RoaXMuWmE9MUUzO3RoaXMuSWF8fE1oKHRoaXMsMCl9O1xuZnVuY3Rpb24gVWgoYSxiLGMpe2M9Yz9RYShjLGZ1bmN0aW9uKGEpe3JldHVybiBVYyhhKX0pLmpvaW4oXCIkXCIpOlwiZGVmYXVsdFwiOyhhPVBoKGEsYixjKSkmJmEuSCYmYS5IKFwicGVybWlzc2lvbl9kZW5pZWRcIil9ZnVuY3Rpb24gUGgoYSxiLGMpe2I9KG5ldyBMKGIpKS50b1N0cmluZygpO3ZhciBkO24oYS4kW2JdKT8oZD1hLiRbYl1bY10sZGVsZXRlIGEuJFtiXVtjXSwwPT09cGEoYS4kW2JdKSYmZGVsZXRlIGEuJFtiXSk6ZD12b2lkIDA7cmV0dXJuIGR9ZnVuY3Rpb24gVmgoYSl7UWgoYSk7cihhLiQsZnVuY3Rpb24oYil7cihiLGZ1bmN0aW9uKGIpe09oKGEsYil9KX0pO2Zvcih2YXIgYj0wO2I8YS5xYS5sZW5ndGg7YisrKWEucWFbYl0mJlRoKGEsYik7Zm9yKDthLlZjLmxlbmd0aDspYj1hLlZjLnNoaWZ0KCksUmgoYSxiLmFjdGlvbixiLiRjLGIuZGF0YSxiLkgpfWZ1bmN0aW9uIFhoKGEpe3ZhciBiO2I9R2UudWIoKS5rYztyZXR1cm4hYS54ZiYmIWEuRWUmJmJ9O3ZhciBWPXtvZzpmdW5jdGlvbigpe2loPXJoPSEwfX07Vi5mb3JjZUxvbmdQb2xsaW5nPVYub2c7Vi5wZz1mdW5jdGlvbigpe2poPSEwfTtWLmZvcmNlV2ViU29ja2V0cz1WLnBnO1YuUGc9ZnVuY3Rpb24oYSxiKXthLmsuUmEuV2U9Yn07Vi5zZXRTZWN1cml0eURlYnVnQ2FsbGJhY2s9Vi5QZztWLlllPWZ1bmN0aW9uKGEsYil7YS5rLlllKGIpfTtWLnN0YXRzPVYuWWU7Vi5aZT1mdW5jdGlvbihhLGIpe2Euay5aZShiKX07Vi5zdGF0c0luY3JlbWVudENvdW50ZXI9Vi5aZTtWLnNkPWZ1bmN0aW9uKGEpe3JldHVybiBhLmsuc2R9O1YuZGF0YVVwZGF0ZUNvdW50PVYuc2Q7Vi5zZz1mdW5jdGlvbihhLGIpe2Euay5EZT1ifTtWLmludGVyY2VwdFNlcnZlckRhdGE9Vi5zZztWLnlnPWZ1bmN0aW9uKGEpe25ldyBJZyhhKX07Vi5vblBvcHVwT3Blbj1WLnlnO1YuTmc9ZnVuY3Rpb24oYSl7c2c9YX07Vi5zZXRBdXRoZW50aWNhdGlvblNlcnZlcj1WLk5nO2Z1bmN0aW9uIFEoYSxiLGMpe3RoaXMuQT1hO3RoaXMuVz1iO3RoaXMuZz1jfVEucHJvdG90eXBlLkk9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LnZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoKX07US5wcm90b3R5cGUudmFsPVEucHJvdG90eXBlLkk7US5wcm90b3R5cGUubWY9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4cG9ydFZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoITApfTtRLnByb3RvdHlwZS5leHBvcnRWYWw9US5wcm90b3R5cGUubWY7US5wcm90b3R5cGUubmc9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4aXN0c1wiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4hdGhpcy5BLmUoKX07US5wcm90b3R5cGUuZXhpc3RzPVEucHJvdG90eXBlLm5nO1xuUS5wcm90b3R5cGUudT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO2dhKGEpJiYoYT1TdHJpbmcoYSkpO2lnKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsYSk7dmFyIGI9bmV3IEwoYSksYz10aGlzLlcudShiKTtyZXR1cm4gbmV3IFEodGhpcy5BLlEoYiksYyxOKX07US5wcm90b3R5cGUuY2hpbGQ9US5wcm90b3R5cGUudTtRLnByb3RvdHlwZS5EYT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lnKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsYSk7dmFyIGI9bmV3IEwoYSk7cmV0dXJuIXRoaXMuQS5RKGIpLmUoKX07US5wcm90b3R5cGUuaGFzQ2hpbGQ9US5wcm90b3R5cGUuRGE7XG5RLnByb3RvdHlwZS5DPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5nZXRQcmlvcml0eVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkMoKS5JKCl9O1EucHJvdG90eXBlLmdldFByaW9yaXR5PVEucHJvdG90eXBlLkM7US5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmZvckVhY2hcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7QShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5mb3JFYWNoXCIsMSxhLCExKTtpZih0aGlzLkEuSygpKXJldHVybiExO3ZhciBiPXRoaXM7cmV0dXJuISF0aGlzLkEuUCh0aGlzLmcsZnVuY3Rpb24oYyxkKXtyZXR1cm4gYShuZXcgUShkLGIuVy51KGMpLE4pKX0pfTtRLnByb3RvdHlwZS5mb3JFYWNoPVEucHJvdG90eXBlLmZvckVhY2g7XG5RLnByb3RvdHlwZS53ZD1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuaGFzQ2hpbGRyZW5cIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5LKCk/ITE6IXRoaXMuQS5lKCl9O1EucHJvdG90eXBlLmhhc0NoaWxkcmVuPVEucHJvdG90eXBlLndkO1EucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXtPKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lm5hbWUoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlLkRhdGFTbmFwc2hvdC5rZXkoKSBpbnN0ZWFkLlwiKTt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lm5hbWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMua2V5KCl9O1EucHJvdG90eXBlLm5hbWU9US5wcm90b3R5cGUubmFtZTtRLnByb3RvdHlwZS5rZXk9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmtleVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5XLmtleSgpfTtcblEucHJvdG90eXBlLmtleT1RLnByb3RvdHlwZS5rZXk7US5wcm90b3R5cGUuRGI9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lm51bUNoaWxkcmVuXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuRGIoKX07US5wcm90b3R5cGUubnVtQ2hpbGRyZW49US5wcm90b3R5cGUuRGI7US5wcm90b3R5cGUuSWI9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5XfTtRLnByb3RvdHlwZS5yZWY9US5wcm90b3R5cGUuSWI7ZnVuY3Rpb24gWWgoYSxiKXt0aGlzLkY9YTt0aGlzLlVhPVJiKGEpO3RoaXMuZmQ9bnVsbDt0aGlzLmRhPW5ldyB2Yjt0aGlzLkhkPTE7dGhpcy5SYT1udWxsO2J8fDA8PShcIm9iamVjdFwiPT09dHlwZW9mIHdpbmRvdyYmd2luZG93Lm5hdmlnYXRvciYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIpLnNlYXJjaCgvZ29vZ2xlYm90fGdvb2dsZSB3ZWJtYXN0ZXIgdG9vbHN8YmluZ2JvdHx5YWhvbyEgc2x1cnB8YmFpZHVzcGlkZXJ8eWFuZGV4Ym90fGR1Y2tkdWNrYm90L2kpPyh0aGlzLmJhPW5ldyBBZSh0aGlzLkYscSh0aGlzLkdiLHRoaXMpKSxzZXRUaW1lb3V0KHEodGhpcy5VYyx0aGlzLCEwKSwwKSk6dGhpcy5iYT10aGlzLlJhPW5ldyBLaCh0aGlzLkYscSh0aGlzLkdiLHRoaXMpLHEodGhpcy5VYyx0aGlzKSxxKHRoaXMuT2UsdGhpcykpO3RoaXMuU2c9U2IoYSxxKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBNYih0aGlzLlVhLHRoaXMuYmEpfSx0aGlzKSk7dGhpcy51Yz1uZXcgUmY7XG50aGlzLkNlPW5ldyBvYjt2YXIgYz10aGlzO3RoaXMuQ2Q9bmV3IHZmKHtYZTpmdW5jdGlvbihhLGIsZixoKXtiPVtdO2Y9Yy5DZS5qKGEucGF0aCk7Zi5lKCl8fChiPXhmKGMuQ2QsbmV3IFhiKGJmLGEucGF0aCxmKSksc2V0VGltZW91dChmdW5jdGlvbigpe2goXCJva1wiKX0sMCkpO3JldHVybiBifSxhZTpiYX0pO1poKHRoaXMsXCJjb25uZWN0ZWRcIiwhMSk7dGhpcy5sYT1uZXcgcWM7dGhpcy5NPW5ldyBTZyhhLHEodGhpcy5iYS5NLHRoaXMuYmEpLHEodGhpcy5iYS5nZSx0aGlzLmJhKSxxKHRoaXMuTGUsdGhpcykpO3RoaXMuc2Q9MDt0aGlzLkRlPW51bGw7dGhpcy5MPW5ldyB2Zih7WGU6ZnVuY3Rpb24oYSxiLGYsaCl7Yy5iYS55ZihhLGYsYixmdW5jdGlvbihiLGUpe3ZhciBmPWgoYixlKTtBYihjLmRhLGEucGF0aCxmKX0pO3JldHVybltdfSxhZTpmdW5jdGlvbihhLGIpe2MuYmEuUmYoYSxiKX19KX1nPVloLnByb3RvdHlwZTtcbmcudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5GLmtiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5GLmhvc3R9O2cubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkYuaGN9O2Z1bmN0aW9uICRoKGEpe2E9YS5DZS5qKG5ldyBMKFwiLmluZm8vc2VydmVyVGltZU9mZnNldFwiKSkuSSgpfHwwO3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpK2F9ZnVuY3Rpb24gYWkoYSl7YT1hPXt0aW1lc3RhbXA6JGgoYSl9O2EudGltZXN0YW1wPWEudGltZXN0YW1wfHwobmV3IERhdGUpLmdldFRpbWUoKTtyZXR1cm4gYX1cbmcuR2I9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5zZCsrO3ZhciBlPW5ldyBMKGEpO2I9dGhpcy5EZT90aGlzLkRlKGEsYik6YjthPVtdO2Q/Yz8oYj1uYShiLGZ1bmN0aW9uKGEpe3JldHVybiBNKGEpfSksYT1GZih0aGlzLkwsZSxiLGQpKTooYj1NKGIpLGE9QmYodGhpcy5MLGUsYixkKSk6Yz8oZD1uYShiLGZ1bmN0aW9uKGEpe3JldHVybiBNKGEpfSksYT1BZih0aGlzLkwsZSxkKSk6KGQ9TShiKSxhPXhmKHRoaXMuTCxuZXcgWGIoYmYsZSxkKSkpO2Q9ZTswPGEubGVuZ3RoJiYoZD1iaSh0aGlzLGUpKTtBYih0aGlzLmRhLGQsYSl9O2cuVWM9ZnVuY3Rpb24oYSl7WmgodGhpcyxcImNvbm5lY3RlZFwiLGEpOyExPT09YSYmY2kodGhpcyl9O2cuT2U9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztXYyhhLGZ1bmN0aW9uKGEsZCl7WmgoYixkLGEpfSl9O2cuTGU9ZnVuY3Rpb24oYSl7WmgodGhpcyxcImF1dGhlbnRpY2F0ZWRcIixhKX07XG5mdW5jdGlvbiBaaChhLGIsYyl7Yj1uZXcgTChcIi8uaW5mby9cIitiKTtjPU0oYyk7dmFyIGQ9YS5DZTtkLldkPWQuV2QuRyhiLGMpO2M9eGYoYS5DZCxuZXcgWGIoYmYsYixjKSk7QWIoYS5kYSxiLGMpfWcuS2I9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5mKFwic2V0XCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmIsJGc6Y30pO3ZhciBlPWFpKHRoaXMpO2I9TShiLGMpO3ZhciBlPXNjKGIsZSksZj10aGlzLkhkKyssZT13Zih0aGlzLkwsYSxlLGYsITApO3diKHRoaXMuZGEsZSk7dmFyIGg9dGhpczt0aGlzLmJhLnB1dChhLnRvU3RyaW5nKCksYi5JKCEwKSxmdW5jdGlvbihiLGMpe3ZhciBlPVwib2tcIj09PWI7ZXx8TyhcInNldCBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7ZT16ZihoLkwsZiwhZSk7QWIoaC5kYSxhLGUpO2RpKGQsYixjKX0pO2U9ZWkodGhpcyxhKTtiaSh0aGlzLGUpO0FiKHRoaXMuZGEsZSxbXSl9O1xuZy51cGRhdGU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuZihcInVwZGF0ZVwiLHtwYXRoOmEudG9TdHJpbmcoKSx2YWx1ZTpifSk7dmFyIGQ9ITAsZT1haSh0aGlzKSxmPXt9O3IoYixmdW5jdGlvbihhLGIpe2Q9ITE7dmFyIGM9TShhKTtmW2JdPXNjKGMsZSl9KTtpZihkKUNiKFwidXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKSxkaShjLFwib2tcIik7ZWxzZXt2YXIgaD10aGlzLkhkKyssaz15Zih0aGlzLkwsYSxmLGgpO3diKHRoaXMuZGEsayk7dmFyIGw9dGhpczt0aGlzLmJhLnpmKGEudG9TdHJpbmcoKSxiLGZ1bmN0aW9uKGIsZCl7dmFyIGU9XCJva1wiPT09YjtlfHxPKFwidXBkYXRlIGF0IFwiK2ErXCIgZmFpbGVkOiBcIitiKTt2YXIgZT16ZihsLkwsaCwhZSksZj1hOzA8ZS5sZW5ndGgmJihmPWJpKGwsYSkpO0FiKGwuZGEsZixlKTtkaShjLGIsZCl9KTtiPWVpKHRoaXMsYSk7YmkodGhpcyxiKTtBYih0aGlzLmRhLGEsW10pfX07XG5mdW5jdGlvbiBjaShhKXthLmYoXCJvbkRpc2Nvbm5lY3RFdmVudHNcIik7dmFyIGI9YWkoYSksYz1bXTtyYyhwYyhhLmxhLGIpLEcsZnVuY3Rpb24oYixlKXtjPWMuY29uY2F0KHhmKGEuTCxuZXcgWGIoYmYsYixlKSkpO3ZhciBmPWVpKGEsYik7YmkoYSxmKX0pO2EubGE9bmV3IHFjO0FiKGEuZGEsRyxjKX1nLkpkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczt0aGlzLmJhLkpkKGEudG9TdHJpbmcoKSxmdW5jdGlvbihkLGUpe1wib2tcIj09PWQmJnJnKGMubGEsYSk7ZGkoYixkLGUpfSl9O2Z1bmN0aW9uIGZpKGEsYixjLGQpe3ZhciBlPU0oYyk7YS5iYS5NZShiLnRvU3RyaW5nKCksZS5JKCEwKSxmdW5jdGlvbihjLGgpe1wib2tcIj09PWMmJmEubGEubmMoYixlKTtkaShkLGMsaCl9KX1mdW5jdGlvbiBnaShhLGIsYyxkLGUpe3ZhciBmPU0oYyxkKTthLmJhLk1lKGIudG9TdHJpbmcoKSxmLkkoITApLGZ1bmN0aW9uKGMsZCl7XCJva1wiPT09YyYmYS5sYS5uYyhiLGYpO2RpKGUsYyxkKX0pfVxuZnVuY3Rpb24gaGkoYSxiLGMsZCl7dmFyIGU9ITAsZjtmb3IoZiBpbiBjKWU9ITE7ZT8oQ2IoXCJvbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLGRpKGQsXCJva1wiKSk6YS5iYS5DZihiLnRvU3RyaW5nKCksYyxmdW5jdGlvbihlLGYpe2lmKFwib2tcIj09PWUpZm9yKHZhciBsIGluIGMpe3ZhciBtPU0oY1tsXSk7YS5sYS5uYyhiLnUobCksbSl9ZGkoZCxlLGYpfSl9ZnVuY3Rpb24gaWkoYSxiLGMpe2M9XCIuaW5mb1wiPT09RShiLnBhdGgpP2EuQ2QuUGIoYixjKTphLkwuUGIoYixjKTt5YihhLmRhLGIucGF0aCxjKX1nLnliPWZ1bmN0aW9uKCl7dGhpcy5SYSYmdGhpcy5SYS55YigpfTtnLnJjPWZ1bmN0aW9uKCl7dGhpcy5SYSYmdGhpcy5SYS5yYygpfTtcbmcuWWU9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXthPyh0aGlzLmZkfHwodGhpcy5mZD1uZXcgTGIodGhpcy5VYSkpLGE9dGhpcy5mZC5nZXQoKSk6YT10aGlzLlVhLmdldCgpO3ZhciBiPVJhKHNhKGEpLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgubWF4KGIubGVuZ3RoLGEpfSwwKSxjO2ZvcihjIGluIGEpe2Zvcih2YXIgZD1hW2NdLGU9Yy5sZW5ndGg7ZTxiKzI7ZSsrKWMrPVwiIFwiO2NvbnNvbGUubG9nKGMrZCl9fX07Zy5aZT1mdW5jdGlvbihhKXtPYih0aGlzLlVhLGEpO3RoaXMuU2cuT2ZbYV09ITB9O2cuZj1mdW5jdGlvbihhKXt2YXIgYj1cIlwiO3RoaXMuUmEmJihiPXRoaXMuUmEuaWQrXCI6XCIpO0NiKGIsYXJndW1lbnRzKX07XG5mdW5jdGlvbiBkaShhLGIsYyl7YSYmRGIoZnVuY3Rpb24oKXtpZihcIm9rXCI9PWIpYShudWxsKTtlbHNle3ZhciBkPShifHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksZT1kO2MmJihlKz1cIjogXCIrYyk7ZT1FcnJvcihlKTtlLmNvZGU9ZDthKGUpfX0pfTtmdW5jdGlvbiBqaShhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoKXt9YS5mKFwidHJhbnNhY3Rpb24gb24gXCIrYik7dmFyIGg9bmV3IFUoYSxiKTtoLkViKFwidmFsdWVcIixmKTtjPXtwYXRoOmIsdXBkYXRlOmMsSDpkLHN0YXR1czpudWxsLEZmOkVjKCksY2Y6ZSxMZjowLGllOmZ1bmN0aW9uKCl7aC5pYyhcInZhbHVlXCIsZil9LGtlOm51bGwsQmE6bnVsbCxwZDpudWxsLHFkOm51bGwscmQ6bnVsbH07ZD1hLkwuemEoYix2b2lkIDApfHxDO2MucGQ9ZDtkPWMudXBkYXRlKGQuSSgpKTtpZihuKGQpKXtjZyhcInRyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCBcIixkLGMucGF0aCk7Yy5zdGF0dXM9MTtlPVNmKGEudWMsYik7dmFyIGs9ZS5DYSgpfHxbXTtrLnB1c2goYyk7VGYoZSxrKTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZ2KGQsXCIucHJpb3JpdHlcIik/KGs9dyhkLFwiLnByaW9yaXR5XCIpLEsoYWcoayksXCJJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiBQcmlvcml0eSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwuXCIpKTpcbms9KGEuTC56YShiKXx8QykuQygpLkkoKTtlPWFpKGEpO2Q9TShkLGspO2U9c2MoZCxlKTtjLnFkPWQ7Yy5yZD1lO2MuQmE9YS5IZCsrO2M9d2YoYS5MLGIsZSxjLkJhLGMuY2YpO0FiKGEuZGEsYixjKTtraShhKX1lbHNlIGMuaWUoKSxjLnFkPW51bGwsYy5yZD1udWxsLGMuSCYmKGE9bmV3IFEoYy5wZCxuZXcgVShhLGMucGF0aCksTiksYy5IKG51bGwsITEsYSkpfWZ1bmN0aW9uIGtpKGEsYil7dmFyIGM9Ynx8YS51YztifHxsaShhLGMpO2lmKG51bGwhPT1jLkNhKCkpe3ZhciBkPW1pKGEsYyk7SygwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtTYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmbmkoYSxjLnBhdGgoKSxkKX1lbHNlIGMud2QoKSYmYy5QKGZ1bmN0aW9uKGIpe2tpKGEsYil9KX1cbmZ1bmN0aW9uIG5pKGEsYixjKXtmb3IodmFyIGQ9UWEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS5CYX0pLGU9YS5MLnphKGIsZCl8fEMsZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO0soMT09PWguc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtoLnN0YXR1cz0yO2guTGYrKzt2YXIgaz1UKGIsaC5wYXRoKSxkPWQuRyhrLGgucWQpfWQ9ZC5JKCEwKTthLmJhLnB1dChiLnRvU3RyaW5nKCksZCxmdW5jdGlvbihkKXthLmYoXCJ0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2VcIix7cGF0aDpiLnRvU3RyaW5nKCksc3RhdHVzOmR9KTt2YXIgZT1bXTtpZihcIm9rXCI9PT1kKXtkPVtdO2ZvcihmPTA7ZjxjLmxlbmd0aDtmKyspe2NbZl0uc3RhdHVzPTM7ZT1lLmNvbmNhdCh6ZihhLkwsY1tmXS5CYSkpO2lmKGNbZl0uSCl7dmFyIGg9Y1tmXS5yZCxrPW5ldyBVKGEsY1tmXS5wYXRoKTtkLnB1c2gocShjW2ZdLkgsXG5udWxsLG51bGwsITAsbmV3IFEoaCxrLE4pKSl9Y1tmXS5pZSgpfWxpKGEsU2YoYS51YyxiKSk7a2koYSk7QWIoYS5kYSxiLGUpO2ZvcihmPTA7ZjxkLmxlbmd0aDtmKyspRGIoZFtmXSl9ZWxzZXtpZihcImRhdGFzdGFsZVwiPT09ZClmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0uc3RhdHVzPTQ9PT1jW2ZdLnN0YXR1cz81OjE7ZWxzZSBmb3IoTyhcInRyYW5zYWN0aW9uIGF0IFwiK2IudG9TdHJpbmcoKStcIiBmYWlsZWQ6IFwiK2QpLGY9MDtmPGMubGVuZ3RoO2YrKyljW2ZdLnN0YXR1cz01LGNbZl0ua2U9ZDtiaShhLGIpfX0sZSl9ZnVuY3Rpb24gYmkoYSxiKXt2YXIgYz1vaShhLGIpLGQ9Yy5wYXRoKCksYz1taShhLGMpO3BpKGEsYyxkKTtyZXR1cm4gZH1cbmZ1bmN0aW9uIHBpKGEsYixjKXtpZigwIT09Yi5sZW5ndGgpe2Zvcih2YXIgZD1bXSxlPVtdLGY9UWEoYixmdW5jdGlvbihhKXtyZXR1cm4gYS5CYX0pLGg9MDtoPGIubGVuZ3RoO2grKyl7dmFyIGs9YltoXSxsPVQoYyxrLnBhdGgpLG09ITEsdDtLKG51bGwhPT1sLFwicmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLlwiKTtpZig1PT09ay5zdGF0dXMpbT0hMCx0PWsua2UsZT1lLmNvbmNhdCh6ZihhLkwsay5CYSwhMCkpO2Vsc2UgaWYoMT09PWsuc3RhdHVzKWlmKDI1PD1rLkxmKW09ITAsdD1cIm1heHJldHJ5XCIsZT1lLmNvbmNhdCh6ZihhLkwsay5CYSwhMCkpO2Vsc2V7dmFyIHo9YS5MLnphKGsucGF0aCxmKXx8QztrLnBkPXo7dmFyIEk9YltoXS51cGRhdGUoei5JKCkpO24oSSk/KGNnKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLEksay5wYXRoKSxsPU0oSSksXCJvYmplY3RcIj09PXR5cGVvZiBJJiZudWxsIT1cbkkmJnYoSSxcIi5wcmlvcml0eVwiKXx8KGw9bC5nYSh6LkMoKSkpLHo9ay5CYSxJPWFpKGEpLEk9c2MobCxJKSxrLnFkPWwsay5yZD1JLGsuQmE9YS5IZCsrLFZhKGYseiksZT1lLmNvbmNhdCh3ZihhLkwsay5wYXRoLEksay5CYSxrLmNmKSksZT1lLmNvbmNhdCh6ZihhLkwseiwhMCkpKToobT0hMCx0PVwibm9kYXRhXCIsZT1lLmNvbmNhdCh6ZihhLkwsay5CYSwhMCkpKX1BYihhLmRhLGMsZSk7ZT1bXTttJiYoYltoXS5zdGF0dXM9MyxzZXRUaW1lb3V0KGJbaF0uaWUsTWF0aC5mbG9vcigwKSksYltoXS5IJiYoXCJub2RhdGFcIj09PXQ/KGs9bmV3IFUoYSxiW2hdLnBhdGgpLGQucHVzaChxKGJbaF0uSCxudWxsLG51bGwsITEsbmV3IFEoYltoXS5wZCxrLE4pKSkpOmQucHVzaChxKGJbaF0uSCxudWxsLEVycm9yKHQpLCExLG51bGwpKSkpfWxpKGEsYS51Yyk7Zm9yKGg9MDtoPGQubGVuZ3RoO2grKylEYihkW2hdKTtraShhKX19XG5mdW5jdGlvbiBvaShhLGIpe2Zvcih2YXIgYyxkPWEudWM7bnVsbCE9PShjPUUoYikpJiZudWxsPT09ZC5DYSgpOylkPVNmKGQsYyksYj1IKGIpO3JldHVybiBkfWZ1bmN0aW9uIG1pKGEsYil7dmFyIGM9W107cWkoYSxiLGMpO2Muc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLkZmLWIuRmZ9KTtyZXR1cm4gY31mdW5jdGlvbiBxaShhLGIsYyl7dmFyIGQ9Yi5DYSgpO2lmKG51bGwhPT1kKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWMucHVzaChkW2VdKTtiLlAoZnVuY3Rpb24oYil7cWkoYSxiLGMpfSl9ZnVuY3Rpb24gbGkoYSxiKXt2YXIgYz1iLkNhKCk7aWYoYyl7Zm9yKHZhciBkPTAsZT0wO2U8Yy5sZW5ndGg7ZSsrKTMhPT1jW2VdLnN0YXR1cyYmKGNbZF09Y1tlXSxkKyspO2MubGVuZ3RoPWQ7VGYoYiwwPGMubGVuZ3RoP2M6bnVsbCl9Yi5QKGZ1bmN0aW9uKGIpe2xpKGEsYil9KX1cbmZ1bmN0aW9uIGVpKGEsYil7dmFyIGM9b2koYSxiKS5wYXRoKCksZD1TZihhLnVjLGIpO1dmKGQsZnVuY3Rpb24oYil7cmkoYSxiKX0pO3JpKGEsZCk7VmYoZCxmdW5jdGlvbihiKXtyaShhLGIpfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiByaShhLGIpe3ZhciBjPWIuQ2EoKTtpZihudWxsIT09Yyl7Zm9yKHZhciBkPVtdLGU9W10sZj0tMSxoPTA7aDxjLmxlbmd0aDtoKyspNCE9PWNbaF0uc3RhdHVzJiYoMj09PWNbaF0uc3RhdHVzPyhLKGY9PT1oLTEsXCJBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLlwiKSxmPWgsY1toXS5zdGF0dXM9NCxjW2hdLmtlPVwic2V0XCIpOihLKDE9PT1jW2hdLnN0YXR1cyxcIlVuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0XCIpLGNbaF0uaWUoKSxlPWUuY29uY2F0KHpmKGEuTCxjW2hdLkJhLCEwKSksY1toXS5IJiZkLnB1c2gocShjW2hdLkgsbnVsbCxFcnJvcihcInNldFwiKSwhMSxudWxsKSkpKTstMT09PWY/VGYoYixudWxsKTpjLmxlbmd0aD1mKzE7QWIoYS5kYSxiLnBhdGgoKSxlKTtmb3IoaD0wO2g8ZC5sZW5ndGg7aCsrKURiKGRbaF0pfX07ZnVuY3Rpb24gVygpe3RoaXMub2M9e307dGhpcy5TZj0hMX1XLnByb3RvdHlwZS55Yj1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLm9jKXRoaXMub2NbYV0ueWIoKX07Vy5wcm90b3R5cGUucmM9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5vYyl0aGlzLm9jW2FdLnJjKCl9O1cucHJvdG90eXBlLnZlPWZ1bmN0aW9uKCl7dGhpcy5TZj0hMH07Y2EoVyk7Vy5wcm90b3R5cGUuaW50ZXJydXB0PVcucHJvdG90eXBlLnliO1cucHJvdG90eXBlLnJlc3VtZT1XLnByb3RvdHlwZS5yYztmdW5jdGlvbiBYKGEsYil7dGhpcy5iZD1hO3RoaXMucmE9Yn1YLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7eChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtBKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt0aGlzLmJkLkpkKHRoaXMucmEsYXx8bnVsbCl9O1gucHJvdG90eXBlLmNhbmNlbD1YLnByb3RvdHlwZS5jYW5jZWw7WC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe3goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIix0aGlzLnJhKTtBKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMSxhLCEwKTtmaSh0aGlzLmJkLHRoaXMucmEsbnVsbCxhKX07WC5wcm90b3R5cGUucmVtb3ZlPVgucHJvdG90eXBlLnJlbW92ZTtcblgucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLnJhKTtiZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsdGhpcy5yYSwhMSk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLDIsYiwhMCk7ZmkodGhpcy5iZCx0aGlzLnJhLGEsYil9O1gucHJvdG90eXBlLnNldD1YLnByb3RvdHlwZS5zZXQ7XG5YLnByb3RvdHlwZS5LYj1mdW5jdGlvbihhLGIsYyl7eChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLHRoaXMucmEpO2JnKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsYSx0aGlzLnJhLCExKTtmZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDIsYik7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDMsYywhMCk7Z2kodGhpcy5iZCx0aGlzLnJhLGEsYixjKX07WC5wcm90b3R5cGUuc2V0V2l0aFByaW9yaXR5PVgucHJvdG90eXBlLktiO1xuWC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLHRoaXMucmEpO2lmKGVhKGEpKXtmb3IodmFyIGM9e30sZD0wO2Q8YS5sZW5ndGg7KytkKWNbXCJcIitkXT1hW2RdO2E9YztPKFwiUGFzc2luZyBhbiBBcnJheSB0byBGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBpcyBkZXByZWNhdGVkLiBVc2Ugc2V0KCkgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBleGlzdGluZyBkYXRhLCBvciBhbiBPYmplY3Qgd2l0aCBpbnRlZ2VyIGtleXMgaWYgeW91IHJlYWxseSBkbyB3YW50IHRvIG9ubHkgdXBkYXRlIHNvbWUgb2YgdGhlIGNoaWxkcmVuLlwiKX1lZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLGEsdGhpcy5yYSk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDIsYiwhMCk7XG5oaSh0aGlzLmJkLHRoaXMucmEsYSxiKX07WC5wcm90b3R5cGUudXBkYXRlPVgucHJvdG90eXBlLnVwZGF0ZTtmdW5jdGlvbiBZKGEsYixjLGQpe3RoaXMuaz1hO3RoaXMucGF0aD1iO3RoaXMubj1jO3RoaXMubGM9ZH1cbmZ1bmN0aW9uIHNpKGEpe3ZhciBiPW51bGwsYz1udWxsO2EubWEmJihiPW5kKGEpKTthLnBhJiYoYz1wZChhKSk7aWYoYS5nPT09UWQpe2lmKGEubWEpe2lmKFwiW01JTl9OQU1FXVwiIT1tZChhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9aWYoYS5wYSl7aWYoXCJbTUFYX05BTUVdXCIhPW9kKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKFwic3RyaW5nXCIhPT1cbnR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fX1lbHNlIGlmKGEuZz09PU4pe2lmKG51bGwhPWImJiFhZyhiKXx8bnVsbCE9YyYmIWFnKGMpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlIChudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLlwiKTt9ZWxzZSBpZihLKGEuZyBpbnN0YW5jZW9mIFVkfHxhLmc9PT0kZCxcInVua25vd24gaW5kZXggdHlwZS5cIiksbnVsbCE9YiYmXCJvYmplY3RcIj09PXR5cGVvZiBifHxudWxsIT1jJiZcIm9iamVjdFwiPT09dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIGNhbm5vdCBiZSBhbiBvYmplY3QuXCIpO1xufWZ1bmN0aW9uIHRpKGEpe2lmKGEubWEmJmEucGEmJmEuamEmJighYS5qYXx8XCJcIj09PWEuTmIpKXRocm93IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBlbmRBdCgpLCBhbmQgbGltaXQoKS4gVXNlIGxpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7fWZ1bmN0aW9uIHVpKGEsYil7aWYoITA9PT1hLmxjKXRocm93IEVycm9yKGIrXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO31nPVkucHJvdG90eXBlO2cuSWI9ZnVuY3Rpb24oKXt4KFwiUXVlcnkucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiBuZXcgVSh0aGlzLmssdGhpcy5wYXRoKX07XG5nLkViPWZ1bmN0aW9uKGEsYixjLGQpe3goXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtnZyhcIlF1ZXJ5Lm9uXCIsYSwhMSk7QShcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT12aShcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKWlpKHRoaXMuayx0aGlzLG5ldyBpZChiLGUuY2FuY2VsfHxudWxsLGUuTWF8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtpaSh0aGlzLmssdGhpcyxuZXcgamQoZixlLmNhbmNlbCxlLk1hKSl9cmV0dXJuIGJ9O1xuZy5pYz1mdW5jdGlvbihhLGIsYyl7eChcIlF1ZXJ5Lm9mZlwiLDAsMyxhcmd1bWVudHMubGVuZ3RoKTtnZyhcIlF1ZXJ5Lm9mZlwiLGEsITApO0EoXCJRdWVyeS5vZmZcIiwyLGIsITApO21iKFwiUXVlcnkub2ZmXCIsMyxjKTt2YXIgZD1udWxsLGU9bnVsbDtcInZhbHVlXCI9PT1hP2Q9bmV3IGlkKGJ8fG51bGwsbnVsbCxjfHxudWxsKTphJiYoYiYmKGU9e30sZVthXT1iKSxkPW5ldyBqZChlLG51bGwsY3x8bnVsbCkpO2U9dGhpcy5rO2Q9XCIuaW5mb1wiPT09RSh0aGlzLnBhdGgpP2UuQ2QuamIodGhpcyxkKTplLkwuamIodGhpcyxkKTt5YihlLmRhLHRoaXMucGF0aCxkKX07XG5nLkRnPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhoKXtmJiYoZj0hMSxlLmljKGEsYyksYi5jYWxsKGQuTWEsaCkpfXgoXCJRdWVyeS5vbmNlXCIsMiw0LGFyZ3VtZW50cy5sZW5ndGgpO2dnKFwiUXVlcnkub25jZVwiLGEsITEpO0EoXCJRdWVyeS5vbmNlXCIsMixiLCExKTt2YXIgZD12aShcIlF1ZXJ5Lm9uY2VcIixhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxlPXRoaXMsZj0hMDt0aGlzLkViKGEsYyxmdW5jdGlvbihiKXtlLmljKGEsYyk7ZC5jYW5jZWwmJmQuY2FuY2VsLmNhbGwoZC5NYSxiKX0pfTtcbmcuSGU9ZnVuY3Rpb24oYSl7TyhcIlF1ZXJ5LmxpbWl0KCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBRdWVyeS5saW1pdFRvRmlyc3QoKSBvciBRdWVyeS5saW1pdFRvTGFzdCgpIGluc3RlYWQuXCIpO3goXCJRdWVyeS5saW1pdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXQ6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4uamEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsIGxpbWl0VG9GaXJzdCwgb3JsaW1pdFRvTGFzdC5cIik7dmFyIGI9dGhpcy5uLkhlKGEpO3RpKGIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGIsdGhpcy5sYyl9O1xuZy5JZT1mdW5jdGlvbihhKXt4KFwiUXVlcnkubGltaXRUb0ZpcnN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4uamEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsdGhpcy5uLkllKGEpLHRoaXMubGMpfTtcbmcuSmU9ZnVuY3Rpb24oYSl7eChcIlF1ZXJ5LmxpbWl0VG9MYXN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi5qYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5KZShhKSx0aGlzLmxjKX07XG5nLkVnPWZ1bmN0aW9uKGEpe3goXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoXCIka2V5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeUtleSgpIGluc3RlYWQuJyk7aWYoXCIkcHJpb3JpdHlcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7aWYoXCIkdmFsdWVcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkdmFsdWVcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7aWcoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIixhKTt1aSh0aGlzLFwiUXVlcnkub3JkZXJCeUNoaWxkXCIpO3ZhciBiPW5ldyBMKGEpO2lmKGIuZSgpKXRocm93IEVycm9yKFwiUXVlcnkub3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuXCIpO1xuYj1uZXcgVWQoYik7Yj1kZSh0aGlzLm4sYik7c2koYik7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYiwhMCl9O2cuRmc9ZnVuY3Rpb24oKXt4KFwiUXVlcnkub3JkZXJCeUtleVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt1aSh0aGlzLFwiUXVlcnkub3JkZXJCeUtleVwiKTt2YXIgYT1kZSh0aGlzLm4sUWQpO3NpKGEpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtnLkdnPWZ1bmN0aW9uKCl7eChcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt1aSh0aGlzLFwiUXVlcnkub3JkZXJCeVByaW9yaXR5XCIpO3ZhciBhPWRlKHRoaXMubixOKTtzaShhKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxhLCEwKX07XG5nLkhnPWZ1bmN0aW9uKCl7eChcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt1aSh0aGlzLFwiUXVlcnkub3JkZXJCeVZhbHVlXCIpO3ZhciBhPWRlKHRoaXMubiwkZCk7c2koYSk7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O2cuJGQ9ZnVuY3Rpb24oYSxiKXt4KFwiUXVlcnkuc3RhcnRBdFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtiZyhcIlF1ZXJ5LnN0YXJ0QXRcIixhLHRoaXMucGF0aCwhMCk7aGcoXCJRdWVyeS5zdGFydEF0XCIsYik7dmFyIGM9dGhpcy5uLiRkKGEsYik7dGkoYyk7c2koYyk7aWYodGhpcy5uLm1hKXRocm93IEVycm9yKFwiUXVlcnkuc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCBvciBlcXVhbFRvKS5cIik7bihhKXx8KGI9YT1udWxsKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxjLHRoaXMubGMpfTtcbmcudGQ9ZnVuY3Rpb24oYSxiKXt4KFwiUXVlcnkuZW5kQXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7YmcoXCJRdWVyeS5lbmRBdFwiLGEsdGhpcy5wYXRoLCEwKTtoZyhcIlF1ZXJ5LmVuZEF0XCIsYik7dmFyIGM9dGhpcy5uLnRkKGEsYik7dGkoYyk7c2koYyk7aWYodGhpcy5uLnBhKXRocm93IEVycm9yKFwiUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYyx0aGlzLmxjKX07XG5nLmtnPWZ1bmN0aW9uKGEsYil7eChcIlF1ZXJ5LmVxdWFsVG9cIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7YmcoXCJRdWVyeS5lcXVhbFRvXCIsYSx0aGlzLnBhdGgsITEpO2hnKFwiUXVlcnkuZXF1YWxUb1wiLGIpO2lmKHRoaXMubi5tYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtpZih0aGlzLm4ucGEpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiB0aGlzLiRkKGEsYikudGQoYSxiKX07XG5nLnRvU3RyaW5nPWZ1bmN0aW9uKCl7eChcIlF1ZXJ5LnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzLnBhdGgsYj1cIlwiLGM9YS5aO2M8YS5vLmxlbmd0aDtjKyspXCJcIiE9PWEub1tjXSYmKGIrPVwiL1wiK2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYS5vW2NdKSkpO3JldHVybiB0aGlzLmsudG9TdHJpbmcoKSsoYnx8XCIvXCIpfTtnLnZhPWZ1bmN0aW9uKCl7dmFyIGE9VWMoZWUodGhpcy5uKSk7cmV0dXJuXCJ7fVwiPT09YT9cImRlZmF1bHRcIjphfTtcbmZ1bmN0aW9uIHZpKGEsYixjKXt2YXIgZD17Y2FuY2VsOm51bGwsTWE6bnVsbH07aWYoYiYmYylkLmNhbmNlbD1iLEEoYSwzLGQuY2FuY2VsLCEwKSxkLk1hPWMsbWIoYSw0LGQuTWEpO2Vsc2UgaWYoYilpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKWQuTWE9YjtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKWQuY2FuY2VsPWI7ZWxzZSB0aHJvdyBFcnJvcih5KGEsMywhMCkrXCIgbXVzdCBlaXRoZXIgYmUgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0IG9iamVjdC5cIik7cmV0dXJuIGR9WS5wcm90b3R5cGUucmVmPVkucHJvdG90eXBlLkliO1kucHJvdG90eXBlLm9uPVkucHJvdG90eXBlLkViO1kucHJvdG90eXBlLm9mZj1ZLnByb3RvdHlwZS5pYztZLnByb3RvdHlwZS5vbmNlPVkucHJvdG90eXBlLkRnO1kucHJvdG90eXBlLmxpbWl0PVkucHJvdG90eXBlLkhlO1kucHJvdG90eXBlLmxpbWl0VG9GaXJzdD1ZLnByb3RvdHlwZS5JZTtcblkucHJvdG90eXBlLmxpbWl0VG9MYXN0PVkucHJvdG90eXBlLkplO1kucHJvdG90eXBlLm9yZGVyQnlDaGlsZD1ZLnByb3RvdHlwZS5FZztZLnByb3RvdHlwZS5vcmRlckJ5S2V5PVkucHJvdG90eXBlLkZnO1kucHJvdG90eXBlLm9yZGVyQnlQcmlvcml0eT1ZLnByb3RvdHlwZS5HZztZLnByb3RvdHlwZS5vcmRlckJ5VmFsdWU9WS5wcm90b3R5cGUuSGc7WS5wcm90b3R5cGUuc3RhcnRBdD1ZLnByb3RvdHlwZS4kZDtZLnByb3RvdHlwZS5lbmRBdD1ZLnByb3RvdHlwZS50ZDtZLnByb3RvdHlwZS5lcXVhbFRvPVkucHJvdG90eXBlLmtnO1kucHJvdG90eXBlLnRvU3RyaW5nPVkucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBaPXt9O1oudmM9S2g7Wi5EYXRhQ29ubmVjdGlvbj1aLnZjO0toLnByb3RvdHlwZS5SZz1mdW5jdGlvbihhLGIpe3RoaXMuRmEoXCJxXCIse3A6YX0sYil9O1oudmMucHJvdG90eXBlLnNpbXBsZUxpc3Rlbj1aLnZjLnByb3RvdHlwZS5SZztLaC5wcm90b3R5cGUuamc9ZnVuY3Rpb24oYSxiKXt0aGlzLkZhKFwiZWNob1wiLHtkOmF9LGIpfTtaLnZjLnByb3RvdHlwZS5lY2hvPVoudmMucHJvdG90eXBlLmpnO0toLnByb3RvdHlwZS5pbnRlcnJ1cHQ9S2gucHJvdG90eXBlLnliO1ouVmY9eWg7Wi5SZWFsVGltZUNvbm5lY3Rpb249Wi5WZjt5aC5wcm90b3R5cGUuc2VuZFJlcXVlc3Q9eWgucHJvdG90eXBlLkZhO3loLnByb3RvdHlwZS5jbG9zZT15aC5wcm90b3R5cGUuY2xvc2U7XG5aLnJnPWZ1bmN0aW9uKGEpe3ZhciBiPUtoLnByb3RvdHlwZS5wdXQ7S2gucHJvdG90eXBlLnB1dD1mdW5jdGlvbihjLGQsZSxmKXtuKGYpJiYoZj1hKCkpO2IuY2FsbCh0aGlzLGMsZCxlLGYpfTtyZXR1cm4gZnVuY3Rpb24oKXtLaC5wcm90b3R5cGUucHV0PWJ9fTtaLmhpamFja0hhc2g9Wi5yZztaLlVmPXpjO1ouQ29ubmVjdGlvblRhcmdldD1aLlVmO1oudmE9ZnVuY3Rpb24oYSl7cmV0dXJuIGEudmEoKX07Wi5xdWVyeUlkZW50aWZpZXI9Wi52YTtaLnRnPWZ1bmN0aW9uKGEpe3JldHVybiBhLmsuUmEuJH07Wi5saXN0ZW5zPVoudGc7Wi52ZT1mdW5jdGlvbihhKXthLnZlKCl9O1ouZm9yY2VSZXN0Q2xpZW50PVoudmU7ZnVuY3Rpb24gVShhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgWWgpYz1hLGQ9YjtlbHNle3goXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1QYyhhcmd1bWVudHNbMF0pO2M9ZC5UZztcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmT2MoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7YyYmXCJ1bmRlZmluZWRcIiE9Y3x8T2MoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2Qua2J8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmTyhcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgemMoZC5ob3N0LGQua2IsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBMKGQuJGMpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcChjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8ISRmKGMuaGMpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocChlKSYmMCE9PWUubGVuZ3RoJiYhWWYudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoeShcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIFcpZT1iO2Vsc2UgaWYocChiKSllPVcudWIoKSxjLk9kPWI7ZWxzZSB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIGEgdmFsaWQgRmlyZWJhc2UuQ29udGV4dCBmb3Igc2Vjb25kIGFyZ3VtZW50IHRvIG5ldyBGaXJlYmFzZSgpXCIpO1xuZWxzZSBlPVcudWIoKTtmPWMudG9TdHJpbmcoKTt2YXIgaD13KGUub2MsZik7aHx8KGg9bmV3IFloKGMsZS5TZiksZS5vY1tmXT1oKTtjPWh9WS5jYWxsKHRoaXMsYyxkLGJlLCExKX1tYShVLFkpO3ZhciB3aT1VLHhpPVtcIkZpcmViYXNlXCJdLHlpPWFhO3hpWzBdaW4geWl8fCF5aS5leGVjU2NyaXB0fHx5aS5leGVjU2NyaXB0KFwidmFyIFwiK3hpWzBdKTtmb3IodmFyIHppO3hpLmxlbmd0aCYmKHppPXhpLnNoaWZ0KCkpOykheGkubGVuZ3RoJiZuKHdpKT95aVt6aV09d2k6eWk9eWlbemldP3lpW3ppXTp5aVt6aV09e307VS5nb09mZmxpbmU9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UuZ29PZmZsaW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1cudWIoKS55YigpfTtVLmdvT25saW5lPWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLmdvT25saW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1cudWIoKS5yYygpfTtcbmZ1bmN0aW9uIExjKGEsYil7SyghYnx8ITA9PT1hfHwhMT09PWEsXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7ITA9PT1hPyhcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJihcImZ1bmN0aW9uXCI9PT10eXBlb2YgY29uc29sZS5sb2c/QmI9cShjb25zb2xlLmxvZyxjb25zb2xlKTpcIm9iamVjdFwiPT09dHlwZW9mIGNvbnNvbGUubG9nJiYoQmI9ZnVuY3Rpb24oYSl7Y29uc29sZS5sb2coYSl9KSksYiYmeWMuc2V0KFwibG9nZ2luZ19lbmFibGVkXCIsITApKTphP0JiPWE6KEJiPW51bGwseWMucmVtb3ZlKFwibG9nZ2luZ19lbmFibGVkXCIpKX1VLmVuYWJsZUxvZ2dpbmc9TGM7VS5TZXJ2ZXJWYWx1ZT17VElNRVNUQU1QOntcIi5zdlwiOlwidGltZXN0YW1wXCJ9fTtVLlNES19WRVJTSU9OPWhiO1UuSU5URVJOQUw9VjtVLkNvbnRleHQ9VztVLlRFU1RfQUNDRVNTPVo7XG5VLnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7TyhcIkZpcmViYXNlLm5hbWUoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlLmtleSgpIGluc3RlYWQuXCIpO3goXCJGaXJlYmFzZS5uYW1lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmtleSgpfTtVLnByb3RvdHlwZS5uYW1lPVUucHJvdG90eXBlLm5hbWU7VS5wcm90b3R5cGUua2V5PWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLmtleVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5wYXRoLmUoKT9udWxsOkxkKHRoaXMucGF0aCl9O1UucHJvdG90eXBlLmtleT1VLnByb3RvdHlwZS5rZXk7XG5VLnByb3RvdHlwZS51PWZ1bmN0aW9uKGEpe3goXCJGaXJlYmFzZS5jaGlsZFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZihnYShhKSlhPVN0cmluZyhhKTtlbHNlIGlmKCEoYSBpbnN0YW5jZW9mIEwpKWlmKG51bGw9PT1FKHRoaXMucGF0aCkpe3ZhciBiPWE7YiYmKGI9Yi5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLyxcIi9cIikpO2lnKFwiRmlyZWJhc2UuY2hpbGRcIixiKX1lbHNlIGlnKFwiRmlyZWJhc2UuY2hpbGRcIixhKTtyZXR1cm4gbmV3IFUodGhpcy5rLHRoaXMucGF0aC51KGEpKX07VS5wcm90b3R5cGUuY2hpbGQ9VS5wcm90b3R5cGUudTtVLnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oKXt4KFwiRmlyZWJhc2UucGFyZW50XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhPXRoaXMucGF0aC5wYXJlbnQoKTtyZXR1cm4gbnVsbD09PWE/bnVsbDpuZXcgVSh0aGlzLmssYSl9O1UucHJvdG90eXBlLnBhcmVudD1VLnByb3RvdHlwZS5wYXJlbnQ7XG5VLnByb3RvdHlwZS5yb290PWZ1bmN0aW9uKCl7eChcIkZpcmViYXNlLnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGE9dGhpcztudWxsIT09YS5wYXJlbnQoKTspYT1hLnBhcmVudCgpO3JldHVybiBhfTtVLnByb3RvdHlwZS5yb290PVUucHJvdG90eXBlLnJvb3Q7VS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnNldFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtqZyhcIkZpcmViYXNlLnNldFwiLHRoaXMucGF0aCk7YmcoXCJGaXJlYmFzZS5zZXRcIixhLHRoaXMucGF0aCwhMSk7QShcIkZpcmViYXNlLnNldFwiLDIsYiwhMCk7dGhpcy5rLktiKHRoaXMucGF0aCxhLG51bGwsYnx8bnVsbCl9O1UucHJvdG90eXBlLnNldD1VLnByb3RvdHlwZS5zZXQ7XG5VLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2UudXBkYXRlXCIsdGhpcy5wYXRoKTtpZihlYShhKSl7Zm9yKHZhciBjPXt9LGQ9MDtkPGEubGVuZ3RoOysrZCljW1wiXCIrZF09YVtkXTthPWM7TyhcIlBhc3NpbmcgYW4gQXJyYXkgdG8gRmlyZWJhc2UudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byBvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi5cIil9ZWcoXCJGaXJlYmFzZS51cGRhdGVcIixhLHRoaXMucGF0aCk7QShcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7dGhpcy5rLnVwZGF0ZSh0aGlzLnBhdGgsYSxifHxudWxsKX07VS5wcm90b3R5cGUudXBkYXRlPVUucHJvdG90eXBlLnVwZGF0ZTtcblUucHJvdG90eXBlLktiPWZ1bmN0aW9uKGEsYixjKXt4KFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsdGhpcy5wYXRoKTtiZyhcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLGEsdGhpcy5wYXRoLCExKTtmZyhcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDIsYik7QShcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDMsYywhMCk7aWYoXCIubGVuZ3RoXCI9PT10aGlzLmtleSgpfHxcIi5rZXlzXCI9PT10aGlzLmtleSgpKXRocm93XCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHkgZmFpbGVkOiBcIit0aGlzLmtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjt0aGlzLmsuS2IodGhpcy5wYXRoLGEsYixjfHxudWxsKX07VS5wcm90b3R5cGUuc2V0V2l0aFByaW9yaXR5PVUucHJvdG90eXBlLktiO1xuVS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe3goXCJGaXJlYmFzZS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5yZW1vdmVcIix0aGlzLnBhdGgpO0EoXCJGaXJlYmFzZS5yZW1vdmVcIiwxLGEsITApO3RoaXMuc2V0KG51bGwsYSl9O1UucHJvdG90eXBlLnJlbW92ZT1VLnByb3RvdHlwZS5yZW1vdmU7XG5VLnByb3RvdHlwZS50cmFuc2FjdGlvbj1mdW5jdGlvbihhLGIsYyl7eChcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIix0aGlzLnBhdGgpO0EoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsYSwhMSk7QShcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMixiLCEwKTtpZihuKGMpJiZcImJvb2xlYW5cIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoeShcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMywhMCkrXCJtdXN0IGJlIGEgYm9vbGVhbi5cIik7aWYoXCIubGVuZ3RoXCI9PT10aGlzLmtleSgpfHxcIi5rZXlzXCI9PT10aGlzLmtleSgpKXRocm93XCJGaXJlYmFzZS50cmFuc2FjdGlvbiBmYWlsZWQ6IFwiK3RoaXMua2V5KCkrXCIgaXMgYSByZWFkLW9ubHkgb2JqZWN0LlwiO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9ITApO2ppKHRoaXMuayx0aGlzLnBhdGgsYSxifHxudWxsLGMpfTtVLnByb3RvdHlwZS50cmFuc2FjdGlvbj1VLnByb3RvdHlwZS50cmFuc2FjdGlvbjtcblUucHJvdG90eXBlLk9nPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2pnKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIix0aGlzLnBhdGgpO2ZnKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwxLGEpO0EoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDIsYiwhMCk7dGhpcy5rLktiKHRoaXMucGF0aC51KFwiLnByaW9yaXR5XCIpLGEsbnVsbCxiKX07VS5wcm90b3R5cGUuc2V0UHJpb3JpdHk9VS5wcm90b3R5cGUuT2c7XG5VLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnB1c2hcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7amcoXCJGaXJlYmFzZS5wdXNoXCIsdGhpcy5wYXRoKTtiZyhcIkZpcmViYXNlLnB1c2hcIixhLHRoaXMucGF0aCwhMCk7QShcIkZpcmViYXNlLnB1c2hcIiwyLGIsITApO3ZhciBjPSRoKHRoaXMuayksYz1GZShjKSxjPXRoaXMudShjKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEmJm51bGwhPT1hJiZjLnNldChhLGIpO3JldHVybiBjfTtVLnByb3RvdHlwZS5wdXNoPVUucHJvdG90eXBlLnB1c2g7VS5wcm90b3R5cGUuaGI9ZnVuY3Rpb24oKXtqZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdFwiLHRoaXMucGF0aCk7cmV0dXJuIG5ldyBYKHRoaXMuayx0aGlzLnBhdGgpfTtVLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3Q9VS5wcm90b3R5cGUuaGI7XG5VLnByb3RvdHlwZS5NPWZ1bmN0aW9uKGEsYixjKXtPKFwiRmlyZWJhc2VSZWYuYXV0aCgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2VSZWYuYXV0aFdpdGhDdXN0b21Ub2tlbigpIGluc3RlYWQuXCIpO3goXCJGaXJlYmFzZS5hdXRoXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpO2tnKFwiRmlyZWJhc2UuYXV0aFwiLGEpO0EoXCJGaXJlYmFzZS5hdXRoXCIsMixiLCEwKTtBKFwiRmlyZWJhc2UuYXV0aFwiLDMsYiwhMCk7WWcodGhpcy5rLk0sYSx7fSx7cmVtZW1iZXI6XCJub25lXCJ9LGIsYyl9O1UucHJvdG90eXBlLmF1dGg9VS5wcm90b3R5cGUuTTtVLnByb3RvdHlwZS5nZT1mdW5jdGlvbihhKXt4KFwiRmlyZWJhc2UudW5hdXRoXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO0EoXCJGaXJlYmFzZS51bmF1dGhcIiwxLGEsITApO1pnKHRoaXMuay5NLGEpfTtVLnByb3RvdHlwZS51bmF1dGg9VS5wcm90b3R5cGUuZ2U7XG5VLnByb3RvdHlwZS54ZT1mdW5jdGlvbigpe3goXCJGaXJlYmFzZS5nZXRBdXRoXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmsuTS54ZSgpfTtVLnByb3RvdHlwZS5nZXRBdXRoPVUucHJvdG90eXBlLnhlO1UucHJvdG90eXBlLnhnPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLm9uQXV0aFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtBKFwiRmlyZWJhc2Uub25BdXRoXCIsMSxhLCExKTttYihcIkZpcmViYXNlLm9uQXV0aFwiLDIsYik7dGhpcy5rLk0uRWIoXCJhdXRoX3N0YXR1c1wiLGEsYil9O1UucHJvdG90eXBlLm9uQXV0aD1VLnByb3RvdHlwZS54ZztVLnByb3RvdHlwZS53Zz1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0EoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSxhLCExKTttYihcIkZpcmViYXNlLm9mZkF1dGhcIiwyLGIpO3RoaXMuay5NLmljKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtVLnByb3RvdHlwZS5vZmZBdXRoPVUucHJvdG90eXBlLndnO1xuVS5wcm90b3R5cGUuWmY9ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO2tnKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLGEpO0EoXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMixiLCExKTtuZyhcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwzLGMsITApO1lnKHRoaXMuay5NLGEse30sY3x8e30sYil9O1UucHJvdG90eXBlLmF1dGhXaXRoQ3VzdG9tVG9rZW49VS5wcm90b3R5cGUuWmY7VS5wcm90b3R5cGUuJGY9ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7bWcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIixhKTtBKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFBvcHVwXCIsMixiLCExKTtuZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDMsYywhMCk7Y2godGhpcy5rLk0sYSxjLGIpfTtcblUucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhQb3B1cD1VLnByb3RvdHlwZS4kZjtVLnByb3RvdHlwZS5hZz1mdW5jdGlvbihhLGIsYyl7eChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTttZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLGEpO0EoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLGIsITEpO25nKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFJlZGlyZWN0XCIsMyxjLCEwKTt2YXIgZD10aGlzLmsuTTthaChkKTt2YXIgZT1bS2ddLGY9dmcoYyk7XCJhbm9ueW1vdXNcIj09PWF8fFwiZmlyZWJhc2VcIj09PWE/UChiLE1nKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKTooeWMuc2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIixmLm9kKSxiaChkLGUsXCIvYXV0aC9cIithLGYsYikpfTtVLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3Q9VS5wcm90b3R5cGUuYWc7XG5VLnByb3RvdHlwZS5iZz1mdW5jdGlvbihhLGIsYyxkKXt4KFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMyw0LGFyZ3VtZW50cy5sZW5ndGgpO21nKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsYSk7QShcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDMsYywhMSk7bmcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiw0LGQsITApO3AoYik/KGxnKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMixiKSwkZyh0aGlzLmsuTSxhK1wiL3Rva2VuXCIse2FjY2Vzc190b2tlbjpifSxkLGMpKToobmcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwyLGIsITEpLCRnKHRoaXMuay5NLGErXCIvdG9rZW5cIixiLGQsYykpfTtVLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoVG9rZW49VS5wcm90b3R5cGUuYmc7XG5VLnByb3RvdHlwZS5ZZj1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7QShcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsYSwhMSk7bmcoXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwyLGIsITApOyRnKHRoaXMuay5NLFwiYW5vbnltb3VzXCIse30sYixhKX07VS5wcm90b3R5cGUuYXV0aEFub255bW91c2x5PVUucHJvdG90eXBlLllmO1xuVS5wcm90b3R5cGUuY2c9ZnVuY3Rpb24oYSxiLGMpe3goXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO25nKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDEsYSwhMSk7b2coXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO29nKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLGEsXCJwYXNzd29yZFwiKTtBKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDIsYiwhMSk7bmcoXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsMyxjLCEwKTskZyh0aGlzLmsuTSxcInBhc3N3b3JkXCIsYSxjLGIpfTtVLnByb3RvdHlwZS5hdXRoV2l0aFBhc3N3b3JkPVUucHJvdG90eXBlLmNnO1xuVS5wcm90b3R5cGUuc2U9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLDIsMixhcmd1bWVudHMubGVuZ3RoKTtuZyhcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwxLGEsITEpO29nKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLGEsXCJlbWFpbFwiKTtvZyhcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIixhLFwicGFzc3dvcmRcIik7QShcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwyLGIsITEpO3RoaXMuay5NLnNlKGEsYil9O1UucHJvdG90eXBlLmNyZWF0ZVVzZXI9VS5wcm90b3R5cGUuc2U7VS5wcm90b3R5cGUuVGU9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLDIsMixhcmd1bWVudHMubGVuZ3RoKTtuZyhcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwxLGEsITEpO29nKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLGEsXCJlbWFpbFwiKTtvZyhcIkZpcmViYXNlLnJlbW92ZVVzZXJcIixhLFwicGFzc3dvcmRcIik7QShcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwyLGIsITEpO3RoaXMuay5NLlRlKGEsYil9O1xuVS5wcm90b3R5cGUucmVtb3ZlVXNlcj1VLnByb3RvdHlwZS5UZTtVLnByb3RvdHlwZS5wZT1mdW5jdGlvbihhLGIpe3goXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLDIsMixhcmd1bWVudHMubGVuZ3RoKTtuZyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMSxhLCExKTtvZyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO29nKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwib2xkUGFzc3dvcmRcIik7b2coXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJuZXdQYXNzd29yZFwiKTtBKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5NLnBlKGEsYil9O1UucHJvdG90eXBlLmNoYW5nZVBhc3N3b3JkPVUucHJvdG90eXBlLnBlO1xuVS5wcm90b3R5cGUub2U9ZnVuY3Rpb24oYSxiKXt4KFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLDEsYSwhMSk7b2coXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJvbGRFbWFpbFwiKTtvZyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm5ld0VtYWlsXCIpO29nKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwicGFzc3dvcmRcIik7QShcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMixiLCExKTt0aGlzLmsuTS5vZShhLGIpfTtVLnByb3RvdHlwZS5jaGFuZ2VFbWFpbD1VLnByb3RvdHlwZS5vZTtcblUucHJvdG90eXBlLlZlPWZ1bmN0aW9uKGEsYil7eChcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMSxhLCExKTtvZyhcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIixhLFwiZW1haWxcIik7QShcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5NLlZlKGEsYil9O1UucHJvdG90eXBlLnJlc2V0UGFzc3dvcmQ9VS5wcm90b3R5cGUuVmU7fSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaXJlYmFzZTtcbiJdfQ==
